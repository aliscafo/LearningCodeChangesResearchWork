733
#method_before
public void start() {
    if (started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            mLog.i("tethering offload config not supported");
            return;
        }
    }
    mControlInitialized = mHwInterface.initOffloadControl(new OffloadHardwareInterface.ControlCallback() {

        @Override
        public void onOffloadEvent(int event) {
            mLog.log("got offload event: " + event);
        }

        @Override
        public void onNatTimeoutUpdate(int proto, String srcAddr, int srcPort, String dstAddr, int dstPort) {
            mLog.log(String.format("NAT timeout update: %s (%s,%s) -> (%s,%s)", proto, srcAddr, srcPort, dstAddr, dstPort));
        }
    });
    if (!mControlInitialized) {
        mLog.i("tethering offload control not supported");
        stop();
    }
}
#method_after
public void start() {
    if (started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            mLog.i("tethering offload config not supported");
            stop();
            return;
        }
    }
    mControlInitialized = mHwInterface.initOffloadControl(new OffloadHardwareInterface.ControlCallback() {

        @Override
        public void onOffloadEvent(int event) {
            mLog.log("got offload event: " + event);
        }

        @Override
        public void onNatTimeoutUpdate(int proto, String srcAddr, int srcPort, String dstAddr, int dstPort) {
            mLog.log(String.format("NAT timeout update: %s (%s,%s) -> (%s,%s)", proto, srcAddr, srcPort, dstAddr, dstPort));
        }
    });
    if (!mControlInitialized) {
        mLog.i("tethering offload control not supported");
        stop();
    }
}
#end_block

#method_before
public boolean initOffloadControl(ControlCallback controlCb) {
    mControlCallback = controlCb;
    if (mOffloadControl == null) {
        try {
            mOffloadControl = IOffloadControl.getService();
        } catch (RemoteException e) {
            mLog.e("tethering offload control not supported: " + e);
            return false;
        }
    }
    mTetheringOffloadCallback = new TetheringOffloadCallback(mHandler, mControlCallback);
    final CbResults results = new CbResults();
    try {
        mOffloadControl.initOffload(mTetheringOffloadCallback, (boolean success, String errMsg) -> {
            if (!success)
                mLog.e("initOffload failed: " + errMsg);
            results.rval = success;
        });
    } catch (RemoteException e) {
        mLog.e("failed to initOffload: " + e);
        return false;
    }
    return results.rval;
}
#method_after
public boolean initOffloadControl(ControlCallback controlCb) {
    mControlCallback = controlCb;
    if (mOffloadControl == null) {
        try {
            mOffloadControl = IOffloadControl.getService();
        } catch (RemoteException e) {
            mLog.e("tethering offload control not supported: " + e);
            return false;
        }
    }
    mTetheringOffloadCallback = new TetheringOffloadCallback(mHandler, mControlCallback);
    final CbResults results = new CbResults();
    try {
        mOffloadControl.initOffload(mTetheringOffloadCallback, (boolean success, String errMsg) -> {
            results.success = success;
            results.errMsg = errMsg;
        });
    } catch (RemoteException e) {
        mLog.e("failed to initOffload: " + e);
        return false;
    }
    if (!results.success)
        mLog.e("initOffload failed: " + results.errMsg);
    return results.success;
}
#end_block

#method_before
public static void applyInvokeWithSystemProperty(Arguments args) {
    if (args.invokeWith == null && args.niceName != null) {
        String property = "wrap." + args.niceName;
        args.invokeWith = SystemProperties.get(property);
        if (args.invokeWith != null && args.invokeWith.length() == 0) {
            args.invokeWith = null;
            // Try old length to be compatible with older tools.
            if (property.length() > 31) {
                // Properties with a trailing "." are illegal.
                if (property.charAt(30) != '.') {
                    property = property.substring(0, 31);
                } else {
                    property = property.substring(0, 30);
                }
            }
            args.invokeWith = SystemProperties.get(property);
            if (args.invokeWith != null && args.invokeWith.length() == 0) {
                args.invokeWith = null;
            }
        }
    }
}
#method_after
public static void applyInvokeWithSystemProperty(Arguments args) {
    if (args.invokeWith == null && args.niceName != null) {
        String property = "wrap." + args.niceName;
        args.invokeWith = SystemProperties.get(property);
        if (args.invokeWith != null && args.invokeWith.length() == 0) {
            args.invokeWith = null;
        }
    }
}
#end_block

#method_before
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_descriptor;
}
#method_after
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_descriptor;
}
#end_block

#method_before
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.class, com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.Builder.class);
}
#method_after
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.class, com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.Builder.class);
}
#end_block

#method_before
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getPartnerReportFieldBuilder();
    }
}
#method_after
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}
#end_block

#method_before
public Builder clear() {
    super.clear();
    testPlanExecutionId_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    testModuleName_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000004);
    testPlanName_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    if (partnerReportBuilder_ == null) {
        partnerReport_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
    } else {
        partnerReportBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clear() {
    super.clear();
    productType_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    productVariant_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    buildFlavor_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    buildId_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    branch_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000010);
    buildAlias_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000020);
    apiLevel_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000040);
    abiName_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000080);
    abiBitness_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000100);
    serial_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000200);
    return this;
}
#end_block

#method_before
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_descriptor;
}
#method_after
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidDeviceInfoMessage_descriptor;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.getDefaultInstance();
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage.getDefaultInstance();
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage build() {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage build() {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage result = new com.android.vts.proto.VtsReportMessage.TestPlanReportMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.testPlanExecutionId_ = testPlanExecutionId_;
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        testModuleName_ = java.util.Collections.unmodifiableList(testModuleName_);
        bitField0_ = (bitField0_ & ~0x00000002);
    }
    result.testModuleName_ = testModuleName_;
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        testModuleStartTimestamp_ = java.util.Collections.unmodifiableList(testModuleStartTimestamp_);
        bitField0_ = (bitField0_ & ~0x00000004);
    }
    result.testModuleStartTimestamp_ = testModuleStartTimestamp_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000002;
    }
    result.testPlanName_ = testPlanName_;
    if (partnerReportBuilder_ == null) {
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
            partnerReport_ = java.util.Collections.unmodifiableList(partnerReport_);
            bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.partnerReport_ = partnerReport_;
    } else {
        result.partnerReport_ = partnerReportBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage result = new com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.productType_ = productType_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.productVariant_ = productVariant_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.buildFlavor_ = buildFlavor_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.buildId_ = buildId_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
        to_bitField0_ |= 0x00000020;
    }
    result.buildAlias_ = buildAlias_;
    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
        to_bitField0_ |= 0x00000040;
    }
    result.apiLevel_ = apiLevel_;
    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
        to_bitField0_ |= 0x00000080;
    }
    result.abiName_ = abiName_;
    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
        to_bitField0_ |= 0x00000100;
    }
    result.abiBitness_ = abiBitness_;
    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
        to_bitField0_ |= 0x00000200;
    }
    result.serial_ = serial_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.TestPlanReportMessage) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.TestPlanReportMessage) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#method_after
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.TestPlanReportMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#method_after
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.AndroidDeviceInfoMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#end_block

#method_before
public boolean hasBranch() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#method_after
public boolean hasBranch() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}
#end_block

#method_before
public Builder setBranch(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000008;
    branch_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setBranch(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000010;
    branch_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearBranch() {
    bitField0_ = (bitField0_ & ~0x00000008);
    branch_ = getDefaultInstance().getBranch();
    onChanged();
    return this;
}
#method_after
public Builder clearBranch() {
    bitField0_ = (bitField0_ & ~0x00000010);
    branch_ = getDefaultInstance().getBranch();
    onChanged();
    return this;
}
#end_block

#method_before
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_descriptor;
}
#method_after
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_descriptor;
}
#end_block

#method_before
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.class, com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.Builder.class);
}
#method_after
protected com.google.protobuf.GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_fieldAccessorTable.ensureFieldAccessorsInitialized(com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.class, com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.Builder.class);
}
#end_block

#method_before
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
        getPartnerReportFieldBuilder();
    }
}
#method_after
private void maybeForceBuilderInitialization() {
    if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
    }
}
#end_block

#method_before
public Builder clear() {
    super.clear();
    testPlanExecutionId_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    testModuleName_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000004);
    testPlanName_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    if (partnerReportBuilder_ == null) {
        partnerReport_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
    } else {
        partnerReportBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clear() {
    super.clear();
    id_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000001);
    name_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000002);
    buildType_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000004);
    branch_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000008);
    buildSummary_ = com.google.protobuf.ByteString.EMPTY;
    bitField0_ = (bitField0_ & ~0x00000010);
    return this;
}
#end_block

#method_before
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_TestPlanReportMessage_descriptor;
}
#method_after
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() {
    return com.android.vts.proto.VtsReportMessage.internal_static_android_vts_AndroidBuildInfo_descriptor;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.getDefaultInstance();
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo getDefaultInstanceForType() {
    return com.android.vts.proto.VtsReportMessage.AndroidBuildInfo.getDefaultInstance();
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage build() {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo build() {
    com.android.vts.proto.VtsReportMessage.AndroidBuildInfo result = buildPartial();
    if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
    }
    return result;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.TestPlanReportMessage buildPartial() {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage result = new com.android.vts.proto.VtsReportMessage.TestPlanReportMessage(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.testPlanExecutionId_ = testPlanExecutionId_;
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        testModuleName_ = java.util.Collections.unmodifiableList(testModuleName_);
        bitField0_ = (bitField0_ & ~0x00000002);
    }
    result.testModuleName_ = testModuleName_;
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
        testModuleStartTimestamp_ = java.util.Collections.unmodifiableList(testModuleStartTimestamp_);
        bitField0_ = (bitField0_ & ~0x00000004);
    }
    result.testModuleStartTimestamp_ = testModuleStartTimestamp_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000002;
    }
    result.testPlanName_ = testPlanName_;
    if (partnerReportBuilder_ == null) {
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
            partnerReport_ = java.util.Collections.unmodifiableList(partnerReport_);
            bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.partnerReport_ = partnerReport_;
    } else {
        result.partnerReport_ = partnerReportBuilder_.build();
    }
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#method_after
public com.android.vts.proto.VtsReportMessage.AndroidBuildInfo buildPartial() {
    com.android.vts.proto.VtsReportMessage.AndroidBuildInfo result = new com.android.vts.proto.VtsReportMessage.AndroidBuildInfo(this);
    int from_bitField0_ = bitField0_;
    int to_bitField0_ = 0;
    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
        to_bitField0_ |= 0x00000001;
    }
    result.id_ = id_;
    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
        to_bitField0_ |= 0x00000002;
    }
    result.name_ = name_;
    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
        to_bitField0_ |= 0x00000004;
    }
    result.buildType_ = buildType_;
    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
        to_bitField0_ |= 0x00000008;
    }
    result.branch_ = branch_;
    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
        to_bitField0_ |= 0x00000010;
    }
    result.buildSummary_ = buildSummary_;
    result.bitField0_ = to_bitField0_;
    onBuilt();
    return result;
}
#end_block

#method_before
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
    com.android.vts.proto.VtsReportMessage.TestPlanReportMessage parsedMessage = null;
    try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.android.vts.proto.VtsReportMessage.TestPlanReportMessage) e.getUnfinishedMessage();
        throw e;
    } finally {
        if (parsedMessage != null) {
            mergeFrom(parsedMessage);
        }
    }
    return this;
}
#method_after
public Builder mergeFrom(com.google.protobuf.Message other) {
    if (other instanceof com.android.vts.proto.VtsReportMessage.AndroidBuildInfo) {
        return mergeFrom((com.android.vts.proto.VtsReportMessage.AndroidBuildInfo) other);
    } else {
        super.mergeFrom(other);
        return this;
    }
}
#end_block

#method_before
public boolean hasName() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}
#method_after
public boolean hasName() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}
#end_block

#method_before
public Builder setName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000002;
    name_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000001;
    name_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearName() {
    bitField0_ = (bitField0_ & ~0x00000002);
    name_ = getDefaultInstance().getName();
    onChanged();
    return this;
}
#method_after
public Builder clearName() {
    bitField0_ = (bitField0_ & ~0x00000001);
    name_ = getDefaultInstance().getName();
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
}
#method_after
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}
#end_block

#method_before
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000400;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000004;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000400);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000004);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}
#method_after
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#end_block

#method_before
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000800;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000008;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000800);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000008);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
private void ensureCoverageIsMutable() {
    if (!((bitField0_ & 0x00001000) == 0x00001000)) {
        coverage_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.CoverageReportMessage>(coverage_);
        bitField0_ |= 0x00001000;
    }
}
#method_after
private void ensureCoverageIsMutable() {
    if (!((bitField0_ & 0x00000010) == 0x00000010)) {
        coverage_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.CoverageReportMessage>(coverage_);
        bitField0_ |= 0x00000010;
    }
}
#end_block

#method_before
public Builder clearCoverage() {
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearCoverage() {
    if (coverageBuilder_ == null) {
        coverage_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
    } else {
        coverageBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder> getCoverageFieldBuilder() {
    if (coverageBuilder_ == null) {
        coverageBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder>(coverage_, ((bitField0_ & 0x00001000) == 0x00001000), getParentForChildren(), isClean());
        coverage_ = null;
    }
    return coverageBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder> getCoverageFieldBuilder() {
    if (coverageBuilder_ == null) {
        coverageBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.CoverageReportMessage, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder, com.android.vts.proto.VtsReportMessage.CoverageReportMessageOrBuilder>(coverage_, ((bitField0_ & 0x00000010) == 0x00000010), getParentForChildren(), isClean());
        coverage_ = null;
    }
    return coverageBuilder_;
}
#end_block

#method_before
private void ensureProfilingIsMutable() {
    if (!((bitField0_ & 0x00000100) == 0x00000100)) {
        profiling_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage>(profiling_);
        bitField0_ |= 0x00000100;
    }
}
#method_after
private void ensureProfilingIsMutable() {
    if (!((bitField0_ & 0x00000020) == 0x00000020)) {
        profiling_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage>(profiling_);
        bitField0_ |= 0x00000020;
    }
}
#end_block

#method_before
public Builder clearProfiling() {
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
    } else {
        profilingBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearProfiling() {
    if (profilingBuilder_ == null) {
        profiling_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
    } else {
        profilingBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder> getProfilingFieldBuilder() {
    if (profilingBuilder_ == null) {
        profilingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder>(profiling_, ((bitField0_ & 0x00000100) == 0x00000100), getParentForChildren(), isClean());
        profiling_ = null;
    }
    return profilingBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder> getProfilingFieldBuilder() {
    if (profilingBuilder_ == null) {
        profilingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.ProfilingReportMessage, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder, com.android.vts.proto.VtsReportMessage.ProfilingReportMessageOrBuilder>(profiling_, ((bitField0_ & 0x00000020) == 0x00000020), getParentForChildren(), isClean());
        profiling_ = null;
    }
    return profilingBuilder_;
}
#end_block

#method_before
private void ensureSystraceIsMutable() {
    if (!((bitField0_ & 0x00000200) == 0x00000200)) {
        systrace_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.SystraceReportMessage>(systrace_);
        bitField0_ |= 0x00000200;
    }
}
#method_after
private void ensureSystraceIsMutable() {
    if (!((bitField0_ & 0x00000040) == 0x00000040)) {
        systrace_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.SystraceReportMessage>(systrace_);
        bitField0_ |= 0x00000040;
    }
}
#end_block

#method_before
public Builder clearSystrace() {
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
    } else {
        systraceBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearSystrace() {
    if (systraceBuilder_ == null) {
        systrace_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
    } else {
        systraceBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder> getSystraceFieldBuilder() {
    if (systraceBuilder_ == null) {
        systraceBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder>(systrace_, ((bitField0_ & 0x00000200) == 0x00000200), getParentForChildren(), isClean());
        systrace_ = null;
    }
    return systraceBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder> getSystraceFieldBuilder() {
    if (systraceBuilder_ == null) {
        systraceBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.SystraceReportMessage, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder, com.android.vts.proto.VtsReportMessage.SystraceReportMessageOrBuilder>(systrace_, ((bitField0_ & 0x00000040) == 0x00000040), getParentForChildren(), isClean());
        systrace_ = null;
    }
    return systraceBuilder_;
}
#end_block

#method_before
private void ensureLogIsMutable() {
    if (!((bitField0_ & 0x00002000) == 0x00002000)) {
        log_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.LogMessage>(log_);
        bitField0_ |= 0x00002000;
    }
}
#method_after
private void ensureLogIsMutable() {
    if (!((bitField0_ & 0x00000080) == 0x00000080)) {
        log_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.LogMessage>(log_);
        bitField0_ |= 0x00000080;
    }
}
#end_block

#method_before
public Builder clearLog() {
    if (logBuilder_ == null) {
        log_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
    } else {
        logBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearLog() {
    if (logBuilder_ == null) {
        log_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
    } else {
        logBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.LogMessage, com.android.vts.proto.VtsReportMessage.LogMessage.Builder, com.android.vts.proto.VtsReportMessage.LogMessageOrBuilder> getLogFieldBuilder() {
    if (logBuilder_ == null) {
        logBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.LogMessage, com.android.vts.proto.VtsReportMessage.LogMessage.Builder, com.android.vts.proto.VtsReportMessage.LogMessageOrBuilder>(log_, ((bitField0_ & 0x00002000) == 0x00002000), getParentForChildren(), isClean());
        log_ = null;
    }
    return logBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.LogMessage, com.android.vts.proto.VtsReportMessage.LogMessage.Builder, com.android.vts.proto.VtsReportMessage.LogMessageOrBuilder> getLogFieldBuilder() {
    if (logBuilder_ == null) {
        logBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.LogMessage, com.android.vts.proto.VtsReportMessage.LogMessage.Builder, com.android.vts.proto.VtsReportMessage.LogMessageOrBuilder>(log_, ((bitField0_ & 0x00000080) == 0x00000080), getParentForChildren(), isClean());
        log_ = null;
    }
    return logBuilder_;
}
#end_block

#method_before
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
}
#method_after
public boolean hasStartTimestamp() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#end_block

#method_before
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000400;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setStartTimestamp(long value) {
    bitField0_ |= 0x00000008;
    startTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000400);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearStartTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000008);
    startTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
}
#method_after
public boolean hasEndTimestamp() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
}
#end_block

#method_before
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000800;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setEndTimestamp(long value) {
    bitField0_ |= 0x00000010;
    endTimestamp_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000800);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#method_after
public Builder clearEndTimestamp() {
    bitField0_ = (bitField0_ & ~0x00000010);
    endTimestamp_ = 0L;
    onChanged();
    return this;
}
#end_block

#method_before
@java.lang.Deprecated
public Builder clearHtml() {
    bitField0_ = (bitField0_ & ~0x00000100);
    html_ = getDefaultInstance().getHtml();
    onChanged();
    return this;
}
#method_after
public Builder clearHtml() {
    html_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearUrl() {
    bitField0_ = (bitField0_ & ~0x00000001);
    url_ = getDefaultInstance().getUrl();
    onChanged();
    return this;
}
#method_after
public Builder clearUrl() {
    url_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000004);
    onChanged();
    return this;
}
#end_block

#method_before
public Builder setProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder builderForValue) {
    if (profilingBuilder_ == null) {
        ensureProfilingIsMutable();
        profiling_.set(index, builderForValue.build());
        onChanged();
    } else {
        profilingBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage value) {
    if (profilingBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureProfilingIsMutable();
        profiling_.set(index, value);
        onChanged();
    } else {
        profilingBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addProfiling(int index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder builderForValue) {
    if (profilingBuilder_ == null) {
        ensureProfilingIsMutable();
        profiling_.add(index, builderForValue.build());
        onChanged();
    } else {
        profilingBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addProfiling(com.android.vts.proto.VtsReportMessage.ProfilingReportMessage value) {
    if (profilingBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureProfilingIsMutable();
        profiling_.add(value);
        onChanged();
    } else {
        profilingBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder addProfilingBuilder(int index) {
    return getProfilingFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.Builder addProfilingBuilder() {
    return getProfilingFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.ProfilingReportMessage.getDefaultInstance());
}
#end_block

#method_before
public Builder setSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder builderForValue) {
    if (systraceBuilder_ == null) {
        ensureSystraceIsMutable();
        systrace_.set(index, builderForValue.build());
        onChanged();
    } else {
        systraceBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage value) {
    if (systraceBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureSystraceIsMutable();
        systrace_.set(index, value);
        onChanged();
    } else {
        systraceBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addSystrace(int index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder builderForValue) {
    if (systraceBuilder_ == null) {
        ensureSystraceIsMutable();
        systrace_.add(index, builderForValue.build());
        onChanged();
    } else {
        systraceBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addSystrace(com.android.vts.proto.VtsReportMessage.SystraceReportMessage value) {
    if (systraceBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureSystraceIsMutable();
        systrace_.add(value);
        onChanged();
    } else {
        systraceBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder addSystraceBuilder(int index) {
    return getSystraceFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.SystraceReportMessage.Builder addSystraceBuilder() {
    return getSystraceFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.SystraceReportMessage.getDefaultInstance());
}
#end_block

#method_before
public Builder setCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder builderForValue) {
    if (coverageBuilder_ == null) {
        ensureCoverageIsMutable();
        coverage_.set(index, builderForValue.build());
        onChanged();
    } else {
        coverageBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage value) {
    if (coverageBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureCoverageIsMutable();
        coverage_.set(index, value);
        onChanged();
    } else {
        coverageBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addCoverage(int index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder builderForValue) {
    if (coverageBuilder_ == null) {
        ensureCoverageIsMutable();
        coverage_.add(index, builderForValue.build());
        onChanged();
    } else {
        coverageBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addCoverage(com.android.vts.proto.VtsReportMessage.CoverageReportMessage value) {
    if (coverageBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureCoverageIsMutable();
        coverage_.add(value);
        onChanged();
    } else {
        coverageBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder addCoverageBuilder(int index) {
    return getCoverageFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.CoverageReportMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.CoverageReportMessage.Builder addCoverageBuilder() {
    return getCoverageFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.CoverageReportMessage.getDefaultInstance());
}
#end_block

#method_before
public Builder setLog(int index, com.android.vts.proto.VtsReportMessage.LogMessage.Builder builderForValue) {
    if (logBuilder_ == null) {
        ensureLogIsMutable();
        log_.set(index, builderForValue.build());
        onChanged();
    } else {
        logBuilder_.setMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder setLog(int index, com.android.vts.proto.VtsReportMessage.LogMessage value) {
    if (logBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureLogIsMutable();
        log_.set(index, value);
        onChanged();
    } else {
        logBuilder_.setMessage(index, value);
    }
    return this;
}
#end_block

#method_before
public Builder addLog(int index, com.android.vts.proto.VtsReportMessage.LogMessage.Builder builderForValue) {
    if (logBuilder_ == null) {
        ensureLogIsMutable();
        log_.add(index, builderForValue.build());
        onChanged();
    } else {
        logBuilder_.addMessage(index, builderForValue.build());
    }
    return this;
}
#method_after
public Builder addLog(com.android.vts.proto.VtsReportMessage.LogMessage value) {
    if (logBuilder_ == null) {
        if (value == null) {
            throw new NullPointerException();
        }
        ensureLogIsMutable();
        log_.add(value);
        onChanged();
    } else {
        logBuilder_.addMessage(value);
    }
    return this;
}
#end_block

#method_before
public com.android.vts.proto.VtsReportMessage.LogMessage.Builder addLogBuilder(int index) {
    return getLogFieldBuilder().addBuilder(index, com.android.vts.proto.VtsReportMessage.LogMessage.getDefaultInstance());
}
#method_after
public com.android.vts.proto.VtsReportMessage.LogMessage.Builder addLogBuilder() {
    return getLogFieldBuilder().addBuilder(com.android.vts.proto.VtsReportMessage.LogMessage.getDefaultInstance());
}
#end_block

#method_before
public boolean hasTestPlanName() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
}
#method_after
public boolean hasTestPlanName() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
}
#end_block

#method_before
private void initFields() {
    testPlanExecutionId_ = com.google.protobuf.ByteString.EMPTY;
    testModuleName_ = java.util.Collections.emptyList();
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    testPlanName_ = com.google.protobuf.ByteString.EMPTY;
    partnerReport_ = java.util.Collections.emptyList();
}
#method_after
private void initFields() {
    testModuleName_ = java.util.Collections.emptyList();
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    testPlanName_ = com.google.protobuf.ByteString.EMPTY;
    partnerReport_ = java.util.Collections.emptyList();
}
#end_block

#method_before
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, testPlanExecutionId_);
    }
    for (int i = 0; i < testModuleName_.size(); i++) {
        output.writeBytes(11, testModuleName_.get(i));
    }
    for (int i = 0; i < testModuleStartTimestamp_.size(); i++) {
        output.writeInt64(12, testModuleStartTimestamp_.get(i));
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(21, testPlanName_);
    }
    for (int i = 0; i < partnerReport_.size(); i++) {
        output.writeMessage(31, partnerReport_.get(i));
    }
    getUnknownFields().writeTo(output);
}
#method_after
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException {
    getSerializedSize();
    for (int i = 0; i < testModuleName_.size(); i++) {
        output.writeBytes(11, testModuleName_.get(i));
    }
    for (int i = 0; i < testModuleStartTimestamp_.size(); i++) {
        output.writeInt64(12, testModuleStartTimestamp_.get(i));
    }
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(21, testPlanName_);
    }
    for (int i = 0; i < partnerReport_.size(); i++) {
        output.writeMessage(31, partnerReport_.get(i));
    }
    getUnknownFields().writeTo(output);
}
#end_block

#method_before
public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(1, testPlanExecutionId_);
    }
    {
        int dataSize = 0;
        for (int i = 0; i < testModuleName_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(testModuleName_.get(i));
        }
        size += dataSize;
        size += 1 * getTestModuleNameList().size();
    }
    {
        int dataSize = 0;
        for (int i = 0; i < testModuleStartTimestamp_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeInt64SizeNoTag(testModuleStartTimestamp_.get(i));
        }
        size += dataSize;
        size += 1 * getTestModuleStartTimestampList().size();
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(21, testPlanName_);
    }
    for (int i = 0; i < partnerReport_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(31, partnerReport_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}
#method_after
public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1)
        return size;
    size = 0;
    {
        int dataSize = 0;
        for (int i = 0; i < testModuleName_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeBytesSizeNoTag(testModuleName_.get(i));
        }
        size += dataSize;
        size += 1 * getTestModuleNameList().size();
    }
    {
        int dataSize = 0;
        for (int i = 0; i < testModuleStartTimestamp_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream.computeInt64SizeNoTag(testModuleStartTimestamp_.get(i));
        }
        size += dataSize;
        size += 1 * getTestModuleStartTimestampList().size();
    }
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream.computeBytesSize(21, testPlanName_);
    }
    for (int i = 0; i < partnerReport_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream.computeMessageSize(31, partnerReport_.get(i));
    }
    size += getUnknownFields().getSerializedSize();
    memoizedSerializedSize = size;
    return size;
}
#end_block

#method_before
public Builder mergeFrom(com.android.vts.proto.VtsReportMessage.TestPlanReportMessage other) {
    if (other == com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.getDefaultInstance())
        return this;
    if (other.hasTestPlanExecutionId()) {
        setTestPlanExecutionId(other.getTestPlanExecutionId());
    }
    if (!other.testModuleName_.isEmpty()) {
        if (testModuleName_.isEmpty()) {
            testModuleName_ = other.testModuleName_;
            bitField0_ = (bitField0_ & ~0x00000002);
        } else {
            ensureTestModuleNameIsMutable();
            testModuleName_.addAll(other.testModuleName_);
        }
        onChanged();
    }
    if (!other.testModuleStartTimestamp_.isEmpty()) {
        if (testModuleStartTimestamp_.isEmpty()) {
            testModuleStartTimestamp_ = other.testModuleStartTimestamp_;
            bitField0_ = (bitField0_ & ~0x00000004);
        } else {
            ensureTestModuleStartTimestampIsMutable();
            testModuleStartTimestamp_.addAll(other.testModuleStartTimestamp_);
        }
        onChanged();
    }
    if (other.hasTestPlanName()) {
        setTestPlanName(other.getTestPlanName());
    }
    if (partnerReportBuilder_ == null) {
        if (!other.partnerReport_.isEmpty()) {
            if (partnerReport_.isEmpty()) {
                partnerReport_ = other.partnerReport_;
                bitField0_ = (bitField0_ & ~0x00000010);
            } else {
                ensurePartnerReportIsMutable();
                partnerReport_.addAll(other.partnerReport_);
            }
            onChanged();
        }
    } else {
        if (!other.partnerReport_.isEmpty()) {
            if (partnerReportBuilder_.isEmpty()) {
                partnerReportBuilder_.dispose();
                partnerReportBuilder_ = null;
                partnerReport_ = other.partnerReport_;
                bitField0_ = (bitField0_ & ~0x00000010);
                partnerReportBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getPartnerReportFieldBuilder() : null;
            } else {
                partnerReportBuilder_.addAllMessages(other.partnerReport_);
            }
        }
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}
#method_after
public Builder mergeFrom(com.android.vts.proto.VtsReportMessage.TestPlanReportMessage other) {
    if (other == com.android.vts.proto.VtsReportMessage.TestPlanReportMessage.getDefaultInstance())
        return this;
    if (!other.testModuleName_.isEmpty()) {
        if (testModuleName_.isEmpty()) {
            testModuleName_ = other.testModuleName_;
            bitField0_ = (bitField0_ & ~0x00000001);
        } else {
            ensureTestModuleNameIsMutable();
            testModuleName_.addAll(other.testModuleName_);
        }
        onChanged();
    }
    if (!other.testModuleStartTimestamp_.isEmpty()) {
        if (testModuleStartTimestamp_.isEmpty()) {
            testModuleStartTimestamp_ = other.testModuleStartTimestamp_;
            bitField0_ = (bitField0_ & ~0x00000002);
        } else {
            ensureTestModuleStartTimestampIsMutable();
            testModuleStartTimestamp_.addAll(other.testModuleStartTimestamp_);
        }
        onChanged();
    }
    if (other.hasTestPlanName()) {
        setTestPlanName(other.getTestPlanName());
    }
    if (partnerReportBuilder_ == null) {
        if (!other.partnerReport_.isEmpty()) {
            if (partnerReport_.isEmpty()) {
                partnerReport_ = other.partnerReport_;
                bitField0_ = (bitField0_ & ~0x00000008);
            } else {
                ensurePartnerReportIsMutable();
                partnerReport_.addAll(other.partnerReport_);
            }
            onChanged();
        }
    } else {
        if (!other.partnerReport_.isEmpty()) {
            if (partnerReportBuilder_.isEmpty()) {
                partnerReportBuilder_.dispose();
                partnerReportBuilder_ = null;
                partnerReport_ = other.partnerReport_;
                bitField0_ = (bitField0_ & ~0x00000008);
                partnerReportBuilder_ = com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ? getPartnerReportFieldBuilder() : null;
            } else {
                partnerReportBuilder_.addAllMessages(other.partnerReport_);
            }
        }
    }
    this.mergeUnknownFields(other.getUnknownFields());
    return this;
}
#end_block

#method_before
private void ensureTestModuleNameIsMutable() {
    if (!((bitField0_ & 0x00000002) == 0x00000002)) {
        testModuleName_ = new java.util.ArrayList<com.google.protobuf.ByteString>(testModuleName_);
        bitField0_ |= 0x00000002;
    }
}
#method_after
private void ensureTestModuleNameIsMutable() {
    if (!((bitField0_ & 0x00000001) == 0x00000001)) {
        testModuleName_ = new java.util.ArrayList<com.google.protobuf.ByteString>(testModuleName_);
        bitField0_ |= 0x00000001;
    }
}
#end_block

#method_before
public Builder clearTestModuleName() {
    testModuleName_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    onChanged();
    return this;
}
#method_after
public Builder clearTestModuleName() {
    testModuleName_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000001);
    onChanged();
    return this;
}
#end_block

#method_before
private void ensureTestModuleStartTimestampIsMutable() {
    if (!((bitField0_ & 0x00000004) == 0x00000004)) {
        testModuleStartTimestamp_ = new java.util.ArrayList<java.lang.Long>(testModuleStartTimestamp_);
        bitField0_ |= 0x00000004;
    }
}
#method_after
private void ensureTestModuleStartTimestampIsMutable() {
    if (!((bitField0_ & 0x00000002) == 0x00000002)) {
        testModuleStartTimestamp_ = new java.util.ArrayList<java.lang.Long>(testModuleStartTimestamp_);
        bitField0_ |= 0x00000002;
    }
}
#end_block

#method_before
public Builder clearTestModuleStartTimestamp() {
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000004);
    onChanged();
    return this;
}
#method_after
public Builder clearTestModuleStartTimestamp() {
    testModuleStartTimestamp_ = java.util.Collections.emptyList();
    bitField0_ = (bitField0_ & ~0x00000002);
    onChanged();
    return this;
}
#end_block

#method_before
public boolean hasTestPlanName() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
}
#method_after
public boolean hasTestPlanName() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
}
#end_block

#method_before
public Builder setTestPlanName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000008;
    testPlanName_ = value;
    onChanged();
    return this;
}
#method_after
public Builder setTestPlanName(com.google.protobuf.ByteString value) {
    if (value == null) {
        throw new NullPointerException();
    }
    bitField0_ |= 0x00000004;
    testPlanName_ = value;
    onChanged();
    return this;
}
#end_block

#method_before
public Builder clearTestPlanName() {
    bitField0_ = (bitField0_ & ~0x00000008);
    testPlanName_ = getDefaultInstance().getTestPlanName();
    onChanged();
    return this;
}
#method_after
public Builder clearTestPlanName() {
    bitField0_ = (bitField0_ & ~0x00000004);
    testPlanName_ = getDefaultInstance().getTestPlanName();
    onChanged();
    return this;
}
#end_block

#method_before
private void ensurePartnerReportIsMutable() {
    if (!((bitField0_ & 0x00000010) == 0x00000010)) {
        partnerReport_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.UrlResourceMessage>(partnerReport_);
        bitField0_ |= 0x00000010;
    }
}
#method_after
private void ensurePartnerReportIsMutable() {
    if (!((bitField0_ & 0x00000008) == 0x00000008)) {
        partnerReport_ = new java.util.ArrayList<com.android.vts.proto.VtsReportMessage.UrlResourceMessage>(partnerReport_);
        bitField0_ |= 0x00000008;
    }
}
#end_block

#method_before
public Builder clearPartnerReport() {
    if (partnerReportBuilder_ == null) {
        partnerReport_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
    } else {
        partnerReportBuilder_.clear();
    }
    return this;
}
#method_after
public Builder clearPartnerReport() {
    if (partnerReportBuilder_ == null) {
        partnerReport_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
    } else {
        partnerReportBuilder_.clear();
    }
    return this;
}
#end_block

#method_before
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.UrlResourceMessage, com.android.vts.proto.VtsReportMessage.UrlResourceMessage.Builder, com.android.vts.proto.VtsReportMessage.UrlResourceMessageOrBuilder> getPartnerReportFieldBuilder() {
    if (partnerReportBuilder_ == null) {
        partnerReportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.UrlResourceMessage, com.android.vts.proto.VtsReportMessage.UrlResourceMessage.Builder, com.android.vts.proto.VtsReportMessage.UrlResourceMessageOrBuilder>(partnerReport_, ((bitField0_ & 0x00000010) == 0x00000010), getParentForChildren(), isClean());
        partnerReport_ = null;
    }
    return partnerReportBuilder_;
}
#method_after
private com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.UrlResourceMessage, com.android.vts.proto.VtsReportMessage.UrlResourceMessage.Builder, com.android.vts.proto.VtsReportMessage.UrlResourceMessageOrBuilder> getPartnerReportFieldBuilder() {
    if (partnerReportBuilder_ == null) {
        partnerReportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<com.android.vts.proto.VtsReportMessage.UrlResourceMessage, com.android.vts.proto.VtsReportMessage.UrlResourceMessage.Builder, com.android.vts.proto.VtsReportMessage.UrlResourceMessageOrBuilder>(partnerReport_, ((bitField0_ & 0x00000008) == 0x00000008), getParentForChildren(), isClean());
        partnerReport_ = null;
    }
    return partnerReportBuilder_;
}
#end_block

#method_before
private Provider doLoadProvider() {
    return AccessController.doPrivileged(new PrivilegedAction<Provider>() {

        public Provider run() {
            if (debug != null) {
                debug.println("Loading provider: " + ProviderConfig.this);
            }
            // BEGIN Android-changed: Prefer the boot classloader to the system classloader
            try {
                // First try with the boot classloader.
                return initProvider(className, Object.class.getClassLoader());
            } catch (Exception e1) {
                // If that fails, try with the system classloader.
                try {
                    return initProvider(className, ClassLoader.getSystemClassLoader());
                } catch (Exception e) {
                    Throwable t;
                    if (e instanceof InvocationTargetException) {
                        t = ((InvocationTargetException) e).getCause();
                    } else {
                        t = e;
                    }
                    if (debug != null) {
                        debug.println("Error loading provider " + ProviderConfig.this);
                        t.printStackTrace();
                    }
                    // provider indicates fatal error, pass through exception
                    if (t instanceof ProviderException) {
                        throw (ProviderException) t;
                    }
                    // provider indicates that loading should not be retried
                    if (t instanceof UnsupportedOperationException) {
                        disableLoad();
                    }
                    return null;
                }
            }
        }
    });
}
#method_after
private Provider doLoadProvider() {
    return AccessController.doPrivileged(new PrivilegedAction<Provider>() {

        public Provider run() {
            if (debug != null) {
                debug.println("Loading provider: " + ProviderConfig.this);
            }
            // BEGIN Android-changed: Prefer the boot classloader to the system classloader.
            try {
                // First try with the boot classloader.
                return initProvider(className, Object.class.getClassLoader());
            } catch (Exception e1) {
                // If that fails, try with the system classloader.
                try {
                    return initProvider(className, ClassLoader.getSystemClassLoader());
                } catch (Exception e) {
                    Throwable t;
                    if (e instanceof InvocationTargetException) {
                        t = ((InvocationTargetException) e).getCause();
                    } else {
                        t = e;
                    }
                    if (debug != null) {
                        debug.println("Error loading provider " + ProviderConfig.this);
                        t.printStackTrace();
                    }
                    // provider indicates fatal error, pass through exception
                    if (t instanceof ProviderException) {
                        throw (ProviderException) t;
                    }
                    // provider indicates that loading should not be retried
                    if (t instanceof UnsupportedOperationException) {
                        disableLoad();
                    }
                    return null;
                }
            }
        }
    });
}
#end_block

#method_before
// END Android-changed: Prefer the boot classloader to the system classloader
private static String expand(final String value) {
    // shortcut if value does not contain any properties
    if (value.contains("${") == false) {
        return value;
    }
    return AccessController.doPrivileged(new PrivilegedAction<String>() {

        public String run() {
            try {
                return PropertyExpander.expand(value);
            } catch (GeneralSecurityException e) {
                throw new ProviderException(e);
            }
        }
    });
}
#method_after
// END Android-changed: Prefer the boot classloader to the system classloader.
private static String expand(final String value) {
    // shortcut if value does not contain any properties
    if (value.contains("${") == false) {
        return value;
    }
    return AccessController.doPrivileged(new PrivilegedAction<String>() {

        public String run() {
            try {
                return PropertyExpander.expand(value);
            } catch (GeneralSecurityException e) {
                throw new ProviderException(e);
            }
        }
    });
}
#end_block

#method_before
// BEGIN Android-changed: Debug is stubbed and disabled on Android
// Removing the static initializer removes the only pathway to set args, which
// in turn means that isOn() always returns false and so no code in this
// class does anything.
/*
    static {
        args = java.security.AccessController.doPrivileged
                (new sun.security.action.GetPropertyAction
                ("java.security.debug"));

        String args2 = java.security.AccessController.doPrivileged
                (new sun.security.action.GetPropertyAction
                ("java.security.auth.debug"));

        if (args == null) {
            args = args2;
        } else {
            if (args2 != null)
               args = args + "," + args2;
        }

        if (args != null) {
            args = marshal(args);
            if (args.equals("help")) {
                Help();
            }
        }
    }

        From public static void Help() : Serves as a documentation of the
        values that "args" accepts.

        System.err.println();
        System.err.println("all           turn on all debugging");
        System.err.println("access        print all checkPermission results");
        System.err.println("certpath      PKIX CertPathBuilder and");
        System.err.println("              CertPathValidator debugging");
        System.err.println("combiner      SubjectDomainCombiner debugging");
        System.err.println("gssloginconfig");
        System.err.println("              GSS LoginConfigImpl debugging");
        System.err.println("configfile    JAAS ConfigFile loading");
        System.err.println("configparser  JAAS ConfigFile parsing");
        System.err.println("jar           jar verification");
        System.err.println("logincontext  login context results");
        System.err.println("jca           JCA engine class debugging");
        System.err.println("policy        loading and granting");
        System.err.println("provider      security provider debugging");
        System.err.println("pkcs11        PKCS11 session manager debugging");
        System.err.println("pkcs11keystore");
        System.err.println("              PKCS11 KeyStore debugging");
        System.err.println("sunpkcs11     SunPKCS11 provider debugging");
        System.err.println("scl           permissions SecureClassLoader assigns");
        System.err.println("ts            timestamping");
        System.err.println();
        System.err.println("The following can be used with access:");
        System.err.println();
        System.err.println("stack         include stack trace");
        System.err.println("domain        dump all domains in context");
        System.err.println("failure       before throwing exception, dump stack");
        System.err.println("              and domain that didn't have permission");
        System.err.println();
        System.err.println("The following can be used with stack and domain:");
        System.err.println();
        System.err.println("permission=<classname>");
        System.err.println("              only dump output if specified permission");
        System.err.println("              is being checked");
        System.err.println("codebase=<URL>");
        System.err.println("              only dump output if specified codebase");
        System.err.println("              is being checked");
        System.err.println();
        System.err.println("The following can be used with provider:");
        System.err.println();
        System.err.println("engine=<engines>");
        System.err.println("              only dump output for the specified list");
        System.err.println("              of JCA engines. Supported values:");
        System.err.println("              Cipher, KeyAgreement, KeyGenerator,");
        System.err.println("              KeyPairGenerator, KeyStore, Mac,");
        System.err.println("              MessageDigest, SecureRandom, Signature.");
        System.err.println();
        System.err.println("Note: Separate multiple options with a comma");
        System.exit(0);
    */
// END Android-changed: Debug is stubbed and disabled on Android
/**
 * Get a Debug object corresponding to whether or not the given
 * option is set. Set the prefix to be the same as option.
 */
public static Debug getInstance(String option) {
    return getInstance(option, option);
}
#method_after
// BEGIN Android-changed: Debug is stubbed and disabled on Android.
// Removing the static initializer removes the only pathway to set args, which
// in turn means that isOn() always returns false and so no code in this
// class does anything.
/*
    static {
        args = java.security.AccessController.doPrivileged
                (new sun.security.action.GetPropertyAction
                ("java.security.debug"));

        String args2 = java.security.AccessController.doPrivileged
                (new sun.security.action.GetPropertyAction
                ("java.security.auth.debug"));

        if (args == null) {
            args = args2;
        } else {
            if (args2 != null)
               args = args + "," + args2;
        }

        if (args != null) {
            args = marshal(args);
            if (args.equals("help")) {
                Help();
            }
        }
    }

        From public static void Help() : Serves as a documentation of the
        values that "args" accepts.

        System.err.println();
        System.err.println("all           turn on all debugging");
        System.err.println("access        print all checkPermission results");
        System.err.println("certpath      PKIX CertPathBuilder and");
        System.err.println("              CertPathValidator debugging");
        System.err.println("combiner      SubjectDomainCombiner debugging");
        System.err.println("gssloginconfig");
        System.err.println("              GSS LoginConfigImpl debugging");
        System.err.println("configfile    JAAS ConfigFile loading");
        System.err.println("configparser  JAAS ConfigFile parsing");
        System.err.println("jar           jar verification");
        System.err.println("logincontext  login context results");
        System.err.println("jca           JCA engine class debugging");
        System.err.println("policy        loading and granting");
        System.err.println("provider      security provider debugging");
        System.err.println("pkcs11        PKCS11 session manager debugging");
        System.err.println("pkcs11keystore");
        System.err.println("              PKCS11 KeyStore debugging");
        System.err.println("sunpkcs11     SunPKCS11 provider debugging");
        System.err.println("scl           permissions SecureClassLoader assigns");
        System.err.println("ts            timestamping");
        System.err.println();
        System.err.println("The following can be used with access:");
        System.err.println();
        System.err.println("stack         include stack trace");
        System.err.println("domain        dump all domains in context");
        System.err.println("failure       before throwing exception, dump stack");
        System.err.println("              and domain that didn't have permission");
        System.err.println();
        System.err.println("The following can be used with stack and domain:");
        System.err.println();
        System.err.println("permission=<classname>");
        System.err.println("              only dump output if specified permission");
        System.err.println("              is being checked");
        System.err.println("codebase=<URL>");
        System.err.println("              only dump output if specified codebase");
        System.err.println("              is being checked");
        System.err.println();
        System.err.println("The following can be used with provider:");
        System.err.println();
        System.err.println("engine=<engines>");
        System.err.println("              only dump output for the specified list");
        System.err.println("              of JCA engines. Supported values:");
        System.err.println("              Cipher, KeyAgreement, KeyGenerator,");
        System.err.println("              KeyPairGenerator, KeyStore, Mac,");
        System.err.println("              MessageDigest, SecureRandom, Signature.");
        System.err.println();
        System.err.println("Note: Separate multiple options with a comma");
        System.exit(0);
    */
// END Android-changed: Debug is stubbed and disabled on Android.
/**
 * Get a Debug object corresponding to whether or not the given
 * option is set. Set the prefix to be the same as option.
 */
public static Debug getInstance(String option) {
    return getInstance(option, option);
}
#end_block

#method_before
// Android-removed: Nothing uses this code and it serves no purpose
/**
 * print a message to stderr that is prefixed with the prefix.
 *
 *    public static void println(String prefix, String message)
 *    {
 *        System.err.println(prefix + ": "+message);
 *    }
 */
public static String toHexString(BigInteger b) {
    String hexValue = b.toString(16);
    StringBuffer buf = new StringBuffer(hexValue.length() * 2);
    if (hexValue.startsWith("-")) {
        buf.append("   -");
        hexValue = hexValue.substring(1);
    } else {
        // four spaces
        buf.append("    ");
    }
    if ((hexValue.length() % 2) != 0) {
        // add back the leading 0
        hexValue = "0" + hexValue;
    }
    int i = 0;
    while (i < hexValue.length()) {
        // one byte at a time
        buf.append(hexValue.substring(i, i + 2));
        i += 2;
        if (i != hexValue.length()) {
            if ((i % 64) == 0) {
                // line after eight words
                buf.append("\n    ");
            } else if (i % 8 == 0) {
                // space between words
                buf.append(" ");
            }
        }
    }
    return buf.toString();
}
#method_after
// Android-removed: Nothing uses this code and it serves no purpose.
/**
 * print a message to stderr that is prefixed with the prefix.
 *
 *    public static void println(String prefix, String message)
 *    {
 *        System.err.println(prefix + ": "+message);
 *    }
 */
public static String toHexString(BigInteger b) {
    String hexValue = b.toString(16);
    StringBuffer buf = new StringBuffer(hexValue.length() * 2);
    if (hexValue.startsWith("-")) {
        buf.append("   -");
        hexValue = hexValue.substring(1);
    } else {
        // four spaces
        buf.append("    ");
    }
    if ((hexValue.length() % 2) != 0) {
        // add back the leading 0
        hexValue = "0" + hexValue;
    }
    int i = 0;
    while (i < hexValue.length()) {
        // one byte at a time
        buf.append(hexValue.substring(i, i + 2));
        i += 2;
        if (i != hexValue.length()) {
            if ((i % 64) == 0) {
                // line after eight words
                buf.append("\n    ");
            } else if (i % 8 == 0) {
                // space between words
                buf.append(" ");
            }
        }
    }
    return buf.toString();
}
#end_block

#method_before
private NetworkRequest requestNetworkForFeatureLocked(NetworkCapabilities netCap) {
    int delay = -1;
    int type = legacyTypeForNetworkCapabilities(netCap);
    try {
        delay = mService.getRestoreDefaultNetworkDelay(type);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    LegacyRequest l = new LegacyRequest();
    l.networkCapabilities = netCap;
    l.delay = delay;
    l.expireSequenceNumber = 0;
    l.networkRequest = sendRequestForNetwork(netCap, l.networkCallback, 0, REQUEST, type, mDefaultHandler);
    if (l.networkRequest == null)
        return null;
    sLegacyRequests.put(netCap, l);
    sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
    return l.networkRequest;
}
#method_after
private NetworkRequest requestNetworkForFeatureLocked(NetworkCapabilities netCap) {
    int delay = -1;
    int type = legacyTypeForNetworkCapabilities(netCap);
    try {
        delay = mService.getRestoreDefaultNetworkDelay(type);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    LegacyRequest l = new LegacyRequest();
    l.networkCapabilities = netCap;
    l.delay = delay;
    l.expireSequenceNumber = 0;
    l.networkRequest = sendRequestForNetwork(netCap, l.networkCallback, 0, REQUEST, type, getDefaultHandler());
    if (l.networkRequest == null)
        return null;
    sLegacyRequests.put(netCap, l);
    sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
    return l.networkRequest;
}
#end_block

#method_before
private void sendExpireMsgForFeature(NetworkCapabilities netCap, int seqNum, int delay) {
    if (delay >= 0) {
        Log.d(TAG, "sending expire msg with seqNum " + seqNum + " and delay " + delay);
        Message msg = mDefaultHandler.obtainMessage(EXPIRE_LEGACY_REQUEST, seqNum, 0, netCap);
        mDefaultHandler.sendMessageDelayed(msg, delay);
    }
}
#method_after
private void sendExpireMsgForFeature(NetworkCapabilities netCap, int seqNum, int delay) {
    if (delay >= 0) {
        Log.d(TAG, "sending expire msg with seqNum " + seqNum + " and delay " + delay);
        CallbackHandler handler = getDefaultHandler();
        Message msg = handler.obtainMessage(EXPIRE_LEGACY_REQUEST, seqNum, 0, netCap);
        handler.sendMessageDelayed(msg, delay);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message message) {
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + " for network " + network);
    }
    final NetworkCallback callback;
    synchronized (mCallbacks) {
        callback = mCallbacks.get(request);
    }
    if (callback == null) {
        Log.w(TAG, "callback not found for " + getCallbackName(message.what) + " message");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                callback.onAvailable(network);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message message) {
    if (message.what == EXPIRE_LEGACY_REQUEST) {
        expireRequest((NetworkCapabilities) message.obj, message.arg1);
        return;
    }
    final NetworkRequest request = getObject(message, NetworkRequest.class);
    final Network network = getObject(message, Network.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(request);
    }
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + " for network " + network);
    }
    if (callback == null) {
        Log.w(TAG, "callback not found for " + getCallbackName(message.what) + " message");
        return;
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                callback.onPreCheck(network);
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                callback.onAvailable(network);
                break;
            }
        case CALLBACK_LOSING:
            {
                callback.onLosing(network, message.arg1);
                break;
            }
        case CALLBACK_LOST:
            {
                callback.onLost(network);
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                callback.onUnavailable();
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                callback.onCapabilitiesChanged(network, cap);
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                LinkProperties lp = getObject(message, LinkProperties.class);
                callback.onLinkPropertiesChanged(network, lp);
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                callback.onNetworkSuspended(network);
                break;
            }
        case CALLBACK_RESUMED:
            {
                callback.onNetworkResumed(network);
                break;
            }
    }
}
#end_block

#method_before
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    checkCallback(callback);
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (mCallbacks) {
            checkNumberOfRequests();
            if (callback.isRegistered()) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                mCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return request;
}
#method_after
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    checkCallbackNotNull(callback);
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (sCallbacks) {
            if (callback.isRegistered()) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                sCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
    return request;
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, mDefaultHandler);
}
#method_after
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, mDefaultHandler);
}
#method_after
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void releaseNetworkRequest(PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void releaseNetworkRequest(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, mDefaultHandler);
}
#method_after
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void registerDefaultNetworkCallback(NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, mDefaultHandler);
}
#method_after
public void registerDefaultNetworkCallback(NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
}
#end_block

#method_before
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    checkCallback(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (mCallbacks) {
        Preconditions.checkArgument(networkCallback.isRegistered(), "NetworkCallback was not registered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : mCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            mCallbacks.remove(r);
        }
        networkCallback.networkRequest = null;
    }
}
#method_after
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.isRegistered(), "NetworkCallback was not registered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = null;
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntent(operation);
    releaseNetworkRequest(operation);
}
#method_after
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#end_block

#method_before
private int setWifiTethering(final boolean enable) {
    synchronized (mPublicSync) {
        mWifiTetherRequested = enable;
        final WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        if ((enable && wifiManager.startSoftAp(null)) || (!enable && wifiManager.stopSoftAp())) {
            return ConnectivityManager.TETHER_ERROR_NO_ERROR;
        }
        return ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
    }
}
#method_after
private int setWifiTethering(final boolean enable) {
    int rval = ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
    final long ident = Binder.clearCallingIdentity();
    try {
        synchronized (mPublicSync) {
            mWifiTetherRequested = enable;
            final WifiManager mgr = getWifiManager();
            if ((enable && mgr.startSoftAp(null)) || (!enable && mgr.stopSoftAp())) {
                rval = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return rval;
}
#end_block

#method_before
// TODO: Consider renaming to something more accurate in its description.
// This method:
// - allows requesting either tethering or local hotspot serving states
// - handles both enabling and disabling serving states
// - only tethers the first matching interface in listInterfaces()
private void tetherMatchingInterfaces(int requestedState, int interfaceType) {
    if (VDBG) {
        Log.d(TAG, "tetherMatchingInterfaces(" + requestedState + ", " + interfaceType + ")");
    }
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(chosenIface);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            // TODO: Remove this locking.
            synchronized (mPublicSync) {
                maybeTrackNewInterfaceLocked(chosenIface);
            }
            result = tether(chosenIface, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#method_after
// TODO: Consider renaming to something more accurate in its description.
// This method:
// - allows requesting either tethering or local hotspot serving states
// - handles both enabling and disabling serving states
// - only tethers the first matching interface in listInterfaces()
private void tetherMatchingInterfaces(int requestedState, int interfaceType) {
    if (VDBG) {
        Log.d(TAG, "tetherMatchingInterfaces(" + requestedState + ", " + interfaceType + ")");
    }
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(chosenIface);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            result = tether(chosenIface, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            mLog.e(ee);
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    mLog.log("SET master tether settings: ON");
    return true;
}
#end_block

#method_before
protected boolean turnOffMasterTetherSettings() {
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
        transitionTo(mStopTetheringErrorState);
        return false;
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
        transitionTo(mSetIpForwardingDisabledErrorState);
        return false;
    }
    transitionTo(mInitialState);
    return true;
}
#method_after
protected boolean turnOffMasterTetherSettings() {
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mStopTetheringErrorState);
        return false;
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingDisabledErrorState);
        return false;
    }
    transitionTo(mInitialState);
    mLog.log("SET master tether settings: OFF");
    return true;
}
#end_block

#method_before
protected void setDnsForwarders(final Network network, final LinkProperties lp) {
    // TODO: Set v4 and/or v6 DNS per available connectivity.
    String[] dnsServers = mConfig.defaultIPv4DNS;
    final Collection<InetAddress> dnses = lp.getDnsServers();
    // TODO: Properly support the absence of DNS servers.
    if (dnses != null && !dnses.isEmpty()) {
        // TODO: remove this invocation of NetworkUtils.makeStrings().
        dnsServers = NetworkUtils.makeStrings(dnses);
    }
    if (VDBG) {
        Log.d(TAG, "Setting DNS forwarders: Network=" + network + ", dnsServers=" + Arrays.toString(dnsServers));
    }
    try {
        mNMService.setDnsForwarders(network, dnsServers);
    } catch (Exception e) {
        // TODO: Investigate how this can fail and what exactly
        // happens if/when such failures occur.
        Log.e(TAG, "Setting DNS forwarders failed!");
        transitionTo(mSetDnsForwardersErrorState);
    }
}
#method_after
protected void setDnsForwarders(final Network network, final LinkProperties lp) {
    // TODO: Set v4 and/or v6 DNS per available connectivity.
    String[] dnsServers = mConfig.defaultIPv4DNS;
    final Collection<InetAddress> dnses = lp.getDnsServers();
    // TODO: Properly support the absence of DNS servers.
    if (dnses != null && !dnses.isEmpty()) {
        // TODO: remove this invocation of NetworkUtils.makeStrings().
        dnsServers = NetworkUtils.makeStrings(dnses);
    }
    try {
        mNMService.setDnsForwarders(network, dnsServers);
        mLog.log(String.format("SET DNS forwarders: network=%s dnsServers=%s", network, Arrays.toString(dnsServers)));
    } catch (Exception e) {
        // TODO: Investigate how this can fail and what exactly
        // happens if/when such failures occur.
        mLog.e("setting DNS forwarders failed, " + e);
        transitionTo(mSetDnsForwardersErrorState);
    }
}
#end_block

#method_before
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mForwardedDownstreams.remove(who);
    }
}
#method_after
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, WifiManager.IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, WifiManager.IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#end_block

#method_before
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mForwardedDownstreams.remove(who);
}
#method_after
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        if (who.lastError() != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#end_block

#method_before
@Override
public void enter() {
    // TODO: examine if we should check the return value.
    // may transition us out
    turnOnMasterTetherSettings();
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    mOffloadController.start();
    if (upstreamWanted()) {
        mUpstreamWanted = true;
        chooseUpstreamType(true);
        mTryCell = false;
    }
}
#method_after
@Override
public void enter() {
    // transitioned to an error state; exit early.
    if (!turnOnMasterTetherSettings()) {
        return;
    }
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    mOffloadController.start();
    if (upstreamWanted()) {
        mUpstreamWanted = true;
        chooseUpstreamType(true);
        mTryCell = false;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // transitions appropriately
                    turnOffMasterTetherSettings();
                } else {
                    if (DBG) {
                        Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                        for (TetherInterfaceStateMachine o : mNotifyList) {
                            Log.d(TAG, "  " + o);
                        }
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#method_after
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
        if (VDBG)
            Log.d(TAG, iface + " is not a tetherable iface, ignoring");
        return;
    }
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.get(iface) != null) {
        if (VDBG)
            Log.d(TAG, "active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
        mLog.log(iface + " is not a tetherable iface, ignoring");
        return;
    }
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService, mLog)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#end_block

#method_before
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        if (VDBG) {
            Log.e(TAG, "attempting to remove unknown iface (" + iface + "), ignoring");
        }
        return;
    }
    tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
    mTetherStates.remove(iface);
}
#method_after
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        mLog.log("attempting to remove unknown iface (" + iface + "), ignoring");
        return;
    }
    tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
    mLog.log("removing TetheringInterfaceStateMachine for: " + iface);
    mTetherStates.remove(iface);
}
#end_block

#method_before
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    checkCallback(callback);
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (sCallbacks) {
            if (callback.isRegistered()) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                sCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
    return request;
}
#method_after
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    checkCallbackNotNull(callback);
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (sCallbacks) {
            if (callback.isRegistered()) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                sCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
    return request;
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void releaseNetworkRequest(PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void releaseNetworkRequest(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    checkPendingIntent(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    checkCallback(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.isRegistered(), "NetworkCallback was not registered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = null;
    }
}
#method_after
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.isRegistered(), "NetworkCallback was not registered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = null;
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntent(operation);
    releaseNetworkRequest(operation);
}
#method_after
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#end_block

#method_before
protected void setLocalPypiPath() throws RuntimeException {
    CLog.i("Loading vendor test config %s", VENDOR_TEST_CONFIG_FILE_PATH);
    InputStream config = getClass().getResourceAsStream(VENDOR_TEST_CONFIG_FILE_PATH);
    // First try to load local PyPI directory path from vendor config file
    if (config != null) {
        try {
            String content = StreamUtil.getStringFromStream(config);
            CLog.i("Loaded vendor test config %s", content);
            if (content != null) {
                JSONObject vendorConfigJson = new JSONObject(content);
                try {
                    String pypiPath = vendorConfigJson.getString(LOCAL_PYPI_PATH_KEY);
                    if (pypiPath.length() > 0) {
                        mLocalPypiPath = pypiPath;
                        CLog.i(String.format("Loaded %s: %s", LOCAL_PYPI_PATH_KEY, mLocalPypiPath));
                    }
                } catch (NoSuchElementException e) {
                    CLog.i("Vendor test config file does not define %s", LOCAL_PYPI_PATH_KEY);
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to read vendor config json file");
        } catch (JSONException e) {
            throw new RuntimeException("Failed to parse vendor config json data");
        }
    } else {
        CLog.i("Vendor test config file %s does not exist", VENDOR_TEST_CONFIG_FILE_PATH);
    }
    // set local PyPI path to LOCAL_PYPI_PACKAGES_PATH
    if (mLocalPypiPath == null) {
        CLog.i("Checking existence of local pypi packages directory at: %s", LOCAL_PYPI_PACKAGES_PATH);
        File localPypiPackagesPath = new File(LOCAL_PYPI_PACKAGES_PATH);
        if (localPypiPackagesPath.exists() && localPypiPackagesPath.isDirectory()) {
            mLocalPypiPath = LOCAL_PYPI_PACKAGES_PATH;
            CLog.i("Confirmed existence of local pypi packages directory");
        } else {
            CLog.i("Local pypi packages directory does not exist. Therefore internet connection" + "to https://pypi.python.org/simple/ must be available to run VTS tests.");
        }
    }
}
#method_after
protected void setLocalPypiPath() throws RuntimeException {
    CLog.i("Loading vendor test config %s", VENDOR_TEST_CONFIG_FILE_PATH);
    InputStream config = getClass().getResourceAsStream(VENDOR_TEST_CONFIG_FILE_PATH);
    // First try to load local PyPI directory path from vendor config file
    if (config != null) {
        try {
            String content = StreamUtil.getStringFromStream(config);
            CLog.i("Loaded vendor test config %s", content);
            if (content != null) {
                JSONObject vendorConfigJson = new JSONObject(content);
                try {
                    String pypiPath = vendorConfigJson.getString(LOCAL_PYPI_PATH_KEY);
                    if (pypiPath.length() > 0) {
                        mLocalPypiPath = pypiPath;
                        CLog.i(String.format("Loaded %s: %s", LOCAL_PYPI_PATH_KEY, mLocalPypiPath));
                    }
                } catch (NoSuchElementException e) {
                    CLog.i("Vendor test config file does not define %s", LOCAL_PYPI_PATH_KEY);
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to read vendor config json file");
        } catch (JSONException e) {
            throw new RuntimeException("Failed to parse vendor config json data");
        }
    } else {
        CLog.i("Vendor test config file %s does not exist", VENDOR_TEST_CONFIG_FILE_PATH);
    }
    // set local PyPI path to LOCAL_PYPI_PACKAGES_PATH
    if (mLocalPypiPath == null) {
        CLog.i("Checking whether local pypi packages directory exists");
        mLocalPypiPath = System.getenv(LOCAL_PYPI_PATH_ENV_VAR_NAME);
        if (mLocalPypiPath != null) {
            CLog.i("Confirmed existence of local pypi packages directory at %s", mLocalPypiPath);
        } else {
            CLog.i("Local pypi packages directory does not exist. Therefore internet connection" + "to https://pypi.python.org/simple/ must be available to run VTS tests.");
        }
    }
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
@Test
public void testV1OneSignerSHA1withDSAAcceptedWithKeysTooLongForDigest() throws Exception {
    // APK signed with v1 scheme only, one signer
    // OpenJDK's default implementation of Signature.SHA1withDSA refuses to verify signatures
    // created with keys too long for the digest used. Android Package Manager does not reject
    // such signatures. We thus skip this test if Signature.SHA1withDSA exhibits this issue.
    PublicKey publicKey = getCertificateFromResources("dsa-2048.x509.pem").getPublicKey();
    Signature s = Signature.getInstance("SHA1withDSA");
    try {
        s.initVerify(publicKey);
    } catch (InvalidKeyException e) {
        assumeNoException(e);
    }
    assertVerifiedForEach("v1-only-with-dsa-sha1-1.2.840.10040.4.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
    assertVerifiedForEach("v1-only-with-dsa-sha1-1.2.840.10040.4.3-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
}
#method_after
@Test
public void testV1OneSignerSHA1withDSAAcceptedWithKeysTooLongForDigest() throws Exception {
    // APK signed with v1 scheme only, one signer
    // OpenJDK's default implementation of Signature.SHA1withDSA refuses to verify signatures
    // created with keys too long for the digest used. Android Package Manager does not reject
    // such signatures. We thus skip this test if Signature.SHA1withDSA exhibits this issue.
    PublicKey publicKey = Resources.toCertificate(getClass(), "dsa-2048.x509.pem").getPublicKey();
    Signature s = Signature.getInstance("SHA1withDSA");
    try {
        s.initVerify(publicKey);
    } catch (InvalidKeyException e) {
        assumeNoException(e);
    }
    assertVerifiedForEach("v1-only-with-dsa-sha1-1.2.840.10040.4.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
    assertVerifiedForEach("v1-only-with-dsa-sha1-1.2.840.10040.4.3-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
}
#end_block

#method_before
@Test
public void testV1OneSignerSHA224withDSAAcceptedWithKeysTooLongForDigest() throws Exception {
    // APK signed with v1 scheme only, one signer
    // OpenJDK's default implementation of Signature.SHA224withDSA refuses to verify signatures
    // created with keys too long for the digest used. Android Package Manager does not reject
    // such signatures. We thus skip this test if Signature.SHA224withDSA exhibits this issue.
    PublicKey publicKey = getCertificateFromResources("dsa-2048.x509.pem").getPublicKey();
    Signature s = Signature.getInstance("SHA224withDSA");
    try {
        s.initVerify(publicKey);
    } catch (InvalidKeyException e) {
        assumeNoException(e);
    }
    assertVerifiedForEach("v1-only-with-dsa-sha224-1.2.840.10040.4.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
    assertVerifiedForEach("v1-only-with-dsa-sha224-2.16.840.1.101.3.4.3.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
}
#method_after
@Test
public void testV1OneSignerSHA224withDSAAcceptedWithKeysTooLongForDigest() throws Exception {
    // APK signed with v1 scheme only, one signer
    // OpenJDK's default implementation of Signature.SHA224withDSA refuses to verify signatures
    // created with keys too long for the digest used. Android Package Manager does not reject
    // such signatures. We thus skip this test if Signature.SHA224withDSA exhibits this issue.
    PublicKey publicKey = Resources.toCertificate(getClass(), "dsa-2048.x509.pem").getPublicKey();
    Signature s = Signature.getInstance("SHA224withDSA");
    try {
        s.initVerify(publicKey);
    } catch (InvalidKeyException e) {
        assumeNoException(e);
    }
    assertVerifiedForEach("v1-only-with-dsa-sha224-1.2.840.10040.4.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
    assertVerifiedForEach("v1-only-with-dsa-sha224-2.16.840.1.101.3.4.3.1-%s.apk", DSA_KEY_NAMES_2048_AND_LARGER);
}
#end_block

#method_before
private ApkVerifier.Result verify(String apkFilenameInResources) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    return verify(apkFilenameInResources, null);
}
#method_after
private ApkVerifier.Result verify(String apkFilenameInResources) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    return verify(apkFilenameInResources, null, null);
}
#end_block

#method_before
private ApkVerifier.Result verifyForMinSdkVersion(String apkFilenameInResources, int minSdkVersion) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    return verify(apkFilenameInResources, minSdkVersion);
}
#method_after
private ApkVerifier.Result verifyForMinSdkVersion(String apkFilenameInResources, int minSdkVersion) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    return verify(apkFilenameInResources, minSdkVersion, null);
}
#end_block

#method_before
private ApkVerifier.Result verify(String apkFilenameInResources, Integer minSdkVersionOverride) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    byte[] apkBytes = getResourceContents(apkFilenameInResources);
    ApkVerifier.Builder builder = new ApkVerifier.Builder(DataSources.asDataSource(ByteBuffer.wrap(apkBytes)));
    if (minSdkVersionOverride != null) {
        builder.setMinCheckedPlatformVersion(minSdkVersionOverride);
    }
    return builder.build().verify();
}
#method_after
private ApkVerifier.Result verify(String apkFilenameInResources, Integer minSdkVersionOverride, Integer maxSdkVersionOverride) throws IOException, ApkFormatException, NoSuchAlgorithmException {
    byte[] apkBytes = Resources.toByteArray(getClass(), apkFilenameInResources);
    ApkVerifier.Builder builder = new ApkVerifier.Builder(DataSources.asDataSource(ByteBuffer.wrap(apkBytes)));
    if (minSdkVersionOverride != null) {
        builder.setMinCheckedPlatformVersion(minSdkVersionOverride);
    }
    if (maxSdkVersionOverride != null) {
        builder.setMaxCheckedPlatformVersion(maxSdkVersionOverride);
    }
    return builder.build().verify();
}
#end_block

#method_before
private static void assertVerified(ApkVerifier.Result result) {
    if (result.isVerified()) {
        return;
    }
    StringBuilder msg = new StringBuilder();
    for (IssueWithParams issue : result.getErrors()) {
        if (msg.length() > 0) {
            msg.append('\n');
        }
        msg.append(issue);
    }
    for (ApkVerifier.Result.V1SchemeSignerInfo signer : result.getV1SchemeSigners()) {
        String signerName = signer.getName();
        for (IssueWithParams issue : signer.getErrors()) {
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("JAR signer ").append(signerName).append(": ").append(issue);
        }
    }
    for (ApkVerifier.Result.V2SchemeSignerInfo signer : result.getV2SchemeSigners()) {
        String signerName = "signer #" + (signer.getIndex() + 1);
        for (IssueWithParams issue : signer.getErrors()) {
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("APK Signature Scheme v2 signer ").append(signerName).append(": ").append(issue);
        }
    }
    fail("APK did not verify: " + msg);
}
#method_after
static void assertVerified(ApkVerifier.Result result) {
    if (result.isVerified()) {
        return;
    }
    StringBuilder msg = new StringBuilder();
    for (IssueWithParams issue : result.getErrors()) {
        if (msg.length() > 0) {
            msg.append('\n');
        }
        msg.append(issue);
    }
    for (ApkVerifier.Result.V1SchemeSignerInfo signer : result.getV1SchemeSigners()) {
        String signerName = signer.getName();
        for (IssueWithParams issue : signer.getErrors()) {
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("JAR signer ").append(signerName).append(": ").append(issue);
        }
    }
    for (ApkVerifier.Result.V2SchemeSignerInfo signer : result.getV2SchemeSigners()) {
        String signerName = "signer #" + (signer.getIndex() + 1);
        for (IssueWithParams issue : signer.getErrors()) {
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("APK Signature Scheme v2 signer ").append(signerName).append(": ").append(issue);
        }
    }
    fail("APK did not verify: " + msg);
}
#end_block

#method_before
private void assertVerified(String apkFilenameInResources, Integer minSdkVersionOverride) throws Exception {
    assertVerified(verify(apkFilenameInResources, minSdkVersionOverride));
}
#method_after
private void assertVerified(String apkFilenameInResources, Integer minSdkVersionOverride, Integer maxSdkVersionOverride) throws Exception {
    assertVerified(verify(apkFilenameInResources, minSdkVersionOverride, maxSdkVersionOverride));
}
#end_block

#method_before
private static void assertVerificationFailure(ApkVerifier.Result result, Issue expectedIssue) {
    if (result.isVerified()) {
        fail("APK verification succeeded instead of failing with " + expectedIssue);
        return;
    }
    StringBuilder msg = new StringBuilder();
    for (IssueWithParams issue : result.getErrors()) {
        if (expectedIssue.equals(issue.getIssue())) {
            return;
        }
        if (msg.length() > 0) {
            msg.append('\n');
        }
        msg.append(issue);
    }
    for (ApkVerifier.Result.V1SchemeSignerInfo signer : result.getV1SchemeSigners()) {
        String signerName = signer.getName();
        for (ApkVerifier.IssueWithParams issue : signer.getErrors()) {
            if (expectedIssue.equals(issue.getIssue())) {
                return;
            }
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("JAR signer ").append(signerName).append(": ").append(issue);
        }
    }
    for (ApkVerifier.Result.V2SchemeSignerInfo signer : result.getV2SchemeSigners()) {
        String signerName = "signer #" + (signer.getIndex() + 1);
        for (IssueWithParams issue : signer.getErrors()) {
            if (expectedIssue.equals(issue.getIssue())) {
                return;
            }
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("APK Signature Scheme v2 signer ").append(signerName).append(": ").append(issue);
        }
    }
    fail("APK failed verification for the wrong reason" + " . Expected: " + expectedIssue + ", actual: " + msg);
}
#method_after
static void assertVerificationFailure(ApkVerifier.Result result, Issue expectedIssue) {
    if (result.isVerified()) {
        fail("APK verification succeeded instead of failing with " + expectedIssue);
        return;
    }
    StringBuilder msg = new StringBuilder();
    for (IssueWithParams issue : result.getErrors()) {
        if (expectedIssue.equals(issue.getIssue())) {
            return;
        }
        if (msg.length() > 0) {
            msg.append('\n');
        }
        msg.append(issue);
    }
    for (ApkVerifier.Result.V1SchemeSignerInfo signer : result.getV1SchemeSigners()) {
        String signerName = signer.getName();
        for (ApkVerifier.IssueWithParams issue : signer.getErrors()) {
            if (expectedIssue.equals(issue.getIssue())) {
                return;
            }
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("JAR signer ").append(signerName).append(": ").append(issue);
        }
    }
    for (ApkVerifier.Result.V2SchemeSignerInfo signer : result.getV2SchemeSigners()) {
        String signerName = "signer #" + (signer.getIndex() + 1);
        for (IssueWithParams issue : signer.getErrors()) {
            if (expectedIssue.equals(issue.getIssue())) {
                return;
            }
            if (msg.length() > 0) {
                msg.append('\n');
            }
            msg.append("APK Signature Scheme v2 signer ").append(signerName).append(": ").append(issue);
        }
    }
    fail("APK failed verification for the wrong reason" + " . Expected: " + expectedIssue + ", actual: " + msg);
}
#end_block

#method_before
private void assertVerifiedForEach(String apkFilenamePatternInResources, String[] args) throws Exception {
    assertVerifiedForEach(apkFilenamePatternInResources, args, null);
}
#method_after
private void assertVerifiedForEach(String apkFilenamePatternInResources, String[] args) throws Exception {
    assertVerifiedForEach(apkFilenamePatternInResources, args, null, null);
}
#end_block

#method_before
private void assertVerifiedForEach(String apkFilenamePatternInResources, String[] args, Integer minSdkVersionOverride) throws Exception {
    for (String arg : args) {
        String apkFilenameInResources = String.format(Locale.US, apkFilenamePatternInResources, arg);
        assertVerified(apkFilenameInResources, minSdkVersionOverride);
    }
}
#method_after
private void assertVerifiedForEach(String apkFilenamePatternInResources, String[] args, Integer minSdkVersionOverride, Integer maxSdkVersionOverride) throws Exception {
    for (String arg : args) {
        String apkFilenameInResources = String.format(Locale.US, apkFilenamePatternInResources, arg);
        assertVerified(apkFilenameInResources, minSdkVersionOverride, maxSdkVersionOverride);
    }
}
#end_block

#method_before
private void assertVerifiedForEachForMinSdkVersion(String apkFilenameInResources, String[] args, int minSdkVersion) throws Exception {
    assertVerifiedForEach(apkFilenameInResources, args, minSdkVersion);
}
#method_after
private void assertVerifiedForEachForMinSdkVersion(String apkFilenameInResources, String[] args, int minSdkVersion) throws Exception {
    assertVerifiedForEach(apkFilenameInResources, args, minSdkVersion, null);
}
#end_block

#method_before
private final int handleAppParaForResponse(AppParamValue appParamValue, int size, HeaderSet reply, Operation op, String name) {
    byte[] misnum = new byte[1];
    ApplicationParameter ap = new ApplicationParameter();
    long folderVersionCounterbitMask = 0x0008;
    long databaseIdentifierBitMask = 0x0004;
    boolean needSendCallHistoryVersionCounters = false;
    if (isNameMatchTarget(name, MCH) || isNameMatchTarget(name, ICH) || isNameMatchTarget(name, OCH) || isNameMatchTarget(name, CCH))
        needSendCallHistoryVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask);
    boolean needSendPhonebookVersionCounters = false;
    if (isNameMatchTarget(name, PB))
        needSendPhonebookVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask);
    // So response not contain any Body header.
    if (mNeedPhonebookSize) {
        if (D)
            Log.d(TAG, "Need Phonebook size in response header.");
        mNeedPhonebookSize = false;
        byte[] pbsize = new byte[2];
        // HIGH VALUE
        pbsize[0] = (byte) ((size / 256) & 0xff);
        // LOW VALUE
        pbsize[1] = (byte) ((size % 256) & 0xff);
        ap.addAPPHeader(ApplicationParameter.TRIPLET_TAGID.PHONEBOOKSIZE_TAGID, ApplicationParameter.TRIPLET_LENGTH.PHONEBOOKSIZE_LENGTH, pbsize);
        if (mNeedNewMissedCallsNum) {
            mNeedNewMissedCallsNum = false;
            int nmnum = 0;
            ContentResolver contentResolver;
            contentResolver = mContext.getContentResolver();
            Cursor c = contentResolver.query(Calls.CONTENT_URI, null, Calls.TYPE + " = " + Calls.MISSED_TYPE + " AND " + android.provider.CallLog.Calls.NEW + " = 1", null, Calls.DEFAULT_SORT_ORDER);
            if (c != null) {
                nmnum = c.getCount();
                c.close();
            }
            nmnum = nmnum > 0 ? nmnum : 0;
            misnum[0] = (byte) nmnum;
            if (D)
                Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        }
        if (checkPbapFeatureSupport(databaseIdentifierBitMask)) {
            setDbCounters(ap);
        }
        if (needSendPhonebookVersionCounters) {
            setFolderVersionCounters(ap);
        }
        if (needSendCallHistoryVersionCounters) {
            setCallversionCounters(ap, appParamValue);
        }
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        if (D)
            Log.d(TAG, "Send back Phonebook size only, without body info! Size= " + size);
        return pushHeader(op, reply);
    }
    // header.
    if (mNeedNewMissedCallsNum) {
        if (D)
            Log.d(TAG, "Need new missed call num in response header.");
        mNeedNewMissedCallsNum = false;
        int nmnum = 0;
        ContentResolver contentResolver;
        contentResolver = mContext.getContentResolver();
        Cursor c = contentResolver.query(Calls.CONTENT_URI, null, Calls.TYPE + " = " + Calls.MISSED_TYPE + " AND " + android.provider.CallLog.Calls.NEW + " = 1", null, Calls.DEFAULT_SORT_ORDER);
        if (c != null) {
            nmnum = c.getCount();
            c.close();
        }
        nmnum = nmnum > 0 ? nmnum : 0;
        misnum[0] = (byte) nmnum;
        if (D)
            Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        ap.addAPPHeader(ApplicationParameter.TRIPLET_TAGID.NEWMISSEDCALLS_TAGID, ApplicationParameter.TRIPLET_LENGTH.NEWMISSEDCALLS_LENGTH, misnum);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        if (D)
            Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        // together with Body
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (checkPbapFeatureSupport(databaseIdentifierBitMask)) {
        setDbCounters(ap);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (needSendPhonebookVersionCounters) {
        setFolderVersionCounters(ap);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (needSendCallHistoryVersionCounters) {
        setCallversionCounters(ap, appParamValue);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    return NEED_SEND_BODY;
}
#method_after
private final int handleAppParaForResponse(AppParamValue appParamValue, int size, HeaderSet reply, Operation op, String name) {
    byte[] misnum = new byte[1];
    ApplicationParameter ap = new ApplicationParameter();
    boolean needSendCallHistoryVersionCounters = false;
    if (isNameMatchTarget(name, MCH) || isNameMatchTarget(name, ICH) || isNameMatchTarget(name, OCH) || isNameMatchTarget(name, CCH))
        needSendCallHistoryVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask);
    boolean needSendPhonebookVersionCounters = false;
    if (isNameMatchTarget(name, PB))
        needSendPhonebookVersionCounters = checkPbapFeatureSupport(folderVersionCounterbitMask);
    // So response not contain any Body header.
    if (mNeedPhonebookSize) {
        if (D)
            Log.d(TAG, "Need Phonebook size in response header.");
        mNeedPhonebookSize = false;
        byte[] pbsize = new byte[2];
        // HIGH VALUE
        pbsize[0] = (byte) ((size / 256) & 0xff);
        // LOW VALUE
        pbsize[1] = (byte) ((size % 256) & 0xff);
        ap.addAPPHeader(ApplicationParameter.TRIPLET_TAGID.PHONEBOOKSIZE_TAGID, ApplicationParameter.TRIPLET_LENGTH.PHONEBOOKSIZE_LENGTH, pbsize);
        if (mNeedNewMissedCallsNum) {
            mNeedNewMissedCallsNum = false;
            int nmnum = 0;
            ContentResolver contentResolver;
            contentResolver = mContext.getContentResolver();
            Cursor c = contentResolver.query(Calls.CONTENT_URI, null, Calls.TYPE + " = " + Calls.MISSED_TYPE + " AND " + android.provider.CallLog.Calls.NEW + " = 1", null, Calls.DEFAULT_SORT_ORDER);
            if (c != null) {
                nmnum = c.getCount();
                c.close();
            }
            nmnum = nmnum > 0 ? nmnum : 0;
            misnum[0] = (byte) nmnum;
            if (D)
                Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        }
        if (checkPbapFeatureSupport(databaseIdentifierBitMask)) {
            setDbCounters(ap);
        }
        if (needSendPhonebookVersionCounters) {
            setFolderVersionCounters(ap);
        }
        if (needSendCallHistoryVersionCounters) {
            setCallversionCounters(ap, appParamValue);
        }
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        if (D)
            Log.d(TAG, "Send back Phonebook size only, without body info! Size= " + size);
        return pushHeader(op, reply);
    }
    // header.
    if (mNeedNewMissedCallsNum) {
        if (D)
            Log.d(TAG, "Need new missed call num in response header.");
        mNeedNewMissedCallsNum = false;
        int nmnum = 0;
        ContentResolver contentResolver;
        contentResolver = mContext.getContentResolver();
        Cursor c = contentResolver.query(Calls.CONTENT_URI, null, Calls.TYPE + " = " + Calls.MISSED_TYPE + " AND " + android.provider.CallLog.Calls.NEW + " = 1", null, Calls.DEFAULT_SORT_ORDER);
        if (c != null) {
            nmnum = c.getCount();
            c.close();
        }
        nmnum = nmnum > 0 ? nmnum : 0;
        misnum[0] = (byte) nmnum;
        if (D)
            Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        ap.addAPPHeader(ApplicationParameter.TRIPLET_TAGID.NEWMISSEDCALLS_TAGID, ApplicationParameter.TRIPLET_LENGTH.NEWMISSEDCALLS_LENGTH, misnum);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        if (D)
            Log.d(TAG, "handleAppParaForResponse(): mNeedNewMissedCallsNum=true,  num= " + nmnum);
        // together with Body
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (checkPbapFeatureSupport(databaseIdentifierBitMask)) {
        setDbCounters(ap);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (needSendPhonebookVersionCounters) {
        setFolderVersionCounters(ap);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    if (needSendCallHistoryVersionCounters) {
        setCallversionCounters(ap, appParamValue);
        reply.setHeader(HeaderSet.APPLICATION_PARAMETER, ap.getAPPparam());
        try {
            op.sendHeaders(reply);
        } catch (IOException e) {
            Log.e(TAG, e.toString());
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
    }
    return NEED_SEND_BODY;
}
#end_block

#method_before
private byte[] getPBPrimaryFolderVersion() {
    long primaryVcMsb = 0;
    ByteBuffer pvc = ByteBuffer.allocate(16);
    pvc.putLong(primaryVcMsb);
    Log.d(TAG, "BluetoothPbapUtils.primaryVersionCounter is " + BluetoothPbapUtils.primaryVersionCounter);
    pvc.putLong(BluetoothPbapUtils.primaryVersionCounter);
    return pvc.array();
}
#method_after
private byte[] getPBPrimaryFolderVersion() {
    long primaryVcMsb = 0;
    ByteBuffer pvc = ByteBuffer.allocate(16);
    pvc.putLong(primaryVcMsb);
    Log.d(TAG, "primaryVersionCounter is " + BluetoothPbapUtils.primaryVersionCounter);
    pvc.putLong(BluetoothPbapUtils.primaryVersionCounter);
    return pvc.array();
}
#end_block

#method_before
private byte[] getPBSecondaryFolderVersion() {
    long secondaryVcMsb = 0;
    ByteBuffer svc = ByteBuffer.allocate(16);
    svc.putLong(secondaryVcMsb);
    Log.d(TAG, "BluetoothPbapUtils.secondaryVersionCounter is " + BluetoothPbapUtils.secondaryVersionCounter);
    svc.putLong(BluetoothPbapUtils.secondaryVersionCounter);
    return svc.array();
}
#method_after
private byte[] getPBSecondaryFolderVersion() {
    long secondaryVcMsb = 0;
    ByteBuffer svc = ByteBuffer.allocate(16);
    svc.putLong(secondaryVcMsb);
    Log.d(TAG, "secondaryVersionCounter is " + BluetoothPbapUtils.secondaryVersionCounter);
    svc.putLong(BluetoothPbapUtils.secondaryVersionCounter);
    return svc.array();
}
#end_block

#method_before
byte[] getCallHistoryPrimaryFolderVersion(final int type) {
    final Uri myUri = CallLog.Calls.CONTENT_URI;
    String selection = BluetoothPbapObexServer.createSelectionPara(type);
    selection = selection + " AND date >= " + LAST_FETCHED_TIME_STAMP;
    Log.d(TAG, "LAST_FETCHED_TIME_STAMP is " + LAST_FETCHED_TIME_STAMP);
    Cursor callCursor = null;
    long count = 0;
    long primaryVcMsb = 0;
    ArrayList<String> list = new ArrayList<String>();
    try {
        callCursor = mResolver.query(myUri, null, selection, null, null);
        while (callCursor != null && callCursor.moveToNext()) {
            count = count + 1;
        }
    } catch (Exception e) {
        Log.e(TAG, "exception while fetching callHistory pvc");
    } finally {
        if (callCursor != null) {
            callCursor.close();
            callCursor = null;
        }
    }
    LAST_FETCHED_TIME_STAMP = System.currentTimeMillis();
    Log.d(TAG, "getCallHistoryPrimaryFolderVersion count is " + count + " type is " + type);
    ByteBuffer pvc = ByteBuffer.allocate(16);
    pvc.putLong(primaryVcMsb);
    Log.d(TAG, "BluetoothPbapUtils.primaryVersionCounter is " + BluetoothPbapUtils.primaryVersionCounter);
    pvc.putLong(count);
    return pvc.array();
}
#method_after
byte[] getCallHistoryPrimaryFolderVersion(final int type) {
    final Uri myUri = CallLog.Calls.CONTENT_URI;
    String selection = BluetoothPbapObexServer.createSelectionPara(type);
    selection = selection + " AND date >= " + LAST_FETCHED_TIME_STAMP;
    Log.d(TAG, "LAST_FETCHED_TIME_STAMP is " + LAST_FETCHED_TIME_STAMP);
    Cursor callCursor = null;
    long count = 0;
    long primaryVcMsb = 0;
    ArrayList<String> list = new ArrayList<String>();
    try {
        callCursor = mResolver.query(myUri, null, selection, null, null);
        while (callCursor != null && callCursor.moveToNext()) {
            count = count + 1;
        }
    } catch (Exception e) {
        Log.e(TAG, "exception while fetching callHistory pvc");
    } finally {
        if (callCursor != null) {
            callCursor.close();
            callCursor = null;
        }
    }
    LAST_FETCHED_TIME_STAMP = System.currentTimeMillis();
    Log.d(TAG, "getCallHistoryPrimaryFolderVersion count is " + count + " type is " + type);
    ByteBuffer pvc = ByteBuffer.allocate(16);
    pvc.putLong(primaryVcMsb);
    Log.d(TAG, "primaryVersionCounter is " + BluetoothPbapUtils.primaryVersionCounter);
    pvc.putLong(count);
    return pvc.array();
}
#end_block

#method_before
final int composeAndSendSelectedCallLogVcards(final int type, Operation op, final int startPoint, final int endPoint, final boolean vcardType21, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] vcardselector, String vcardselectorop, boolean vcardselect) {
    if (startPoint < 1 || startPoint > endPoint) {
        Log.e(TAG, "internal error: startPoint or endPoint is not correct.");
        return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
    }
    String typeSelection = BluetoothPbapObexServer.createSelectionPara(type);
    final Uri myUri = CallLog.Calls.CONTENT_URI;
    final String[] CALLLOG_PROJECTION = new String[] { // 0
    CallLog.Calls._ID };
    final int ID_COLUMN_INDEX = 0;
    Cursor callsCursor = null;
    long startPointId = 0;
    long endPointId = 0;
    try {
        // Need test to see if order by _ID is ok here, or by date?
        callsCursor = mResolver.query(myUri, CALLLOG_PROJECTION, typeSelection, null, CALLLOG_SORT_ORDER);
        if (callsCursor != null) {
            callsCursor.moveToPosition(startPoint - 1);
            startPointId = callsCursor.getLong(ID_COLUMN_INDEX);
            if (V)
                Log.v(TAG, "Call Log query startPointId = " + startPointId);
            if (startPoint == endPoint) {
                endPointId = startPointId;
            } else {
                callsCursor.moveToPosition(endPoint - 1);
                endPointId = callsCursor.getLong(ID_COLUMN_INDEX);
            }
            if (V)
                Log.v(TAG, "Call log query endPointId = " + endPointId);
        }
    } catch (CursorWindowAllocationException e) {
        Log.e(TAG, "CursorWindowAllocationException while composing calllog vcards");
    } finally {
        if (callsCursor != null) {
            callsCursor.close();
            callsCursor = null;
        }
    }
    String recordSelection;
    if (startPoint == endPoint) {
        recordSelection = Calls._ID + "=" + startPointId;
    } else {
        // The query to call table is by "_id DESC" order, so change
        // correspondingly.
        recordSelection = Calls._ID + ">=" + endPointId + " AND " + Calls._ID + "<=" + startPointId;
    }
    String selection;
    if (typeSelection == null) {
        selection = recordSelection;
    } else {
        selection = "(" + typeSelection + ") AND (" + recordSelection + ")";
    }
    if (V)
        Log.v(TAG, "Call log query selection is: " + selection);
    /*return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody,
            pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop);*/
    return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop, vcardselect);
}
#method_after
final int composeAndSendSelectedCallLogVcards(final int type, Operation op, final int startPoint, final int endPoint, final boolean vcardType21, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] vcardselector, String vcardselectorop, boolean vcardselect) {
    if (startPoint < 1 || startPoint > endPoint) {
        Log.e(TAG, "internal error: startPoint or endPoint is not correct.");
        return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
    }
    String typeSelection = BluetoothPbapObexServer.createSelectionPara(type);
    final Uri myUri = CallLog.Calls.CONTENT_URI;
    final String[] CALLLOG_PROJECTION = new String[] { // 0
    CallLog.Calls._ID };
    final int ID_COLUMN_INDEX = 0;
    Cursor callsCursor = null;
    long startPointId = 0;
    long endPointId = 0;
    try {
        // Need test to see if order by _ID is ok here, or by date?
        callsCursor = mResolver.query(myUri, CALLLOG_PROJECTION, typeSelection, null, CALLLOG_SORT_ORDER);
        if (callsCursor != null) {
            callsCursor.moveToPosition(startPoint - 1);
            startPointId = callsCursor.getLong(ID_COLUMN_INDEX);
            if (V)
                Log.v(TAG, "Call Log query startPointId = " + startPointId);
            if (startPoint == endPoint) {
                endPointId = startPointId;
            } else {
                callsCursor.moveToPosition(endPoint - 1);
                endPointId = callsCursor.getLong(ID_COLUMN_INDEX);
            }
            if (V)
                Log.v(TAG, "Call log query endPointId = " + endPointId);
        }
    } catch (CursorWindowAllocationException e) {
        Log.e(TAG, "CursorWindowAllocationException while composing calllog vcards");
    } finally {
        if (callsCursor != null) {
            callsCursor.close();
            callsCursor = null;
        }
    }
    String recordSelection;
    if (startPoint == endPoint) {
        recordSelection = Calls._ID + "=" + startPointId;
    } else {
        // The query to call table is by "_id DESC" order, so change
        // correspondingly.
        recordSelection = Calls._ID + ">=" + endPointId + " AND " + Calls._ID + "<=" + startPointId;
    }
    String selection;
    if (typeSelection == null) {
        selection = recordSelection;
    } else {
        selection = "(" + typeSelection + ") AND (" + recordSelection + ")";
    }
    if (V)
        Log.v(TAG, "Call log query selection is: " + selection);
    return composeCallLogsAndSendSelectedVCards(op, selection, vcardType21, needSendBody, pbSize, null, ignorefilter, filter, vcardselector, vcardselectorop, vcardselect);
}
#end_block

#method_before
private final int composeContactsAndSendSelectedVCards(Operation op, final Cursor contactIdCursor, final boolean vcardType21, String ownerVCard, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] selector, String vcardselectorop) {
    long timestamp = 0;
    if (V)
        timestamp = System.currentTimeMillis();
    VCardComposer composer = null;
    VCardFilter vcardfilter = new VCardFilter(ignorefilter ? null : filter);
    PropertySelector vcardselector = new PropertySelector(selector);
    HandlerForStringBuffer buffer = null;
    try {
        // Currently only support Generic Vcard 2.1 and 3.0
        int vcardType;
        if (vcardType21) {
            vcardType = VCardConfig.VCARD_TYPE_V21_GENERIC;
        } else {
            vcardType = VCardConfig.VCARD_TYPE_V30_GENERIC;
        }
        if (!vcardfilter.isPhotoEnabled()) {
            vcardType |= VCardConfig.FLAG_REFRAIN_IMAGE_EXPORT;
        }
        // Enhancement: customize Vcard based on preferences/settings and
        // input from caller
        composer = BluetoothPbapUtils.createFilteredVCardComposer(mContext, vcardType, null);
        // End enhancement
        // BT does want PAUSE/WAIT conversion while it doesn't want the
        // other formatting
        // done by vCard library by default.
        composer.setPhoneNumberTranslationCallback(new VCardPhoneNumberTranslationCallback() {

            public String onValueReceived(String rawValue, int type, String label, boolean isPrimary) {
                // 'p' and 'w' are the standard characters for pause and
                // wait
                // (see RFC 3601)
                // so use those when exporting phone numbers via vCard.
                String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p').replace(PhoneNumberUtils.WAIT, 'w');
                return numberWithControlSequence;
            }
        });
        buffer = new HandlerForStringBuffer(op, ownerVCard);
        Log.v(TAG, "contactIdCursor size: " + contactIdCursor.getCount());
        if (!composer.initWithCallback(contactIdCursor, new EnterpriseRawContactEntitlesInfoCallback()) || !buffer.onInit(mContext)) {
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
        while (!composer.isAfterLast()) {
            if (BluetoothPbapObexServer.sIsAborted) {
                ((ServerOperation) op).isAborted = true;
                BluetoothPbapObexServer.sIsAborted = false;
                break;
            }
            String vcard = composer.createOneEntry();
            if (vcard == null) {
                Log.e(TAG, "Failed to read a contact. Error reason: " + composer.getErrorReason());
                return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
            if (V)
                Log.v(TAG, "Checking selected bits in the vcard composer" + vcard);
            if (!vcardselector.CheckVcardSelector(vcard, vcardselectorop)) {
                Log.e(TAG, "vcard selector check fail");
                vcard = null;
                pbSize--;
                continue;
            }
            Log.e(TAG, "vcard selector check pass");
            if (needSendBody == NEED_SEND_BODY) {
                vcard = vcardfilter.apply(vcard, vcardType21);
                vcard = StripTelephoneNumber(vcard);
                if (V)
                    Log.v(TAG, "vCard after cleanup: " + vcard);
                if (!buffer.onEntryCreated(vcard)) {
                    // onEntryCreate() already emits error.
                    return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            }
        }
        if (needSendBody != NEED_SEND_BODY)
            return pbSize;
    } finally {
        if (composer != null) {
            composer.terminate();
        }
        if (buffer != null) {
            buffer.onTerminate();
        }
    }
    if (V)
        Log.v(TAG, "Total vcard composing and sending out takes " + (System.currentTimeMillis() - timestamp) + " ms");
    return ResponseCodes.OBEX_HTTP_OK;
}
#method_after
private final int composeContactsAndSendSelectedVCards(Operation op, final Cursor contactIdCursor, final boolean vcardType21, String ownerVCard, int needSendBody, int pbSize, boolean ignorefilter, byte[] filter, byte[] selector, String vcardselectorop) {
    long timestamp = 0;
    if (V)
        timestamp = System.currentTimeMillis();
    VCardComposer composer = null;
    VCardFilter vcardfilter = new VCardFilter(ignorefilter ? null : filter);
    PropertySelector vcardselector = new PropertySelector(selector);
    HandlerForStringBuffer buffer = null;
    try {
        // Currently only support Generic Vcard 2.1 and 3.0
        int vcardType;
        if (vcardType21) {
            vcardType = VCardConfig.VCARD_TYPE_V21_GENERIC;
        } else {
            vcardType = VCardConfig.VCARD_TYPE_V30_GENERIC;
        }
        if (!vcardfilter.isPhotoEnabled()) {
            vcardType |= VCardConfig.FLAG_REFRAIN_IMAGE_EXPORT;
        }
        // Enhancement: customize Vcard based on preferences/settings and
        // input from caller
        composer = BluetoothPbapUtils.createFilteredVCardComposer(mContext, vcardType, null);
        // End enhancement
        /* BT does want PAUSE/WAIT conversion while it doesn't want the
             * other formatting done by vCard library by default. */
        composer.setPhoneNumberTranslationCallback(new VCardPhoneNumberTranslationCallback() {

            public String onValueReceived(String rawValue, int type, String label, boolean isPrimary) {
                /* 'p' and 'w' are the standard characters for pause and wait
                     * (see RFC 3601) so use those when exporting phone numbers via vCard.*/
                String numberWithControlSequence = rawValue.replace(PhoneNumberUtils.PAUSE, 'p').replace(PhoneNumberUtils.WAIT, 'w');
                return numberWithControlSequence;
            }
        });
        buffer = new HandlerForStringBuffer(op, ownerVCard);
        Log.v(TAG, "contactIdCursor size: " + contactIdCursor.getCount());
        if (!composer.initWithCallback(contactIdCursor, new EnterpriseRawContactEntitlesInfoCallback()) || !buffer.onInit(mContext)) {
            return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
        while (!composer.isAfterLast()) {
            if (BluetoothPbapObexServer.sIsAborted) {
                ((ServerOperation) op).isAborted = true;
                BluetoothPbapObexServer.sIsAborted = false;
                break;
            }
            String vcard = composer.createOneEntry();
            if (vcard == null) {
                Log.e(TAG, "Failed to read a contact. Error reason: " + composer.getErrorReason());
                return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
            if (V)
                Log.v(TAG, "Checking selected bits in the vcard composer" + vcard);
            if (!vcardselector.CheckVcardSelector(vcard, vcardselectorop)) {
                Log.e(TAG, "vcard selector check fail");
                vcard = null;
                pbSize--;
                continue;
            }
            Log.e(TAG, "vcard selector check pass");
            if (needSendBody == NEED_SEND_BODY) {
                vcard = vcardfilter.apply(vcard, vcardType21);
                vcard = StripTelephoneNumber(vcard);
                if (V)
                    Log.v(TAG, "vCard after cleanup: " + vcard);
                if (!buffer.onEntryCreated(vcard)) {
                    // onEntryCreate() already emits error.
                    return ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            }
        }
        if (needSendBody != NEED_SEND_BODY)
            return pbSize;
    } finally {
        if (composer != null) {
            composer.terminate();
        }
        if (buffer != null) {
            buffer.onTerminate();
        }
    }
    if (V)
        Log.v(TAG, "Total vcard composing and sending out takes " + (System.currentTimeMillis() - timestamp) + " ms");
    return ResponseCodes.OBEX_HTTP_OK;
}
#end_block

#method_before
private boolean checkprop(String vcard, String prop) {
    String[] lines = vcard.split(SEPARATOR);
    boolean isPresent = false;
    for (String line : lines) {
        if (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("=")) {
            String currentProp = line.split("[;:]")[0];
            if (prop.equals(currentProp)) {
                Log.e(TAG, "bit.prop.equals current prop :" + prop);
                isPresent = true;
                return isPresent;
            }
        }
    }
    return isPresent;
}
#method_after
private boolean checkprop(String vcard, String prop) {
    String[] lines = vcard.split(SEPARATOR);
    boolean isPresent = false;
    for (String line : lines) {
        if (!Character.isWhitespace(line.charAt(0)) && !line.startsWith("=")) {
            String currentProp = line.split("[;:]")[0];
            if (prop.equals(currentProp)) {
                Log.d(TAG, "bit.prop.equals current prop :" + prop);
                isPresent = true;
                return isPresent;
            }
        }
    }
    return isPresent;
}
#end_block

#method_before
private boolean CheckVcardSelector(String vcard, String vcardselectorop) {
    boolean selectedIn = true;
    for (PropertyMask bit : PropertyMask.values()) {
        if (checkbit(bit.pos, selector)) {
            Log.e(TAG, "checking for prop :" + bit.prop);
            if (vcardselectorop.equals("0")) {
                if (checkprop(vcard, bit.prop)) {
                    Log.e(TAG, "bit.prop.equals current prop :" + bit.prop);
                    selectedIn = true;
                    break;
                } else {
                    selectedIn = false;
                }
            } else if (vcardselectorop.equals("1")) {
                if (!checkprop(vcard, bit.prop)) {
                    Log.e(TAG, "bit.prop.notequals current prop" + bit.prop);
                    selectedIn = false;
                    return selectedIn;
                } else {
                    selectedIn = true;
                }
            }
        }
    }
    return selectedIn;
}
#method_after
private boolean CheckVcardSelector(String vcard, String vcardselectorop) {
    boolean selectedIn = true;
    for (PropertyMask bit : PropertyMask.values()) {
        if (checkbit(bit.pos, selector)) {
            Log.d(TAG, "checking for prop :" + bit.prop);
            if (vcardselectorop.equals("0")) {
                if (checkprop(vcard, bit.prop)) {
                    Log.d(TAG, "bit.prop.equals current prop :" + bit.prop);
                    selectedIn = true;
                    break;
                } else {
                    selectedIn = false;
                }
            } else if (vcardselectorop.equals("1")) {
                if (!checkprop(vcard, bit.prop)) {
                    Log.d(TAG, "bit.prop.notequals current prop" + bit.prop);
                    selectedIn = false;
                    return selectedIn;
                } else {
                    selectedIn = true;
                }
            }
        }
    }
    return selectedIn;
}
#end_block

#method_before
private synchronized void setState(int state, int result) {
    if (state != mState) {
        if (DEBUG)
            Log.d(TAG, "Pbap state " + mState + " -> " + state + ", result = " + result);
        int prevState = mState;
        mState = state;
        Intent intent = new Intent(BluetoothPbap.PBAP_STATE_CHANGED_ACTION);
        intent.putExtra(BluetoothPbap.PBAP_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothPbap.PBAP_STATE, mState);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        sendBroadcast(intent, BLUETOOTH_PERM);
    }
}
#method_after
private synchronized void setState(int state, int result) {
    if (state != mState) {
        if (DEBUG)
            Log.d(TAG, "Pbap state " + mState + " -> " + state + ", result = " + result);
        int prevState = mState;
        mState = state;
        Intent intent = new Intent(BluetoothPbap.PBAP_STATE_CHANGED_ACTION);
        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothProfile.EXTRA_STATE, mState);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        sendBroadcast(intent, BLUETOOTH_PERM);
    }
}
#end_block

#method_before
synchronized private void startSocketListeners() {
    if (DEBUG)
        Log.d(TAG, "startsocketListener");
    if (mServerSession != null) {
        if (DEBUG)
            Log.d(TAG, "mServerSession exists - shutting it down...");
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(TAG, "Failed to start the listeners");
            return;
        }
        SdpManager sdpManager = SdpManager.getDefaultManager();
        if (sdpManager == null) {
            Log.e(TAG, "Failed to start the listeners sdp null ");
            return;
        }
        if (mAdapter != null && mSdpHandle >= 0) {
            Log.d(TAG, "Removing SDP record for PBAP with SDP handle:" + mSdpHandle);
            boolean status = sdpManager.removeSdpRecord(mSdpHandle);
            Log.d(TAG, "RemoveSDPrecord returns " + status);
            mSdpHandle = -1;
        }
        mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord("OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES);
        // fetch DbIdentifier to check if significant change has happened to Db
        getPbapDbParams();
        if (DEBUG)
            Log.d(TAG, "PBAP server with handle:" + mSdpHandle);
    }
}
#method_after
synchronized private void startSocketListeners() {
    if (DEBUG)
        Log.d(TAG, "startsocketListener");
    if (mServerSession != null) {
        if (DEBUG)
            Log.d(TAG, "mServerSession exists - shutting it down...");
        mServerSession.close();
        mServerSession = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mServerSockets.prepareForNewConnect();
    } else {
        mServerSockets = ObexServerSockets.create(this);
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(TAG, "Failed to start the listeners");
            return;
        }
        SdpManager sdpManager = SdpManager.getDefaultManager();
        if (sdpManager == null) {
            Log.e(TAG, "Failed to start the listeners sdp null ");
            return;
        }
        if (mAdapter != null && mSdpHandle >= 0) {
            Log.d(TAG, "Removing SDP record for PBAP with SDP handle:" + mSdpHandle);
            boolean status = sdpManager.removeSdpRecord(mSdpHandle);
            Log.d(TAG, "RemoveSDPrecord returns " + status);
            mSdpHandle = -1;
        }
        mSdpHandle = SdpManager.getDefaultManager().createPbapPseRecord("OBEX Phonebook Access Server", mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm(), SDP_PBAP_SERVER_VERSION, SDP_PBAP_SUPPORTED_REPOSITORIES, SDP_PBAP_SUPPORTED_FEATURES);
        // fetch Pbap Params to check if significant change has happened to Database
        BluetoothPbapUtils.fetchPbapParams(mContext);
        if (DEBUG)
            Log.d(TAG, "PBAP server with handle:" + mSdpHandle);
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (mRemoteDevice == null || socket == null) {
        Log.i(TAG, "mRemoteDevice :" + mRemoteDevice + " socket :" + socket);
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG)
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE)
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        // In case car kit time out and try to use HFP for
        // phonebook
        // access, while UI still there waiting for user to
        // confirm
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    // We will continue the process when we receive
    // BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app.
    }
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice remoteDevice, BluetoothSocket socket) {
    mRemoteDevice = remoteDevice;
    if (mRemoteDevice == null || socket == null) {
        Log.i(TAG, "mRemoteDevice :" + mRemoteDevice + " socket :" + socket);
        return false;
    }
    mConnSocket = socket;
    sRemoteDeviceName = mRemoteDevice.getName();
    // In case getRemoteName failed and return null
    if (TextUtils.isEmpty(sRemoteDeviceName)) {
        sRemoteDeviceName = getString(R.string.defaultname);
    }
    int permission = mRemoteDevice.getPhonebookAccessPermission();
    if (DEBUG)
        Log.d(TAG, "getPhonebookAccessPermission() = " + permission);
    if (permission == BluetoothDevice.ACCESS_ALLOWED) {
        try {
            startObexServerSession();
        } catch (IOException ex) {
            Log.e(TAG, "Caught exception starting obex server session" + ex.toString());
        }
        if (!BluetoothPbapUtils.contactsLoaded) {
            mSessionStatusHandler.sendMessage(mSessionStatusHandler.obtainMessage(LOAD_CONTACTS));
        }
    } else if (permission == BluetoothDevice.ACCESS_REJECTED) {
        if (DEBUG) {
            Log.d(TAG, "incoming connection rejected from: " + sRemoteDeviceName + " automatically as already rejected device");
        }
        return false;
    } else {
        // permission == BluetoothDevice.ACCESS_UNKNOWN
        // Send an Intent to Settings app to ask user preference.
        Intent intent = new Intent(BluetoothDevice.ACTION_CONNECTION_ACCESS_REQUEST);
        intent.setClassName(ACCESS_AUTHORITY_PACKAGE, ACCESS_AUTHORITY_CLASS);
        intent.putExtra(BluetoothDevice.EXTRA_ACCESS_REQUEST_TYPE, BluetoothDevice.REQUEST_TYPE_PHONEBOOK_ACCESS);
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevice);
        intent.putExtra(BluetoothDevice.EXTRA_PACKAGE_NAME, getPackageName());
        mIsWaitingAuthorization = true;
        sendOrderedBroadcast(intent, BLUETOOTH_ADMIN_PERM);
        if (VERBOSE)
            Log.v(TAG, "waiting for authorization for connection from: " + sRemoteDeviceName);
        /* In case car kit time out and try to use HFP for phonebook
             * access, while UI still there waiting for user to confirm */
        mSessionStatusHandler.sendMessageDelayed(mSessionStatusHandler.obtainMessage(USER_TIMEOUT), USER_CONFIRM_TIMEOUT_VALUE);
    /* We will continue the process when we receive
             * BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY from Settings app. */
    }
    return true;
}
#end_block

#method_before
protected static void fetchPbapParams(Context ctx) {
    SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(ctx);
    long timeStamp = Calendar.getInstance().getTimeInMillis();
    BluetoothPbapUtils.mDbIdentifier.set(timeStamp);
    BluetoothPbapUtils.primaryVersionCounter = pref.getLong("primary", 0);
    BluetoothPbapUtils.secondaryVersionCounter = pref.getLong("secondary", 0);
    BluetoothPbapUtils.totalFields = pref.getLong("totalContacts", 0);
    BluetoothPbapUtils.contactsLastUpdated = pref.getLong("lastUpdatedTimestamp", timeStamp);
    BluetoothPbapUtils.totalFields = pref.getLong("totalFields", 0);
    BluetoothPbapUtils.totalSvcFields = pref.getLong("totalSvcFields", 0);
    if (V)
        Log.v(TAG, " fetchPbapParams " + pref.getAll());
}
#method_after
protected static void fetchPbapParams(Context ctx) {
    SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(ctx);
    long timeStamp = Calendar.getInstance().getTimeInMillis();
    BluetoothPbapUtils.mDbIdentifier.set(pref.getLong("mDbIdentifier", timeStamp));
    BluetoothPbapUtils.primaryVersionCounter = pref.getLong("primary", 0);
    BluetoothPbapUtils.secondaryVersionCounter = pref.getLong("secondary", 0);
    BluetoothPbapUtils.totalFields = pref.getLong("totalContacts", 0);
    BluetoothPbapUtils.contactsLastUpdated = pref.getLong("lastUpdatedTimestamp", timeStamp);
    BluetoothPbapUtils.totalFields = pref.getLong("totalFields", 0);
    BluetoothPbapUtils.totalSvcFields = pref.getLong("totalSvcFields", 0);
    if (V)
        Log.v(TAG, " fetchPbapParams " + pref.getAll());
}
#end_block

#method_before
protected static void updateSecondaryVersionCounter(Context mContext, Handler mHandler) {
    try {
        /* updated_list stores list of contacts which are added/updated after
             * the time when contacts were last updated. (contactsLastUpdated
             * indicates the time when contact/contacts were last updated and
             * corresponding changes were reflected in Folder Version Counters).*/
        ArrayList<String> updated_list = new ArrayList<String>();
        HashSet<String> currentContactSet = new HashSet<String>();
        int currentContactCount = 0;
        String[] projection = { Contacts._ID, Contacts.CONTACT_LAST_UPDATED_TIMESTAMP };
        Cursor c = mContext.getContentResolver().query(Contacts.CONTENT_URI, projection, null, null, null);
        if (c == null) {
            Log.d(TAG, "Failed to fetch data from contact database");
            return;
        }
        while (c.moveToNext()) {
            String c_id = c.getString(0);
            long lastUpdatedTime = c.getLong(1);
            if (lastUpdatedTime > contactsLastUpdated) {
                updated_list.add(c_id);
            }
            currentContactSet.add(c_id);
        }
        currentContactCount = c.getCount();
        c.close();
        if (V)
            Log.v(TAG, "updated list =" + updated_list);
        String[] dataProjection = { Data.CONTACT_ID, Data.DATA1, Data.MIMETYPE };
        String whereClause = Data.CONTACT_ID + "=?";
        /* code to check if new contact/contacts are added */
        if (currentContactCount > totalContacts) {
            for (int i = 0; i < updated_list.size(); i++) {
                String[] selectionArgs = { updated_list.get(i) };
                fetchAndSetContacts(mContext, mHandler, dataProjection, whereClause, selectionArgs, false);
                secondaryVersionCounter++;
                primaryVersionCounter++;
                totalContacts = currentContactCount;
            }
        /* When contact/contacts are deleted */
        } else if (currentContactCount < totalContacts) {
            totalContacts = currentContactCount;
            ArrayList<String> svcFields = new ArrayList<String>(Arrays.asList(StructuredName.CONTENT_ITEM_TYPE, Phone.CONTENT_ITEM_TYPE, Email.CONTENT_ITEM_TYPE, StructuredPostal.CONTENT_ITEM_TYPE));
            HashSet<String> deletedContacts = new HashSet<String>(ContactSet);
            deletedContacts.removeAll(currentContactSet);
            primaryVersionCounter += deletedContacts.size();
            secondaryVersionCounter += deletedContacts.size();
            if (V)
                Log.v(TAG, "Deleted Contacts : " + deletedContacts);
            // to decrement totalFields and totalSvcFields count
            for (String deletedContact : deletedContacts) {
                ContactSet.remove(deletedContact);
                String[] selectionArgs = { deletedContact };
                Cursor dataCursor = mContext.getContentResolver().query(Data.CONTENT_URI, dataProjection, whereClause, selectionArgs, null);
                if (dataCursor == null) {
                    Log.d(TAG, "Failed to fetch data from contact database");
                    return;
                }
                while (dataCursor.moveToNext()) {
                    if (svcFields.contains(dataCursor.getString(dataCursor.getColumnIndex(Data.MIMETYPE))))
                        totalSvcFields--;
                    totalFields--;
                }
                dataCursor.close();
            }
        /* When contacts are updated. i.e. Fields of existing contacts are
                 * added/updated/deleted */
        } else {
            for (int i = 0; i < updated_list.size(); i++) {
                primaryVersionCounter++;
                ArrayList<String> phone_tmp = new ArrayList<String>();
                ArrayList<String> email_tmp = new ArrayList<String>();
                ArrayList<String> address_tmp = new ArrayList<String>();
                String name_tmp = null, updatedCID = updated_list.get(i);
                boolean updated = false;
                String[] selectionArgs = { updated_list.get(i) };
                Cursor dataCursor = mContext.getContentResolver().query(Data.CONTENT_URI, dataProjection, whereClause, selectionArgs, null);
                if (dataCursor == null) {
                    Log.d(TAG, "Failed to fetch data from contact database");
                    return;
                }
                // fetch all updated contacts and compare with cached copy of contacts
                int indexData = dataCursor.getColumnIndex(Data.DATA1);
                int indexMimeType = dataCursor.getColumnIndex(Data.MIMETYPE);
                String data;
                String mime_type;
                while (dataCursor.moveToNext()) {
                    data = dataCursor.getString(indexData);
                    mime_type = dataCursor.getString(indexMimeType);
                    switch(mime_type) {
                        case Email.CONTENT_ITEM_TYPE:
                            email_tmp.add(data);
                            break;
                        case Phone.CONTENT_ITEM_TYPE:
                            phone_tmp.add(data);
                            break;
                        case StructuredPostal.CONTENT_ITEM_TYPE:
                            address_tmp.add(data);
                            break;
                        case StructuredName.CONTENT_ITEM_TYPE:
                            name_tmp = new String(data);
                            break;
                    }
                }
                dataCursor.close();
                if ((name_tmp == null && name.get(updatedCID) != null) || (name_tmp != null && name.get(updatedCID) == null) || (!(name_tmp == null && name.get(updatedCID) == null) && !name_tmp.equals(name.get(updatedCID)))) {
                    updated = true;
                } else if (checkFieldUpdates(phone.get(updatedCID), phone_tmp)) {
                    updated = true;
                } else if (checkFieldUpdates(email.get(updatedCID), email_tmp)) {
                    updated = true;
                } else if (checkFieldUpdates(address.get(updatedCID), address_tmp)) {
                    updated = true;
                }
                if (updated) {
                    secondaryVersionCounter++;
                    name.put(updatedCID, name_tmp);
                    phone.put(updatedCID, phone_tmp);
                    email.put(updatedCID, email_tmp);
                    address.put(updatedCID, address_tmp);
                }
            }
        }
        Log.d(TAG, "primaryVersionCounter = " + primaryVersionCounter + ", secondaryVersionCounter=" + secondaryVersionCounter);
        // check if Primary/Secondary version Counter has rolled over
        if (secondaryVersionCounter < 0 || primaryVersionCounter < 0)
            mHandler.sendMessage(mHandler.obtainMessage(BluetoothPbapService.ROLLOVER_COUNTERS));
    } catch (Exception e) {
        Log.e(TAG, "Exception while updating secondary version counter:" + e);
    }
}
#method_after
protected static void updateSecondaryVersionCounter(Context mContext, Handler mHandler) {
    try {
        /* updated_list stores list of contacts which are added/updated after
             * the time when contacts were last updated. (contactsLastUpdated
             * indicates the time when contact/contacts were last updated and
             * corresponding changes were reflected in Folder Version Counters).*/
        ArrayList<String> updated_list = new ArrayList<String>();
        HashSet<String> currentContactSet = new HashSet<String>();
        int currentContactCount = 0;
        String[] projection = { Contacts._ID, Contacts.CONTACT_LAST_UPDATED_TIMESTAMP };
        Cursor c = mContext.getContentResolver().query(Contacts.CONTENT_URI, projection, null, null, null);
        if (c == null) {
            Log.d(TAG, "Failed to fetch data from contact database");
            return;
        }
        while (c.moveToNext()) {
            String contactId = c.getString(0);
            long lastUpdatedTime = c.getLong(1);
            if (lastUpdatedTime > contactsLastUpdated) {
                updated_list.add(contactId);
            }
            currentContactSet.add(contactId);
        }
        currentContactCount = c.getCount();
        c.close();
        if (V)
            Log.v(TAG, "updated list =" + updated_list);
        String[] dataProjection = { Data.CONTACT_ID, Data.DATA1, Data.MIMETYPE };
        String whereClause = Data.CONTACT_ID + "=?";
        /* code to check if new contact/contacts are added */
        if (currentContactCount > totalContacts) {
            for (int i = 0; i < updated_list.size(); i++) {
                String[] selectionArgs = { updated_list.get(i) };
                fetchAndSetContacts(mContext, mHandler, dataProjection, whereClause, selectionArgs, false);
                secondaryVersionCounter++;
                primaryVersionCounter++;
                totalContacts = currentContactCount;
            }
        /* When contact/contacts are deleted */
        } else if (currentContactCount < totalContacts) {
            totalContacts = currentContactCount;
            ArrayList<String> svcFields = new ArrayList<String>(Arrays.asList(StructuredName.CONTENT_ITEM_TYPE, Phone.CONTENT_ITEM_TYPE, Email.CONTENT_ITEM_TYPE, StructuredPostal.CONTENT_ITEM_TYPE));
            HashSet<String> deletedContacts = new HashSet<String>(ContactSet);
            deletedContacts.removeAll(currentContactSet);
            primaryVersionCounter += deletedContacts.size();
            secondaryVersionCounter += deletedContacts.size();
            if (V)
                Log.v(TAG, "Deleted Contacts : " + deletedContacts);
            // to decrement totalFields and totalSvcFields count
            for (String deletedContact : deletedContacts) {
                ContactSet.remove(deletedContact);
                String[] selectionArgs = { deletedContact };
                Cursor dataCursor = mContext.getContentResolver().query(Data.CONTENT_URI, dataProjection, whereClause, selectionArgs, null);
                if (dataCursor == null) {
                    Log.d(TAG, "Failed to fetch data from contact database");
                    return;
                }
                while (dataCursor.moveToNext()) {
                    if (svcFields.contains(dataCursor.getString(dataCursor.getColumnIndex(Data.MIMETYPE))))
                        totalSvcFields--;
                    totalFields--;
                }
                dataCursor.close();
            }
        /* When contacts are updated. i.e. Fields of existing contacts are
                 * added/updated/deleted */
        } else {
            for (int i = 0; i < updated_list.size(); i++) {
                primaryVersionCounter++;
                ArrayList<String> phone_tmp = new ArrayList<String>();
                ArrayList<String> email_tmp = new ArrayList<String>();
                ArrayList<String> address_tmp = new ArrayList<String>();
                String name_tmp = null, updatedCID = updated_list.get(i);
                boolean updated = false;
                String[] selectionArgs = { updated_list.get(i) };
                Cursor dataCursor = mContext.getContentResolver().query(Data.CONTENT_URI, dataProjection, whereClause, selectionArgs, null);
                if (dataCursor == null) {
                    Log.d(TAG, "Failed to fetch data from contact database");
                    return;
                }
                // fetch all updated contacts and compare with cached copy of contacts
                int indexData = dataCursor.getColumnIndex(Data.DATA1);
                int indexMimeType = dataCursor.getColumnIndex(Data.MIMETYPE);
                String data;
                String mimeType;
                while (dataCursor.moveToNext()) {
                    data = dataCursor.getString(indexData);
                    mimeType = dataCursor.getString(indexMimeType);
                    switch(mimeType) {
                        case Email.CONTENT_ITEM_TYPE:
                            email_tmp.add(data);
                            break;
                        case Phone.CONTENT_ITEM_TYPE:
                            phone_tmp.add(data);
                            break;
                        case StructuredPostal.CONTENT_ITEM_TYPE:
                            address_tmp.add(data);
                            break;
                        case StructuredName.CONTENT_ITEM_TYPE:
                            name_tmp = new String(data);
                            break;
                    }
                }
                ContactData cData = new ContactData(name_tmp, phone_tmp, email_tmp, address_tmp);
                dataCursor.close();
                if ((name_tmp == null && contactDataset.get(updatedCID).name != null) || (name_tmp != null && contactDataset.get(updatedCID).name == null) || (!(name_tmp == null && contactDataset.get(updatedCID).name == null) && !name_tmp.equals(contactDataset.get(updatedCID).name))) {
                    updated = true;
                } else if (checkFieldUpdates(contactDataset.get(updatedCID).phone, phone_tmp)) {
                    updated = true;
                } else if (checkFieldUpdates(contactDataset.get(updatedCID).email, email_tmp)) {
                    updated = true;
                } else if (checkFieldUpdates(contactDataset.get(updatedCID).address, address_tmp)) {
                    updated = true;
                }
                if (updated) {
                    secondaryVersionCounter++;
                    contactDataset.put(updatedCID, cData);
                }
            }
        }
        Log.d(TAG, "primaryVersionCounter = " + primaryVersionCounter + ", secondaryVersionCounter=" + secondaryVersionCounter);
        // check if Primary/Secondary version Counter has rolled over
        if (secondaryVersionCounter < 0 || primaryVersionCounter < 0)
            mHandler.sendMessage(mHandler.obtainMessage(BluetoothPbapService.ROLLOVER_COUNTERS));
    } catch (Exception e) {
        Log.e(TAG, "Exception while updating secondary version counter:" + e);
    }
}
#end_block

#method_before
protected static int fetchAndSetContacts(Context mContext, Handler mHandler, String[] projection, String whereClause, String[] selectionArgs, boolean isLoad) {
    long currentTotalFields = 0, currentSvcFieldCount = 0;
    Cursor c = mContext.getContentResolver().query(Data.CONTENT_URI, projection, whereClause, selectionArgs, null);
    /* send delayed message to loadContact when ContentResolver is unable
         * to fetch data from contact database using the specified URI at that
         * moment (Case: immediate Pbap connect on system boot with BT ON)*/
    if (c == null) {
        Log.d(TAG, "Failed to fetch contacts data from database..");
        if (isLoad)
            mHandler.sendMessageDelayed(mHandler.obtainMessage(BluetoothPbapService.LOAD_CONTACTS), QUERY_CONTACT_RETRY_INTERVAL);
        return -1;
    }
    int indexCId = c.getColumnIndex(Data.CONTACT_ID);
    int indexData = c.getColumnIndex(Data.DATA1);
    int indexMimeType = c.getColumnIndex(Data.MIMETYPE);
    String c_id, data, mime_type;
    while (c.moveToNext()) {
        c_id = c.getString(indexCId);
        data = c.getString(indexData);
        mime_type = c.getString(indexMimeType);
        /* fetch phone/email/address/name information of the contact */
        switch(mime_type) {
            case Phone.CONTENT_ITEM_TYPE:
                setContactFields(phone, c_id, data);
                currentSvcFieldCount++;
                break;
            case Email.CONTENT_ITEM_TYPE:
                setContactFields(email, c_id, data);
                currentSvcFieldCount++;
                break;
            case StructuredPostal.CONTENT_ITEM_TYPE:
                setContactFields(address, c_id, data);
                currentSvcFieldCount++;
                break;
            case StructuredName.CONTENT_ITEM_TYPE:
                name.put(c_id, data);
                currentSvcFieldCount++;
                break;
        }
        ContactSet.add(c_id);
        currentTotalFields++;
    }
    c.close();
    /* This code checks if there is any update in contacts after last pbap
         * disconnect has happenned (even if BT is turned OFF during this time)*/
    if (isLoad && currentTotalFields != totalFields) {
        primaryVersionCounter += Math.abs(totalContacts - ContactSet.size());
        if (currentSvcFieldCount != totalSvcFields)
            if (totalContacts != ContactSet.size())
                secondaryVersionCounter += Math.abs(totalContacts - ContactSet.size());
            else
                secondaryVersionCounter++;
        if (primaryVersionCounter < 0 || secondaryVersionCounter < 0)
            rolloverCounters();
        totalFields = currentTotalFields;
        totalSvcFields = currentSvcFieldCount;
        contactsLastUpdated = System.currentTimeMillis();
        Log.d(TAG, "Contacts updated between last BT OFF and current" + "Pbap Connect, primaryVersionCounter=" + primaryVersionCounter + ", secondaryVersionCounter=" + secondaryVersionCounter);
    } else if (!isLoad) {
        totalFields++;
        totalSvcFields++;
    }
    return ContactSet.size();
}
#method_after
protected static int fetchAndSetContacts(Context mContext, Handler mHandler, String[] projection, String whereClause, String[] selectionArgs, boolean isLoad) {
    long currentTotalFields = 0, currentSvcFieldCount = 0;
    Cursor c = mContext.getContentResolver().query(Data.CONTENT_URI, projection, whereClause, selectionArgs, null);
    /* send delayed message to loadContact when ContentResolver is unable
         * to fetch data from contact database using the specified URI at that
         * moment (Case: immediate Pbap connect on system boot with BT ON)*/
    if (c == null) {
        Log.d(TAG, "Failed to fetch contacts data from database..");
        if (isLoad)
            mHandler.sendMessageDelayed(mHandler.obtainMessage(BluetoothPbapService.LOAD_CONTACTS), QUERY_CONTACT_RETRY_INTERVAL);
        return -1;
    }
    int indexCId = c.getColumnIndex(Data.CONTACT_ID);
    int indexData = c.getColumnIndex(Data.DATA1);
    int indexMimeType = c.getColumnIndex(Data.MIMETYPE);
    String contactId, data, mimeType;
    while (c.moveToNext()) {
        contactId = c.getString(indexCId);
        data = c.getString(indexData);
        mimeType = c.getString(indexMimeType);
        /* fetch phone/email/address/name information of the contact */
        switch(mimeType) {
            case Phone.CONTENT_ITEM_TYPE:
                setContactFields(TYPE_PHONE, contactId, data);
                currentSvcFieldCount++;
                break;
            case Email.CONTENT_ITEM_TYPE:
                setContactFields(TYPE_EMAIL, contactId, data);
                currentSvcFieldCount++;
                break;
            case StructuredPostal.CONTENT_ITEM_TYPE:
                setContactFields(TYPE_ADDRESS, contactId, data);
                currentSvcFieldCount++;
                break;
            case StructuredName.CONTENT_ITEM_TYPE:
                setContactFields(TYPE_NAME, contactId, data);
                currentSvcFieldCount++;
                break;
        }
        ContactSet.add(contactId);
        currentTotalFields++;
    }
    c.close();
    /* This code checks if there is any update in contacts after last pbap
         * disconnect has happenned (even if BT is turned OFF during this time)*/
    if (isLoad && currentTotalFields != totalFields) {
        primaryVersionCounter += Math.abs(totalContacts - ContactSet.size());
        if (currentSvcFieldCount != totalSvcFields)
            if (totalContacts != ContactSet.size())
                secondaryVersionCounter += Math.abs(totalContacts - ContactSet.size());
            else
                secondaryVersionCounter++;
        if (primaryVersionCounter < 0 || secondaryVersionCounter < 0)
            rolloverCounters();
        totalFields = currentTotalFields;
        totalSvcFields = currentSvcFieldCount;
        contactsLastUpdated = System.currentTimeMillis();
        Log.d(TAG, "Contacts updated between last BT OFF and current" + "Pbap Connect, primaryVersionCounter=" + primaryVersionCounter + ", secondaryVersionCounter=" + secondaryVersionCounter);
    } else if (!isLoad) {
        totalFields++;
        totalSvcFields++;
    }
    return ContactSet.size();
}
#end_block

#method_before
/* setContactFields() is used to store contacts data in local cache (phone,
     * email or address which is required for updating Secondary Version counter).
     * contactsFieldData - List of field data for phone/email/address.
     * c_id - Contact ID, data1 - field value from data table for phone/email/address*/
protected static void setContactFields(HashMap<String, ArrayList<String>> contactsFieldData, String c_id, String data1) {
    ArrayList<String> fieldList_tmp = null;
    if (contactsFieldData.containsKey(c_id))
        fieldList_tmp = contactsFieldData.get(c_id);
    else
        fieldList_tmp = new ArrayList<String>();
    fieldList_tmp.add(data1);
    contactsFieldData.put(c_id, fieldList_tmp);
}
#method_after
/* setContactFields() is used to store contacts data in local cache (phone,
     * email or address which is required for updating Secondary Version counter).
     * contactsFieldData - List of field data for phone/email/address.
     * contactId - Contact ID, data1 - field value from data table for phone/email/address*/
protected static void setContactFields(String fieldType, String contactId, String data) {
    ContactData cData = null;
    if (contactDataset.containsKey(contactId))
        cData = contactDataset.get(contactId);
    else
        cData = new ContactData();
    switch(fieldType) {
        case TYPE_NAME:
            cData.name = data;
            break;
        case TYPE_PHONE:
            cData.phone.add(data);
            break;
        case TYPE_EMAIL:
            cData.email.add(data);
            break;
        case TYPE_ADDRESS:
            cData.address.add(data);
            break;
    }
    contactDataset.put(contactId, cData);
}
#end_block

#method_before
@Override
public short set(byte val) {
    if (storage == null) {
        return 0x0001;
    }
    // Do not require meta on unlock.
    if (val != 0) {
        // pointless if metadataLength == 0.
        if (needMetadata == true && metadataLength() > 0) {
            return 0x0002;
        }
    }
    // To relock, the lock must be unlocked, then relocked.
    if (val != (byte) 0 && storage[lockOffset()] != (byte) 0) {
        return 0x0005;
    }
    if (globalState.production() == true) {
        // Enforce only when in production.
        if (onlyInBootloader == true) {
            // If onlyInBootloader is false, we allow toggling regardless.
            if (globalState.inBootloader() == false) {
                return 0x0003;
            }
        }
        if (onlyInHLOS == true) {
            // If onlyInHLOS is false, we allow toggling regardless.
            if (globalState.inBootloader() == true) {
                return 0x0003;
            }
        }
    }
    if (requiredLocks.length != 0) {
        byte[] temp = new byte[1];
        short resp = 0;
        for (short l = 0; l < requiredLocks.length; ++l) {
            resp = requiredLocks[l].get(temp, (short) 0);
            // On error or not cleared, fail.
            if (resp != 0 || temp[0] != (byte) 0x0) {
                return 0x0a00;
            }
        }
    }
    try {
        storage[storageOffset] = val;
    } catch (CardRuntimeException e) {
        return 0x0004;
    }
    return 0;
}
#method_after
@Override
public short set(byte val) {
    if (storage == null) {
        return 0x0001;
    }
    // Do not require meta on unlock.
    if (val != 0) {
        // pointless if metadataLength == 0.
        if (needMetadata == true && metadataLength() > 0) {
            return 0x0002;
        }
    }
    // To relock, the lock must be unlocked, then relocked.
    if (val != (byte) 0 && storage[lockOffset()] != (byte) 0) {
        return 0x0005;
    }
    if (globalState.production() == true) {
        // Enforce only when in production.
        if (onlyInBootloader == true) {
            // If onlyInBootloader is false, we allow toggling regardless.
            if (globalState.inBootloader() == false) {
                return 0x0003;
            }
        }
        if (onlyInHLOS == true) {
            // If onlyInHLOS is false, we allow toggling regardless.
            if (globalState.inBootloader() == true) {
                return 0x0003;
            }
        }
    }
    if (prerequisitesMet() == false) {
        return 0x0a00;
    }
    try {
        storage[storageOffset] = val;
    } catch (CardRuntimeException e) {
        return 0x0004;
    }
    return 0;
}
#end_block

#method_before
@Override
public short setWithMetadata(byte lockValue, byte[] lockMeta, short lockMetaOffset, short lockMetaLength) {
    if (storage == null) {
        return 0x0001;
    }
    // No overruns, please.
    if (lockMetaLength > metadataLength()) {
        return 0x0002;
    }
    // To relock, the lock must be unlocked, then relocked.
    if (lockValue != (byte) 0 && storage[lockOffset()] != (byte) 0) {
        return 0x0005;
    }
    if (metadataLength() == 0) {
        return set(lockValue);
    }
    try {
        Util.arrayCopyNonAtomic(lockMeta, lockMetaOffset, storage, metadataOffset(), lockMetaLength);
        // Lock must follow the copy, but interrupting the
        // copy is fine as long as it is still unlocked.
        JCSystem.beginTransaction();
        storage[lockOffset()] = lockValue;
        JCSystem.commitTransaction();
    } catch (CardRuntimeException e) {
        return 0x0004;
    }
    return 0;
}
#method_after
@Override
public short setWithMetadata(byte lockValue, byte[] lockMeta, short lockMetaOffset, short lockMetaLength) {
    if (storage == null) {
        return 0x0001;
    }
    // No overruns, please.
    if (lockMetaLength > metadataLength()) {
        return 0x0002;
    }
    // changed without first having the permission to unlock and lock again.
    if (lockValue != (byte) 0 && storage[lockOffset()] != (byte) 0) {
        return 0x0005;
    }
    if (metadataLength() == 0) {
        return set(lockValue);
    }
    // Before copying, ensure changing the lock state is currently permitted.
    if (prerequisitesMet() == false) {
        return 0x0a00;
    }
    try {
        // When unlocking, do so before clearing the metadata.
        if (lockValue == (byte) 0) {
            JCSystem.beginTransaction();
            storage[lockOffset()] = lockValue;
            JCSystem.commitTransaction();
        }
        if (lockMetaLength == 0) {
            // An empty lockMeta will clear the value.
            Util.arrayFillNonAtomic(storage, metadataOffset(), metadataLength(), (byte) 0x00);
        } else {
            Util.arrayCopyNonAtomic(lockMeta, lockMetaOffset, storage, metadataOffset(), lockMetaLength);
        }
        // not impact its use in a locked state.
        if (lockValue != (byte) 0) {
            JCSystem.beginTransaction();
            storage[lockOffset()] = lockValue;
            JCSystem.commitTransaction();
        }
    } catch (CardRuntimeException e) {
        return 0x0004;
    }
    return 0;
}
#end_block

#method_before
private short sendStorageState(APDU apdu) {
    final byte[] buffer = apdu.getBuffer();
    byte[] working = new byte[2];
    short value = 0;
    short resp = 0;
    byte i;
    short expectedLength = apdu.setOutgoing();
    short length = (short) (2 + 1 + 2 + 1 + 1 + 1 + (2 * locks.length) + 2 + lockStorage.length + 2);
    if (expectedLength < length) {
        // Error with length.
        buffer[0] = (byte) 0x01;
        buffer[1] = (byte) 0x00;
        buffer[2] = (byte) (length >> 8);
        buffer[3] = (byte) (length & 0xff);
        apdu.setOutgoingLength((short) 4);
        apdu.sendBytes((short) 0, (short) 4);
        return 0x0;
    }
    try {
        apdu.setOutgoingLength(length);
    } catch (CardRuntimeException e) {
        return 0x0101;
    }
    // Send the usual prefix status indicating we made it this far.
    try {
        Util.setShort(working, (short) 0, (short) 0x0);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        return 0x0001;
    }
    try {
        working[0] = VERSION;
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        return 0x0001;
    }
    try {
        Util.setShort(working, (short) 0, length);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) 0;
        if (globalState.inBootloader() == true) {
            working[0] = (byte) 1;
        }
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) 0;
        if (globalState.production() == true) {
            working[0] = (byte) 1;
        }
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) locks.length;
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        for (i = 0; i < (byte) locks.length; ++i) {
            Util.setShort(working, (short) 0, locks[i].initialized());
            apdu.sendBytesLong(working, (short) 0, (short) 2);
            length -= 2;
        }
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        Util.setShort(working, (short) 0, (short) lockStorage.length);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        apdu.sendBytesLong(lockStorage, (short) 0, (short) lockStorage.length);
        length -= (short) lockStorage.length;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    if (length != 0) {
        ISOException.throwIt(length);
    }
    return 0;
}
#method_after
private short sendStorageState(APDU apdu) {
    final byte[] buffer = apdu.getBuffer();
    byte[] working = new byte[2];
    short value = 0;
    short resp = 0;
    byte i;
    short expectedLength = apdu.setOutgoing();
    short length = (short) (2 + 1 + 2 + 1 + 1 + 1 + 1 + (2 * locks.length) + 2 + lockStorage.length + 2);
    if (expectedLength < length) {
        // Error with length.
        buffer[0] = (byte) 0x01;
        buffer[1] = (byte) 0x00;
        buffer[2] = (byte) (length >> 8);
        buffer[3] = (byte) (length & 0xff);
        apdu.setOutgoingLength((short) 4);
        apdu.sendBytes((short) 0, (short) 4);
        return 0x0;
    }
    try {
        apdu.setOutgoingLength(length);
    } catch (CardRuntimeException e) {
        return 0x0101;
    }
    // Send the usual prefix status indicating we made it this far.
    try {
        Util.setShort(working, (short) 0, (short) 0x0);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        return 0x0001;
    }
    try {
        working[0] = VERSION;
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        return 0x0001;
    }
    try {
        Util.setShort(working, (short) 0, length);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = globalState.inBootloaderRaw();
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) 0;
        if (globalState.inBootloader() == true) {
            working[0] = (byte) 1;
        }
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) 0;
        if (globalState.production() == true) {
            working[0] = (byte) 1;
        }
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        working[0] = (byte) locks.length;
        apdu.sendBytesLong(working, (short) 0, (short) 1);
        length--;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        for (i = 0; i < (byte) locks.length; ++i) {
            Util.setShort(working, (short) 0, locks[i].initialized());
            apdu.sendBytesLong(working, (short) 0, (short) 2);
            length -= 2;
        }
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        Util.setShort(working, (short) 0, (short) lockStorage.length);
        apdu.sendBytesLong(working, (short) 0, (short) 2);
        length -= 2;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    try {
        apdu.sendBytesLong(lockStorage, (short) 0, (short) lockStorage.length);
        length -= (short) lockStorage.length;
    } catch (CardRuntimeException e) {
        ISOException.throwIt(length);
    }
    if (length != 0) {
        ISOException.throwIt(length);
    }
    return 0;
}
#end_block

#method_before
public void process(APDU apdu) {
    final byte[] buffer = apdu.getBuffer();
    final byte cla = buffer[ISO7816.OFFSET_CLA];
    final byte ins = buffer[ISO7816.OFFSET_INS];
    // Handle standard commands
    if (apdu.isISOInterindustryCLA()) {
        switch(ins) {
            case ISO7816.INS_SELECT:
                // Do nothing, successfully
                return;
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }
        ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);
    }
    short availableBytes = apdu.setIncomingAndReceive();
    short numBytes = apdu.getIncomingLength();
    short cdataOffset = apdu.getOffsetCdata();
    // (really it is 6 * 254 - framing).
    if (numBytes > INCOMING_BYTES_MAX) {
        sendResponseCode(apdu, (short) 0x0f00);
        return;
    }
    byte p1 = (byte) (buffer[ISO7816.OFFSET_P1] & (byte) 0xff);
    byte p2 = (byte) (buffer[ISO7816.OFFSET_P2] & (byte) 0xff);
    short length = 0;
    short expectedLength = 0;
    short resp = 0;
    boolean enable = false;
    if (p1 != 0) {
        enable = true;
    }
    switch(buffer[ISO7816.OFFSET_INS]) {
        case INS_GET_STATE:
            /* getStorageState(0x0, 0x0) */
            resp = sendStorageState(apdu);
            if (resp != 0) {
                sendResponseCode(apdu, resp);
            }
            return;
        case INS_LOAD:
            /* getSlot(id) */
            resp = versionStorage.getSlot(p1, buffer, (short) 2);
            buffer[0] = (byte) (resp >> 8);
            buffer[1] = (byte) (resp & 0xff);
            length = 2;
            if (resp == 0) {
                length += (short) VersionStorage.SLOT_BYTES;
            }
            // Always send the two bytes of status as they are more
            // useful than the APDU error.
            apdu.setOutgoingAndSend((short) 0, length);
            return;
        case INS_STORE:
            /* setSlot(id) {uint64_t} */
            resp = versionStorage.setSlot(p1, buffer, cdataOffset);
            Util.setShort(buffer, (short) 0, resp);
            apdu.setOutgoingAndSend((short) 0, (short) 2);
            return;
        case INS_GET_LOCK:
            /* getLock(lockId, sendMetadata) */
            resp = sendLockData(apdu, p1, p2);
            if (resp != 0) {
                sendResponseCode(apdu, resp);
            }
            return;
        case INS_SET_LOCK:
            /* setlock(index, val) { data } */
            if (p1 >= (byte) locks.length) {
                sendResponseCode(apdu, (short) 0x0100);
                return;
            }
            if (metadataLength == (short) 0) {
                resp = locks[p1].set(p2);
                sendResponseCode(apdu, resp);
                return;
            }
            resp = locks[p1].setWithMetadata(p2, metadata, (short) 0, metadataLength);
            // "Consume" the metadata.
            metadataLength = (short) 0;
            sendResponseCode(apdu, resp);
            return;
        case INS_SET_PRODUCTION:
            /* setProduction(p1) */
            if (globalState.setProduction(enable) == true) {
                resp = 0x0000;
            } else {
                resp = 0x0001;
            }
            sendResponseCode(apdu, resp);
            return;
        /* carrierLockTest() { testVector } */
        case INS_CARRIER_LOCK_TEST:
            try {
                short copied = fillIncomingBuffer(apdu, metadata, (short) 0, availableBytes);
                if (numBytes != copied) {
                    // Declared length did not match read bytes.
                    sendResponseCode(apdu, (short) 0x0101);
                    return;
                }
                resp = ((CarrierLock) locks[LOCK_CARRIER]).testVector(metadata, (short) 0, copied);
                sendResponseCode(apdu, resp);
                return;
            } catch (CardRuntimeException e) {
                sendResponseCode(apdu, (short) 0x0201);
                return;
            }
        /* reset(0x0=factory 0x1=locks) {} */
        case INS_RESET:
            if (p1 != RESET_LOCKS) {
                /* Not implemented */
                resp = 0x0001;
                sendResponseCode(apdu, resp);
                return;
            }
            if (globalState.production() == true) {
                resp = 0x0100;
                sendResponseCode(apdu, resp);
                return;
            }
            Util.arrayFillNonAtomic(lockStorage, (short) 0, (short) lockStorage.length, (byte) 0x00);
            return;
        /* load_meta(new|append) {} */
        case INS_LOAD_META:
            if (p1 == LOAD_META_CLEAR) {
                metadataLength = (short) 0;
                sendResponseCode(apdu, (short) 0x0000);
                return;
            }
            if (p1 != LOAD_META_APPEND) {
                sendResponseCode(apdu, (short) 0x0100);
                return;
            }
            try {
                // fillIncomingBuffer will only copy up to the length.
                short copied = fillIncomingBuffer(apdu, metadata, metadataLength, availableBytes);
                // just the new stuff
                copied -= metadataLength;
                metadataLength += copied;
                if (numBytes != copied) {
                    // Could not read all the bytes -- the data is
                    // copied though.
                    sendResponseCode(apdu, (short) 0x0101);
                    return;
                }
            } catch (CardRuntimeException e) {
                sendResponseCode(apdu, (short) 0x0201);
                return;
            }
            return;
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }
}
#method_after
public void process(APDU apdu) {
    final byte[] buffer = apdu.getBuffer();
    final byte cla = buffer[ISO7816.OFFSET_CLA];
    final byte ins = buffer[ISO7816.OFFSET_INS];
    // Handle standard commands
    if (apdu.isISOInterindustryCLA()) {
        switch(ins) {
            case ISO7816.INS_SELECT:
                // Do nothing, successfully
                return;
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
        }
        ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);
    }
    short availableBytes = apdu.setIncomingAndReceive();
    short numBytes = apdu.getIncomingLength();
    short cdataOffset = apdu.getOffsetCdata();
    // (really it is 6 * 254 - framing).
    if (numBytes > INCOMING_BYTES_MAX) {
        sendResponseCode(apdu, (short) 0x0f00);
        return;
    }
    byte p1 = (byte) (buffer[ISO7816.OFFSET_P1] & (byte) 0xff);
    byte p2 = (byte) (buffer[ISO7816.OFFSET_P2] & (byte) 0xff);
    short length = 0;
    short expectedLength = 0;
    short resp = 0;
    boolean enable = false;
    if (p1 != 0) {
        enable = true;
    }
    switch(buffer[ISO7816.OFFSET_INS]) {
        case INS_GET_STATE:
            /* getStorageState(0x0, 0x0) */
            resp = sendStorageState(apdu);
            if (resp != 0) {
                sendResponseCode(apdu, resp);
            }
            return;
        case INS_LOAD:
            /* getSlot(id) */
            resp = versionStorage.getSlot(p1, buffer, (short) 2);
            buffer[0] = (byte) (resp >> 8);
            buffer[1] = (byte) (resp & 0xff);
            length = 2;
            if (resp == 0) {
                length += (short) VersionStorage.SLOT_BYTES;
            }
            // Always send the two bytes of status as they are more
            // useful than the APDU error.
            apdu.setOutgoingAndSend((short) 0, length);
            return;
        case INS_STORE:
            /* setSlot(id) {uint64_t} */
            resp = versionStorage.setSlot(p1, buffer, cdataOffset);
            Util.setShort(buffer, (short) 0, resp);
            apdu.setOutgoingAndSend((short) 0, (short) 2);
            return;
        case INS_GET_LOCK:
            /* getLock(lockId, sendMetadata) */
            resp = sendLockData(apdu, p1, p2);
            if (resp != 0) {
                sendResponseCode(apdu, resp);
            }
            return;
        case INS_SET_LOCK:
            /* setlock(index, val) { useMetadata(byte) } */
            if (p1 >= (byte) locks.length) {
                sendResponseCode(apdu, (short) 0x0100);
                return;
            }
            // useMetadata argument byte is required.
            if (numBytes != 1) {
                sendResponseCode(apdu, (short) 0x0200);
                return;
            }
            if (buffer[cdataOffset] == (byte) 0) {
                resp = locks[p1].set(p2);
            } else if (buffer[cdataOffset] == (byte) 1) {
                resp = locks[p1].setWithMetadata(p2, metadata, (short) 0, metadataLength);
                // "Consume" the metadata even if an error occurred.
                metadataLength = (short) 0;
            }
            sendResponseCode(apdu, resp);
            return;
        case INS_SET_PRODUCTION:
            /* setProduction(p1) */
            if (globalState.setProduction(enable) == true) {
                resp = 0x0000;
            } else {
                resp = 0x0001;
            }
            sendResponseCode(apdu, resp);
            return;
        /* carrierLockTest() { testVector } */
        case INS_CARRIER_LOCK_TEST:
            try {
                short copied = fillIncomingBuffer(apdu, metadata, (short) 0, availableBytes);
                if (numBytes != copied) {
                    // Declared length did not match read bytes.
                    sendResponseCode(apdu, (short) 0x0101);
                    return;
                }
                resp = ((CarrierLock) locks[LOCK_CARRIER]).testVector(metadata, (short) 0, copied);
                sendResponseCode(apdu, resp);
                return;
            } catch (CardRuntimeException e) {
                sendResponseCode(apdu, (short) 0x0201);
                return;
            }
        /* reset(0x0=factory 0x1=locks) {} */
        case INS_RESET:
            if (p1 != RESET_LOCKS) {
                /* Not implemented */
                resp = 0x0001;
                sendResponseCode(apdu, resp);
                return;
            }
            if (globalState.production() == true) {
                resp = 0x0100;
                sendResponseCode(apdu, resp);
                return;
            }
            Util.arrayFillNonAtomic(lockStorage, (short) 0, (short) lockStorage.length, (byte) 0x00);
            return;
        /* load_meta(new|append) {} */
        case INS_LOAD_META:
            if (p1 == LOAD_META_CLEAR) {
                metadataLength = (short) 0;
                sendResponseCode(apdu, (short) 0x0000);
                return;
            }
            if (p1 != LOAD_META_APPEND) {
                sendResponseCode(apdu, (short) 0x0100);
                return;
            }
            try {
                // fillIncomingBuffer will only copy up to the length.
                short copied = fillIncomingBuffer(apdu, metadata, metadataLength, availableBytes);
                // just the new stuff
                copied -= metadataLength;
                metadataLength += copied;
                if (numBytes != copied) {
                    // Could not read all the bytes -- the data is
                    // copied though.
                    sendResponseCode(apdu, (short) 0x0101);
                    return;
                }
            } catch (CardRuntimeException e) {
                sendResponseCode(apdu, (short) 0x0201);
                return;
            }
            sendResponseCode(apdu, (short) 0x0000);
            return;
        default:
            ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
    }
}
#end_block

#method_before
@Test
public void testBasicOperation() {
    final SharedLog logTop = new SharedLog("top");
    logTop.mark("first post!");
    final SharedLog logLevel2a = logTop.forSubSystem("twoA");
    final SharedLog logLevel2b = logTop.forSubSystem("twoB");
    logLevel2b.error("2b or not 2b");
    logLevel2a.event("second post?");
    final SharedLog logLevel3 = logLevel2a.forSubSystem("three");
    logTop.log("still logging");
    logLevel3.log("3 >> 2");
    logLevel2a.mark("ok: last post");
    final String[] expected = { TIMESTAMP + " - MARK first post!", TIMESTAMP + " - [twoB] ERROR 2b or not 2b", TIMESTAMP + " - [twoA] EVENT second post?", TIMESTAMP + " - still logging", TIMESTAMP + " - [twoA.three] 3 >> 2", TIMESTAMP + " - [twoA] MARK ok: last post" };
    // Verify the logs are all there and in the correct order.
    verifyLogLines(expected, logTop);
    // In fact, because they all share the same underlying LocalLog,
    // every subsystem SharedLog's dump() is identical.
    verifyLogLines(expected, logLevel2a);
    verifyLogLines(expected, logLevel2b);
    verifyLogLines(expected, logLevel3);
}
#method_after
@Test
public void testBasicOperation() {
    final SharedLog logTop = new SharedLog("top");
    logTop.mark("first post!");
    final SharedLog logLevel2a = logTop.forSubComponent("twoA");
    final SharedLog logLevel2b = logTop.forSubComponent("twoB");
    logLevel2b.e("2b or not 2b");
    logLevel2a.w("second post?");
    final SharedLog logLevel3 = logLevel2a.forSubComponent("three");
    logTop.log("still logging");
    logLevel3.log("3 >> 2");
    logLevel2a.mark("ok: last post");
    final String[] expected = { TIMESTAMP + " - MARK first post!", TIMESTAMP + " - [twoB] ERROR 2b or not 2b", TIMESTAMP + " - [twoA] WARN second post?", TIMESTAMP + " - still logging", TIMESTAMP + " - [twoA.three] 3 >> 2", TIMESTAMP + " - [twoA] MARK ok: last post" };
    // Verify the logs are all there and in the correct order.
    verifyLogLines(expected, logTop);
    // In fact, because they all share the same underlying LocalLog,
    // every subcomponent SharedLog's dump() is identical.
    verifyLogLines(expected, logLevel2a);
    verifyLogLines(expected, logLevel2b);
    verifyLogLines(expected, logLevel3);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    reset(mContext);
    reset(mCS);
    reset(mLog);
    when(mLog.forSubSystem(anyString())).thenReturn(mLog);
    mCM = spy(new TestConnectivityManager(mContext, mCS));
    mSM = new TestStateMachine();
    mUNM = new UpstreamNetworkMonitor(mLog, mSM, EVENT_UNM_UPDATE, (ConnectivityManager) mCM);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    reset(mContext);
    reset(mCS);
    reset(mLog);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mCM = spy(new TestConnectivityManager(mContext, mCS));
    mSM = new TestStateMachine();
    mUNM = new UpstreamNetworkMonitor(mSM, EVENT_UNM_UPDATE, (ConnectivityManager) mCM, mLog);
}
#end_block

#method_before
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        mLog.error(e);
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            mLog.error(ee);
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    mLog.log("SET master tether settings: ON");
    return true;
}
#method_after
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            mLog.e(ee);
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    mLog.log("SET master tether settings: ON");
    return true;
}
#end_block

#method_before
protected boolean turnOffMasterTetherSettings() {
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
        mLog.error(e);
        transitionTo(mStopTetheringErrorState);
        return false;
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
        mLog.error(e);
        transitionTo(mSetIpForwardingDisabledErrorState);
        return false;
    }
    transitionTo(mInitialState);
    mLog.log("SET master tether settings: OFF");
    return true;
}
#method_after
protected boolean turnOffMasterTetherSettings() {
    try {
        mNMService.stopTethering();
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mStopTetheringErrorState);
        return false;
    }
    try {
        mNMService.setIpForwardingEnabled(false);
    } catch (Exception e) {
        mLog.e(e);
        transitionTo(mSetIpForwardingDisabledErrorState);
        return false;
    }
    transitionTo(mInitialState);
    mLog.log("SET master tether settings: OFF");
    return true;
}
#end_block

#method_before
protected void setDnsForwarders(final Network network, final LinkProperties lp) {
    // TODO: Set v4 and/or v6 DNS per available connectivity.
    String[] dnsServers = mConfig.defaultIPv4DNS;
    final Collection<InetAddress> dnses = lp.getDnsServers();
    // TODO: Properly support the absence of DNS servers.
    if (dnses != null && !dnses.isEmpty()) {
        // TODO: remove this invocation of NetworkUtils.makeStrings().
        dnsServers = NetworkUtils.makeStrings(dnses);
    }
    try {
        mNMService.setDnsForwarders(network, dnsServers);
        mLog.log(String.format("SET DNS forwarders: network=%s dnsServers=%s", network, Arrays.toString(dnsServers)));
    } catch (Exception e) {
        // TODO: Investigate how this can fail and what exactly
        // happens if/when such failures occur.
        mLog.error("setting DNS forwarders failed, " + e);
        transitionTo(mSetDnsForwardersErrorState);
    }
}
#method_after
protected void setDnsForwarders(final Network network, final LinkProperties lp) {
    // TODO: Set v4 and/or v6 DNS per available connectivity.
    String[] dnsServers = mConfig.defaultIPv4DNS;
    final Collection<InetAddress> dnses = lp.getDnsServers();
    // TODO: Properly support the absence of DNS servers.
    if (dnses != null && !dnses.isEmpty()) {
        // TODO: remove this invocation of NetworkUtils.makeStrings().
        dnsServers = NetworkUtils.makeStrings(dnses);
    }
    try {
        mNMService.setDnsForwarders(network, dnsServers);
        mLog.log(String.format("SET DNS forwarders: network=%s dnsServers=%s", network, Arrays.toString(dnsServers)));
    } catch (Exception e) {
        // TODO: Investigate how this can fail and what exactly
        // happens if/when such failures occur.
        mLog.e("setting DNS forwarders failed, " + e);
        transitionTo(mSetDnsForwardersErrorState);
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // transitions appropriately
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.println("Log:");
    pw.increaseIndent();
    mLog.dump(fd, pw, args);
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_ONLY:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.println("Log:");
    pw.increaseIndent();
    if (argsContain(args, SHORT_ARG)) {
        pw.println("<log removed for brevity>");
    } else {
        mLog.dump(fd, pw, args);
    }
    pw.decreaseIndent();
    pw.decreaseIndent();
}
#end_block

#method_before
private void trackNewTetherableInterface(String iface, int interfaceType) {
    TetherState tetherState;
    tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mLog, mNMService)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#method_after
private void trackNewTetherableInterface(String iface, int interfaceType) {
    TetherState tetherState;
    tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService, mLog)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#end_block

#method_before
private boolean configureIfaceIp(boolean enabled) {
    if (VDBG)
        Log.d(TAG, "configureIfaceIp(" + enabled + ")");
    String ipAsString = null;
    int prefixLen = 0;
    if (mInterfaceType == ConnectivityManager.TETHERING_USB) {
        ipAsString = USB_NEAR_IFACE_ADDR;
        prefixLen = USB_PREFIX_LENGTH;
    } else if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
        ipAsString = WIFI_HOST_IFACE_ADDR;
        prefixLen = WIFI_HOST_IFACE_PREFIX_LENGTH;
    } else {
        // Nothing to do, BT does this elsewhere.
        return true;
    }
    InterfaceConfiguration ifcg = null;
    try {
        ifcg = mNMService.getInterfaceConfig(mIfaceName);
        if (ifcg != null) {
            InetAddress addr = NetworkUtils.numericToInetAddress(ipAsString);
            ifcg.setLinkAddress(new LinkAddress(addr, prefixLen));
            if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
                // The WiFi stack has ownership of the interface up/down state.
                // It is unclear whether the bluetooth or USB stacks will manage their own
                // state.
                ifcg.ignoreInterfaceUpDownStatus();
            } else {
                if (enabled) {
                    ifcg.setInterfaceUp();
                } else {
                    ifcg.setInterfaceDown();
                }
            }
            ifcg.clearFlag("running");
            mNMService.setInterfaceConfig(mIfaceName, ifcg);
        }
    } catch (Exception e) {
        mLog.error("Error configuring interface " + e);
        return false;
    }
    return true;
}
#method_after
private boolean configureIfaceIp(boolean enabled) {
    if (VDBG)
        Log.d(TAG, "configureIfaceIp(" + enabled + ")");
    String ipAsString = null;
    int prefixLen = 0;
    if (mInterfaceType == ConnectivityManager.TETHERING_USB) {
        ipAsString = USB_NEAR_IFACE_ADDR;
        prefixLen = USB_PREFIX_LENGTH;
    } else if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
        ipAsString = WIFI_HOST_IFACE_ADDR;
        prefixLen = WIFI_HOST_IFACE_PREFIX_LENGTH;
    } else {
        // Nothing to do, BT does this elsewhere.
        return true;
    }
    InterfaceConfiguration ifcg = null;
    try {
        ifcg = mNMService.getInterfaceConfig(mIfaceName);
        if (ifcg != null) {
            InetAddress addr = NetworkUtils.numericToInetAddress(ipAsString);
            ifcg.setLinkAddress(new LinkAddress(addr, prefixLen));
            if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
                // The WiFi stack has ownership of the interface up/down state.
                // It is unclear whether the bluetooth or USB stacks will manage their own
                // state.
                ifcg.ignoreInterfaceUpDownStatus();
            } else {
                if (enabled) {
                    ifcg.setInterfaceUp();
                } else {
                    ifcg.setInterfaceDown();
                }
            }
            ifcg.clearFlag("running");
            mNMService.setInterfaceConfig(mIfaceName, ifcg);
        }
    } catch (Exception e) {
        mLog.e("Error configuring interface " + e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.error("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.e("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void enter() {
    if (!configureIfaceIp(true)) {
        mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;
        return;
    }
    try {
        mNMService.tetherInterface(mIfaceName);
    } catch (Exception e) {
        mLog.error("Error Tethering: " + e);
        mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
        return;
    }
    if (!mIPv6TetherSvc.start()) {
        mLog.error("Failed to start IPv6TetheringInterfaceServices");
        // TODO: Make this a fatal error once Bluetooth IPv6 is sorted.
        return;
    }
}
#method_after
@Override
public void enter() {
    if (!configureIfaceIp(true)) {
        mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;
        return;
    }
    try {
        mNMService.tetherInterface(mIfaceName);
    } catch (Exception e) {
        mLog.e("Error Tethering: " + e);
        mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
        return;
    }
    if (!mIPv6TetherSvc.start()) {
        mLog.e("Failed to start IPv6TetheringInterfaceServices");
        // TODO: Make this a fatal error once Bluetooth IPv6 is sorted.
        return;
    }
}
#end_block

#method_before
@Override
public void exit() {
    // Note that at this point, we're leaving the tethered state.  We can fail any
    // of these operations, but it doesn't really change that we have to try them
    // all in sequence.
    mIPv6TetherSvc.stop();
    try {
        mNMService.untetherInterface(mIfaceName);
    } catch (Exception e) {
        mLastError = ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
        mLog.error("Failed to untether interface: " + e);
    }
    configureIfaceIp(false);
}
#method_after
@Override
public void exit() {
    // Note that at this point, we're leaving the tethered state.  We can fail any
    // of these operations, but it doesn't really change that we have to try them
    // all in sequence.
    mIPv6TetherSvc.stop();
    try {
        mNMService.untetherInterface(mIfaceName);
    } catch (Exception e) {
        mLastError = ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
        mLog.e("Failed to untether interface: " + e);
    }
    configureIfaceIp(false);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.error("CMD_TETHER_REQUESTED while in local-only hotspot mode.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            // Ignored in local hotspot state.
            break;
        default:
            return false;
    }
    return true;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.e("CMD_TETHER_REQUESTED while in local-only hotspot mode.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            // Ignored in local hotspot state.
            break;
        default:
            return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.error("CMD_TETHER_REQUESTED while already tethering.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    mLog.error("Exception enabling NAT: " + e);
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.e("CMD_TETHER_REQUESTED while already tethering.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    mLog.e("Exception enabling NAT: " + e);
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
public void start() {
    // TODO: initOffload() and configure callbacks to be handled on our
    // preferred Handler.
    mLog.log("tethering offload not supported");
}
#method_after
public void start() {
    if (started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            mLog.i("tethering offload config not supported");
            return;
        }
    }
    // TODO: Create and register ITetheringOffloadCallback.
    mControlInitialized = mHwInterface.initOffloadControl();
}
#end_block

#method_before
public void stop() {
    // TODO: stopOffload().
    mUpstreamLinkProperties = null;
}
#method_after
public void stop() {
    mUpstreamLinkProperties = null;
    mHwInterface.stopOffloadControl();
    mControlInitialized = false;
    mConfigInitialized = false;
}
#end_block

#method_before
public void setUpstreamLinkProperties(LinkProperties lp) {
    // TODO: setUpstreamParameters().
    mUpstreamLinkProperties = lp;
}
#method_after
public void setUpstreamLinkProperties(LinkProperties lp) {
    if (!started())
        return;
    // TODO: setUpstreamParameters().
    mUpstreamLinkProperties = lp;
}
#end_block

#method_before
public void registerMobileNetworkRequest() {
    if (mMobileNetworkCallback != null) {
        mLog.error("registerMobileNetworkRequest() already registered");
        return;
    }
    // The following use of the legacy type system cannot be removed until
    // after upstream selection no longer finds networks by legacy type.
    // See also http://b/34364553 .
    final int legacyType = mDunRequired ? TYPE_MOBILE_DUN : TYPE_MOBILE_HIPRI;
    final NetworkRequest mobileUpstreamRequest = new NetworkRequest.Builder().setCapabilities(ConnectivityManager.networkCapabilitiesForType(legacyType)).build();
    // The existing default network and DUN callbacks will be notified.
    // Therefore, to avoid duplicate notifications, we only register a no-op.
    mMobileNetworkCallback = new UpstreamNetworkCallback(CALLBACK_MOBILE_REQUEST);
    // TODO: Change the timeout from 0 (no onUnavailable callback) to some
    // moderate callback timeout. This might be useful for updating some UI.
    // Additionally, we log a message to aid in any subsequent debugging.
    mLog.logAndEmit("requesting mobile upstream network: " + mobileUpstreamRequest);
    cm().requestNetwork(mobileUpstreamRequest, mMobileNetworkCallback, 0, legacyType, mHandler);
}
#method_after
public void registerMobileNetworkRequest() {
    if (mMobileNetworkCallback != null) {
        mLog.e("registerMobileNetworkRequest() already registered");
        return;
    }
    // The following use of the legacy type system cannot be removed until
    // after upstream selection no longer finds networks by legacy type.
    // See also http://b/34364553 .
    final int legacyType = mDunRequired ? TYPE_MOBILE_DUN : TYPE_MOBILE_HIPRI;
    final NetworkRequest mobileUpstreamRequest = new NetworkRequest.Builder().setCapabilities(ConnectivityManager.networkCapabilitiesForType(legacyType)).build();
    // The existing default network and DUN callbacks will be notified.
    // Therefore, to avoid duplicate notifications, we only register a no-op.
    mMobileNetworkCallback = new UpstreamNetworkCallback(CALLBACK_MOBILE_REQUEST);
    // TODO: Change the timeout from 0 (no onUnavailable callback) to some
    // moderate callback timeout. This might be useful for updating some UI.
    // Additionally, we log a message to aid in any subsequent debugging.
    mLog.i("requesting mobile upstream network: " + mobileUpstreamRequest);
    cm().requestNetwork(mobileUpstreamRequest, mMobileNetworkCallback, 0, legacyType, mHandler);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mSharedLog.forSubSystem(anyString())).thenReturn(mSharedLog);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mSharedLog.forSubComponent(anyString())).thenReturn(mSharedLog);
}
#end_block

#method_before
public void log(String msg) {
    record(NO_CATEGORY, msg);
}
#method_after
// ////
// Methods that only log an entry (and do NOT emit to the system log).
// ////
public void log(String msg) {
    record(Category.NONE, msg);
}
#end_block

#method_before
public void mark(String msg) {
    record(MARK, msg);
}
#method_after
public void mark(String msg) {
    record(Category.MARK, msg);
}
#end_block

#method_before
private void record(String category, String msg) {
    mLocalLog.log(logLine(category, msg));
}
#method_after
private String record(Category category, String msg) {
    final String entry = logLine(category, msg);
    mLocalLog.log(entry);
    return entry;
}
#end_block

#method_before
private String logLine(String category, String msg) {
    final StringJoiner sj = new StringJoiner(" ");
    if (!TextUtils.isEmpty(mSubSystem))
        sj.add("[" + mSubSystem + "]");
    if (!TextUtils.isEmpty(category))
        sj.add(category);
    return sj.add(msg).toString();
}
#method_after
private String logLine(Category category, String msg) {
    final StringJoiner sj = new StringJoiner(" ");
    if (!isRootLogInstance())
        sj.add("[" + mComponent + "]");
    if (category != Category.NONE)
        sj.add(category.toString());
    return sj.add(msg).toString();
}
#end_block

#method_before
public boolean start() {
    // instance and calling getifaddrs() directly).
    try {
        mNetworkInterface = NetworkInterface.getByName(mIfName);
    } catch (SocketException e) {
        mLog.error("Error looking up NetworkInterfaces: " + e);
        stop();
        return false;
    }
    if (mNetworkInterface == null) {
        mLog.error("Failed to find NetworkInterface");
        stop();
        return false;
    }
    try {
        mHwAddr = mNetworkInterface.getHardwareAddress();
    } catch (SocketException e) {
        mLog.error("Failed to find hardware address: " + e);
        stop();
        return false;
    }
    final int ifindex = mNetworkInterface.getIndex();
    mRaDaemon = new RouterAdvertisementDaemon(mIfName, ifindex, mHwAddr);
    if (!mRaDaemon.start()) {
        stop();
        return false;
    }
    return true;
}
#method_after
public boolean start() {
    // instance and calling getifaddrs() directly).
    try {
        mNetworkInterface = NetworkInterface.getByName(mIfName);
    } catch (SocketException e) {
        mLog.e("Error looking up NetworkInterfaces: " + e);
        stop();
        return false;
    }
    if (mNetworkInterface == null) {
        mLog.e("Failed to find NetworkInterface");
        stop();
        return false;
    }
    try {
        mHwAddr = mNetworkInterface.getHardwareAddress();
    } catch (SocketException e) {
        mLog.e("Failed to find hardware address: " + e);
        stop();
        return false;
    }
    final int ifindex = mNetworkInterface.getIndex();
    mRaDaemon = new RouterAdvertisementDaemon(mIfName, ifindex, mHwAddr);
    if (!mRaDaemon.start()) {
        stop();
        return false;
    }
    return true;
}
#end_block

#method_before
private void configureLocalRoutes(HashSet<IpPrefix> deprecatedPrefixes, HashSet<IpPrefix> newPrefixes) {
    // [1] Remove the routes that are deprecated.
    if (!deprecatedPrefixes.isEmpty()) {
        final ArrayList<RouteInfo> toBeRemoved = getLocalRoutesFor(deprecatedPrefixes);
        try {
            final int removalFailures = mNMService.removeRoutesFromLocalNetwork(toBeRemoved);
            if (removalFailures > 0) {
                mLog.error(String.format("Failed to remove %d IPv6 routes from local table.", removalFailures));
            }
        } catch (RemoteException e) {
            mLog.error("Failed to remove IPv6 routes from local table: " + e);
        }
    }
    // [2] Add only the routes that have not previously been added.
    if (newPrefixes != null && !newPrefixes.isEmpty()) {
        HashSet<IpPrefix> addedPrefixes = (HashSet) newPrefixes.clone();
        if (mLastRaParams != null) {
            addedPrefixes.removeAll(mLastRaParams.prefixes);
        }
        if (mLastRaParams == null || mLastRaParams.prefixes.isEmpty()) {
            // We need to be able to send unicast RAs, and clients might
            // like to ping the default router's link-local address.  Note
            // that we never remove the link-local route from the network
            // until Tethering disables tethering on the interface. We
            // only need to add the link-local prefix once, but in the
            // event we add it more than once netd silently ignores EEXIST.
            addedPrefixes.add(LINK_LOCAL_PREFIX);
        }
        if (!addedPrefixes.isEmpty()) {
            final ArrayList<RouteInfo> toBeAdded = getLocalRoutesFor(addedPrefixes);
            try {
                // It's safe to call addInterfaceToLocalNetwork() even if
                // the interface is already in the local_network. Note also
                // that adding routes that already exist does not cause an
                // error (EEXIST is silently ignored).
                mNMService.addInterfaceToLocalNetwork(mIfName, toBeAdded);
            } catch (RemoteException e) {
                mLog.error("Failed to add IPv6 routes to local table: " + e);
            }
        }
    }
}
#method_after
private void configureLocalRoutes(HashSet<IpPrefix> deprecatedPrefixes, HashSet<IpPrefix> newPrefixes) {
    // [1] Remove the routes that are deprecated.
    if (!deprecatedPrefixes.isEmpty()) {
        final ArrayList<RouteInfo> toBeRemoved = getLocalRoutesFor(deprecatedPrefixes);
        try {
            final int removalFailures = mNMService.removeRoutesFromLocalNetwork(toBeRemoved);
            if (removalFailures > 0) {
                mLog.e(String.format("Failed to remove %d IPv6 routes from local table.", removalFailures));
            }
        } catch (RemoteException e) {
            mLog.e("Failed to remove IPv6 routes from local table: " + e);
        }
    }
    // [2] Add only the routes that have not previously been added.
    if (newPrefixes != null && !newPrefixes.isEmpty()) {
        HashSet<IpPrefix> addedPrefixes = (HashSet) newPrefixes.clone();
        if (mLastRaParams != null) {
            addedPrefixes.removeAll(mLastRaParams.prefixes);
        }
        if (mLastRaParams == null || mLastRaParams.prefixes.isEmpty()) {
            // We need to be able to send unicast RAs, and clients might
            // like to ping the default router's link-local address.  Note
            // that we never remove the link-local route from the network
            // until Tethering disables tethering on the interface. We
            // only need to add the link-local prefix once, but in the
            // event we add it more than once netd silently ignores EEXIST.
            addedPrefixes.add(LINK_LOCAL_PREFIX);
        }
        if (!addedPrefixes.isEmpty()) {
            final ArrayList<RouteInfo> toBeAdded = getLocalRoutesFor(addedPrefixes);
            try {
                // It's safe to call addInterfaceToLocalNetwork() even if
                // the interface is already in the local_network. Note also
                // that adding routes that already exist does not cause an
                // error (EEXIST is silently ignored).
                mNMService.addInterfaceToLocalNetwork(mIfName, toBeAdded);
            } catch (RemoteException e) {
                mLog.e("Failed to add IPv6 routes to local table: " + e);
            }
        }
    }
}
#end_block

#method_before
private void configureLocalDns(HashSet<Inet6Address> deprecatedDnses, HashSet<Inet6Address> newDnses) {
    final INetd netd = NetdService.getInstance();
    if (netd == null) {
        if (newDnses != null)
            newDnses.clear();
        mLog.error("No netd service instance available; not setting local IPv6 addresses");
        return;
    }
    // [1] Remove deprecated local DNS IP addresses.
    if (!deprecatedDnses.isEmpty()) {
        for (Inet6Address dns : deprecatedDnses) {
            final String dnsString = dns.getHostAddress();
            try {
                netd.interfaceDelAddress(mIfName, dnsString, RFC7421_PREFIX_LENGTH);
            } catch (ServiceSpecificException | RemoteException e) {
                mLog.error("Failed to remove local dns IP " + dnsString + ": " + e);
            }
        }
    }
    // [2] Add only the local DNS IP addresses that have not previously been added.
    if (newDnses != null && !newDnses.isEmpty()) {
        final HashSet<Inet6Address> addedDnses = (HashSet) newDnses.clone();
        if (mLastRaParams != null) {
            addedDnses.removeAll(mLastRaParams.dnses);
        }
        for (Inet6Address dns : addedDnses) {
            final String dnsString = dns.getHostAddress();
            try {
                netd.interfaceAddAddress(mIfName, dnsString, RFC7421_PREFIX_LENGTH);
            } catch (ServiceSpecificException | RemoteException e) {
                mLog.error("Failed to add local dns IP " + dnsString + ": " + e);
                newDnses.remove(dns);
            }
        }
    }
    try {
        netd.tetherApplyDnsInterfaces();
    } catch (ServiceSpecificException | RemoteException e) {
        mLog.error("Failed to update local DNS caching server");
        if (newDnses != null)
            newDnses.clear();
    }
}
#method_after
private void configureLocalDns(HashSet<Inet6Address> deprecatedDnses, HashSet<Inet6Address> newDnses) {
    final INetd netd = NetdService.getInstance();
    if (netd == null) {
        if (newDnses != null)
            newDnses.clear();
        mLog.e("No netd service instance available; not setting local IPv6 addresses");
        return;
    }
    // [1] Remove deprecated local DNS IP addresses.
    if (!deprecatedDnses.isEmpty()) {
        for (Inet6Address dns : deprecatedDnses) {
            final String dnsString = dns.getHostAddress();
            try {
                netd.interfaceDelAddress(mIfName, dnsString, RFC7421_PREFIX_LENGTH);
            } catch (ServiceSpecificException | RemoteException e) {
                mLog.e("Failed to remove local dns IP " + dnsString + ": " + e);
            }
        }
    }
    // [2] Add only the local DNS IP addresses that have not previously been added.
    if (newDnses != null && !newDnses.isEmpty()) {
        final HashSet<Inet6Address> addedDnses = (HashSet) newDnses.clone();
        if (mLastRaParams != null) {
            addedDnses.removeAll(mLastRaParams.dnses);
        }
        for (Inet6Address dns : addedDnses) {
            final String dnsString = dns.getHostAddress();
            try {
                netd.interfaceAddAddress(mIfName, dnsString, RFC7421_PREFIX_LENGTH);
            } catch (ServiceSpecificException | RemoteException e) {
                mLog.e("Failed to add local dns IP " + dnsString + ": " + e);
                newDnses.remove(dns);
            }
        }
    }
    try {
        netd.tetherApplyDnsInterfaces();
    } catch (ServiceSpecificException | RemoteException e) {
        mLog.e("Failed to update local DNS caching server");
        if (newDnses != null)
            newDnses.clear();
    }
}
#end_block

#method_before
@Override
public Object getSystemService(String name) {
    if (Context.TELEPHONY_SERVICE.equals(name)) {
        return mWithTelephonyManager ? mTelephonyManager : null;
    }
    return super.getSystemService(name);
}
#method_after
@Override
public Object getSystemService(String name) {
    if (Context.TELEPHONY_SERVICE.equals(name)) {
        return mHasTelephonyManager ? mTelephonyManager : null;
    }
    return super.getSystemService(name);
}
#end_block

#method_before
@Test
public void testDunFromTelephonyManagerMeansDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE, TYPE_WIFI, TYPE_MOBILE_HIPRI });
    mWithTelephonyManager = true;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_REQUIRED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertTrue(cfg.isDunRequired);
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE));
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#method_after
@Test
public void testDunFromTelephonyManagerMeansDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE, TYPE_WIFI, TYPE_MOBILE_HIPRI });
    mHasTelephonyManager = true;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_REQUIRED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertTrue(cfg.isDunRequired);
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE));
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#end_block

#method_before
@Test
public void testDunNotRequiredFromTelephonyManagerMeansNoDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE_DUN, TYPE_WIFI });
    mWithTelephonyManager = true;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_NOT_REQUIRED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertFalse(cfg.isDunRequired);
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE));
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#method_after
@Test
public void testDunNotRequiredFromTelephonyManagerMeansNoDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE_DUN, TYPE_WIFI });
    mHasTelephonyManager = true;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_NOT_REQUIRED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertFalse(cfg.isDunRequired);
    assertFalse(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE));
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#end_block

#method_before
@Test
public void testDunFromUpstreamConfigMeansDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE_DUN, TYPE_WIFI });
    mWithTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertTrue(cfg.isDunRequired);
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#method_after
@Test
public void testDunFromUpstreamConfigMeansDun() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_MOBILE_DUN, TYPE_WIFI });
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext);
    assertTrue(cfg.isDunRequired);
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_MOBILE_DUN));
    // Just to prove we haven't clobbered Wi-Fi:
    assertTrue(cfg.preferredUpstreamIfaceTypes.contains(TYPE_WIFI));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG)
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG)
                        Slog.d(TAG, "Binding to service to get name and address");
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG)
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(new Integer(msg.arg1));
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(service);
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(service);
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly)
                            return;
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (mQuietEnable == false) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null)
                            break;
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(REASON_UNEXPECTED, false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(REASON_RESTARTED, true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mEnable && mBluetooth != null) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(REASON_USER_SWITCH, false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(REASON_USER_SWITCH, true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG)
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG)
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG)
                        Slog.d(TAG, "Binding to service to get name and address");
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG)
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            try {
                if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                    if (DBG)
                        Slog.d(TAG, "Restore Bluetooth state to disabled");
                    disable(REASON_RESTORE_USER_SETTING, true);
                } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                    if (DBG)
                        Slog.d(TAG, "Restore Bluetooth state to enabled");
                    enable(REASON_RESTORE_USER_SETTING);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "Unable to change Bluetooth On setting", e);
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(new Integer(msg.arg1));
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(service);
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(service);
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly)
                            return;
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (mQuietEnable == false) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null)
                            break;
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(REASON_UNEXPECTED, false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(REASON_RESTARTED, true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mBluetooth != null && isEnabled()) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(REASON_USER_SWITCH, false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(REASON_USER_SWITCH, true);
                    // mEnable flag could have been reset on disableBLE. Reenable it.
                    mEnable = true;
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG)
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#end_block

#method_before
public void start() {
    if (!mState.configComplete) {
        mState.configComplete = configOffload();
        if (!mState.configComplete) {
            Log.d(TAG, "tethering offload not supported");
            return;
        }
    }
// TODO: initOffload() and configure callbacks to be handled on our
// preferred Handler.
}
#method_after
public void start() {
    if (started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            Log.d(TAG, "tethering offload config not supported");
            return;
        }
    }
    // TODO: Create and register ITetheringOffloadCallback.
    mControlInitialized = mHwInterface.initOffloadControl();
}
#end_block

#method_before
public void stop() {
    if (!mState.started())
        return;
    // TODO: stopOffload().
    mUpstreamLinkProperties = null;
}
#method_after
public void stop() {
    mUpstreamLinkProperties = null;
    mHwInterface.stopOffloadControl();
    mControlInitialized = false;
    mConfigInitialized = false;
}
#end_block

#method_before
public void setUpstreamLinkProperties(LinkProperties lp) {
    if (!mState.started())
        return;
    // TODO: setUpstreamParameters().
    mUpstreamLinkProperties = lp;
}
#method_after
public void setUpstreamLinkProperties(LinkProperties lp) {
    if (!started())
        return;
    // TODO: setUpstreamParameters().
    mUpstreamLinkProperties = lp;
}
#end_block

#method_before
protected boolean cleanup() {
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mInputDevices != null) {
        mInputDevices.clear();
    }
    clearHidService();
    return true;
}
#method_after
protected boolean cleanup() {
    if (mNativeAvailable) {
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mInputDevices != null) {
        for (BluetoothDevice device : mInputDevices.keySet()) {
            int inputDeviceState = getConnectionState(device);
            if (inputDeviceState != BluetoothProfile.STATE_DISCONNECTED) {
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED);
            }
        }
        mInputDevices.clear();
    }
    clearHidService();
    return true;
}
#end_block

#method_before
boolean sendData(BluetoothDevice device, String report) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    int state = this.getConnectionState(device);
    if (state != BluetoothInputDevice.STATE_CONNECTED) {
        return false;
    }
    return sendDataNative(Utils.getByteAddress(device), report);
/*Message msg = mHandler.obtainMessage(MESSAGE_SEND_DATA);
        msg.obj = device;
        Bundle data = new Bundle();
        data.putString(BluetoothInputDevice.EXTRA_REPORT, report);
        msg.setData(data);
        mHandler.sendMessage(msg);
        return true ;*/
}
#method_after
boolean sendData(BluetoothDevice device, String report) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    int state = this.getConnectionState(device);
    if (state != BluetoothInputDevice.STATE_CONNECTED) {
        return false;
    }
    return sendDataNative(Utils.getByteAddress(device), report);
}
#end_block

#method_before
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothInputDevice.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    log("Connection state " + device + ": " + prevState + "->" + newState);
    notifyProfileConnectionStateChanged(device, BluetoothProfile.INPUT_DEVICE, newState, prevState);
    Intent intent = new Intent(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#method_after
private void broadcastConnectionState(BluetoothDevice device, int newState) {
    Integer prevStateInteger = mInputDevices.get(device);
    int prevState = (prevStateInteger == null) ? BluetoothInputDevice.STATE_DISCONNECTED : prevStateInteger;
    if (prevState == newState) {
        Log.w(TAG, "no state change: " + newState);
        return;
    }
    mInputDevices.put(device, newState);
    /* Notifying the connection state change of the profile before sending the intent for
           connection state change, as it was causing a race condition, with the UI not being
           updated with the correct connection state. */
    log("Connection state " + device + ": " + prevState + "->" + newState);
    Intent intent = new Intent(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
    intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
    intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    sendBroadcast(intent, BLUETOOTH_PERM);
}
#end_block

#method_before
static void testNoOverride() {
    sArray = new Main1[3];
    sArray[0] = new Main1();
    sArray[1] = new Main2();
    sArray[2] = new Main3();
    long sum = 0;
    for (int i = 0; i < 200000; i++) {
        testNoOverrideLoop(1);
    }
    try {
        Thread.sleep(5000);
    } catch (Exception e) {
    }
    long t1 = System.currentTimeMillis();
    sum = testNoOverrideLoop(10000000);
    long t2 = System.currentTimeMillis();
    if (sum != 2730000000L) {
        System.out.println("Unexpected result.");
    }
}
#method_after
static void testNoOverride() {
    sArray = new Main1[3];
    sArray[0] = new Main1();
    sArray[1] = Dummy.createMain2();
    sArray[2] = Dummy.createMain3();
    long sum = 0;
    // Loop enough to get methods JITed.
    for (int i = 0; i < 100; i++) {
        testNoOverrideLoop(1);
    }
    ensureJitCompiled(Main.class, "testNoOverrideLoop");
    ensureJitCompiled(Main.class, "calcValue");
    long t1 = System.currentTimeMillis();
    sum = testNoOverrideLoop(100000);
    long t2 = System.currentTimeMillis();
    if (sum != 27300000L) {
        System.out.println("Unexpected result.");
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    // Allow some initial jitting to be finished.
    try {
        Thread.sleep(2000);
    } catch (Exception e) {
    }
    // sMain1 is an instance of Main1. Main2 hasn't bee loaded yet.
    sMain1 = new Main1();
    // Make helper start to be jitted.
    for (int i = 0; i < 100; i++) {
        helper(i, true);
    }
    // Give some time for jitting helper() to be completed.
    try {
        Thread.sleep(5000);
    } catch (Exception e) {
    }
    // Create another thread that also calls sMain1.foo().
    new Thread() {

        public void run() {
            for (int i = 0; i < 1000; i++) {
                helper(i, false);
            }
        }
    }.start();
    // This will create Main2 instance in the middle of helper().
    for (int i = 0; i < 200; i++) {
        helper(i, true);
    }
    testNoOverride();
}
#method_after
// Test scanerios under which CHA-based devirtualization happens,
// and class loading that overrides a method can invalidate compiled code.
// Also test pure non-overriding case, which is more for checking generated
public static void main(String[] args) {
    System.loadLibrary(args[0]);
    // CHeck some boot-image methods.
    assertSingleImplementation(java.util.ArrayList.class, "size", true);
    // java.util.LinkedHashMap overrides get().
    assertSingleImplementation(java.util.HashMap.class, "get", false);
    // We don't set single-implementation modifier bit for final classes or methods
    // since we can devirtualize without CHA for those cases. However hasSingleImplementation()
    // should return true for those cases.
    assertSingleImplementation(java.lang.String.class, "charAt", true);
    assertSingleImplementation(java.lang.Thread.class, "join", true);
    // We don't set single-implementation modifier bit for native methods.
    assertSingleImplementation(java.lang.Thread.class, "isInterrupted", false);
    if (isInterpreted()) {
        sIsOptimizing = false;
    }
    // sMain1 is an instance of Main1. Main2 hasn't bee loaded yet.
    sMain1 = new Main1();
    // Loop enough to get testOverride() JITed.
    for (int i = 0; i < 100; i++) {
        testOverride(false, false, false);
    }
    ensureJitCompiled(Main.class, "testOverride");
    testOverride(false, false, true);
    if (sHasJIT && !sIsOptimizing) {
        assertSingleImplementation(Main1.class, "foo", true);
    } else {
    // Main2 is verified ahead-of-time so it's linked in already.
    }
    assertSingleImplementation(Main1.class, "getValue1", true);
    // Create another thread that also calls sMain1.foo().
    // Try to test suspend and deopt another thread.
    new Thread() {

        public void run() {
            testOverride(false, true, false);
        }
    }.start();
    // This will create Main2 instance in the middle of testOverride().
    testOverride(true, false, false);
    assertSingleImplementation(Main1.class, "foo", false);
    assertSingleImplementation(Main1.class, "getValue1", true);
    testNoOverride();
}
#end_block

#method_before
static void createMain2() {
    if (Main.sMain1.getClass() == Main1.class) {
        Main.sMain1 = new Main2();
    }
}
#method_after
static Main1 createMain2() {
    return new Main2();
}
#end_block

#method_before
static int countQuotes(String string, int from, int to) {
    int count = 0;
    int escape = 0;
    for (int i = from; i < to; i++) {
        if (string.charAt(i) == '"' && escape % 2 == 0) {
            count++;
        }
        escape = (string.charAt(i) == '\\') ? escape + 1 : 0;
    }
    return count;
}
#method_after
static int countQuotes(String string, int from, int to) {
    int count = 0;
    // BEGIN Android-changed: Fix countQuotes in case of escaped backslashes: \\"
    int escape = 0;
    for (int i = from; i < to; i++) {
        if (string.charAt(i) == '"' && escape % 2 == 0) {
            count++;
        }
        escape = (string.charAt(i) == '\\') ? escape + 1 : 0;
    }
    return count;
}
#end_block

#method_before
protected void decodeParams() throws IOException {
    String algidString = algid.toString();
    try {
        algParams = AlgorithmParameters.getInstance(algidString);
    } catch (NoSuchAlgorithmException e) {
        // BEGIN Android-changed
        // It was searching for the EC parameters in an internal provider in the deleted package
        // sun.security.ec before setting them to null. Since EC is in the OpenSSL provider,
        // there's no need for such fallback. Setting it to null directly.
        /*
             * This algorithm parameter type is not supported, so we cannot
             * parse the parameters.
             */
        algParams = null;
        return;
    // END Android-changed
    }
    // Decode (parse) the parameters
    algParams.init(params.toByteArray());
}
#method_after
protected void decodeParams() throws IOException {
    String algidString = algid.toString();
    try {
        algParams = AlgorithmParameters.getInstance(algidString);
    } catch (NoSuchAlgorithmException e) {
        /*
             * This algorithm parameter type is not supported, so we cannot
             * parse the parameters.
             */
        algParams = null;
        return;
    }
    // Decode (parse) the parameters
    algParams.init(params.toByteArray());
}
#end_block

#method_before
private static ObjectIdentifier algOID(String name) throws IOException {
    // See if algname is in printable OID ("dot-dot") notation
    if (name.indexOf('.') != -1) {
        if (name.startsWith("OID.")) {
            return new ObjectIdentifier(name.substring("OID.".length()));
        } else {
            return new ObjectIdentifier(name);
        }
    }
    // Digesting algorithms
    if (name.equalsIgnoreCase("MD5")) {
        return AlgorithmId.MD5_oid;
    }
    if (name.equalsIgnoreCase("MD2")) {
        return AlgorithmId.MD2_oid;
    }
    if (name.equalsIgnoreCase("SHA") || name.equalsIgnoreCase("SHA1") || name.equalsIgnoreCase("SHA-1")) {
        return AlgorithmId.SHA_oid;
    }
    if (name.equalsIgnoreCase("SHA-256") || name.equalsIgnoreCase("SHA256")) {
        return AlgorithmId.SHA256_oid;
    }
    if (name.equalsIgnoreCase("SHA-384") || name.equalsIgnoreCase("SHA384")) {
        return AlgorithmId.SHA384_oid;
    }
    if (name.equalsIgnoreCase("SHA-512") || name.equalsIgnoreCase("SHA512")) {
        return AlgorithmId.SHA512_oid;
    }
    if (name.equalsIgnoreCase("SHA-224") || name.equalsIgnoreCase("SHA224")) {
        return AlgorithmId.SHA224_oid;
    }
    // Various public key algorithms
    if (name.equalsIgnoreCase("RSA")) {
        return AlgorithmId.RSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("Diffie-Hellman") || name.equalsIgnoreCase("DH")) {
        return AlgorithmId.DH_oid;
    }
    if (name.equalsIgnoreCase("DSA")) {
        return AlgorithmId.DSA_oid;
    }
    if (name.equalsIgnoreCase("EC")) {
        return EC_oid;
    }
    if (name.equalsIgnoreCase("ECDH")) {
        return AlgorithmId.ECDH_oid;
    }
    // Secret key algorithms
    if (name.equalsIgnoreCase("AES")) {
        return AlgorithmId.AES_oid;
    }
    // Common signature types
    if (name.equalsIgnoreCase("MD5withRSA") || name.equalsIgnoreCase("MD5/RSA")) {
        return AlgorithmId.md5WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("MD2withRSA") || name.equalsIgnoreCase("MD2/RSA")) {
        return AlgorithmId.md2WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("SHAwithDSA") || name.equalsIgnoreCase("SHA1withDSA") || name.equalsIgnoreCase("SHA/DSA") || name.equalsIgnoreCase("SHA1/DSA") || name.equalsIgnoreCase("DSAWithSHA1") || name.equalsIgnoreCase("DSS") || name.equalsIgnoreCase("SHA-1/DSA")) {
        return AlgorithmId.sha1WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA224WithDSA")) {
        return AlgorithmId.sha224WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA256WithDSA")) {
        return AlgorithmId.sha256WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA1WithRSA") || name.equalsIgnoreCase("SHA1/RSA")) {
        return AlgorithmId.sha1WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("SHA1withECDSA") || name.equalsIgnoreCase("ECDSA")) {
        return AlgorithmId.sha1WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA224withECDSA")) {
        return AlgorithmId.sha224WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA256withECDSA")) {
        return AlgorithmId.sha256WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA384withECDSA")) {
        return AlgorithmId.sha384WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA512withECDSA")) {
        return AlgorithmId.sha512WithECDSA_oid;
    }
    // the given algorithm name to an OID string
    synchronized (oidTable) {
        reinitializeMappingTableLocked();
        return oidTable.get(name.toUpperCase(Locale.ENGLISH));
    }
}
#method_after
private static ObjectIdentifier algOID(String name) throws IOException {
    // See if algname is in printable OID ("dot-dot") notation
    if (name.indexOf('.') != -1) {
        if (name.startsWith("OID.")) {
            return new ObjectIdentifier(name.substring("OID.".length()));
        } else {
            return new ObjectIdentifier(name);
        }
    }
    // Digesting algorithms
    if (name.equalsIgnoreCase("MD5")) {
        return AlgorithmId.MD5_oid;
    }
    if (name.equalsIgnoreCase("MD2")) {
        return AlgorithmId.MD2_oid;
    }
    if (name.equalsIgnoreCase("SHA") || name.equalsIgnoreCase("SHA1") || name.equalsIgnoreCase("SHA-1")) {
        return AlgorithmId.SHA_oid;
    }
    if (name.equalsIgnoreCase("SHA-256") || name.equalsIgnoreCase("SHA256")) {
        return AlgorithmId.SHA256_oid;
    }
    if (name.equalsIgnoreCase("SHA-384") || name.equalsIgnoreCase("SHA384")) {
        return AlgorithmId.SHA384_oid;
    }
    if (name.equalsIgnoreCase("SHA-512") || name.equalsIgnoreCase("SHA512")) {
        return AlgorithmId.SHA512_oid;
    }
    if (name.equalsIgnoreCase("SHA-224") || name.equalsIgnoreCase("SHA224")) {
        return AlgorithmId.SHA224_oid;
    }
    // Various public key algorithms
    if (name.equalsIgnoreCase("RSA")) {
        return AlgorithmId.RSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("Diffie-Hellman") || name.equalsIgnoreCase("DH")) {
        return AlgorithmId.DH_oid;
    }
    if (name.equalsIgnoreCase("DSA")) {
        return AlgorithmId.DSA_oid;
    }
    if (name.equalsIgnoreCase("EC")) {
        return EC_oid;
    }
    if (name.equalsIgnoreCase("ECDH")) {
        return AlgorithmId.ECDH_oid;
    }
    // Secret key algorithms
    if (name.equalsIgnoreCase("AES")) {
        return AlgorithmId.AES_oid;
    }
    // Common signature types
    if (name.equalsIgnoreCase("MD5withRSA") || name.equalsIgnoreCase("MD5/RSA")) {
        return AlgorithmId.md5WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("MD2withRSA") || name.equalsIgnoreCase("MD2/RSA")) {
        return AlgorithmId.md2WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("SHAwithDSA") || name.equalsIgnoreCase("SHA1withDSA") || name.equalsIgnoreCase("SHA/DSA") || name.equalsIgnoreCase("SHA1/DSA") || name.equalsIgnoreCase("DSAWithSHA1") || name.equalsIgnoreCase("DSS") || name.equalsIgnoreCase("SHA-1/DSA")) {
        return AlgorithmId.sha1WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA224WithDSA")) {
        return AlgorithmId.sha224WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA256WithDSA")) {
        return AlgorithmId.sha256WithDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA1WithRSA") || name.equalsIgnoreCase("SHA1/RSA")) {
        return AlgorithmId.sha1WithRSAEncryption_oid;
    }
    if (name.equalsIgnoreCase("SHA1withECDSA") || name.equalsIgnoreCase("ECDSA")) {
        return AlgorithmId.sha1WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA224withECDSA")) {
        return AlgorithmId.sha224WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA256withECDSA")) {
        return AlgorithmId.sha256WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA384withECDSA")) {
        return AlgorithmId.sha384WithECDSA_oid;
    }
    if (name.equalsIgnoreCase("SHA512withECDSA")) {
        return AlgorithmId.sha512WithECDSA_oid;
    }
    // BEGIN Android-changed: Update algorithm mapping tables for names when OID is used
    synchronized (oidTable) {
        reinitializeMappingTableLocked();
        return oidTable.get(name.toUpperCase(Locale.ENGLISH));
    }
}
#end_block

#method_before
private static void reinitializeMappingTableLocked() {
    // Android-changed: Update the table only if the OID changed. Also synchronize
    // on oidTable for thread safety.
    int currentVersion = Security.getVersion();
    if (initOidTableVersion != currentVersion) {
        Provider[] provs = Security.getProviders();
        for (int i = 0; i < provs.length; i++) {
            for (Enumeration<Object> enum_ = provs[i].keys(); enum_.hasMoreElements(); ) {
                String alias = (String) enum_.nextElement();
                String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
                int index;
                if (upperCaseAlias.startsWith("ALG.ALIAS")) {
                    if ((index = upperCaseAlias.indexOf("OID.", 0)) != -1) {
                        index += "OID.".length();
                        if (index == alias.length()) {
                            // invalid alias entry
                            break;
                        }
                        String oidString = alias.substring(index);
                        String stdAlgName = provs[i].getProperty(alias);
                        if (stdAlgName != null) {
                            stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
                            ObjectIdentifier oid = null;
                            try {
                                oid = new ObjectIdentifier(oidString);
                            } catch (IOException e) {
                            // Not an OID.
                            }
                            if (oid != null) {
                                if (!oidTable.containsKey(stdAlgName)) {
                                    oidTable.put(stdAlgName, oid);
                                }
                                if (!nameTable.containsKey(oid)) {
                                    nameTable.put(oid, stdAlgName);
                                }
                            }
                        }
                    } else {
                        // Android-changed: If the alias isn't specified with an explicit
                        // "OID." in the name, we still attempt to parse it as one.
                        final int sep = alias.indexOf('.', "ALG.ALIAS.".length());
                        String suffix = alias.substring(sep + 1);
                        ObjectIdentifier oid = null;
                        try {
                            oid = new ObjectIdentifier(suffix);
                        } catch (IOException e) {
                        // Not an OID.
                        }
                        if (oid != null) {
                            String stdAlgName = provs[i].getProperty(alias);
                            if (stdAlgName != null) {
                                stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
                                if (!oidTable.containsKey(stdAlgName)) {
                                    oidTable.put(stdAlgName, oid);
                                }
                                if (!nameTable.containsKey(oid)) {
                                    nameTable.put(oid, stdAlgName);
                                }
                            }
                        }
                    }
                }
            }
        }
        initOidTableVersion = currentVersion;
    }
}
#method_after
private static void reinitializeMappingTableLocked() {
    // Android-changed: Update the table only if the OID changed. Also synchronize
    // on oidTable for thread safety.
    int currentVersion = Security.getVersion();
    if (initOidTableVersion != currentVersion) {
        Provider[] provs = Security.getProviders();
        for (int i = 0; i < provs.length; i++) {
            for (Enumeration<Object> enum_ = provs[i].keys(); enum_.hasMoreElements(); ) {
                String alias = (String) enum_.nextElement();
                String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
                int index;
                if (upperCaseAlias.startsWith("ALG.ALIAS")) {
                    if ((index = upperCaseAlias.indexOf("OID.", 0)) != -1) {
                        index += "OID.".length();
                        if (index == alias.length()) {
                            // invalid alias entry
                            break;
                        }
                        String oidString = alias.substring(index);
                        String stdAlgName = provs[i].getProperty(alias);
                        if (stdAlgName != null) {
                            stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
                            ObjectIdentifier oid = null;
                            try {
                                oid = new ObjectIdentifier(oidString);
                            } catch (IOException e) {
                            // Not an OID.
                            }
                            if (oid != null) {
                                if (!oidTable.containsKey(stdAlgName)) {
                                    oidTable.put(stdAlgName, oid);
                                }
                                if (!nameTable.containsKey(oid)) {
                                    nameTable.put(oid, stdAlgName);
                                }
                            }
                        }
                    } else {
                        // Android-changed: If the alias isn't specified with an explicit
                        // "OID." in the name, we still attempt to parse it as one.
                        final int sep = alias.indexOf('.', "ALG.ALIAS.".length());
                        String suffix = alias.substring(sep + 1);
                        ObjectIdentifier oid = null;
                        try {
                            oid = new ObjectIdentifier(suffix);
                        } catch (IOException e) {
                        // Not an OID.
                        }
                        if (oid != null) {
                            String stdAlgName = provs[i].getProperty(alias);
                            if (stdAlgName != null) {
                                stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
                                if (!oidTable.containsKey(stdAlgName)) {
                                    oidTable.put(stdAlgName, oid);
                                }
                                if (!nameTable.containsKey(oid)) {
                                    nameTable.put(oid, stdAlgName);
                                }
                            }
                        }
                    }
                }
            }
        }
        initOidTableVersion = currentVersion;
    }
// END Android-changed: Update algorithm mapping tables for names when OID is used
}
#end_block

#method_before
public int compare(AVA a1, AVA a2) {
    boolean a1Has2253 = a1.hasRFC2253Keyword();
    boolean a2Has2253 = a2.hasRFC2253Keyword();
    // BEGIN Android-changed: Keep sort order of RDN from prev impl
    if (a1Has2253) {
        if (a2Has2253) {
            return a1.toRFC2253CanonicalString().compareTo(a2.toRFC2253CanonicalString());
        } else {
            return -1;
        }
    } else {
        if (a2Has2253) {
            return 1;
        } else {
            int[] a1Oid = a1.getObjectIdentifier().toIntArray();
            int[] a2Oid = a2.getObjectIdentifier().toIntArray();
            int pos = 0;
            int len = (a1Oid.length > a2Oid.length) ? a2Oid.length : a1Oid.length;
            while (pos < len && a1Oid[pos] == a2Oid[pos]) {
                ++pos;
            }
            return (pos == len) ? a1Oid.length - a2Oid.length : a1Oid[pos] - a2Oid[pos];
        }
    }
// BEGIN Android-changed: Keep sort order of RDN from prev impl
}
#method_after
public int compare(AVA a1, AVA a2) {
    boolean a1Has2253 = a1.hasRFC2253Keyword();
    boolean a2Has2253 = a2.hasRFC2253Keyword();
    // BEGIN Android-changed: Keep sort order of RDN from Android M
    if (a1Has2253) {
        if (a2Has2253) {
            return a1.toRFC2253CanonicalString().compareTo(a2.toRFC2253CanonicalString());
        } else {
            return -1;
        }
    } else {
        if (a2Has2253) {
            return 1;
        } else {
            int[] a1Oid = a1.getObjectIdentifier().toIntArray();
            int[] a2Oid = a2.getObjectIdentifier().toIntArray();
            int pos = 0;
            int len = (a1Oid.length > a2Oid.length) ? a2Oid.length : a1Oid.length;
            while (pos < len && a1Oid[pos] == a2Oid[pos]) {
                ++pos;
            }
            return (pos == len) ? a1Oid.length - a2Oid.length : a1Oid[pos] - a2Oid[pos];
        }
    }
// BEGIN Android-changed: Keep sort order of RDN from prev impl
}
#end_block

#method_before
private static DerValue parseHexString(Reader in, int format) throws IOException {
    int c;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    byte b = 0;
    int cNdx = 0;
    while (true) {
        c = in.read();
        if (isTerminator(c, format)) {
            break;
        }
        // Android-changed: Skip trailing whitespace.
        if (c == ' ' || c == '\n') {
            do {
                if (c != ' ' && c != '\n') {
                    throw new IOException("AVA parse, invalid hex " + "digit: " + (char) c);
                }
                c = in.read();
            } while (!isTerminator(c, format));
            break;
        }
        int cVal = hexDigits.indexOf(Character.toUpperCase((char) c));
        if (cVal == -1) {
            throw new IOException("AVA parse, invalid hex " + "digit: " + (char) c);
        }
        if ((cNdx % 2) == 1) {
            b = (byte) ((b * 16) + (byte) (cVal));
            baos.write(b);
        } else {
            b = (byte) (cVal);
        }
        cNdx++;
    }
    // throw exception if no hex digits
    if (cNdx == 0) {
        throw new IOException("AVA parse, zero hex digits");
    }
    // throw exception if odd number of hex digits
    if (cNdx % 2 == 1) {
        throw new IOException("AVA parse, odd number of hex digits");
    }
    return new DerValue(baos.toByteArray());
}
#method_after
private static DerValue parseHexString(Reader in, int format) throws IOException {
    int c;
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    byte b = 0;
    int cNdx = 0;
    while (true) {
        c = in.read();
        if (isTerminator(c, format)) {
            break;
        }
        // BEGIN Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n'
        if (c == ' ' || c == '\n') {
            do {
                if (c != ' ' && c != '\n') {
                    throw new IOException("AVA parse, invalid hex " + "digit: " + (char) c);
                }
                c = in.read();
            } while (!isTerminator(c, format));
            break;
        }
        // END Android-added: AVA: Support DerValue hex strings that contain ' ' or '\n'
        int cVal = hexDigits.indexOf(Character.toUpperCase((char) c));
        if (cVal == -1) {
            throw new IOException("AVA parse, invalid hex " + "digit: " + (char) c);
        }
        if ((cNdx % 2) == 1) {
            b = (byte) ((b * 16) + (byte) (cVal));
            baos.write(b);
        } else {
            b = (byte) (cVal);
        }
        cNdx++;
    }
    // throw exception if no hex digits
    if (cNdx == 0) {
        throw new IOException("AVA parse, zero hex digits");
    }
    // throw exception if odd number of hex digits
    if (cNdx % 2 == 1) {
        throw new IOException("AVA parse, odd number of hex digits");
    }
    return new DerValue(baos.toByteArray());
}
#end_block

#method_before
private DerValue parseQuotedString(Reader in, StringBuilder temp) throws IOException {
    // RFC1779 specifies that an entire RDN may be enclosed in double
    // quotes. In this case the syntax is any sequence of
    // backslash-specialChar, backslash-backslash,
    // backslash-doublequote, or character other than backslash or
    // doublequote.
    int c = readChar(in, "Quoted string did not end in quote");
    List<Byte> embeddedHex = new ArrayList<Byte>();
    boolean isPrintableString = true;
    while (c != '"') {
        if (c == '\\') {
            c = readChar(in, "Quoted string did not end in quote");
            // check for embedded hex pairs
            Byte hexByte = null;
            if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
                // always encode AVAs with embedded hex as UTF8
                isPrintableString = false;
                // append consecutive embedded hex
                // as single string later
                embeddedHex.add(hexByte);
                c = in.read();
                continue;
            }
            if (specialChars1779.indexOf((char) c) < 0) {
                throw new IOException("Invalid escaped character in AVA: " + (char) c);
            }
        }
        // add embedded hex bytes before next char
        if (embeddedHex.size() > 0) {
            String hexString = getEmbeddedHexString(embeddedHex);
            temp.append(hexString);
            embeddedHex.clear();
        }
        // check for non-PrintableString chars
        isPrintableString &= DerValue.isPrintableStringChar((char) c);
        temp.append((char) c);
        c = readChar(in, "Quoted string did not end in quote");
    }
    // add trailing embedded hex bytes
    if (embeddedHex.size() > 0) {
        String hexString = getEmbeddedHexString(embeddedHex);
        temp.append(hexString);
        embeddedHex.clear();
    }
    do {
        c = in.read();
    } while ((c == '\n') || (c == ' '));
    if (c != -1) {
        throw new IOException("AVA had characters other than " + "whitespace after terminating quote");
    }
    // Android-changed: Removed .trim() from .toString calls so they wouldn't remove spaces
    if (this.oid.equals((Object) PKCS9Attribute.EMAIL_ADDRESS_OID) || (this.oid.equals((Object) X500Name.DOMAIN_COMPONENT_OID) && PRESERVE_OLD_DC_ENCODING == false)) {
        // EmailAddress and DomainComponent must be IA5String
        return new DerValue(DerValue.tag_IA5String, temp.toString());
    } else if (isPrintableString) {
        return new DerValue(temp.toString());
    } else {
        return new DerValue(DerValue.tag_UTF8String, temp.toString());
    }
}
#method_after
private DerValue parseQuotedString(Reader in, StringBuilder temp) throws IOException {
    // RFC1779 specifies that an entire RDN may be enclosed in double
    // quotes. In this case the syntax is any sequence of
    // backslash-specialChar, backslash-backslash,
    // backslash-doublequote, or character other than backslash or
    // doublequote.
    int c = readChar(in, "Quoted string did not end in quote");
    List<Byte> embeddedHex = new ArrayList<Byte>();
    boolean isPrintableString = true;
    while (c != '"') {
        if (c == '\\') {
            c = readChar(in, "Quoted string did not end in quote");
            // check for embedded hex pairs
            Byte hexByte = null;
            if ((hexByte = getEmbeddedHexPair(c, in)) != null) {
                // always encode AVAs with embedded hex as UTF8
                isPrintableString = false;
                // append consecutive embedded hex
                // as single string later
                embeddedHex.add(hexByte);
                c = in.read();
                continue;
            }
            if (specialChars1779.indexOf((char) c) < 0) {
                throw new IOException("Invalid escaped character in AVA: " + (char) c);
            }
        }
        // add embedded hex bytes before next char
        if (embeddedHex.size() > 0) {
            String hexString = getEmbeddedHexString(embeddedHex);
            temp.append(hexString);
            embeddedHex.clear();
        }
        // check for non-PrintableString chars
        isPrintableString &= DerValue.isPrintableStringChar((char) c);
        temp.append((char) c);
        c = readChar(in, "Quoted string did not end in quote");
    }
    // add trailing embedded hex bytes
    if (embeddedHex.size() > 0) {
        String hexString = getEmbeddedHexString(embeddedHex);
        temp.append(hexString);
        embeddedHex.clear();
    }
    do {
        c = in.read();
    } while ((c == '\n') || (c == ' '));
    if (c != -1) {
        throw new IOException("AVA had characters other than " + "whitespace after terminating quote");
    }
    // non-PrintableString chars
    if (this.oid.equals((Object) PKCS9Attribute.EMAIL_ADDRESS_OID) || (this.oid.equals((Object) X500Name.DOMAIN_COMPONENT_OID) && PRESERVE_OLD_DC_ENCODING == false)) {
        // EmailAddress and DomainComponent must be IA5String
        return new DerValue(DerValue.tag_IA5String, // temp.toString().trim());
        temp.toString());
    } else if (isPrintableString) {
        // return new DerValue(temp.toString().trim());
        return new DerValue(temp.toString());
    } else {
        return new DerValue(DerValue.tag_UTF8String, // temp.toString().trim());
        temp.toString());
    }
}
#end_block

#method_before
public String toRFC2253CanonicalString() {
    /*
         * Section 2.3: The AttributeTypeAndValue is encoded as the string
         * representation of the AttributeType, followed by an equals character
         * ('=' ASCII 61), followed by the string representation of the
         * AttributeValue. The encoding of the AttributeValue is given in
         * section 2.4.
         */
    StringBuilder typeAndValue = new StringBuilder(40);
    typeAndValue.append(toKeyword(RFC2253, Collections.<String, String>emptyMap()));
    typeAndValue.append('=');
    /*
         * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
         * If the AttributeValue is of a type which does not have a string
         * representation defined for it, then it is simply encoded as an
         * octothorpe character ('#' ASCII 35) followed by the hexadecimal
         * representation of each of the bytes of the BER encoding of the X.500
         * AttributeValue.  This form SHOULD be used if the AttributeType is of
         * the dotted-decimal form.
         */
    if ((typeAndValue.charAt(0) >= '0' && typeAndValue.charAt(0) <= '9') || (!isDerString(value, true) && value.tag != DerValue.tag_T61String)) {
        byte[] data = null;
        try {
            data = value.toByteArray();
        } catch (IOException ie) {
            throw new IllegalArgumentException("DER Value conversion");
        }
        typeAndValue.append('#');
        for (int j = 0; j < data.length; j++) {
            byte b = data[j];
            typeAndValue.append(Character.forDigit(0xF & (b >>> 4), 16));
            typeAndValue.append(Character.forDigit(0xF & b, 16));
        }
    } else {
        /*
             * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
             * has a string representation, the value is converted first to a
             * UTF-8 string according to its syntax specification.
             *
             * NOTE: this implementation only emits DirectoryStrings of the
             * types returned by isDerString().
             */
        String valStr = null;
        try {
            valStr = new String(value.getDataBytes(), "UTF8");
        } catch (IOException ie) {
            throw new IllegalArgumentException("DER Value conversion");
        }
        /*
             * 2.4 (cont): If the UTF-8 string does not have any of the
             * following characters which need escaping, then that string can be
             * used as the string representation of the value.
             *
             *   o   a space or "#" character occurring at the beginning of the
             *       string
             *   o   a space character occurring at the end of the string
             *
             *   o   one of the characters ",", "+", """, "\", "<", ">" or ";"
             *
             * If a character to be escaped is one of the list shown above, then
             * it is prefixed by a backslash ('\' ASCII 92).
             *
             * Otherwise the character to be escaped is replaced by a backslash
             * and two hex digits, which form a single byte in the code of the
             * character.
             */
        final String escapees = ",+<>;\"\\";
        StringBuilder sbuffer = new StringBuilder();
        boolean previousWhite = false;
        for (int i = 0; i < valStr.length(); i++) {
            char c = valStr.charAt(i);
            if (DerValue.isPrintableStringChar(c) || escapees.indexOf(c) >= 0 || (i == 0 && c == '#')) {
                // escape leading '#' and escapees
                if ((i == 0 && c == '#') || escapees.indexOf(c) >= 0) {
                    sbuffer.append('\\');
                }
                // convert multiple whitespace to single whitespace
                if (!Character.isWhitespace(c)) {
                    previousWhite = false;
                    sbuffer.append(c);
                } else {
                    if (previousWhite == false) {
                        // add single whitespace
                        previousWhite = true;
                        sbuffer.append(c);
                    } else {
                        // ignore subsequent consecutive whitespace
                        continue;
                    }
                }
            } else if (debug != null && Debug.isOn("ava")) {
                // embed non-printable/non-escaped char
                // as escaped hex pairs for debugging
                previousWhite = false;
                byte[] valueBytes = null;
                try {
                    valueBytes = Character.toString(c).getBytes("UTF8");
                } catch (IOException ie) {
                    throw new IllegalArgumentException("DER Value conversion");
                }
                for (int j = 0; j < valueBytes.length; j++) {
                    sbuffer.append('\\');
                    sbuffer.append(Character.forDigit(0xF & (valueBytes[j] >>> 4), 16));
                    sbuffer.append(Character.forDigit(0xF & (valueBytes[j]), 16));
                }
            } else {
                // append non-printable/non-escaped char
                previousWhite = false;
                sbuffer.append(c);
            }
        }
        // remove leading and trailing whitespace from value
        typeAndValue.append(sbuffer.toString().trim());
    }
    String canon = typeAndValue.toString();
    canon = canon.toUpperCase(Locale.US).toLowerCase(Locale.US);
    return Normalizer.normalize(canon, Normalizer.Form.NFKD);
}
#method_after
public String toRFC2253CanonicalString() {
    /*
         * Section 2.3: The AttributeTypeAndValue is encoded as the string
         * representation of the AttributeType, followed by an equals character
         * ('=' ASCII 61), followed by the string representation of the
         * AttributeValue. The encoding of the AttributeValue is given in
         * section 2.4.
         */
    StringBuilder typeAndValue = new StringBuilder(40);
    typeAndValue.append(toKeyword(RFC2253, Collections.<String, String>emptyMap()));
    typeAndValue.append('=');
    /*
         * Section 2.4: Converting an AttributeValue from ASN.1 to a String.
         * If the AttributeValue is of a type which does not have a string
         * representation defined for it, then it is simply encoded as an
         * octothorpe character ('#' ASCII 35) followed by the hexadecimal
         * representation of each of the bytes of the BER encoding of the X.500
         * AttributeValue.  This form SHOULD be used if the AttributeType is of
         * the dotted-decimal form.
         */
    if ((typeAndValue.charAt(0) >= '0' && typeAndValue.charAt(0) <= '9') || // !isDerString(value, true))
    (!isDerString(value, true) && value.tag != DerValue.tag_T61String)) {
        byte[] data = null;
        try {
            data = value.toByteArray();
        } catch (IOException ie) {
            throw new IllegalArgumentException("DER Value conversion");
        }
        typeAndValue.append('#');
        for (int j = 0; j < data.length; j++) {
            byte b = data[j];
            typeAndValue.append(Character.forDigit(0xF & (b >>> 4), 16));
            typeAndValue.append(Character.forDigit(0xF & b, 16));
        }
    } else {
        /*
             * 2.4 (cont): Otherwise, if the AttributeValue is of a type which
             * has a string representation, the value is converted first to a
             * UTF-8 string according to its syntax specification.
             *
             * NOTE: this implementation only emits DirectoryStrings of the
             * types returned by isDerString().
             */
        String valStr = null;
        try {
            valStr = new String(value.getDataBytes(), "UTF8");
        } catch (IOException ie) {
            throw new IllegalArgumentException("DER Value conversion");
        }
        /*
             * 2.4 (cont): If the UTF-8 string does not have any of the
             * following characters which need escaping, then that string can be
             * used as the string representation of the value.
             *
             *   o   a space or "#" character occurring at the beginning of the
             *       string
             *   o   a space character occurring at the end of the string
             *
             *   o   one of the characters ",", "+", """, "\", "<", ">" or ";"
             *
             * If a character to be escaped is one of the list shown above, then
             * it is prefixed by a backslash ('\' ASCII 92).
             *
             * Otherwise the character to be escaped is replaced by a backslash
             * and two hex digits, which form a single byte in the code of the
             * character.
             */
        final String escapees = ",+<>;\"\\";
        StringBuilder sbuffer = new StringBuilder();
        boolean previousWhite = false;
        for (int i = 0; i < valStr.length(); i++) {
            char c = valStr.charAt(i);
            if (DerValue.isPrintableStringChar(c) || escapees.indexOf(c) >= 0 || (i == 0 && c == '#')) {
                // escape leading '#' and escapees
                if ((i == 0 && c == '#') || escapees.indexOf(c) >= 0) {
                    sbuffer.append('\\');
                }
                // convert multiple whitespace to single whitespace
                if (!Character.isWhitespace(c)) {
                    previousWhite = false;
                    sbuffer.append(c);
                } else {
                    if (previousWhite == false) {
                        // add single whitespace
                        previousWhite = true;
                        sbuffer.append(c);
                    } else {
                        // ignore subsequent consecutive whitespace
                        continue;
                    }
                }
            } else if (debug != null && Debug.isOn("ava")) {
                // embed non-printable/non-escaped char
                // as escaped hex pairs for debugging
                previousWhite = false;
                byte[] valueBytes = null;
                try {
                    valueBytes = Character.toString(c).getBytes("UTF8");
                } catch (IOException ie) {
                    throw new IllegalArgumentException("DER Value conversion");
                }
                for (int j = 0; j < valueBytes.length; j++) {
                    sbuffer.append('\\');
                    sbuffer.append(Character.forDigit(0xF & (valueBytes[j] >>> 4), 16));
                    sbuffer.append(Character.forDigit(0xF & (valueBytes[j]), 16));
                }
            } else {
                // append non-printable/non-escaped char
                previousWhite = false;
                sbuffer.append(c);
            }
        }
        // remove leading and trailing whitespace from value
        typeAndValue.append(sbuffer.toString().trim());
    }
    String canon = typeAndValue.toString();
    canon = canon.toUpperCase(Locale.US).toLowerCase(Locale.US);
    return Normalizer.normalize(canon, Normalizer.Form.NFKD);
}
#end_block

#method_before
// END Android-changed: Hardcode class names in OIDMap to fix proguard issues
private static void addInternal(String name, ObjectIdentifier oid, Class clazz) {
    OIDInfo info = new OIDInfo(name, oid, clazz);
    oidMap.put(oid, info);
    nameMap.put(name, info);
}
#method_after
private static void addInternal(String name, ObjectIdentifier oid, Class clazz) {
    OIDInfo info = new OIDInfo(name, oid, clazz);
    oidMap.put(oid, info);
    nameMap.put(name, info);
}
#end_block

#method_before
public static void addAttribute(String name, String oid, Class<?> clazz) throws CertificateException {
    ObjectIdentifier objId;
    try {
        objId = new ObjectIdentifier(oid);
    } catch (IOException ioe) {
        throw new CertificateException("Invalid Object identifier: " + oid);
    }
    OIDInfo info = new OIDInfo(name, objId, clazz);
    if (oidMap.put(objId, info) != null) {
        throw new CertificateException("Object identifier already exists: " + oid);
    }
    if (nameMap.put(name, info) != null) {
        throw new CertificateException("Name already exists: " + name);
    }
}
#method_after
// END Android-changed: Specify Class objects rather for oidMap rather than String
// literals + reflection.
public static void addAttribute(String name, String oid, Class<?> clazz) throws CertificateException {
    ObjectIdentifier objId;
    try {
        objId = new ObjectIdentifier(oid);
    } catch (IOException ioe) {
        throw new CertificateException("Invalid Object identifier: " + oid);
    }
    OIDInfo info = new OIDInfo(name, objId, clazz);
    if (oidMap.put(objId, info) != null) {
        throw new CertificateException("Object identifier already exists: " + oid);
    }
    if (nameMap.put(name, info) != null) {
        throw new CertificateException("Name already exists: " + name);
    }
}
#end_block

#method_before
// Test whether the function of getError() works well.
// Load invalid library 'libinvalid.so' from Java and ART will call NativeBridge to get error.
private static void testGetErrorByLoadInvalidLibrary() {
    System.out.println("Start to load invalid library 'libinvalid.so' from Java, which will fail.");
    try {
        System.loadLibrary("invalid");
    } catch (java.lang.UnsatisfiedLinkError e) {
        System.out.println("Catch UnsatisfiedLinkError exception as expected.");
    }
}
#method_after
// Test the path from Java to getError() of NativeBridge.
// 
// Load invalid library 'libinvalid.so' from Java. Library loading will fail since it's
// invalid (empty file). ART, NativeLoader actually, calls getError() to dump error message.
private static void testGetErrorByLoadInvalidLibrary() {
    System.out.println("Loading invalid library 'libinvalid.so' from Java, which will fail.");
    try {
        System.loadLibrary("invalid");
    } catch (java.lang.UnsatisfiedLinkError e) {
        System.out.println("Catch UnsatisfiedLinkError exception as expected.");
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG)
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG)
                        Slog.d(TAG, "Binding to service to get name and address");
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG)
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(new Integer(msg.arg1));
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(service);
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(service);
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly)
                            return;
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (mQuietEnable == false) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null)
                            break;
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(REASON_UNEXPECTED, false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(REASON_RESTARTED, true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mEnable && mBluetooth != null) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(REASON_USER_SWITCH, false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(REASON_USER_SWITCH, true);
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG)
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MESSAGE_GET_NAME_AND_ADDRESS:
            if (DBG)
                Slog.d(TAG, "MESSAGE_GET_NAME_AND_ADDRESS");
            try {
                mBluetoothLock.writeLock().lock();
                if ((mBluetooth == null) && (!mBinding)) {
                    if (DBG)
                        Slog.d(TAG, "Binding to service to get name and address");
                    mGetNameAddressOnly = true;
                    Message timeoutMsg = mHandler.obtainMessage(MESSAGE_TIMEOUT_BIND);
                    mHandler.sendMessageDelayed(timeoutMsg, TIMEOUT_BIND_MS);
                    Intent i = new Intent(IBluetooth.class.getName());
                    if (!doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT)) {
                        mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    } else {
                        mBinding = true;
                    }
                } else if (mBluetooth != null) {
                    try {
                        storeNameAndAddress(mBluetooth.getName(), mBluetooth.getAddress());
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to grab names", re);
                    }
                    if (mGetNameAddressOnly && !mEnable) {
                        unbindAndFinish();
                    }
                    mGetNameAddressOnly = false;
                }
            } finally {
                mBluetoothLock.writeLock().unlock();
            }
            break;
        case MESSAGE_ENABLE:
            if (DBG) {
                Slog.d(TAG, "MESSAGE_ENABLE(" + msg.arg1 + "): mBluetooth = " + mBluetooth);
            }
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            mEnable = true;
            // Use service interface to get the exact state
            try {
                mBluetoothLock.readLock().lock();
                if (mBluetooth != null) {
                    int state = mBluetooth.getState();
                    if (state == BluetoothAdapter.STATE_BLE_ON) {
                        Slog.w(TAG, "BT Enable in BLE_ON State, going to ON");
                        mBluetooth.onLeServiceUp();
                        persistBluetoothSetting(BLUETOOTH_ON_BLUETOOTH);
                        break;
                    }
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "", e);
            } finally {
                mBluetoothLock.readLock().unlock();
            }
            mQuietEnable = (msg.arg1 == 1);
            if (mBluetooth == null) {
                handleEnable(mQuietEnable);
            } else {
                // 
                // We need to wait until transitioned to STATE_OFF and
                // the previous Bluetooth process has exited. The
                // waiting period has three components:
                // (a) Wait until the local state is STATE_OFF. This
                // is accomplished by "waitForOnOff(false, true)".
                // (b) Wait until the STATE_OFF state is updated to
                // all components.
                // (c) Wait until the Bluetooth process exits, and
                // ActivityManager detects it.
                // The waiting for (b) and (c) is accomplished by
                // delaying the MESSAGE_RESTART_BLUETOOTH_SERVICE
                // message. On slower devices, that delay needs to be
                // on the order of (2 * SERVICE_RESTART_TIME_MS).
                // 
                waitForOnOff(false, true);
                Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
            }
            break;
        case MESSAGE_DISABLE:
            if (DBG)
                Slog.d(TAG, "MESSAGE_DISABLE: mBluetooth = " + mBluetooth);
            mHandler.removeMessages(MESSAGE_RESTART_BLUETOOTH_SERVICE);
            if (mEnable && mBluetooth != null) {
                waitForOnOff(true, false);
                mEnable = false;
                handleDisable();
                waitForOnOff(false, false);
            } else {
                mEnable = false;
                handleDisable();
            }
            break;
        case MESSAGE_RESTORE_USER_SETTING:
            try {
                if ((msg.arg1 == RESTORE_SETTING_TO_OFF) && mEnable) {
                    if (DBG)
                        Slog.d(TAG, "Restore Bluetooth state to disabled");
                    disable(REASON_RESTORE_USER_SETTING, true);
                } else if ((msg.arg1 == RESTORE_SETTING_TO_ON) && !mEnable) {
                    if (DBG)
                        Slog.d(TAG, "Restore Bluetooth state to enabled");
                    enable(REASON_RESTORE_USER_SETTING);
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "Unable to change Bluetooth On setting", e);
            }
            break;
        case MESSAGE_REGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_ADAPTER:
            {
                IBluetoothManagerCallback callback = (IBluetoothManagerCallback) msg.obj;
                mCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_REGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.register(callback);
                break;
            }
        case MESSAGE_UNREGISTER_STATE_CHANGE_CALLBACK:
            {
                IBluetoothStateChangeCallback callback = (IBluetoothStateChangeCallback) msg.obj;
                mStateChangeCallbacks.unregister(callback);
                break;
            }
        case MESSAGE_ADD_PROXY_DELAYED:
            {
                ProfileServiceConnections psc = mProfileServices.get(new Integer(msg.arg1));
                if (psc == null) {
                    break;
                }
                IBluetoothProfileServiceConnection proxy = (IBluetoothProfileServiceConnection) msg.obj;
                psc.addProxy(proxy);
                break;
            }
        case MESSAGE_BIND_PROFILE_SERVICE:
            {
                ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
                removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
                if (psc == null) {
                    break;
                }
                psc.bindService();
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
                IBinder service = (IBinder) msg.obj;
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = IBluetoothGatt.Stub.asInterface(service);
                        onBluetoothGattServiceUp();
                        break;
                    }
                    // else must be SERVICE_IBLUETOOTH
                    // Remove timeout
                    mHandler.removeMessages(MESSAGE_TIMEOUT_BIND);
                    mBinding = false;
                    mBluetoothBinder = service;
                    mBluetooth = IBluetooth.Stub.asInterface(service);
                    if (!isNameAndAddressSet()) {
                        Message getMsg = mHandler.obtainMessage(MESSAGE_GET_NAME_AND_ADDRESS);
                        mHandler.sendMessage(getMsg);
                        if (mGetNameAddressOnly)
                            return;
                    }
                    // Register callback object
                    try {
                        mBluetooth.registerCallback(mBluetoothCallback);
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to register BluetoothCallback", re);
                    }
                    // Inform BluetoothAdapter instances that service is up
                    sendBluetoothServiceUpCallback();
                    // Do enable request
                    try {
                        if (mQuietEnable == false) {
                            if (!mBluetooth.enable()) {
                                Slog.e(TAG, "IBluetooth.enable() returned false");
                            }
                        } else {
                            if (!mBluetooth.enableNoAutoConnect()) {
                                Slog.e(TAG, "IBluetooth.enableNoAutoConnect() returned false");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e(TAG, "Unable to call enable()", e);
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                if (!mEnable) {
                    waitForOnOff(true, false);
                    handleDisable();
                    waitForOnOff(false, false);
                }
                break;
            }
        case MESSAGE_BLUETOOTH_STATE_CHANGE:
            {
                int prevState = msg.arg1;
                int newState = msg.arg2;
                if (DBG) {
                    Slog.d(TAG, "MESSAGE_BLUETOOTH_STATE_CHANGE: " + BluetoothAdapter.nameForState(prevState) + " > " + BluetoothAdapter.nameForState(newState));
                }
                mState = newState;
                bluetoothStateChangeHandler(prevState, newState);
                // unbind and rebind bluetooth service and enable bluetooth
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_ON) && (newState == BluetoothAdapter.STATE_OFF) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(false);
                }
                if ((prevState == BluetoothAdapter.STATE_TURNING_ON) && (newState == BluetoothAdapter.STATE_BLE_ON) && (mBluetooth != null) && mEnable) {
                    recoverBluetoothServiceFromError(true);
                }
                // here.  This is a bit of a hack (b/29363429).
                if ((prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) && (newState == BluetoothAdapter.STATE_OFF)) {
                    if (mEnable) {
                        Slog.d(TAG, "Entering STATE_OFF but mEnabled is true; restarting.");
                        waitForOnOff(false, true);
                        Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                        mHandler.sendMessageDelayed(restartMsg, 2 * SERVICE_RESTART_TIME_MS);
                    }
                }
                if (newState == BluetoothAdapter.STATE_ON || newState == BluetoothAdapter.STATE_BLE_ON) {
                    // bluetooth is working, reset the counter
                    if (mErrorRecoveryRetryCounter != 0) {
                        Slog.w(TAG, "bluetooth is recovered from error");
                        mErrorRecoveryRetryCounter = 0;
                    }
                }
                break;
            }
        case MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED:
            {
                Slog.e(TAG, "MESSAGE_BLUETOOTH_SERVICE_DISCONNECTED(" + msg.arg1 + ")");
                try {
                    mBluetoothLock.writeLock().lock();
                    if (msg.arg1 == SERVICE_IBLUETOOTH) {
                        // if service is unbinded already, do nothing and return
                        if (mBluetooth == null)
                            break;
                        mBluetooth = null;
                    } else if (msg.arg1 == SERVICE_IBLUETOOTHGATT) {
                        mBluetoothGatt = null;
                        break;
                    } else {
                        Slog.e(TAG, "Unknown argument for service disconnect!");
                        break;
                    }
                } finally {
                    mBluetoothLock.writeLock().unlock();
                }
                // log the unexpected crash
                addCrashLog();
                addActiveLog(REASON_UNEXPECTED, false);
                if (mEnable) {
                    mEnable = false;
                    // Send a Bluetooth Restart message
                    Message restartMsg = mHandler.obtainMessage(MESSAGE_RESTART_BLUETOOTH_SERVICE);
                    mHandler.sendMessageDelayed(restartMsg, SERVICE_RESTART_TIME_MS);
                }
                sendBluetoothServiceDownCallback();
                // the BT icon correctly
                if ((mState == BluetoothAdapter.STATE_TURNING_ON) || (mState == BluetoothAdapter.STATE_ON)) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    mState = BluetoothAdapter.STATE_TURNING_OFF;
                }
                if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                }
                mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                mState = BluetoothAdapter.STATE_OFF;
                break;
            }
        case MESSAGE_RESTART_BLUETOOTH_SERVICE:
            {
                Slog.d(TAG, "MESSAGE_RESTART_BLUETOOTH_SERVICE");
                /* Enable without persisting the setting as
                     it doesnt change when IBluetooth
                     service restarts */
                mEnable = true;
                addActiveLog(REASON_RESTARTED, true);
                handleEnable(mQuietEnable);
                break;
            }
        case MESSAGE_TIMEOUT_BIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_BIND");
                mBluetoothLock.writeLock().lock();
                mBinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_TIMEOUT_UNBIND:
            {
                Slog.e(TAG, "MESSAGE_TIMEOUT_UNBIND");
                mBluetoothLock.writeLock().lock();
                mUnbinding = false;
                mBluetoothLock.writeLock().unlock();
                break;
            }
        case MESSAGE_USER_SWITCHED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_SWITCHED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                /* disable and enable BT when detect a user switch */
                if (mEnable && mBluetooth != null) {
                    try {
                        mBluetoothLock.readLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth.unregisterCallback(mBluetoothCallback);
                        }
                    } catch (RemoteException re) {
                        Slog.e(TAG, "Unable to unregister", re);
                    } finally {
                        mBluetoothLock.readLock().unlock();
                    }
                    if (mState == BluetoothAdapter.STATE_TURNING_OFF) {
                        // MESSAGE_USER_SWITCHED happened right after MESSAGE_ENABLE
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_OFF);
                        mState = BluetoothAdapter.STATE_OFF;
                    }
                    if (mState == BluetoothAdapter.STATE_OFF) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_TURNING_ON);
                        mState = BluetoothAdapter.STATE_TURNING_ON;
                    }
                    waitForOnOff(true, false);
                    if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                        bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                    }
                    unbindAllBluetoothProfileServices();
                    // disable
                    addActiveLog(REASON_USER_SWITCH, false);
                    handleDisable();
                    // Pbap service need receive STATE_TURNING_OFF intent to close
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON, BluetoothAdapter.STATE_TURNING_OFF);
                    boolean didDisableTimeout = !waitForOnOff(false, true);
                    bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF, BluetoothAdapter.STATE_OFF);
                    sendBluetoothServiceDownCallback();
                    try {
                        mBluetoothLock.writeLock().lock();
                        if (mBluetooth != null) {
                            mBluetooth = null;
                            // Unbind
                            mContext.unbindService(mConnection);
                        }
                        mBluetoothGatt = null;
                    } finally {
                        mBluetoothLock.writeLock().unlock();
                    }
                    // 
                    if (didDisableTimeout) {
                        SystemClock.sleep(3000);
                    } else {
                        SystemClock.sleep(100);
                    }
                    mHandler.removeMessages(MESSAGE_BLUETOOTH_STATE_CHANGE);
                    mState = BluetoothAdapter.STATE_OFF;
                    // enable
                    addActiveLog(REASON_USER_SWITCH, true);
                    handleEnable(mQuietEnable);
                } else if (mBinding || mBluetooth != null) {
                    Message userMsg = mHandler.obtainMessage(MESSAGE_USER_SWITCHED);
                    userMsg.arg2 = 1 + msg.arg2;
                    // if user is switched when service is binding retry after a delay
                    mHandler.sendMessageDelayed(userMsg, USER_SWITCHED_TIME_MS);
                    if (DBG) {
                        Slog.d(TAG, "Retry MESSAGE_USER_SWITCHED " + userMsg.arg2);
                    }
                }
                break;
            }
        case MESSAGE_USER_UNLOCKED:
            {
                if (DBG)
                    Slog.d(TAG, "MESSAGE_USER_UNLOCKED");
                mHandler.removeMessages(MESSAGE_USER_SWITCHED);
                if (mEnable && !mBinding && (mBluetooth == null)) {
                    // aware, so try binding again.
                    if (DBG)
                        Slog.d(TAG, "Enabled but not bound; retrying after unlock");
                    handleEnable(mQuietEnable);
                }
            }
    }
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
                } else if (mRoamingIndicator >= 0) {
                    mNewSS.setDataRoaming(!isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator)));
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    mNewSS.setDataRoaming(!isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator)));
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    // may transition us out
    if (!turnOnMasterTetherSettings()) {
        return;
    }
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    mOffloadController.start();
    if (upstreamWanted()) {
        mUpstreamWanted = true;
        chooseUpstreamType(true);
        mTryCell = false;
    }
}
#method_after
@Override
public void enter() {
    // transitioned to an error state; exit early.
    if (!turnOnMasterTetherSettings()) {
        return;
    }
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    mOffloadController.start();
    if (upstreamWanted()) {
        mUpstreamWanted = true;
        chooseUpstreamType(true);
        mTryCell = false;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message message) {
    final int what = message.what;
    final int key = message.arg2;
    switch(what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, "Channel lost");
            return;
        default:
            break;
    }
    final NsdServiceInfo ns = getNsdService(key);
    final Object listener = getListener(key);
    if (listener == null) {
        Log.d(TAG, "Stale key " + message.arg2);
        return;
    }
    if (DBG) {
        Log.d(TAG, "received " + nameOf(what) + " for key " + key + ", service " + ns);
    }
    switch(what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(key);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            removeListener(key);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(key);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            removeListener(key);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(key);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(key);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, "Ignored " + message);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message message) {
    final int what = message.what;
    final int key = message.arg2;
    switch(what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            mAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            return;
        case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
            mConnected.countDown();
            return;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            Log.e(TAG, "Channel lost");
            return;
        default:
            break;
    }
    final Object listener;
    final NsdServiceInfo ns;
    synchronized (mMapLock) {
        listener = mListenerMap.get(key);
        ns = mServiceMap.get(key);
    }
    if (listener == null) {
        Log.d(TAG, "Stale key " + message.arg2);
        return;
    }
    if (DBG) {
        Log.d(TAG, "received " + nameOf(what) + " for key " + key + ", service " + ns);
    }
    switch(what) {
        case DISCOVER_SERVICES_STARTED:
            String s = getNsdServiceInfoType((NsdServiceInfo) message.obj);
            ((DiscoveryListener) listener).onDiscoveryStarted(s);
            break;
        case DISCOVER_SERVICES_FAILED:
            removeListener(key);
            ((DiscoveryListener) listener).onStartDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case SERVICE_FOUND:
            ((DiscoveryListener) listener).onServiceFound((NsdServiceInfo) message.obj);
            break;
        case SERVICE_LOST:
            ((DiscoveryListener) listener).onServiceLost((NsdServiceInfo) message.obj);
            break;
        case STOP_DISCOVERY_FAILED:
            // TODO: failure to stop discovery should be internal and retried internally, as
            // the effect for the client is indistinguishable from STOP_DISCOVERY_SUCCEEDED
            removeListener(key);
            ((DiscoveryListener) listener).onStopDiscoveryFailed(getNsdServiceInfoType(ns), message.arg1);
            break;
        case STOP_DISCOVERY_SUCCEEDED:
            removeListener(key);
            ((DiscoveryListener) listener).onDiscoveryStopped(getNsdServiceInfoType(ns));
            break;
        case REGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onRegistrationFailed(ns, message.arg1);
            break;
        case REGISTER_SERVICE_SUCCEEDED:
            ((RegistrationListener) listener).onServiceRegistered((NsdServiceInfo) message.obj);
            break;
        case UNREGISTER_SERVICE_FAILED:
            removeListener(key);
            ((RegistrationListener) listener).onUnregistrationFailed(ns, message.arg1);
            break;
        case UNREGISTER_SERVICE_SUCCEEDED:
            // TODO: do not unregister listener until service is unregistered, or provide
            // alternative way for unregistering ?
            removeListener(message.arg2);
            ((RegistrationListener) listener).onServiceUnregistered(ns);
            break;
        case RESOLVE_SERVICE_FAILED:
            removeListener(key);
            ((ResolveListener) listener).onResolveFailed(ns, message.arg1);
            break;
        case RESOLVE_SERVICE_SUCCEEDED:
            removeListener(key);
            ((ResolveListener) listener).onServiceResolved((NsdServiceInfo) message.obj);
            break;
        default:
            Log.d(TAG, "Ignored " + message);
            break;
    }
}
#end_block

#method_before
// if the listener is already in the map, reject it.  Otherwise, add it and
private int putListener(Object listener, NsdServiceInfo s) {
    checkListener(listener);
    final int key;
    synchronized (mMapLock) {
        int valueIndex = mListenerMap.indexOfValue(listener);
        checkArgument(valueIndex == -1, "listener already in use");
        key = Math.abs(mListenerKey++);
        mListenerMap.put(key, listener);
        mServiceMap.put(key, s);
    }
    return key;
}
#method_after
private int putListener(Object listener, NsdServiceInfo s) {
    checkListener(listener);
    final int key;
    synchronized (mMapLock) {
        int valueIndex = mListenerMap.indexOfValue(listener);
        checkArgument(valueIndex == -1, "listener already in use");
        key = nextListenerKey();
        mListenerMap.put(key, listener);
        mServiceMap.put(key, s);
    }
    return key;
}
#end_block

#method_before
private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForCarrierApp) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Invalid message body");
    }
    try {
        ISms iccISms = getISmsServiceOrThrow();
        iccISms.sendTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, text, sentIntent, deliveryIntent, persistMessageForCarrierApp);
    } catch (RemoteException ex) {
    // ignore it
    }
}
#method_after
private void sendTextMessageInternal(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessage) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Invalid message body");
    }
    try {
        ISms iccISms = getISmsServiceOrThrow();
        iccISms.sendTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, text, sentIntent, deliveryIntent, persistMessage);
    } catch (RemoteException ex) {
    // ignore it
    }
}
#end_block

#method_before
public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent, false);
}
#method_after
@SystemApi
public void sendTextMessageWithoutPersisting(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    sendTextMessageInternal(destinationAddress, scAddress, text, sentIntent, deliveryIntent, false);
}
#end_block

#method_before
private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents, boolean persistMessageForCarrierApp) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (parts == null || parts.size() < 1) {
        throw new IllegalArgumentException("Invalid message body");
    }
    if (parts.size() > 1) {
        try {
            ISms iccISms = getISmsServiceOrThrow();
            iccISms.sendMultipartTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, parts, sentIntents, deliveryIntents, persistMessageForCarrierApp);
        } catch (RemoteException ex) {
        // ignore it
        }
    } else {
        PendingIntent sentIntent = null;
        PendingIntent deliveryIntent = null;
        if (sentIntents != null && sentIntents.size() > 0) {
            sentIntent = sentIntents.get(0);
        }
        if (deliveryIntents != null && deliveryIntents.size() > 0) {
            deliveryIntent = deliveryIntents.get(0);
        }
        sendTextMessage(destinationAddress, scAddress, parts.get(0), sentIntent, deliveryIntent);
    }
}
#method_after
private void sendMultipartTextMessageInternal(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents, boolean persistMessage) {
    if (TextUtils.isEmpty(destinationAddress)) {
        throw new IllegalArgumentException("Invalid destinationAddress");
    }
    if (parts == null || parts.size() < 1) {
        throw new IllegalArgumentException("Invalid message body");
    }
    if (parts.size() > 1) {
        try {
            ISms iccISms = getISmsServiceOrThrow();
            iccISms.sendMultipartTextForSubscriber(getSubscriptionId(), ActivityThread.currentPackageName(), destinationAddress, scAddress, parts, sentIntents, deliveryIntents, persistMessage);
        } catch (RemoteException ex) {
        // ignore it
        }
    } else {
        PendingIntent sentIntent = null;
        PendingIntent deliveryIntent = null;
        if (sentIntents != null && sentIntents.size() > 0) {
            sentIntent = sentIntents.get(0);
        }
        if (deliveryIntents != null && deliveryIntents.size() > 0) {
            deliveryIntent = deliveryIntents.get(0);
        }
        sendTextMessage(destinationAddress, scAddress, parts.get(0), sentIntent, deliveryIntent);
    }
}
#end_block

#method_before
public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, ArrayList<String> parts, ArrayList<PendingIntent> sentIntents, ArrayList<PendingIntent> deliveryIntents) {
    sendMultipartTextMessageInternal(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, false);
}
#method_after
@SystemApi
public void sendMultipartTextMessageWithoutPersisting(String destinationAddress, String scAddress, List<String> parts, List<PendingIntent> sentIntents, List<PendingIntent> deliveryIntents) {
    sendMultipartTextMessageInternal(destinationAddress, scAddress, parts, sentIntents, deliveryIntents, false);
}
#end_block

#method_before
private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) {
    if (shouldBeInLowPersistenceMode()) {
        brightnessMode = BRIGHTNESS_MODE_LOW_PERSISTENCE;
    } else if (brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE) {
        brightnessMode = mLastBrightnessMode;
    }
    if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) {
        if (DEBUG)
            Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode);
        mLastColor = mColor;
        mColor = color;
        mMode = mode;
        mOnMS = onMS;
        mOffMS = offMS;
        mBrightnessMode = brightnessMode;
        mInitialized = true;
        Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")");
        try {
            setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_POWER);
        }
    }
}
#method_after
private void setLightLocked(int color, int mode, int onMS, int offMS, int brightnessMode) {
    if (shouldBeInLowPersistenceMode()) {
        brightnessMode = BRIGHTNESS_MODE_LOW_PERSISTENCE;
    } else if (brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE) {
        brightnessMode = mLastBrightnessMode;
    }
    if (!mInitialized || color != mColor || mode != mMode || onMS != mOnMS || offMS != mOffMS || mBrightnessMode != brightnessMode) {
        if (DEBUG)
            Slog.v(TAG, "setLight #" + mId + ": color=#" + Integer.toHexString(color) + ": brightnessMode=" + brightnessMode);
        mInitialized = true;
        mLastColor = mColor;
        mColor = color;
        mMode = mode;
        mOnMS = onMS;
        mOffMS = offMS;
        mBrightnessMode = brightnessMode;
        Trace.traceBegin(Trace.TRACE_TAG_POWER, "setLight(" + mId + ", 0x" + Integer.toHexString(color) + ")");
        try {
            setLight_native(mNativePointer, mId, color, mode, onMS, offMS, brightnessMode);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_POWER);
        }
    }
}
#end_block

#method_before
@Test
public void testDiscoverService() {
    NsdManager manager = makeManager();
    NsdServiceInfo reply1 = new NsdServiceInfo("a_name", "a_type");
    NsdServiceInfo reply2 = new NsdServiceInfo("another_name", "a_type");
    NsdServiceInfo reply3 = new NsdServiceInfo("a_third_name", "a_type");
    NsdManager.DiscoveryListener listener = mock(NsdManager.DiscoveryListener.class);
    // Client registers for discovery, request fails
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key1 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    int err = 1;
    sendResponse(NsdManager.DISCOVER_SERVICES_FAILED, err, key1, null);
    verify(listener, timeout(mTimeoutMs).times(1)).onStartDiscoveryFailed("a_type", err);
    // Client retries, request succeeds
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key2 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    sendResponse(NsdManager.DISCOVER_SERVICES_STARTED, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStarted("a_type");
    // mdns notifies about services
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceFound(reply1);
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply2);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceFound(reply2);
    sendResponse(NsdManager.SERVICE_LOST, 0, key2, reply2);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceLost(reply2);
    // Client unregisters its listener
    manager.stopServiceDiscovery(listener);
    int key2again = verifyRequest(NsdManager.STOP_DISCOVERY);
    assertEquals(key2, key2again);
    // TODO: unregister listener immediately and stop notifying it abotu services
    // Notifications are still passed to the client's listener
    sendResponse(NsdManager.SERVICE_LOST, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceLost(reply1);
    // Client is notified of complete unregistration
    sendResponse(NsdManager.STOP_DISCOVERY_SUCCEEDED, 0, key2again, "a_type");
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStopped("a_type");
    // Notifications are not passed to the client anymore
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply3);
    verify(listener, timeout(mTimeoutMs).times(0)).onServiceLost(reply3);
    // Client registers for service discovery
    reset(listener);
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key3 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    sendResponse(NsdManager.DISCOVER_SERVICES_STARTED, 0, key3, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStarted("a_type");
    // Client unregisters immediately, it fails
    manager.stopServiceDiscovery(listener);
    int key3again = verifyRequest(NsdManager.STOP_DISCOVERY);
    assertEquals(key3, key3again);
    err = 2;
    sendResponse(NsdManager.STOP_DISCOVERY_FAILED, err, key3again, "a_type");
    verify(listener, timeout(mTimeoutMs).times(1)).onStopDiscoveryFailed("a_type", err);
    // New notifications are not passed to the client anymore
    sendResponse(NsdManager.SERVICE_FOUND, 0, key3, reply1);
    verify(listener, timeout(mTimeoutMs).times(0)).onServiceFound(reply1);
}
#method_after
@Test
public void testDiscoverService() {
    NsdManager manager = makeManager();
    NsdServiceInfo reply1 = new NsdServiceInfo("a_name", "a_type");
    NsdServiceInfo reply2 = new NsdServiceInfo("another_name", "a_type");
    NsdServiceInfo reply3 = new NsdServiceInfo("a_third_name", "a_type");
    NsdManager.DiscoveryListener listener = mock(NsdManager.DiscoveryListener.class);
    // Client registers for discovery, request fails
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key1 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    int err = 1;
    sendResponse(NsdManager.DISCOVER_SERVICES_FAILED, err, key1, null);
    verify(listener, timeout(mTimeoutMs).times(1)).onStartDiscoveryFailed("a_type", err);
    // Client retries, request succeeds
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key2 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    sendResponse(NsdManager.DISCOVER_SERVICES_STARTED, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStarted("a_type");
    // mdns notifies about services
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceFound(reply1);
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply2);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceFound(reply2);
    sendResponse(NsdManager.SERVICE_LOST, 0, key2, reply2);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceLost(reply2);
    // Client unregisters its listener
    manager.stopServiceDiscovery(listener);
    int key2again = verifyRequest(NsdManager.STOP_DISCOVERY);
    assertEquals(key2, key2again);
    // TODO: unregister listener immediately and stop notifying it about services
    // Notifications are still passed to the client's listener
    sendResponse(NsdManager.SERVICE_LOST, 0, key2, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onServiceLost(reply1);
    // Client is notified of complete unregistration
    sendResponse(NsdManager.STOP_DISCOVERY_SUCCEEDED, 0, key2again, "a_type");
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStopped("a_type");
    // Notifications are not passed to the client anymore
    sendResponse(NsdManager.SERVICE_FOUND, 0, key2, reply3);
    verify(listener, timeout(mTimeoutMs).times(0)).onServiceLost(reply3);
    // Client registers for service discovery
    reset(listener);
    manager.discoverServices("a_type", PROTOCOL, listener);
    int key3 = verifyRequest(NsdManager.DISCOVER_SERVICES);
    sendResponse(NsdManager.DISCOVER_SERVICES_STARTED, 0, key3, reply1);
    verify(listener, timeout(mTimeoutMs).times(1)).onDiscoveryStarted("a_type");
    // Client unregisters immediately, it fails
    manager.stopServiceDiscovery(listener);
    int key3again = verifyRequest(NsdManager.STOP_DISCOVERY);
    assertEquals(key3, key3again);
    err = 2;
    sendResponse(NsdManager.STOP_DISCOVERY_FAILED, err, key3again, "a_type");
    verify(listener, timeout(mTimeoutMs).times(1)).onStopDiscoveryFailed("a_type", err);
    // New notifications are not passed to the client anymore
    sendResponse(NsdManager.SERVICE_FOUND, 0, key3, reply1);
    verify(listener, timeout(mTimeoutMs).times(0)).onServiceFound(reply1);
}
#end_block

#method_before
public void setUp() throws Exception {
    super.setUp();
    // It's not clear how we would get this without invoking "/system/bin/sh", but we need the
    // value first to do so. It has been hardcoded instead.
    deviceAndroidRootDir = "/system";
    // Create a test root directory on host and device.
    Path hostTestRootDir = Files.createTempDirectory("tzdatacheck_test");
    testRootDir = new PathPair(hostTestRootDir, "/data/local/tmp/tzdatacheck_test");
    createDeviceDirectory(testRootDir);
    // tzdatacheck requires two directories: a "system" path and a "data" path.
    systemDir = testRootDir.createSubPath("system_dir");
    dataDir = testRootDir.createSubPath("data_dir");
    // Create the host-side directory structure (for preparing files before pushing them to
    // device and looking at files retrieved from device).
    createHostDirectory(systemDir);
    createHostDirectory(dataDir);
    // Create the equivalent device-side directory structure for receiving files.
    createDeviceDirectory(systemDir);
    createDeviceDirectory(dataDir);
}
#method_after
public void setUp() throws Exception {
    super.setUp();
    // It's not clear how we would get this without invoking "/system/bin/sh", but we need the
    // value first to do so. It has been hardcoded instead.
    mDeviceAndroidRootDir = "/system";
    // Create a test root directory on host and device.
    Path hostTestRootDir = Files.createTempDirectory("tzdatacheck_test");
    mTestRootDir = new PathPair(hostTestRootDir, "/data/local/tmp/tzdatacheck_test");
    createDeviceDirectory(mTestRootDir);
    // tzdatacheck requires two directories: a "system" path and a "data" path.
    mSystemDir = mTestRootDir.createSubPath("system_dir");
    mDataDir = mTestRootDir.createSubPath("data_dir");
    // Create the host-side directory structure (for preparing files before pushing them to
    // device and looking at files retrieved from device).
    createHostDirectory(mSystemDir);
    createHostDirectory(mDataDir);
    // Create the equivalent device-side directory structure for receiving files.
    createDeviceDirectory(mSystemDir);
    createDeviceDirectory(mDataDir);
}
#end_block

#method_before
@Override
public void tearDown() throws Exception {
    // Remove the test root directories that have been created by this test.
    deleteHostDirectory(testRootDir, true);
    deleteDeviceDirectory(testRootDir, true);
    super.tearDown();
}
#method_after
@Override
public void tearDown() throws Exception {
    // Remove the test root directories that have been created by this test.
    deleteHostDirectory(mTestRootDir, true);
    deleteDeviceDirectory(mTestRootDir, true);
    super.tearDown();
}
#end_block

#method_before
public void testCurrentDataDirIsFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    // Create a file with the same name as the directory that tzdatacheck expects.
    Files.write(dataCurrentDir.hostPath, new byte[] { 'a' });
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(2, runTzDataCheckOnDevice());
    // Assert the file was just ignored. This is a fairly arbitrary choice to leave it rather
    // than delete.
    assertDevicePathExists(dataCurrentDir.devicePath);
    assertDevicePathIsFile(dataCurrentDir.devicePath);
}
#method_after
public void testCurrentDataDirIsFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    // Create a file with the same name as the directory that tzdatacheck expects.
    Files.write(dataCurrentDir.hostPath, new byte[] { 'a' });
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(2, runTzDataCheckOnDevice());
    // Assert the file was just ignored. This is a fairly arbitrary choice to leave it rather
    // than delete.
    assertDevicePathExists(dataCurrentDir);
    assertDevicePathIsFile(dataCurrentDir);
}
#end_block

#method_before
public void testMissingDataDirDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    TimeZoneDistro distroWithoutAVersionFile = createValidDistroBuilder().clearVersionForTests().buildUnvalidated();
    distroWithoutAVersionFile.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(3, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testMissingDataDirDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    TimeZoneDistro distroWithoutAVersionFile = createValidDistroBuilder().clearVersionForTests().buildUnvalidated();
    unpackOnHost(dataCurrentDir, distroWithoutAVersionFile);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(3, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
public void testShortDataDirDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    createValidDistroBuilder().build().extractTo(dataCurrentDir.hostFile());
    // Replace the distro version file with a short file.
    Path distroVersionFile = dataCurrentDir.hostPath.resolve(TimeZoneDistro.DISTRO_VERSION_FILE_NAME);
    assertHostFileExists(distroVersionFile);
    Files.write(distroVersionFile, new byte[3]);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(3, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testShortDataDirDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    unpackOnHost(dataCurrentDir, createValidDistroBuilder().build());
    // Replace the distro version file with a short file.
    Path distroVersionFile = dataCurrentDir.hostPath.resolve(TimeZoneDistro.DISTRO_VERSION_FILE_NAME);
    assertHostFileExists(distroVersionFile);
    Files.write(distroVersionFile, new byte[3]);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(3, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
public void testCorruptDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    createValidDistroBuilder().build().extractTo(dataCurrentDir.hostFile());
    // Replace the distro version file with junk.
    Path distroVersionFile = dataCurrentDir.hostPath.resolve(TimeZoneDistro.DISTRO_VERSION_FILE_NAME);
    assertHostFileExists(distroVersionFile);
    int fileLength = (int) Files.size(distroVersionFile);
    // all zeros
    byte[] junkArray = new byte[fileLength];
    Files.write(distroVersionFile, junkArray);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(4, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testCorruptDistroVersionFile() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    unpackOnHost(dataCurrentDir, createValidDistroBuilder().build());
    // Replace the distro version file with junk.
    Path distroVersionFile = dataCurrentDir.hostPath.resolve(TimeZoneDistro.DISTRO_VERSION_FILE_NAME);
    assertHostFileExists(distroVersionFile);
    int fileLength = (int) Files.size(distroVersionFile);
    // all zeros
    byte[] junkArray = new byte[fileLength];
    Files.write(distroVersionFile, junkArray);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(4, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
public void testInvalidMajorDistroVersion_older() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    DistroVersion oldMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION - 1, 1, VALID_RULES_VERSION, 1);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(oldMajorDistroVersion).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testInvalidMajorDistroVersion_older() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    DistroVersion oldMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION - 1, 1, VALID_RULES_VERSION, 1);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(oldMajorDistroVersion).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
public void testInvalidMajorDistroVersion_newer() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    DistroVersion newMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION + 1, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, VALID_RULES_VERSION, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(newMajorDistroVersion).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testInvalidMajorDistroVersion_newer() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    DistroVersion newMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION + 1, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, VALID_RULES_VERSION, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(newMajorDistroVersion).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
public void testInvalidMinorDistroVersion_older() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    DistroVersion oldMinorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION - 1, VALID_RULES_VERSION, 1);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(oldMinorDistroVersion).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testInvalidMinorDistroVersion_older() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    DistroVersion oldMinorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION - 1, VALID_RULES_VERSION, 1);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(oldMinorDistroVersion).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(5, runTzDataCheckOnDevice());
    // Assert the current data directory was deleted.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
// {dataDir}/current exists but the distro version is newer (which is accepted because it should
public void testValidMinorDistroVersion_newer() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    DistroVersion newMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION + 1, VALID_RULES_VERSION, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(newMajorDistroVersion).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDevicePathExists(dataCurrentDir.devicePath);
}
#method_after
// {dataDir}/current exists but the distro version is newer (which is accepted because it should
public void testValidMinorDistroVersion_newer() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(VALID_RULES_VERSION);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    DistroVersion newMajorDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION + 1, VALID_RULES_VERSION, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(newMajorDistroVersion).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDeviceDirContainsDistro(dataCurrentDir, distro);
}
#end_block

#method_before
public void testSystemTzDataFileMissing() throws Exception {
    // Deliberately not writing anything in /system here.
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    TimeZoneDistro validDistro = createValidDistroBuilder().build();
    validDistro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(6, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDevicePathExists(dataCurrentDir.devicePath);
}
#method_after
public void testSystemTzDataFileMissing() throws Exception {
    // Deliberately not writing anything in /system here.
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    TimeZoneDistro validDistro = createValidDistroBuilder().build();
    unpackOnHost(dataCurrentDir, validDistro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(6, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDeviceDirContainsDistro(dataCurrentDir, validDistro);
}
#end_block

#method_before
public void testSystemTzDataFileCorrupt() throws Exception {
    // Set up the /system directory structure on host.
    byte[] invalidTzDataBytes = new byte[20];
    Files.write(systemDir.hostPath.resolve(SYSTEM_TZDATA_FILE_NAME), invalidTzDataBytes);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    TimeZoneDistro validDistro = createValidDistroBuilder().build();
    validDistro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(7, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDevicePathExists(dataCurrentDir.devicePath);
}
#method_after
public void testSystemTzDataFileCorrupt() throws Exception {
    // Set up the /system directory structure on host.
    byte[] invalidTzDataBytes = new byte[20];
    Files.write(mSystemDir.hostPath.resolve(SYSTEM_TZDATA_FILE_NAME), invalidTzDataBytes);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    TimeZoneDistro validDistro = createValidDistroBuilder().build();
    unpackOnHost(dataCurrentDir, validDistro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(7, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDeviceDirContainsDistro(dataCurrentDir, validDistro);
}
#end_block

#method_before
public void testSystemTzRulesOlder() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(RULES_VERSION_ONE);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    // Newer than RULES_VERSION_ONE in /system
    final String distroRulesVersion = RULES_VERSION_TWO;
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzData(createValidTzDataBytes(distroRulesVersion)).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDevicePathExists(dataCurrentDir.devicePath);
}
#method_after
public void testSystemTzRulesOlder() throws Exception {
    // Set up the /system directory structure on host.
    createSystemTzDataFileOnHost(RULES_VERSION_ONE);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    // Newer than RULES_VERSION_ONE in /system
    final String distroRulesVersion = RULES_VERSION_TWO;
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzDataFile(createValidTzDataBytes(distroRulesVersion)).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDeviceDirContainsDistro(dataCurrentDir, distro);
}
#end_block

#method_before
public void testSystemTzDataSame() throws Exception {
    // Set up the /system directory structure on host.
    final String systemRulesVersion = VALID_RULES_VERSION;
    createSystemTzDataFileOnHost(systemRulesVersion);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, systemRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzData(createValidTzDataBytes(systemRulesVersion)).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDevicePathExists(dataCurrentDir.devicePath);
}
#method_after
public void testSystemTzDataSame() throws Exception {
    // Set up the /system directory structure on host.
    final String systemRulesVersion = VALID_RULES_VERSION;
    createSystemTzDataFileOnHost(systemRulesVersion);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, systemRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzDataFile(createValidTzDataBytes(systemRulesVersion)).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // Assert the current data directory was not touched.
    assertDeviceDirContainsDistro(dataCurrentDir, distro);
}
#end_block

#method_before
public void testSystemTzDataNewer() throws Exception {
    // Set up the /system directory structure on host.
    String systemRulesVersion = RULES_VERSION_TWO;
    createSystemTzDataFileOnHost(systemRulesVersion);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = dataDir.createSubPath(CURRENT_DIR_NAME);
    createHostDirectory(dataCurrentDir);
    // Older than the system version.
    String distroRulesVersion = RULES_VERSION_ONE;
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzData(createValidTzDataBytes(distroRulesVersion)).build();
    distro.extractTo(dataCurrentDir.hostFile());
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // It is important the dataCurrentDir is deleted in this case - this test case is the main
    // reason tzdatacheck exists.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#method_after
public void testSystemTzDataNewer() throws Exception {
    // Set up the /system directory structure on host.
    String systemRulesVersion = RULES_VERSION_TWO;
    createSystemTzDataFileOnHost(systemRulesVersion);
    // Set up the /data directory structure on host.
    PathPair dataCurrentDir = mDataDir.createSubPath(CURRENT_DIR_NAME);
    // Older than the system version.
    String distroRulesVersion = RULES_VERSION_ONE;
    DistroVersion distroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    TimeZoneDistro distro = createValidDistroBuilder().setDistroVersion(distroVersion).setTzDataFile(createValidTzDataBytes(distroRulesVersion)).build();
    unpackOnHost(dataCurrentDir, distro);
    // Push the host test directory and contents to the device.
    pushHostTestDirToDevice();
    // Execute tzdatacheck and check the status code.
    assertEquals(0, runTzDataCheckOnDevice());
    // It is important the dataCurrentDir is deleted in this case - this test case is the main
    // reason tzdatacheck exists.
    assertDevicePathDoesNotExist(dataCurrentDir);
}
#end_block

#method_before
private void createSystemTzDataFileOnHost(String systemRulesVersion) throws IOException {
    byte[] systemTzData = createValidTzDataBytes(systemRulesVersion);
    Files.write(systemDir.hostPath.resolve(SYSTEM_TZDATA_FILE_NAME), systemTzData);
}
#method_after
private void createSystemTzDataFileOnHost(String systemRulesVersion) throws IOException {
    byte[] systemTzData = createValidTzDataBytes(systemRulesVersion);
    Files.write(mSystemDir.hostPath.resolve(SYSTEM_TZDATA_FILE_NAME), systemTzData);
}
#end_block

#method_before
private static TimeZoneDistroBuilder createValidDistroBuilder() throws Exception {
    String distroRulesVersion = VALID_RULES_VERSION;
    DistroVersion validDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    return new TimeZoneDistroBuilder().setDistroVersion(validDistroVersion).setTzData(createValidTzDataBytes(distroRulesVersion)).setIcuData(new byte[10]);
}
#method_after
private static TimeZoneDistroBuilder createValidDistroBuilder() throws Exception {
    String distroRulesVersion = VALID_RULES_VERSION;
    DistroVersion validDistroVersion = new DistroVersion(DistroVersion.CURRENT_FORMAT_MAJOR_VERSION, DistroVersion.CURRENT_FORMAT_MINOR_VERSION, distroRulesVersion, VALID_REVISION);
    return new TimeZoneDistroBuilder().setDistroVersion(validDistroVersion).setTzDataFile(createValidTzDataBytes(distroRulesVersion)).setIcuDataFile(new byte[10]);
}
#end_block

#method_before
private int runTzDataCheckOnDevice() throws Exception {
    return runTzDataCheckWithArgs(new String[] { systemDir.devicePath, dataDir.devicePath });
}
#method_after
private int runTzDataCheckOnDevice() throws Exception {
    return runTzDataCheckWithArgs(new String[] { mSystemDir.devicePath, mDataDir.devicePath });
}
#end_block

#method_before
private int runTzDataCheckWithArgs(String[] args) throws Exception {
    String command = createTzDataCheckCommand(deviceAndroidRootDir, args);
    return executeCommandOnDeviceWithResultCode(command).statusCode;
}
#method_after
private int runTzDataCheckWithArgs(String[] args) throws Exception {
    String command = createTzDataCheckCommand(mDeviceAndroidRootDir, args);
    return executeCommandOnDeviceWithResultCode(command).statusCode;
}
#end_block

#method_before
private String executeCommandOnDeviceRaw(String command) throws Exception {
    CollectingOutputReceiver outputReceiver = new CollectingOutputReceiver();
    getDevice().executeShellCommand(command, outputReceiver, 5000, TimeUnit.MILLISECONDS, 1);
    return outputReceiver.getOutput();
}
#method_after
private String executeCommandOnDeviceRaw(String command) throws DeviceNotAvailableException {
    return getDevice().executeShellCommand(command);
}
#end_block

#method_before
private void createDeviceDirectory(PathPair dir) {
    try {
        executeCommandOnDeviceRaw("mkdir -p " + dir.devicePath);
    } catch (Exception e) {
        fail(e);
    }
}
#method_after
private void createDeviceDirectory(PathPair dir) throws DeviceNotAvailableException {
    executeCommandOnDeviceRaw("mkdir -p " + dir.devicePath);
}
#end_block

#method_before
private ShellResult executeCommandOnDeviceWithResultCode(String command) throws Exception {
    // A file to hold the script we're going to create.
    PathPair scriptFile = testRootDir.createSubPath("script.sh");
    // A file to hold the output of the script.
    PathPair scriptOut = testRootDir.createSubPath("script.out");
    // The content of the script. Runs the command, capturing stdout and stderr to scriptOut
    // and printing the result code.
    String hostScriptContent = command + " > " + scriptOut.devicePath + " 2>&1 ; echo -n $?";
    // Parse and return the result.
    try {
        Files.write(scriptFile.hostPath, hostScriptContent.getBytes(StandardCharsets.US_ASCII));
        // Push the script to the device.
        pushFile(scriptFile);
        // Execute the script using "sh".
        String execCommandUnderShell = deviceAndroidRootDir + "/bin/sh " + scriptFile.devicePath;
        String resultCodeString = executeCommandOnDeviceRaw(execCommandUnderShell);
        // Pull back scriptOut to the host and read the content.
        pullFile(scriptOut);
        byte[] outputBytes = Files.readAllBytes(scriptOut.hostPath);
        String output = new String(outputBytes, StandardCharsets.US_ASCII);
        int resultCode;
        try {
            resultCode = Integer.parseInt(resultCodeString);
        } catch (NumberFormatException e) {
            fail("Command: " + command + " returned a non-integer: \"" + resultCodeString + "\"" + ", output=\"" + output + "\"");
            return null;
        }
        return new ShellResult(output, resultCode);
    } finally {
        deleteDeviceFile(scriptFile, false);
        deleteDeviceFile(scriptOut, false);
        deleteHostFile(scriptFile, false);
        deleteHostFile(scriptOut, false);
    }
}
#method_after
private ShellResult executeCommandOnDeviceWithResultCode(String command) throws Exception {
    // A file to hold the script we're going to create.
    PathPair scriptFile = mTestRootDir.createSubPath("script.sh");
    // A file to hold the output of the script.
    PathPair scriptOut = mTestRootDir.createSubPath("script.out");
    // The content of the script. Runs the command, capturing stdout and stderr to scriptOut
    // and printing the result code.
    String hostScriptContent = command + " > " + scriptOut.devicePath + " 2>&1 ; echo -n $?";
    // Parse and return the result.
    try {
        Files.write(scriptFile.hostPath, hostScriptContent.getBytes(StandardCharsets.US_ASCII));
        // Push the script to the device.
        pushFile(scriptFile);
        // Execute the script using "sh".
        String execCommandUnderShell = mDeviceAndroidRootDir + "/bin/sh " + scriptFile.devicePath;
        String resultCodeString = executeCommandOnDeviceRaw(execCommandUnderShell);
        // Pull back scriptOut to the host and read the content.
        pullFile(scriptOut);
        byte[] outputBytes = Files.readAllBytes(scriptOut.hostPath);
        String output = new String(outputBytes, StandardCharsets.US_ASCII);
        int resultCode;
        try {
            resultCode = Integer.parseInt(resultCodeString);
        } catch (NumberFormatException e) {
            fail("Command: " + command + " returned a non-integer: \"" + resultCodeString + "\"" + ", output=\"" + output + "\"");
            return null;
        }
        return new ShellResult(output, resultCode);
    } finally {
        deleteDeviceFile(scriptFile, false);
        deleteDeviceFile(scriptOut, false);
        deleteHostFile(scriptFile, false);
        deleteHostFile(scriptOut, false);
    }
}
#end_block

#method_before
private void pushHostTestDirToDevice() throws Exception {
    assertTrue(getDevice().pushDir(testRootDir.hostFile(), testRootDir.devicePath));
}
#method_after
private void pushHostTestDirToDevice() throws Exception {
    assertTrue(getDevice().pushDir(mTestRootDir.hostFile(), mTestRootDir.devicePath));
}
#end_block

#method_before
private void pullFile(PathPair file) {
    try {
        assertTrue("Could not pull file " + file.devicePath + " to " + file.hostFile(), getDevice().pullFile(file.devicePath, file.hostFile()));
    } catch (Exception e) {
        fail(e);
    }
}
#method_after
private void pullFile(PathPair file) throws DeviceNotAvailableException {
    assertTrue("Could not pull file " + file.devicePath + " to " + file.hostFile(), getDevice().pullFile(file.devicePath, file.hostFile()));
}
#end_block

#method_before
private void pushFile(PathPair file) {
    try {
        assertTrue("Could not push file " + file.hostFile() + " to " + file.devicePath, getDevice().pushFile(file.hostFile(), file.devicePath));
    } catch (Exception e) {
        fail(e);
    }
}
#method_after
private void pushFile(PathPair file) throws DeviceNotAvailableException {
    assertTrue("Could not push file " + file.hostFile() + " to " + file.devicePath, getDevice().pushFile(file.hostFile(), file.devicePath));
}
#end_block

#method_before
private void deleteDeviceDirectory(PathPair dir, boolean failOnError) {
    String deviceDir = dir.devicePath;
    try {
        executeCommandOnDeviceRaw("rm -r " + deviceDir);
    } catch (Exception e) {
        if (failOnError) {
            fail(e);
        }
    }
}
#method_after
private void deleteDeviceDirectory(PathPair dir, boolean failOnError) throws DeviceNotAvailableException {
    String deviceDir = dir.devicePath;
    try {
        executeCommandOnDeviceRaw("rm -r " + deviceDir);
    } catch (Exception e) {
        if (failOnError) {
            throw deviceFail(e);
        }
    }
}
#end_block

#method_before
private void deleteDeviceFile(PathPair file, boolean failOnError) {
    try {
        assertDevicePathIsFile(file.devicePath);
        executeCommandOnDeviceRaw("rm " + file.devicePath);
    } catch (Exception e) {
        if (failOnError) {
            fail(e);
        }
    }
}
#method_after
private void deleteDeviceFile(PathPair file, boolean failOnError) throws DeviceNotAvailableException {
    try {
        assertDevicePathIsFile(file);
        executeCommandOnDeviceRaw("rm " + file.devicePath);
    } catch (Exception e) {
        if (failOnError) {
            throw deviceFail(e);
        }
    }
}
#end_block

#method_before
private void assertDevicePathExists(String devicePath) {
    try {
        assertTrue(getDevice().doesFileExist(devicePath));
    } catch (DeviceNotAvailableException e) {
        fail(e);
    }
}
#method_after
private void assertDevicePathExists(PathPair path) throws DeviceNotAvailableException {
    assertTrue(getDevice().doesFileExist(path.devicePath));
}
#end_block

#method_before
private void assertDevicePathDoesNotExist(PathPair path) {
    try {
        assertFalse(getDevice().doesFileExist(path.devicePath));
    } catch (DeviceNotAvailableException e) {
        fail(e);
    }
}
#method_after
private void assertDevicePathDoesNotExist(PathPair path) throws DeviceNotAvailableException {
    assertFalse(getDevice().doesFileExist(path.devicePath));
}
#end_block

#method_before
private void assertDevicePathIsFile(String devicePath) {
    // directories. http://b/35753041.
    try {
        String output = executeCommandOnDeviceRaw("stat -c %F " + devicePath);
        assertTrue(devicePath + " not a file. Received: " + output, output.startsWith("regular") && output.endsWith("file\n"));
    } catch (Exception e) {
        fail(e);
    }
}
#method_after
private void assertDevicePathIsFile(PathPair path) throws DeviceNotAvailableException {
    // This check cannot rely on getDevice().getFile(devicePath).isDirectory() here because that
    // requires that the user has rights to list all files beneath each and every directory in
    // the path. That is not the case for the shell user and the /data and /data/local
    // directories. http://b/35753041.
    String output = executeCommandOnDeviceRaw("stat -c %F " + path.devicePath);
    assertTrue(path.devicePath + " not a file. Received: " + output, output.startsWith("regular") && output.endsWith("file\n"));
}
#end_block

#method_before
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mForwardedDownstreams.remove(who);
    }
    // serving mode explicitly.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        int wifiMode = WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR;
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                wifiMode = WifiManager.IFACE_IP_MODE_TETHERED;
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                wifiMode = WifiManager.IFACE_IP_MODE_LOCAL_ONLY;
                break;
        }
        if (wifiMode != WifiManager.IFACE_IP_MODE_CONFIGURATION_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), wifiMode);
        }
    }
}
#method_after
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, WifiManager.IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, WifiManager.IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#end_block

#method_before
private static int readHighTagNumber(InputStream in) throws IOException, BerDataValueFormatException {
    // Base-128 big-endian form, where each byte has the highest bit set, except for the last
    // byte where the highest bit is not set
    int b;
    int result = 0;
    do {
        b = in.read();
        if (b == -1) {
            throw new BerDataValueFormatException("Truncated tag number");
        }
        result <<= 7;
        result += b & 0x7f;
        if (result < 0) {
            throw new BerDataValueFormatException("Tag number too large");
        }
    } while ((b & 0x80) != 0);
    return result;
}
#method_after
private static int readHighTagNumber(InputStream in) throws IOException, BerDataValueFormatException {
    // Base-128 big-endian form, where each byte has the highest bit set, except for the last
    // byte where the highest bit is not set
    int b;
    int result = 0;
    do {
        b = in.read();
        if (b == -1) {
            throw new BerDataValueFormatException("Truncated tag number");
        }
        if (result > Integer.MAX_VALUE >>> 7) {
            throw new BerDataValueFormatException("Tag number too large");
        }
        result <<= 7;
        result |= b & 0x7f;
    } while ((b & 0x80) != 0);
    return result;
}
#end_block

#method_before
private static int readLongFormLength(InputStream in, int firstLengthByte) throws IOException, BerDataValueFormatException {
    // The low 7 bits of the first byte represent the number of bytes (following the first
    // byte) in which the length is in big-endian base-256 form
    int byteCount = firstLengthByte & 0x7f;
    if (byteCount > 4) {
        throw new BerDataValueFormatException("Length too large: " + byteCount + " bytes");
    }
    int result = 0;
    for (int i = 0; i < byteCount; i++) {
        int b = in.read();
        if (b == -1) {
            throw new BerDataValueFormatException("Truncated length");
        }
        result <<= 8;
        result += b & 0xff;
        if (result < 0) {
            throw new BerDataValueFormatException("Length too large");
        }
    }
    return result;
}
#method_after
private static int readLongFormLength(InputStream in, int firstLengthByte) throws IOException, BerDataValueFormatException {
    // The low 7 bits of the first byte represent the number of bytes (following the first
    // byte) in which the length is in big-endian base-256 form
    int byteCount = firstLengthByte & 0x7f;
    if (byteCount > 4) {
        throw new BerDataValueFormatException("Length too large: " + byteCount + " bytes");
    }
    int result = 0;
    for (int i = 0; i < byteCount; i++) {
        int b = in.read();
        if (b == -1) {
            throw new BerDataValueFormatException("Truncated length");
        }
        if (result > Integer.MAX_VALUE >>> 8) {
            throw new BerDataValueFormatException("Length too large");
        }
        result <<= 8;
        result |= b & 0xff;
    }
    return result;
}
#end_block

#method_before
@Test
public void testLongFormLength() throws Exception {
    assertByteBufferEquals(new byte[0], readDataValue("308100").getEncodedContents());
    assertByteBufferEquals(HexEncoding.decode("010203"), readDataValue("30820003010203").getEncodedContents());
    assertByteBufferEquals(HexEncoding.decode("000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f"), readDataValue("30820110" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f" + "000102030405060708090a0b0c0d0e0f").getEncodedContents());
}
#method_after
@Test
public void testLongFormLength() throws Exception {
    assertByteBufferEquals(new byte[0], readDataValue("308100").getEncodedContents());
    assertByteBufferEquals(HexEncoding.decode("010203"), readDataValue("30820003010203").getEncodedContents());
    assertEquals(255, readDataValue(concat(HexEncoding.decode("3081ff"), new byte[255])).getEncodedContents().remaining());
    assertEquals(0x110, readDataValue(concat(HexEncoding.decode("30820110"), new byte[0x110])).getEncodedContents().remaining());
}
#end_block

#method_before
private BerDataValue readDataValue(String hexEncodedInput) throws BerDataValueFormatException {
    return createReader(hexEncodedInput).readDataValue();
}
#method_after
private BerDataValue readDataValue(byte[] input) throws BerDataValueFormatException {
    return createReader(input).readDataValue();
}
#end_block

#method_before
private int readHighTagNumber() throws BerDataValueFormatException {
    // Base-128 big-endian form, where each byte has the highest bit set, except for the last
    // byte
    int b;
    int result = 0;
    do {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated tag number");
        }
        b = mBuf.get();
        result <<= 7;
        result += b & 0x7f;
        if (result < 0) {
            throw new BerDataValueFormatException("Tag number too large");
        }
    } while ((b & 0x80) != 0);
    return result;
}
#method_after
private int readHighTagNumber() throws BerDataValueFormatException {
    // Base-128 big-endian form, where each byte has the highest bit set, except for the last
    // byte
    int b;
    int result = 0;
    do {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated tag number");
        }
        b = mBuf.get();
        if (result > Integer.MAX_VALUE >>> 7) {
            throw new BerDataValueFormatException("Tag number too large");
        }
        result <<= 7;
        result |= b & 0x7f;
    } while ((b & 0x80) != 0);
    return result;
}
#end_block

#method_before
private int readLongFormLength(int firstLengthByte) throws BerDataValueFormatException {
    // The low 7 bits of the first byte represent the number of bytes (following the first
    // byte) in which the length is in big-endian base-256 form
    int byteCount = firstLengthByte & 0x7f;
    if (byteCount > 4) {
        throw new BerDataValueFormatException("Length too large: " + byteCount + " bytes");
    }
    int result = 0;
    for (int i = 0; i < byteCount; i++) {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated length");
        }
        int b = mBuf.get();
        result <<= 8;
        result += b & 0xff;
        if (result < 0) {
            throw new BerDataValueFormatException("Length too large");
        }
    }
    return result;
}
#method_after
private int readLongFormLength(int firstLengthByte) throws BerDataValueFormatException {
    // The low 7 bits of the first byte represent the number of bytes (following the first
    // byte) in which the length is in big-endian base-256 form
    int byteCount = firstLengthByte & 0x7f;
    if (byteCount > 4) {
        throw new BerDataValueFormatException("Length too large: " + byteCount + " bytes");
    }
    int result = 0;
    for (int i = 0; i < byteCount; i++) {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated length");
        }
        int b = mBuf.get();
        if (result > Integer.MAX_VALUE >>> 8) {
            throw new BerDataValueFormatException("Length too large");
        }
        result <<= 8;
        result |= b & 0xff;
    }
    return result;
}
#end_block

#method_before
private int skipIndefiniteLengthContents() throws BerDataValueFormatException {
    // Contents are terminated by 0x00 0x00
    boolean prevZeroByte = false;
    int bytesRead = 0;
    while (true) {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated indefinite-length contents: " + bytesRead + " bytes read");
        }
        int b = mBuf.get();
        bytesRead++;
        if (bytesRead < 0) {
            throw new BerDataValueFormatException("Indefinite-length contents too long");
        }
        if (b == 0) {
            if (prevZeroByte) {
                // End of contents reached -- we've read the value and its terminator 0x00 0x00
                return bytesRead - 2;
            }
            prevZeroByte = true;
            continue;
        } else {
            prevZeroByte = false;
        }
    }
}
#method_after
private int skipIndefiniteLengthContents() throws BerDataValueFormatException {
    // Contents are terminated by 0x00 0x00
    boolean prevZeroByte = false;
    int bytesRead = 0;
    while (true) {
        if (!mBuf.hasRemaining()) {
            throw new BerDataValueFormatException("Truncated indefinite-length contents: " + bytesRead + " bytes read");
        }
        int b = mBuf.get();
        bytesRead++;
        if (bytesRead < 0) {
            throw new BerDataValueFormatException("Indefinite-length contents too long");
        }
        if (b == 0) {
            if (prevZeroByte) {
                // End of contents reached -- we've read the value and its terminator 0x00 0x00
                return bytesRead - 2;
            }
            prevZeroByte = true;
        } else {
            prevZeroByte = false;
        }
    }
}
#end_block

#method_before
public void encode(OutputStream out) throws CertificateEncodingException {
    if (signedCert == null)
        throw new CertificateEncodingException("Null certificate to encode");
    try {
        out.write(signedCert.clone());
    } catch (IOException e) {
        throw new CertificateEncodingException(e.toString());
    }
}
#method_after
// END Android-added: Ctor to retain original encoded form for APKs parsing
public void encode(OutputStream out) throws CertificateEncodingException {
    if (signedCert == null)
        throw new CertificateEncodingException("Null certificate to encode");
    try {
        out.write(signedCert.clone());
    } catch (IOException e) {
        throw new CertificateEncodingException(e.toString());
    }
}
#end_block

#method_before
/**
 * ********************************************************
 */
private void parse(DerValue val) throws CertificateException, IOException {
    // BEGIN Android-added: Needed for providing encoded form of cert
    parse(val, // use re-encoded form of val as the encoded form
    null);
}
#method_after
/**
 * ********************************************************
 */
private void parse(DerValue val) throws CertificateException, IOException {
    // BEGIN Android-added: Use original encoded form of cert rather than regenerating.
    parse(val, // use re-encoded form of val as the encoded form
    null);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    super.writeToParcel(dest, flags);
    dest.writeList(files);
}
#end_block

#method_before
public void fileServicesUpdated() {
// default implementation empty
}
#method_after
public void fileServicesUpdated(List<FileServiceInfo> services) {
// default implementation empty
}
#end_block

#method_before
public URI getPlaybackUri() {
}
#method_after
public Uri getPlaybackUri() {
    return null;
}
#end_block

#method_before
public StreamingServiceInfo getInfo() {
}
#method_after
public StreamingServiceInfo getInfo() {
    return null;
}
#end_block

#method_before
public int getState() {
}
#method_after
public int getState() {
    return STATE_STOPPED;
}
#end_block

#method_before
public void switchStream(StreamServiceInfo streamServiceInfo) {
}
#method_after
public void switchStream(StreamingServiceInfo streamingServiceInfo) {
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    super.writeToParcel(dest, flags);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
}
#method_after
public void writeToParcel(Parcel dest, int flags) {
    Set<Locale> keySet = names.keySet();
    dest.writeInt(keySet.size());
    for (Locale l : keySet) {
        dest.writeSerializable(l);
        dest.writeString(names.get(l));
    }
    dest.writeString(className);
    dest.writeSerializable(locale);
    dest.writeString(serviceId);
    dest.writeSerializable(sessionStartTime);
    dest.writeSerializable(sessionEndTime);
}
#end_block

#method_before
@Override
public int describeContents() {
    return 0;
}
#method_after
public int describeContents() {
    return 0;
}
#end_block

#method_before
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        userVpn.loadAlwaysOnPackage();
        mVpns.put(userId, userVpn);
    }
    if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
        updateLockdownVpn();
    }
}
#method_after
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
    }
    if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
        updateLockdownVpn();
    }
}
#end_block

#method_before
private void initLocked() {
    Slog.d(TAG, "initLocked()");
    mVpn.setEnableTeardown(false);
    mVpn.setLockdownEnabled(true);
    final IntentFilter resetFilter = new IntentFilter(ACTION_LOCKDOWN_RESET);
    mContext.registerReceiver(mResetReceiver, resetFilter, CONNECTIVITY_INTERNAL, null);
    handleStateChangedLocked();
}
#method_after
private void initLocked() {
    Slog.d(TAG, "initLocked()");
    mVpn.setEnableTeardown(false);
    mVpn.setLockdown(true);
    final IntentFilter resetFilter = new IntentFilter(ACTION_LOCKDOWN_RESET);
    mContext.registerReceiver(mResetReceiver, resetFilter, CONNECTIVITY_INTERNAL, null);
    handleStateChangedLocked();
}
#end_block

#method_before
private void shutdownLocked() {
    Slog.d(TAG, "shutdownLocked()");
    mAcceptedEgressIface = null;
    mErrorCount = 0;
    mVpn.stopLegacyVpnPrivileged();
    mVpn.setLockdownEnabled(false);
    hideNotification();
    mContext.unregisterReceiver(mResetReceiver);
    mVpn.setEnableTeardown(true);
}
#method_after
private void shutdownLocked() {
    Slog.d(TAG, "shutdownLocked()");
    mAcceptedEgressIface = null;
    mErrorCount = 0;
    mVpn.stopLegacyVpnPrivileged();
    mVpn.setLockdown(false);
    hideNotification();
    mContext.unregisterReceiver(mResetReceiver);
    mVpn.setEnableTeardown(true);
}
#end_block

#method_before
public synchronized void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public synchronized void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdownEnabled(false);
    mAlwaysOn = false;
    unregisterPackageChangeReceiverLocked();
    // Quit any active connections
    agentDisconnect();
}
#method_after
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    unregisterPackageChangeReceiverLocked();
    // Quit any active connections
    agentDisconnect();
}
#end_block

#method_before
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    if (isNullOrLegacyVpn(mPackage)) {
        setVpnForcedWithExemptionsLocked(enforce, null);
    } else {
        setVpnForcedWithExemptionsLocked(enforce, Collections.singletonList(mPackage));
    }
}
#method_after
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    final List<String> exemptedPackages = isNullOrLegacyVpn(mPackage) ? null : Collections.singletonList(mPackage);
    setVpnForcedWithExemptionsLocked(enforce, exemptedPackages);
}
#end_block

#method_before
@GuardedBy("this")
private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) {
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    final Set<UidRange> addedRanges;
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        exemptedPackages);
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    } else {
        addedRanges = Collections.<UidRange>emptySet();
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#method_after
@GuardedBy("this")
private void setVpnForcedWithExemptionsLocked(boolean enforce, @Nullable List<String> exemptedPackages) {
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    Set<UidRange> addedRanges = Collections.emptySet();
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        exemptedPackages);
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#end_block

#method_before
void adapterPropertyChangedCallback(int[] types, byte[][] values) {
    Intent intent;
    int type;
    byte[] val;
    for (int i = 0; i < types.length; i++) {
        val = values[i];
        type = types[i];
        infoLog("adapterPropertyChangedCallback with type:" + type + " len:" + val.length);
        synchronized (mObject) {
            switch(type) {
                case AbstractionLayer.BT_PROPERTY_BDNAME:
                    mName = new String(val);
                    intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, mName);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcastAsUser(intent, UserHandle.ALL, mService.BLUETOOTH_PERM);
                    debugLog("Name is: " + mName);
                    break;
                case AbstractionLayer.BT_PROPERTY_BDADDR:
                    // Check that this is a valid device address (i.e. not broadcast).
                    if ((val[0] & 0x01) != 0) {
                        // Invalid since this is a broadcast address.
                        errorLog("Invalid device address=" + Utils.getAddressStringFromByte(val) + ". Ignore this address.");
                        break;
                    }
                    mAddress = val;
                    debugLog("Address is:" + Utils.getAddressStringFromByte(mAddress));
                    intent = new Intent(BluetoothAdapter.ACTION_BT_BD_ADDR_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_BT_BD_ADDR, Utils.getAddressStringFromByte(mAddress));
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcastAsUser(intent, UserHandle.ALL, mService.BLUETOOTH_PERM);
                    break;
                case AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE:
                    mBluetoothClass = Utils.byteArrayToInt(val, 0);
                    debugLog("BT Class:" + mBluetoothClass);
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_SCAN_MODE:
                    int mode = Utils.byteArrayToInt(val, 0);
                    mScanMode = mService.convertScanModeFromHal(mode);
                    intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcast(intent, mService.BLUETOOTH_PERM);
                    debugLog("Scan Mode:" + mScanMode);
                    if (mBluetoothDisabling) {
                        mBluetoothDisabling = false;
                        mService.startBluetoothDisable();
                    }
                    break;
                case AbstractionLayer.BT_PROPERTY_UUIDS:
                    mUuids = Utils.byteArrayToUuid(val);
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_BONDED_DEVICES:
                    int number = val.length / BD_ADDR_LEN;
                    byte[] addrByte = new byte[BD_ADDR_LEN];
                    for (int j = 0; j < number; j++) {
                        System.arraycopy(val, j * BD_ADDR_LEN, addrByte, 0, BD_ADDR_LEN);
                        onBondStateChanged(mAdapter.getRemoteDevice(Utils.getAddressStringFromByte(addrByte)), BluetoothDevice.BOND_BONDED);
                    }
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_DISCOVERABLE_TIMEOUT:
                    mDiscoverableTimeout = Utils.byteArrayToInt(val, 0);
                    debugLog("Discoverable Timeout:" + mDiscoverableTimeout);
                    break;
                case AbstractionLayer.BT_PROPERTY_LOCAL_LE_FEATURES:
                    updateFeatureSupport(val);
                    break;
                default:
                    errorLog("Property change not handled in Java land:" + type);
            }
        }
    }
}
#method_after
void adapterPropertyChangedCallback(int[] types, byte[][] values) {
    Intent intent;
    int type;
    byte[] val;
    for (int i = 0; i < types.length; i++) {
        val = values[i];
        type = types[i];
        infoLog("adapterPropertyChangedCallback with type:" + type + " len:" + val.length);
        synchronized (mObject) {
            switch(type) {
                case AbstractionLayer.BT_PROPERTY_BDNAME:
                    mName = new String(val);
                    intent = new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME, mName);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcastAsUser(intent, UserHandle.ALL, mService.BLUETOOTH_PERM);
                    debugLog("Name is: " + mName);
                    break;
                case AbstractionLayer.BT_PROPERTY_BDADDR:
                    mAddress = val;
                    String address = Utils.getAddressStringFromByte(mAddress);
                    debugLog("Address is:" + address);
                    intent = new Intent(BluetoothAdapter.ACTION_BLUETOOTH_ADDRESS_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_BLUETOOTH_ADDRESS, address);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcastAsUser(intent, UserHandle.ALL, mService.BLUETOOTH_PERM);
                    break;
                case AbstractionLayer.BT_PROPERTY_CLASS_OF_DEVICE:
                    mBluetoothClass = Utils.byteArrayToInt(val, 0);
                    debugLog("BT Class:" + mBluetoothClass);
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_SCAN_MODE:
                    int mode = Utils.byteArrayToInt(val, 0);
                    mScanMode = mService.convertScanModeFromHal(mode);
                    intent = new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
                    intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE, mScanMode);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
                    mService.sendBroadcast(intent, mService.BLUETOOTH_PERM);
                    debugLog("Scan Mode:" + mScanMode);
                    if (mBluetoothDisabling) {
                        mBluetoothDisabling = false;
                        mService.startBluetoothDisable();
                    }
                    break;
                case AbstractionLayer.BT_PROPERTY_UUIDS:
                    mUuids = Utils.byteArrayToUuid(val);
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_BONDED_DEVICES:
                    int number = val.length / BD_ADDR_LEN;
                    byte[] addrByte = new byte[BD_ADDR_LEN];
                    for (int j = 0; j < number; j++) {
                        System.arraycopy(val, j * BD_ADDR_LEN, addrByte, 0, BD_ADDR_LEN);
                        onBondStateChanged(mAdapter.getRemoteDevice(Utils.getAddressStringFromByte(addrByte)), BluetoothDevice.BOND_BONDED);
                    }
                    break;
                case AbstractionLayer.BT_PROPERTY_ADAPTER_DISCOVERABLE_TIMEOUT:
                    mDiscoverableTimeout = Utils.byteArrayToInt(val, 0);
                    debugLog("Discoverable Timeout:" + mDiscoverableTimeout);
                    break;
                case AbstractionLayer.BT_PROPERTY_LOCAL_LE_FEATURES:
                    updateFeatureSupport(val);
                    break;
                default:
                    errorLog("Property change not handled in Java land:" + type);
            }
        }
    }
}
#end_block

#method_before
public static void doTest() throws Exception {
    Method say_hi_method = Transform.class.getDeclaredMethod("sayHi");
    // Test we will autobind normally.
    Transform.sayHi2();
    // Test we can get in the middle of autobind
    setNativeTransform(say_hi_method, "NoReallySayGoodbye");
    Transform.sayHi();
    // Test we can get in between manual bind.
    setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2");
    Main.bindAgentJNIForClass(Transform.class);
    Transform.sayHi();
    // Test we can get rid of transform
    removeNativeTransform(say_hi_method);
    Main.bindAgentJNIForClass(Transform.class);
    Transform.sayHi();
    Main.bindAgentJNIForClass(Main.class);
    Main.bindAgentJNIForClass(Test986.class);
}
#method_after
public static void doTest() throws Exception {
    Method say_hi_method = Transform.class.getDeclaredMethod("sayHi");
    // Test we will bind fine if we make no changes.
    Transform.sayHi2();
    // Test we can get in the middle of autobind
    setNativeTransform(say_hi_method, "NoReallySayGoodbye");
    Transform.sayHi();
    // Test we can get in between manual bind.
    setNativeTransform(say_hi_method, "Java_art_Test986_00024Transform_sayHi2");
    rebindTransformClass();
    Transform.sayHi();
    // Test we can get rid of transform
    removeNativeTransform(say_hi_method);
    rebindTransformClass();
    Transform.sayHi();
}
#end_block

#method_before
private void mapIconSets() {
    mNetworkToIconLookup.clear();
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
    if (!mConfig.showAtLeast3G) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.UNKNOWN);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
        mDefaultIcons = TelephonyIcons.G;
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.THREE_G);
        mDefaultIcons = TelephonyIcons.THREE_G;
    }
    MobileIconGroup hGroup = TelephonyIcons.THREE_G;
    if (mConfig.hspaDataDistinguishable) {
        hGroup = TelephonyIcons.H;
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
    if (mConfig.show4gForLte) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
}
#method_after
private void mapIconSets() {
    mNetworkToIconLookup.clear();
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_0, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_A, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EVDO_B, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EHRPD, TelephonyIcons.THREE_G);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UMTS, TelephonyIcons.THREE_G);
    if (!mConfig.showAtLeast3G) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.UNKNOWN);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.E);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.ONE_X);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.ONE_X);
        mDefaultIcons = TelephonyIcons.G;
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_UNKNOWN, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_EDGE, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_CDMA, TelephonyIcons.THREE_G);
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_1xRTT, TelephonyIcons.THREE_G);
        mDefaultIcons = TelephonyIcons.THREE_G;
    }
    MobileIconGroup hGroup = TelephonyIcons.THREE_G;
    if (mConfig.hspaDataDistinguishable) {
        hGroup = TelephonyIcons.H;
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSDPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSUPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPA, hGroup);
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_HSPAP, hGroup);
    if (mConfig.show4gForLte) {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.FOUR_G_PLUS);
        }
    } else {
        mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);
        if (mConfig.hideLtePlus) {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE);
        } else {
            mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE_CA, TelephonyIcons.LTE_PLUS);
        }
    }
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_IWLAN, TelephonyIcons.WFC);
}
#end_block

#method_before
@Override
public void notifyListeners(SignalCallback callback) {
    MobileIconGroup icons = getIcons();
    String contentDescription = getStringIfExists(getContentDescription());
    String dataContentDescription = getStringIfExists(icons.mDataContentDescription);
    final boolean dataDisabled = isDataDisabled() && mCurrentState.userSetup;
    // Show icon in QS when we are connected or need to show roaming or data is disabled.
    boolean showDataIcon = mCurrentState.dataConnected || mCurrentState.iconGroup == TelephonyIcons.ROAMING || dataDisabled;
    IconState statusIcon = new IconState(mCurrentState.enabled && !mCurrentState.airplaneMode, getCurrentIconId(), contentDescription);
    int qsTypeIcon = 0;
    IconState qsIcon = null;
    String description = null;
    // Only send data sim callbacks to QS.
    if (mCurrentState.dataSim) {
        qsTypeIcon = showDataIcon ? icons.mQsDataType : 0;
        qsIcon = new IconState(mCurrentState.enabled && !mCurrentState.isEmergency, getQsCurrentIconId(), contentDescription);
        description = mCurrentState.isEmergency ? null : mCurrentState.networkName;
    }
    boolean activityIn = mCurrentState.dataConnected && !mCurrentState.carrierNetworkChangeMode && mCurrentState.activityIn;
    boolean activityOut = mCurrentState.dataConnected && !mCurrentState.carrierNetworkChangeMode && mCurrentState.activityOut;
    showDataIcon &= mCurrentState.isDefault || mCurrentState.iconGroup == TelephonyIcons.ROAMING || dataDisabled;
    int typeIcon = showDataIcon ? icons.mDataType : 0;
    callback.setMobileDataIndicators(statusIcon, qsIcon, typeIcon, qsTypeIcon, activityIn, activityOut, dataContentDescription, description, icons.mIsWide, mSubscriptionInfo.getSubscriptionId());
}
#method_after
@Override
public void notifyListeners(SignalCallback callback) {
    MobileIconGroup icons = getIcons();
    String contentDescription = getStringIfExists(getContentDescription());
    String dataContentDescription = getStringIfExists(icons.mDataContentDescription);
    final boolean dataDisabled = isDataDisabled() && mCurrentState.userSetup;
    // Show icon in QS when we are connected or data is disabled.
    boolean showDataIcon = mCurrentState.dataConnected || dataDisabled;
    IconState statusIcon = new IconState(mCurrentState.enabled && !mCurrentState.airplaneMode, getCurrentIconId(), contentDescription);
    int qsTypeIcon = 0;
    IconState qsIcon = null;
    String description = null;
    // Only send data sim callbacks to QS.
    if (mCurrentState.dataSim) {
        qsTypeIcon = showDataIcon ? icons.mQsDataType : 0;
        qsIcon = new IconState(mCurrentState.enabled && !mCurrentState.isEmergency, getQsCurrentIconId(), contentDescription);
        description = mCurrentState.isEmergency ? null : mCurrentState.networkName;
    }
    boolean activityIn = mCurrentState.dataConnected && !mCurrentState.carrierNetworkChangeMode && mCurrentState.activityIn;
    boolean activityOut = mCurrentState.dataConnected && !mCurrentState.carrierNetworkChangeMode && mCurrentState.activityOut;
    showDataIcon &= mCurrentState.isDefault || dataDisabled;
    int typeIcon = showDataIcon ? icons.mDataType : 0;
    callback.setMobileDataIndicators(statusIcon, qsIcon, typeIcon, qsTypeIcon, activityIn, activityOut, dataContentDescription, description, icons.mIsWide, mSubscriptionInfo.getSubscriptionId(), mCurrentState.roaming);
}
#end_block

#method_before
private final void updateTelephony() {
    if (DEBUG) {
        Log.d(mTag, "updateTelephonySignalStrength: hasService=" + hasService() + " ss=" + mSignalStrength);
    }
    mCurrentState.connected = hasService() && mSignalStrength != null;
    if (mCurrentState.connected) {
        if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
            mCurrentState.level = mSignalStrength.getCdmaLevel();
        } else {
            mCurrentState.level = mSignalStrength.getLevel();
        }
    }
    if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
        mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
    } else {
        mCurrentState.iconGroup = mDefaultIcons;
    }
    mCurrentState.dataConnected = mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
    if (isCarrierNetworkChangeActive()) {
        mCurrentState.iconGroup = TelephonyIcons.CARRIER_NETWORK_CHANGE;
    } else if (isRoaming()) {
        mCurrentState.iconGroup = TelephonyIcons.ROAMING;
    } else if (isDataDisabled() && !mConfig.alwaysShowDataIcon) {
        mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
    }
    if (isEmergencyOnly() != mCurrentState.isEmergency) {
        mCurrentState.isEmergency = isEmergencyOnly();
        mNetworkController.recalculateEmergency();
    }
    // Fill in the network name if we think we have it.
    if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
        mCurrentState.networkName = mServiceState.getOperatorAlphaShort();
    }
    notifyListenersIfNecessary();
}
#method_after
private final void updateTelephony() {
    if (DEBUG) {
        Log.d(mTag, "updateTelephonySignalStrength: hasService=" + hasService() + " ss=" + mSignalStrength);
    }
    mCurrentState.connected = hasService() && mSignalStrength != null;
    if (mCurrentState.connected) {
        if (!mSignalStrength.isGsm() && mConfig.alwaysShowCdmaRssi) {
            mCurrentState.level = mSignalStrength.getCdmaLevel();
        } else {
            mCurrentState.level = mSignalStrength.getLevel();
        }
    }
    if (mNetworkToIconLookup.indexOfKey(mDataNetType) >= 0) {
        mCurrentState.iconGroup = mNetworkToIconLookup.get(mDataNetType);
    } else {
        mCurrentState.iconGroup = mDefaultIcons;
    }
    mCurrentState.dataConnected = mCurrentState.connected && mDataState == TelephonyManager.DATA_CONNECTED;
    mCurrentState.roaming = isRoaming();
    if (isCarrierNetworkChangeActive()) {
        mCurrentState.iconGroup = TelephonyIcons.CARRIER_NETWORK_CHANGE;
    } else if (isDataDisabled() && !mConfig.alwaysShowDataRatIcon) {
        mCurrentState.iconGroup = TelephonyIcons.DATA_DISABLED;
    }
    if (isEmergencyOnly() != mCurrentState.isEmergency) {
        mCurrentState.isEmergency = isEmergencyOnly();
        mNetworkController.recalculateEmergency();
    }
    // Fill in the network name if we think we have it.
    if (mCurrentState.networkName == mNetworkNameDefault && mServiceState != null && !TextUtils.isEmpty(mServiceState.getOperatorAlphaShort())) {
        mCurrentState.networkName = mServiceState.getOperatorAlphaShort();
    }
    notifyListenersIfNecessary();
}
#end_block

#method_before
@Override
public void onServiceStateChanged(ServiceState state) {
    if (DEBUG) {
        Log.d(mTag, "onServiceStateChanged voiceState=" + state.getVoiceRegState() + " dataState=" + state.getDataRegState());
    }
    mServiceState = state;
    mDataNetType = state.getDataNetworkType();
    updateTelephony();
}
#method_after
@Override
public void onServiceStateChanged(ServiceState state) {
    if (DEBUG) {
        Log.d(mTag, "onServiceStateChanged voiceState=" + state.getVoiceRegState() + " dataState=" + state.getDataRegState());
    }
    mServiceState = state;
    mDataNetType = state.getDataNetworkType();
    if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null && mServiceState.isUsingCarrierAggregation()) {
        mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
    }
    updateTelephony();
}
#end_block

#method_before
@Override
public void onDataConnectionStateChanged(int state, int networkType) {
    if (DEBUG) {
        Log.d(mTag, "onDataConnectionStateChanged: state=" + state + " type=" + networkType);
    }
    mDataState = state;
    mDataNetType = networkType;
    updateTelephony();
}
#method_after
@Override
public void onDataConnectionStateChanged(int state, int networkType) {
    if (DEBUG) {
        Log.d(mTag, "onDataConnectionStateChanged: state=" + state + " type=" + networkType);
    }
    mDataState = state;
    mDataNetType = networkType;
    if (mDataNetType == TelephonyManager.NETWORK_TYPE_LTE && mServiceState != null && mServiceState.isUsingCarrierAggregation()) {
        mDataNetType = TelephonyManager.NETWORK_TYPE_LTE_CA;
    }
    updateTelephony();
}
#end_block

#method_before
@Override
public void copyFrom(State s) {
    super.copyFrom(s);
    MobileState state = (MobileState) s;
    dataSim = state.dataSim;
    networkName = state.networkName;
    networkNameData = state.networkNameData;
    dataConnected = state.dataConnected;
    isDefault = state.isDefault;
    isEmergency = state.isEmergency;
    airplaneMode = state.airplaneMode;
    carrierNetworkChangeMode = state.carrierNetworkChangeMode;
    userSetup = state.userSetup;
}
#method_after
@Override
public void copyFrom(State s) {
    super.copyFrom(s);
    MobileState state = (MobileState) s;
    dataSim = state.dataSim;
    networkName = state.networkName;
    networkNameData = state.networkNameData;
    dataConnected = state.dataConnected;
    isDefault = state.isDefault;
    isEmergency = state.isEmergency;
    airplaneMode = state.airplaneMode;
    carrierNetworkChangeMode = state.carrierNetworkChangeMode;
    userSetup = state.userSetup;
    roaming = state.roaming;
}
#end_block

#method_before
@Override
protected void toString(StringBuilder builder) {
    super.toString(builder);
    builder.append(',');
    builder.append("dataSim=").append(dataSim).append(',');
    builder.append("networkName=").append(networkName).append(',');
    builder.append("networkNameData=").append(networkNameData).append(',');
    builder.append("dataConnected=").append(dataConnected).append(',');
    builder.append("isDefault=").append(isDefault).append(',');
    builder.append("isEmergency=").append(isEmergency).append(',');
    builder.append("airplaneMode=").append(airplaneMode).append(',');
    builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode).append(',');
    builder.append("userSetup=").append(userSetup);
}
#method_after
@Override
protected void toString(StringBuilder builder) {
    super.toString(builder);
    builder.append(',');
    builder.append("dataSim=").append(dataSim).append(',');
    builder.append("networkName=").append(networkName).append(',');
    builder.append("networkNameData=").append(networkNameData).append(',');
    builder.append("dataConnected=").append(dataConnected).append(',');
    builder.append("roaming=").append(roaming).append(',');
    builder.append("isDefault=").append(isDefault).append(',');
    builder.append("isEmergency=").append(isEmergency).append(',');
    builder.append("airplaneMode=").append(airplaneMode).append(',');
    builder.append("carrierNetworkChangeMode=").append(carrierNetworkChangeMode).append(',');
    builder.append("userSetup=").append(userSetup);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return super.equals(o) && Objects.equals(((MobileState) o).networkName, networkName) && Objects.equals(((MobileState) o).networkNameData, networkNameData) && ((MobileState) o).dataSim == dataSim && ((MobileState) o).dataConnected == dataConnected && ((MobileState) o).isEmergency == isEmergency && ((MobileState) o).airplaneMode == airplaneMode && ((MobileState) o).carrierNetworkChangeMode == carrierNetworkChangeMode && ((MobileState) o).userSetup == userSetup && ((MobileState) o).isDefault == isDefault;
}
#method_after
@Override
public boolean equals(Object o) {
    return super.equals(o) && Objects.equals(((MobileState) o).networkName, networkName) && Objects.equals(((MobileState) o).networkNameData, networkNameData) && ((MobileState) o).dataSim == dataSim && ((MobileState) o).dataConnected == dataConnected && ((MobileState) o).isEmergency == isEmergency && ((MobileState) o).airplaneMode == airplaneMode && ((MobileState) o).carrierNetworkChangeMode == carrierNetworkChangeMode && ((MobileState) o).userSetup == userSetup && ((MobileState) o).isDefault == isDefault && ((MobileState) o).roaming == roaming;
}
#end_block

#method_before
private void registerListeners() {
    for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
        mobileSignalController.registerListener();
    }
    if (mSubscriptionListener == null) {
        mSubscriptionListener = new SubListener();
    }
    mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionListener);
    // broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
    filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
    filter.addAction(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
    filter.addAction(ConnectivityManager.INET_CONDITION_ACTION);
    filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
    mContext.registerReceiver(this, filter, null, mReceiverHandler);
    mListening = true;
    updateMobileControllers();
}
#method_after
private void registerListeners() {
    for (MobileSignalController mobileSignalController : mMobileSignalControllers.values()) {
        mobileSignalController.registerListener();
    }
    if (mSubscriptionListener == null) {
        mSubscriptionListener = new SubListener();
    }
    mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionListener);
    // broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
    filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
    filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
    filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED);
    filter.addAction(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED);
    filter.addAction(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
    filter.addAction(ConnectivityManager.INET_CONDITION_ACTION);
    filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
    filter.addAction(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
    mContext.registerReceiver(this, filter, null, mReceiverHandler);
    mListening = true;
    updateMobileControllers();
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (CHATTY) {
        Log.d(TAG, "onReceive: intent=" + intent);
    }
    final String action = intent.getAction();
    if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        updateConnectivity();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        refreshLocale();
        updateAirplaneMode(false);
    } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED)) {
        // We are using different subs now, we might be able to make calls.
        recalculateEmergency();
    } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
        // data sim or not.
        for (MobileSignalController controller : mMobileSignalControllers.values()) {
            controller.handleBroadcast(intent);
        }
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        // Might have different subscriptions now.
        updateMobileControllers();
    } else if (action.equals(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED)) {
        mLastServiceState = ServiceState.newFromBundle(intent.getExtras());
        if (mMobileSignalControllers.size() == 0) {
            // If none of the subscriptions are active, we might need to recalculate
            // emergency state.
            recalculateEmergency();
        }
    } else {
        int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            if (mMobileSignalControllers.containsKey(subId)) {
                mMobileSignalControllers.get(subId).handleBroadcast(intent);
            } else {
                // Can't find this subscription...  We must be out of date.
                updateMobileControllers();
            }
        } else {
            // No sub id, must be for the wifi.
            mWifiSignalController.handleBroadcast(intent);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (CHATTY) {
        Log.d(TAG, "onReceive: intent=" + intent);
    }
    final String action = intent.getAction();
    if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION) || action.equals(ConnectivityManager.INET_CONDITION_ACTION)) {
        updateConnectivity();
    } else if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
        refreshLocale();
        updateAirplaneMode(false);
    } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED)) {
        // We are using different subs now, we might be able to make calls.
        recalculateEmergency();
    } else if (action.equals(TelephonyIntents.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED)) {
        // data sim or not.
        for (MobileSignalController controller : mMobileSignalControllers.values()) {
            controller.handleBroadcast(intent);
        }
    } else if (action.equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
        // Might have different subscriptions now.
        updateMobileControllers();
    } else if (action.equals(TelephonyIntents.ACTION_SERVICE_STATE_CHANGED)) {
        mLastServiceState = ServiceState.newFromBundle(intent.getExtras());
        if (mMobileSignalControllers.size() == 0) {
            // If none of the subscriptions are active, we might need to recalculate
            // emergency state.
            recalculateEmergency();
        }
    } else if (action.equals(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED)) {
        mConfig = Config.readConfig(mContext);
        mReceiverHandler.post(new Runnable() {

            @Override
            public void run() {
                handleConfigurationChanged();
            }
        });
    } else {
        int subId = intent.getIntExtra(PhoneConstants.SUBSCRIPTION_KEY, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            if (mMobileSignalControllers.containsKey(subId)) {
                mMobileSignalControllers.get(subId).handleBroadcast(intent);
            } else {
                // Can't find this subscription...  We must be out of date.
                updateMobileControllers();
            }
        } else {
            // No sub id, must be for the wifi.
            mWifiSignalController.handleBroadcast(intent);
        }
    }
}
#end_block

#method_before
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoMode && command.equals(COMMAND_ENTER)) {
        if (DEBUG)
            Log.d(TAG, "Entering demo mode");
        unregisterListeners();
        mDemoMode = true;
        mDemoInetCondition = mInetCondition;
        mDemoWifiState = mWifiSignalController.getState();
    } else if (mDemoMode && command.equals(COMMAND_EXIT)) {
        if (DEBUG)
            Log.d(TAG, "Exiting demo mode");
        mDemoMode = false;
        // Update what MobileSignalControllers, because they may change
        // to set the number of sim slots.
        updateMobileControllers();
        for (MobileSignalController controller : mMobileSignalControllers.values()) {
            controller.resetLastState();
        }
        mWifiSignalController.resetLastState();
        mReceiverHandler.post(mRegisterListeners);
        notifyAllListeners();
    } else if (mDemoMode && command.equals(COMMAND_NETWORK)) {
        String airplane = args.getString("airplane");
        if (airplane != null) {
            boolean show = airplane.equals("show");
            mCallbackHandler.setIsAirplaneMode(new IconState(show, TelephonyIcons.FLIGHT_MODE_ICON, R.string.accessibility_airplane_mode, mContext));
        }
        String fully = args.getString("fully");
        if (fully != null) {
            mDemoInetCondition = Boolean.parseBoolean(fully);
            BitSet connected = new BitSet();
            if (mDemoInetCondition) {
                connected.set(mWifiSignalController.mTransportType);
            }
            mWifiSignalController.updateConnectivity(connected, connected);
            for (MobileSignalController controller : mMobileSignalControllers.values()) {
                if (mDemoInetCondition) {
                    connected.set(controller.mTransportType);
                }
                controller.updateConnectivity(connected, connected);
            }
        }
        String wifi = args.getString("wifi");
        if (wifi != null) {
            boolean show = wifi.equals("show");
            String level = args.getString("level");
            if (level != null) {
                mDemoWifiState.level = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), WifiIcons.WIFI_LEVEL_COUNT - 1);
                mDemoWifiState.connected = mDemoWifiState.level >= 0;
            }
            mDemoWifiState.enabled = show;
            mWifiSignalController.notifyListeners();
        }
        String sims = args.getString("sims");
        if (sims != null) {
            int num = MathUtils.constrain(Integer.parseInt(sims), 1, 8);
            List<SubscriptionInfo> subs = new ArrayList<>();
            if (num != mMobileSignalControllers.size()) {
                mMobileSignalControllers.clear();
                int start = mSubscriptionManager.getActiveSubscriptionInfoCountMax();
                for (int i = start; /* get out of normal index range */
                i < start + num; i++) {
                    subs.add(addSignalController(i, i));
                }
                mCallbackHandler.setSubs(subs);
            }
        }
        String nosim = args.getString("nosim");
        if (nosim != null) {
            mHasNoSims = nosim.equals("show");
            mCallbackHandler.setNoSims(mHasNoSims);
        }
        String mobile = args.getString("mobile");
        if (mobile != null) {
            boolean show = mobile.equals("show");
            String datatype = args.getString("datatype");
            String slotString = args.getString("slot");
            int slot = TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
            slot = MathUtils.constrain(slot, 0, 8);
            // Ensure we have enough sim slots
            List<SubscriptionInfo> subs = new ArrayList<>();
            while (mMobileSignalControllers.size() <= slot) {
                int nextSlot = mMobileSignalControllers.size();
                subs.add(addSignalController(nextSlot, nextSlot));
            }
            if (!subs.isEmpty()) {
                mCallbackHandler.setSubs(subs);
            }
            // Hack to index linearly for easy use.
            MobileSignalController controller = mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
            controller.getState().dataSim = datatype != null;
            if (datatype != null) {
                controller.getState().iconGroup = datatype.equals("1x") ? TelephonyIcons.ONE_X : datatype.equals("3g") ? TelephonyIcons.THREE_G : datatype.equals("4g") ? TelephonyIcons.FOUR_G : datatype.equals("e") ? TelephonyIcons.E : datatype.equals("g") ? TelephonyIcons.G : datatype.equals("h") ? TelephonyIcons.H : datatype.equals("lte") ? TelephonyIcons.LTE : datatype.equals("roam") ? TelephonyIcons.ROAMING : TelephonyIcons.UNKNOWN;
            }
            int[][] icons = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
            String level = args.getString("level");
            if (level != null) {
                controller.getState().level = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), icons[0].length - 1);
                controller.getState().connected = controller.getState().level >= 0;
            }
            controller.getState().enabled = show;
            controller.notifyListeners();
        }
        String carrierNetworkChange = args.getString("carriernetworkchange");
        if (carrierNetworkChange != null) {
            boolean show = carrierNetworkChange.equals("show");
            for (MobileSignalController controller : mMobileSignalControllers.values()) {
                controller.setCarrierNetworkChangeMode(show);
            }
        }
    }
}
#method_after
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoMode && command.equals(COMMAND_ENTER)) {
        if (DEBUG)
            Log.d(TAG, "Entering demo mode");
        unregisterListeners();
        mDemoMode = true;
        mDemoInetCondition = mInetCondition;
        mDemoWifiState = mWifiSignalController.getState();
        mDemoWifiState.ssid = "DemoMode";
    } else if (mDemoMode && command.equals(COMMAND_EXIT)) {
        if (DEBUG)
            Log.d(TAG, "Exiting demo mode");
        mDemoMode = false;
        // Update what MobileSignalControllers, because they may change
        // to set the number of sim slots.
        updateMobileControllers();
        for (MobileSignalController controller : mMobileSignalControllers.values()) {
            controller.resetLastState();
        }
        mWifiSignalController.resetLastState();
        mReceiverHandler.post(mRegisterListeners);
        notifyAllListeners();
    } else if (mDemoMode && command.equals(COMMAND_NETWORK)) {
        String airplane = args.getString("airplane");
        if (airplane != null) {
            boolean show = airplane.equals("show");
            mCallbackHandler.setIsAirplaneMode(new IconState(show, TelephonyIcons.FLIGHT_MODE_ICON, R.string.accessibility_airplane_mode, mContext));
        }
        String fully = args.getString("fully");
        if (fully != null) {
            mDemoInetCondition = Boolean.parseBoolean(fully);
            BitSet connected = new BitSet();
            if (mDemoInetCondition) {
                connected.set(mWifiSignalController.mTransportType);
            }
            mWifiSignalController.updateConnectivity(connected, connected);
            for (MobileSignalController controller : mMobileSignalControllers.values()) {
                if (mDemoInetCondition) {
                    connected.set(controller.mTransportType);
                }
                controller.updateConnectivity(connected, connected);
            }
        }
        String wifi = args.getString("wifi");
        if (wifi != null) {
            boolean show = wifi.equals("show");
            String level = args.getString("level");
            if (level != null) {
                mDemoWifiState.level = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), WifiIcons.WIFI_LEVEL_COUNT - 1);
                mDemoWifiState.connected = mDemoWifiState.level >= 0;
            }
            String activity = args.getString("activity");
            if (activity != null) {
                switch(activity) {
                    case "inout":
                        mWifiSignalController.setActivity(WifiManager.DATA_ACTIVITY_INOUT);
                        break;
                    case "in":
                        mWifiSignalController.setActivity(WifiManager.DATA_ACTIVITY_IN);
                        break;
                    case "out":
                        mWifiSignalController.setActivity(WifiManager.DATA_ACTIVITY_OUT);
                        break;
                    default:
                        mWifiSignalController.setActivity(WifiManager.DATA_ACTIVITY_NONE);
                        break;
                }
            } else {
                mWifiSignalController.setActivity(WifiManager.DATA_ACTIVITY_NONE);
            }
            mDemoWifiState.enabled = show;
            mWifiSignalController.notifyListeners();
        }
        String sims = args.getString("sims");
        if (sims != null) {
            int num = MathUtils.constrain(Integer.parseInt(sims), 1, 8);
            List<SubscriptionInfo> subs = new ArrayList<>();
            if (num != mMobileSignalControllers.size()) {
                mMobileSignalControllers.clear();
                int start = mSubscriptionManager.getActiveSubscriptionInfoCountMax();
                for (int i = start; /* get out of normal index range */
                i < start + num; i++) {
                    subs.add(addSignalController(i, i));
                }
                mCallbackHandler.setSubs(subs);
            }
        }
        String nosim = args.getString("nosim");
        if (nosim != null) {
            mHasNoSims = nosim.equals("show");
            mCallbackHandler.setNoSims(mHasNoSims);
        }
        String mobile = args.getString("mobile");
        if (mobile != null) {
            boolean show = mobile.equals("show");
            String datatype = args.getString("datatype");
            String slotString = args.getString("slot");
            int slot = TextUtils.isEmpty(slotString) ? 0 : Integer.parseInt(slotString);
            slot = MathUtils.constrain(slot, 0, 8);
            // Ensure we have enough sim slots
            List<SubscriptionInfo> subs = new ArrayList<>();
            while (mMobileSignalControllers.size() <= slot) {
                int nextSlot = mMobileSignalControllers.size();
                subs.add(addSignalController(nextSlot, nextSlot));
            }
            if (!subs.isEmpty()) {
                mCallbackHandler.setSubs(subs);
            }
            // Hack to index linearly for easy use.
            MobileSignalController controller = mMobileSignalControllers.values().toArray(new MobileSignalController[0])[slot];
            controller.getState().dataSim = datatype != null;
            if (datatype != null) {
                controller.getState().iconGroup = datatype.equals("1x") ? TelephonyIcons.ONE_X : datatype.equals("3g") ? TelephonyIcons.THREE_G : datatype.equals("4g") ? TelephonyIcons.FOUR_G : datatype.equals("4g+") ? TelephonyIcons.FOUR_G_PLUS : datatype.equals("e") ? TelephonyIcons.E : datatype.equals("g") ? TelephonyIcons.G : datatype.equals("h") ? TelephonyIcons.H : datatype.equals("lte") ? TelephonyIcons.LTE : datatype.equals("lte+") ? TelephonyIcons.LTE_PLUS : TelephonyIcons.UNKNOWN;
            }
            if (args.containsKey("roam")) {
                controller.getState().roaming = "show".equals(args.getString("roam"));
            }
            int[][] icons = TelephonyIcons.TELEPHONY_SIGNAL_STRENGTH;
            String level = args.getString("level");
            if (level != null) {
                controller.getState().level = level.equals("null") ? -1 : Math.min(Integer.parseInt(level), icons[0].length - 1);
                controller.getState().connected = controller.getState().level >= 0;
            }
            String activity = args.getString("activity");
            if (activity != null) {
                controller.getState().dataConnected = true;
                switch(activity) {
                    case "inout":
                        controller.setActivity(TelephonyManager.DATA_ACTIVITY_INOUT);
                        break;
                    case "in":
                        controller.setActivity(TelephonyManager.DATA_ACTIVITY_IN);
                        break;
                    case "out":
                        controller.setActivity(TelephonyManager.DATA_ACTIVITY_OUT);
                        break;
                    default:
                        controller.setActivity(TelephonyManager.DATA_ACTIVITY_NONE);
                        break;
                }
            } else {
                controller.setActivity(TelephonyManager.DATA_ACTIVITY_NONE);
            }
            controller.getState().enabled = show;
            controller.notifyListeners();
        }
        String carrierNetworkChange = args.getString("carriernetworkchange");
        if (carrierNetworkChange != null) {
            boolean show = carrierNetworkChange.equals("show");
            for (MobileSignalController controller : mMobileSignalControllers.values()) {
                controller.setCarrierNetworkChangeMode(show);
            }
        }
    }
}
#end_block

#method_before
private SubscriptionInfo addSignalController(int id, int simSlotIndex) {
    SubscriptionInfo info = new SubscriptionInfo(id, "", simSlotIndex, "", "", 0, 0, "", 0, null, 0, 0, "", SubscriptionManager.SIM_PROVISIONED);
    mMobileSignalControllers.put(id, new MobileSignalController(mContext, mConfig, mHasMobileDataFeature, mPhone, mCallbackHandler, this, info, mSubDefaults, mReceiverHandler.getLooper()));
    return info;
}
#method_after
private SubscriptionInfo addSignalController(int id, int simSlotIndex) {
    SubscriptionInfo info = new SubscriptionInfo(id, "", simSlotIndex, "", "", 0, 0, "", 0, null, 0, 0, "");
    mMobileSignalControllers.put(id, new MobileSignalController(mContext, mConfig, mHasMobileDataFeature, mPhone, mCallbackHandler, this, info, mSubDefaults, mReceiverHandler.getLooper()));
    return info;
}
#end_block

#method_before
static Config readConfig(Context context) {
    Config config = new Config();
    Resources res = context.getResources();
    config.showAtLeast3G = res.getBoolean(R.bool.config_showMin3G);
    config.alwaysShowCdmaRssi = res.getBoolean(com.android.internal.R.bool.config_alwaysUseCdmaRssi);
    config.show4gForLte = res.getBoolean(R.bool.config_show4GForLTE);
    config.hspaDataDistinguishable = res.getBoolean(R.bool.config_hspa_data_distinguishable);
    CarrierConfigManager configMgr = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configMgr.getConfigForSubId(SubscriptionManager.getDefaultDataSubscriptionId());
    if (b != null) {
        config.alwaysShowDataIcon = b.getBoolean(CarrierConfigManager.KEY_ALWAYS_SHOW_DATA_ICON_BOOL);
    }
    return config;
}
#method_after
static Config readConfig(Context context) {
    Config config = new Config();
    Resources res = context.getResources();
    config.showAtLeast3G = res.getBoolean(R.bool.config_showMin3G);
    config.alwaysShowCdmaRssi = res.getBoolean(com.android.internal.R.bool.config_alwaysUseCdmaRssi);
    config.show4gForLte = res.getBoolean(R.bool.config_show4GForLTE);
    config.hspaDataDistinguishable = res.getBoolean(R.bool.config_hspa_data_distinguishable);
    config.hideLtePlus = res.getBoolean(R.bool.config_hideLtePlus);
    CarrierConfigManager configMgr = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    PersistableBundle b = configMgr.getConfig();
    if (b != null) {
        config.alwaysShowDataRatIcon = b.getBoolean(CarrierConfigManager.KEY_ALWAYS_SHOW_DATA_RAT_ICON_BOOL);
    }
    return config;
}
#end_block

#method_before
public static void main(String[] args) {
    System.loadLibrary(args[0]);
    testGetFieldId(TestClass.class, "intField", "I");
    testGetFieldId(TestClass.class, "intField", "int");
    testGetFieldId(TestClass.class, "intField", "Lint;");
    testGetFieldId(TestClass.class, "stringField", "I");
    testGetFieldId(TestClass.class, "stringField", "Ljava/lang/String;");
    testGetFieldId(TestClass.class, "stringField", "java/lang/String");
    testGetFieldId(TestClass.class, "stringField", "Ljava.lang.String;");
    testGetFieldId(TestClass.class, "stringField", "java.lang.String");
}
#method_after
public static void main(String[] args) {
    System.loadLibrary(args[0]);
    testGetFieldId(TestClass.class, "intField", "I");
    testGetFieldId(TestClass.class, "intField", "int");
    testGetFieldId(TestClass.class, "intField", "Lint;");
    testGetFieldId(TestClass.class, "stringField", "I");
    testGetFieldId(TestClass.class, "stringField", "Ljava/lang/String;");
    testGetFieldId(TestClass.class, "stringField", "java/lang/String");
    testGetFieldId(TestClass.class, "stringField", "Ljava.lang.String;");
    testGetFieldId(TestClass.class, "stringField", "java.lang.String");
    try {
        Method get = Main.class.getDeclaredMethod("getFieldId", Class.class, String.class, String.class);
        MyClassLoader loader = new MyClassLoader(Main.class.getClassLoader());
        Class<?> otherMain = Class.forName("Main", true, loader);
        Method m = otherMain.getDeclaredMethod("testClassLoading", Method.class);
        m.invoke(null, get);
    } catch (Throwable t) {
        t.printStackTrace(System.out);
    }
}
#end_block

#method_before
public static final void enforceTetherChangePermission(Context context) {
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteWriteSettingsOperation(context, uid, Settings.getPackageNameForUid(context, uid), true);
    }
}
#method_after
public static final void enforceTetherChangePermission(Context context, String callingPkg) {
    if (null == context || null == callingPkg) {
        throw new IllegalArgumentException("arguments should not be null");
    }
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        // If callingPkg's uid is not same as Binder.getCallingUid(),
        // AppOpsService throws SecurityException.
        Settings.checkAndNoteWriteSettingsOperation(context, uid, callingPkg, true);
    }
}
#end_block

#method_before
public int tether(String iface) {
    try {
        return mService.tether(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int tether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "tether caller:" + pkgName);
        return mService.tether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int untether(String iface) {
    try {
        return mService.untether(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int untether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "untether caller:" + pkgName);
        return mService.untether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@SystemApi
public void startTethering(int type, boolean showProvisioningUi, final OnStartTetheringCallback callback, Handler handler) {
    Preconditions.checkNotNull(callback, "OnStartTetheringCallback cannot be null.");
    ResultReceiver wrappedCallback = new ResultReceiver(handler) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                callback.onTetheringStarted();
            } else {
                callback.onTetheringFailed();
            }
        }
    };
    try {
        mService.startTethering(type, wrappedCallback, showProvisioningUi);
    } catch (RemoteException e) {
        Log.e(TAG, "Exception trying to start tethering.", e);
        wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, null);
    }
}
#method_after
@SystemApi
public void startTethering(int type, boolean showProvisioningUi, final OnStartTetheringCallback callback, Handler handler) {
    Preconditions.checkNotNull(callback, "OnStartTetheringCallback cannot be null.");
    ResultReceiver wrappedCallback = new ResultReceiver(handler) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                callback.onTetheringStarted();
            } else {
                callback.onTetheringFailed();
            }
        }
    };
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "startTethering caller:" + pkgName);
        mService.startTethering(type, wrappedCallback, showProvisioningUi, pkgName);
    } catch (RemoteException e) {
        Log.e(TAG, "Exception trying to start tethering.", e);
        wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, null);
    }
}
#end_block

#method_before
@SystemApi
public void stopTethering(int type) {
    try {
        mService.stopTethering(type);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@SystemApi
public void stopTethering(int type) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "stopTethering caller:" + pkgName);
        mService.stopTethering(type, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    try {
        return mService.setUsbTethering(enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int setUsbTethering(boolean enable) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "setUsbTethering caller:" + pkgName);
        return mService.setUsbTethering(enable, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message message) {
    NetworkRequest request = getObject(message, NetworkRequest.class);
    Network network = getObject(message, Network.class);
    if (DBG) {
        Log.d(TAG, whatToString(message.what) + " for network " + network);
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                NetworkCallback callback = getCallback(request, "PRECHECK");
                if (callback != null) {
                    callback.onPreCheck(network);
                }
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCallback callback = getCallback(request, "AVAILABLE");
                if (callback != null) {
                    callback.onAvailable(network);
                }
                break;
            }
        case CALLBACK_LOSING:
            {
                NetworkCallback callback = getCallback(request, "LOSING");
                if (callback != null) {
                    callback.onLosing(network, message.arg1);
                }
                break;
            }
        case CALLBACK_LOST:
            {
                NetworkCallback callback = getCallback(request, "LOST");
                if (callback != null) {
                    callback.onLost(network);
                }
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                NetworkCallback callback = getCallback(request, "UNAVAIL");
                if (callback != null) {
                    callback.onUnavailable();
                }
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCallback callback = getCallback(request, "CAP_CHANGED");
                if (callback != null) {
                    NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                    callback.onCapabilitiesChanged(network, cap);
                }
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                NetworkCallback callback = getCallback(request, "IP_CHANGED");
                if (callback != null) {
                    LinkProperties lp = getObject(message, LinkProperties.class);
                    callback.onLinkPropertiesChanged(network, lp);
                }
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                NetworkCallback callback = getCallback(request, "SUSPENDED");
                if (callback != null) {
                    callback.onNetworkSuspended(network);
                }
                break;
            }
        case CALLBACK_RESUMED:
            {
                NetworkCallback callback = getCallback(request, "RESUMED");
                if (callback != null) {
                    callback.onNetworkResumed(network);
                }
                break;
            }
        case CALLBACK_RELEASED:
            {
                break;
            }
        case CALLBACK_EXIT:
            {
                break;
            }
        case EXPIRE_LEGACY_REQUEST:
            {
                expireRequest((NetworkCapabilities) message.obj, message.arg1);
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message message) {
    NetworkRequest request = getObject(message, NetworkRequest.class);
    Network network = getObject(message, Network.class);
    if (DBG) {
        Log.d(TAG, getCallbackName(message.what) + " for network " + network);
    }
    switch(message.what) {
        case CALLBACK_PRECHECK:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onPreCheck(network);
                }
                break;
            }
        case CALLBACK_AVAILABLE:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onAvailable(network);
                }
                break;
            }
        case CALLBACK_LOSING:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onLosing(network, message.arg1);
                }
                break;
            }
        case CALLBACK_LOST:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onLost(network);
                }
                break;
            }
        case CALLBACK_UNAVAIL:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onUnavailable();
                }
                break;
            }
        case CALLBACK_CAP_CHANGED:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    NetworkCapabilities cap = getObject(message, NetworkCapabilities.class);
                    callback.onCapabilitiesChanged(network, cap);
                }
                break;
            }
        case CALLBACK_IP_CHANGED:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    LinkProperties lp = getObject(message, LinkProperties.class);
                    callback.onLinkPropertiesChanged(network, lp);
                }
                break;
            }
        case CALLBACK_SUSPENDED:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onNetworkSuspended(network);
                }
                break;
            }
        case CALLBACK_RESUMED:
            {
                NetworkCallback callback = getCallback(message);
                if (callback != null) {
                    callback.onNetworkResumed(network);
                }
                break;
            }
        case CALLBACK_RELEASED:
            {
                break;
            }
        case CALLBACK_EXIT:
            {
                break;
            }
        case EXPIRE_LEGACY_REQUEST:
            {
                expireRequest((NetworkCapabilities) message.obj, message.arg1);
                break;
            }
    }
}
#end_block

#method_before
private NetworkCallback getCallback(NetworkRequest req, String name) {
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(req);
    }
    if (callback == null) {
        Log.w(TAG, "callback not found for " + name + " message");
    }
    return callback;
}
#method_after
private NetworkCallback getCallback(Message msg) {
    final NetworkRequest req = getObject(msg, NetworkRequest.class);
    final NetworkCallback callback;
    synchronized (sCallbacks) {
        callback = sCallbacks.get(req);
    }
    if (callback == null) {
        Log.w(TAG, "callback not found for " + getCallbackName(msg.what) + " message");
    }
    return callback;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { "test_rmnet_data0", mTestIfname });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    mServiceContext = new MockContext(mContext);
    mIntents = new Vector<>();
    mServiceContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    }, new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { "test_rmnet_data0", mTestIfname });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    mServiceContext = new MockContext(mContext);
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties);
}
#end_block

#method_before
@Test
public void workingLocalOnlyHotspot() throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())).thenReturn(true);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // hotspot mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_LOCAL_HOTSPOT);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // Emulate externally-visible WifiManager effects, when hotspot mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#method_after
@Test
public void workingLocalOnlyHotspot() throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())).thenReturn(true);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // hotspot mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted();
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_LOCAL_ONLY);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // Emulate externally-visible WifiManager effects, when hotspot mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#end_block

#method_before
private void sendTetherStateChangedBroadcast() {
    if (!getConnectivityManager().isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<String>();
    final ArrayList<String> tetherList = new ArrayList<String>();
    final ArrayList<String> hotspotList = new ArrayList<String>();
    final ArrayList<String> erroredList = new ArrayList<String>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_HOTSPOT) {
                hotspotList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_LOCAL_HOTSPOT, hotspotList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_hotspot", TextUtils.join(",", hotspotList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
#method_after
private void sendTetherStateChangedBroadcast() {
    if (!getConnectivityManager().isTetheringSupported())
        return;
    final ArrayList<String> availableList = new ArrayList<>();
    final ArrayList<String> tetherList = new ArrayList<>();
    final ArrayList<String> localOnlyList = new ArrayList<>();
    final ArrayList<String> erroredList = new ArrayList<>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_LOCAL_HOTSPOT) {
                localOnlyList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                tetherList.add(iface);
            }
        }
    }
    final Intent bcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    bcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_LOCAL_ONLY, localOnlyList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, tetherList);
    bcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(bcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast %s=[%s] %s=[%s] %s=[%s] %s=[%s]", "avail", TextUtils.join(",", availableList), "local_only", TextUtils.join(",", localOnlyList), "tether", TextUtils.join(",", tetherList), "error", TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
#end_block

#method_before
public static final void enforceTetherChangePermission(Context context, String callingPkg) {
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        if (callingPkg == null) {
            // This is not entirely correct. If uid is shared by multiple packages, it returns
            // a first package of shared uid list.
            callingPkg = Settings.getPackageNameForUid(context, uid);
        }
        // If callingPkg's uid is not same as Binder.getCallingUid(),
        // AppOpsService throws SecurityException.
        Settings.checkAndNoteWriteSettingsOperation(context, uid, callingPkg, true);
    }
}
#method_after
public static final void enforceTetherChangePermission(Context context, String callingPkg) {
    if (null == context || null == callingPkg) {
        throw new IllegalArgumentException("arguments should not be null");
    }
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        // If callingPkg's uid is not same as Binder.getCallingUid(),
        // AppOpsService throws SecurityException.
        Settings.checkAndNoteWriteSettingsOperation(context, uid, callingPkg, true);
    }
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        for (String tether : getTetheredIfaces()) {
            untether(tether);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
        }
        // Turn Always-on VPN off
        if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
            final long ident = Binder.clearCallingIdentity();
            try {
                mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                mLockdownEnabled = false;
                setLockdownTracker(null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        String pkgName = mContext.getOpPackageName();
        for (String tether : getTetheredIfaces()) {
            untether(tether, pkgName);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
        }
        // Turn Always-on VPN off
        if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
            final long ident = Binder.clearCallingIdentity();
            try {
                mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                mLockdownEnabled = false;
                setLockdownTracker(null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
        // Turn VPN off
        VpnConfig vpnConfig = getVpnConfig(userId);
        if (vpnConfig != null) {
            if (vpnConfig.legacy) {
                prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
            } else {
                // Prevent this app (packagename = vpnConfig.user) from initiating VPN connections
                // in the future without user intervention.
                setVpnPackageAuthorization(vpnConfig.user, userId, false);
                prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#end_block

#method_before
void getFolderItemsNowPlaying(byte[] bdaddr, AvrcpCmd.FolderItemsCmd reqObj, MediaController mediaController) {
    List<MediaSession.QueueItem> items = mNowPlayingList;
    if (DEBUG)
        Log.v(TAG, "getFolderItemsNowPlaying");
    if (items == null) {
        if (mediaController == null) {
            // No players (if a player exists, we would have selected it)
            Log.e(TAG, "mediaController = null, sending no available players response");
            mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
            return;
        }
        // We don't have the cached list, fetching it from Media Controller
        items = mediaController.getQueue();
        if (items == null) {
            Log.i(TAG, "null queue from " + mediaController.getPackageName() + ", constructing current-item list");
            MediaMetadata metadata = mediaController.getMetadata();
            MediaSession.QueueItem current = getCurrentQueueItem(mediaController);
            items = new ArrayList<MediaSession.QueueItem>();
            items.add(current);
        }
    }
    getFolderItemsFilterAttr(bdaddr, reqObj, items, AvrcpConstants.BTRC_SCOPE_NOW_PLAYING, reqObj.mStartItem, reqObj.mEndItem);
}
#method_after
void getFolderItemsNowPlaying(byte[] bdaddr, AvrcpCmd.FolderItemsCmd reqObj, MediaController mediaController) {
    if (DEBUG)
        Log.v(TAG, "getFolderItemsNowPlaying");
    if (mediaController == null) {
        // No players (if a player exists, we would have selected it)
        Log.e(TAG, "mediaController = null, sending no available players response");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
        return;
    }
    List<MediaSession.QueueItem> items = getNowPlayingList(mediaController);
    getFolderItemsFilterAttr(bdaddr, reqObj, items, AvrcpConstants.BTRC_SCOPE_NOW_PLAYING, reqObj.mStartItem, reqObj.mEndItem, mediaController);
}
#end_block

#method_before
void getItemAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd itemAttr, MediaController mediaController) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    long mediaId = ByteBuffer.wrap(itemAttr.mUid).getLong();
    List<MediaSession.QueueItem> items = mNowPlayingList;
    /* checking if item attributes has been asked for now playing item or
         * some other item with specific media id */
    if (Arrays.equals(itemAttr.mUid, NOW_PLAYING_UID)) {
        if (DEBUG)
            Log.d(TAG, "getItemAttr: Remote requests for now playing contents:");
        if (mediaController == null) {
            Log.e(TAG, "mediaController = null, sending no available players response");
            mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
            return;
        }
        // get the current playing metadata and send.
        getItemAttrFilterAttr(bdaddr, itemAttr, getCurrentQueueItem(mediaController));
        return;
    }
    if (items == null) {
        // See if the controller has a new set of items.
        items = mediaController.getQueue();
        if (items == null) {
            // The mediaController doesn't have more items, and they aren't requesting the
            // current item, so the item they're requesting is invalid.
            Log.e(TAG, "getItemAttr: no queue and request for id " + mediaId);
            mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM, null);
            return;
        }
        // Cache the queue response
        mNowPlayingList = items;
    }
    if (DEBUG)
        printByteArray("getItemAttr-UID", itemAttr.mUid);
    for (MediaSession.QueueItem item : items) {
        if (item.getQueueId() == mediaId) {
            getItemAttrFilterAttr(bdaddr, itemAttr, item);
            return;
        }
    }
    // Couldn't find it, so the id is invalid
    mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM, null);
}
#method_after
void getItemAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd itemAttr, MediaController mediaController) {
    int status = AvrcpConstants.RSP_NO_ERROR;
    long mediaId = ByteBuffer.wrap(itemAttr.mUid).getLong();
    List<MediaSession.QueueItem> items = getNowPlayingList(mediaController);
    /* checking if item attributes has been asked for now playing item or
         * some other item with specific media id */
    if (Arrays.equals(itemAttr.mUid, NOW_PLAYING_UID)) {
        if (DEBUG)
            Log.d(TAG, "getItemAttr: Remote requests for now playing contents:");
        if (mediaController == null) {
            Log.e(TAG, "mediaController = null, sending no available players response");
            mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
            return;
        }
        // get the current playing metadata and send.
        getItemAttrFilterAttr(bdaddr, itemAttr, getCurrentQueueItem(mediaController, mediaId), mediaController);
        return;
    }
    if (DEBUG)
        printByteArray("getItemAttr-UID", itemAttr.mUid);
    for (MediaSession.QueueItem item : items) {
        if (item.getQueueId() == mediaId) {
            getItemAttrFilterAttr(bdaddr, itemAttr, item, mediaController);
            return;
        }
    }
    // Couldn't find it, so the id is invalid
    mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_INV_ITEM, null);
}
#end_block

#method_before
private MediaSession.QueueItem getCurrentQueueItem(MediaController controller) {
    MediaMetadata metadata = controller.getMetadata();
    if (metadata == null) {
        Log.w(TAG, "Controller has no metadata!? Making an empty one");
        metadata = (new MediaMetadata.Builder()).build();
    }
    MediaDescription.Builder bob = new MediaDescription.Builder();
    MediaDescription desc = metadata.getDescription();
    // set the simple ones that MediaMetadata builds for us
    bob.setMediaId(desc.getMediaId());
    bob.setTitle(desc.getTitle());
    bob.setSubtitle(desc.getSubtitle());
    bob.setDescription(desc.getDescription());
    // fill the ones that we use later
    bob.setExtras(fillBundle(metadata));
    // build queue item with the new metadata
    desc = bob.build();
    return new QueueItem(desc, ByteBuffer.wrap(NOW_PLAYING_UID).getLong());
}
#method_after
private MediaSession.QueueItem getCurrentQueueItem(MediaController controller, long qid) {
    MediaMetadata metadata = controller.getMetadata();
    if (metadata == null) {
        Log.w(TAG, "Controller has no metadata!? Making an empty one");
        metadata = (new MediaMetadata.Builder()).build();
    }
    MediaDescription.Builder bob = new MediaDescription.Builder();
    MediaDescription desc = metadata.getDescription();
    // set the simple ones that MediaMetadata builds for us
    bob.setMediaId(desc.getMediaId());
    bob.setTitle(desc.getTitle());
    bob.setSubtitle(desc.getSubtitle());
    bob.setDescription(desc.getDescription());
    // fill the ones that we use later
    bob.setExtras(fillBundle(metadata, desc.getExtras()));
    // build queue item with the new metadata
    desc = bob.build();
    return new QueueItem(desc, qid);
}
#end_block

#method_before
private Bundle fillBundle(MediaMetadata metadata) {
    String[] stringKeys = { MediaMetadata.METADATA_KEY_ARTIST, MediaMetadata.METADATA_KEY_ALBUM, MediaMetadata.METADATA_KEY_GENRE };
    String[] longKeys = { MediaMetadata.METADATA_KEY_TRACK_NUMBER, MediaMetadata.METADATA_KEY_NUM_TRACKS, MediaMetadata.METADATA_KEY_DURATION };
    Bundle bundle = new Bundle();
    for (String key : stringKeys) {
        bundle.putString(key, metadata.getString(key));
    }
    for (String key : longKeys) {
        bundle.putString(key, metadata.getLong(key) + "");
    }
    return bundle;
}
#method_after
private Bundle fillBundle(MediaMetadata metadata, Bundle currentExtras) {
    if (metadata == null) {
        return currentExtras;
    }
    String[] stringKeys = { MediaMetadata.METADATA_KEY_ARTIST, MediaMetadata.METADATA_KEY_ALBUM, MediaMetadata.METADATA_KEY_GENRE };
    String[] longKeys = { MediaMetadata.METADATA_KEY_TRACK_NUMBER, MediaMetadata.METADATA_KEY_NUM_TRACKS, MediaMetadata.METADATA_KEY_DURATION };
    Bundle bundle = currentExtras;
    if (bundle == null)
        bundle = new Bundle();
    for (String key : stringKeys) {
        String current = bundle.getString(key);
        if (current == null)
            bundle.putString(key, metadata.getString(key));
    }
    for (String key : longKeys) {
        String current = bundle.getString(key);
        if (current == null)
            bundle.putString(key, metadata.getLong(key) + "");
    }
    return bundle;
}
#end_block

#method_before
void getTotalNumOfItems(byte[] bdaddr, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "getTotalNumOfItems");
    List<MediaSession.QueueItem> items = mNowPlayingList;
    if (items != null) {
        // We already have the cached list sending the response to remote
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
        return;
    }
    if (mediaController == null) {
        Log.e(TAG, "mediaController = null, sending no available players response");
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
        return;
    }
    // We don't have the cached list, fetch it from Media Controller
    items = mediaController.getQueue();
    if (items == null) {
        // We're presenting a queue with only 1 item (the current one)
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, 1);
    }
    // Cache the response for later
    mNowPlayingList = items;
    mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
}
#method_after
void getTotalNumOfItems(byte[] bdaddr, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "getTotalNumOfItems");
    List<MediaSession.QueueItem> items = mNowPlayingList;
    if (items != null) {
        // We already have the cached list sending the response to remote
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
        return;
    }
    if (mediaController == null) {
        Log.e(TAG, "mediaController = null, sending no available players response");
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_AVBL_PLAY, null);
        return;
    }
    // We don't have the cached list, fetch it from Media Controller
    items = mediaController.getQueue();
    if (items == null) {
        // We may be presenting a queue with only 1 item (the current one)
        int count = mediaController.getMetadata() != null ? 1 : 0;
        mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, count);
    }
    // Cache the response for later
    mNowPlayingList = items;
    mMediaInterface.getTotalNumOfItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, 0, items.size());
}
#end_block

#method_before
void sendTrackChangeWithId(int trackChangedNT, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "sendTrackChangeWithId");
    byte[] track;
    try {
        if (mediaController == null) {
            mMediaInterface.trackChangedRsp(trackChangedNT, AvrcpConstants.NO_TRACK_SELECTED);
            return;
        }
        String mediaId = mediaController.getMetadata().getDescription().getMediaId();
        long qid = MediaSession.QueueItem.UNKNOWN_ID;
        List<MediaSession.QueueItem> items = mNowPlayingList;
        /* traverse now playing list for current playing item */
        for (QueueItem item : items) {
            if (item.getDescription().getMediaId().equals(mediaId)) {
                qid = item.getQueueId();
                if (DEBUG)
                    Log.d(TAG, "sendTrackChangeWithId: Found matching qid= " + qid);
                break;
            }
        }
        /* for any item associated with NowPlaying, uid is queueId */
        track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
    } catch (NullPointerException e) {
        Log.w(TAG, "NullPointerException getting uid, sending no track selected");
        e.printStackTrace();
        // Track selected (0x0) is not allowed for browsable players (AVRCP 1.6.1 p64)
        track = AvrcpConstants.NO_TRACK_SELECTED;
    }
    if (DEBUG)
        printByteArray("trackChangedRsp", track);
    mMediaInterface.trackChangedRsp(trackChangedNT, track);
}
#method_after
void sendTrackChangeWithId(int trackChangedNT, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "sendTrackChangeWithId");
    byte[] track;
    if (mediaController == null) {
        mMediaInterface.trackChangedRsp(trackChangedNT, AvrcpConstants.NO_TRACK_SELECTED);
        return;
    }
    long qid = MediaSession.QueueItem.UNKNOWN_ID;
    PlaybackState state = mediaController.getPlaybackState();
    if (state != null) {
        qid = state.getActiveQueueItemId();
    }
    /* for any item associated with NowPlaying, uid is queueId */
    track = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
    if (DEBUG)
        printByteArray("trackChangedRsp", track);
    mMediaInterface.trackChangedRsp(trackChangedNT, track);
}
#end_block

#method_before
private void getFolderItemsFilterAttr(byte[] bdaddr, AvrcpCmd.FolderItemsCmd folderItemsReqObj, List<MediaSession.QueueItem> items, byte scope, int startItem, int endItem) {
    if (DEBUG)
        Log.d(TAG, "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
    List<MediaSession.QueueItem> result_items = new ArrayList<MediaSession.QueueItem>();
    if (items == null) {
        Log.e(TAG, "items is null in getFolderItemsFilterAttr");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return;
    }
    result_items = checkIndexOutofBounds(bdaddr, items, startItem, endItem);
    /* check for index out of bound errors */
    if (result_items == null) {
        Log.w(TAG, "result_items is null.");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return;
    }
    FolderItemsData folderDataNative = new FolderItemsData(result_items.size());
    /* variables to temperorily add attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) {
        // get the queue id
        long qid = result_items.get(itemIndex).getQueueId();
        byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
        // get the array of uid from 2d to array 1D array
        for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
            folderDataNative.mItemUid[itemIndex * AvrcpConstants.UID_SIZE + idx] = uid[idx];
        }
        /* Set display name for current item */
        folderDataNative.mDisplayNames[itemIndex] = result_items.get(itemIndex).getDescription().getTitle().toString();
        int maxAttributesRequested = 0;
        boolean isAllAttribRequested = false;
        /* check if remote requested for attributes */
        if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
            int attrCnt = 0;
            /* add requested attr ids to a temp array */
            if (folderItemsReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
                isAllAttribRequested = true;
                maxAttributesRequested = AvrcpConstants.MAX_NUM_ATTR;
            } else {
                /* get only the requested attribute ids from the request */
                maxAttributesRequested = folderItemsReqObj.mNumAttr;
            }
            /* lookup and copy values of attributes for ids requested above */
            for (int idx = 0; idx < maxAttributesRequested; idx++) {
                /* check if media player provided requested attributes */
                String value = null;
                int attribId = isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx];
                if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) {
                    value = getAttrValue(attribId, result_items, itemIndex);
                    if (value != null) {
                        attrArray.add(value);
                        attrId.add(attribId);
                        attrCnt++;
                    }
                } else {
                    Log.w(TAG, "invalid attributed id is requested: " + attribId);
                }
            }
            /* add num attr actually received from media player for a particular item */
            folderDataNative.mAttributesNum[itemIndex] = attrCnt;
        }
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        folderDataNative.mAttrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
        folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
    }
    for (int attrIndex = 0; attrIndex < folderDataNative.mAttributesNum.length; attrIndex++) if (DEBUG)
        Log.d(TAG, "folderDataNative.mAttributesNum" + folderDataNative.mAttributesNum[attrIndex] + " attrIndex " + attrIndex);
    /* create rsp object and send response to remote device */
    FolderItemsRsp rspObj = new FolderItemsRsp(AvrcpConstants.RSP_NO_ERROR, Avrcp.sUIDCounter, scope, folderDataNative.mNumItems, folderDataNative.mFolderTypes, folderDataNative.mPlayable, folderDataNative.mItemTypes, folderDataNative.mItemUid, folderDataNative.mDisplayNames, folderDataNative.mAttributesNum, folderDataNative.mAttrIds, folderDataNative.mAttrValues);
    mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
}
#method_after
private void getFolderItemsFilterAttr(byte[] bdaddr, AvrcpCmd.FolderItemsCmd folderItemsReqObj, List<MediaSession.QueueItem> items, byte scope, int startItem, int endItem, MediaController mediaController) {
    if (DEBUG)
        Log.d(TAG, "getFolderItemsFilterAttr: startItem =" + startItem + ", endItem = " + endItem);
    List<MediaSession.QueueItem> result_items = new ArrayList<MediaSession.QueueItem>();
    if (items == null) {
        Log.e(TAG, "items is null in getFolderItemsFilterAttr");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return;
    }
    result_items = checkIndexOutofBounds(bdaddr, items, startItem, endItem);
    /* check for index out of bound errors */
    if (result_items == null) {
        Log.w(TAG, "result_items is null.");
        mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_INV_RANGE, null);
        return;
    }
    FolderItemsData folderDataNative = new FolderItemsData(result_items.size());
    /* variables to accumulate attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    for (int itemIndex = 0; itemIndex < result_items.size(); itemIndex++) {
        // get the queue id
        long qid = result_items.get(itemIndex).getQueueId();
        byte[] uid = ByteBuffer.allocate(AvrcpConstants.UID_SIZE).putLong(qid).array();
        // get the array of uid from 2d to array 1D array
        for (int idx = 0; idx < AvrcpConstants.UID_SIZE; idx++) {
            folderDataNative.mItemUid[itemIndex * AvrcpConstants.UID_SIZE + idx] = uid[idx];
        }
        /* Set display name for current item */
        folderDataNative.mDisplayNames[itemIndex] = result_items.get(itemIndex).getDescription().getTitle().toString();
        int maxAttributesRequested = 0;
        boolean isAllAttribRequested = false;
        /* check if remote requested for attributes */
        if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
            int attrCnt = 0;
            /* add requested attr ids to a temp array */
            if (folderItemsReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
                isAllAttribRequested = true;
                maxAttributesRequested = AvrcpConstants.MAX_NUM_ATTR;
            } else {
                /* get only the requested attribute ids from the request */
                maxAttributesRequested = folderItemsReqObj.mNumAttr;
            }
            /* lookup and copy values of attributes for ids requested above */
            for (int idx = 0; idx < maxAttributesRequested; idx++) {
                /* check if media player provided requested attributes */
                String value = null;
                int attribId = isAllAttribRequested ? (idx + 1) : folderItemsReqObj.mAttrIDs[idx];
                if (attribId >= AvrcpConstants.ATTRID_TITLE && attribId <= AvrcpConstants.ATTRID_PLAY_TIME) {
                    value = getAttrValue(attribId, result_items.get(itemIndex), mediaController);
                    if (value != null) {
                        attrArray.add(value);
                        attrId.add(attribId);
                        attrCnt++;
                    }
                } else {
                    Log.w(TAG, "invalid attribute id is requested: " + attribId);
                }
            }
            /* add num attr actually received from media player for a particular item */
            folderDataNative.mAttributesNum[itemIndex] = attrCnt;
        }
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (folderItemsReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        folderDataNative.mAttrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) folderDataNative.mAttrIds[attrIndex] = attrId.get(attrIndex);
        folderDataNative.mAttrValues = attrArray.toArray(new String[attrArray.size()]);
    }
    for (int attrIndex = 0; attrIndex < folderDataNative.mAttributesNum.length; attrIndex++) if (DEBUG)
        Log.d(TAG, "folderDataNative.mAttributesNum" + folderDataNative.mAttributesNum[attrIndex] + " attrIndex " + attrIndex);
    /* create rsp object and send response to remote device */
    FolderItemsRsp rspObj = new FolderItemsRsp(AvrcpConstants.RSP_NO_ERROR, Avrcp.sUIDCounter, scope, folderDataNative.mNumItems, folderDataNative.mFolderTypes, folderDataNative.mPlayable, folderDataNative.mItemTypes, folderDataNative.mItemUid, folderDataNative.mDisplayNames, folderDataNative.mAttributesNum, folderDataNative.mAttrIds, folderDataNative.mAttrValues);
    mMediaInterface.folderItemsRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
}
#end_block

#method_before
private String getAttrValue(int attr, List<MediaSession.QueueItem> resultItems, int itemIndex) {
    String attrValue = null;
    try {
        switch(attr) {
            /* Title is mandatory attribute */
            case AvrcpConstants.ATTRID_TITLE:
                attrValue = resultItems.get(itemIndex).getDescription().getTitle().toString();
                break;
            case AvrcpConstants.ATTRID_ARTIST:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ARTIST);
                break;
            case AvrcpConstants.ATTRID_ALBUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_ALBUM);
                break;
            case AvrcpConstants.ATTRID_TRACK_NUM:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
                break;
            case AvrcpConstants.ATTRID_NUM_TRACKS:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_NUM_TRACKS);
                break;
            case AvrcpConstants.ATTRID_GENRE:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_GENRE);
                break;
            case AvrcpConstants.ATTRID_PLAY_TIME:
                attrValue = resultItems.get(itemIndex).getDescription().getExtras().getString(MediaMetadata.METADATA_KEY_DURATION);
                break;
            case AvrcpConstants.ATTRID_COVER_ART:
                Log.e(TAG, "Cover art attribute not supported");
                break;
            default:
                Log.e(TAG, "Unknown attribute ID");
        }
    } catch (IndexOutOfBoundsException ex) {
        Log.w(TAG, "getAttrValue: requested item index out of bounds");
        return null;
    } catch (NullPointerException ex) {
        Log.w(TAG, "getAttrValue: attr id not found in result");
        /* checking if attribute is title, then it is mandatory and cannot send null */
        if (attr == AvrcpConstants.ATTRID_TITLE) {
            return "<Unknown Title>";
        }
        return null;
    }
    if (DEBUG)
        Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + ", attr id:" + attr);
    return attrValue;
}
#method_after
private String getAttrValue(int attr, MediaSession.QueueItem item, MediaController mediaController) {
    String attrValue = null;
    if (item == null) {
        if (DEBUG)
            Log.d(TAG, "getAttrValue received null item");
        return null;
    }
    try {
        MediaDescription desc = item.getDescription();
        PlaybackState state = mediaController.getPlaybackState();
        Bundle extras = desc.getExtras();
        if (state != null && (item.getQueueId() == state.getActiveQueueItemId())) {
            extras = fillBundle(mediaController.getMetadata(), extras);
        }
        if (DEBUG)
            Log.d(TAG, "getAttrValue: item " + item + " : " + desc);
        switch(attr) {
            case AvrcpConstants.ATTRID_TITLE:
                /* Title is mandatory attribute */
                attrValue = desc.getTitle().toString();
                break;
            case AvrcpConstants.ATTRID_ARTIST:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_ARTIST);
                break;
            case AvrcpConstants.ATTRID_ALBUM:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_ALBUM);
                break;
            case AvrcpConstants.ATTRID_TRACK_NUM:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_TRACK_NUMBER);
                break;
            case AvrcpConstants.ATTRID_NUM_TRACKS:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_NUM_TRACKS);
                break;
            case AvrcpConstants.ATTRID_GENRE:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_GENRE);
                break;
            case AvrcpConstants.ATTRID_PLAY_TIME:
                attrValue = extras.getString(MediaMetadata.METADATA_KEY_DURATION);
                break;
            case AvrcpConstants.ATTRID_COVER_ART:
                Log.e(TAG, "Cover art attribute not supported");
                break;
            default:
                Log.e(TAG, "Unknown attribute ID");
        }
    } catch (NullPointerException ex) {
        Log.w(TAG, "getAttrValue: attr id not found in result");
        /* checking if attribute is title, then it is mandatory and cannot send null */
        if (attr == AvrcpConstants.ATTRID_TITLE) {
            return "<Unknown Title>";
        }
        return null;
    }
    if (DEBUG)
        Log.d(TAG, "getAttrValue: attrvalue = " + attrValue + ", attr id:" + attr);
    return attrValue;
}
#end_block

#method_before
private void getItemAttrFilterAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd mItemAttrReqObj, MediaSession.QueueItem mediaItem) {
    /* Response parameters */
    int[] attrIds = null;
    /* array of attr ids */
    String[] attrValues = null;
    /* array of attr values */
    int attrCounter = 0;
    /* num attributes for each item */
    List<MediaSession.QueueItem> resultItems = new ArrayList<MediaSession.QueueItem>();
    resultItems.add(mediaItem);
    /* variables to temperorily add attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    ArrayList<Integer> attrTempId = new ArrayList<Integer>();
    /* check if remote device has requested for attributes */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        if (mItemAttrReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
            for (int idx = 1; idx < AvrcpConstants.MAX_NUM_ATTR; idx++) {
                attrTempId.add(idx);
            /* attr id 0x00 is unused */
            }
        } else {
            /* get only the requested attribute ids from the request */
            for (int idx = 0; idx < mItemAttrReqObj.mNumAttr; idx++) {
                if (DEBUG)
                    Log.d(TAG, "getAttrValue: attr id[" + idx + "] :" + mItemAttrReqObj.mAttrIDs[idx]);
                attrTempId.add(mItemAttrReqObj.mAttrIDs[idx]);
            }
        }
        if (DEBUG)
            Log.d(TAG, "getAttrValue: attr id list size:" + attrTempId.size());
        /* lookup and copy values of attributes for ids requested above */
        for (int idx = 0; idx < attrTempId.size(); idx++) {
            /* check if media player provided requested attributes */
            String value = null;
            if ((value = getAttrValue(attrTempId.get(idx), resultItems, 0)) != null) {
                attrArray.add(value);
                attrId.add(attrTempId.get(idx));
                attrCounter++;
            }
        }
        attrTempId = null;
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        attrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) attrIds[attrIndex] = attrId.get(attrIndex);
        attrValues = attrArray.toArray(new String[attrId.size()]);
        /* create rsp object and send response */
        ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpConstants.RSP_NO_ERROR, (byte) attrCounter, attrIds, attrValues);
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
        return;
    }
}
#method_after
private void getItemAttrFilterAttr(byte[] bdaddr, AvrcpCmd.ItemAttrCmd mItemAttrReqObj, MediaSession.QueueItem mediaItem, MediaController mediaController) {
    /* Response parameters */
    int[] attrIds = null;
    /* array of attr ids */
    String[] attrValues = null;
    /* array of attr values */
    int attrCounter = 0;
    /* num attributes for each item */
    /* variables to temperorily add attrs */
    ArrayList<String> attrArray = new ArrayList<String>();
    ArrayList<Integer> attrId = new ArrayList<Integer>();
    ArrayList<Integer> attrTempId = new ArrayList<Integer>();
    /* check if remote device has requested for attributes */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        if (mItemAttrReqObj.mNumAttr == AvrcpConstants.NUM_ATTR_ALL) {
            for (int idx = 1; idx < AvrcpConstants.MAX_NUM_ATTR; idx++) {
                attrTempId.add(idx);
            /* attr id 0x00 is unused */
            }
        } else {
            /* get only the requested attribute ids from the request */
            for (int idx = 0; idx < mItemAttrReqObj.mNumAttr; idx++) {
                if (DEBUG)
                    Log.d(TAG, "getAttrValue: attr id[" + idx + "] :" + mItemAttrReqObj.mAttrIDs[idx]);
                attrTempId.add(mItemAttrReqObj.mAttrIDs[idx]);
            }
        }
    }
    if (DEBUG)
        Log.d(TAG, "getAttrValue: attr id list size:" + attrTempId.size());
    /* lookup and copy values of attributes for ids requested above */
    for (int idx = 0; idx < attrTempId.size(); idx++) {
        /* check if media player provided requested attributes */
        String value = getAttrValue(attrTempId.get(idx), mediaItem, mediaController);
        if (value != null) {
            attrArray.add(value);
            attrId.add(attrTempId.get(idx));
            attrCounter++;
        }
    }
    /* copy filtered attr ids and attr values to response parameters */
    if (mItemAttrReqObj.mNumAttr != AvrcpConstants.NUM_ATTR_NONE) {
        attrIds = new int[attrId.size()];
        for (int attrIndex = 0; attrIndex < attrId.size(); attrIndex++) attrIds[attrIndex] = attrId.get(attrIndex);
        attrValues = attrArray.toArray(new String[attrId.size()]);
        /* create rsp object and send response */
        ItemAttrRsp rspObj = new ItemAttrRsp(AvrcpConstants.RSP_NO_ERROR, (byte) attrCounter, attrIds, attrValues);
        mMediaInterface.getItemAttrRsp(bdaddr, AvrcpConstants.RSP_NO_ERROR, rspObj);
        return;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (DEBUG)
        Log.v(TAG, "AvrcpMessageHandler: received message=" + msg.what);
    switch(msg.what) {
        case MSG_NATIVE_REQ_GET_RC_FEATURES:
            {
                String address = (String) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_RC_FEATURES: address=" + address + ", features=" + msg.arg1);
                mFeatures = msg.arg1;
                mFeatures = modifyRcFeatureFromBlacklist(mFeatures, address);
                mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
                mLastLocalVolume = -1;
                mRemoteVolume = -1;
                mLocalVolume = -1;
                mInitialRemoteVolume = -1;
                mAddress = address;
                if (mVolumeMapping != null)
                    mVolumeMapping.clear();
                break;
            }
        case MSG_NATIVE_REQ_GET_PLAY_STATUS:
            {
                byte[] address = (byte[]) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_PLAY_STATUS");
                getPlayStatusRspNative(address, convertPlayStateToPlayStatus(mCurrentPlayState), (int) mSongLengthMs, (int) getPlayPosition());
                break;
            }
        case MSG_NATIVE_REQ_GET_ELEM_ATTRS:
            {
                String[] textArray;
                AvrcpCmd.ElementAttrCmd elem = (AvrcpCmd.ElementAttrCmd) msg.obj;
                byte numAttr = elem.mNumAttr;
                int[] attrIds = elem.mAttrIDs;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_ELEM_ATTRS:numAttr=" + numAttr);
                textArray = new String[numAttr];
                for (int i = 0; i < numAttr; ++i) {
                    textArray[i] = mMediaAttributes.getString(attrIds[i]);
                    Log.v(TAG, "getAttributeString:attrId=" + attrIds[i] + " str=" + textArray[i]);
                }
                byte[] bdaddr = elem.mAddress;
                getElementAttrRspNative(bdaddr, numAttr, attrIds, textArray);
                break;
            }
        case MSG_NATIVE_REQ_REGISTER_NOTIFICATION:
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_REGISTER_NOTIFICATION:event=" + msg.arg1 + " param=" + msg.arg2);
            processRegisterNotification((byte[]) msg.obj, msg.arg1, msg.arg2);
            break;
        case MSG_AVAILABLE_PLAYERS_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_AVAILABLE_PLAYERS_CHANGED_RSP");
            removeMessages(MSG_AVAILABLE_PLAYERS_CHANGED_RSP);
            registerNotificationRspAvalPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
            break;
        case MSG_NOW_PLAYING_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_NOW_PLAYING_CHANGED_RSP");
            removeMessages(MSG_NOW_PLAYING_CHANGED_RSP);
            registerNotificationRspNowPlayingChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
            break;
        case MSG_ADDRESSED_PLAYER_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_ADDRESSED_PLAYER_CHANGED_RSP: newAddrPlayer = " + msg.arg1);
            // Later addressed players override earlier ones.
            if (hasMessages(MSG_ADDRESSED_PLAYER_CHANGED_RSP)) {
                Log.i(TAG, "MSG_ADDRESSED_PLAYER_CHANGED_RSP: skip, more changes in queue");
                break;
            }
            registerNotificationRspAddrPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, msg.arg1, sUIDCounter);
            break;
        case MSG_PLAY_INTERVAL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_PLAY_INTERVAL_TIMEOUT");
            sendPlayPosNotificationRsp(false);
            break;
        case MSG_NATIVE_REQ_VOLUME_CHANGE:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_NATIVE_REQ_VOLUME_CHANGE");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_VOLUME_CHANGE: volume=" + ((byte) msg.arg1 & 0x7f) + " ctype=" + msg.arg2);
            boolean volAdj = false;
            if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
                if (mVolCmdAdjustInProgress == false && mVolCmdSetInProgress == false) {
                    Log.e(TAG, "Unsolicited response, ignored");
                    break;
                }
                removeMessages(MSG_ABS_VOL_TIMEOUT);
                volAdj = mVolCmdAdjustInProgress;
                mVolCmdAdjustInProgress = false;
                mVolCmdSetInProgress = false;
                mAbsVolRetryTimes = 0;
            }
            // discard MSB as it is RFD
            byte absVol = (byte) ((byte) msg.arg1 & 0x7f);
            // convert remote volume to local volume
            int volIndex = convertToAudioStreamVolume(absVol);
            if (mInitialRemoteVolume == -1) {
                mInitialRemoteVolume = absVol;
                if (mAbsVolThreshold > 0 && mAbsVolThreshold < mAudioStreamMax && volIndex > mAbsVolThreshold) {
                    if (DEBUG)
                        Log.v(TAG, "remote inital volume too high " + volIndex + ">" + mAbsVolThreshold);
                    Message msg1 = mHandler.obtainMessage(MSG_SET_ABSOLUTE_VOLUME, mAbsVolThreshold, 0);
                    mHandler.sendMessage(msg1);
                    mRemoteVolume = absVol;
                    mLocalVolume = volIndex;
                    break;
                }
            }
            if (mLocalVolume != volIndex && (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_CHANGED || msg.arg2 == AVRC_RSP_INTERIM)) {
                /* If the volume has successfully changed */
                mLocalVolume = volIndex;
                if (mLastLocalVolume != -1 && msg.arg2 == AVRC_RSP_ACCEPT) {
                    if (mLastLocalVolume != volIndex) {
                        /* remote volume changed more than requested due to
                             * local and remote has different volume steps */
                        if (DEBUG)
                            Log.d(TAG, "Remote returned volume does not match desired volume " + mLastLocalVolume + " vs " + volIndex);
                        mLastLocalVolume = mLocalVolume;
                    }
                }
                // remember the remote volume value, as it's the one supported by remote
                if (volAdj) {
                    synchronized (mVolumeMapping) {
                        mVolumeMapping.put(volIndex, (int) absVol);
                        if (DEBUG)
                            Log.v(TAG, "remember volume mapping " + volIndex + "-" + absVol);
                    }
                }
                notifyVolumeChanged(mLocalVolume);
                mRemoteVolume = absVol;
                long pecentVolChanged = ((long) absVol * 100) / 0x7f;
                Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
            } else if (msg.arg2 == AVRC_RSP_REJ) {
                Log.e(TAG, "setAbsoluteVolume call rejected");
            } else if (volAdj && mLastRemoteVolume > 0 && mLastRemoteVolume < AVRCP_MAX_VOL && mLocalVolume == volIndex && (msg.arg2 == AVRC_RSP_ACCEPT)) {
                /* oops, the volume is still same, remote does not like the value
                     * retry a volume one step up/down */
                if (DEBUG)
                    Log.d(TAG, "Remote device didn't tune volume, let's try one more step.");
                int retry_volume = Math.min(AVRCP_MAX_VOL, Math.max(0, mLastRemoteVolume + mLastDirection));
                if (setVolumeNative(retry_volume)) {
                    mLastRemoteVolume = retry_volume;
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                }
            }
            break;
        case MSG_ADJUST_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_ADJUST_VOLUME");
                break;
            }
            if (DEBUG)
                Log.d(TAG, "MSG_ADJUST_VOLUME: direction=" + msg.arg1);
            if (mVolCmdAdjustInProgress || mVolCmdSetInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            // Wait on verification on volume from device, before changing the volume.
            if (mRemoteVolume != -1 && (msg.arg1 == -1 || msg.arg1 == 1)) {
                int setVol = -1;
                int targetVolIndex = -1;
                if (mLocalVolume == 0 && msg.arg1 == -1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol down from 0.");
                    break;
                }
                if (mLocalVolume == mAudioStreamMax && msg.arg1 == 1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol up from max.");
                    break;
                }
                targetVolIndex = mLocalVolume + msg.arg1;
                if (DEBUG)
                    Log.d(TAG, "Adjusting volume to  " + targetVolIndex);
                Integer i;
                synchronized (mVolumeMapping) {
                    i = mVolumeMapping.get(targetVolIndex);
                }
                if (i != null) {
                    /* if we already know this volume mapping, use it */
                    setVol = i.byteValue();
                    if (setVol == mRemoteVolume) {
                        if (DEBUG)
                            Log.d(TAG, "got same volume from mapping for " + targetVolIndex + ", ignore.");
                        setVol = -1;
                    }
                    if (DEBUG)
                        Log.d(TAG, "set volume from mapping " + targetVolIndex + "-" + setVol);
                }
                if (setVol == -1) {
                    /* otherwise use phone steps */
                    setVol = Math.min(AVRCP_MAX_VOL, convertToAvrcpVolume(Math.max(0, targetVolIndex)));
                    if (DEBUG)
                        Log.d(TAG, "set volume from local volume " + targetVolIndex + "-" + setVol);
                }
                if (setVolumeNative(setVol)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                    mLastDirection = msg.arg1;
                    mLastRemoteVolume = setVol;
                    mLastLocalVolume = targetVolIndex;
                } else {
                    if (DEBUG)
                        Log.d(TAG, "setVolumeNative failed");
                }
            } else {
                Log.e(TAG, "Unknown direction in MSG_ADJUST_VOLUME");
            }
            break;
        case MSG_SET_ABSOLUTE_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_SET_ABSOLUTE_VOLUME");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_SET_ABSOLUTE_VOLUME");
            if (mVolCmdSetInProgress || mVolCmdAdjustInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                if (DEBUG)
                    Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            int avrcpVolume = convertToAvrcpVolume(msg.arg1);
            avrcpVolume = Math.min(AVRCP_MAX_VOL, Math.max(0, avrcpVolume));
            if (DEBUG)
                Log.d(TAG, "Setting volume to " + msg.arg1 + "-" + avrcpVolume);
            if (setVolumeNative(avrcpVolume)) {
                sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                mVolCmdSetInProgress = true;
                mLastRemoteVolume = avrcpVolume;
                mLastLocalVolume = msg.arg1;
            } else {
                if (DEBUG)
                    Log.d(TAG, "setVolumeNative failed");
            }
            break;
        case MSG_ABS_VOL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
            mVolCmdAdjustInProgress = false;
            mVolCmdSetInProgress = false;
            if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
                mAbsVolRetryTimes = 0;
                /* too many volume change failures, black list the device */
                blackListCurrentDevice();
            } else {
                mAbsVolRetryTimes += 1;
                if (setVolumeNative(mLastRemoteVolume)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdSetInProgress = true;
                }
            }
            break;
        case MSG_FAST_FORWARD:
        case MSG_REWIND:
            if (msg.what == MSG_FAST_FORWARD) {
                if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                    int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                    KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_FAST_FORWARD);
                    mMediaController.dispatchMediaButtonEvent(keyEvent);
                    break;
                }
            } else if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_REWIND) != 0) {
                int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_REWIND);
                mMediaController.dispatchMediaButtonEvent(keyEvent);
                break;
            }
            int skipAmount;
            int playStatus;
            if (msg.what == MSG_FAST_FORWARD) {
                if (DEBUG)
                    Log.v(TAG, "MSG_FAST_FORWARD");
                removeMessages(MSG_FAST_FORWARD);
                skipAmount = BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_FWD_SEEK;
            } else {
                if (DEBUG)
                    Log.v(TAG, "MSG_REWIND");
                removeMessages(MSG_REWIND);
                skipAmount = -BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_REV_SEEK;
            }
            if (hasMessages(MSG_CHANGE_PLAY_POS) && (skipAmount != mSkipAmount)) {
                Log.w(TAG, "missing release button event:" + mSkipAmount);
            }
            if ((!hasMessages(MSG_CHANGE_PLAY_POS)) || (skipAmount != mSkipAmount)) {
                mSkipStartTime = SystemClock.elapsedRealtime();
            }
            removeMessages(MSG_CHANGE_PLAY_POS);
            if (msg.arg1 == AvrcpConstants.KEY_STATE_PRESS) {
                mSkipAmount = skipAmount;
                changePositionBy(mSkipAmount * getSkipMultiplier());
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            registerNotificationRspPlayStatusNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, playStatus);
            break;
        case MSG_CHANGE_PLAY_POS:
            if (DEBUG)
                Log.v(TAG, "MSG_CHANGE_PLAY_POS:" + msg.arg1);
            changePositionBy(mSkipAmount * getSkipMultiplier());
            if (msg.arg1 * SKIP_PERIOD < BUTTON_TIMEOUT_TIME) {
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = msg.arg1 + 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            break;
        case MSG_SET_A2DP_AUDIO_STATE:
            if (DEBUG)
                Log.v(TAG, "MSG_SET_A2DP_AUDIO_STATE:" + msg.arg1);
            updateA2dpAudioState(msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_FOLDER_ITEMS:
            {
                AvrcpCmd.FolderItemsCmd folderObj = (AvrcpCmd.FolderItemsCmd) msg.obj;
                switch(folderObj.mScope) {
                    case AvrcpConstants.BTRC_SCOPE_PLAYER_LIST:
                        handleMediaPlayerListRsp(folderObj);
                        break;
                    case AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM:
                    case AvrcpConstants.BTRC_SCOPE_NOW_PLAYING:
                        handleGetFolderItemBrowseResponse(folderObj, folderObj.mAddress);
                        break;
                    default:
                        Log.e(TAG, "unknown scope for getfolderitems. scope = " + folderObj.mScope);
                        getFolderItemsRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_SCOPE, (short) 0, (byte) 0, 0, null, null, null, null, null, null, null, null);
                }
                break;
            }
        case MSG_NATIVE_REQ_SET_ADDR_PLAYER:
            // object is bdaddr, argument 1 is the selected player id
            setAddressedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_ITEM_ATTR:
            // msg object contains the item attribute object
            handleGetItemAttr((AvrcpCmd.ItemAttrCmd) msg.obj);
            break;
        case MSG_NATIVE_REQ_SET_BR_PLAYER:
            // argument 1 is the selected player id
            setBrowsedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_CHANGE_PATH:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] folderUid = data.getByteArray("folderUid");
                byte direction = data.getByte("direction");
                if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
                    mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).changePath(folderUid, direction);
                } else {
                    Log.e(TAG, "Remote requesting change path before setbrowsedplayer");
                    changePathRspNative(bdaddr, AvrcpConstants.RSP_BAD_CMD, 0);
                }
                break;
            }
        case MSG_NATIVE_REQ_PLAY_ITEM:
            {
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] uid = data.getByteArray("uid");
                byte scope = data.getByte("scope");
                handlePlayItemResponse(bdaddr, uid, scope);
                break;
            }
        case MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS:
            // argument 1 is scope, object is bdaddr
            handleGetTotalNumOfItemsResponse((byte[]) msg.obj, (byte) msg.arg1);
            break;
        case MSG_NATIVE_REQ_PASS_THROUGH:
            // argument 1 is id, argument 2 is keyState, object is bdaddr
            mAddressedMediaPlayer.handlePassthroughCmd(msg.arg1, msg.arg2, (byte[]) msg.obj, mMediaController);
            break;
        default:
            Log.e(TAG, "unknown message! msg.what=" + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_NATIVE_REQ_GET_RC_FEATURES:
            {
                String address = (String) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_RC_FEATURES: address=" + address + ", features=" + msg.arg1);
                mFeatures = msg.arg1;
                mFeatures = modifyRcFeatureFromBlacklist(mFeatures, address);
                mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
                mLastLocalVolume = -1;
                mRemoteVolume = -1;
                mLocalVolume = -1;
                mInitialRemoteVolume = -1;
                mAddress = address;
                if (mVolumeMapping != null)
                    mVolumeMapping.clear();
                break;
            }
        case MSG_NATIVE_REQ_GET_PLAY_STATUS:
            {
                byte[] address = (byte[]) msg.obj;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_PLAY_STATUS");
                getPlayStatusRspNative(address, convertPlayStateToPlayStatus(mCurrentPlayState), (int) mSongLengthMs, (int) getPlayPosition());
                break;
            }
        case MSG_NATIVE_REQ_GET_ELEM_ATTRS:
            {
                String[] textArray;
                AvrcpCmd.ElementAttrCmd elem = (AvrcpCmd.ElementAttrCmd) msg.obj;
                byte numAttr = elem.mNumAttr;
                int[] attrIds = elem.mAttrIDs;
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_ELEM_ATTRS:numAttr=" + numAttr);
                textArray = new String[numAttr];
                for (int i = 0; i < numAttr; ++i) {
                    textArray[i] = mMediaAttributes.getString(attrIds[i]);
                    Log.v(TAG, "getAttributeString:attrId=" + attrIds[i] + " str=" + textArray[i]);
                }
                byte[] bdaddr = elem.mAddress;
                getElementAttrRspNative(bdaddr, numAttr, attrIds, textArray);
                break;
            }
        case MSG_NATIVE_REQ_REGISTER_NOTIFICATION:
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_REGISTER_NOTIFICATION:event=" + msg.arg1 + " param=" + msg.arg2);
            processRegisterNotification((byte[]) msg.obj, msg.arg1, msg.arg2);
            break;
        case MSG_AVAILABLE_PLAYERS_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_AVAILABLE_PLAYERS_CHANGED_RSP");
            removeMessages(MSG_AVAILABLE_PLAYERS_CHANGED_RSP);
            registerNotificationRspAvalPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
            break;
        case MSG_NOW_PLAYING_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_NOW_PLAYING_CHANGED_RSP");
            removeMessages(MSG_NOW_PLAYING_CHANGED_RSP);
            registerNotificationRspNowPlayingChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED);
            break;
        case MSG_ADDRESSED_PLAYER_CHANGED_RSP:
            if (DEBUG)
                Log.v(TAG, "MSG_ADDRESSED_PLAYER_CHANGED_RSP: newAddrPlayer = " + msg.arg1);
            // Later addressed players override earlier ones.
            if (hasMessages(MSG_ADDRESSED_PLAYER_CHANGED_RSP)) {
                Log.i(TAG, "MSG_ADDRESSED_PLAYER_CHANGED_RSP: skip, more changes in queue");
                break;
            }
            registerNotificationRspAddrPlayerChangedNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, msg.arg1, sUIDCounter);
            break;
        case MSG_PLAY_INTERVAL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_PLAY_INTERVAL_TIMEOUT");
            sendPlayPosNotificationRsp(false);
            break;
        case MSG_NATIVE_REQ_VOLUME_CHANGE:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_NATIVE_REQ_VOLUME_CHANGE");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_VOLUME_CHANGE: volume=" + ((byte) msg.arg1 & 0x7f) + " ctype=" + msg.arg2);
            boolean volAdj = false;
            if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
                if (mVolCmdAdjustInProgress == false && mVolCmdSetInProgress == false) {
                    Log.e(TAG, "Unsolicited response, ignored");
                    break;
                }
                removeMessages(MSG_ABS_VOL_TIMEOUT);
                volAdj = mVolCmdAdjustInProgress;
                mVolCmdAdjustInProgress = false;
                mVolCmdSetInProgress = false;
                mAbsVolRetryTimes = 0;
            }
            // discard MSB as it is RFD
            byte absVol = (byte) ((byte) msg.arg1 & 0x7f);
            // convert remote volume to local volume
            int volIndex = convertToAudioStreamVolume(absVol);
            if (mInitialRemoteVolume == -1) {
                mInitialRemoteVolume = absVol;
                if (mAbsVolThreshold > 0 && mAbsVolThreshold < mAudioStreamMax && volIndex > mAbsVolThreshold) {
                    if (DEBUG)
                        Log.v(TAG, "remote inital volume too high " + volIndex + ">" + mAbsVolThreshold);
                    Message msg1 = mHandler.obtainMessage(MSG_SET_ABSOLUTE_VOLUME, mAbsVolThreshold, 0);
                    mHandler.sendMessage(msg1);
                    mRemoteVolume = absVol;
                    mLocalVolume = volIndex;
                    break;
                }
            }
            if (mLocalVolume != volIndex && (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_CHANGED || msg.arg2 == AVRC_RSP_INTERIM)) {
                /* If the volume has successfully changed */
                mLocalVolume = volIndex;
                if (mLastLocalVolume != -1 && msg.arg2 == AVRC_RSP_ACCEPT) {
                    if (mLastLocalVolume != volIndex) {
                        /* remote volume changed more than requested due to
                             * local and remote has different volume steps */
                        if (DEBUG)
                            Log.d(TAG, "Remote returned volume does not match desired volume " + mLastLocalVolume + " vs " + volIndex);
                        mLastLocalVolume = mLocalVolume;
                    }
                }
                // remember the remote volume value, as it's the one supported by remote
                if (volAdj) {
                    synchronized (mVolumeMapping) {
                        mVolumeMapping.put(volIndex, (int) absVol);
                        if (DEBUG)
                            Log.v(TAG, "remember volume mapping " + volIndex + "-" + absVol);
                    }
                }
                notifyVolumeChanged(mLocalVolume);
                mRemoteVolume = absVol;
                long pecentVolChanged = ((long) absVol * 100) / 0x7f;
                Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
            } else if (msg.arg2 == AVRC_RSP_REJ) {
                Log.e(TAG, "setAbsoluteVolume call rejected");
            } else if (volAdj && mLastRemoteVolume > 0 && mLastRemoteVolume < AVRCP_MAX_VOL && mLocalVolume == volIndex && (msg.arg2 == AVRC_RSP_ACCEPT)) {
                /* oops, the volume is still same, remote does not like the value
                     * retry a volume one step up/down */
                if (DEBUG)
                    Log.d(TAG, "Remote device didn't tune volume, let's try one more step.");
                int retry_volume = Math.min(AVRCP_MAX_VOL, Math.max(0, mLastRemoteVolume + mLastDirection));
                if (setVolumeNative(retry_volume)) {
                    mLastRemoteVolume = retry_volume;
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                }
            }
            break;
        case MSG_ADJUST_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_ADJUST_VOLUME");
                break;
            }
            if (DEBUG)
                Log.d(TAG, "MSG_ADJUST_VOLUME: direction=" + msg.arg1);
            if (mVolCmdAdjustInProgress || mVolCmdSetInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            // Wait on verification on volume from device, before changing the volume.
            if (mRemoteVolume != -1 && (msg.arg1 == -1 || msg.arg1 == 1)) {
                int setVol = -1;
                int targetVolIndex = -1;
                if (mLocalVolume == 0 && msg.arg1 == -1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol down from 0.");
                    break;
                }
                if (mLocalVolume == mAudioStreamMax && msg.arg1 == 1) {
                    if (DEBUG)
                        Log.w(TAG, "No need to Vol up from max.");
                    break;
                }
                targetVolIndex = mLocalVolume + msg.arg1;
                if (DEBUG)
                    Log.d(TAG, "Adjusting volume to  " + targetVolIndex);
                Integer i;
                synchronized (mVolumeMapping) {
                    i = mVolumeMapping.get(targetVolIndex);
                }
                if (i != null) {
                    /* if we already know this volume mapping, use it */
                    setVol = i.byteValue();
                    if (setVol == mRemoteVolume) {
                        if (DEBUG)
                            Log.d(TAG, "got same volume from mapping for " + targetVolIndex + ", ignore.");
                        setVol = -1;
                    }
                    if (DEBUG)
                        Log.d(TAG, "set volume from mapping " + targetVolIndex + "-" + setVol);
                }
                if (setVol == -1) {
                    /* otherwise use phone steps */
                    setVol = Math.min(AVRCP_MAX_VOL, convertToAvrcpVolume(Math.max(0, targetVolIndex)));
                    if (DEBUG)
                        Log.d(TAG, "set volume from local volume " + targetVolIndex + "-" + setVol);
                }
                if (setVolumeNative(setVol)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdAdjustInProgress = true;
                    mLastDirection = msg.arg1;
                    mLastRemoteVolume = setVol;
                    mLastLocalVolume = targetVolIndex;
                } else {
                    if (DEBUG)
                        Log.d(TAG, "setVolumeNative failed");
                }
            } else {
                Log.e(TAG, "Unknown direction in MSG_ADJUST_VOLUME");
            }
            break;
        case MSG_SET_ABSOLUTE_VOLUME:
            if (!isAbsoluteVolumeSupported()) {
                if (DEBUG)
                    Log.v(TAG, "ignore MSG_SET_ABSOLUTE_VOLUME");
                break;
            }
            if (DEBUG)
                Log.v(TAG, "MSG_SET_ABSOLUTE_VOLUME");
            if (mVolCmdSetInProgress || mVolCmdAdjustInProgress) {
                if (DEBUG)
                    Log.w(TAG, "There is already a volume command in progress.");
                break;
            }
            // Remote device didn't set initial volume. Let's black list it
            if (mInitialRemoteVolume == -1) {
                if (DEBUG)
                    Log.d(TAG, "remote " + mAddress + " never tell us initial volume, black list it.");
                blackListCurrentDevice();
                break;
            }
            int avrcpVolume = convertToAvrcpVolume(msg.arg1);
            avrcpVolume = Math.min(AVRCP_MAX_VOL, Math.max(0, avrcpVolume));
            if (DEBUG)
                Log.d(TAG, "Setting volume to " + msg.arg1 + "-" + avrcpVolume);
            if (setVolumeNative(avrcpVolume)) {
                sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                mVolCmdSetInProgress = true;
                mLastRemoteVolume = avrcpVolume;
                mLastLocalVolume = msg.arg1;
            } else {
                if (DEBUG)
                    Log.d(TAG, "setVolumeNative failed");
            }
            break;
        case MSG_ABS_VOL_TIMEOUT:
            if (DEBUG)
                Log.v(TAG, "MSG_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
            mVolCmdAdjustInProgress = false;
            mVolCmdSetInProgress = false;
            if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
                mAbsVolRetryTimes = 0;
                /* too many volume change failures, black list the device */
                blackListCurrentDevice();
            } else {
                mAbsVolRetryTimes += 1;
                if (setVolumeNative(mLastRemoteVolume)) {
                    sendMessageDelayed(obtainMessage(MSG_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
                    mVolCmdSetInProgress = true;
                }
            }
            break;
        case MSG_FAST_FORWARD:
        case MSG_REWIND:
            if (msg.what == MSG_FAST_FORWARD) {
                if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                    int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                    KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_FAST_FORWARD);
                    mMediaController.dispatchMediaButtonEvent(keyEvent);
                    break;
                }
            } else if ((mCurrentPlayState.getActions() & PlaybackState.ACTION_REWIND) != 0) {
                int keyState = msg.arg1 == AvrcpConstants.KEY_STATE_PRESS ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP;
                KeyEvent keyEvent = new KeyEvent(keyState, KeyEvent.KEYCODE_MEDIA_REWIND);
                mMediaController.dispatchMediaButtonEvent(keyEvent);
                break;
            }
            int skipAmount;
            int playStatus;
            if (msg.what == MSG_FAST_FORWARD) {
                if (DEBUG)
                    Log.v(TAG, "MSG_FAST_FORWARD");
                removeMessages(MSG_FAST_FORWARD);
                skipAmount = BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_FWD_SEEK;
            } else {
                if (DEBUG)
                    Log.v(TAG, "MSG_REWIND");
                removeMessages(MSG_REWIND);
                skipAmount = -BASE_SKIP_AMOUNT;
                playStatus = PLAYSTATUS_REV_SEEK;
            }
            if (hasMessages(MSG_CHANGE_PLAY_POS) && (skipAmount != mSkipAmount)) {
                Log.w(TAG, "missing release button event:" + mSkipAmount);
            }
            if ((!hasMessages(MSG_CHANGE_PLAY_POS)) || (skipAmount != mSkipAmount)) {
                mSkipStartTime = SystemClock.elapsedRealtime();
            }
            removeMessages(MSG_CHANGE_PLAY_POS);
            if (msg.arg1 == AvrcpConstants.KEY_STATE_PRESS) {
                mSkipAmount = skipAmount;
                changePositionBy(mSkipAmount * getSkipMultiplier());
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            registerNotificationRspPlayStatusNative(AvrcpConstants.NOTIFICATION_TYPE_CHANGED, playStatus);
            break;
        case MSG_CHANGE_PLAY_POS:
            if (DEBUG)
                Log.v(TAG, "MSG_CHANGE_PLAY_POS:" + msg.arg1);
            changePositionBy(mSkipAmount * getSkipMultiplier());
            if (msg.arg1 * SKIP_PERIOD < BUTTON_TIMEOUT_TIME) {
                Message posMsg = obtainMessage(MSG_CHANGE_PLAY_POS);
                posMsg.arg1 = msg.arg1 + 1;
                sendMessageDelayed(posMsg, SKIP_PERIOD);
            }
            break;
        case MSG_SET_A2DP_AUDIO_STATE:
            if (DEBUG)
                Log.v(TAG, "MSG_SET_A2DP_AUDIO_STATE:" + msg.arg1);
            updateA2dpAudioState(msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_FOLDER_ITEMS:
            {
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_GET_FOLDER_ITEMS");
                AvrcpCmd.FolderItemsCmd folderObj = (AvrcpCmd.FolderItemsCmd) msg.obj;
                switch(folderObj.mScope) {
                    case AvrcpConstants.BTRC_SCOPE_PLAYER_LIST:
                        handleMediaPlayerListRsp(folderObj);
                        break;
                    case AvrcpConstants.BTRC_SCOPE_FILE_SYSTEM:
                    case AvrcpConstants.BTRC_SCOPE_NOW_PLAYING:
                        handleGetFolderItemBrowseResponse(folderObj, folderObj.mAddress);
                        break;
                    default:
                        Log.e(TAG, "unknown scope for getfolderitems. scope = " + folderObj.mScope);
                        getFolderItemsRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_SCOPE, (short) 0, (byte) 0, 0, null, null, null, null, null, null, null, null);
                }
                break;
            }
        case MSG_NATIVE_REQ_SET_ADDR_PLAYER:
            // object is bdaddr, argument 1 is the selected player id
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_SET_ADDR_PLAYER id=" + msg.arg1);
            setAddressedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_GET_ITEM_ATTR:
            // msg object contains the item attribute object
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_GET_ITEM_ATTR");
            handleGetItemAttr((AvrcpCmd.ItemAttrCmd) msg.obj);
            break;
        case MSG_NATIVE_REQ_SET_BR_PLAYER:
            // argument 1 is the selected player id
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_SET_BR_PLAYER id=" + msg.arg1);
            setBrowsedPlayer((byte[]) msg.obj, msg.arg1);
            break;
        case MSG_NATIVE_REQ_CHANGE_PATH:
            {
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_CHANGE_PATH");
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] folderUid = data.getByteArray("folderUid");
                byte direction = data.getByte("direction");
                if (mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr) != null) {
                    mAvrcpBrowseManager.getBrowsedMediaPlayer(bdaddr).changePath(folderUid, direction);
                } else {
                    Log.e(TAG, "Remote requesting change path before setbrowsedplayer");
                    changePathRspNative(bdaddr, AvrcpConstants.RSP_BAD_CMD, 0);
                }
                break;
            }
        case MSG_NATIVE_REQ_PLAY_ITEM:
            {
                if (DEBUG)
                    Log.v(TAG, "MSG_NATIVE_REQ_PLAY_ITEM");
                Bundle data = msg.getData();
                byte[] bdaddr = data.getByteArray("BdAddress");
                byte[] uid = data.getByteArray("uid");
                byte scope = data.getByte("scope");
                handlePlayItemResponse(bdaddr, uid, scope);
                break;
            }
        case MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS:
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_GET_TOTAL_NUM_OF_ITEMS scope=" + msg.arg1);
            // argument 1 is scope, object is bdaddr
            handleGetTotalNumOfItemsResponse((byte[]) msg.obj, (byte) msg.arg1);
            break;
        case MSG_NATIVE_REQ_PASS_THROUGH:
            if (DEBUG)
                Log.v(TAG, "MSG_NATIVE_REQ_PASS_THROUGH: id=" + msg.arg1 + " state=" + msg.arg2);
            // argument 1 is id, argument 2 is keyState, object is bdaddr
            mAddressedMediaPlayer.handlePassthroughCmd(msg.arg1, msg.arg2, (byte[]) msg.obj, mMediaController);
            break;
        default:
            Log.e(TAG, "unknown message! msg.what=" + msg.what);
            break;
    }
}
#end_block

#method_before
private void buildMediaPlayersList() {
    initMediaPlayersInfoList();
    if (mMediaPlayerInfoList.size() > 0) {
        // Set the first one as the Addressed Player
        updateCurrentController(mMediaPlayerInfoList.firstKey(), -1);
    } else {
        Log.i(TAG, "No players available in the media players list");
        /* No players have started. Start one so we can passthrough commands. */
        if ((mBrowsePlayerInfoList != null) && (mBrowsePlayerInfoList.size() > 0)) {
            BrowsePlayerInfo player = mBrowsePlayerInfoList.get(0);
            Intent intent = new Intent();
            intent.setComponent(new ComponentName(player.packageName, player.serviceClass));
            Log.i(TAG, "Starting service:" + player.packageName + ", " + player.serviceClass);
            try {
                mContext.startService(intent);
            } catch (SecurityException ex) {
                Log.e(TAG, "Can't start " + player.serviceClass + ": " + ex.getMessage());
            }
        } else {
            Log.e(TAG, "Opening player to support AVRCP operations failed, " + "No browsable players available!");
        }
    }
}
#method_after
private void buildMediaPlayersList() {
    initMediaPlayersInfoList();
    if (mMediaPlayerInfoList.size() > 0) {
        // Set the first one as the Addressed Player
        updateCurrentController(mMediaPlayerInfoList.firstKey(), -1);
    }
}
#end_block

#method_before
private void handleMediaPlayerListRsp(AvrcpCmd.FolderItemsCmd folderObj) {
    if (folderObj.mStartItem >= mMediaPlayerInfoList.size()) {
        Log.i(TAG, "handleMediaPlayerListRsp: start item = " + folderObj.mStartItem + ", but available num of items = " + mMediaPlayerInfoList.size());
        mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_RANGE, (short) 0, (byte) 0, 0, null, null, null, null, null, null);
        return;
    }
    MediaPlayerListRsp rspObj = prepareMediaPlayerRspObj();
    if (DEBUG)
        Log.d(TAG, "handleMediaPlayerListRsp: send " + rspObj.mNumItems + " players");
    mediaPlayerListRspNative(folderObj.mAddress, rspObj.mStatus, rspObj.mUIDCounter, rspObj.itemType, rspObj.mNumItems, rspObj.mPlayerIds, rspObj.mPlayerTypes, rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues, rspObj.mFeatureBitMaskValues, rspObj.mPlayerNameList);
}
#method_after
private void handleMediaPlayerListRsp(AvrcpCmd.FolderItemsCmd folderObj) {
    if (mMediaPlayerInfoList.size() == 0) {
        mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_NO_AVBL_PLAY, (short) 0, (byte) 0, 0, null, null, null, null, null, null);
        return;
    }
    if (folderObj.mStartItem >= mMediaPlayerInfoList.size()) {
        Log.i(TAG, "handleMediaPlayerListRsp: start item = " + folderObj.mStartItem + ", but available num of items = " + mMediaPlayerInfoList.size());
        mediaPlayerListRspNative(folderObj.mAddress, AvrcpConstants.RSP_INV_RANGE, (short) 0, (byte) 0, 0, null, null, null, null, null, null);
        return;
    }
    MediaPlayerListRsp rspObj = prepareMediaPlayerRspObj();
    if (DEBUG)
        Log.d(TAG, "handleMediaPlayerListRsp: send " + rspObj.mNumItems + " players");
    mediaPlayerListRspNative(folderObj.mAddress, rspObj.mStatus, rspObj.mUIDCounter, rspObj.itemType, rspObj.mNumItems, rspObj.mPlayerIds, rspObj.mPlayerTypes, rspObj.mPlayerSubTypes, rspObj.mPlayStatusValues, rspObj.mFeatureBitMaskValues, rspObj.mPlayerNameList);
}
#end_block

#method_before
private boolean updateCurrentController(int addrId, int browseId) {
    boolean registerRsp = true;
    updateNewIds(addrId, browseId);
    MediaController newController = null;
    MediaPlayerInfo info = getAddressedPlayerInfo();
    if (info != null)
        newController = info.getMediaController();
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: " + mMediaController + " to " + newController);
    if (mMediaController == null || newController == null || (mMediaController.getWrappedInstance() != newController.getWrappedInstance())) {
        if (mMediaController != null)
            mMediaController.unregisterCallback(mMediaControllerCb);
        if (newController != null) {
            mMediaController = newController;
            mMediaController.registerCallback(mMediaControllerCb, mHandler);
            updateMetadata(mMediaController.getMetadata());
            mAddressedMediaPlayer.updateNowPlayingList(mMediaController.getQueue());
        } else {
            updateMetadata(null);
            mAddressedMediaPlayer.updateNowPlayingList(null);
            registerRsp = false;
        }
    }
    return registerRsp;
}
#method_after
private boolean updateCurrentController(int addrId, int browseId) {
    boolean registerRsp = true;
    updateNewIds(addrId, browseId);
    MediaController newController = null;
    MediaPlayerInfo info = getAddressedPlayerInfo();
    if (info != null) {
        newController = info.getMediaController();
        if (newController == null) {
            // Browsable player, try to start it, which will trigger an update via
            // MesiaSessionManager
            startBrowsedPlayer(getBrowseId(info.getPackageName()));
        }
    }
    if (DEBUG)
        Log.d(TAG, "updateCurrentController: " + mMediaController + " to " + newController);
    if (mMediaController == null || newController == null || (mMediaController.getWrappedInstance() != newController.getWrappedInstance())) {
        if (mMediaController != null)
            mMediaController.unregisterCallback(mMediaControllerCb);
        if (newController != null) {
            mMediaController = newController;
            mMediaController.registerCallback(mMediaControllerCb, mHandler);
            updateMetadata(mMediaController.getMetadata());
            mAddressedMediaPlayer.updateNowPlayingList(mMediaController.getQueue());
        } else {
            updateMetadata(null);
            mAddressedMediaPlayer.updateNowPlayingList(null);
            registerRsp = false;
        }
    }
    return registerRsp;
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_signed() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void halving_add_signed() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + b2[i]) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_signed(short[], short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed(short[], short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:false rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_signed(short[] b1, short[] b2, short[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + b2[i]) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff)) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned(short[], short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned(short[], short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned(short[] b1, short[] b2, short[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff)) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_signed() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_signed() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void rounding_halving_add_signed() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_signed(short[], short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_signed(short[], short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:false rounded:true loop:<<Loop>> outer_loop:none
private static void rounding_halving_add_signed(short[] b1, short[] b2, short[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void rounding_halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff) + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_unsigned(short[], short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:s\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<UMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned(short[], short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:true loop:<<Loop>> outer_loop:none
private static void rounding_halving_add_unsigned(short[] b1, short[] b2, short[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff) + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_signed_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<SMAX:i\d+>> IntConstant 32767                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<SMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed_constant() loop_optimization (after)
// / CHECK-DAG: <<SMAX:i\d+>> IntConstant 32767                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<SMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
private static void halving_add_signed_constant() {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + 0x7fff) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_signed_constant(short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<SMAX:i\d+>> IntConstant 32767                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<SMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed_constant(short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<SMAX:i\d+>> IntConstant 32767                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<SMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:false rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_signed_constant(short[] b1, short[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) ((b1[i] + 0x7fff) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant() loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned_constant() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + 0xffff) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned_constant(short[], short[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant(short[], short[]) loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned_constant(short[] b1, short[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (short) (((b1[i] & 0xffff) + 0xffff) >> 1);
    }
}
#end_block

#method_before
public static void main(String[] args) {
    // Some interesting values.
    short[] interesting = { (short) 0x0000, (short) 0x0001, (short) 0x0002, (short) 0x1234, (short) 0x8000, (short) 0x8001, (short) 0x7fff, (short) 0xffff };
    // set up some extra values to exercise the cleanup loop.
    for (int i = 0; i < M; i++) {
        b1[i] = (short) i;
        b2[i] = interesting[i & 7];
    }
    // Test halving add idioms.
    halving_add_signed();
    for (int i = 0; i < M; i++) {
        short e = (short) ((b1[i] + b2[i]) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        short e = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff)) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_signed();
    for (int i = 0; i < M; i++) {
        short e = (short) ((b1[i] + b2[i] + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        short e = (short) (((b1[i] & 0xffff) + (b2[i] & 0xffff) + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_signed_constant();
    for (int i = 0; i < M; i++) {
        short e = (short) ((b1[i] + 0x7fff) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_unsigned_constant();
    for (int i = 0; i < M; i++) {
        short e = (short) (((b1[i] & 0xffff) + 0xffff) >> 1);
        expectEquals(e, bo[i]);
    }
    System.out.println("passed");
}
#method_after
public static void main(String[] args) {
    // Some interesting values.
    short[] interesting = { (short) 0x0000, (short) 0x0001, (short) 0x0002, (short) 0x1234, (short) 0x8000, (short) 0x8001, (short) 0x7fff, (short) 0xffff };
    // set up some extra values to exercise the cleanup loop.
    for (int i = 0; i < M; i++) {
        sB1[i] = (short) i;
        sB2[i] = interesting[i & 7];
    }
    // Test halving add idioms.
    halving_add_signed(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) ((sB1[i] + sB2[i]) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) (((sB1[i] & 0xffff) + (sB2[i] & 0xffff)) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_signed(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) ((sB1[i] + sB2[i] + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) (((sB1[i] & 0xffff) + (sB2[i] & 0xffff) + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_signed_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) ((sB1[i] + 0x7fff) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_unsigned_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        short e = (short) (((sB1[i] & 0xffff) + 0xffff) >> 1);
        expectEquals(e, sBo[i]);
    }
    System.out.println("passed");
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + b2[i]) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned(char[], char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned(char[], char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned(char[] b1, char[] b2, char[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + b2[i]) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_also_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_also_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void halving_add_also_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + (b2[i] & 0xffff)) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_also_unsigned(char[], char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_also_unsigned(char[], char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void halving_add_also_unsigned(char[] b1, char[] b2, char[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + (b2[i] & 0xffff)) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void rounding_halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_unsigned(char[], char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned(char[], char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:true loop:<<Loop>> outer_loop:none
private static void rounding_halving_add_unsigned(char[] b1, char[] b2, char[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_also_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_also_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void rounding_halving_add_also_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + (b2[i] & 0xffff) + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_also_unsigned(char[], char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<IMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:c\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<IMAX>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_also_unsigned(char[], char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:true loop:<<Loop>> outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void rounding_halving_add_also_unsigned(char[] b1, char[] b2, char[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + (b2[i] & 0xffff) + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant() loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned_constant() {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + 0xffff) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned_constant(char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:c\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant(char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned_constant(char[] b1, char[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) ((b1[i] + 0xffff) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_also_unsigned_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:s\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:s\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_also_unsigned_constant() loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void halving_add_also_unsigned_constant() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + 0xffff) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_also_unsigned_constant(char[], char[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                   loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:c\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<UMAX>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:c\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_also_unsigned_constant(char[], char[]) loop_optimization (after)
// / CHECK-DAG: <<UMAX:i\d+>> IntConstant 65535                    loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<UMAX>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
// / CHECK-DAG:               VecStore [{{l\d+}},<<Phi>>,<<HAdd>>] loop:<<Loop>>      outer_loop:none
// 
// Note: HAnd has no impact (already a zero extension).
private static void halving_add_also_unsigned_constant(char[] b1, char[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (char) (((b1[i] & 0xffff) + 0xffff) >> 1);
    }
}
#end_block

#method_before
public static void main(String[] args) {
    // Some interesting values.
    char[] interesting = { (char) 0x0000, (char) 0x0001, (char) 0x0002, (char) 0x1234, (char) 0x8000, (char) 0x8001, (char) 0x7fff, (char) 0xffff };
    // set up some extra values to exercise the cleanup loop.
    for (int i = 0; i < M; i++) {
        b1[i] = (char) i;
        b2[i] = interesting[i & 7];
    }
    // Test halving add idioms.
    halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + b2[i]) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_also_unsigned();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + b2[i]) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + b2[i] + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_also_unsigned();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + b2[i] + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_unsigned_constant();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + 0xffff) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_also_unsigned_constant();
    for (int i = 0; i < M; i++) {
        char e = (char) ((b1[i] + 0xffff) >> 1);
        expectEquals(e, bo[i]);
    }
    System.out.println("passed");
}
#method_after
public static void main(String[] args) {
    // Some interesting values.
    char[] interesting = { (char) 0x0000, (char) 0x0001, (char) 0x0002, (char) 0x1234, (char) 0x8000, (char) 0x8001, (char) 0x7fff, (char) 0xffff };
    // set up some extra values to exercise the cleanup loop.
    for (int i = 0; i < M; i++) {
        sB1[i] = (char) i;
        sB2[i] = interesting[i & 7];
    }
    // Test halving add idioms.
    halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + sB2[i]) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_also_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + sB2[i]) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + sB2[i] + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_also_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + sB2[i] + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_unsigned_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + 0xffff) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_also_unsigned_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        char e = (char) ((sB1[i] + 0xffff) >> 1);
        expectEquals(e, sBo[i]);
    }
    System.out.println("passed");
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_signed() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void halving_add_signed() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + b2[i]) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_signed(byte[], byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed(byte[], byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:false rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_signed(byte[] b1, byte[] b2, byte[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + b2[i]) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff)) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned(byte[], byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned(byte[], byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned(byte[] b1, byte[] b2, byte[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff)) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_signed() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_signed() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void rounding_halving_add_signed() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_signed(byte[], byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<Get1>>,<<Get2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_signed(byte[], byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>] unsigned:false rounded:true loop:<<Loop>> outer_loop:none
private static void rounding_halving_add_signed(byte[] b1, byte[] b2, byte[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + b2[i] + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.rounding_halving_add_unsigned() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned() loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]    loop:<<Loop>>      outer_loop:none
private static void rounding_halving_add_unsigned() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff) + 1) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.rounding_halving_add_unsigned(byte[], byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:b\d+>> ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And1:i\d+>> And [<<Get1>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And2:i\d+>> And [<<Get2>>,<<I255>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add1:i\d+>> Add [<<And1>>,<<And2>>]             loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add2:i\d+>> Add [<<Add1>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add2>>,<<I1>>]               loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.rounding_halving_add_unsigned(byte[], byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get1:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Get2:d\d+>> VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get1>>,<<Get2>>]  unsigned:true rounded:true loop:<<Loop>> outer_loop:none
private static void rounding_halving_add_unsigned(byte[] b1, byte[] b2, byte[] bo) {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff) + 1) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_signed_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I127:i\d+>> IntConstant 127                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:b\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<I127>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed_constant() loop_optimization (after)
// / CHECK-DAG: <<I127:i\d+>> IntConstant 127                      loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I127>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
private static void halving_add_signed_constant() {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + 0x7f) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_signed_constant(byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I127:i\d+>> IntConstant 127                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:b\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<Get>>,<<I127>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_signed_constant(byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<I127:i\d+>> IntConstant 127                      loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I127>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:false rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_signed_constant(byte[] b1, byte[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) ((b1[i] + 0x7f) >> 1);
    }
}
#end_block

#method_before
// / CHECK-START: void Main.halving_add_unsigned_constant() loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:b\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<I255>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<I255>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant() loop_optimization (after)
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                      loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I255>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>]     loop:<<Loop>>      outer_loop:none
private static void halving_add_unsigned_constant() {
    int min_length = Math.min(bo.length, Math.min(b1.length, b2.length));
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + 0xff) >> 1);
    }
}
#method_after
// / CHECK-START: void Main.halving_add_unsigned_constant(byte[], byte[]) loop_optimization (before)
// / CHECK-DAG: <<I1:i\d+>>   IntConstant 1                       loop:none
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                     loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                 loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:b\d+>>  ArrayGet                            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<And:i\d+>>  And [<<Get>>,<<I255>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Add:i\d+>>  Add [<<And>>,<<I255>>]              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Shr:i\d+>>  Shr [<<Add>>,<<I1>>]                loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<Cnv:b\d+>>  TypeConversion [<<Shr>>]            loop:<<Loop>>      outer_loop:none
// / CHECK-DAG:               ArraySet [{{l\d+}},<<Phi>>,<<Cnv>>] loop:<<Loop>>      outer_loop:none
// 
// / CHECK-START-ARM64: void Main.halving_add_unsigned_constant(byte[], byte[]) loop_optimization (after)
// / CHECK-DAG: <<I255:i\d+>> IntConstant 255                      loop:none
// / CHECK-DAG: <<Repl:d\d+>> VecReplicateScalar [<<I255>>]        loop:none
// / CHECK-DAG: <<Phi:i\d+>>  Phi                                  loop:<<Loop:B\d+>> outer_loop:none
// / CHECK-DAG: <<Get:d\d+>>  VecLoad                              loop:<<Loop>>      outer_loop:none
// / CHECK-DAG: <<HAdd:d\d+>> VecHalvingAdd [<<Get>>,<<Repl>>] unsigned:true rounded:false loop:<<Loop>> outer_loop:none
private static void halving_add_unsigned_constant(byte[] b1, byte[] bo) {
    int min_length = Math.min(bo.length, b1.length);
    for (int i = 0; i < min_length; i++) {
        bo[i] = (byte) (((b1[i] & 0xff) + 0xff) >> 1);
    }
}
#end_block

#method_before
public static void main(String[] args) {
    // Initialize cross-values to test all cases, and also
    // set up some extra values to exercise the cleanup loop.
    int k = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            b1[k] = (byte) i;
            b2[k] = (byte) j;
            k++;
        }
    }
    for (int i = 0; i < 15; i++) {
        b1[k] = (byte) i;
        b2[k] = 100;
        k++;
    }
    expectEquals(k, M);
    // Test halving add idioms.
    halving_add_signed();
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((b1[i] + b2[i]) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff)) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_signed();
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((b1[i] + b2[i] + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    rounding_halving_add_unsigned();
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((b1[i] & 0xff) + (b2[i] & 0xff) + 1) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_signed_constant();
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((b1[i] + 0x7f) >> 1);
        expectEquals(e, bo[i]);
    }
    halving_add_unsigned_constant();
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((b1[i] & 0xff) + 0xff) >> 1);
        expectEquals(e, bo[i]);
    }
    System.out.println("passed");
}
#method_after
public static void main(String[] args) {
    // Initialize cross-values to test all cases, and also
    // set up some extra values to exercise the cleanup loop.
    int k = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            sB1[k] = (byte) i;
            sB2[k] = (byte) j;
            k++;
        }
    }
    for (int i = 0; i < 15; i++) {
        sB1[k] = (byte) i;
        sB2[k] = 100;
        k++;
    }
    expectEquals(k, M);
    // Test halving add idioms.
    halving_add_signed(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((sB1[i] + sB2[i]) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((sB1[i] & 0xff) + (sB2[i] & 0xff)) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_signed(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((sB1[i] + sB2[i] + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    rounding_halving_add_unsigned(sB1, sB2, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((sB1[i] & 0xff) + (sB2[i] & 0xff) + 1) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_signed_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) ((sB1[i] + 0x7f) >> 1);
        expectEquals(e, sBo[i]);
    }
    halving_add_unsigned_constant(sB1, sBo);
    for (int i = 0; i < M; i++) {
        byte e = (byte) (((sB1[i] & 0xff) + 0xff) >> 1);
        expectEquals(e, sBo[i]);
    }
    System.out.println("passed");
}
#end_block

#method_before
public byte read(byte[] keyBuffer, short keyOffset, byte[] outBuffer, short outOffset) {
    // mBackoffTimer.getRemainingTime(sRemainingBackoff, (short) 0);
    if (sRemainingBackoff[0] != 0 || sRemainingBackoff[1] != 0 || sRemainingBackoff[2] != 0 || sRemainingBackoff[3] != 0) {
        Util.arrayCopyNonAtomic(sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4);
        return Consts.READ_BACK_OFF;
    }
    // Check the key matches and copy out the value if it does
    byte result = Consts.READ_WRONG_KEY;
    if (Util.arrayCompare(keyBuffer, keyOffset, mKey, (short) 0, Consts.SLOT_KEY_BYTES) == 0) {
        return Consts.READ_SUCCESS;
    }
    JCSystem.beginTransaction();
    if (result == Consts.READ_WRONG_KEY) {
        if (mFailureCount != 0x7fff) {
            mFailureCount += 1;
        }
        if (throttle(sRemainingBackoff, (short) 0, mFailureCount)) {
        // mBackoffTimer.startTimer(
        // sRemainingBackoff, (short) 0, DSTimer.DST_POWEROFFMODE_FALLBACK);
        }
        Util.arrayCopyNonAtomic(sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4);
    } else {
        // This attempt was successful so reset the failures
        mFailureCount = 0;
        // mBackoffTimer.stopTimer();
        Util.arrayCopyNonAtomic(mValue, (short) 0, outBuffer, outOffset, Consts.SLOT_VALUE_BYTES);
    }
    JCSystem.commitTransaction();
    return result;
}
#method_after
public byte read(byte[] keyBuffer, short keyOffset, byte[] outBuffer, short outOffset) {
    // Check timeout has expired or hasn't been started
    // TODO: bring back the timer
    // mBackoffTimer.getRemainingTime(sRemainingBackoff, (short) 0);
    Util.setShort(sRemainingBackoff, (short) 0, (short) 0);
    Util.setShort(sRemainingBackoff, (short) 2, (short) 0);
    if (sRemainingBackoff[0] != 0 || sRemainingBackoff[1] != 0 || sRemainingBackoff[2] != 0 || sRemainingBackoff[3] != 0) {
        Util.arrayCopyNonAtomic(sRemainingBackoff, (short) 0, outBuffer, outOffset, (byte) 4);
        return Consts.READ_BACK_OFF;
    }
    // Check the key matches in constant time and copy out the value if it does
    byte difference = 0;
    for (short i = 0; i < Consts.SLOT_KEY_BYTES; ++i) {
        difference |= keyBuffer[(short) (keyOffset + i)] ^ mKey[i];
    }
    final byte result = (difference == 0) ? Consts.READ_SUCCESS : Consts.READ_WRONG_KEY;
    // Keep track of the number of failures
    if (result == Consts.READ_WRONG_KEY) {
        if (mFailureCount != 0x7fff) {
            mFailureCount += 1;
        }
    } else {
        // This read was successful so reset the failures
        if (mFailureCount != 0) {
            // attempt to maintain constant time
            mFailureCount = 0;
        }
    }
    // Start the timer on a failure
    if (throttle(sRemainingBackoff, (short) 0, mFailureCount)) {
    // mBackoffTimer.startTimer(
    // sRemainingBackoff, (short) 0, DSTimer.DST_POWEROFFMODE_FALLBACK);
    } else {
    // mBackoffTimer.stopTimer();
    }
    final byte[] data = (result == Consts.READ_SUCCESS) ? mValue : sRemainingBackoff;
    Util.arrayCopyNonAtomic(data, (short) 0, outBuffer, outOffset, Consts.SLOT_VALUE_BYTES);
    return result;
}
#end_block

#method_before
public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
        // is out of bounds.
        throw new IllegalArgumentException("Priority out of range: " + priority);
    }
    if ((g = getThreadGroup()) != null) {
        if (newPriority > g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        synchronized (this) {
            this.priority = newPriority;
            if (isAlive()) {
                nativeSetPriority(newPriority);
            }
        }
    }
}
#method_after
public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
        // is out of bounds.
        throw new IllegalArgumentException("Priority out of range: " + newPriority);
    }
    if ((g = getThreadGroup()) != null) {
        if (newPriority > g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        synchronized (this) {
            this.priority = newPriority;
            if (isAlive()) {
                nativeSetPriority(newPriority);
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean acceptRequest(NetworkRequest request, int score) {
    if (VDBG) {
        Log.v(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + ", score=" + score);
    }
    if (!mMgr.isUsageEnabled()) {
        if (VDBG) {
            Log.v(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " -- Aware disabled");
        }
        return false;
    }
    if (mInterfaces.isEmpty()) {
        Log.w(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " -- No Aware interfaces are up");
        return false;
    }
    NetworkSpecifier networkSpecifierBase = request.networkCapabilities.getNetworkSpecifier();
    if (!(networkSpecifierBase instanceof WifiAwareNetworkSpecifier)) {
        Log.w(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - not a WifiAwareNetworkSpecifier");
        return false;
    }
    WifiAwareNetworkSpecifier networkSpecifier = (WifiAwareNetworkSpecifier) networkSpecifierBase;
    // look up specifier - are we being called again?
    AwareNetworkRequestInformation nnri = mNetworkRequestsCache.get(networkSpecifier);
    if (nnri != null) {
        if (DBG) {
            Log.d(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - already in cache!?");
        }
        // requests again!?
        return true;
    }
    // parse network specifier (JSON) & cache
    // TODO: validate that the client ID actually comes from the correct process and is
    // not faked?
    nnri = AwareNetworkRequestInformation.processNetworkSpecifier(networkSpecifier, mMgr);
    if (nnri == null) {
        Log.e(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - can't parse network specifier");
        return false;
    }
    mNetworkRequestsCache.put(networkSpecifier, nnri);
    return true;
}
#method_after
@Override
public boolean acceptRequest(NetworkRequest request, int score) {
    if (VDBG) {
        Log.v(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + ", score=" + score);
    }
    if (!mMgr.isUsageEnabled()) {
        if (VDBG) {
            Log.v(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " -- Aware disabled");
        }
        return false;
    }
    if (mInterfaces.isEmpty()) {
        Log.w(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " -- No Aware interfaces are up");
        return false;
    }
    NetworkSpecifier networkSpecifierBase = request.networkCapabilities.getNetworkSpecifier();
    if (!(networkSpecifierBase instanceof WifiAwareNetworkSpecifier)) {
        Log.w(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - not a WifiAwareNetworkSpecifier");
        return false;
    }
    WifiAwareNetworkSpecifier networkSpecifier = (WifiAwareNetworkSpecifier) networkSpecifierBase;
    // look up specifier - are we being called again?
    AwareNetworkRequestInformation nnri = mNetworkRequestsCache.get(networkSpecifier);
    if (nnri != null) {
        if (DBG) {
            Log.d(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - already in cache!?");
        }
        // requests again!?
        return true;
    }
    // TODO: validate that the client ID actually comes from the correct process and is
    // not faked?
    nnri = AwareNetworkRequestInformation.processNetworkSpecifier(networkSpecifier, mMgr);
    if (nnri == null) {
        Log.e(TAG, "WifiAwareNetworkFactory.acceptRequest: request=" + request + " - can't parse network specifier");
        return false;
    }
    mNetworkRequestsCache.put(networkSpecifier, nnri);
    return true;
}
#end_block

#method_before
/*
     * Utilities
     */
private void testDataPathInitiatorResponderMismatchUtility(boolean doPublish) throws Exception {
    final int clientId = 123;
    final int pubSubId = 11234;
    final int ndpId = 2;
    final byte[] pmk = "some bytes".getBytes();
    final PeerHandle peerHandle = new PeerHandle(1341234);
    final byte[] peerDiscoveryMac = HexEncoding.decode("000102030405".toCharArray(), false);
    InOrder inOrder = inOrder(mMockNative, mMockCm, mMockCallback, mMockSessionCallback);
    // (0) initialize
    Pair<Integer, Messenger> res = initDataPathEndPoint(clientId, pubSubId, peerHandle, peerDiscoveryMac, inOrder, doPublish);
    // (1) request network
    NetworkRequest nr = getSessionNetworkRequest(clientId, res.first, peerHandle, pmk, doPublish);
    // corrupt the network specifier: reverse the role (so it's mis-matched)
    WifiAwareNetworkSpecifier ns = (WifiAwareNetworkSpecifier) nr.networkCapabilities.getNetworkSpecifier();
    // corruption hack
    ns.role = 1 - ns.role;
    Message reqNetworkMsg = Message.obtain();
    reqNetworkMsg.what = NetworkFactory.CMD_REQUEST_NETWORK;
    reqNetworkMsg.obj = nr;
    reqNetworkMsg.arg1 = 0;
    res.second.send(reqNetworkMsg);
    mMockLooper.dispatchAll();
    // Initiator (subscribe): doesn't initiate (i.e. no HAL requests)
    if (doPublish) {
        // (2) get request & respond
        mDut.onDataPathRequestNotification(pubSubId, peerDiscoveryMac, ndpId);
        mMockLooper.dispatchAll();
        inOrder.verify(mMockNative).respondToDataPathRequest(anyShort(), eq(false), eq(ndpId), eq(""), eq(null), eq(null), any());
    }
    verifyNoMoreInteractions(mMockNative, mMockCm);
}
#method_after
/*
     * Utilities
     */
private void testDataPathInitiatorResponderMismatchUtility(boolean doPublish) throws Exception {
    final int clientId = 123;
    final int pubSubId = 11234;
    final int ndpId = 2;
    final byte[] pmk = "some bytes".getBytes();
    final PeerHandle peerHandle = new PeerHandle(1341234);
    final byte[] peerDiscoveryMac = HexEncoding.decode("000102030405".toCharArray(), false);
    InOrder inOrder = inOrder(mMockNative, mMockCm, mMockCallback, mMockSessionCallback);
    // (0) initialize
    Pair<Integer, Messenger> res = initDataPathEndPoint(clientId, pubSubId, peerHandle, peerDiscoveryMac, inOrder, doPublish);
    // (1) request network
    NetworkRequest nr = getSessionNetworkRequest(clientId, res.first, peerHandle, pmk, doPublish);
    // corrupt the network specifier: reverse the role (so it's mis-matched)
    WifiAwareNetworkSpecifier ns = (WifiAwareNetworkSpecifier) nr.networkCapabilities.getNetworkSpecifier();
    ns = new WifiAwareNetworkSpecifier(ns.type, // corruption hack
    1 - ns.role, ns.clientId, ns.sessionId, ns.peerId, ns.peerMac, ns.pmk, ns.passphrase);
    nr.networkCapabilities.setNetworkSpecifier(ns);
    Message reqNetworkMsg = Message.obtain();
    reqNetworkMsg.what = NetworkFactory.CMD_REQUEST_NETWORK;
    reqNetworkMsg.obj = nr;
    reqNetworkMsg.arg1 = 0;
    res.second.send(reqNetworkMsg);
    mMockLooper.dispatchAll();
    // Initiator (subscribe): doesn't initiate (i.e. no HAL requests)
    if (doPublish) {
        // (2) get request & respond
        mDut.onDataPathRequestNotification(pubSubId, peerDiscoveryMac, ndpId);
        mMockLooper.dispatchAll();
        inOrder.verify(mMockNative).respondToDataPathRequest(anyShort(), eq(false), eq(ndpId), eq(""), eq(null), eq(null), any());
    }
    verifyNoMoreInteractions(mMockNative, mMockCm);
}
#end_block

#method_before
public NetworkSpecifier createNetworkSpecifier(int clientId, int role, int sessionId, PeerHandle peerHandle, @Nullable byte[] pmk, @Nullable String passphrase) {
    if (VDBG) {
        Log.v(TAG, "createNetworkSpecifier: role=" + role + ", sessionId=" + sessionId + ", peerHandle=" + ((peerHandle == null) ? peerHandle : peerHandle.peerId) + ", pmk=" + ((pmk == null) ? "null" : "non-null") + ", passphrase=" + ((passphrase == null) ? "null" : "non-null"));
    }
    WifiAwareNetworkSpecifier ns = new WifiAwareNetworkSpecifier();
    ns.type = (peerHandle == null) ? WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_IB_ANY_PEER : WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_IB;
    if (role != WIFI_AWARE_DATA_PATH_ROLE_INITIATOR && role != WIFI_AWARE_DATA_PATH_ROLE_RESPONDER) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid 'role' argument when creating a network " + "specifier");
    }
    if (role == WIFI_AWARE_DATA_PATH_ROLE_INITIATOR) {
        if (peerHandle == null) {
            throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer handle (value of null) - not " + "permitted on INITIATOR");
        }
    }
    ns.role = role;
    ns.clientId = clientId;
    ns.sessionId = sessionId;
    if (peerHandle != null) {
        ns.peerId = peerHandle.peerId;
    }
    ns.pmk = pmk;
    ns.passphrase = passphrase;
    return ns;
}
#method_after
public NetworkSpecifier createNetworkSpecifier(int clientId, int role, int sessionId, PeerHandle peerHandle, @Nullable byte[] pmk, @Nullable String passphrase) {
    if (VDBG) {
        Log.v(TAG, "createNetworkSpecifier: role=" + role + ", sessionId=" + sessionId + ", peerHandle=" + ((peerHandle == null) ? peerHandle : peerHandle.peerId) + ", pmk=" + ((pmk == null) ? "null" : "non-null") + ", passphrase=" + ((passphrase == null) ? "null" : "non-null"));
    }
    if (role != WIFI_AWARE_DATA_PATH_ROLE_INITIATOR && role != WIFI_AWARE_DATA_PATH_ROLE_RESPONDER) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid 'role' argument when creating a network " + "specifier");
    }
    if (role == WIFI_AWARE_DATA_PATH_ROLE_INITIATOR) {
        if (peerHandle == null) {
            throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer handle (value of null) - not " + "permitted on INITIATOR");
        }
    }
    return new WifiAwareNetworkSpecifier((peerHandle == null) ? WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_IB_ANY_PEER : WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_IB, role, clientId, sessionId, // 0 is an invalid peer ID
    peerHandle != null ? peerHandle.peerId : 0, // peerMac (not used in this method)
    null, pmk, passphrase);
}
#end_block

#method_before
public NetworkSpecifier createNetworkSpecifier(int clientId, @DataPathRole int role, @Nullable byte[] peer, @Nullable byte[] pmk, @Nullable String passphrase) {
    if (VDBG) {
        Log.v(TAG, "createNetworkSpecifier: role=" + role + ", pmk=" + ((pmk == null) ? "null" : "non-null") + ", passphrase=" + ((passphrase == null) ? "null" : "non-null"));
    }
    WifiAwareNetworkSpecifier ns = new WifiAwareNetworkSpecifier();
    ns.type = (peer == null) ? WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_OOB_ANY_PEER : WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_OOB;
    if (role != WIFI_AWARE_DATA_PATH_ROLE_INITIATOR && role != WIFI_AWARE_DATA_PATH_ROLE_RESPONDER) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid 'role' argument when creating a network " + "specifier");
    }
    if (role == WIFI_AWARE_DATA_PATH_ROLE_INITIATOR) {
        if (peer == null) {
            throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer MAC " + "address - null not permitted on INITIATOR");
        }
    }
    if (peer != null && peer.length != 6) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer MAC address");
    }
    ns.role = role;
    ns.clientId = clientId;
    ns.peerMac = peer;
    ns.pmk = pmk;
    ns.passphrase = passphrase;
    return ns;
}
#method_after
public NetworkSpecifier createNetworkSpecifier(int clientId, @DataPathRole int role, @Nullable byte[] peer, @Nullable byte[] pmk, @Nullable String passphrase) {
    if (VDBG) {
        Log.v(TAG, "createNetworkSpecifier: role=" + role + ", pmk=" + ((pmk == null) ? "null" : "non-null") + ", passphrase=" + ((passphrase == null) ? "null" : "non-null"));
    }
    if (role != WIFI_AWARE_DATA_PATH_ROLE_INITIATOR && role != WIFI_AWARE_DATA_PATH_ROLE_RESPONDER) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid 'role' argument when creating a network " + "specifier");
    }
    if (role == WIFI_AWARE_DATA_PATH_ROLE_INITIATOR) {
        if (peer == null) {
            throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer MAC " + "address - null not permitted on INITIATOR");
        }
    }
    if (peer != null && peer.length != 6) {
        throw new IllegalArgumentException("createNetworkSpecifier: Invalid peer MAC address");
    }
    return new WifiAwareNetworkSpecifier((peer == null) ? WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_OOB_ANY_PEER : WifiAwareNetworkSpecifier.NETWORK_SPECIFIER_TYPE_OOB, role, clientId, // 0 is an invalid session ID
    0, // 0 is an invalid peer ID
    0, peer, pmk, passphrase);
}
#end_block

#method_before
@Override
public boolean satisfiedBy(NetworkSpecifier other) {
    // Match All is taken care of already
    return equals(other);
}
#method_after
@Override
public boolean satisfiedBy(NetworkSpecifier other) {
    // MatchAllNetworkSpecifier is taken care in NetworkCapabilities#satisfiedBySpecifier.
    return equals(other);
}
#end_block

#method_before
@Override
public void attachInfo(Context context, ProviderInfo info) {
    mContext = context;
    mProviderInfo = info;
    UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
    if (userManager.isUserUnlocked()) {
        super.attachInfo(mContext, mProviderInfo);
    } else {
        IntentFilter userFilter = new IntentFilter();
        userFilter.addAction(Intent.ACTION_USER_UNLOCKED);
        context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, userFilter, null, null);
    }
}
#method_after
@Override
public void attachInfo(Context context, ProviderInfo info) {
    synchronized (this) {
        mContext = context;
        mProviderInfo = info;
        if (!mRegisteredReceiver) {
            IntentFilter userFilter = new IntentFilter();
            userFilter.addAction(Intent.ACTION_USER_UNLOCKED);
            mContext.registerReceiverAsUser(mBroadcastReceiver, UserHandle.CURRENT, userFilter, null, null);
            mRegisteredReceiver = true;
        }
        UserManager userManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
        if (userManager.isUserUnlocked()) {
            if (!mInitialized) {
                if (Constants.DEBUG)
                    Log.d(TAG, "Initialized");
                super.attachInfo(mContext, mProviderInfo);
                mInitialized = true;
            }
            if (mRegisteredReceiver) {
                mContext.unregisterReceiver(mBroadcastReceiver);
                mRegisteredReceiver = false;
            }
        }
    }
}
#end_block

#method_before
public static Uri getUriForFile(Context context, String authority, File file) {
    UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
    if (!userManager.isUserUnlocked()) {
        return null;
    }
    return FileProvider.getUriForFile(context, authority, file);
}
#method_after
public static Uri getUriForFile(Context context, String authority, File file) {
    UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
    if (!userManager.isUserUnlocked()) {
        return null;
    }
    context = context.createCredentialProtectedStorageContext();
    return FileProvider.getUriForFile(context, authority, file);
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    // init with 0, because it is treated as a boolean
                    int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setCssIndicator(cssIndicator);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
protected void setPowerStateToDesired() {
    if (DBG) {
        log("mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch + ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && !mRadioDisabledByCarrier && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#method_after
protected void setPowerStateToDesired() {
    if (DBG) {
        String tmpLog = "mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch + ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier;
        log(tmpLog);
        mRadioPowerLog.log(tmpLog);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && !mRadioDisabledByCarrier && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState oldSS = mSS;
    mSS = mNewSS;
    mNewSS = new ServiceState();
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    mTimeZoneLog.log("pollStateDone: set time zone=" + zone.getID() + " mcc=" + mcc + " iso=" + iso);
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // notify using the ServiceStateProvider. This will trigger apps to wake through
        // JobScheduler
        notifyViaProvider(oldSS, mNewSS, mPhone.getSubId());
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(mRejectCode == 0 ? CS_REJECT_CAUSE_DISABLED : CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else {
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                ArrayList<TimeZone> uniqueZones = TimeUtils.getTimeZonesWithUniqueOffsets(iso);
                if ((uniqueZones.size() == 1) || testOneUniqueOffsetPath) {
                    TimeZone zone = uniqueZones.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zone.getID() + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    mTimeZoneLog.log("pollStateDone: set time zone=" + zone.getID() + " mcc=" + mcc + " iso=" + iso);
                    setAndBroadcastNetworkSetTimeZone(zone.getID());
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZones.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CharSequence details = "";
    CharSequence title = context.getText(com.android.internal.R.string.RestrictedOnData);
    int notificationId = CS_NOTIFICATION;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            details = context.getText(com.android.internal.R.string.RestrictedOnData);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoice);
            break;
        case CS_NORMAL_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnNormal);
            break;
        case CS_EMERGENCY_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergency);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
    }
    if (DBG)
        log("setNotification: put notification " + title + " / " + details);
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(com.android.internal.R.drawable.stat_sys_warning).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnDataContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnNormalContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergencyContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                // cancel notification because current reject code is not handled.
                notifyType = CS_REJECT_CAUSE_DISABLED;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
        case CS_REJECT_CAUSE_DISABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#end_block

#method_before
public static Uri getUriForSubId(String field, int subId) {
    return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)).appendEncodedPath(field).build();
}
#method_after
public static Uri getUriForSubId(int subId) {
    return CONTENT_URI.buildUpon().appendEncodedPath(String.valueOf(subId)).build();
}
#end_block

#method_before
@VisibleForTesting
public ServiceState getServiceState(int subId) {
    mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    Log.d("ServiceStateProvider", "onCreate: getContext()=" + getContext());
    Log.d("ServiceStateProvider", "onCreate: mTelephonyManager=" + mTelephonyManager);
    ServiceState ss = mTelephonyManager.getServiceStateForSubscriber(subId);
    if (ss == null) {
        Log.d("ServiceStateProvider", "PhoneFactory.getDefaultPhone().getServiceState() is null");
    }
    return ss;
}
#method_after
@VisibleForTesting
public ServiceState getServiceState(int subId) {
    return mServiceStates.get(subId);
}
#end_block

#method_before
@VisibleForTesting
public int getDefaultSubId() {
    mSubscriptionController = SubscriptionController.getInstance();
    return mSubscriptionController.getDefaultSubId();
}
#method_after
@VisibleForTesting
public int getDefaultSubId() {
    return SubscriptionController.getInstance().getDefaultSubId();
}
#end_block

#method_before
@Override
public Uri insert(Uri uri, ContentValues values) {
    throw new RuntimeException("Not supported");
}
#method_after
@Override
public Uri insert(Uri uri, ContentValues values) {
    if (uri.isPathPrefixMatch(CONTENT_URI)) {
        // Parse the subId
        int subId = 0;
        try {
            subId = Integer.parseInt(uri.getLastPathSegment());
        } catch (NumberFormatException e) {
            Log.d(TAG, "insert: no subId provided in uri");
            throw e;
        }
        Log.d(TAG, "subId=" + subId);
        // handle DEFAULT_SUBSCRIPTION_ID
        if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
            subId = getDefaultSubId();
        }
        // create the new service state
        ServiceState newSS = new ServiceState();
        newSS.setVoiceRegState(values.getAsInteger(VOICE_REG_STATE));
        newSS.setDataRegState(values.getAsInteger(DATA_REG_STATE));
        newSS.setVoiceOperatorName(values.getAsString(VOICE_OPERATOR_ALPHA_LONG), values.getAsString(VOICE_OPERATOR_ALPHA_SHORT), values.getAsString(VOICE_OPERATOR_NUMERIC));
        newSS.setDataOperatorName(values.getAsString(DATA_OPERATOR_ALPHA_LONG), values.getAsString(DATA_OPERATOR_ALPHA_SHORT), values.getAsString(DATA_OPERATOR_NUMERIC));
        newSS.setIsManualSelection(values.getAsBoolean(IS_MANUAL_NETWORK_SELECTION));
        newSS.setRilVoiceRadioTechnology(values.getAsInteger(RIL_VOICE_RADIO_TECHNOLOGY));
        newSS.setRilDataRadioTechnology(values.getAsInteger(RIL_DATA_RADIO_TECHNOLOGY));
        newSS.setCssIndicator(values.getAsInteger(CSS_INDICATOR));
        newSS.setSystemAndNetworkId(values.getAsInteger(SYSTEM_ID), values.getAsInteger(NETWORK_ID));
        newSS.setCdmaRoamingIndicator(values.getAsInteger(CDMA_ROAMING_INDICATOR));
        newSS.setCdmaDefaultRoamingIndicator(values.getAsInteger(CDMA_DEFAULT_ROAMING_INDICATOR));
        newSS.setCdmaEriIconIndex(values.getAsInteger(CDMA_ERI_ICON_INDEX));
        newSS.setCdmaEriIconMode(values.getAsInteger(CDMA_ERI_ICON_MODE));
        newSS.setEmergencyOnly(values.getAsBoolean(IS_EMERGENCY_ONLY));
        newSS.setDataRoamingFromRegistration(values.getAsBoolean(IS_DATA_ROAMING_FROM_REGISTRATION));
        newSS.setIsUsingCarrierAggregation(values.getAsBoolean(IS_USING_CARRIER_AGGREGATION));
        // notify listeners
        // if ss is null (e.g. first service state update) we will notify for all fields
        ServiceState ss = getServiceState(subId);
        notifyChangeForSubIdAndField(getContext(), ss, newSS, subId);
        notifyChangeForSubId(getContext(), ss, newSS, subId);
        // store the new service state
        mServiceStates.put(subId, newSS);
        return uri;
    }
    return null;
}
#end_block

#method_before
@Override
public String getType(Uri uri) {
    if (ServiceStateTable.CONTENT_URI.equals(uri)) {
        return ServiceStateTable.CONTENT_TYPE;
    }
    throw new IllegalArgumentException("Invalid URI: " + uri);
}
#method_after
@Override
public String getType(Uri uri) {
    throw new RuntimeException("Not supported");
}
#end_block

#method_before
@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    if (uri.isPathPrefixMatch(ServiceStateTable.CONTENT_URI)) {
        // Parse the subid
        int subId = 0;
        try {
            subId = Integer.parseInt(uri.getLastPathSegment());
        } catch (NumberFormatException e) {
            Log.d("ServiceStateProvider", "no subId provided, using default.");
            subId = getDefaultSubId();
        }
        Log.d("ServiceStateProvider", "subId=" + subId);
        // Get the service state
        ServiceState ss = getServiceState(subId);
        if (ss == null) {
            Log.d("ServiceStateProvider", "returning null");
            return null;
        }
        // Build the result
        final int voice_reg_state = ss.getVoiceRegState();
        final int data_reg_state = ss.getDataRegState();
        final String voice_operator_alpha_long = ss.getVoiceOperatorAlphaLong();
        final String voice_operator_alpha_short = ss.getVoiceOperatorAlphaShort();
        final String voice_operator_numeric = ss.getVoiceOperatorNumeric();
        final String data_operator_alpha_long = ss.getDataOperatorAlphaLong();
        final String data_operator_alpha_short = ss.getDataOperatorAlphaShort();
        final String data_operator_numeric = ss.getDataOperatorNumeric();
        final int is_manual_network_selection = (ss.getIsManualSelection()) ? 1 : 0;
        final int ril_voice_radio_technology = ss.getRilVoiceRadioTechnology();
        final int ril_data_radio_technology = ss.getRilDataRadioTechnology();
        final int css_indicator = ss.getCssIndicator();
        final int network_id = ss.getNetworkId();
        final int system_id = ss.getSystemId();
        final int cdma_roaming_indicator = ss.getCdmaRoamingIndicator();
        final int cdma_default_roaming_indicator = ss.getCdmaDefaultRoamingIndicator();
        final int cdma_eri_icon_index = ss.getCdmaEriIconIndex();
        final int cdma_eri_icon_mode = ss.getCdmaEriIconMode();
        final int is_emergency_only = (ss.isEmergencyOnly()) ? 1 : 0;
        final int is_data_roaming_from_registration = (ss.getDataRoamingFromRegistration()) ? 1 : 0;
        final int is_using_carrier_aggregation = (ss.isUsingCarrierAggregation()) ? 1 : 0;
        return buildSingleRowResult(projection, sColumns, new Object[] { voice_reg_state, data_reg_state, voice_operator_alpha_long, voice_operator_alpha_short, voice_operator_numeric, data_operator_alpha_long, data_operator_alpha_short, data_operator_numeric, is_manual_network_selection, ril_voice_radio_technology, ril_data_radio_technology, css_indicator, network_id, system_id, cdma_roaming_indicator, cdma_default_roaming_indicator, cdma_eri_icon_index, cdma_eri_icon_mode, is_emergency_only, is_data_roaming_from_registration, is_using_carrier_aggregation });
    }
    throw new IllegalArgumentException("Invalid URI: " + uri);
}
#method_after
@Override
public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
    if (!uri.isPathPrefixMatch(CONTENT_URI)) {
        throw new IllegalArgumentException("Invalid URI: " + uri);
    } else {
        // Parse the subId
        int subId = 0;
        try {
            subId = Integer.parseInt(uri.getLastPathSegment());
        } catch (NumberFormatException e) {
            Log.d(TAG, "query: no subId provided in uri");
            throw e;
        }
        Log.d(TAG, "subId=" + subId);
        // handle DEFAULT_SUBSCRIPTION_ID
        if (subId == SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
            subId = getDefaultSubId();
        }
        // Get the service state
        ServiceState ss = getServiceState(subId);
        if (ss == null) {
            Log.d(TAG, "returning null");
            return null;
        }
        // Build the result
        final int voice_reg_state = ss.getVoiceRegState();
        final int data_reg_state = ss.getDataRegState();
        final int voice_roaming_type = ss.getVoiceRoamingType();
        final int data_roaming_type = ss.getDataRoamingType();
        final String voice_operator_alpha_long = ss.getVoiceOperatorAlphaLong();
        final String voice_operator_alpha_short = ss.getVoiceOperatorAlphaShort();
        final String voice_operator_numeric = ss.getVoiceOperatorNumeric();
        final String data_operator_alpha_long = ss.getDataOperatorAlphaLong();
        final String data_operator_alpha_short = ss.getDataOperatorAlphaShort();
        final String data_operator_numeric = ss.getDataOperatorNumeric();
        final int is_manual_network_selection = (ss.getIsManualSelection()) ? 1 : 0;
        final int ril_voice_radio_technology = ss.getRilVoiceRadioTechnology();
        final int ril_data_radio_technology = ss.getRilDataRadioTechnology();
        final int css_indicator = ss.getCssIndicator();
        final int network_id = ss.getNetworkId();
        final int system_id = ss.getSystemId();
        final int cdma_roaming_indicator = ss.getCdmaRoamingIndicator();
        final int cdma_default_roaming_indicator = ss.getCdmaDefaultRoamingIndicator();
        final int cdma_eri_icon_index = ss.getCdmaEriIconIndex();
        final int cdma_eri_icon_mode = ss.getCdmaEriIconMode();
        final int is_emergency_only = (ss.isEmergencyOnly()) ? 1 : 0;
        final int is_data_roaming_from_registration = (ss.getDataRoamingFromRegistration()) ? 1 : 0;
        final int is_using_carrier_aggregation = (ss.isUsingCarrierAggregation()) ? 1 : 0;
        return buildSingleRowResult(projection, sColumns, new Object[] { voice_reg_state, data_reg_state, voice_roaming_type, data_roaming_type, voice_operator_alpha_long, voice_operator_alpha_short, voice_operator_numeric, data_operator_alpha_long, data_operator_alpha_short, data_operator_numeric, is_manual_network_selection, ril_voice_radio_technology, ril_data_radio_technology, css_indicator, network_id, system_id, cdma_roaming_indicator, cdma_default_roaming_indicator, cdma_eri_icon_index, cdma_eri_icon_mode, is_emergency_only, is_data_roaming_from_registration, is_using_carrier_aggregation });
    }
}
#end_block

#method_before
static Cursor buildSingleRowResult(String[] projection, String[] availableColumns, Object[] data) {
    if (projection == null) {
        projection = availableColumns;
    }
    final MatrixCursor c = new MatrixCursor(projection, 1);
    final RowBuilder row = c.newRow();
    for (int i = 0; i < c.getColumnCount(); i++) {
        final String columnName = c.getColumnName(i);
        boolean found = false;
        for (int j = 0; j < availableColumns.length; j++) {
            if (availableColumns[j].equals(columnName)) {
                row.add(data[j]);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("Invalid column " + projection[i]);
        }
    }
    return c;
}
#method_after
private static Cursor buildSingleRowResult(String[] projection, String[] availableColumns, Object[] data) {
    if (projection == null) {
        projection = availableColumns;
    }
    final MatrixCursor c = new MatrixCursor(projection, 1);
    final RowBuilder row = c.newRow();
    for (int i = 0; i < c.getColumnCount(); i++) {
        final String columnName = c.getColumnName(i);
        boolean found = false;
        for (int j = 0; j < availableColumns.length; j++) {
            if (availableColumns[j].equals(columnName)) {
                row.add(data[j]);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("Invalid column " + projection[i]);
        }
    }
    return c;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    mContext = mock(Context.class);
    mContentResolver = new MockContentResolver(mContext);
    testServiceState = new ServiceState();
    testServiceState.setStateOutOfService();
    testServiceStateForSubId1 = new ServiceState();
    testServiceStateForSubId1.setStateOff();
    // Mock out the actual phone state
    ServiceStateProvider provider = new ServiceStateProvider() {

        @Override
        public ServiceState getServiceState(int subId) {
            if (subId == 1) {
                return testServiceStateForSubId1;
            } else {
                return testServiceState;
            }
        }

        @Override
        public int getDefaultSubId() {
            return 0;
        }
    };
    ProviderInfo providerInfo = new ProviderInfo();
    providerInfo.authority = "service-state";
    provider.attachInfoForTesting(mContext, providerInfo);
    mContentResolver.addProvider("service-state", provider);
    doReturn(mContentResolver).when(mContext).getContentResolver();
}
#method_after
@Before
public void setUp() throws Exception {
    mContext = mock(Context.class);
    mContentResolver = new MockContentResolver() {

        @Override
        public void notifyChange(Uri uri, ContentObserver observer, boolean syncToNetwork) {
            throw new RuntimeException("notifyChange!");
        }
    };
    doReturn(mContentResolver).when(mContext).getContentResolver();
    testServiceState = new ServiceState();
    testServiceState.setStateOutOfService();
    testServiceStateForSubId1 = new ServiceState();
    testServiceStateForSubId1.setStateOff();
    // Mock out the actual phone state
    ServiceStateProvider provider = new ServiceStateProvider() {

        @Override
        public ServiceState getServiceState(int subId) {
            if (subId == 1) {
                return testServiceStateForSubId1;
            } else {
                return testServiceState;
            }
        }

        @Override
        public int getDefaultSubId() {
            return 0;
        }
    };
    ProviderInfo providerInfo = new ProviderInfo();
    providerInfo.authority = "service-state";
    provider.attachInfoForTesting(mContext, providerInfo);
    mContentResolver.addProvider("service-state", provider);
}
#end_block

#method_before
@Test
@SmallTest
public void testGetServiceStateForSubId() {
    // Verify that when calling with a specific subId the correct ServiceState is returned
    // In this case the subId is set to 1 and the expected service state is
    // testServiceStateForSubId1
    Cursor cursor = mContentResolver.query(SUBID_1_CONTENT_URI, testProjection, "", null, null);
    assertNotNull(cursor);
    cursor.moveToFirst();
    final ServiceState ss = testServiceStateForSubId1;
    final int voiceRegState = ss.getVoiceRegState();
    final int dataRegState = ss.getDataRegState();
    final String voiceOperatorAlphaLong = ss.getVoiceOperatorAlphaLong();
    final String voiceOperatorAlphaShort = ss.getVoiceOperatorAlphaShort();
    final String voiceOperatorNumeric = ss.getVoiceOperatorNumeric();
    final String dataOperatorAlphaLong = ss.getDataOperatorAlphaLong();
    final String dataOperatorAlphaShort = ss.getDataOperatorAlphaShort();
    final String dataOperatorNumeric = ss.getDataOperatorNumeric();
    final int isManualNetworkSelection = (ss.getIsManualSelection()) ? 1 : 0;
    final int rilVoiceRadioTechnology = ss.getRilVoiceRadioTechnology();
    final int rilDataRadioTechnology = ss.getRilDataRadioTechnology();
    final int cssIndicator = ss.getCssIndicator();
    final int networkId = ss.getNetworkId();
    final int systemId = ss.getSystemId();
    final int cdmaRoamingIndicator = ss.getCdmaRoamingIndicator();
    final int cdmaDefaultRoamingIndicator = ss.getCdmaDefaultRoamingIndicator();
    final int cdmaEriIconIndex = ss.getCdmaEriIconIndex();
    final int cdmaEriIconMode = ss.getCdmaEriIconMode();
    final int isEmergencyOnly = (ss.isEmergencyOnly()) ? 1 : 0;
    final int isDataRoamingFromRegistration = (ss.getDataRoamingFromRegistration()) ? 1 : 0;
    final int isUsingCarrierAggregation = (ss.isUsingCarrierAggregation()) ? 1 : 0;
    assertEquals(voiceRegState, cursor.getInt(0));
    assertEquals(dataRegState, cursor.getInt(1));
    assertEquals(voiceOperatorAlphaLong, cursor.getString(2));
    assertEquals(voiceOperatorAlphaShort, cursor.getString(3));
    assertEquals(voiceOperatorNumeric, cursor.getString(4));
    assertEquals(dataOperatorAlphaLong, cursor.getString(5));
    assertEquals(dataOperatorAlphaShort, cursor.getString(6));
    assertEquals(dataOperatorNumeric, cursor.getString(7));
    assertEquals(isManualNetworkSelection, cursor.getInt(8));
    assertEquals(rilVoiceRadioTechnology, cursor.getInt(9));
    assertEquals(rilDataRadioTechnology, cursor.getInt(10));
    assertEquals(cssIndicator, cursor.getInt(11));
    assertEquals(networkId, cursor.getInt(12));
    assertEquals(systemId, cursor.getInt(13));
    assertEquals(cdmaRoamingIndicator, cursor.getInt(14));
    assertEquals(cdmaDefaultRoamingIndicator, cursor.getInt(15));
    assertEquals(cdmaEriIconIndex, cursor.getInt(16));
    assertEquals(cdmaEriIconMode, cursor.getInt(17));
    assertEquals(isEmergencyOnly, cursor.getInt(18));
    assertEquals(isDataRoamingFromRegistration, cursor.getInt(19));
    assertEquals(isUsingCarrierAggregation, cursor.getInt(20));
}
#method_after
@Test
@SmallTest
public void testGetServiceStateForSubId() {
    // Verify that when calling with a specific subId the correct ServiceState is returned
    // In this case the subId is set to 1 and the expected service state is
    // testServiceStateForSubId1
    verifyServiceStateForSubId(1, testServiceStateForSubId1);
}
#end_block

#method_before
private void writeObject(ObjectOutputStream stream) throws IOException {
    internalZoneStrings();
    stream.defaultWriteObject();
}
#method_after
private void writeObject(ObjectOutputStream stream) throws IOException {
    // Android-changed: extract initialization of zoneStrings to separate method.
    internalZoneStrings();
    stream.defaultWriteObject();
}
#end_block

#method_before
private void addOffsetStrings(String[][] result) {
    for (int i = 0; i < result.length; ++i) {
        TimeZone tz = null;
        for (int j = 1; j < NAME_COUNT; ++j) {
            if (result[i][j] != null) {
                continue;
            }
            if (tz == null) {
                tz = TimeZone.getTimeZone(result[i][0]);
            }
            int offsetMillis = tz.getRawOffset();
            if (j == LONG_NAME_DST || j == SHORT_NAME_DST) {
                offsetMillis += tz.getDSTSavings();
            }
            result[i][j] = TimeZone.createGmtOffsetString(true, true, offsetMillis);
        }
    }
}
#method_after
private void addOffsetStrings(String[][] result) {
    for (int i = 0; i < result.length; ++i) {
        TimeZone tz = null;
        for (int j = 1; j < NAME_COUNT; ++j) {
            if (result[i][j] != null) {
                continue;
            }
            if (tz == null) {
                tz = TimeZone.getTimeZone(result[i][0]);
            }
            int offsetMillis = tz.getRawOffset();
            if (j == LONG_NAME_DST || j == SHORT_NAME_DST) {
                offsetMillis += tz.getDSTSavings();
            }
            result[i][j] = TimeZone.createGmtOffsetString(/* includeGmt */
            true, /*includeMinuteSeparator */
            true, offsetMillis);
        }
    }
}
#end_block

#method_before
public String getDisplayName(boolean daylightTime, int style, Locale locale) {
    // Android-changed: implement using android.icu.text.TimeZoneNames
    TimeZoneNames.NameType nameType;
    switch(style) {
        case SHORT:
            nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
            break;
        case LONG:
            nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
            break;
        default:
            throw new IllegalArgumentException("Illegal style: " + style);
    }
    long now = System.currentTimeMillis();
    String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID());
    if (canonicalID != null) {
        TimeZoneNames names = TimeZoneNames.getInstance(locale);
        String displayName = names.getDisplayName(canonicalID, nameType, now);
        if (displayName != null) {
            return displayName;
        }
    }
    // We get here if this is a custom timezone or ICU doesn't have name data for the specific
    // style and locale.
    int offsetMillis = getRawOffset();
    if (daylightTime) {
        offsetMillis += getDSTSavings();
    }
    return createGmtOffsetString(true, /* includeGmt */
    true, /* includeMinuteSeparator */
    offsetMillis);
}
#method_after
public String getDisplayName(boolean daylightTime, int style, Locale locale) {
    // BEGIN Android-changed: implement using android.icu.text.TimeZoneNames
    TimeZoneNames.NameType nameType;
    switch(style) {
        case SHORT:
            nameType = daylightTime ? TimeZoneNames.NameType.SHORT_DAYLIGHT : TimeZoneNames.NameType.SHORT_STANDARD;
            break;
        case LONG:
            nameType = daylightTime ? TimeZoneNames.NameType.LONG_DAYLIGHT : TimeZoneNames.NameType.LONG_STANDARD;
            break;
        default:
            throw new IllegalArgumentException("Illegal style: " + style);
    }
    String canonicalID = android.icu.util.TimeZone.getCanonicalID(getID());
    if (canonicalID != null) {
        TimeZoneNames names = TimeZoneNames.getInstance(locale);
        long now = System.currentTimeMillis();
        String displayName = names.getDisplayName(canonicalID, nameType, now);
        if (displayName != null) {
            return displayName;
        }
    }
    // We get here if this is a custom timezone or ICU doesn't have name data for the specific
    // style and locale.
    int offsetMillis = getRawOffset();
    if (daylightTime) {
        offsetMillis += getDSTSavings();
    }
    return createGmtOffsetString(true, /* includeGmt */
    true, /* includeMinuteSeparator */
    offsetMillis);
// END Android-changed: implement using android.icu.text.TimeZoneNames
}
#end_block

#method_before
public static String createGmtOffsetString(boolean includeGmt, boolean includeMinuteSeparator, int offsetMillis) {
    int offsetMinutes = offsetMillis / 60000;
    char sign = '+';
    if (offsetMinutes < 0) {
        sign = '-';
        offsetMinutes = -offsetMinutes;
    }
    StringBuilder builder = new StringBuilder(9);
    if (includeGmt) {
        builder.append("GMT");
    }
    builder.append(sign);
    appendNumber(builder, 2, offsetMinutes / 60);
    if (includeMinuteSeparator) {
        builder.append(':');
    }
    appendNumber(builder, 2, offsetMinutes % 60);
    return builder.toString();
}
#method_after
// BEGIN Android-added: utility method to format an offset as a GMT offset string.
public static String createGmtOffsetString(boolean includeGmt, boolean includeMinuteSeparator, int offsetMillis) {
    int offsetMinutes = offsetMillis / 60000;
    char sign = '+';
    if (offsetMinutes < 0) {
        sign = '-';
        offsetMinutes = -offsetMinutes;
    }
    StringBuilder builder = new StringBuilder(9);
    if (includeGmt) {
        builder.append("GMT");
    }
    builder.append(sign);
    appendNumber(builder, 2, offsetMinutes / 60);
    if (includeMinuteSeparator) {
        builder.append(':');
    }
    appendNumber(builder, 2, offsetMinutes % 60);
    return builder.toString();
}
#end_block

#method_before
public int getDSTSavings() {
    if (useDaylightTime()) {
        return 3600000;
    }
    return 0;
}
#method_after
// END Android-added: utility method to format an offset as a GMT offset string.
public int getDSTSavings() {
    if (useDaylightTime()) {
        return 3600000;
    }
    return 0;
}
#end_block

#method_before
public void testDisplayNameForNonCanonicalTimezones() {
    TimeZone canonical = TimeZone.getTimeZone("Europe/London");
    TimeZone nonCanonical = TimeZone.getTimeZone("GB");
    // verify that GB is actually an alias for Europe/London
    assertTrue(canonical.hasSameRules(nonCanonical));
    System.out.println(canonical.getDisplayName() + nonCanonical.getDisplayName());
    assertEquals(canonical.getDisplayName(true, TimeZone.LONG, Locale.ENGLISH), nonCanonical.getDisplayName(true, TimeZone.LONG, Locale.ENGLISH));
}
#method_after
public void testDisplayNameForNonCanonicalTimezones() {
    TimeZone canonical = TimeZone.getTimeZone("Europe/London");
    TimeZone nonCanonical = TimeZone.getTimeZone("GB");
    // verify that GB is actually an alias for Europe/London
    assertTrue(canonical.hasSameRules(nonCanonical));
    assertEquals(canonical.getDisplayName(true, TimeZone.LONG, Locale.ENGLISH), nonCanonical.getDisplayName(true, TimeZone.LONG, Locale.ENGLISH));
}
#end_block

#method_before
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    Preconditions.checkArgument(callback != null, "null NetworkCallback");
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (sCallbacks) {
            if (callback.networkRequest != null) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                sCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return request;
}
#method_after
private NetworkRequest sendRequestForNetwork(NetworkCapabilities need, NetworkCallback callback, int timeoutMs, int action, int legacyType, CallbackHandler handler) {
    Preconditions.checkArgument(callback != null, "null NetworkCallback");
    Preconditions.checkArgument(action == REQUEST || need != null, "null NetworkCapabilities");
    final NetworkRequest request;
    try {
        synchronized (sCallbacks) {
            if (callback.isRegistered()) {
                // TODO: throw exception instead and enforce 1:1 mapping of callbacks
                // and requests (http://b/20701525).
                Log.e(TAG, "NetworkCallback was already registered");
            }
            Messenger messenger = new Messenger(handler);
            Binder binder = new Binder();
            if (action == LISTEN) {
                request = mService.listenForNetwork(need, messenger, binder);
            } else {
                request = mService.requestNetwork(need, messenger, timeoutMs, binder, legacyType);
            }
            if (request != null) {
                sCallbacks.put(request, callback);
            }
            callback.networkRequest = request;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return request;
}
#end_block

#method_before
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    Preconditions.checkArgument(networkCallback != null, "null NetworkCallback");
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
    }
}
#method_after
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    Preconditions.checkArgument(networkCallback != null, "null NetworkCallback");
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.isRegistered(), "NetworkCallback was not registered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = null;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, mNetworkAgentInfo.network);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_URL, mLastPortalProbeResult.detectUrl);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, getCaptivePortalUserAgent(mContext));
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, mNetworkAgentInfo.network);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_URL, mLastPortalProbeResult.detectUrl);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, mCaptivePortalUserAgent);
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
private URL[] makeCaptivePortalFallbackUrls(Context context) {
    String firstUrl = getCaptivePortalFallbackUrl(context);
    String joinedUrls = firstUrl + "," + getSetting(context, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS);
    List<URL> urls = new ArrayList<>();
    for (String s : joinedUrls.split(",")) {
        URL u = makeURL(s);
        if (u == null) {
            continue;
        }
        urls.add(u);
    }
    if (urls.isEmpty()) {
        Log.e(TAG, String.format("could not create any url from %s", joinedUrls));
    }
    return urls.toArray(new URL[urls.size()]);
}
#method_after
private URL[] makeCaptivePortalFallbackUrls(Context context) {
    String separator = "|";
    String firstUrl = getSetting(context, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL);
    String joinedUrls = firstUrl + separator + getSetting(context, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS);
    List<URL> urls = new ArrayList<>();
    for (String s : joinedUrls.split(separator)) {
        URL u = makeURL(s);
        if (u == null) {
            continue;
        }
        urls.add(u);
    }
    if (urls.isEmpty()) {
        Log.e(TAG, String.format("could not create any url from %s", joinedUrls));
    }
    return urls.toArray(new URL[urls.size()]);
}
#end_block

#method_before
private URL nextFallbackUrl() {
    if (mCaptivePortalFallbackUrls.length == 0) {
        return null;
    }
    int idx = Math.abs(mFallbackUrlIndex++) % mCaptivePortalFallbackUrls.length;
    return mCaptivePortalFallbackUrls[idx];
}
#method_after
private URL nextFallbackUrl() {
    if (mCaptivePortalFallbackUrls.length == 0) {
        return null;
    }
    int idx = Math.abs(mNextFallbackUrlIndex) % mCaptivePortalFallbackUrls.length;
    // randomely change url without memory.
    mNextFallbackUrlIndex += new Random().nextInt();
    return mCaptivePortalFallbackUrls[idx];
}
#end_block

#method_before
@VisibleForTesting
protected CaptivePortalProbeResult sendHttpProbe(URL url, int probeType) {
    HttpURLConnection urlConnection = null;
    int httpResponseCode = CaptivePortalProbeResult.FAILED_CODE;
    String redirectUrl = null;
    final Stopwatch probeTimer = new Stopwatch().start();
    try {
        urlConnection = (HttpURLConnection) mNetworkAgentInfo.network.openConnection(url);
        urlConnection.setInstanceFollowRedirects(probeType == ValidationProbeEvent.PROBE_PAC);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        if (mCaptivePortalUserAgent != null) {
            urlConnection.setRequestProperty("User-Agent", mCaptivePortalUserAgent);
        }
        // cannot read request header after connection
        String requestHeader = urlConnection.getRequestProperties().toString();
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        redirectUrl = urlConnection.getHeaderField("location");
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        validationLog(probeType, url, "time=" + (responseTimestamp - requestTimestamp) + "ms" + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
        // proxy server.
        if (httpResponseCode == 200) {
            if (probeType == ValidationProbeEvent.PROBE_PAC) {
                validationLog(probeType, url, "PAC fetch 200 response interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == 0) {
                // Consider 200 response with "Content-length=0" to not be a captive portal.
                // There's no point in considering this a captive portal as the user cannot
                // sign-in to an empty page. Probably the result of a broken transparent proxy.
                // See http://b/9972012.
                validationLog(probeType, url, "200 response with Content-length=0 interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == -1) {
                // response. Do not use available() as it is unreliable. See http://b/33498325.
                if (urlConnection.getInputStream().read() == -1) {
                    validationLog(probeType, url, "Empty 200 response interpreted as 204 response.");
                    httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
                }
            }
        }
    } catch (IOException e) {
        validationLog(probeType, url, "Probably not a portal: exception " + e);
        if (httpResponseCode == CaptivePortalProbeResult.FAILED_CODE) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
    }
    logValidationProbe(probeTimer.stop(), probeType, httpResponseCode);
    return new CaptivePortalProbeResult(httpResponseCode, redirectUrl, url.toString());
}
#method_after
@VisibleForTesting
protected CaptivePortalProbeResult sendHttpProbe(URL url, int probeType) {
    HttpURLConnection urlConnection = null;
    int httpResponseCode = CaptivePortalProbeResult.FAILED_CODE;
    String redirectUrl = null;
    final Stopwatch probeTimer = new Stopwatch().start();
    try {
        urlConnection = (HttpURLConnection) mNetworkAgentInfo.network.openConnection(url);
        urlConnection.setInstanceFollowRedirects(probeType == ValidationProbeEvent.PROBE_PAC);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        if (mCaptivePortalUserAgent != null) {
            urlConnection.setRequestProperty("User-Agent", mCaptivePortalUserAgent);
        }
        // cannot read request header after connection
        String requestHeader = urlConnection.getRequestProperties().toString();
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        redirectUrl = urlConnection.getHeaderField("location");
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        validationLog(probeType, url, "time=" + (responseTimestamp - requestTimestamp) + "ms" + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
        // proxy server.
        if (httpResponseCode == 200) {
            if (probeType == ValidationProbeEvent.PROBE_PAC) {
                validationLog(probeType, url, "PAC fetch 200 response interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == 0) {
                // Consider 200 response with "Content-length=0" to not be a captive portal.
                // There's no point in considering this a captive portal as the user cannot
                // sign-in to an empty page. Probably the result of a broken transparent proxy.
                // See http://b/9972012.
                validationLog(probeType, url, "200 response with Content-length=0 interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == -1) {
                // response. Do not use available() as it is unreliable. See http://b/33498325.
                if (urlConnection.getInputStream().read() == -1) {
                    validationLog(probeType, url, "Empty 200 response interpreted as 204 response.");
                    httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
                }
            }
        }
    } catch (IOException e) {
        validationLog(probeType, url, "Probe failed with exception " + e);
        if (httpResponseCode == CaptivePortalProbeResult.FAILED_CODE) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
    }
    logValidationProbe(probeTimer.stop(), probeType, httpResponseCode);
    return new CaptivePortalProbeResult(httpResponseCode, redirectUrl, url.toString());
}
#end_block

#method_before
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    synchronized (mPublicSync) {
        int interfaceType = ifaceNameToType(iface);
        if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
            return;
        }
        TetherState tetherState = mTetherStates.get(iface);
        if (up) {
            if (tetherState == null) {
                trackNewTetherableInterface(iface, interfaceType);
            }
        } else {
            if (interfaceType == ConnectivityManager.TETHERING_BLUETOOTH) {
                tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
                mTetherStates.remove(iface);
            } else {
                // through the WifiManager.WIFI_AP_STATE_CHANGED_ACTION intent.
                if (VDBG)
                    Log.d(TAG, "ignore interface down for " + iface);
            }
        }
    }
}
#method_after
@Override
public void interfaceStatusChanged(String iface, boolean up) {
    // See NetlinkHandler.cpp:71.
    if (VDBG)
        Log.d(TAG, "interfaceStatusChanged " + iface + ", " + up);
    synchronized (mPublicSync) {
        int interfaceType = ifaceNameToType(iface);
        if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
            return;
        }
        TetherState tetherState = mTetherStates.get(iface);
        if (up) {
            if (tetherState == null) {
                trackNewTetherableInterface(iface, interfaceType);
            }
        } else {
            if (interfaceType == ConnectivityManager.TETHERING_BLUETOOTH) {
                tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
                mTetherStates.remove(iface);
            } else {
                // through the WifiManager.WIFI_AP_STATE_CHANGED_ACTION intent.
                if (VDBG)
                    Log.d(TAG, "ignore interface down for " + iface);
            }
        }
    }
}
#end_block

#method_before
@Override
public void interfaceRemoved(String iface) {
    if (VDBG)
        Log.d(TAG, "interfaceRemoved " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            if (VDBG) {
                Log.e(TAG, "attempting to remove unknown iface (" + iface + "), ignoring");
            }
            return;
        }
        tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
        mTetherStates.remove(iface);
    }
}
#method_after
@Override
public void interfaceRemoved(String iface) {
    if (VDBG)
        Log.d(TAG, "interfaceRemoved " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            if (VDBG) {
                Log.e(TAG, "attempting to remove unknown iface (" + iface + "), ignoring");
            }
            return;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
        mTetherStates.remove(iface);
    }
}
#end_block

#method_before
public int tether(String iface) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.mLastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
public int tether(String iface) {
    return tether(iface, IControlsTethering.STATE_TETHERED);
}
#end_block

#method_before
public int tether(String iface) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.mLastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (tetherState.mLastState != IControlsTethering.STATE_TETHERED) {
            Log.e(TAG, "Tried to untether an untethered iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.mStateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public int getLastTetherError(String iface) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to getLastTetherError on an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        return tetherState.mLastError;
    }
}
#method_after
public int getLastTetherError(String iface) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to getLastTetherError on an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        return tetherState.lastError;
    }
}
#end_block

#method_before
private void sendTetherStateChangedBroadcast() {
    if (!getConnectivityManager().isTetheringSupported())
        return;
    ArrayList<String> availableList = new ArrayList<String>();
    ArrayList<String> activeList = new ArrayList<String>();
    ArrayList<String> erroredList = new ArrayList<String>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.mLastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.mLastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                activeList.add(iface);
            }
        }
    }
    Intent broadcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    broadcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, activeList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(broadcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast avail=[%s] active=[%s] error=[%s]", TextUtils.join(",", availableList), TextUtils.join(",", activeList), TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
#method_after
private void sendTetherStateChangedBroadcast() {
    if (!getConnectivityManager().isTetheringSupported())
        return;
    ArrayList<String> availableList = new ArrayList<String>();
    ArrayList<String> activeList = new ArrayList<String>();
    ArrayList<String> erroredList = new ArrayList<String>();
    boolean wifiTethered = false;
    boolean usbTethered = false;
    boolean bluetoothTethered = false;
    final TetheringConfiguration cfg = mConfig;
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            String iface = mTetherStates.keyAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                erroredList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                availableList.add(iface);
            } else if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                if (cfg.isUsb(iface)) {
                    usbTethered = true;
                } else if (cfg.isWifi(iface)) {
                    wifiTethered = true;
                } else if (cfg.isBluetooth(iface)) {
                    bluetoothTethered = true;
                }
                activeList.add(iface);
            }
        }
    }
    Intent broadcast = new Intent(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    broadcast.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_AVAILABLE_TETHER, availableList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ACTIVE_TETHER, activeList);
    broadcast.putStringArrayListExtra(ConnectivityManager.EXTRA_ERRORED_TETHER, erroredList);
    mContext.sendStickyBroadcastAsUser(broadcast, UserHandle.ALL);
    if (DBG) {
        Log.d(TAG, String.format("sendTetherStateChangedBroadcast avail=[%s] active=[%s] error=[%s]", TextUtils.join(",", availableList), TextUtils.join(",", activeList), TextUtils.join(",", erroredList)));
    }
    if (usbTethered) {
        if (wifiTethered || bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_usb);
        }
    } else if (wifiTethered) {
        if (bluetoothTethered) {
            showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general);
        } else {
            /* We now have a status bar icon for WifiTethering, so drop the notification */
            clearTetheredNotification();
        }
    } else if (bluetoothTethered) {
        showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_bluetooth);
    } else {
        clearTetheredNotification();
    }
}
#end_block

#method_before
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    synchronized (Tethering.this.mPublicSync) {
        mRndisEnabled = rndisEnabled;
        // start tethering if we have a request pending
        if (usbConnected && mRndisEnabled && mUsbTetherRequested) {
            tetherMatchingInterfaces(true, ConnectivityManager.TETHERING_USB);
        }
        mUsbTetherRequested = false;
    }
}
#method_after
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    synchronized (Tethering.this.mPublicSync) {
        mRndisEnabled = rndisEnabled;
        // start tethering if we have a request pending
        if (usbConnected && mRndisEnabled && mUsbTetherRequested) {
            tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, ConnectivityManager.TETHERING_USB);
        }
        mUsbTetherRequested = false;
    }
}
#end_block

#method_before
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                // When the AP comes up and we've been requested to tether it, do so.
                if (mWifiTetherRequested) {
                    tetherMatchingInterfaces(true, ConnectivityManager.TETHERING_WIFI);
                }
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                if (DBG) {
                    Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                }
                // themselves down.
                for (int i = 0; i < mTetherStates.size(); i++) {
                    TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).mStateMachine;
                    if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                        tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                        // There should be at most one of these.
                        break;
                    }
                }
                // Regardless of whether we requested this transition, the AP has gone
                // down.  Don't try to tether again unless we're requested to do so.
                mWifiTetherRequested = false;
                break;
        }
    }
}
#method_after
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                // When the AP comes up and we've been requested to tether it, do so.
                // Otherwise, assume it's a local-only hotspot request.
                final int state = mWifiTetherRequested ? IControlsTethering.STATE_TETHERED : IControlsTethering.STATE_LOCAL_HOTSPOT;
                tetherMatchingInterfaces(state, ConnectivityManager.TETHERING_WIFI);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                if (DBG) {
                    Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                }
                // themselves down.
                for (int i = 0; i < mTetherStates.size(); i++) {
                    TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
                    if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                        tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                        // There should be at most one of these.
                        break;
                    }
                }
                // Regardless of whether we requested this transition, the AP has gone
                // down.  Don't try to tether again unless we're requested to do so.
                mWifiTetherRequested = false;
                break;
        }
    }
}
#end_block

#method_before
private void tetherMatchingInterfaces(boolean enable, int interfaceType) {
    if (VDBG)
        Log.d(TAG, "tetherMatchingInterfaces(" + enable + ", " + interfaceType + ")");
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    int result = (enable ? tether(chosenIface) : untether(chosenIface));
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#method_after
// TODO: Consider renaming to something more accurate in its description.
// This method:
// - allows requesting either tethering or local hotspot serving states
// - handles both enabling and disabling serving states
// - only tethers the first matching interface in listInterfaces()
private void tetherMatchingInterfaces(int requestedState, int interfaceType) {
    if (VDBG) {
        Log.d(TAG, "tetherMatchingInterfaces(" + requestedState + ", " + interfaceType + ")");
    }
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(chosenIface);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_HOTSPOT:
            result = tether(chosenIface, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = mContext.getSystemService(UsbManager.class);
    synchronized (mPublicSync) {
        if (enable) {
            if (mRndisEnabled) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    tetherMatchingInterfaces(true, ConnectivityManager.TETHERING_USB);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            } else {
                mUsbTetherRequested = true;
                usbManager.setCurrentFunction(UsbManager.USB_FUNCTION_RNDIS, false);
            }
        } else {
            final long ident = Binder.clearCallingIdentity();
            try {
                tetherMatchingInterfaces(false, ConnectivityManager.TETHERING_USB);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            if (mRndisEnabled) {
                usbManager.setCurrentFunction(null, false);
            }
            mUsbTetherRequested = false;
        }
    }
    return ConnectivityManager.TETHER_ERROR_NO_ERROR;
}
#method_after
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = mContext.getSystemService(UsbManager.class);
    synchronized (mPublicSync) {
        if (enable) {
            if (mRndisEnabled) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, ConnectivityManager.TETHERING_USB);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            } else {
                mUsbTetherRequested = true;
                usbManager.setCurrentFunction(UsbManager.USB_FUNCTION_RNDIS, false);
            }
        } else {
            final long ident = Binder.clearCallingIdentity();
            try {
                tetherMatchingInterfaces(IControlsTethering.STATE_AVAILABLE, ConnectivityManager.TETHERING_USB);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            if (mRndisEnabled) {
                usbManager.setCurrentFunction(null, false);
            }
            mUsbTetherRequested = false;
        }
    }
    return ConnectivityManager.TETHER_ERROR_NO_ERROR;
}
#end_block

#method_before
public String[] getTetheredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.mLastState == IControlsTethering.STATE_TETHERED) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getTetheredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IControlsTethering.STATE_TETHERED) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
public String[] getTetherableIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.mLastState == IControlsTethering.STATE_AVAILABLE) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getTetherableIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastState == IControlsTethering.STATE_AVAILABLE) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
public String[] getErroredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.mLastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#method_after
public String[] getErroredIfaces() {
    ArrayList<String> list = new ArrayList<String>();
    synchronized (mPublicSync) {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherState tetherState = mTetherStates.valueAt(i);
            if (tetherState.lastError != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                list.add(mTetherStates.keyAt(i));
            }
        }
    }
    return list.toArray(new String[list.size()]);
}
#end_block

#method_before
protected boolean requestUpstreamMobileConnection(int apnType) {
    if (apnType == ConnectivityManager.TYPE_NONE) {
        return false;
    }
    if (apnType != mPreviousMobileType) {
        // Unregister any previous mobile upstream callback because
        // this request, if any, will be different.
        unrequestUpstreamMobileConnection();
    }
    if (mUpstreamNetworkMonitor.mobileNetworkRequested()) {
        // Looks like we already filed a request for this apnType.
        return true;
    }
    switch(apnType) {
        case ConnectivityManager.TYPE_MOBILE_DUN:
        case ConnectivityManager.TYPE_MOBILE:
        case ConnectivityManager.TYPE_MOBILE_HIPRI:
            mPreviousMobileType = apnType;
            break;
        default:
            return false;
    }
    // TODO: Replace this with a call to pass the current tethering
    // configuration to mUpstreamNetworkMonitor and let it handle
    // choosing APN type accordingly.
    mUpstreamNetworkMonitor.updateMobileRequiresDun(apnType == ConnectivityManager.TYPE_MOBILE_DUN);
    mUpstreamNetworkMonitor.registerMobileNetworkRequest();
    return true;
}
#method_after
protected void requestUpstreamMobileConnection() {
    mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);
    mUpstreamNetworkMonitor.registerMobileNetworkRequest();
}
#end_block

#method_before
protected void unrequestUpstreamMobileConnection() {
    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
    mPreviousMobileType = ConnectivityManager.TYPE_NONE;
}
#method_after
protected void unrequestUpstreamMobileConnection() {
    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
}
#end_block

#method_before
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    try {
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean turnOnMasterTetherSettings() {
    final TetheringConfiguration cfg = mConfig;
    try {
        mNMService.setIpForwardingEnabled(true);
    } catch (Exception e) {
        transitionTo(mSetIpForwardingEnabledErrorState);
        return false;
    }
    // TODO: Randomize DHCPv4 ranges, especially in hotspot mode.
    try {
        // TODO: Find a more accurate method name (startDHCPv4()?).
        mNMService.startTethering(cfg.dhcpRanges);
    } catch (Exception e) {
        try {
            mNMService.stopTethering();
            mNMService.startTethering(cfg.dhcpRanges);
        } catch (Exception ee) {
            transitionTo(mStartTetheringErrorState);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void chooseUpstreamType(boolean tryCell) {
    final ConnectivityManager cm = getConnectivityManager();
    int upType = ConnectivityManager.TYPE_NONE;
    String iface = null;
    // TODO - remove?
    updateConfiguration();
    final TetheringConfiguration cfg = mConfig;
    if (VDBG) {
        Log.d(TAG, "chooseUpstreamType has upstream iface types:");
        for (Integer netType : cfg.preferredUpstreamIfaceTypes) {
            Log.d(TAG, " " + netType);
        }
    }
    for (Integer netType : cfg.preferredUpstreamIfaceTypes) {
        NetworkInfo info = cm.getNetworkInfo(netType.intValue());
        // that to be the same as connected here.
        if ((info != null) && info.isConnected()) {
            upType = netType.intValue();
            break;
        }
    }
    final int preferredUpstreamMobileApn = cfg.isDunRequired ? ConnectivityManager.TYPE_MOBILE_DUN : ConnectivityManager.TYPE_MOBILE_HIPRI;
    if (DBG) {
        Log.d(TAG, "chooseUpstreamType(" + tryCell + ")," + " preferredApn=" + ConnectivityManager.getNetworkTypeName(preferredUpstreamMobileApn) + ", got type=" + ConnectivityManager.getNetworkTypeName(upType));
    }
    switch(upType) {
        case ConnectivityManager.TYPE_MOBILE_DUN:
        case ConnectivityManager.TYPE_MOBILE_HIPRI:
            // If we're on DUN, put our own grab on it.
            requestUpstreamMobileConnection(upType);
            break;
        case ConnectivityManager.TYPE_NONE:
            if (tryCell && requestUpstreamMobileConnection(preferredUpstreamMobileApn)) {
            // We think mobile should be coming up; don't set a retry.
            } else {
                sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);
            }
            break;
        default:
            /* If we've found an active upstream connection that's not DUN/HIPRI
                         * we should stop any outstanding DUN/HIPRI start requests.
                         *
                         * If we found NONE we don't want to do this as we want any previous
                         * requests to keep trying to bring up something we can use.
                         */
            unrequestUpstreamMobileConnection();
            break;
    }
    Network network = null;
    if (upType != ConnectivityManager.TYPE_NONE) {
        LinkProperties linkProperties = cm.getLinkProperties(upType);
        if (linkProperties != null) {
            // Find the interface with the default IPv4 route. It may be the
            // interface described by linkProperties, or one of the interfaces
            // stacked on top of it.
            Log.i(TAG, "Finding IPv4 upstream interface on: " + linkProperties);
            RouteInfo ipv4Default = RouteInfo.selectBestRoute(linkProperties.getAllRoutes(), Inet4Address.ANY);
            if (ipv4Default != null) {
                iface = ipv4Default.getInterface();
                Log.i(TAG, "Found interface " + ipv4Default.getInterface());
            } else {
                Log.i(TAG, "No IPv4 upstream interface, giving up.");
            }
        }
        if (iface != null) {
            network = cm.getNetworkForType(upType);
            if (network == null) {
                Log.e(TAG, "No Network for upstream type " + upType + "!");
            }
            setDnsForwarders(network, linkProperties);
        }
    }
    notifyTetheredOfNewUpstreamIface(iface);
    NetworkState ns = mUpstreamNetworkMonitor.lookup(network);
    if (ns != null && pertainsToCurrentUpstream(ns)) {
        // If we already have NetworkState for this network examine
        // it immediately, because there likely will be no second
        // EVENT_ON_AVAILABLE (it was already received).
        handleNewUpstreamNetworkState(ns);
    } else if (mCurrentUpstreamIface == null) {
        // There are no available upstream networks, or none that
        // have an IPv4 default route (current metric for success).
        handleNewUpstreamNetworkState(null);
    }
}
#method_after
protected void chooseUpstreamType(boolean tryCell) {
    final int upstreamType = findPreferredUpstreamType(tryCell);
    setUpstreamByType(upstreamType);
}
#end_block

#method_before
protected void handleNewUpstreamNetworkState(NetworkState ns) {
    mIPv6TetheringCoordinator.updateUpstreamNetworkState(ns);
}
#method_after
protected void handleNewUpstreamNetworkState(NetworkState ns) {
    mIPv6TetheringCoordinator.updateUpstreamNetworkState(ns);
    mOffloadController.setUpstreamLinkProperties((ns != null) ? ns.linkProperties : null);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            if (mNotifyList.indexOf(who) < 0) {
                mNotifyList.add(who);
                mIPv6TetheringCoordinator.addActiveDownstream(who);
            }
            transitionTo(mTetherModeAliveState);
            break;
        case CMD_TETHER_MODE_UNREQUESTED:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            mNotifyList.remove(who);
            mIPv6TetheringCoordinator.removeActiveDownstream(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void enter() {
    // TODO: examine if we should check the return value.
    // may transition us out
    turnOnMasterTetherSettings();
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    // better try something first pass or crazy tests cases will fail
    mTryCell = true;
    chooseUpstreamType(mTryCell);
    mTryCell = !mTryCell;
}
#method_after
@Override
public void enter() {
    // TODO: examine if we should check the return value.
    // may transition us out
    turnOnMasterTetherSettings();
    mSimChange.startListening();
    mUpstreamNetworkMonitor.start();
    mOffloadController.start();
    if (upstreamWanted()) {
        mUpstreamWanted = true;
        chooseUpstreamType(true);
        mTryCell = false;
    }
}
#end_block

#method_before
@Override
public void exit() {
    unrequestUpstreamMobileConnection();
    mUpstreamNetworkMonitor.stop();
    mSimChange.stopListening();
    notifyTetheredOfNewUpstreamIface(null);
    handleNewUpstreamNetworkState(null);
}
#method_after
@Override
public void exit() {
    mOffloadController.stop();
    unrequestUpstreamMobileConnection();
    mUpstreamNetworkMonitor.stop();
    mSimChange.stopListening();
    notifyTetheredOfNewUpstreamIface(null);
    handleNewUpstreamNetworkState(null);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                if (mNotifyList.indexOf(who) < 0) {
                    mNotifyList.add(who);
                    mIPv6TetheringCoordinator.addActiveDownstream(who);
                }
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                break;
            }
        case CMD_TETHER_MODE_UNREQUESTED:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                if (mNotifyList.remove(who)) {
                    if (DBG)
                        Log.d(TAG, "TetherModeAlive removing notifyee " + who);
                    if (mNotifyList.isEmpty()) {
                        // transitions appropriately
                        turnOffMasterTetherSettings();
                    } else {
                        if (DBG) {
                            Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                            for (TetherInterfaceStateMachine o : mNotifyList) {
                                Log.d(TAG, "  " + o);
                            }
                        }
                    }
                } else {
                    Log.e(TAG, "TetherModeAliveState UNREQUESTED has unknown who: " + who);
                }
                mIPv6TetheringCoordinator.removeActiveDownstream(who);
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            // need to try DUN immediately if Wifi goes down
            mTryCell = true;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case CMD_RETRY_UPSTREAM:
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // transitions appropriately
                    turnOffMasterTetherSettings();
                } else {
                    if (DBG) {
                        Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                        for (TetherInterfaceStateMachine o : mNotifyList) {
                            Log.d(TAG, "  " + o);
                        }
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    pw.print("preferredUpstreamIfaceTypes:");
    synchronized (mPublicSync) {
        for (Integer netType : cfg.preferredUpstreamIfaceTypes) {
            pw.print(" " + ConnectivityManager.getNetworkTypeName(netType));
        }
        pw.println();
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.mLastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.mLastError);
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_HOTSPOT:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.mStateMachine.equals(who)) {
            tetherState.mLastState = state;
            tetherState.mLastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#method_after
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_HOTSPOT:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
private void trackNewTetherableInterface(String iface, int interfaceType) {
    TetherState tetherState;
    tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService)));
    mTetherStates.put(iface, tetherState);
    tetherState.mStateMachine.start();
}
#method_after
private void trackNewTetherableInterface(String iface, int interfaceType) {
    TetherState tetherState;
    tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimAbsentSeen=" + mSimAbsentSeen);
    if (isSimCardAbsent(state)) {
        if (!mSimAbsentSeen)
            mSimAbsentSeen = true;
        return;
    }
    if (isSimCardLoaded(state) && mSimAbsentSeen) {
        mSimAbsentSeen = false;
        mCallback.onSimCardLoaded();
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimNotLoadedSeen=" + mSimNotLoadedSeen);
    if (!isSimCardLoaded(state)) {
        mSimNotLoadedSeen = true;
        return;
    }
    if (mSimNotLoadedSeen) {
        mSimNotLoadedSeen = false;
        mCallback.run();
    }
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkCapabilities.getNetworkSpecifier())) {
        throw new IllegalArgumentException("Invalid network specifier - must not be '" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + "'");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
private void setDefaultDnsSystemProperties(Collection<InetAddress> dnses) {
    int last = 0;
    for (InetAddress dns : dnses) {
        ++last;
        String key = "net.dns" + last;
        String value = dns.getHostAddress();
        // Ignore errors setting unsupported properties.
        try {
            mSystemProperties.set(key, value);
        } catch (Exception ignored) {
        }
    }
    for (int i = last + 1; i <= mNumDnsEntries; ++i) {
        String key = "net.dns" + i;
        // Ignore errors setting unsupported properties.
        try {
            mSystemProperties.set(key, "");
        } catch (Exception ignored) {
        }
    }
    mNumDnsEntries = last;
}
#method_after
private void setDefaultDnsSystemProperties(Collection<InetAddress> dnses) {
    int last = 0;
    for (InetAddress dns : dnses) {
        ++last;
        setNetDnsProperty(last, dns.getHostAddress());
    }
    for (int i = last + 1; i <= mNumDnsEntries; ++i) {
        setNetDnsProperty(i, "");
    }
    mNumDnsEntries = last;
}
#end_block

#method_before
public Builder setNetworkSpecifier(String networkSpecifier) {
    return setNetworkSpecifier(new StringNetworkSpecifier(networkSpecifier));
}
#method_after
public Builder setNetworkSpecifier(String networkSpecifier) {
    /*
             * A StringNetworkSpecifier does not accept null or empty ("") strings. When network
             * specifiers were strings a null string and an empty string were considered equivalent.
             * Hence no meaning is attached to a null or empty ("") string.
             */
    return setNetworkSpecifier(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier));
}
#end_block

#method_before
public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    if (networkSpecifier instanceof MatchAllNetworkSpecifier) {
        throw new IllegalArgumentException("NetworkRequests must not use MatchAllNetworkSpecifier");
    }
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
#method_after
public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkSpecifier);
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
#end_block

#method_before
private int phoneIdForRequest(NetworkRequest netRequest) {
    NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier();
    int subId;
    if (specifier == null) {
        subId = mDefaultDataSubscription;
    } else if (specifier instanceof StringNetworkSpecifier) {
        subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier);
    } else {
        subId = INVALID_SUBSCRIPTION_ID;
    }
    int phoneId = INVALID_PHONE_INDEX;
    if (subId == INVALID_SUBSCRIPTION_ID)
        return phoneId;
    for (int i = 0; i < mNumPhones; i++) {
        if (mPhoneSubscriptions[i] == subId) {
            phoneId = i;
            break;
        }
    }
    return phoneId;
}
#method_after
private int phoneIdForRequest(NetworkRequest netRequest) {
    NetworkSpecifier specifier = netRequest.networkCapabilities.getNetworkSpecifier();
    int subId;
    if (specifier == null) {
        subId = mDefaultDataSubscription;
    } else if (specifier instanceof StringNetworkSpecifier) {
        try {
            subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier);
        } catch (NumberFormatException e) {
            Rlog.e(LOG_TAG, "NumberFormatException on " + ((StringNetworkSpecifier) specifier).specifier);
            subId = INVALID_SUBSCRIPTION_ID;
        }
    } else {
        subId = INVALID_SUBSCRIPTION_ID;
    }
    int phoneId = INVALID_PHONE_INDEX;
    if (subId == INVALID_SUBSCRIPTION_ID)
        return phoneId;
    for (int i = 0; i < mNumPhones; i++) {
        if (mPhoneSubscriptions[i] == subId) {
            phoneId = i;
            break;
        }
    }
    return phoneId;
}
#end_block

#method_before
@SmallTest
public void testInvalidNetworkSpecifier() {
    try {
        NetworkRequest.Builder builder = new NetworkRequest.Builder();
        builder.setNetworkSpecifier(new StringNetworkSpecifier(MATCH_ALL_REQUESTS_NETWORK_SPECIFIER));
        fail("NetworkRequest builder with MATCH_ALL_REQUESTS_NETWORK_SPECIFIER");
    } catch (IllegalArgumentException expected) {
    }
    try {
        NetworkRequest.Builder builder = new NetworkRequest.Builder();
        builder.setNetworkSpecifier(new MatchAllNetworkSpecifier());
        fail("NetworkRequest builder with MatchAllNetworkSpecifier");
    } catch (IllegalArgumentException expected) {
    }
    try {
        NetworkCapabilities networkCapabilities = new NetworkCapabilities();
        networkCapabilities.addTransportType(TRANSPORT_WIFI).setNetworkSpecifier(new StringNetworkSpecifier(NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER));
        mService.requestNetwork(networkCapabilities, null, 0, null, ConnectivityManager.TYPE_WIFI);
        fail("ConnectivityService requestNetwork with MATCH_ALL_REQUESTS_NETWORK_SPECIFIER");
    } catch (IllegalArgumentException expected) {
    }
    try {
        NetworkCapabilities networkCapabilities = new NetworkCapabilities();
        networkCapabilities.addTransportType(TRANSPORT_WIFI).setNetworkSpecifier(new MatchAllNetworkSpecifier());
        mService.requestNetwork(networkCapabilities, null, 0, null, ConnectivityManager.TYPE_WIFI);
        fail("ConnectivityService requestNetwork with MatchAllNetworkSpecifier");
    } catch (IllegalArgumentException expected) {
    }
    class NonParcelableSpecifier extends NetworkSpecifier {

        public boolean satisfiedBy(NetworkSpecifier other) {
            return false;
        }
    }
    ;
    class ParcelableSpecifier extends NonParcelableSpecifier implements Parcelable {

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel p, int flags) {
        }
    }
    NetworkRequest.Builder builder;
    builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET);
    try {
        builder.setNetworkSpecifier(new NonParcelableSpecifier());
        fail("Non-parcelable specifier did not throw exception");
    } catch (IllegalArgumentException expected) {
    }
    builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET);
    builder.setNetworkSpecifier(new ParcelableSpecifier());
    assertNotNull(builder.build());
}
#method_after
@SmallTest
public void testInvalidNetworkSpecifier() {
    try {
        NetworkRequest.Builder builder = new NetworkRequest.Builder();
        builder.setNetworkSpecifier(new MatchAllNetworkSpecifier());
        fail("NetworkRequest builder with MatchAllNetworkSpecifier");
    } catch (IllegalArgumentException expected) {
    // expected
    }
    try {
        NetworkCapabilities networkCapabilities = new NetworkCapabilities();
        networkCapabilities.addTransportType(TRANSPORT_WIFI).setNetworkSpecifier(new MatchAllNetworkSpecifier());
        mService.requestNetwork(networkCapabilities, null, 0, null, ConnectivityManager.TYPE_WIFI);
        fail("ConnectivityService requestNetwork with MatchAllNetworkSpecifier");
    } catch (IllegalArgumentException expected) {
    // expected
    }
    class NonParcelableSpecifier extends NetworkSpecifier {

        public boolean satisfiedBy(NetworkSpecifier other) {
            return false;
        }
    }
    ;
    class ParcelableSpecifier extends NonParcelableSpecifier implements Parcelable {

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel p, int flags) {
        }
    }
    NetworkRequest.Builder builder;
    builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET);
    try {
        builder.setNetworkSpecifier(new NonParcelableSpecifier());
        Parcel parcelW = Parcel.obtain();
        builder.build().writeToParcel(parcelW, 0);
        fail("Parceling a non-parcelable specifier did not throw an exception");
    } catch (Exception e) {
    // expected
    }
    builder = new NetworkRequest.Builder().addTransportType(TRANSPORT_ETHERNET);
    builder.setNetworkSpecifier(new ParcelableSpecifier());
    NetworkRequest nr = builder.build();
    assertNotNull(nr);
    try {
        Parcel parcelW = Parcel.obtain();
        nr.writeToParcel(parcelW, 0);
        byte[] bytes = parcelW.marshall();
        parcelW.recycle();
        Parcel parcelR = Parcel.obtain();
        parcelR.unmarshall(bytes, 0, bytes.length);
        parcelR.setDataPosition(0);
        NetworkRequest rereadNr = NetworkRequest.CREATOR.createFromParcel(parcelR);
        fail("Unparceling a non-framework NetworkSpecifier did not throw an exception");
    } catch (Exception e) {
    // expected
    }
}
#end_block

#method_before
@Override
public boolean satisfiedBy(NetworkSpecifier other) {
    if (other == null)
        return true;
    if (!(other instanceof StringNetworkSpecifier))
        return false;
    return specifier.equals(((StringNetworkSpecifier) other).specifier);
}
#method_after
@Override
public boolean satisfiedBy(NetworkSpecifier other) {
    return equals(other);
}
#end_block

#method_before
public boolean equals(Object o) {
    if (!(o instanceof StringNetworkSpecifier))
        return false;
    StringNetworkSpecifier other = (StringNetworkSpecifier) o;
    return specifier.equals(other.specifier);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof StringNetworkSpecifier))
        return false;
    return TextUtils.equals(specifier, ((StringNetworkSpecifier) o).specifier);
}
#end_block

#method_before
public int hashCode() {
    return Objects.hashCode(specifier);
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(specifier);
}
#end_block

#method_before
public String toString() {
    return specifier;
}
#method_after
@Override
public String toString() {
    return specifier;
}
#end_block

#method_before
public Builder setNetworkSpecifier(String networkSpecifier) {
    return setNetworkSpecifier(new StringNetworkSpecifier(networkSpecifier));
}
#method_after
public Builder setNetworkSpecifier(String networkSpecifier) {
    /*
             * A StringNetworkSpecifier does not accept null or empty ("") strings. When network
             * specifiers were strings a null string and an empty string were considered equivalent.
             * Hence no meaning is attached to a null or empty ("") string.
             */
    return setNetworkSpecifier(TextUtils.isEmpty(networkSpecifier) ? null : new StringNetworkSpecifier(networkSpecifier));
}
#end_block

#method_before
public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    if (networkSpecifier instanceof MatchAllNetworkSpecifier) {
        throw new IllegalArgumentException("NetworkRequests must not use MatchAllNetworkSpecifier");
    }
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
#method_after
public Builder setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkSpecifier);
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
#end_block

#method_before
public boolean satisfiedBy(NetworkSpecifier other) {
    throw new IllegalStateException("MatchAllNetworkSpecifier must not be used in NetworkRequests");
}
#method_after
public boolean satisfiedBy(NetworkSpecifier other) {
    /*
         * The method is called by a NetworkRequest to see if it is satisfied by a proposed
         * network (e.g. as offered by a network factory). Since MatchAllNetweorkSpecifier must
         * not be used in network requests this method should never be called.
         */
    throw new IllegalStateException("MatchAllNetworkSpecifier must not be used in NetworkRequests");
}
#end_block

#method_before
public boolean equals(Object o) {
    return o instanceof MatchAllNetworkSpecifier;
}
#method_after
@Override
public boolean equals(Object o) {
    return o instanceof MatchAllNetworkSpecifier;
}
#end_block

#method_before
public int hashCode() {
    return 0;
}
#method_after
@Override
public int hashCode() {
    return 0;
}
#end_block

#method_before
private void maybeLogBlockedNetworkInfo(NetworkInfo ni, int uid) {
    if (ni == null || !LOGD_BLOCKED_NETWORKINFO) {
        return;
    }
    boolean removed = false;
    boolean added = false;
    synchronized (mBlockedAppUids) {
        if (ni.getDetailedState() == DetailedState.BLOCKED && mBlockedAppUids.add(uid)) {
            added = true;
        } else if (ni.isConnected() && mBlockedAppUids.remove(uid)) {
            removed = true;
        }
    }
    if (added) {
        log("Returning blocked NetworkInfo to uid=" + uid);
        mNetworkInfoBlockingLogs.log("BLOCKED " + uid);
    } else if (removed) {
        log("Returning unblocked NetworkInfo to uid=" + uid);
        mNetworkInfoBlockingLogs.log("UNBLOCKED " + uid);
    }
}
#method_after
private void maybeLogBlockedNetworkInfo(NetworkInfo ni, int uid) {
    if (ni == null || !LOGD_BLOCKED_NETWORKINFO) {
        return;
    }
    final boolean blocked;
    synchronized (mBlockedAppUids) {
        if (ni.getDetailedState() == DetailedState.BLOCKED && mBlockedAppUids.add(uid)) {
            blocked = true;
        } else if (ni.isConnected() && mBlockedAppUids.remove(uid)) {
            blocked = false;
        } else {
            return;
        }
    }
    String action = blocked ? "BLOCKED" : "UNBLOCKED";
    log(String.format("Returning %s NetworkInfo to uid=%d", action, uid));
    mNetworkInfoBlockingLogs.log(action + " " + uid);
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (argsContain(args, "--diag")) {
        dumpNetworkDiagnostics(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Metered Interfaces:");
    pw.increaseIndent();
    for (String value : mMeteredIfaces) {
        pw.println(value);
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    synchronized (this) {
        pw.print("mNetTransitionWakeLock: currently " + (mNetTransitionWakeLock.isHeld() ? "" : "not ") + "held");
        if (!TextUtils.isEmpty(mNetTransitionWakeLockCausedBy)) {
            pw.println(", last requested for " + mNetTransitionWakeLockCausedBy);
        } else {
            pw.println(", last requested never");
        }
    }
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    if (mInetLog != null && mInetLog.size() > 0) {
        pw.println();
        pw.println("Inet condition reports:");
        pw.increaseIndent();
        for (int i = 0; i < mInetLog.size(); i++) {
            pw.println(mInetLog.get(i));
        }
        pw.decreaseIndent();
    }
    if (argsContain(args, "--short") == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (argsContain(args, "--diag")) {
        dumpNetworkDiagnostics(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Metered Interfaces:");
    pw.increaseIndent();
    for (String value : mMeteredIfaces) {
        pw.println(value);
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (argsContain(args, "--short") == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private boolean isLiveNetworkAgent(NetworkAgentInfo nai, int what) {
    if (nai.network == null)
        return false;
    final NetworkAgentInfo officialNai = getNetworkAgentInfoForNetwork(nai.network);
    if (officialNai != null && officialNai.equals(nai))
        return true;
    if (officialNai != null || VDBG) {
        final String msg = sMagicDecoderRing.get(what, Integer.toString(what));
        loge(msg + " - isLiveNetworkAgent found mismatched netId: " + officialNai + " - " + nai);
    }
    return false;
}
#method_after
private boolean isLiveNetworkAgent(NetworkAgentInfo nai, int what) {
    if (nai.network == null)
        return false;
    final NetworkAgentInfo officialNai = getNetworkAgentInfoForNetwork(nai.network);
    if (officialNai != null && officialNai.equals(nai))
        return true;
    if (officialNai != null || VDBG) {
        loge(eventName(what) + " - isLiveNetworkAgent found mismatched netId: " + officialNai + " - " + nai);
    }
    return false;
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            final String what = sMagicDecoderRing.get(msg.what, Integer.toString(msg.what));
            log(String.format("%s from unknown NetworkAgent", what));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                if (VDBG) {
                    log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
                }
                LinkProperties oldLp = nai.linkProperties;
                synchronized (nai) {
                    nai.linkProperties = (LinkProperties) msg.obj;
                }
                if (nai.everConnected)
                    updateLinkProperties(nai, oldLp);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_ADDED:
            {
                try {
                    mNetd.addVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in addVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_REMOVED:
            {
                try {
                    mNetd.removeVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in removeVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                if (VDBG) {
                    log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
                }
                LinkProperties oldLp = nai.linkProperties;
                synchronized (nai) {
                    nai.linkProperties = (LinkProperties) msg.obj;
                }
                if (nai.everConnected)
                    updateLinkProperties(nai, oldLp);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                Integer score = (Integer) msg.obj;
                if (score != null)
                    updateNetworkScore(nai, score.intValue());
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_ADDED:
            {
                try {
                    mNetd.addVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in addVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_UID_RANGES_REMOVED:
            {
                try {
                    mNetd.removeVpnUidRanges(nai.network.netId, (UidRange[]) msg.obj);
                } catch (Exception e) {
                    // Never crash!
                    loge("Exception in removeVpnUidRanges: " + e);
                }
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = (boolean) msg.obj;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            requestNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                String causedBy = null;
                synchronized (ConnectivityService.this) {
                    if (msg.arg1 == mNetTransitionWakeLockSerialNumber && mNetTransitionWakeLock.isHeld()) {
                        mNetTransitionWakeLock.release();
                        causedBy = mNetTransitionWakeLockCausedBy;
                    } else {
                        break;
                    }
                }
                if (VDBG) {
                    if (msg.what == EVENT_EXPIRE_NET_TRANSITION_WAKELOCK) {
                        log("Failed to find a new network - expiring NetTransition Wakelock");
                    } else {
                        log("NetTransition Wakelock (" + (causedBy == null ? "unknown" : causedBy) + " cleared because we found a replacement network");
                    }
                }
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                handleSetAcceptUnvalidated((Network) msg.obj, msg.arg1 != 0, msg.arg2 != 0);
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                handleSetAcceptUnvalidated((Network) msg.obj, msg.arg1 != 0, msg.arg2 != 0);
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
    }
}
#end_block

#method_before
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    // Can't set always-on VPN if legacy VPN is already in lockdown mode.
    if (LockdownVpnTracker.isEnabled()) {
        return false;
    }
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false);
            return false;
        }
        vpn.saveAlwaysOnPackage();
    }
    return true;
}
#method_after
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    // Can't set always-on VPN if legacy VPN is already in lockdown mode.
    if (LockdownVpnTracker.isEnabled()) {
        return false;
    }
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
        final ContentResolver cr = mContext.getContentResolver();
        String alwaysOnPackage = Settings.Secure.getStringForUser(cr, Settings.Secure.ALWAYS_ON_VPN_APP, userId);
        final boolean alwaysOnLockdown = Settings.Secure.getIntForUser(cr, Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, /* default */
        0, userId) != 0;
        if (alwaysOnPackage != null) {
            userVpn.setAlwaysOnPackage(alwaysOnPackage, alwaysOnLockdown);
        }
    }
    if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
        updateLockdownVpn();
    }
}
#method_after
private void onUserStart(int userId) {
    synchronized (mVpns) {
        Vpn userVpn = mVpns.get(userId);
        if (userVpn != null) {
            loge("Starting user already has a VPN");
            return;
        }
        userVpn = new Vpn(mHandler.getLooper(), mContext, mNetd, userId);
        mVpns.put(userId, userVpn);
    }
    if (mUserManager.getUserInfo(userId).isPrimary() && LockdownVpnTracker.isEnabled()) {
        updateLockdownVpn();
    }
}
#end_block

#method_before
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    if (networkCapabilities.getNetworkSpecifier() instanceof MatchAllNetworkSpecifier) {
        throw new IllegalArgumentException("NetworkRequest with MatchAllNetworkSpecifier");
    }
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#method_after
@Override
public NetworkRequest requestNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, int timeoutMs, IBinder binder, int legacyType) {
    final NetworkRequest.Type type = (networkCapabilities == null) ? NetworkRequest.Type.TRACK_DEFAULT : NetworkRequest.Type.REQUEST;
    // the system default network.
    if (type == NetworkRequest.Type.TRACK_DEFAULT) {
        networkCapabilities = new NetworkCapabilities(mDefaultRequest.networkCapabilities);
        enforceAccessPermission();
    } else {
        networkCapabilities = new NetworkCapabilities(networkCapabilities);
        enforceNetworkRequestPermissions(networkCapabilities);
        // TODO: this is incorrect. We mark the request as metered or not depending on the state
        // of the app when the request is filed, but we never change the request if the app
        // changes network state. http://b/29964605
        enforceMeteredApnPolicy(networkCapabilities);
    }
    ensureRequestableCapabilities(networkCapabilities);
    if (timeoutMs < 0) {
        throw new IllegalArgumentException("Bad timeout specified");
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, legacyType, nextNetworkRequestId(), type);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (DBG)
        log("requestNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST, nri));
    if (timeoutMs > 0) {
        mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NETWORK_REQUEST, nri), timeoutMs);
    }
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest pendingRequestForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    enforceNetworkRequestPermissions(networkCapabilities);
    enforceMeteredApnPolicy(networkCapabilities);
    ensureRequestableCapabilities(networkCapabilities);
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(networkCapabilities, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.REQUEST);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (DBG)
        log("pendingRequest for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#method_after
@Override
public NetworkRequest listenForNetwork(NetworkCapabilities networkCapabilities, Messenger messenger, IBinder binder) {
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    if (!ConnectivityManager.checkChangePermission(mContext)) {
        // Apps without the CHANGE_NETWORK_STATE permission can't use background networks, so
        // make all their listens include NET_CAPABILITY_FOREGROUND. That way, they will get
        // onLost and onAvailable callbacks when networks move in and out of the background.
        // There is no need to do this for requests because an app without CHANGE_NETWORK_STATE
        // can't request networks.
        nc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(nc, TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(messenger, networkRequest, binder);
    if (VDBG)
        log("listenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
    return networkRequest;
}
#end_block

#method_before
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#method_after
@Override
public void pendingListenForNetwork(NetworkCapabilities networkCapabilities, PendingIntent operation) {
    checkNotNull(operation, "PendingIntent cannot be null.");
    if (!hasWifiNetworkListenPermission(networkCapabilities)) {
        enforceAccessPermission();
    }
    MatchAllNetworkSpecifier.checkNotMatchAllNetworkSpecifier(networkCapabilities.getNetworkSpecifier());
    NetworkRequest networkRequest = new NetworkRequest(new NetworkCapabilities(networkCapabilities), TYPE_NONE, nextNetworkRequestId(), NetworkRequest.Type.LISTEN);
    NetworkRequestInfo nri = new NetworkRequestInfo(networkRequest, operation);
    if (VDBG)
        log("pendingListenForNetwork for " + nri);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_LISTENER, nri));
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        synchronized (ConnectivityService.this) {
            // to reconnect over the new network
            if (mNetTransitionWakeLock.isHeld()) {
                mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_CLEAR_NET_TRANSITION_WAKELOCK, mNetTransitionWakeLockSerialNumber, 0), 1000);
            }
        }
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
@SystemApi
public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) {
        throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier");
    }
    if (mNetworkSpecifier != null) {
        throw new IllegalStateException("Network specifier already set");
    }
    if (networkSpecifier != null && !(networkSpecifier instanceof Parcelable)) {
        throw new IllegalArgumentException("Network specifier must be parcelable");
    }
    mNetworkSpecifier = networkSpecifier;
    return this;
}
#method_after
public NetworkCapabilities setNetworkSpecifier(NetworkSpecifier networkSpecifier) {
    if (networkSpecifier != null && Long.bitCount(mTransportTypes) != 1) {
        throw new IllegalStateException("Must have a single transport specified to use " + "setNetworkSpecifier");
    }
    mNetworkSpecifier = networkSpecifier;
    return this;
}
#end_block

#method_before
private void combineSpecifiers(NetworkCapabilities nc) {
    if (mNetworkSpecifier != null) {
        throw new IllegalStateException("Can't combine two networkSpecifiers");
    }
    setNetworkSpecifier(nc.getNetworkSpecifier());
}
#method_after
private void combineSpecifiers(NetworkCapabilities nc) {
    if (mNetworkSpecifier != null && !mNetworkSpecifier.equals(nc.mNetworkSpecifier)) {
        throw new IllegalStateException("Can't combine two networkSpecifiers");
    }
    setNetworkSpecifier(nc.mNetworkSpecifier);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, 0);
    dest.writeInt(mSignalStrength);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
}
#end_block

#method_before
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(int subId, String AID, byte p2) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccOpenLogicalChannel(subId, AID, p2);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
#method_after
@Deprecated
public IccOpenLogicalChannelResponse iccOpenLogicalChannel(String AID) {
    return iccOpenLogicalChannel(getSubId(), AID, -1);
}
#end_block

#method_before
public static void setTelephonyProperty(int phoneId, String property, String value) {
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (property.length() > SystemProperties.PROP_NAME_MAX || propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property to long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
#method_after
public static void setTelephonyProperty(int phoneId, String property, String value) {
    String propVal = "";
    String[] p = null;
    String prop = SystemProperties.get(property);
    if (value == null) {
        value = "";
    }
    if (prop != null) {
        p = prop.split(",");
    }
    if (!SubscriptionManager.isValidPhoneId(phoneId)) {
        Rlog.d(TAG, "setTelephonyProperty: invalid phoneId=" + phoneId + " property=" + property + " value: " + value + " prop=" + prop);
        return;
    }
    for (int i = 0; i < phoneId; i++) {
        String str = "";
        if ((p != null) && (i < p.length)) {
            str = p[i];
        }
        propVal = propVal + str + ",";
    }
    propVal = propVal + value;
    if (p != null) {
        for (int i = phoneId + 1; i < p.length; i++) {
            propVal = propVal + "," + p[i];
        }
    }
    if (propVal.length() > SystemProperties.PROP_VALUE_MAX) {
        Rlog.d(TAG, "setTelephonyProperty: property too long phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
        return;
    }
    Rlog.d(TAG, "setTelephonyProperty: success phoneId=" + phoneId + " property=" + property + " value: " + value + " propVal=" + propVal);
    SystemProperties.set(property, propVal);
}
#end_block

#method_before
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#method_after
@Deprecated
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}
#end_block

#method_before
public int setAllowedCarriers(int slotId, List<CarrierIdentifier> carriers) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.setAllowedCarriers(slotId, carriers);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return -1;
}
#method_after
@SystemApi
public int setAllowedCarriers(int slotId, List<CarrierIdentifier> carriers) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.setAllowedCarriers(slotId, carriers);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return -1;
}
#end_block

#method_before
public List<CarrierIdentifier> getAllowedCarriers(int slotId) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
#method_after
@SystemApi
public List<CarrierIdentifier> getAllowedCarriers(int slotId) {
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, int p2, Message response) {
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, int p2, Message response) {
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, int p2, Message response) {
}
#end_block

#method_before
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized (sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    rr.mSerial = sNextSerial.getAndIncrement();
    rr.mRequest = request;
    rr.mResult = result;
    rr.mParcel = Parcel.obtain();
    rr.mWakeLockType = RIL.INVALID_WAKELOCK;
    rr.mStartTimeMs = SystemClock.elapsedRealtime();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
#method_after
private static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized (sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    rr.mSerial = sNextSerial.getAndIncrement();
    rr.mRequest = request;
    rr.mResult = result;
    rr.mWakeLockType = RIL.INVALID_WAKELOCK;
    rr.mWorkSource = null;
    rr.mStartTimeMs = SystemClock.elapsedRealtime();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    return rr;
}
#end_block

#method_before
static RILRequest obtain(int request, Message result) {
    RILRequest rr = null;
    synchronized (sPoolSync) {
        if (sPool != null) {
            rr = sPool;
            sPool = rr.mNext;
            rr.mNext = null;
            sPoolSize--;
        }
    }
    if (rr == null) {
        rr = new RILRequest();
    }
    rr.mSerial = sNextSerial.getAndIncrement();
    rr.mRequest = request;
    rr.mResult = result;
    rr.mParcel = Parcel.obtain();
    rr.mWakeLockType = RIL.INVALID_WAKELOCK;
    rr.mStartTimeMs = SystemClock.elapsedRealtime();
    if (result != null && result.getTarget() == null) {
        throw new NullPointerException("Message target must not be null");
    }
    // first elements in any RIL Parcel
    rr.mParcel.writeInt(request);
    rr.mParcel.writeInt(rr.mSerial);
    return rr;
}
#method_after
static RILRequest obtain(int request, Message result, WorkSource workSource) {
    RILRequest rr = null;
    rr = obtain(request, result);
    if (workSource != null) {
        rr.mWorkSource = workSource;
        rr.mClientId = String.valueOf(workSource.get(0)) + ":" + workSource.getName(0);
    } else {
        Rlog.e(LOG_TAG, "null workSource " + request);
    }
    return rr;
}
#end_block

#method_before
void onError(int error, Object ret) {
    CommandException ex;
    ex = CommandException.fromRilErrno(error);
    if (RIL.RILJ_LOGD)
        Rlog.d(LOG_TAG, serialString() + "< " + RIL.requestToString(mRequest) + " error: " + ex + " ret=" + RIL.retToString(mRequest, ret));
    if (mResult != null) {
        AsyncResult.forMessage(mResult, ret, ex);
        mResult.sendToTarget();
    }
    if (mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
}
#method_after
void onError(int error, Object ret) {
    CommandException ex;
    ex = CommandException.fromRilErrno(error);
    if (RIL.RILJ_LOGD)
        Rlog.d(LOG_TAG, serialString() + "< " + RIL.requestToString(mRequest) + " error: " + ex + " ret=" + RIL.retToString(mRequest, ret));
    if (mResult != null) {
        AsyncResult.forMessage(mResult, ret, ex);
        mResult.sendToTarget();
    }
}
#end_block

#method_before
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mInstanceId == null || mInstanceId == 0) {
                rilSocket = SOCKET_NAME_RIL[0];
            } else {
                rilSocket = SOCKET_NAME_RIL[mInstanceId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    Rlog.e(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    Parcel p;
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                    p = Parcel.obtain();
                    p.unmarshall(buffer, 0, length);
                    p.setDataPosition(0);
                    // Rlog.v(RILJ_LOG_TAG, "Read packet: " + length + " bytes");
                    processResponse(p);
                    p.recycle();
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                Rlog.e(RILJ_LOG_TAG, "Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mInstanceId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#method_after
@Override
public void run() {
    int retryCount = 0;
    String rilSocket = "rild";
    try {
        for (; ; ) {
            LocalSocket s = null;
            LocalSocketAddress l;
            if (mPhoneId == null || mPhoneId == 0) {
                rilSocket = RIL_SERVICE_NAME[0];
            } else {
                rilSocket = RIL_SERVICE_NAME[mPhoneId];
            }
            try {
                s = new LocalSocket();
                l = new LocalSocketAddress(rilSocket, LocalSocketAddress.Namespace.RESERVED);
                s.connect(l);
            } catch (IOException ex) {
                try {
                    if (s != null) {
                        s.close();
                    }
                } catch (IOException ex2) {
                // ignore failure to close after failure to connect
                }
                if (retryCount == 8) {
                    riljLoge("Couldn't find '" + rilSocket + "' socket after " + retryCount + " times, continuing to retry silently");
                } else if (retryCount >= 0 && retryCount < 8) {
                    Rlog.i(RILJ_LOG_TAG, "Couldn't find '" + rilSocket + "' socket; retrying after timeout");
                }
                try {
                    Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                } catch (InterruptedException er) {
                }
                retryCount++;
                continue;
            }
            retryCount = 0;
            mSocket = s;
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Connected to '" + rilSocket + "' socket");
            int length = 0;
            try {
                InputStream is = mSocket.getInputStream();
                for (; ; ) {
                    length = readRilMessage(is, buffer);
                    if (length < 0) {
                        // End-of-stream reached
                        break;
                    }
                }
            } catch (java.io.IOException ex) {
                Rlog.i(RILJ_LOG_TAG, "'" + rilSocket + "' socket closed", ex);
            } catch (Throwable tr) {
                riljLoge("Uncaught exception read length=" + length + "Exception:" + tr.toString());
            }
            Rlog.i(RILJ_LOG_TAG, "(" + mPhoneId + ") Disconnected from '" + rilSocket + "' socket");
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            try {
                mSocket.close();
            } catch (IOException ex) {
            }
            mSocket = null;
            RILRequest.resetSerial();
            // Clear request list on close
            clearRequestList(RADIO_NOT_AVAILABLE, false);
        }
    } catch (Throwable tr) {
        Rlog.e(RILJ_LOG_TAG, "Uncaught exception", tr);
    }
    /* We're disconnected so we don't know the ril version */
    notifyRegistrantsRilConnectionChanged(-1);
}
#end_block

#method_before
@Override
public void getIccCardStatus(Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SIM_STATUS, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getIccCardStatus(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SIM_STATUS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getIccCardStatus(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getIccCardStatus", e);
        }
    }
}
#end_block

#method_before
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPinForApp(String pin, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_PIN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " aid = " + aid + " pin = " + pin);
        }
        try {
            radioProxy.supplyIccPinForApp(rr.mSerial, convertNullToEmptyString(pin), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "supplyIccPinForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_PUK, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " puk = " + puk + " newPin = " + newPin + " aid = " + aid);
        }
        try {
            radioProxy.supplyIccPukForApp(rr.mSerial, convertNullToEmptyString(puk), convertNullToEmptyString(newPin), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "supplyIccPukForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(pin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPin2ForApp(String pin, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_PIN2, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " aid = " + aid + " pin = " + pin);
        }
        try {
            radioProxy.supplyIccPin2ForApp(rr.mSerial, convertNullToEmptyString(pin), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "supplyIccPin2ForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(puk);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_SIM_PUK2, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " puk = " + puk + " newPin = " + newPin2 + " aid = " + aid);
        }
        try {
            radioProxy.supplyIccPuk2ForApp(rr.mSerial, convertNullToEmptyString(puk), convertNullToEmptyString(newPin2), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "supplyIccPuk2ForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin);
    rr.mParcel.writeString(newPin);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CHANGE_SIM_PIN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " oldPin = " + oldPin + " newPin = " + newPin + " aid = " + aid);
        }
        try {
            radioProxy.changeIccPinForApp(rr.mSerial, convertNullToEmptyString(oldPin), convertNullToEmptyString(newPin), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "changeIccPinForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(oldPin2);
    rr.mParcel.writeString(newPin2);
    rr.mParcel.writeString(aid);
    send(rr);
}
#method_after
@Override
public void changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CHANGE_SIM_PIN2, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " oldPin = " + oldPin2 + " newPin = " + newPin2 + " aid = " + aid);
        }
        try {
            radioProxy.changeIccPin2ForApp(rr.mSerial, convertNullToEmptyString(oldPin2), convertNullToEmptyString(newPin2), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "changeIccPin2ForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void supplyNetworkDepersonalization(String netpin, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(1);
    rr.mParcel.writeString(netpin);
    send(rr);
}
#method_after
@Override
public void supplyNetworkDepersonalization(String netpin, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " netpin = " + netpin);
        }
        try {
            radioProxy.supplyNetworkDepersonalization(rr.mSerial, convertNullToEmptyString(netpin));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "supplyNetworkDepersonalization", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCurrentCalls(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_CURRENT_CALLS, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getCurrentCalls(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_CURRENT_CALLS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getCurrentCalls(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCurrentCalls", e);
        }
    }
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilDial(mInstanceId, rr.mSerial, clirMode, uusInfo);
    send(rr);
}
#method_after
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DIAL, result, mRILDefaultWorkSource);
        Dial dialInfo = new Dial();
        dialInfo.address = convertNullToEmptyString(address);
        dialInfo.clir = clirMode;
        if (uusInfo != null) {
            UusInfo info = new UusInfo();
            info.uusType = uusInfo.getType();
            info.uusDcs = uusInfo.getDcs();
            info.uusData = new String(uusInfo.getUserData());
            dialInfo.uusInfo.add(info);
        }
        if (RILJ_LOGD) {
            // Do not log function arg for privacy
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.dial(rr.mSerial, dialInfo);
            mMetrics.writeRilDial(mPhoneId, rr.mSerial, clirMode, uusInfo);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "dial", e);
        }
    }
}
#end_block

#method_before
@Override
public void getIMSIForApp(String aid, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> getIMSI: " + requestToString(rr.mRequest) + " aid: " + aid);
    send(rr);
}
#method_after
@Override
public void getIMSIForApp(String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_IMSI, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + ">  " + requestToString(rr.mRequest) + " aid = " + aid);
        }
        try {
            radioProxy.getImsiForApp(rr.mSerial, convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getIMSIForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void hangupConnection(int gsmIndex, Message result) {
    if (RILJ_LOGD)
        riljLog("hangupConnection: gsmIndex=" + gsmIndex);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + gsmIndex);
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, gsmIndex);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(gsmIndex);
    send(rr);
}
#method_after
@Override
public void hangupConnection(int gsmIndex, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_HANGUP, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " gsmIndex = " + gsmIndex);
        }
        try {
            radioProxy.hangup(rr.mSerial, gsmIndex);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "hangupConnection", e);
        }
    }
}
#end_block

#method_before
@Override
public void hangupWaitingOrBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, -1);
    send(rr);
}
#method_after
@Override
public void hangupWaitingOrBackground(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.hangupWaitingOrBackground(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "hangupWaitingOrBackground", e);
        }
    }
}
#end_block

#method_before
@Override
public void hangupForegroundResumeBackground(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilHangup(mInstanceId, rr.mSerial, -1);
    send(rr);
}
#method_after
@Override
public void hangupForegroundResumeBackground(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.hangupForegroundResumeBackground(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "hangupForegroundResumeBackground", e);
        }
    }
}
#end_block

#method_before
@Override
public void switchWaitingOrHoldingAndActive(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void switchWaitingOrHoldingAndActive(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.switchWaitingOrHoldingAndActive(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "switchWaitingOrHoldingAndActive", e);
        }
    }
}
#end_block

#method_before
@Override
public void conference(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void conference(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CONFERENCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.conference(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "conference", e);
        }
    }
}
#end_block

#method_before
@Override
public void rejectCall(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_UDUB, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void rejectCall(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_UDUB, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.rejectCall(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "rejectCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void getLastCallFailCause(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_LAST_CALL_FAIL_CAUSE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getLastCallFailCause(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_LAST_CALL_FAIL_CAUSE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getLastCallFailCause(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getLastCallFailCause", e);
        }
    }
}
#end_block

#method_before
@Override
public void getSignalStrength(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIGNAL_STRENGTH, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getSignalStrength(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIGNAL_STRENGTH, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getSignalStrength(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getSignalStrength", e);
        }
    }
}
#end_block

#method_before
@Override
public void getVoiceRegistrationState(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_REGISTRATION_STATE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getVoiceRegistrationState(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_VOICE_REGISTRATION_STATE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getVoiceRegistrationState(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getVoiceRegistrationState", e);
        }
    }
}
#end_block

#method_before
@Override
public void getDataRegistrationState(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DATA_REGISTRATION_STATE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getDataRegistrationState(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DATA_REGISTRATION_STATE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getDataRegistrationState(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getDataRegistrationState", e);
        }
    }
}
#end_block

#method_before
@Override
public void getOperator(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_OPERATOR, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getOperator(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_OPERATOR, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getOperator(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getOperator", e);
        }
    }
}
#end_block

#method_before
@Override
public void setRadioPower(boolean on, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(on ? 1 : 0);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + (on ? " on" : " off"));
    }
    send(rr);
}
#method_after
@Override
public void setRadioPower(boolean on, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_RADIO_POWER, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " on = " + on);
        }
        try {
            radioProxy.setRadioPower(rr.mSerial, on);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setRadioPower", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendDtmf(char c, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeString(Character.toString(c));
    send(rr);
}
#method_after
@Override
public void sendDtmf(char c, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DTMF, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            // Do not log function arg for privacy
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.sendDtmf(rr.mSerial, c + "");
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendDtmf", e);
        }
    }
}
#end_block

#method_before
private void constructGsmSendSmsRilRequest(RILRequest rr, String smscPDU, String pdu) {
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(smscPDU);
    rr.mParcel.writeString(pdu);
}
#method_after
private GsmSmsMessage constructGsmSendSmsRilRequest(String smscPdu, String pdu) {
    GsmSmsMessage msg = new GsmSmsMessage();
    msg.smscPdu = smscPdu == null ? "" : smscPdu;
    msg.pdu = pdu == null ? "" : pdu;
    return msg;
}
#end_block

#method_before
public void sendSMS(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#method_after
@Override
public void sendSMS(String smscPdu, String pdu, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_SMS, result, mRILDefaultWorkSource);
        // Do not log function args for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        GsmSmsMessage msg = constructGsmSendSmsRilRequest(smscPdu, pdu);
        try {
            radioProxy.sendSms(rr.mSerial, msg);
            mMetrics.writeRilSendSms(mPhoneId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendSMS", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendSMSExpectMore(String smscPDU, String pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_SMS_EXPECT_MORE, result);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#method_after
@Override
public void sendSMSExpectMore(String smscPdu, String pdu, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_SMS_EXPECT_MORE, result, mRILDefaultWorkSource);
        // Do not log function arg for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        GsmSmsMessage msg = constructGsmSendSmsRilRequest(smscPdu, pdu);
        try {
            radioProxy.sendSMSExpectMore(rr.mSerial, msg);
            mMetrics.writeRilSendSms(mPhoneId, rr.mSerial, SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendSMSExpectMore", e);
        }
    }
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
    rr.mParcel.writeInt(7);
    rr.mParcel.writeString(Integer.toString(radioTechnology + 2));
    rr.mParcel.writeString(Integer.toString(profile));
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(user);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(authType));
    rr.mParcel.writeString(protocol);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + radioTechnology + " " + profile + " " + apn + " " + user + " " + password + " " + authType + " " + protocol);
    mMetrics.writeRilSetupDataCall(mInstanceId, rr.mSerial, radioTechnology, profile, apn, authType, protocol);
    send(rr);
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SETUP_DATA_CALL, result, mRILDefaultWorkSource);
        // Convert to HAL data profile
        DataProfileInfo dpi = convertToHalDataProfile(dataProfile);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ",radioTechnology=" + radioTechnology + ",isRoaming=" + isRoaming + ",allowRoaming=" + allowRoaming + "," + dataProfile);
        }
        try {
            radioProxy.setupDataCall(rr.mSerial, radioTechnology, dpi, dataProfile.modemCognitive, allowRoaming, isRoaming);
            mMetrics.writeRilSetupDataCall(mPhoneId, rr.mSerial, radioTechnology, dpi.profileId, dpi.apn, dpi.authType, dpi.protocol);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setupDataCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccIO(int command, int fileid, String path, int p1, int p2, int p3, String data, String pin2, Message result) {
    iccIOForApp(command, fileid, path, p1, p2, p3, data, pin2, null, result);
}
#method_after
@Override
public void iccIO(int command, int fileId, String path, int p1, int p2, int p3, String data, String pin2, Message result) {
    iccIOForApp(command, fileId, path, p1, p2, p3, data, pin2, null, result);
}
#end_block

#method_before
@Override
public void iccIOForApp(int command, int fileid, String path, int p1, int p2, int p3, String data, String pin2, String aid, Message result) {
    // Note: This RIL request has not been renamed to ICC,
    // but this request is also valid for SIM and RUIM
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
    rr.mParcel.writeInt(command);
    rr.mParcel.writeInt(fileid);
    rr.mParcel.writeString(path);
    rr.mParcel.writeInt(p1);
    rr.mParcel.writeInt(p2);
    rr.mParcel.writeInt(p3);
    rr.mParcel.writeString(data);
    rr.mParcel.writeString(pin2);
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> iccIO: " + requestToString(rr.mRequest) + " 0x" + Integer.toHexString(command) + " 0x" + Integer.toHexString(fileid) + " " + " path: " + path + "," + p1 + "," + p2 + "," + p3 + " aid: " + aid);
    send(rr);
}
#method_after
@Override
public void iccIOForApp(int command, int fileId, String path, int p1, int p2, int p3, String data, String pin2, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_IO, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> iccIO: " + requestToString(rr.mRequest) + " command = 0x" + Integer.toHexString(command) + " fileId = 0x" + Integer.toHexString(fileId) + " path = " + path + " p1 = " + p1 + " p2 = " + p2 + " p3 = " + " data = " + data + " aid = " + aid);
        }
        IccIo iccIo = new IccIo();
        iccIo.command = command;
        iccIo.fileId = fileId;
        iccIo.path = convertNullToEmptyString(path);
        iccIo.p1 = p1;
        iccIo.p2 = p2;
        iccIo.p3 = p3;
        iccIo.data = convertNullToEmptyString(data);
        iccIo.pin2 = convertNullToEmptyString(pin2);
        iccIo.aid = convertNullToEmptyString(aid);
        try {
            radioProxy.iccIOForApp(rr.mSerial, iccIo);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccIOForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendUSSD(String ussdString, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEND_USSD, response);
    if (RILJ_LOGD) {
        String logUssdString = "*******";
        if (RILJ_LOGV)
            logUssdString = ussdString;
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + logUssdString);
    }
    rr.mParcel.writeString(ussdString);
    send(rr);
}
#method_after
@Override
public void sendUSSD(String ussd, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEND_USSD, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logUssd = "*******";
            if (RILJ_LOGV)
                logUssd = ussd;
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " ussd = " + logUssd);
        }
        try {
            radioProxy.sendUssd(rr.mSerial, convertNullToEmptyString(ussd));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendUSSD", e);
        }
    }
}
#end_block

#method_before
@Override
public void cancelPendingUssd(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CANCEL_USSD, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void cancelPendingUssd(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CANCEL_USSD, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.cancelPendingUssd(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "cancelPendingUssd", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCLIR(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_CLIR, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getCLIR(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_CLIR, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getClir(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCLIR", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCLIR(int clirMode, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CLIR, result);
    // count ints
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(clirMode);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + clirMode);
    send(rr);
}
#method_after
@Override
public void setCLIR(int clirMode, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_CLIR, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " clirMode = " + clirMode);
        }
        try {
            radioProxy.setClir(rr.mSerial, clirMode);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCLIR", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryCallForwardStatus(int cfReason, int serviceClass, String number, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, response);
    // 2 is for query action, not in used anyway
    rr.mParcel.writeInt(2);
    rr.mParcel.writeInt(cfReason);
    rr.mParcel.writeInt(serviceClass);
    rr.mParcel.writeInt(PhoneNumberUtils.toaFromString(number));
    rr.mParcel.writeString(number);
    rr.mParcel.writeInt(0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + cfReason + " " + serviceClass);
    send(rr);
}
#method_after
@Override
public void queryCallForwardStatus(int cfReason, int serviceClass, String number, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cfreason = " + cfReason + " serviceClass = " + serviceClass);
        }
        android.hardware.radio.V1_0.CallForwardInfo cfInfo = new android.hardware.radio.V1_0.CallForwardInfo();
        cfInfo.reason = cfReason;
        cfInfo.serviceClass = serviceClass;
        cfInfo.toa = PhoneNumberUtils.toaFromString(number);
        cfInfo.number = convertNullToEmptyString(number);
        cfInfo.timeSeconds = 0;
        try {
            radioProxy.getCallForwardStatus(rr.mSerial, cfInfo);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryCallForwardStatus", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCallForward(int action, int cfReason, int serviceClass, String number, int timeSeconds, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CALL_FORWARD, response);
    rr.mParcel.writeInt(action);
    rr.mParcel.writeInt(cfReason);
    rr.mParcel.writeInt(serviceClass);
    rr.mParcel.writeInt(PhoneNumberUtils.toaFromString(number));
    rr.mParcel.writeString(number);
    rr.mParcel.writeInt(timeSeconds);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + action + " " + cfReason + " " + serviceClass + timeSeconds);
    send(rr);
}
#method_after
@Override
public void setCallForward(int action, int cfReason, int serviceClass, String number, int timeSeconds, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_CALL_FORWARD, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " action = " + action + " cfReason = " + cfReason + " serviceClass = " + serviceClass + " timeSeconds = " + timeSeconds);
        }
        android.hardware.radio.V1_0.CallForwardInfo cfInfo = new android.hardware.radio.V1_0.CallForwardInfo();
        cfInfo.status = action;
        cfInfo.reason = cfReason;
        cfInfo.serviceClass = serviceClass;
        cfInfo.toa = PhoneNumberUtils.toaFromString(number);
        cfInfo.number = number;
        cfInfo.timeSeconds = 0;
        try {
            radioProxy.setCallForward(rr.mSerial, cfInfo);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCallForward", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryCallWaiting(int serviceClass, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_CALL_WAITING, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(serviceClass);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + serviceClass);
    send(rr);
}
#method_after
@Override
public void queryCallWaiting(int serviceClass, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_CALL_WAITING, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " serviceClass = " + serviceClass);
        }
        try {
            radioProxy.getCallWaiting(rr.mSerial, serviceClass);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryCallWaiting", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCallWaiting(boolean enable, int serviceClass, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_CALL_WAITING, response);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeInt(enable ? 1 : 0);
    rr.mParcel.writeInt(serviceClass);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + enable + ", " + serviceClass);
    send(rr);
}
#method_after
@Override
public void setCallWaiting(boolean enable, int serviceClass, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_CALL_WAITING, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable = " + enable + " serviceClass = " + serviceClass);
        }
        try {
            radioProxy.setCallWaiting(rr.mSerial, enable, serviceClass);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCallWaiting", e);
        }
    }
}
#end_block

#method_before
@Override
public void acknowledgeLastIncomingGsmSms(boolean success, int cause, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SMS_ACKNOWLEDGE, result);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeInt(success ? 1 : 0);
    rr.mParcel.writeInt(cause);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + success + " " + cause);
    send(rr);
}
#method_after
@Override
public void acknowledgeLastIncomingGsmSms(boolean success, int cause, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SMS_ACKNOWLEDGE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " success = " + success + " cause = " + cause);
        }
        try {
            radioProxy.acknowledgeLastIncomingGsmSms(rr.mSerial, success, cause);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "acknowledgeLastIncomingGsmSms", e);
        }
    }
}
#end_block

#method_before
@Override
public void acceptCall(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ANSWER, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilAnswer(mInstanceId, rr.mSerial);
    send(rr);
}
#method_after
@Override
public void acceptCall(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ANSWER, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.acceptCall(rr.mSerial);
            mMetrics.writeRilAnswer(mPhoneId, rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "acceptCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void deactivateDataCall(int cid, int reason, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DEACTIVATE_DATA_CALL, result);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(Integer.toString(cid));
    rr.mParcel.writeString(Integer.toString(reason));
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + cid + " " + reason);
    mMetrics.writeRilDeactivateDataCall(mInstanceId, rr.mSerial, cid, reason);
    send(rr);
}
#method_after
@Override
public void deactivateDataCall(int cid, int reason, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cid = " + cid + " reason = " + reason);
        }
        try {
            radioProxy.deactivateDataCall(rr.mSerial, cid, (reason == 0) ? false : true);
            mMetrics.writeRilDeactivateDataCall(mPhoneId, rr.mSerial, cid, reason);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "deactivateDataCall", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryFacilityLock(String facility, String password, int serviceClass, Message response) {
    queryFacilityLockForApp(facility, password, serviceClass, null, response);
}
#method_after
@Override
public void queryFacilityLock(String facility, String password, int serviceClass, Message result) {
    queryFacilityLockForApp(facility, password, serviceClass, null, result);
}
#end_block

#method_before
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(4);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#method_after
@Override
public void queryFacilityLockForApp(String facility, String password, int serviceClass, String appId, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_FACILITY_LOCK, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " facility = " + facility + " serviceClass = " + serviceClass + " appId = " + appId);
        }
        try {
            radioProxy.getFacilityLockForApp(rr.mSerial, convertNullToEmptyString(facility), convertNullToEmptyString(password), serviceClass, convertNullToEmptyString(appId));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getFacilityLockForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void setFacilityLock(String facility, boolean lockState, String password, int serviceClass, Message response) {
    setFacilityLockForApp(facility, lockState, password, serviceClass, null, response);
}
#method_after
@Override
public void setFacilityLock(String facility, boolean lockState, String password, int serviceClass, Message result) {
    setFacilityLockForApp(facility, lockState, password, serviceClass, null, result);
}
#end_block

#method_before
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message response) {
    String lockString;
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " [" + facility + " " + lockState + " " + serviceClass + " " + appId + "]");
    // count strings
    rr.mParcel.writeInt(5);
    rr.mParcel.writeString(facility);
    lockString = (lockState) ? "1" : "0";
    rr.mParcel.writeString(lockString);
    rr.mParcel.writeString(password);
    rr.mParcel.writeString(Integer.toString(serviceClass));
    rr.mParcel.writeString(appId);
    send(rr);
}
#method_after
@Override
public void setFacilityLockForApp(String facility, boolean lockState, String password, int serviceClass, String appId, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_FACILITY_LOCK, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " facility = " + facility + " lockstate = " + lockState + " serviceClass = " + serviceClass + " appId = " + appId);
        }
        try {
            radioProxy.setFacilityLockForApp(rr.mSerial, convertNullToEmptyString(facility), lockState, convertNullToEmptyString(password), serviceClass, convertNullToEmptyString(appId));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setFacilityLockForApp", e);
        }
    }
}
#end_block

#method_before
@Override
public void changeBarringPassword(String facility, String oldPwd, String newPwd, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(facility);
    rr.mParcel.writeString(oldPwd);
    rr.mParcel.writeString(newPwd);
    send(rr);
}
#method_after
@Override
public void changeBarringPassword(String facility, String oldPwd, String newPwd, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result, mRILDefaultWorkSource);
        // Do not log all function args for privacy
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "facility = " + facility);
        }
        try {
            radioProxy.setBarringPassword(rr.mSerial, convertNullToEmptyString(facility), convertNullToEmptyString(oldPwd), convertNullToEmptyString(newPwd));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "changeBarringPassword", e);
        }
    }
}
#end_block

#method_before
@Override
public void getNetworkSelectionMode(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getNetworkSelectionMode(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getNetworkSelectionMode(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getNetworkSelectionMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void setNetworkSelectionModeAutomatic(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void setNetworkSelectionModeAutomatic(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.setNetworkSelectionModeAutomatic(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setNetworkSelectionModeAutomatic", e);
        }
    }
}
#end_block

#method_before
@Override
public void setNetworkSelectionModeManual(String operatorNumeric, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + operatorNumeric);
    rr.mParcel.writeString(operatorNumeric);
    send(rr);
}
#method_after
@Override
public void setNetworkSelectionModeManual(String operatorNumeric, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " operatorNumeric = " + operatorNumeric);
        }
        try {
            radioProxy.setNetworkSelectionModeManual(rr.mSerial, convertNullToEmptyString(operatorNumeric));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setNetworkSelectionModeManual", e);
        }
    }
}
#end_block

#method_before
@Override
public void getAvailableNetworks(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_AVAILABLE_NETWORKS, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getAvailableNetworks(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_AVAILABLE_NETWORKS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getAvailableNetworks(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAvailableNetworks", e);
        }
    }
}
#end_block

#method_before
@Override
public void startDtmf(char c, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeString(Character.toString(c));
    send(rr);
}
#method_after
@Override
public void startDtmf(char c, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DTMF_START, result, mRILDefaultWorkSource);
        // Do not log function arg for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.startDtmf(rr.mSerial, c + "");
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "startDtmf", e);
        }
    }
}
#end_block

#method_before
@Override
public void stopDtmf(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void stopDtmf(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DTMF_STOP, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.stopDtmf(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "stopDtmf", e);
        }
    }
}
#end_block

#method_before
@Override
public void separateConnection(int gsmIndex, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SEPARATE_CONNECTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + gsmIndex);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(gsmIndex);
    send(rr);
}
#method_after
@Override
public void separateConnection(int gsmIndex, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SEPARATE_CONNECTION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " gsmIndex = " + gsmIndex);
        }
        try {
            radioProxy.separateConnection(rr.mSerial, gsmIndex);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "separateConnection", e);
        }
    }
}
#end_block

#method_before
@Override
public void getBasebandVersion(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_BASEBAND_VERSION, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getBasebandVersion(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_BASEBAND_VERSION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getBasebandVersion(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getBasebandVersion", e);
        }
    }
}
#end_block

#method_before
@Override
public void setMute(boolean enableMute, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_MUTE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + enableMute);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(enableMute ? 1 : 0);
    send(rr);
}
#method_after
@Override
public void setMute(boolean enableMute, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_MUTE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enableMute = " + enableMute);
        }
        try {
            radioProxy.setMute(rr.mSerial, enableMute);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setMute", e);
        }
    }
}
#end_block

#method_before
@Override
public void getMute(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_MUTE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getMute(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_MUTE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getMute(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getMute", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryCLIP(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_CLIP, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void queryCLIP(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_CLIP, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getClip(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryCLIP", e);
        }
    }
}
#end_block

#method_before
@Override
public void getDataCallList(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DATA_CALL_LIST, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getDataCallList(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DATA_CALL_LIST, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getDataCallList(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getDataCallList", e);
        }
    }
}
#end_block

#method_before
@Override
public void invokeOemRilRequestRaw(byte[] data, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_OEM_HOOK_RAW, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "[" + IccUtils.bytesToHexString(data) + "]");
    rr.mParcel.writeByteArray(data);
    send(rr);
}
#method_after
@Override
public void invokeOemRilRequestRaw(byte[] data, Message response) {
    IOemHook oemHookProxy = getOemHookProxy(response);
    if (oemHookProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_OEM_HOOK_RAW, response, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "[" + IccUtils.bytesToHexString(data) + "]");
        }
        try {
            oemHookProxy.sendRequestRaw(rr.mSerial, primitiveArrayToArrayList(data));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "invokeOemRilRequestStrings", e);
        }
    }
}
#end_block

#method_before
@Override
public void invokeOemRilRequestStrings(String[] strings, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_OEM_HOOK_STRINGS, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeStringArray(strings);
    send(rr);
}
#method_after
@Override
public void invokeOemRilRequestStrings(String[] strings, Message result) {
    IOemHook oemHookProxy = getOemHookProxy(result);
    if (oemHookProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_OEM_HOOK_STRINGS, result, mRILDefaultWorkSource);
        String logStr = "";
        for (int i = 0; i < strings.length; i++) {
            logStr = logStr + strings[i] + " ";
        }
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " strings = " + logStr);
        }
        try {
            oemHookProxy.sendRequestStrings(rr.mSerial, new ArrayList<String>(Arrays.asList(strings)));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "invokeOemRilRequestStrings", e);
        }
    }
}
#end_block

#method_before
@Override
public void setSuppServiceNotifications(boolean enable, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(enable ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void setSuppServiceNotifications(boolean enable, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable = " + enable);
        }
        try {
            radioProxy.setSuppServiceNotifications(rr.mSerial, enable);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setSuppServiceNotifications", e);
        }
    }
}
#end_block

#method_before
@Override
public void writeSmsToSim(int status, String smsc, String pdu, Message response) {
    status = translateStatus(status);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_WRITE_SMS_TO_SIM, response);
    rr.mParcel.writeInt(status);
    rr.mParcel.writeString(pdu);
    rr.mParcel.writeString(smsc);
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + status);
    send(rr);
}
#method_after
@Override
public void writeSmsToSim(int status, String smsc, String pdu, Message result) {
    status = translateStatus(status);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_WRITE_SMS_TO_SIM, result, mRILDefaultWorkSource);
        if (RILJ_LOGV) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + status);
        }
        SmsWriteArgs args = new SmsWriteArgs();
        args.status = status;
        args.smsc = convertNullToEmptyString(smsc);
        args.pdu = convertNullToEmptyString(pdu);
        try {
            radioProxy.writeSmsToSim(rr.mSerial, args);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "writeSmsToSim", e);
        }
    }
}
#end_block

#method_before
@Override
public void deleteSmsOnSim(int index, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DELETE_SMS_ON_SIM, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(index);
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + index);
    send(rr);
}
#method_after
@Override
public void deleteSmsOnSim(int index, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DELETE_SMS_ON_SIM, result, mRILDefaultWorkSource);
        if (RILJ_LOGV) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " index = " + index);
        }
        try {
            radioProxy.deleteSmsOnSim(rr.mSerial, index);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "deleteSmsOnSim", e);
        }
    }
}
#end_block

#method_before
@Override
public void setBandMode(int bandMode, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_BAND_MODE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(bandMode);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + bandMode);
    send(rr);
}
#method_after
@Override
public void setBandMode(int bandMode, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_BAND_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " bandMode = " + bandMode);
        }
        try {
            radioProxy.setBandMode(rr.mSerial, bandMode);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setBandMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryAvailableBandMode(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void queryAvailableBandMode(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getAvailableBandModes(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryAvailableBandMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendEnvelope(String contents, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeString(contents);
    send(rr);
}
#method_after
@Override
public void sendEnvelope(String contents, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " contents = " + contents);
        }
        try {
            radioProxy.sendEnvelope(rr.mSerial, convertNullToEmptyString(contents));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendEnvelope", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendTerminalResponse(String contents, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    rr.mParcel.writeString(contents);
    send(rr);
}
#method_after
@Override
public void sendTerminalResponse(String contents, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " contents = " + contents);
        }
        try {
            radioProxy.sendTerminalResponseToSim(rr.mSerial, convertNullToEmptyString(contents));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendTerminalResponse", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendEnvelopeWithStatus(String contents, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + '[' + contents + ']');
    rr.mParcel.writeString(contents);
    send(rr);
}
#method_after
@Override
public void sendEnvelopeWithStatus(String contents, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " contents = " + contents);
        }
        try {
            radioProxy.sendEnvelopeWithStatus(rr.mSerial, convertNullToEmptyString(contents));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendEnvelopeWithStatus", e);
        }
    }
}
#end_block

#method_before
@Override
public void explicitCallTransfer(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_EXPLICIT_CALL_TRANSFER, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void explicitCallTransfer(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_EXPLICIT_CALL_TRANSFER, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.explicitCallTransfer(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "explicitCallTransfer", e);
        }
    }
}
#end_block

#method_before
@Override
public void setPreferredNetworkType(int networkType, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(networkType);
    mPreferredNetworkType = networkType;
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + networkType);
    mMetrics.writeSetPreferredNetworkType(mInstanceId, networkType);
    send(rr);
}
#method_after
@Override
public void setPreferredNetworkType(int networkType, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " networkType = " + networkType);
        }
        mPreferredNetworkType = networkType;
        mMetrics.writeSetPreferredNetworkType(mPhoneId, networkType);
        try {
            radioProxy.setPreferredNetworkType(rr.mSerial, networkType);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setPreferredNetworkType", e);
        }
    }
}
#end_block

#method_before
@Override
public void getPreferredNetworkType(Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getPreferredNetworkType(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getPreferredNetworkType(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getPreferredNetworkType", e);
        }
    }
}
#end_block

#method_before
@Override
public void getNeighboringCids(Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getNeighboringCids(Message result, WorkSource workSource) {
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, result, workSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getNeighboringCids(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getNeighboringCids", e);
        }
    }
}
#end_block

#method_before
@Override
public void setLocationUpdates(boolean enable, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_LOCATION_UPDATES, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(enable ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + enable);
    send(rr);
}
#method_after
@Override
public void setLocationUpdates(boolean enable, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_LOCATION_UPDATES, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable = " + enable);
        }
        try {
            radioProxy.setLocationUpdates(rr.mSerial, enable);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setLocationUpdates", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCdmaSubscriptionSource(int cdmaSubscription, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(cdmaSubscription);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + cdmaSubscription);
    send(rr);
}
#method_after
@Override
public void setCdmaSubscriptionSource(int cdmaSubscription, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cdmaSubscription = " + cdmaSubscription);
        }
        try {
            radioProxy.setCdmaSubscriptionSource(rr.mSerial, cdmaSubscription);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCdmaSubscriptionSource", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryCdmaRoamingPreference(Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void queryCdmaRoamingPreference(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getCdmaRoamingPreference(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryCdmaRoamingPreference", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCdmaRoamingPreference(int cdmaRoamingType, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(cdmaRoamingType);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + cdmaRoamingType);
    send(rr);
}
#method_after
@Override
public void setCdmaRoamingPreference(int cdmaRoamingType, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cdmaRoamingType = " + cdmaRoamingType);
        }
        try {
            radioProxy.setCdmaRoamingPreference(rr.mSerial, cdmaRoamingType);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCdmaRoamingPreference", e);
        }
    }
}
#end_block

#method_before
@Override
public void queryTTYMode(Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_QUERY_TTY_MODE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void queryTTYMode(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_QUERY_TTY_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getTTYMode(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "queryTTYMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void setTTYMode(int ttyMode, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_SET_TTY_MODE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(ttyMode);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + ttyMode);
    send(rr);
}
#method_after
@Override
public void setTTYMode(int ttyMode, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_TTY_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " ttyMode = " + ttyMode);
        }
        try {
            radioProxy.setTTYMode(rr.mSerial, ttyMode);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setTTYMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void setPreferredVoicePrivacy(boolean enable, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(enable ? 1 : 0);
    send(rr);
}
#method_after
@Override
public void setPreferredVoicePrivacy(boolean enable, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " enable = " + enable);
        }
        try {
            radioProxy.setPreferredVoicePrivacy(rr.mSerial, enable);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setPreferredVoicePrivacy", e);
        }
    }
}
#end_block

#method_before
@Override
public void getPreferredVoicePrivacy(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, result);
    send(rr);
}
#method_after
@Override
public void getPreferredVoicePrivacy(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getPreferredVoicePrivacy(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getPreferredVoicePrivacy", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendCDMAFeatureCode(String FeatureCode, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_FLASH, response);
    rr.mParcel.writeString(FeatureCode);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + FeatureCode);
    send(rr);
}
#method_after
@Override
public void sendCDMAFeatureCode(String featureCode, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_FLASH, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " featureCode = " + featureCode);
        }
        try {
            radioProxy.sendCDMAFeatureCode(rr.mSerial, convertNullToEmptyString(featureCode));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendCDMAFeatureCode", e);
        }
    }
}
#end_block

#method_before
@Override
public void sendBurstDtmf(String dtmfString, int on, int off, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_BURST_DTMF, result);
    rr.mParcel.writeInt(3);
    rr.mParcel.writeString(dtmfString);
    rr.mParcel.writeString(Integer.toString(on));
    rr.mParcel.writeString(Integer.toString(off));
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + dtmfString);
    send(rr);
}
#method_after
@Override
public void sendBurstDtmf(String dtmfString, int on, int off, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_BURST_DTMF, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " dtmfString = " + dtmfString + " on = " + on + " off = " + off);
        }
        try {
            radioProxy.sendBurstDtmf(rr.mSerial, convertNullToEmptyString(dtmfString), on, off);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendBurstDtmf", e);
        }
    }
}
#end_block

#method_before
private void constructCdmaSendSmsRilRequest(RILRequest rr, byte[] pdu) {
    int address_nbr_of_digits;
    int subaddr_nbr_of_digits;
    int bearerDataLength;
    ByteArrayInputStream bais = new ByteArrayInputStream(pdu);
    DataInputStream dis = new DataInputStream(bais);
    try {
        // teleServiceId
        rr.mParcel.writeInt(dis.readInt());
        // servicePresent
        rr.mParcel.writeByte((byte) dis.readInt());
        // serviceCategory
        rr.mParcel.writeInt(dis.readInt());
        // address_digit_mode
        rr.mParcel.writeInt(dis.read());
        // address_nbr_mode
        rr.mParcel.writeInt(dis.read());
        // address_ton
        rr.mParcel.writeInt(dis.read());
        // address_nbr_plan
        rr.mParcel.writeInt(dis.read());
        address_nbr_of_digits = (byte) dis.read();
        rr.mParcel.writeByte((byte) address_nbr_of_digits);
        for (int i = 0; i < address_nbr_of_digits; i++) {
            // address_orig_bytes[i]
            rr.mParcel.writeByte(dis.readByte());
        }
        // subaddressType
        rr.mParcel.writeInt(dis.read());
        // subaddr_odd
        rr.mParcel.writeByte((byte) dis.read());
        subaddr_nbr_of_digits = (byte) dis.read();
        rr.mParcel.writeByte((byte) subaddr_nbr_of_digits);
        for (int i = 0; i < subaddr_nbr_of_digits; i++) {
            // subaddr_orig_bytes[i]
            rr.mParcel.writeByte(dis.readByte());
        }
        bearerDataLength = dis.read();
        rr.mParcel.writeInt(bearerDataLength);
        for (int i = 0; i < bearerDataLength; i++) {
            // bearerData[i]
            rr.mParcel.writeByte(dis.readByte());
        }
    } catch (IOException ex) {
        if (RILJ_LOGD)
            riljLog("sendSmsCdma: conversion from input stream to object failed: " + ex);
    }
}
#method_after
private void constructCdmaSendSmsRilRequest(CdmaSmsMessage msg, byte[] pdu) {
    int addrNbrOfDigits;
    int subaddrNbrOfDigits;
    int bearerDataLength;
    ByteArrayInputStream bais = new ByteArrayInputStream(pdu);
    DataInputStream dis = new DataInputStream(bais);
    try {
        // teleServiceId
        msg.teleserviceId = dis.readInt();
        // servicePresent
        msg.isServicePresent = (byte) dis.readInt() == 1 ? true : false;
        // serviceCategory
        msg.serviceCategory = dis.readInt();
        // address digit mode
        msg.address.digitMode = dis.read();
        // address number mode
        msg.address.numberMode = dis.read();
        // address number type
        msg.address.numberType = dis.read();
        // address number plan
        msg.address.numberPlan = dis.read();
        addrNbrOfDigits = (byte) dis.read();
        for (int i = 0; i < addrNbrOfDigits; i++) {
            // address_orig_bytes[i]
            msg.address.digits.add(dis.readByte());
        }
        // subaddressType
        msg.subAddress.subaddressType = dis.read();
        // subaddr odd
        msg.subAddress.odd = (byte) dis.read() == 1 ? true : false;
        subaddrNbrOfDigits = (byte) dis.read();
        for (int i = 0; i < subaddrNbrOfDigits; i++) {
            // subaddr_orig_bytes[i]
            msg.subAddress.digits.add(dis.readByte());
        }
        bearerDataLength = dis.read();
        for (int i = 0; i < bearerDataLength; i++) {
            // bearerData[i]
            msg.bearerData.add(dis.readByte());
        }
    } catch (IOException ex) {
        if (RILJ_LOGD) {
            riljLog("sendSmsCdma: conversion from input stream to object failed: " + ex);
        }
    }
}
#end_block

#method_before
public void sendCdmaSms(byte[] pdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SEND_SMS, result);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_CDMA, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
    send(rr);
}
#method_after
@Override
public void sendCdmaSms(byte[] pdu, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SEND_SMS, result, mRILDefaultWorkSource);
        // Do not log function arg for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        CdmaSmsMessage msg = new CdmaSmsMessage();
        constructCdmaSendSmsRilRequest(msg, pdu);
        try {
            radioProxy.sendCdmaSms(rr.mSerial, msg);
            mMetrics.writeRilSendSms(mPhoneId, rr.mSerial, SmsSession.Event.Tech.SMS_CDMA, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendCdmaSms", e);
        }
    }
}
#end_block

#method_before
@Override
public void acknowledgeLastIncomingCdmaSms(boolean success, int cause, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, result);
    // RIL_CDMA_SMS_ErrorClass
    rr.mParcel.writeInt(success ? 0 : 1);
    // cause code according to X.S004-550E
    rr.mParcel.writeInt(cause);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + success + " " + cause);
    send(rr);
}
#method_after
@Override
public void acknowledgeLastIncomingCdmaSms(boolean success, int cause, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " success = " + success + " cause = " + cause);
        }
        CdmaSmsAck msg = new CdmaSmsAck();
        msg.errorClass = success ? 0 : 1;
        msg.smsCauseCode = cause;
        try {
            radioProxy.acknowledgeLastIncomingCdmaSms(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "acknowledgeLastIncomingCdmaSms", e);
        }
    }
}
#end_block

#method_before
@Override
public void getGsmBroadcastConfig(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GSM_GET_BROADCAST_CONFIG, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getGsmBroadcastConfig(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GSM_GET_BROADCAST_CONFIG, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getGsmBroadcastConfig(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getGsmBroadcastConfig", e);
        }
    }
}
#end_block

#method_before
@Override
public void setGsmBroadcastConfig(SmsBroadcastConfigInfo[] config, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GSM_SET_BROADCAST_CONFIG, response);
    int numOfConfig = config.length;
    rr.mParcel.writeInt(numOfConfig);
    for (int i = 0; i < numOfConfig; i++) {
        rr.mParcel.writeInt(config[i].getFromServiceId());
        rr.mParcel.writeInt(config[i].getToServiceId());
        rr.mParcel.writeInt(config[i].getFromCodeScheme());
        rr.mParcel.writeInt(config[i].getToCodeScheme());
        rr.mParcel.writeInt(config[i].isSelected() ? 1 : 0);
    }
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + numOfConfig + " configs : ");
        for (int i = 0; i < numOfConfig; i++) {
            riljLog(config[i].toString());
        }
    }
    send(rr);
}
#method_after
@Override
public void setGsmBroadcastConfig(SmsBroadcastConfigInfo[] config, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GSM_SET_BROADCAST_CONFIG, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + config.length + " configs : ");
            for (int i = 0; i < config.length; i++) {
                riljLog(config[i].toString());
            }
        }
        ArrayList<GsmBroadcastSmsConfigInfo> configs = new ArrayList<>();
        int numOfConfig = config.length;
        GsmBroadcastSmsConfigInfo info;
        for (int i = 0; i < numOfConfig; i++) {
            info = new GsmBroadcastSmsConfigInfo();
            info.fromServiceId = config[i].getFromServiceId();
            info.toServiceId = config[i].getToServiceId();
            info.fromCodeScheme = config[i].getFromCodeScheme();
            info.toCodeScheme = config[i].getToCodeScheme();
            info.selected = config[i].isSelected();
            configs.add(info);
        }
        try {
            radioProxy.setGsmBroadcastConfig(rr.mSerial, configs);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setGsmBroadcastConfig", e);
        }
    }
}
#end_block

#method_before
@Override
public void setGsmBroadcastActivation(boolean activate, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GSM_BROADCAST_ACTIVATION, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(activate ? 0 : 1);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void setGsmBroadcastActivation(boolean activate, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GSM_BROADCAST_ACTIVATION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " activate = " + activate);
        }
        try {
            radioProxy.setGsmBroadcastActivation(rr.mSerial, activate);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setGsmBroadcastActivation", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCdmaBroadcastConfig(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG, response);
    send(rr);
}
#method_after
@Override
public void getCdmaBroadcastConfig(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getCdmaBroadcastConfig(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCdmaBroadcastConfig", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCdmaBroadcastConfig(CdmaSmsBroadcastConfigInfo[] configs, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG, response);
    // Convert to 1 service category per config (the way RIL takes is)
    ArrayList<CdmaSmsBroadcastConfigInfo> processedConfigs = new ArrayList<CdmaSmsBroadcastConfigInfo>();
    for (CdmaSmsBroadcastConfigInfo config : configs) {
        for (int i = config.getFromServiceCategory(); i <= config.getToServiceCategory(); i++) {
            processedConfigs.add(new CdmaSmsBroadcastConfigInfo(i, i, config.getLanguage(), config.isSelected()));
        }
    }
    CdmaSmsBroadcastConfigInfo[] rilConfigs = processedConfigs.toArray(configs);
    rr.mParcel.writeInt(rilConfigs.length);
    for (int i = 0; i < rilConfigs.length; i++) {
        rr.mParcel.writeInt(rilConfigs[i].getFromServiceCategory());
        rr.mParcel.writeInt(rilConfigs[i].getLanguage());
        rr.mParcel.writeInt(rilConfigs[i].isSelected() ? 1 : 0);
    }
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + rilConfigs.length + " configs : ");
        for (int i = 0; i < rilConfigs.length; i++) {
            riljLog(rilConfigs[i].toString());
        }
    }
    send(rr);
}
#method_after
@Override
public void setCdmaBroadcastConfig(CdmaSmsBroadcastConfigInfo[] configs, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + configs.length + " configs : ");
            for (int i = 0; i < configs.length; i++) {
                riljLog(configs[i].toString());
            }
        }
        ArrayList<CdmaBroadcastSmsConfigInfo> halConfigs = new ArrayList<>();
        int numOfConfig = configs.length;
        CdmaBroadcastSmsConfigInfo info;
        for (int i = 0; i < numOfConfig; i++) {
            info = new CdmaBroadcastSmsConfigInfo();
            info.serviceCategory = configs[i].getFromServiceCategory();
            info.language = configs[i].getLanguage();
            info.selected = configs[i].isSelected();
            halConfigs.add(info);
        }
        try {
            radioProxy.setCdmaBroadcastConfig(rr.mSerial, halConfigs);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCdmaBroadcastConfig", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCdmaBroadcastActivation(boolean activate, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_BROADCAST_ACTIVATION, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(activate ? 0 : 1);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void setCdmaBroadcastActivation(boolean activate, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_BROADCAST_ACTIVATION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " activate = " + activate);
        }
        try {
            radioProxy.setCdmaBroadcastActivation(rr.mSerial, activate);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCdmaBroadcastActivation", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCDMASubscription(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_SUBSCRIPTION, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getCDMASubscription(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_SUBSCRIPTION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getCDMASubscription(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCDMASubscription", e);
        }
    }
}
#end_block

#method_before
@Override
public void writeSmsToRuim(int status, String pdu, Message response) {
    status = translateStatus(status);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, response);
    rr.mParcel.writeInt(status);
    rr.mParcel.writeString(pdu);
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + status);
    send(rr);
}
#method_after
@Override
public void writeSmsToRuim(int status, String pdu, Message result) {
    status = translateStatus(status);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, result, mRILDefaultWorkSource);
        if (RILJ_LOGV) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " status = " + status);
        }
        CdmaSmsWriteArgs args = new CdmaSmsWriteArgs();
        args.status = status;
        constructCdmaSendSmsRilRequest(args.message, pdu.getBytes());
        try {
            radioProxy.writeSmsToRuim(rr.mSerial, args);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "writeSmsToRuim", e);
        }
    }
}
#end_block

#method_before
@Override
public void deleteSmsOnRuim(int index, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(index);
    if (RILJ_LOGV)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + index);
    send(rr);
}
#method_after
@Override
public void deleteSmsOnRuim(int index, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, result, mRILDefaultWorkSource);
        if (RILJ_LOGV) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " index = " + index);
        }
        try {
            radioProxy.deleteSmsOnRuim(rr.mSerial, index);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "deleteSmsOnRuim", e);
        }
    }
}
#end_block

#method_before
@Override
public void getDeviceIdentity(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DEVICE_IDENTITY, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getDeviceIdentity(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_DEVICE_IDENTITY, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getDeviceIdentity(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getDeviceIdentity", e);
        }
    }
}
#end_block

#method_before
@Override
public void exitEmergencyCallbackMode(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void exitEmergencyCallbackMode(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.exitEmergencyCallbackMode(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "exitEmergencyCallbackMode", e);
        }
    }
}
#end_block

#method_before
@Override
public void getSmscAddress(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_SMSC_ADDRESS, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getSmscAddress(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_SMSC_ADDRESS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getSmscAddress(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getSmscAddress", e);
        }
    }
}
#end_block

#method_before
@Override
public void setSmscAddress(String address, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_SMSC_ADDRESS, result);
    rr.mParcel.writeString(address);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " : " + address);
    send(rr);
}
#method_after
@Override
public void setSmscAddress(String address, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_SMSC_ADDRESS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " address = " + address);
        }
        try {
            radioProxy.setSmscAddress(rr.mSerial, convertNullToEmptyString(address));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setSmscAddress", e);
        }
    }
}
#end_block

#method_before
@Override
public void reportSmsMemoryStatus(boolean available, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, result);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(available ? 1 : 0);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ": " + available);
    send(rr);
}
#method_after
@Override
public void reportSmsMemoryStatus(boolean available, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " available = " + available);
        }
        try {
            radioProxy.reportSmsMemoryStatus(rr.mSerial, available);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "reportSmsMemoryStatus", e);
        }
    }
}
#end_block

#method_before
@Override
public void reportStkServiceIsRunning(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void reportStkServiceIsRunning(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.reportStkServiceIsRunning(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "reportStkServiceIsRunning", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCdmaSubscriptionSource(Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getCdmaSubscriptionSource(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getCdmaSubscriptionSource(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCdmaSubscriptionSource", e);
        }
    }
}
#end_block

#method_before
@Override
public void requestIsimAuthentication(String nonce, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ISIM_AUTHENTICATION, response);
    rr.mParcel.writeString(nonce);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void requestIsimAuthentication(String nonce, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ISIM_AUTHENTICATION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " nonce = " + nonce);
        }
        try {
            radioProxy.requestIsimAuthentication(rr.mSerial, convertNullToEmptyString(nonce));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "requestIsimAuthentication", e);
        }
    }
}
#end_block

#method_before
@Override
public void acknowledgeIncomingGsmSmsWithPdu(boolean success, String ackPdu, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, result);
    rr.mParcel.writeInt(2);
    rr.mParcel.writeString(success ? "1" : "0");
    rr.mParcel.writeString(ackPdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ' ' + success + " [" + ackPdu + ']');
    send(rr);
}
#method_after
@Override
public void acknowledgeIncomingGsmSmsWithPdu(boolean success, String ackPdu, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " success = " + success);
        }
        try {
            radioProxy.acknowledgeIncomingGsmSmsWithPdu(rr.mSerial, success, convertNullToEmptyString(ackPdu));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "acknowledgeIncomingGsmSmsWithPdu", e);
        }
    }
}
#end_block

#method_before
// ***** CommandsInterface implementation
@Override
public void getVoiceRadioTechnology(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_RADIO_TECH, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getVoiceRadioTechnology(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_VOICE_RADIO_TECH, result, mRILDefaultWorkSource);
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getVoiceRadioTechnology(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getVoiceRadioTechnology", e);
        }
    }
}
#end_block

#method_before
@Override
public void getCellInfoList(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_CELL_INFO_LIST, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getCellInfoList(Message result, WorkSource workSource) {
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_CELL_INFO_LIST, result, workSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getCellInfoList(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getCellInfoList", e);
        }
    }
}
#end_block

#method_before
@Override
public void setCellInfoListRate(int rateInMillis, Message response) {
    if (RILJ_LOGD)
        riljLog("setCellInfoListRate: " + rateInMillis);
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(rateInMillis);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void setCellInfoListRate(int rateInMillis, Message result, WorkSource workSource) {
    workSource = getDeafultWorkSourceIfInvalid(workSource);
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, result, workSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " rateInMillis = " + rateInMillis);
        }
        try {
            radioProxy.setCellInfoListRate(rr.mSerial, rateInMillis);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setCellInfoListRate", e);
        }
    }
}
#end_block

#method_before
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result);
    if (RILJ_LOGD)
        riljLog("Set RIL_REQUEST_SET_INITIAL_ATTACH_APN");
    rr.mParcel.writeString(apn);
    rr.mParcel.writeString(protocol);
    rr.mParcel.writeInt(authType);
    rr.mParcel.writeString(username);
    rr.mParcel.writeString(password);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ", apn:" + apn + ", protocol:" + protocol + ", authType:" + authType + ", username:" + username + ", password:" + password);
    send(rr);
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_INITIAL_ATTACH_APN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + dataProfile);
        }
        try {
            radioProxy.setInitialAttachApn(rr.mSerial, convertToHalDataProfile(dataProfile), dataProfile.modemCognitive, isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setInitialAttachApn", e);
        }
    }
}
#end_block

#method_before
public void getImsRegistrationState(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_REGISTRATION_STATE, result);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void getImsRegistrationState(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_IMS_REGISTRATION_STATE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getImsRegistrationState(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getImsRegistrationState", e);
        }
    }
}
#end_block

#method_before
public void sendImsGsmSms(String smscPDU, String pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.GSM_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructGsmSendSmsRilRequest(rr, smscPDU, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP);
    send(rr);
}
#method_after
@Override
public void sendImsGsmSms(String smscPdu, String pdu, int retry, int messageRef, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_IMS_SEND_SMS, result, mRILDefaultWorkSource);
        // Do not log function args for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        ImsSmsMessage msg = new ImsSmsMessage();
        msg.tech = RILConstants.GSM_PHONE;
        msg.retry = (byte) retry == 1 ? true : false;
        msg.messageRef = messageRef;
        GsmSmsMessage gsmMsg = constructGsmSendSmsRilRequest(smscPdu, pdu);
        msg.gsmMessage.add(gsmMsg);
        try {
            radioProxy.sendImsSms(rr.mSerial, msg);
            mMetrics.writeRilSendSms(mPhoneId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendImsGsmSms", e);
        }
    }
}
#end_block

#method_before
public void sendImsCdmaSms(byte[] pdu, int retry, int messageRef, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_IMS_SEND_SMS, result);
    rr.mParcel.writeInt(RILConstants.CDMA_PHONE);
    rr.mParcel.writeByte((byte) retry);
    rr.mParcel.writeInt(messageRef);
    constructCdmaSendSmsRilRequest(rr, pdu);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    mMetrics.writeRilSendSms(mInstanceId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP2);
    send(rr);
}
#method_after
@Override
public void sendImsCdmaSms(byte[] pdu, int retry, int messageRef, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_IMS_SEND_SMS, result, mRILDefaultWorkSource);
        // Do not log function args for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        ImsSmsMessage msg = new ImsSmsMessage();
        msg.tech = RILConstants.CDMA_PHONE;
        msg.retry = (byte) retry == 1 ? true : false;
        msg.messageRef = messageRef;
        CdmaSmsMessage cdmaMsg = new CdmaSmsMessage();
        constructCdmaSendSmsRilRequest(cdmaMsg, pdu);
        msg.cdmaMessage.add(cdmaMsg);
        try {
            radioProxy.sendImsSms(rr.mSerial, msg);
            mMetrics.writeRilSendSms(mPhoneId, rr.mSerial, SmsSession.Event.Tech.SMS_IMS, SmsSession.Event.Format.SMS_FORMAT_3GPP);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "sendImsCdmaSms", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, 0, cla, instruction, p1, p2, p3, data, response);
}
#method_after
@Override
public void iccTransmitApduBasicChannel(int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " cla = " + cla + " instruction = " + instruction + " p1 = " + p1 + " p2 = " + " p3 = " + p3 + " data = " + data);
        }
        SimApdu msg = createSimApdu(0, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduBasicChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduBasicChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_OPEN_CHANNEL, response);
    rr.mParcel.writeByte(p2);
    rr.mParcel.writeString(AID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void iccOpenLogicalChannel(String aid, int p2, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_OPEN_CHANNEL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " aid = " + aid + " p2 = " + p2);
        }
        try {
            radioProxy.iccOpenLogicalChannel(rr.mSerial, convertNullToEmptyString(aid), p2);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccOpenLogicalChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccCloseLogicalChannel(int channel, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_CLOSE_CHANNEL, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(channel);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void iccCloseLogicalChannel(int channel, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_CLOSE_CHANNEL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " channel = " + channel);
        }
        try {
            radioProxy.iccCloseLogicalChannel(rr.mSerial, channel);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccCloseLogicalChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message response) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    iccTransmitApduHelper(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, channel, cla, instruction, p1, p2, p3, data, response);
}
#method_after
@Override
public void iccTransmitApduLogicalChannel(int channel, int cla, int instruction, int p1, int p2, int p3, String data, Message result) {
    if (channel <= 0) {
        throw new RuntimeException("Invalid channel in iccTransmitApduLogicalChannel: " + channel);
    }
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " channel = " + channel + " cla = " + cla + " instruction = " + instruction + " p1 = " + p1 + " p2 = " + " p3 = " + p3 + " data = " + data);
        }
        SimApdu msg = createSimApdu(channel, cla, instruction, p1, p2, p3, data);
        try {
            radioProxy.iccTransmitApduLogicalChannel(rr.mSerial, msg);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "iccTransmitApduLogicalChannel", e);
        }
    }
}
#end_block

#method_before
@Override
public void nvReadItem(int itemID, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_NV_READ_ITEM, response);
    rr.mParcel.writeInt(itemID);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ' ' + itemID);
    send(rr);
}
#method_after
@Override
public void nvReadItem(int itemID, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_NV_READ_ITEM, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " itemId = " + itemID);
        }
        try {
            radioProxy.nvReadItem(rr.mSerial, itemID);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "nvReadItem", e);
        }
    }
}
#end_block

#method_before
@Override
public void nvWriteItem(int itemID, String itemValue, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_NV_WRITE_ITEM, response);
    rr.mParcel.writeInt(itemID);
    rr.mParcel.writeString(itemValue);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ' ' + itemID + ": " + itemValue);
    send(rr);
}
#method_after
@Override
public void nvWriteItem(int itemId, String itemValue, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_NV_WRITE_ITEM, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " itemId = " + itemId + " itemValue = " + itemValue);
        }
        NvWriteItem item = new NvWriteItem();
        item.itemId = itemId;
        item.value = convertNullToEmptyString(itemValue);
        try {
            radioProxy.nvWriteItem(rr.mSerial, item);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "nvWriteItem", e);
        }
    }
}
#end_block

#method_before
@Override
public void nvWriteCdmaPrl(byte[] preferredRoamingList, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_NV_WRITE_CDMA_PRL, response);
    rr.mParcel.writeByteArray(preferredRoamingList);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " (" + preferredRoamingList.length + " bytes)");
    send(rr);
}
#method_after
@Override
public void nvWriteCdmaPrl(byte[] preferredRoamingList, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_NV_WRITE_CDMA_PRL, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " PreferredRoamingList = 0x" + IccUtils.bytesToHexString(preferredRoamingList));
        }
        ArrayList<Byte> arrList = new ArrayList<>();
        for (int i = 0; i < preferredRoamingList.length; i++) {
            arrList.add(preferredRoamingList[i]);
        }
        try {
            radioProxy.nvWriteCdmaPrl(rr.mSerial, arrList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "nvWriteCdmaPrl", e);
        }
    }
}
#end_block

#method_before
@Override
public void nvResetConfig(int resetType, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_NV_RESET_CONFIG, response);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(resetType);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + ' ' + resetType);
    send(rr);
}
#method_after
@Override
public void nvResetConfig(int resetType, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_NV_RESET_CONFIG, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " resetType = " + resetType);
        }
        try {
            radioProxy.nvResetConfig(rr.mSerial, resetType);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "nvResetConfig", e);
        }
    }
}
#end_block

#method_before
public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus, Message result) {
    // Note: This RIL request is also valid for SIM and RUIM (ICC card)
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " slot: " + slotId + " appIndex: " + appIndex + " subId: " + subId + " subStatus: " + subStatus);
    rr.mParcel.writeInt(slotId);
    rr.mParcel.writeInt(appIndex);
    rr.mParcel.writeInt(subId);
    rr.mParcel.writeInt(subStatus);
    send(rr);
}
#method_after
@Override
public void setUiccSubscription(int slotId, int appIndex, int subId, int subStatus, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_UICC_SUBSCRIPTION, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " slot = " + slotId + " appIndex = " + appIndex + " subId = " + subId + " subStatus = " + subStatus);
        }
        SelectUiccSub info = new SelectUiccSub();
        info.slot = slotId;
        info.appIndex = appIndex;
        info.subType = subId;
        info.actStatus = subStatus;
        try {
            radioProxy.setUiccSubscription(rr.mSerial, info);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setUiccSubscription", e);
        }
    }
}
#end_block

#method_before
public void setDataAllowed(boolean allowed, Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_ALLOW_DATA, result);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " allowed: " + allowed);
    }
    rr.mParcel.writeInt(1);
    rr.mParcel.writeInt(allowed ? 1 : 0);
    send(rr);
}
#method_after
@Override
public void setDataAllowed(boolean allowed, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_ALLOW_DATA, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " allowed = " + allowed);
        }
        try {
            radioProxy.setDataAllowed(rr.mSerial, allowed);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setDataAllowed", e);
        }
    }
}
#end_block

#method_before
@Override
public void getHardwareConfig(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_HARDWARE_CONFIG, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getHardwareConfig(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_HARDWARE_CONFIG, result, mRILDefaultWorkSource);
        // Do not log function args for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.getHardwareConfig(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getHardwareConfig", e);
        }
    }
}
#end_block

#method_before
@Override
public void requestIccSimAuthentication(int authContext, String data, String aid, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_AUTHENTICATION, response);
    rr.mParcel.writeInt(authContext);
    rr.mParcel.writeString(data);
    rr.mParcel.writeString(aid);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void requestIccSimAuthentication(int authContext, String data, String aid, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SIM_AUTHENTICATION, result, mRILDefaultWorkSource);
        // Do not log function args for privacy
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        try {
            radioProxy.requestIccSimAuthentication(rr.mSerial, authContext, convertNullToEmptyString(data), convertNullToEmptyString(aid));
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "requestIccSimAuthentication", e);
        }
    }
}
#end_block

#method_before
public void setDataProfile(DataProfile[] dps, Message result) {
    if (RILJ_LOGD)
        riljLog("Set RIL_REQUEST_SET_DATA_PROFILE");
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_DATA_PROFILE, null);
    DataProfile.toParcel(rr.mParcel, dps);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with " + dps + " Data Profiles : ");
        for (int i = 0; i < dps.length; i++) {
            riljLog(dps[i].toString());
        }
    }
    send(rr);
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_DATA_PROFILE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " with data profiles : ");
            for (DataProfile profile : dps) {
                riljLog(profile.toString());
            }
        }
        ArrayList<DataProfileInfo> dpis = new ArrayList<>();
        for (DataProfile dp : dps) {
            dpis.add(convertToHalDataProfile(dp));
        }
        try {
            radioProxy.setDataProfile(rr.mSerial, dpis, isRoaming);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setDataProfile", e);
        }
    }
}
#end_block

#method_before
@Override
public void requestShutdown(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SHUTDOWN, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void requestShutdown(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SHUTDOWN, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.requestShutdown(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "requestShutdown", e);
        }
    }
}
#end_block

#method_before
@Override
public void getRadioCapability(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_RADIO_CAPABILITY, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getRadioCapability(Message response) {
    IRadio radioProxy = getRadioProxy(response);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_RADIO_CAPABILITY, response, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getRadioCapability(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getRadioCapability", e);
        }
    }
}
#end_block

#method_before
@Override
public void setRadioCapability(RadioCapability rc, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_RADIO_CAPABILITY, response);
    rr.mParcel.writeInt(rc.getVersion());
    rr.mParcel.writeInt(rc.getSession());
    rr.mParcel.writeInt(rc.getPhase());
    rr.mParcel.writeInt(rc.getRadioAccessFamily());
    rr.mParcel.writeString(rc.getLogicalModemUuid());
    rr.mParcel.writeInt(rc.getStatus());
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " + rc.toString());
    }
    send(rr);
}
#method_after
@Override
public void setRadioCapability(RadioCapability rc, Message response) {
    IRadio radioProxy = getRadioProxy(response);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_RADIO_CAPABILITY, response, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " RadioCapability = " + rc.toString());
        }
        android.hardware.radio.V1_0.RadioCapability halRc = new android.hardware.radio.V1_0.RadioCapability();
        halRc.session = rc.getSession();
        halRc.phase = rc.getPhase();
        halRc.raf = rc.getRadioAccessFamily();
        halRc.logicalModemUuid = convertNullToEmptyString(rc.getLogicalModemUuid());
        halRc.status = rc.getStatus();
        try {
            radioProxy.setRadioCapability(rr.mSerial, halRc);
        } catch (Exception e) {
            handleRadioProxyExceptionForRR(rr, "setRadioCapability", e);
        }
    }
}
#end_block

#method_before
@Override
public void startLceService(int reportIntervalMs, boolean pullMode, Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_START_LCE, response);
    /**
     * solicited command argument: reportIntervalMs, pullMode.
     */
    rr.mParcel.writeInt(2);
    rr.mParcel.writeInt(reportIntervalMs);
    // PULL mode: 1; PUSH mode: 0;
    rr.mParcel.writeInt(pullMode ? 1 : 0);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void startLceService(int reportIntervalMs, boolean pullMode, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_START_LCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " reportIntervalMs = " + reportIntervalMs + " pullMode = " + pullMode);
        }
        try {
            radioProxy.startLceService(rr.mSerial, reportIntervalMs, pullMode);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "startLceService", e);
        }
    }
}
#end_block

#method_before
@Override
public void stopLceService(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_STOP_LCE, response);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void stopLceService(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_STOP_LCE, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.stopLceService(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "stopLceService", e);
        }
    }
}
#end_block

#method_before
@Override
public void pullLceData(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_PULL_LCEDATA, response);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void pullLceData(Message response) {
    IRadio radioProxy = getRadioProxy(response);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_PULL_LCEDATA, response, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.pullLceData(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "pullLceData", e);
        }
    }
}
#end_block

#method_before
public void getModemActivityInfo(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_ACTIVITY_INFO, response);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
    Message msg = mSender.obtainMessage(EVENT_BLOCKING_RESPONSE_TIMEOUT);
    msg.obj = null;
    msg.arg1 = rr.mSerial;
    mSender.sendMessageDelayed(msg, DEFAULT_BLOCKING_MESSAGE_RESPONSE_TIMEOUT_MS);
}
#method_after
@Override
public void getModemActivityInfo(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_ACTIVITY_INFO, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getModemActivityInfo(rr.mSerial);
            Message msg = mRilHandler.obtainMessage(EVENT_BLOCKING_RESPONSE_TIMEOUT);
            msg.obj = null;
            msg.arg1 = rr.mSerial;
            mRilHandler.sendMessageDelayed(msg, DEFAULT_BLOCKING_MESSAGE_RESPONSE_TIMEOUT_MS);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getModemActivityInfo", e);
        }
    }
}
#end_block

#method_before
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message response) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ALLOWED_CARRIERS, response);
    rr.mParcel.writeInt(carriers.size());
    /* len_allowed_carriers */
    rr.mParcel.writeInt(0);
    /* TODO: add excluded carriers */
    for (CarrierIdentifier ci : carriers) {
        /* allowed carriers */
        rr.mParcel.writeString(ci.getMcc());
        rr.mParcel.writeString(ci.getMnc());
        int matchType = CarrierIdentifier.MatchType.ALL;
        String matchData = null;
        if (!TextUtils.isEmpty(ci.getSpn())) {
            matchType = CarrierIdentifier.MatchType.SPN;
            matchData = ci.getSpn();
        } else if (!TextUtils.isEmpty(ci.getImsi())) {
            matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
            matchData = ci.getImsi();
        } else if (!TextUtils.isEmpty(ci.getGid1())) {
            matchType = CarrierIdentifier.MatchType.GID1;
            matchData = ci.getGid1();
        } else if (!TextUtils.isEmpty(ci.getGid2())) {
            matchType = CarrierIdentifier.MatchType.GID2;
            matchData = ci.getGid2();
        }
        rr.mParcel.writeInt(matchType);
        rr.mParcel.writeString(matchData);
    }
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void setAllowedCarriers(List<CarrierIdentifier> carriers, Message result) {
    checkNotNull(carriers, "Allowed carriers list cannot be null.");
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_SET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            String logStr = "";
            for (int i = 0; i < carriers.size(); i++) {
                logStr = logStr + carriers.get(i) + " ";
            }
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + "carriers = " + logStr);
        }
        boolean allAllowed;
        if (carriers.size() == 0) {
            allAllowed = true;
        } else {
            allAllowed = false;
        }
        CarrierRestrictions carrierList = new CarrierRestrictions();
        for (CarrierIdentifier ci : carriers) {
            /* allowed carriers */
            Carrier c = new Carrier();
            c.mcc = convertNullToEmptyString(ci.getMcc());
            c.mnc = convertNullToEmptyString(ci.getMnc());
            int matchType = CarrierIdentifier.MatchType.ALL;
            String matchData = null;
            if (!TextUtils.isEmpty(ci.getSpn())) {
                matchType = CarrierIdentifier.MatchType.SPN;
                matchData = ci.getSpn();
            } else if (!TextUtils.isEmpty(ci.getImsi())) {
                matchType = CarrierIdentifier.MatchType.IMSI_PREFIX;
                matchData = ci.getImsi();
            } else if (!TextUtils.isEmpty(ci.getGid1())) {
                matchType = CarrierIdentifier.MatchType.GID1;
                matchData = ci.getGid1();
            } else if (!TextUtils.isEmpty(ci.getGid2())) {
                matchType = CarrierIdentifier.MatchType.GID2;
                matchData = ci.getGid2();
            }
            c.matchType = matchType;
            c.matchData = convertNullToEmptyString(matchData);
            carrierList.allowedCarriers.add(c);
        }
        try {
            radioProxy.setAllowedCarriers(rr.mSerial, allAllowed, carrierList);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "setAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
@Override
public void getAllowedCarriers(Message response) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_ALLOWED_CARRIERS, response);
    if (RILJ_LOGD) {
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    }
    send(rr);
}
#method_after
@Override
public void getAllowedCarriers(Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_GET_ALLOWED_CARRIERS, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.getAllowedCarriers(rr.mSerial);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
@Override
public void getIMEI(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMEI, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getIMEI(Message result) {
    throw new RuntimeException("getIMEI not expected to be called");
}
#end_block

#method_before
@Override
public void getIMEISV(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMEISV, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getIMEISV(Message result) {
    throw new RuntimeException("getIMEISV not expected to be called");
}
#end_block

#method_before
@Deprecated
@Override
public void getLastPdpFailCause(Message result) {
    getLastDataCallFailCause(result);
}
#method_after
@Deprecated
@Override
public void getLastPdpFailCause(Message result) {
    throw new RuntimeException("getLastPdpFailCause not expected to be called");
}
#end_block

#method_before
@Override
public void getLastDataCallFailCause(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void getLastDataCallFailCause(Message result) {
    throw new RuntimeException("getLastDataCallFailCause not expected to be called");
}
#end_block

#method_before
@Override
public void resetRadio(Message result) {
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESET_RADIO, result);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#method_after
@Override
public void resetRadio(Message result) {
    throw new RuntimeException("resetRadio not expected to be called");
}
#end_block

#method_before
@Override
public void handleCallSetupRequestFromSim(boolean accept, Message response) {
    RILRequest rr = RILRequest.obtain(RILConstants.RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, response);
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    int[] param = new int[1];
    param[0] = accept ? 1 : 0;
    rr.mParcel.writeIntArray(param);
    send(rr);
}
#method_after
@Override
public void handleCallSetupRequestFromSim(boolean accept, Message result) {
    IRadio radioProxy = getRadioProxy(result);
    if (radioProxy != null) {
        RILRequest rr = obtainRequest(RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, result, mRILDefaultWorkSource);
        if (RILJ_LOGD) {
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        }
        try {
            radioProxy.handleStkCallSetupRequestFromSim(rr.mSerial, accept);
        } catch (RemoteException | RuntimeException e) {
            handleRadioProxyExceptionForRR(rr, "getAllowedCarriers", e);
        }
    }
}
#end_block

#method_before
private void processResponse(Parcel p) {
    int type;
    type = p.readInt();
    if (type == RESPONSE_UNSOLICITED || type == RESPONSE_UNSOLICITED_ACK_EXP) {
        processUnsolicited(p, type);
    } else if (type == RESPONSE_SOLICITED || type == RESPONSE_SOLICITED_ACK_EXP) {
        RILRequest rr = processSolicited(p, type);
        if (rr != null) {
            if (type == RESPONSE_SOLICITED) {
                decrementWakeLock(rr);
            }
            rr.release();
            return;
        }
    } else if (type == RESPONSE_SOLICITED_ACK) {
        int serial;
        serial = p.readInt();
        RILRequest rr;
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
    }
}
#method_after
RILRequest processResponse(RadioResponseInfo responseInfo) {
    int serial = responseInfo.serial;
    int error = responseInfo.error;
    int type = responseInfo.type;
    RILRequest rr = null;
    if (type == RadioResponseType.SOLICITED_ACK) {
        synchronized (mRequestList) {
            rr = mRequestList.get(serial);
        }
        if (rr == null) {
            Rlog.w(RILJ_LOG_TAG, "Unexpected solicited ack response! sn: " + serial);
        } else {
            decrementWakeLock(rr);
            if (RILJ_LOGD) {
                riljLog(rr.serialString() + " Ack < " + requestToString(rr.mRequest));
            }
        }
        return rr;
    }
    rr = findAndRemoveRequestFromList(serial);
    if (rr == null) {
        Rlog.e(RIL.RILJ_LOG_TAG, "processResponse: Unexpected response! serial: " + serial + " error: " + error);
        return null;
    }
    // Time logging for RIL command and storing it in TelephonyHistogram.
    addToRilHistogram(rr);
    if (type == RadioResponseType.SOLICITED_ACK_EXP) {
        sendAck();
        if (RIL.RILJ_LOGD) {
            riljLog("Response received for " + rr.serialString() + " " + RIL.requestToString(rr.mRequest) + " Sending ack to ril.cpp");
        }
    } else {
    // ack sent for SOLICITED_ACK_EXP above; nothing to do for SOLICITED response
    }
    // screen when the pin or puk is entered incorrectly.
    switch(rr.mRequest) {
        case RIL_REQUEST_ENTER_SIM_PUK:
        case RIL_REQUEST_ENTER_SIM_PUK2:
            if (mIccStatusChangedRegistrants != null) {
                if (RILJ_LOGD) {
                    riljLog("ON enter sim puk fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                }
                mIccStatusChangedRegistrants.notifyRegistrants();
            }
            break;
        case RIL_REQUEST_SHUTDOWN:
            setRadioState(RadioState.RADIO_UNAVAILABLE);
            break;
    }
    if (error != RadioError.NONE) {
        switch(rr.mRequest) {
            case RIL_REQUEST_ENTER_SIM_PIN:
            case RIL_REQUEST_ENTER_SIM_PIN2:
            case RIL_REQUEST_CHANGE_SIM_PIN:
            case RIL_REQUEST_CHANGE_SIM_PIN2:
            case RIL_REQUEST_SET_FACILITY_LOCK:
                if (mIccStatusChangedRegistrants != null) {
                    if (RILJ_LOGD) {
                        riljLog("ON some errors fakeSimStatusChanged: reg count=" + mIccStatusChangedRegistrants.size());
                    }
                    mIccStatusChangedRegistrants.notifyRegistrants();
                }
                break;
        }
    } else {
        switch(rr.mRequest) {
            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
                if (mTestingEmergencyCall.getAndSet(false)) {
                    if (mEmergencyCallbackModeRegistrant != null) {
                        riljLog("testing emergency call, notify ECM Registrants");
                        mEmergencyCallbackModeRegistrant.notifyRegistrant();
                    }
                }
        }
    }
    return rr;
}
#end_block

#method_before
/**
 * Holds a PARTIAL_WAKE_LOCK whenever
 * a) There is outstanding RIL request sent to RIL deamon and no replied
 * b) There is a request pending to be sent out.
 *
 * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
 * happen often.
 */
private void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mSender.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mSender.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#method_after
/**
 * Holds a PARTIAL_WAKE_LOCK whenever
 * a) There is outstanding RIL request sent to RIL deamon and no replied
 * b) There is a request pending to be sent out.
 *
 * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
 * happen often.
 */
private void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    String clientId = getWorkSourceClientId(rr.mWorkSource);
                    if (!mClientWakelockTracker.isClientActive(clientId)) {
                        if (mActiveWakelockWorkSource != null) {
                            mActiveWakelockWorkSource.add(rr.mWorkSource);
                        } else {
                            mActiveWakelockWorkSource = rr.mWorkSource;
                        }
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    mClientWakelockTracker.startTracking(rr.mClientId, rr.mRequest, rr.mSerial, mWakeLockCount);
                    Message msg = mRilHandler.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mRilHandler.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#end_block

#method_before
private void decrementWakeLock(RILRequest rr) {
    synchronized (rr) {
        switch(rr.mWakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    if (mWakeLockCount > 1) {
                        mWakeLockCount--;
                    } else {
                        mWakeLockCount = 0;
                        mWakeLock.release();
                    }
                }
                break;
            case FOR_ACK_WAKELOCK:
                // We do not decrement the ACK wakelock
                break;
            case INVALID_WAKELOCK:
                break;
            default:
                Rlog.w(RILJ_LOG_TAG, "Decrementing Invalid Wakelock type " + rr.mWakeLockType);
        }
        rr.mWakeLockType = INVALID_WAKELOCK;
    }
}
#method_after
private void decrementWakeLock(RILRequest rr) {
    synchronized (rr) {
        switch(rr.mWakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mClientWakelockTracker.stopTracking(rr.mClientId, rr.mRequest, rr.mSerial, (mWakeLockCount > 1) ? mWakeLockCount - 1 : 0);
                    String clientId = getWorkSourceClientId(rr.mWorkSource);
                    ;
                    if (!mClientWakelockTracker.isClientActive(clientId) && (mActiveWakelockWorkSource != null)) {
                        mActiveWakelockWorkSource.remove(rr.mWorkSource);
                        if (mActiveWakelockWorkSource.size() == 0) {
                            mActiveWakelockWorkSource = null;
                        }
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    if (mWakeLockCount > 1) {
                        mWakeLockCount--;
                    } else {
                        mWakeLockCount = 0;
                        mWakeLock.release();
                    }
                }
                break;
            case FOR_ACK_WAKELOCK:
                // We do not decrement the ACK wakelock
                break;
            case INVALID_WAKELOCK:
                break;
            default:
                Rlog.w(RILJ_LOG_TAG, "Decrementing Invalid Wakelock type " + rr.mWakeLockType);
        }
        rr.mWakeLockType = INVALID_WAKELOCK;
    }
}
#end_block

#method_before
private boolean clearWakeLock(int wakeLockType) {
    if (wakeLockType == FOR_WAKELOCK) {
        synchronized (mWakeLock) {
            if (mWakeLockCount == 0 && mWakeLock.isHeld() == false)
                return false;
            Rlog.d(RILJ_LOG_TAG, "NOTE: mWakeLockCount is " + mWakeLockCount + "at time of clearing");
            mWakeLockCount = 0;
            mWakeLock.release();
            return true;
        }
    } else {
        synchronized (mAckWakeLock) {
            if (mAckWakeLock.isHeld() == false)
                return false;
            mAckWakeLock.release();
            return true;
        }
    }
}
#method_after
private boolean clearWakeLock(int wakeLockType) {
    if (wakeLockType == FOR_WAKELOCK) {
        synchronized (mWakeLock) {
            if (mWakeLockCount == 0 && !mWakeLock.isHeld())
                return false;
            Rlog.d(RILJ_LOG_TAG, "NOTE: mWakeLockCount is " + mWakeLockCount + "at time of clearing");
            mWakeLockCount = 0;
            mWakeLock.release();
            mClientWakelockTracker.stopTrackingAll();
            mActiveWakelockWorkSource = null;
            return true;
        }
    } else {
        synchronized (mAckWakeLock) {
            if (!mAckWakeLock.isHeld())
                return false;
            mAckWakeLock.release();
            return true;
        }
    }
}
#end_block

#method_before
private RadioCapability makeStaticRadioCapability() {
    // default to UNKNOWN so we fail fast.
    int raf = RadioAccessFamily.RAF_UNKNOWN;
    String rafString = mContext.getResources().getString(com.android.internal.R.string.config_radio_access_family);
    if (TextUtils.isEmpty(rafString) == false) {
        raf = RadioAccessFamily.rafTypeFromString(rafString);
    }
    RadioCapability rc = new RadioCapability(mInstanceId.intValue(), 0, 0, raf, "", RadioCapability.RC_STATUS_SUCCESS);
    if (RILJ_LOGD)
        riljLog("Faking RIL_REQUEST_GET_RADIO_CAPABILITY response using " + raf);
    return rc;
}
#method_after
RadioCapability makeStaticRadioCapability() {
    // default to UNKNOWN so we fail fast.
    int raf = RadioAccessFamily.RAF_UNKNOWN;
    String rafString = mContext.getResources().getString(com.android.internal.R.string.config_radio_access_family);
    if (!TextUtils.isEmpty(rafString)) {
        raf = RadioAccessFamily.rafTypeFromString(rafString);
    }
    RadioCapability rc = new RadioCapability(mPhoneId.intValue(), 0, 0, raf, "", RadioCapability.RC_STATUS_SUCCESS);
    if (RILJ_LOGD)
        riljLog("Faking RIL_REQUEST_GET_RADIO_CAPABILITY response using " + raf);
    return rc;
}
#end_block

#method_before
private void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#method_after
void notifyRegistrantsRilConnectionChanged(int rilVer) {
    mRilVersion = rilVer;
    if (mRilConnectedRegistrants != null) {
        mRilConnectedRegistrants.notifyRegistrants(new AsyncResult(null, new Integer(rilVer), null));
    }
}
#end_block

#method_before
private void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#method_after
void notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
    int response = RIL_UNSOL_CDMA_INFO_REC;
    if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
        if (mDisplayInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mDisplayInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaSignalInfoRec) {
        if (mSignalInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mSignalInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaNumberInfoRec) {
        if (mNumberInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mNumberInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaRedirectingNumberInfoRec) {
        if (mRedirNumInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mRedirNumInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaLineControlInfoRec) {
        if (mLineControlInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mLineControlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53ClirInfoRec) {
        if (mT53ClirInfoRegistrants != null) {
            if (RILJ_LOGD)
                unsljLogRet(response, infoRec.record);
            mT53ClirInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    } else if (infoRec.record instanceof CdmaInformationRecords.CdmaT53AudioControlInfoRec) {
        if (mT53AudCntrlInfoRegistrants != null) {
            if (RILJ_LOGD) {
                unsljLogRet(response, infoRec.record);
            }
            mT53AudCntrlInfoRegistrants.notifyRegistrants(new AsyncResult(null, infoRec.record, null));
        }
    }
}
#end_block

#method_before
static String requestToString(int request) {
    /*
 cat libs/telephony/ril_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#method_after
static String requestToString(int request) {
    switch(request) {
        case RIL_REQUEST_GET_SIM_STATUS:
            return "GET_SIM_STATUS";
        case RIL_REQUEST_ENTER_SIM_PIN:
            return "ENTER_SIM_PIN";
        case RIL_REQUEST_ENTER_SIM_PUK:
            return "ENTER_SIM_PUK";
        case RIL_REQUEST_ENTER_SIM_PIN2:
            return "ENTER_SIM_PIN2";
        case RIL_REQUEST_ENTER_SIM_PUK2:
            return "ENTER_SIM_PUK2";
        case RIL_REQUEST_CHANGE_SIM_PIN:
            return "CHANGE_SIM_PIN";
        case RIL_REQUEST_CHANGE_SIM_PIN2:
            return "CHANGE_SIM_PIN2";
        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
            return "ENTER_NETWORK_DEPERSONALIZATION";
        case RIL_REQUEST_GET_CURRENT_CALLS:
            return "GET_CURRENT_CALLS";
        case RIL_REQUEST_DIAL:
            return "DIAL";
        case RIL_REQUEST_GET_IMSI:
            return "GET_IMSI";
        case RIL_REQUEST_HANGUP:
            return "HANGUP";
        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND:
            return "HANGUP_WAITING_OR_BACKGROUND";
        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
            return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
            return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
        case RIL_REQUEST_CONFERENCE:
            return "CONFERENCE";
        case RIL_REQUEST_UDUB:
            return "UDUB";
        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE:
            return "LAST_CALL_FAIL_CAUSE";
        case RIL_REQUEST_SIGNAL_STRENGTH:
            return "SIGNAL_STRENGTH";
        case RIL_REQUEST_VOICE_REGISTRATION_STATE:
            return "VOICE_REGISTRATION_STATE";
        case RIL_REQUEST_DATA_REGISTRATION_STATE:
            return "DATA_REGISTRATION_STATE";
        case RIL_REQUEST_OPERATOR:
            return "OPERATOR";
        case RIL_REQUEST_RADIO_POWER:
            return "RADIO_POWER";
        case RIL_REQUEST_DTMF:
            return "DTMF";
        case RIL_REQUEST_SEND_SMS:
            return "SEND_SMS";
        case RIL_REQUEST_SEND_SMS_EXPECT_MORE:
            return "SEND_SMS_EXPECT_MORE";
        case RIL_REQUEST_SETUP_DATA_CALL:
            return "SETUP_DATA_CALL";
        case RIL_REQUEST_SIM_IO:
            return "SIM_IO";
        case RIL_REQUEST_SEND_USSD:
            return "SEND_USSD";
        case RIL_REQUEST_CANCEL_USSD:
            return "CANCEL_USSD";
        case RIL_REQUEST_GET_CLIR:
            return "GET_CLIR";
        case RIL_REQUEST_SET_CLIR:
            return "SET_CLIR";
        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS:
            return "QUERY_CALL_FORWARD_STATUS";
        case RIL_REQUEST_SET_CALL_FORWARD:
            return "SET_CALL_FORWARD";
        case RIL_REQUEST_QUERY_CALL_WAITING:
            return "QUERY_CALL_WAITING";
        case RIL_REQUEST_SET_CALL_WAITING:
            return "SET_CALL_WAITING";
        case RIL_REQUEST_SMS_ACKNOWLEDGE:
            return "SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GET_IMEI:
            return "GET_IMEI";
        case RIL_REQUEST_GET_IMEISV:
            return "GET_IMEISV";
        case RIL_REQUEST_ANSWER:
            return "ANSWER";
        case RIL_REQUEST_DEACTIVATE_DATA_CALL:
            return "DEACTIVATE_DATA_CALL";
        case RIL_REQUEST_QUERY_FACILITY_LOCK:
            return "QUERY_FACILITY_LOCK";
        case RIL_REQUEST_SET_FACILITY_LOCK:
            return "SET_FACILITY_LOCK";
        case RIL_REQUEST_CHANGE_BARRING_PASSWORD:
            return "CHANGE_BARRING_PASSWORD";
        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
            return "QUERY_NETWORK_SELECTION_MODE";
        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
            return "SET_NETWORK_SELECTION_AUTOMATIC";
        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
            return "SET_NETWORK_SELECTION_MANUAL";
        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
            return "QUERY_AVAILABLE_NETWORKS ";
        case RIL_REQUEST_DTMF_START:
            return "DTMF_START";
        case RIL_REQUEST_DTMF_STOP:
            return "DTMF_STOP";
        case RIL_REQUEST_BASEBAND_VERSION:
            return "BASEBAND_VERSION";
        case RIL_REQUEST_SEPARATE_CONNECTION:
            return "SEPARATE_CONNECTION";
        case RIL_REQUEST_SET_MUTE:
            return "SET_MUTE";
        case RIL_REQUEST_GET_MUTE:
            return "GET_MUTE";
        case RIL_REQUEST_QUERY_CLIP:
            return "QUERY_CLIP";
        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE:
            return "LAST_DATA_CALL_FAIL_CAUSE";
        case RIL_REQUEST_DATA_CALL_LIST:
            return "DATA_CALL_LIST";
        case RIL_REQUEST_RESET_RADIO:
            return "RESET_RADIO";
        case RIL_REQUEST_OEM_HOOK_RAW:
            return "OEM_HOOK_RAW";
        case RIL_REQUEST_OEM_HOOK_STRINGS:
            return "OEM_HOOK_STRINGS";
        case RIL_REQUEST_SCREEN_STATE:
            return "SCREEN_STATE";
        case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION:
            return "SET_SUPP_SVC_NOTIFICATION";
        case RIL_REQUEST_WRITE_SMS_TO_SIM:
            return "WRITE_SMS_TO_SIM";
        case RIL_REQUEST_DELETE_SMS_ON_SIM:
            return "DELETE_SMS_ON_SIM";
        case RIL_REQUEST_SET_BAND_MODE:
            return "SET_BAND_MODE";
        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE:
            return "QUERY_AVAILABLE_BAND_MODE";
        case RIL_REQUEST_STK_GET_PROFILE:
            return "REQUEST_STK_GET_PROFILE";
        case RIL_REQUEST_STK_SET_PROFILE:
            return "REQUEST_STK_SET_PROFILE";
        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND:
            return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
            return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
            return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER:
            return "REQUEST_EXPLICIT_CALL_TRANSFER";
        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
            return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS:
            return "REQUEST_GET_NEIGHBORING_CELL_IDS";
        case RIL_REQUEST_SET_LOCATION_UPDATES:
            return "REQUEST_SET_LOCATION_UPDATES";
        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
            return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
        case RIL_REQUEST_SET_TTY_MODE:
            return "RIL_REQUEST_SET_TTY_MODE";
        case RIL_REQUEST_QUERY_TTY_MODE:
            return "RIL_REQUEST_QUERY_TTY_MODE";
        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
            return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
        case RIL_REQUEST_CDMA_FLASH:
            return "RIL_REQUEST_CDMA_FLASH";
        case RIL_REQUEST_CDMA_BURST_DTMF:
            return "RIL_REQUEST_CDMA_BURST_DTMF";
        case RIL_REQUEST_CDMA_SEND_SMS:
            return "RIL_REQUEST_CDMA_SEND_SMS";
        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:
            return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
        case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
        case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
            return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
        case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
            return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
        case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
            return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
        case RIL_REQUEST_CDMA_SUBSCRIPTION:
            return "RIL_REQUEST_CDMA_SUBSCRIPTION";
        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM:
            return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM:
            return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
        case RIL_REQUEST_DEVICE_IDENTITY:
            return "RIL_REQUEST_DEVICE_IDENTITY";
        case RIL_REQUEST_GET_SMSC_ADDRESS:
            return "RIL_REQUEST_GET_SMSC_ADDRESS";
        case RIL_REQUEST_SET_SMSC_ADDRESS:
            return "RIL_REQUEST_SET_SMSC_ADDRESS";
        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
            return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
            return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
            return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
            return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
        case RIL_REQUEST_ISIM_AUTHENTICATION:
            return "RIL_REQUEST_ISIM_AUTHENTICATION";
        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
            return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
            return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
        case RIL_REQUEST_VOICE_RADIO_TECH:
            return "RIL_REQUEST_VOICE_RADIO_TECH";
        case RIL_REQUEST_GET_CELL_INFO_LIST:
            return "RIL_REQUEST_GET_CELL_INFO_LIST";
        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
            return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
        case RIL_REQUEST_SET_INITIAL_ATTACH_APN:
            return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
        case RIL_REQUEST_SET_DATA_PROFILE:
            return "RIL_REQUEST_SET_DATA_PROFILE";
        case RIL_REQUEST_IMS_REGISTRATION_STATE:
            return "RIL_REQUEST_IMS_REGISTRATION_STATE";
        case RIL_REQUEST_IMS_SEND_SMS:
            return "RIL_REQUEST_IMS_SEND_SMS";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
            return "RIL_REQUEST_SIM_OPEN_CHANNEL";
        case RIL_REQUEST_SIM_CLOSE_CHANNEL:
            return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
        case RIL_REQUEST_NV_READ_ITEM:
            return "RIL_REQUEST_NV_READ_ITEM";
        case RIL_REQUEST_NV_WRITE_ITEM:
            return "RIL_REQUEST_NV_WRITE_ITEM";
        case RIL_REQUEST_NV_WRITE_CDMA_PRL:
            return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
        case RIL_REQUEST_NV_RESET_CONFIG:
            return "RIL_REQUEST_NV_RESET_CONFIG";
        case RIL_REQUEST_SET_UICC_SUBSCRIPTION:
            return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
        case RIL_REQUEST_ALLOW_DATA:
            return "RIL_REQUEST_ALLOW_DATA";
        case RIL_REQUEST_GET_HARDWARE_CONFIG:
            return "GET_HARDWARE_CONFIG";
        case RIL_REQUEST_SIM_AUTHENTICATION:
            return "RIL_REQUEST_SIM_AUTHENTICATION";
        case RIL_REQUEST_SHUTDOWN:
            return "RIL_REQUEST_SHUTDOWN";
        case RIL_REQUEST_SET_RADIO_CAPABILITY:
            return "RIL_REQUEST_SET_RADIO_CAPABILITY";
        case RIL_REQUEST_GET_RADIO_CAPABILITY:
            return "RIL_REQUEST_GET_RADIO_CAPABILITY";
        case RIL_REQUEST_START_LCE:
            return "RIL_REQUEST_START_LCE";
        case RIL_REQUEST_STOP_LCE:
            return "RIL_REQUEST_STOP_LCE";
        case RIL_REQUEST_PULL_LCEDATA:
            return "RIL_REQUEST_PULL_LCEDATA";
        case RIL_REQUEST_GET_ACTIVITY_INFO:
            return "RIL_REQUEST_GET_ACTIVITY_INFO";
        case RIL_REQUEST_SET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_SET_ALLOWED_CARRIERS";
        case RIL_REQUEST_GET_ALLOWED_CARRIERS:
            return "RIL_REQUEST_GET_ALLOWED_CARRIERS";
        case RIL_REQUEST_SET_SIM_CARD_POWER:
            return "RIL_REQUEST_SET_SIM_CARD_POWER";
        case RIL_REQUEST_SEND_DEVICE_STATE:
            return "RIL_REQUEST_SEND_DEVICE_STATE";
        case RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER:
            return "RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER";
        case RIL_RESPONSE_ACKNOWLEDGEMENT:
            return "RIL_RESPONSE_ACKNOWLEDGEMENT";
        default:
            return "<unknown request>";
    }
}
#end_block

#method_before
static String responseToString(int request) {
    /*
 cat libs/telephony/ril_unsol_commands.h \
 | egrep "^ *{RIL_" \
 | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
*/
    switch(request) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            return "UNSOL_RESPONSE_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
        case RIL_UNSOL_ON_USSD:
            return "UNSOL_ON_USSD";
        case RIL_UNSOL_ON_USSD_REQUEST:
            return "UNSOL_ON_USSD_REQUEST";
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            return "UNSOL_NITZ_TIME_RECEIVED";
        case RIL_UNSOL_SIGNAL_STRENGTH:
            return "UNSOL_SIGNAL_STRENGTH";
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            return "UNSOL_DATA_CALL_LIST_CHANGED";
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            return "UNSOL_SUPP_SVC_NOTIFICATION";
        case RIL_UNSOL_STK_SESSION_END:
            return "UNSOL_STK_SESSION_END";
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            return "UNSOL_STK_PROACTIVE_COMMAND";
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            return "UNSOL_STK_EVENT_NOTIFY";
        case RIL_UNSOL_STK_CALL_SETUP:
            return "UNSOL_STK_CALL_SETUP";
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            return "UNSOL_SIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_SIM_REFRESH:
            return "UNSOL_SIM_REFRESH";
        case RIL_UNSOL_CALL_RING:
            return "UNSOL_CALL_RING";
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            return "UNSOL_RESPONSE_CDMA_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            return "UNSOL_RESTRICTED_STATE_CHANGED";
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_CDMA_CALL_WAITING:
            return "UNSOL_CDMA_CALL_WAITING";
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            return "UNSOL_CDMA_OTA_PROVISION_STATUS";
        case RIL_UNSOL_CDMA_INFO_REC:
            return "UNSOL_CDMA_INFO_REC";
        case RIL_UNSOL_OEM_HOOK_RAW:
            return "UNSOL_OEM_HOOK_RAW";
        case RIL_UNSOL_RINGBACK_TONE:
            return "UNSOL_RINGBACK_TONE";
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            return "UNSOL_RESEND_INCALL_MUTE";
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            return "UNSOL_CDMA_PRL_CHANGED";
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_RIL_CONNECTED:
            return "UNSOL_RIL_CONNECTED";
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            return "UNSOL_VOICE_RADIO_TECH_CHANGED";
        case RIL_UNSOL_CELL_INFO_LIST:
            return "UNSOL_CELL_INFO_LIST";
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            return "UNSOL_SRVCC_STATE_NOTIFY";
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
        case RIL_UNSOL_RADIO_CAPABILITY:
            return "RIL_UNSOL_RADIO_CAPABILITY";
        case RIL_UNSOL_ON_SS:
            return "UNSOL_ON_SS";
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            return "UNSOL_STK_CC_ALPHA_NOTIFY";
        case RIL_UNSOL_LCEDATA_RECV:
            return "UNSOL_LCE_INFO_RECV";
        case RIL_UNSOL_PCO_DATA:
            return "UNSOL_PCO_DATA";
        default:
            return "<unknown response>";
    }
}
#method_after
static String responseToString(int request) {
    switch(request) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
            return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_RESPONSE_NEW_SMS:
            return "UNSOL_RESPONSE_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
            return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
            return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
        case RIL_UNSOL_ON_USSD:
            return "UNSOL_ON_USSD";
        case RIL_UNSOL_ON_USSD_REQUEST:
            return "UNSOL_ON_USSD_REQUEST";
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            return "UNSOL_NITZ_TIME_RECEIVED";
        case RIL_UNSOL_SIGNAL_STRENGTH:
            return "UNSOL_SIGNAL_STRENGTH";
        case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
            return "UNSOL_DATA_CALL_LIST_CHANGED";
        case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
            return "UNSOL_SUPP_SVC_NOTIFICATION";
        case RIL_UNSOL_STK_SESSION_END:
            return "UNSOL_STK_SESSION_END";
        case RIL_UNSOL_STK_PROACTIVE_COMMAND:
            return "UNSOL_STK_PROACTIVE_COMMAND";
        case RIL_UNSOL_STK_EVENT_NOTIFY:
            return "UNSOL_STK_EVENT_NOTIFY";
        case RIL_UNSOL_STK_CALL_SETUP:
            return "UNSOL_STK_CALL_SETUP";
        case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
            return "UNSOL_SIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_SIM_REFRESH:
            return "UNSOL_SIM_REFRESH";
        case RIL_UNSOL_CALL_RING:
            return "UNSOL_CALL_RING";
        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
            return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
            return "UNSOL_RESPONSE_CDMA_NEW_SMS";
        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
            return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
            return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
        case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
            return "UNSOL_RESTRICTED_STATE_CHANGED";
        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_CDMA_CALL_WAITING:
            return "UNSOL_CDMA_CALL_WAITING";
        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
            return "UNSOL_CDMA_OTA_PROVISION_STATUS";
        case RIL_UNSOL_CDMA_INFO_REC:
            return "UNSOL_CDMA_INFO_REC";
        case RIL_UNSOL_OEM_HOOK_RAW:
            return "UNSOL_OEM_HOOK_RAW";
        case RIL_UNSOL_RINGBACK_TONE:
            return "UNSOL_RINGBACK_TONE";
        case RIL_UNSOL_RESEND_INCALL_MUTE:
            return "UNSOL_RESEND_INCALL_MUTE";
        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
        case RIL_UNSOl_CDMA_PRL_CHANGED:
            return "UNSOL_CDMA_PRL_CHANGED";
        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
            return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
        case RIL_UNSOL_RIL_CONNECTED:
            return "UNSOL_RIL_CONNECTED";
        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED:
            return "UNSOL_VOICE_RADIO_TECH_CHANGED";
        case RIL_UNSOL_CELL_INFO_LIST:
            return "UNSOL_CELL_INFO_LIST";
        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
            return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
            return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
        case RIL_UNSOL_SRVCC_STATE_NOTIFY:
            return "UNSOL_SRVCC_STATE_NOTIFY";
        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED:
            return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
        case RIL_UNSOL_RADIO_CAPABILITY:
            return "RIL_UNSOL_RADIO_CAPABILITY";
        case RIL_UNSOL_ON_SS:
            return "UNSOL_ON_SS";
        case RIL_UNSOL_STK_CC_ALPHA_NOTIFY:
            return "UNSOL_STK_CC_ALPHA_NOTIFY";
        case RIL_UNSOL_LCEDATA_RECV:
            return "UNSOL_LCE_INFO_RECV";
        case RIL_UNSOL_PCO_DATA:
            return "UNSOL_PCO_DATA";
        default:
            return "<unknown response>";
    }
}
#end_block

#method_before
private void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
void riljLog(String msg) {
    Rlog.d(RILJ_LOG_TAG, msg + (mPhoneId != null ? (" [SUB" + mPhoneId + "]") : ""));
}
#end_block

#method_before
private void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mInstanceId != null ? (" [SUB" + mInstanceId + "]") : ""));
}
#method_after
void riljLogv(String msg) {
    Rlog.v(RILJ_LOG_TAG, msg + (mPhoneId != null ? (" [SUB" + mPhoneId + "]") : ""));
}
#end_block

#method_before
private void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#method_after
void unsljLog(int response) {
    riljLog("[UNSL]< " + responseToString(response));
}
#end_block

#method_before
private void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#method_after
void unsljLogMore(int response, String more) {
    riljLog("[UNSL]< " + responseToString(response) + " " + more);
}
#end_block

#method_before
private void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
void unsljLogRet(int response, Object ret) {
    riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
private void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#method_after
void unsljLogvRet(int response, Object ret) {
    riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("RIL: " + this);
    pw.println(" mSocket=" + mSocket);
    pw.println(" mSenderThread=" + mSenderThread);
    pw.println(" mSender=" + mSender);
    pw.println(" mReceiverThread=" + mReceiverThread);
    pw.println(" mReceiver=" + mReceiver);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mWakeLockTimeout=" + mWakeLockTimeout);
    synchronized (mRequestList) {
        synchronized (mWakeLock) {
            pw.println(" mWakeLockCount=" + mWakeLockCount);
        }
        int count = mRequestList.size();
        pw.println(" mRequestList count=" + count);
        for (int i = 0; i < count; i++) {
            RILRequest rr = mRequestList.valueAt(i);
            pw.println("  [" + rr.mSerial + "] " + requestToString(rr.mRequest));
        }
    }
    pw.println(" mLastNITZTimeInfo=" + Arrays.toString(mLastNITZTimeInfo));
    pw.println(" mTestingEmergencyCall=" + mTestingEmergencyCall.get());
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("RIL: " + this);
    pw.println(" mSocket=" + mSocket);
    pw.println(" mReceiverThread=" + mReceiverThread);
    pw.println(" mReceiver=" + mReceiver);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mWakeLockTimeout=" + mWakeLockTimeout);
    synchronized (mRequestList) {
        synchronized (mWakeLock) {
            pw.println(" mWakeLockCount=" + mWakeLockCount);
        }
        int count = mRequestList.size();
        pw.println(" mRequestList count=" + count);
        for (int i = 0; i < count; i++) {
            RILRequest rr = mRequestList.valueAt(i);
            pw.println("  [" + rr.mSerial + "] " + requestToString(rr.mRequest));
        }
    }
    pw.println(" mLastNITZTimeInfo=" + Arrays.toString(mLastNITZTimeInfo));
    pw.println(" mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    mClientWakelockTracker.dumpClientRequestTracker();
}
#end_block

#method_before
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
    loglocal("Open Logical Channel: " + AID + " , " + p2 + " by pid:" + Binder.getCallingPid() + " uid:" + Binder.getCallingUid());
    mCi.iccOpenLogicalChannel(AID, p2, mHandler.obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, response));
}
#method_after
public void iccOpenLogicalChannel(String AID, int p2, Message response) {
    loglocal("Open Logical Channel: " + AID + " , " + p2 + " by pid:" + Binder.getCallingPid() + " uid:" + Binder.getCallingUid());
    mCi.iccOpenLogicalChannel(AID, p2, mHandler.obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, response));
}
#end_block

#method_before
@Test
@SmallTest
public void testUpdateUiccCardState() {
    int mChannelId = 1;
    /* set card as present */
    mIccCardStatus.mCardState = IccCardStatus.CardState.CARDSTATE_PRESENT;
    /* Mock open Channel ID 1 */
    mSimulatedCommands.setOpenChannelId(mChannelId);
    Message mCardUpdate = mHandler.obtainMessage(UICCCARD_UPDATE_CARD_STATE_EVENT);
    setReady(false);
    mCardUpdate.sendToTarget();
    /* try to create a new CarrierPrivilege, loading state -> loaded state */
    /* wait till the async result and message delay */
    waitUntilReady();
    assertEquals(IccCardStatus.CardState.CARDSTATE_PRESENT, mUicccard.getCardState());
    waitForMs(50);
    assertTrue(mUicccard.areCarrierPriviligeRulesLoaded());
    verify(mSimulatedCommandsVerifier, times(1)).iccOpenLogicalChannel(isA(String.class), isA(byte.class), isA(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).iccTransmitApduLogicalChannel(eq(mChannelId), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyString(), isA(Message.class));
}
#method_after
@Test
@SmallTest
public void testUpdateUiccCardState() {
    int mChannelId = 1;
    /* set card as present */
    mIccCardStatus.mCardState = IccCardStatus.CardState.CARDSTATE_PRESENT;
    /* Mock open Channel ID 1 */
    mSimulatedCommands.setOpenChannelId(mChannelId);
    Message mCardUpdate = mHandler.obtainMessage(UICCCARD_UPDATE_CARD_STATE_EVENT);
    setReady(false);
    mCardUpdate.sendToTarget();
    /* try to create a new CarrierPrivilege, loading state -> loaded state */
    /* wait till the async result and message delay */
    waitUntilReady();
    assertEquals(IccCardStatus.CardState.CARDSTATE_PRESENT, mUicccard.getCardState());
    waitForMs(50);
    assertTrue(mUicccard.areCarrierPriviligeRulesLoaded());
    verify(mSimulatedCommandsVerifier, times(1)).iccOpenLogicalChannel(isA(String.class), anyInt(), isA(Message.class));
    verify(mSimulatedCommandsVerifier, times(1)).iccTransmitApduLogicalChannel(eq(mChannelId), anyInt(), anyInt(), anyInt(), anyInt(), anyInt(), anyString(), isA(Message.class));
}
#end_block

#method_before
private void openChannel() {
    // Send open logical channel request.
    byte p2 = 0x00;
    mUiccCard.iccOpenLogicalChannel(AID, p2, /* supported p2 value */
    obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, null));
}
#method_after
private void openChannel() {
    // Send open logical channel request.
    int p2 = 0x00;
    mUiccCard.iccOpenLogicalChannel(AID, p2, /* supported p2 value */
    obtainMessage(EVENT_OPEN_LOGICAL_CHANNEL_DONE, null));
}
#end_block

#method_before
@Override
public void getVoiceRegistrationState(Message result) {
    mGetVoiceRegistrationStateCallCount.incrementAndGet();
    String[] ret = new String[14];
    ret[0] = Integer.toString(mVoiceRegState);
    ret[3] = Integer.toString(mVoiceRadioTech);
    resultSuccess(result, ret);
}
#method_after
@Override
public void getVoiceRegistrationState(Message result) {
    mGetVoiceRegistrationStateCallCount.incrementAndGet();
    VoiceRegStateResult ret = new VoiceRegStateResult();
    ret.regState = mVoiceRegState;
    ret.rat = mVoiceRadioTech;
    resultSuccess(result, ret);
}
#end_block

#method_before
@Override
public void getDataRegistrationState(Message result) {
    mGetDataRegistrationStateCallCount.incrementAndGet();
    String[] ret = new String[11];
    ret[0] = Integer.toString(mDataRegState);
    ret[3] = Integer.toString(mDataRadioTech);
    resultSuccess(result, ret);
}
#method_after
@Override
public void getDataRegistrationState(Message result) {
    mGetDataRegistrationStateCallCount.incrementAndGet();
    DataRegStateResult ret = new DataRegStateResult();
    ret.regState = mDataRegState;
    ret.rat = mDataRadioTech;
    resultSuccess(result, ret);
}
#end_block

#method_before
@Override
public void setupDataCall(int radioTechnology, int profile, String apn, String user, String password, int authType, String protocol, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, profile, apn, user, password, authType, protocol, result);
    if (mDcResponse == null) {
        mDcResponse = new DataCallResponse();
        mDcResponse.version = 11;
        mDcResponse.status = 0;
        mDcResponse.suggestedRetryTime = -1;
        mDcResponse.cid = 1;
        mDcResponse.active = 2;
        mDcResponse.type = "IP";
        mDcResponse.ifname = "rmnet_data7";
        mDcResponse.mtu = 1440;
        mDcResponse.addresses = new String[] { "12.34.56.78" };
        mDcResponse.dnses = new String[] { "98.76.54.32" };
        mDcResponse.gateways = new String[] { "11.22.33.44" };
        mDcResponse.pcscf = new String[] {};
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#method_after
@Override
public void setupDataCall(int radioTechnology, DataProfile dataProfile, boolean isRoaming, boolean allowRoaming, Message result) {
    SimulatedCommandsVerifier.getInstance().setupDataCall(radioTechnology, dataProfile, isRoaming, allowRoaming, result);
    if (mDcResponse == null) {
        mDcResponse = new DataCallResponse(0, -1, 1, 2, "IP", "rmnet_data7", "12.34.56.78", "98.76.54.32", "11.22.33.44", "", 1440);
    }
    if (mDcSuccess) {
        resultSuccess(result, mDcResponse);
    } else {
        resultFail(result, mDcResponse, new RuntimeException("Setup data call failed!"));
    }
}
#end_block

#method_before
@Override
public void getNeighboringCids(Message result) {
    int[] ret = new int[7];
    ret[0] = 6;
    for (int i = 1; i < 7; i++) {
        ret[i] = i;
    }
    resultSuccess(result, ret);
}
#method_after
@Override
public void getNeighboringCids(Message result, WorkSource workSource) {
    int[] ret = new int[7];
    ret[0] = 6;
    for (int i = 1; i < 7; i++) {
        ret[i] = i;
    }
    resultSuccess(result, ret);
}
#end_block

#method_before
@Override
public void getCellInfoList(Message response) {
    if (mCellInfoList == null) {
        Parcel p = Parcel.obtain();
        p.writeInt(1);
        p.writeInt(1);
        p.writeInt(2);
        p.writeLong(1453510289108L);
        p.writeInt(310);
        p.writeInt(260);
        p.writeInt(123);
        p.writeInt(456);
        p.writeInt(99);
        p.writeInt(3);
        p.setDataPosition(0);
        CellInfoGsm cellInfo = CellInfoGsm.CREATOR.createFromParcel(p);
        ArrayList<CellInfo> mCellInfoList = new ArrayList();
        mCellInfoList.add(cellInfo);
    }
    resultSuccess(response, mCellInfoList);
}
#method_after
@Override
public void getCellInfoList(Message response, WorkSource WorkSource) {
    if (mCellInfoList == null) {
        Parcel p = Parcel.obtain();
        p.writeInt(1);
        p.writeInt(1);
        p.writeInt(2);
        p.writeLong(1453510289108L);
        p.writeInt(310);
        p.writeInt(260);
        p.writeInt(123);
        p.writeInt(456);
        p.writeInt(99);
        p.writeInt(3);
        p.setDataPosition(0);
        CellInfoGsm cellInfo = CellInfoGsm.CREATOR.createFromParcel(p);
        ArrayList<CellInfo> mCellInfoList = new ArrayList();
        mCellInfoList.add(cellInfo);
    }
    resultSuccess(response, mCellInfoList);
}
#end_block

#method_before
@Override
public void setCellInfoListRate(int rateInMillis, Message response) {
    unimplemented(response);
}
#method_after
@Override
public void setCellInfoListRate(int rateInMillis, Message response, WorkSource workSource) {
    unimplemented(response);
}
#end_block

#method_before
@Override
public void setInitialAttachApn(String apn, String protocol, int authType, String username, String password, Message result) {
}
#method_after
@Override
public void setInitialAttachApn(DataProfile dataProfile, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void setDataProfile(DataProfile[] dps, Message result) {
}
#method_after
@Override
public void setDataProfile(DataProfile[] dps, boolean isRoaming, Message result) {
}
#end_block

#method_before
@Override
public void iccOpenLogicalChannel(String AID, byte p2, Message response) {
    SimulatedCommandsVerifier.getInstance().iccOpenLogicalChannel(AID, p2, response);
    Object result = new int[] { mChannelId };
    resultSuccess(response, result);
}
#method_after
@Override
public void iccOpenLogicalChannel(String AID, int p2, Message response) {
    SimulatedCommandsVerifier.getInstance().iccOpenLogicalChannel(AID, p2, response);
    Object result = new int[] { mChannelId };
    resultSuccess(response, result);
}
#end_block

#method_before
@VisibleForTesting
public void triggerRestrictedStateChanged(int restrictedState) {
    if (mRestrictedStateRegistrant != null) {
        mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, new int[] { restrictedState }, null));
    }
}
#method_after
@VisibleForTesting
public void triggerRestrictedStateChanged(int restrictedState) {
    if (mRestrictedStateRegistrant != null) {
        mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null, restrictedState, null));
    }
}
#end_block

#method_before
private void setAdapter() {
    if (mCursorAdapter == null) {
        mCursorAdapter = newAdapter();
        ((SimpleCursorAdapter) mCursorAdapter).setViewBinder(new SimpleCursorAdapter.ViewBinder() {

            public boolean setViewValue(View view, Cursor cursor, int columnIndex) {
                view.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
                if (columnIndex == NUMBER_COLUMN) {
                    String number = formatLtr(cursor.getString(NUMBER_COLUMN));
                    if (view instanceof TextView) {
                        ((TextView) view).setText(number);
                    }
                    return true;
                }
                return false;
            }
        });
        setListAdapter(mCursorAdapter);
    } else {
        mCursorAdapter.changeCursor(mCursor);
    }
    if (mInitialSelection >= 0 && mInitialSelection < mCursorAdapter.getCount()) {
        setSelection(mInitialSelection);
        getListView().setFocusableInTouchMode(true);
        boolean gotfocus = getListView().requestFocus();
    }
}
#method_after
private void setAdapter() {
    if (mCursorAdapter == null) {
        mCursorAdapter = newAdapter();
        setListAdapter(mCursorAdapter);
    } else {
        mCursorAdapter.changeCursor(mCursor);
    }
    if (mInitialSelection >= 0 && mInitialSelection < mCursorAdapter.getCount()) {
        setSelection(mInitialSelection);
        getListView().setFocusableInTouchMode(true);
        boolean gotfocus = getListView().requestFocus();
    }
}
#end_block

#method_before
protected CursorAdapter newAdapter() {
    return new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, mCursor, COLUMN_NAMES, VIEW_NAMES);
}
#method_after
protected CursorAdapter newAdapter() {
    SimpleCursorAdapter sca = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, mCursor, COLUMN_NAMES, VIEW_NAMES);
    // This code block is for displaying a phone number including "+ country code" correctly
    // in bidirectional language (b/35180168).
    // Without this code, e.g. "+0123456789" is wrongly displayed as "0123456789+".
    sca.setViewBinder(new SimpleCursorAdapter.ViewBinder() {

        public boolean setViewValue(View view, Cursor cursor, int columnIndex) {
            view.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
            if (columnIndex == NUMBER_COLUMN) {
                String num = cursor.getString(NUMBER_COLUMN);
                if (num != null) {
                    BidiFormatter bf = BidiFormatter.getInstance();
                    num = bf.unicodeWrap(num, TextDirectionHeuristics.LTR, true);
                }
                if (view instanceof TextView) {
                    ((TextView) view).setText(num);
                }
                return true;
            }
            return false;
        }
    });
    return sca;
}
#end_block

#method_before
private boolean isValidNumber(String number) {
    return (number.length() <= 20);
}
#method_after
private boolean isValidNumber(String number) {
    return (number.length() <= 20) && (number.length() > 0);
}
#end_block

#method_before
private void registerForAllEvents() {
    mPhone.mCi.registerForAvailable(this, DctConstants.EVENT_RADIO_AVAILABLE, null);
    mPhone.mCi.registerForOffOrNotAvailable(this, DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mPhone.mCi.registerForDataNetworkStateChanged(this, DctConstants.EVENT_DATA_STATE_CHANGED, null);
    // Note, this is fragile - the Phone is now presenting a merged picture
    // of PS (volte) & CS and by diving into its internals you're just seeing
    // the CS data.  This works well for the purposes this is currently used for
    // but that may not always be the case.  Should probably be redesigned to
    // accurately reflect what we're really interested in (registerForCSVoiceCallEnded).
    mPhone.getCallTracker().registerForVoiceCallEnded(this, DctConstants.EVENT_VOICE_CALL_ENDED, null);
    mPhone.getCallTracker().registerForVoiceCallStarted(this, DctConstants.EVENT_VOICE_CALL_STARTED, null);
    registerServiceStateTrackerEvents();
    // SubscriptionManager.registerForDdsSwitch(this,
    // DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS, null);
    mPhone.mCi.registerForPcoData(this, DctConstants.EVENT_PCO_DATA_RECEIVED, null);
    mPhone.getCarrierActionAgent().registerForCarrierAction(CarrierActionAgent.CARRIER_ACTION_SET_METERED_APNS_ENABLED, this, DctConstants.EVENT_SET_CARRIER_DATA_ENABLED, null, false);
}
#method_after
private void registerForAllEvents() {
    mPhone.mCi.registerForAvailable(this, DctConstants.EVENT_RADIO_AVAILABLE, null);
    mPhone.mCi.registerForOffOrNotAvailable(this, DctConstants.EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mPhone.mCi.registerForDataCallListChanged(this, DctConstants.EVENT_DATA_STATE_CHANGED, null);
    // Note, this is fragile - the Phone is now presenting a merged picture
    // of PS (volte) & CS and by diving into its internals you're just seeing
    // the CS data.  This works well for the purposes this is currently used for
    // but that may not always be the case.  Should probably be redesigned to
    // accurately reflect what we're really interested in (registerForCSVoiceCallEnded).
    mPhone.getCallTracker().registerForVoiceCallEnded(this, DctConstants.EVENT_VOICE_CALL_ENDED, null);
    mPhone.getCallTracker().registerForVoiceCallStarted(this, DctConstants.EVENT_VOICE_CALL_STARTED, null);
    registerServiceStateTrackerEvents();
    // SubscriptionManager.registerForDdsSwitch(this,
    // DctConstants.EVENT_CLEAN_UP_ALL_CONNECTIONS, null);
    mPhone.mCi.registerForPcoData(this, DctConstants.EVENT_PCO_DATA_RECEIVED, null);
    mPhone.getCarrierActionAgent().registerForCarrierAction(CarrierActionAgent.CARRIER_ACTION_SET_METERED_APNS_ENABLED, this, DctConstants.EVENT_SET_CARRIER_DATA_ENABLED, null, false);
}
#end_block

#method_before
private void unregisterForAllEvents() {
    // Unregister for all events
    mPhone.mCi.unregisterForAvailable(this);
    mPhone.mCi.unregisterForOffOrNotAvailable(this);
    IccRecords r = mIccRecords.get();
    if (r != null) {
        r.unregisterForRecordsLoaded(this);
        mIccRecords.set(null);
    }
    mPhone.mCi.unregisterForDataNetworkStateChanged(this);
    mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
    mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
    unregisterServiceStateTrackerEvents();
    // SubscriptionManager.unregisterForDdsSwitch(this);
    mPhone.mCi.unregisterForPcoData(this);
    mPhone.getCarrierActionAgent().unregisterForCarrierAction(this, CarrierActionAgent.CARRIER_ACTION_SET_METERED_APNS_ENABLED);
}
#method_after
private void unregisterForAllEvents() {
    // Unregister for all events
    mPhone.mCi.unregisterForAvailable(this);
    mPhone.mCi.unregisterForOffOrNotAvailable(this);
    IccRecords r = mIccRecords.get();
    if (r != null) {
        r.unregisterForRecordsLoaded(this);
        mIccRecords.set(null);
    }
    mPhone.mCi.unregisterForDataCallListChanged(this);
    mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
    mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
    unregisterServiceStateTrackerEvents();
    // SubscriptionManager.unregisterForDdsSwitch(this);
    mPhone.mCi.unregisterForPcoData(this);
    mPhone.getCarrierActionAgent().unregisterForCarrierAction(this, CarrierActionAgent.CARRIER_ACTION_SET_METERED_APNS_ENABLED);
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    // Turning back on the radio can take time on the order of a minute, so show user a
    // spinner so they know something is going on.
    mProvisioningSpinner = new ProgressDialog(context);
    mProvisioningSpinner.setTitle(mNetworkOperator);
    mProvisioningSpinner.setMessage(// TODO: Don't borrow "Connecting..." i18n string; give Telephony a version.
    context.getText(com.android.internal.R.string.media_route_status_connecting));
    mProvisioningSpinner.setIndeterminate(true);
    mProvisioningSpinner.setCancelable(true);
    // Allow non-Activity Service Context to create a View.
    mProvisioningSpinner.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mProvisioningSpinner.show();
    // After timeout, hide spinner so user can at least use their device.
    // TODO: Indicate to user that it is taking an unusually long time to connect?
    sendMessageDelayed(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER, mProvisioningSpinner), PROVISIONING_SPINNER_TIMEOUT_MILLIS);
    // This code is almost identical to the old
    // ConnectivityService.handleMobileProvisioningAction code.
    setRadio(true);
    setEnableFailFastMobileData(DctConstants.ENABLED);
    enableMobileProvisioning();
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    // Turning back on the radio can take time on the order of a minute, so show user a
    // spinner so they know something is going on.
    log("onReceive : ProvisionNotificationBroadcastReceiver");
    mProvisioningSpinner = new ProgressDialog(context);
    mProvisioningSpinner.setTitle(mNetworkOperator);
    mProvisioningSpinner.setMessage(// TODO: Don't borrow "Connecting..." i18n string; give Telephony a version.
    context.getText(com.android.internal.R.string.media_route_status_connecting));
    mProvisioningSpinner.setIndeterminate(true);
    mProvisioningSpinner.setCancelable(true);
    // Allow non-Activity Service Context to create a View.
    mProvisioningSpinner.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mProvisioningSpinner.show();
    // After timeout, hide spinner so user can at least use their device.
    // TODO: Indicate to user that it is taking an unusually long time to connect?
    sendMessageDelayed(obtainMessage(DctConstants.CMD_CLEAR_PROVISIONING_SPINNER, mProvisioningSpinner), PROVISIONING_SPINNER_TIMEOUT_MILLIS);
    // This code is almost identical to the old
    // ConnectivityService.handleMobileProvisioningAction code.
    setRadio(true);
    setEnableFailFastMobileData(DctConstants.ENABLED);
    enableMobileProvisioning();
}
#end_block

#method_before
ApnSetting fetchDunApn() {
    if (SystemProperties.getBoolean("net.tethering.noprovisioning", false)) {
        log("fetchDunApn: net.tethering.noprovisioning=true ret: null");
        return null;
    }
    int bearer = mPhone.getServiceState().getRilDataRadioTechnology();
    ApnSetting retDunSetting = null;
    String apnData = Settings.Global.getString(mResolver, Settings.Global.TETHER_DUN_APN);
    List<ApnSetting> dunSettings = ApnSetting.arrayFromString(apnData);
    IccRecords r = mIccRecords.get();
    for (ApnSetting dunSetting : dunSettings) {
        String operator = (r != null) ? r.getOperatorNumeric() : "";
        if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer))
            continue;
        if (dunSetting.numeric.equals(operator)) {
            if (dunSetting.hasMvnoParams()) {
                if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType, dunSetting.mvnoMatchData)) {
                    if (VDBG) {
                        log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
                    }
                    return dunSetting;
                }
            } else if (mMvnoMatched == false) {
                if (VDBG)
                    log("fetchDunApn: global TETHER_DUN_APN dunSetting=" + dunSetting);
                return dunSetting;
            }
        }
    }
    Context c = mPhone.getContext();
    String[] apnArrayData = c.getResources().getStringArray(R.array.config_tether_apndata);
    for (String apn : apnArrayData) {
        ApnSetting dunSetting = ApnSetting.fromString(apn);
        if (dunSetting != null) {
            if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer))
                continue;
            if (dunSetting.hasMvnoParams()) {
                if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType, dunSetting.mvnoMatchData)) {
                    if (VDBG) {
                        log("fetchDunApn: config_tether_apndata mvno dunSetting=" + dunSetting);
                    }
                    return dunSetting;
                }
            } else if (mMvnoMatched == false) {
                retDunSetting = dunSetting;
            }
        }
    }
    if (VDBG)
        log("fetchDunApn: config_tether_apndata dunSetting=" + retDunSetting);
    return retDunSetting;
}
#method_after
ApnSetting fetchDunApn() {
    if (SystemProperties.getBoolean("net.tethering.noprovisioning", false)) {
        log("fetchDunApn: net.tethering.noprovisioning=true ret: null");
        return null;
    }
    int bearer = mPhone.getServiceState().getRilDataRadioTechnology();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    ArrayList<ApnSetting> dunCandidates = new ArrayList<ApnSetting>();
    ApnSetting retDunSetting = null;
    // Places to look for tether APN in order: TETHER_DUN_APN setting, APN database if
    // carrier allows it, and config_tether_apndata resource.
    String apnData = Settings.Global.getString(mResolver, Settings.Global.TETHER_DUN_APN);
    if (!TextUtils.isEmpty(apnData)) {
        dunCandidates.addAll(ApnSetting.arrayFromString(apnData));
        if (VDBG)
            log("fetchDunApn: dunCandidates from Setting: " + dunCandidates);
    } else if (mAllowUserEditTetherApn) {
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.canHandleType(PhoneConstants.APN_TYPE_DUN)) {
                dunCandidates.add(apn);
            }
        }
        if (VDBG)
            log("fetchDunApn: dunCandidates from database: " + dunCandidates);
    }
    // try the resource as last resort.
    if (dunCandidates.isEmpty()) {
        String[] apnArrayData = mPhone.getContext().getResources().getStringArray(R.array.config_tether_apndata);
        for (String apnString : apnArrayData) {
            ApnSetting apn = ApnSetting.fromString(apnString);
            // apn may be null if apnString isn't valid or has error parsing
            if (apn != null)
                dunCandidates.add(apn);
        }
        if (VDBG)
            log("fetchDunApn: dunCandidates from resource: " + dunCandidates);
    }
    for (ApnSetting dunSetting : dunCandidates) {
        if (!ServiceState.bitmaskHasTech(dunSetting.bearerBitmask, bearer))
            continue;
        if (dunSetting.numeric.equals(operator)) {
            if (dunSetting.hasMvnoParams()) {
                if (r != null && ApnSetting.mvnoMatches(r, dunSetting.mvnoType, dunSetting.mvnoMatchData)) {
                    retDunSetting = dunSetting;
                    break;
                }
            } else if (mMvnoMatched == false) {
                retDunSetting = dunSetting;
                break;
            }
        }
    }
    if (VDBG)
        log("fetchDunApn: dunSetting=" + retDunSetting);
    return retDunSetting;
}
#end_block

#method_before
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        firstApnSetting = mAllApnSettings.get(0);
        log("setInitialApn: firstApnSetting=" + firstApnSetting);
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
            if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) && apn.carrierEnabled) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstApnSetting");
        initialAttachApnSetting = firstApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mPhone.mCi.setInitialAttachApn(initialAttachApnSetting.apn, initialAttachApnSetting.protocol, initialAttachApnSetting.authType, initialAttachApnSetting.user, initialAttachApnSetting.password, null);
    }
}
#method_after
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mPreferredApn != null && mPreferredApn.canHandleType(PhoneConstants.APN_TYPE_IA)) {
        iaApnSetting = mPreferredApn;
    } else if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        firstApnSetting = mAllApnSettings.get(0);
        log("setInitialApn: firstApnSetting=" + firstApnSetting);
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.canHandleType(PhoneConstants.APN_TYPE_IA)) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(PhoneConstants.APN_TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstApnSetting");
        initialAttachApnSetting = firstApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mPhone.mCi.setInitialAttachApn(new DataProfile(initialAttachApnSetting), mPhone.getServiceState().getDataRoaming(), null);
    }
}
#end_block

#method_before
private void onSetCarrierDataEnabled(AsyncResult ar) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "CarrierDataEnable exception: " + ar.exception);
        return;
    }
    synchronized (mDataEnabledSettings) {
        boolean enabled = (boolean) ar.result;
        if (enabled != mDataEnabledSettings.isCarrierDataEnabled()) {
            if (DBG) {
                log("carrier Action: set metered apns enabled: " + enabled);
            }
            // Disable/enable all metered apns
            mDataEnabledSettings.setCarrierDataEnabled(enabled);
            if (!enabled) {
                // Send otasp_sim_unprovisioned so that SuW is able to proceed and notify users
                mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED);
                // Tear down all metered apns
                cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
            } else {
                teardownRestrictedMeteredConnections();
                setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED);
            }
        }
    }
}
#method_after
private void onSetCarrierDataEnabled(AsyncResult ar) {
    if (ar.exception != null) {
        Rlog.e(LOG_TAG, "CarrierDataEnable exception: " + ar.exception);
        return;
    }
    synchronized (mDataEnabledSettings) {
        boolean enabled = (boolean) ar.result;
        if (enabled != mDataEnabledSettings.isCarrierDataEnabled()) {
            if (DBG) {
                log("carrier Action: set metered apns enabled: " + enabled);
            }
            // Disable/enable all metered apns
            mDataEnabledSettings.setCarrierDataEnabled(enabled);
            if (!enabled) {
                // Send otasp_sim_unprovisioned so that SuW is able to proceed and notify users
                mPhone.notifyOtaspChanged(ServiceStateTracker.OTASP_SIM_UNPROVISIONED);
                // Tear down all metered apns
                cleanUpAllConnections(true, Phone.REASON_CARRIER_ACTION_DISABLE_METERED_APN);
            } else {
                // Re-evauluate Otasp state
                int otaspState = mPhone.getServiceStateTracker().getOtasp();
                mPhone.notifyOtaspChanged(otaspState);
                teardownRestrictedMeteredConnections();
                setupDataOnConnectableApns(Phone.REASON_DATA_ENABLED);
            }
        }
    }
}
#end_block

#method_before
private void onSimNotReady() {
    if (DBG)
        log("onSimNotReady");
    cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY);
    mAllApnSettings = null;
    mAutoAttachOnCreationConfig = false;
}
#method_after
private void onSimNotReady() {
    if (DBG)
        log("onSimNotReady");
    cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY);
    mAllApnSettings = null;
    mAutoAttachOnCreationConfig = false;
    // Clear auto attach as modem is expected to do a new attach once SIM is ready
    mAutoAttachOnCreation.set(false);
}
#end_block

#method_before
private void applyNewState(ApnContext apnContext, boolean enabled, boolean met) {
    boolean cleanup = false;
    boolean trySetup = false;
    String str = "applyNewState(" + apnContext.getApnType() + ", " + enabled + "(" + apnContext.isEnabled() + "), " + met + "(" + apnContext.getDependencyMet() + "))";
    if (DBG)
        log(str);
    apnContext.requestLog(str);
    if (apnContext.isReady()) {
        cleanup = true;
        if (enabled && met) {
            DctConstants.State state = apnContext.getState();
            switch(state) {
                case CONNECTING:
                case SCANNING:
                case CONNECTED:
                case DISCONNECTING:
                    // We're "READY" and active so just return
                    if (DBG)
                        log("applyNewState: 'ready' so return");
                    apnContext.requestLog("applyNewState state=" + state + ", so return");
                    return;
                case IDLE:
                // fall through: this is unexpected but if it happens cleanup and try setup
                case FAILED:
                case RETRYING:
                    {
                        // We're "READY" but not active so disconnect (cleanup = true) and
                        // connect (trySetup = true) to be sure we retry the connection.
                        trySetup = true;
                        apnContext.setReason(Phone.REASON_DATA_ENABLED);
                        break;
                    }
            }
        } else if (met) {
            apnContext.setReason(Phone.REASON_DATA_DISABLED);
            // those requests and not torn down organically.
            if (apnContext.getApnType() == PhoneConstants.APN_TYPE_DUN && teardownForDun()) {
                cleanup = true;
            } else {
                cleanup = false;
            }
        } else {
            apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_UNMET);
        }
    } else {
        if (enabled && met) {
            if (apnContext.isEnabled()) {
                apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_MET);
            } else {
                apnContext.setReason(Phone.REASON_DATA_ENABLED);
            }
            if (apnContext.getState() == DctConstants.State.FAILED) {
                apnContext.setState(DctConstants.State.IDLE);
            }
            trySetup = true;
        }
    }
    apnContext.setEnabled(enabled);
    apnContext.setDependencyMet(met);
    if (cleanup)
        cleanUpConnection(true, apnContext);
    if (trySetup) {
        apnContext.resetErrorCodeRetries();
        trySetupData(apnContext);
    }
}
#method_after
private void applyNewState(ApnContext apnContext, boolean enabled, boolean met) {
    boolean cleanup = false;
    boolean trySetup = false;
    String str = "applyNewState(" + apnContext.getApnType() + ", " + enabled + "(" + apnContext.isEnabled() + "), " + met + "(" + apnContext.getDependencyMet() + "))";
    if (DBG)
        log(str);
    apnContext.requestLog(str);
    if (apnContext.isReady()) {
        cleanup = true;
        if (enabled && met) {
            DctConstants.State state = apnContext.getState();
            switch(state) {
                case CONNECTING:
                case SCANNING:
                case CONNECTED:
                case DISCONNECTING:
                    // We're "READY" and active so just return
                    if (DBG)
                        log("applyNewState: 'ready' so return");
                    apnContext.requestLog("applyNewState state=" + state + ", so return");
                    return;
                case IDLE:
                // fall through: this is unexpected but if it happens cleanup and try setup
                case FAILED:
                case RETRYING:
                    {
                        // We're "READY" but not active so disconnect (cleanup = true) and
                        // connect (trySetup = true) to be sure we retry the connection.
                        trySetup = true;
                        apnContext.setReason(Phone.REASON_DATA_ENABLED);
                        break;
                    }
            }
        } else if (met) {
            apnContext.setReason(Phone.REASON_DATA_DISABLED);
            // those requests and not torn down organically.
            if ((apnContext.getApnType() == PhoneConstants.APN_TYPE_DUN && teardownForDun()) || apnContext.getState() != DctConstants.State.CONNECTED) {
                str = "Clean up the connection. Apn type = " + apnContext.getApnType() + ", state = " + apnContext.getState();
                if (DBG)
                    log(str);
                apnContext.requestLog(str);
                cleanup = true;
            } else {
                cleanup = false;
            }
        } else {
            apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_UNMET);
        }
    } else {
        if (enabled && met) {
            if (apnContext.isEnabled()) {
                apnContext.setReason(Phone.REASON_DATA_DEPENDENCY_MET);
            } else {
                apnContext.setReason(Phone.REASON_DATA_ENABLED);
            }
            if (apnContext.getState() == DctConstants.State.FAILED) {
                apnContext.setState(DctConstants.State.IDLE);
            }
            trySetup = true;
        }
    }
    apnContext.setEnabled(enabled);
    apnContext.setDependencyMet(met);
    if (cleanup)
        cleanUpConnection(true, apnContext);
    if (trySetup) {
        apnContext.resetErrorCodeRetries();
        trySetupData(apnContext);
    }
}
#end_block

#method_before
private void onEnableApn(int apnId, int enabled) {
    ApnContext apnContext = mApnContextsById.get(apnId);
    if (apnContext == null) {
        loge("onEnableApn(" + apnId + ", " + enabled + "): NO ApnContext");
        return;
    }
    // TODO change our retry manager to use the appropriate numbers for the new APN
    if (DBG)
        log("onEnableApn: apnContext=" + apnContext + " call applyNewState");
    applyNewState(apnContext, enabled == DctConstants.ENABLED, apnContext.getDependencyMet());
}
#method_after
private void onEnableApn(int apnId, int enabled) {
    ApnContext apnContext = mApnContextsById.get(apnId);
    if (apnContext == null) {
        loge("onEnableApn(" + apnId + ", " + enabled + "): NO ApnContext");
        return;
    }
    // TODO change our retry manager to use the appropriate numbers for the new APN
    if (DBG)
        log("onEnableApn: apnContext=" + apnContext + " call applyNewState");
    applyNewState(apnContext, enabled == DctConstants.ENABLED, apnContext.getDependencyMet());
    if ((enabled == DctConstants.DISABLED) && isOnlySingleDcAllowed(mPhone.getServiceState().getRilDataRadioTechnology()) && !isHigherPriorityApnContextActive(apnContext)) {
        if (DBG)
            log("onEnableApn: isOnlySingleDcAllowed true & higher priority APN disabled");
        // If the highest priority APN is disabled and only single
        // data call is allowed, try to setup data call on other connectable APN.
        setupDataOnConnectableApns(Phone.REASON_SINGLE_PDN_ARBITRATION);
    }
}
#end_block

#method_before
private void onRoamingOff() {
    if (DBG)
        log("onRoamingOff");
    if (!mDataEnabledSettings.isUserDataEnabled())
        return;
    if (getDataOnRoamingEnabled() == false) {
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
        setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
    } else {
        notifyDataConnection(Phone.REASON_ROAMING_OFF);
    }
}
#method_after
private void onRoamingOff() {
    if (DBG)
        log("onRoamingOff");
    // TODO: Remove this once all old vendor RILs are gone. We don't need to set initial apn
    // attach and send the data profile again as the modem should have both roaming and
    // non-roaming protocol in place. Modem should choose the right protocol based on the
    // roaming condition.
    setInitialAttachApn();
    setDataProfilesAsNeeded();
    if (!mDataEnabledSettings.isUserDataEnabled())
        return;
    if (getDataOnRoamingEnabled() == false) {
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_OFF);
        setupDataOnConnectableApns(Phone.REASON_ROAMING_OFF);
    } else {
        notifyDataConnection(Phone.REASON_ROAMING_OFF);
    }
}
#end_block

#method_before
private void onRoamingOn() {
    if (DBG)
        log("onRoamingOn");
    if (!mDataEnabledSettings.isUserDataEnabled()) {
        if (DBG)
            log("data not enabled by user");
        return;
    }
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    if (getDataOnRoamingEnabled()) {
        if (DBG)
            log("onRoamingOn: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        if (DBG)
            log("onRoamingOn: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#method_after
private void onRoamingOn() {
    if (DBG)
        log("onRoamingOn");
    // TODO: Remove this once all old vendor RILs are gone. We don't need to set initial apn
    // attach and send the data profile again as the modem should have both roaming and
    // non-roaming protocol in place. Modem should choose the right protocol based on the
    // roaming condition.
    setInitialAttachApn();
    setDataProfilesAsNeeded();
    if (!mDataEnabledSettings.isUserDataEnabled()) {
        if (DBG)
            log("data not enabled by user");
        return;
    }
    // Check if the device is actually data roaming
    if (!mPhone.getServiceState().getDataRoaming()) {
        if (DBG)
            log("device is not roaming. ignored the request.");
        return;
    }
    if (getDataOnRoamingEnabled()) {
        if (DBG)
            log("onRoamingOn: setup data on roaming");
        setupDataOnConnectableApns(Phone.REASON_ROAMING_ON);
        notifyDataConnection(Phone.REASON_ROAMING_ON);
    } else {
        if (DBG)
            log("onRoamingOn: Tear down data connection on roaming.");
        cleanUpAllConnections(true, Phone.REASON_ROAMING_ON);
        notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
    }
}
#end_block

#method_before
private void onRadioOffOrNotAvailable() {
    // Make sure our reconnect delay starts at the initial value
    // next time the radio comes on
    mReregisterOnReconnectFailure = false;
    if (mPhone.getSimulatedRadioControl() != null) {
        // Assume data is connected on the simulator
        // FIXME  this can be improved
        log("We're on the simulator; assuming radio off is meaningless");
    } else {
        if (DBG)
            log("onRadioOffOrNotAvailable: is off and clean up all connections");
        cleanUpAllConnections(false, Phone.REASON_RADIO_TURNED_OFF);
    }
    notifyOffApnsOfAvailability(null);
}
#method_after
private void onRadioOffOrNotAvailable() {
    // Make sure our reconnect delay starts at the initial value
    // next time the radio comes on
    mReregisterOnReconnectFailure = false;
    // Clear auto attach as modem is expected to do a new attach
    mAutoAttachOnCreation.set(false);
    if (mPhone.getSimulatedRadioControl() != null) {
        // Assume data is connected on the simulator
        // FIXME  this can be improved
        log("We're on the simulator; assuming radio off is meaningless");
    } else {
        if (DBG)
            log("onRadioOffOrNotAvailable: is off and clean up all connections");
        cleanUpAllConnections(false, Phone.REASON_RADIO_TURNED_OFF);
    }
    notifyOffApnsOfAvailability(null);
}
#end_block

#method_before
private void setDataProfilesAsNeeded() {
    if (DBG)
        log("setDataProfilesAsNeeded");
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.modemCognitive) {
                DataProfile dp = new DataProfile(apn, mPhone.getServiceState().getDataRoaming());
                boolean isDup = false;
                for (DataProfile dpIn : dps) {
                    if (dp.equals(dpIn)) {
                        isDup = true;
                        break;
                    }
                }
                if (!isDup) {
                    dps.add(dp);
                }
            }
        }
        if (dps.size() > 0) {
            mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), null);
        }
    }
}
#method_after
private void setDataProfilesAsNeeded() {
    if (DBG)
        log("setDataProfilesAsNeeded");
    if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
        ArrayList<DataProfile> dps = new ArrayList<DataProfile>();
        boolean isRoaming = mPhone.getServiceState().getDataRoaming();
        for (ApnSetting apn : mAllApnSettings) {
            if (apn.modemCognitive) {
                DataProfile dp = new DataProfile(apn);
                if (!dps.contains(dp)) {
                    dps.add(dp);
                }
            }
        }
        if (dps.size() > 0) {
            mPhone.mCi.setDataProfile(dps.toArray(new DataProfile[0]), mPhone.getServiceState().getDataRoaming(), null);
        }
    }
}
#end_block

#method_before
private void createAllApnList() {
    mMvnoMatched = false;
    mAllApnSettings = new ArrayList<ApnSetting>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = Telephony.Carriers.NUMERIC + " = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#method_after
private void createAllApnList() {
    mMvnoMatched = false;
    mAllApnSettings = new ArrayList<>();
    IccRecords r = mIccRecords.get();
    String operator = (r != null) ? r.getOperatorNumeric() : "";
    if (operator != null) {
        String selection = Telephony.Carriers.NUMERIC + " = '" + operator + "'";
        // selection += " and carrier_enabled = 1";
        if (DBG)
            log("createAllApnList: selection=" + selection);
        // ORDER BY Telephony.Carriers._ID ("_id")
        Cursor cursor = mPhone.getContext().getContentResolver().query(Telephony.Carriers.CONTENT_URI, null, selection, null, Telephony.Carriers._ID);
        if (cursor != null) {
            if (cursor.getCount() > 0) {
                mAllApnSettings = createApnList(cursor);
            }
            cursor.close();
        }
    }
    addEmergencyApnSetting();
    dedupeApnSettings();
    if (mAllApnSettings.isEmpty()) {
        if (DBG)
            log("createAllApnList: No APN found for carrier: " + operator);
        mPreferredApn = null;
    // TODO: What is the right behavior?
    // notifyNoData(DataConnection.FailCause.MISSING_UNKNOWN_APN);
    } else {
        mPreferredApn = getPreferredApn();
        if (mPreferredApn != null && !mPreferredApn.numeric.equals(operator)) {
            mPreferredApn = null;
            setPreferredApn(-1);
        }
        if (DBG)
            log("createAllApnList: mPreferredApn=" + mPreferredApn);
    }
    if (DBG)
        log("createAllApnList: X mAllApnSettings=" + mAllApnSettings);
    setDataProfilesAsNeeded();
}
#end_block

#method_before
private void onUpdateIcc() {
    if (mUiccController == null) {
        return;
    }
    IccRecords newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
    IccRecords r = mIccRecords.get();
    if (r != newIccRecords) {
        if (r != null) {
            log("Removing stale icc objects.");
            r.unregisterForRecordsLoaded(this);
            mIccRecords.set(null);
        }
        if (newIccRecords != null) {
            if (SubscriptionManager.isValidSubscriptionId(mPhone.getSubId())) {
                log("New records found.");
                mIccRecords.set(newIccRecords);
                newIccRecords.registerForRecordsLoaded(this, DctConstants.EVENT_RECORDS_LOADED, null);
                // reset carrier actions on sim loaded
                final ServiceStateTracker sst = mPhone.getServiceStateTracker();
                sst.setRadioPowerFromCarrier(true);
                mDataEnabledSettings.setCarrierDataEnabled(true);
            }
        } else {
            onSimNotReady();
        }
    }
}
#method_after
private void onUpdateIcc() {
    if (mUiccController == null) {
        return;
    }
    IccRecords newIccRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
    IccRecords r = mIccRecords.get();
    if (r != newIccRecords) {
        if (r != null) {
            log("Removing stale icc objects.");
            r.unregisterForRecordsLoaded(this);
            mIccRecords.set(null);
        }
        if (newIccRecords != null) {
            if (SubscriptionManager.isValidSubscriptionId(mPhone.getSubId())) {
                log("New records found.");
                mIccRecords.set(newIccRecords);
                newIccRecords.registerForRecordsLoaded(this, DctConstants.EVENT_RECORDS_LOADED, null);
            }
        } else {
            onSimNotReady();
        }
    }
}
#end_block

#method_before
private boolean isPhoneStateIdle() {
    for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
        Phone phone = PhoneFactory.getPhone(i);
        if (phone != null && phone.getState() != PhoneConstants.State.IDLE) {
            log("isPhoneStateIdle: Voice call active on sub: " + i);
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPhoneStateIdle() {
    for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
        Phone phone = PhoneFactory.getPhone(i);
        if (phone != null && phone.getState() != PhoneConstants.State.IDLE) {
            log("isPhoneStateIdle false: Voice call active on phone " + i);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void workingWifiTethering() throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(ConnectivityManager.TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).setWifiApEnabled(null, true);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine starts up, and telling us that tethering
    // mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).listInterfaces();
    verify(mNMService, times(1)).getInterfaceConfig(mTestIfname);
    verify(mNMService, times(1)).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(mTestIfname);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mConnectivityManager, atLeastOnce()).getNetworkInfo(anyInt());
    verify(mConnectivityManager, times(1)).requestNetwork(any(NetworkRequest.class), any(NetworkCallback.class), eq(0), anyInt(), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(ConnectivityManager.TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).setWifiApEnabled(null, false);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#method_after
@Test
public void workingWifiTethering() throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.setWifiApEnabled(any(WifiConfiguration.class), anyBoolean())).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(ConnectivityManager.TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).setWifiApEnabled(null, true);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_ENABLED);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).listInterfaces();
    verify(mNMService, times(1)).getInterfaceConfig(mTestIfname);
    verify(mNMService, times(1)).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).tetherInterface(mTestIfname);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mConnectivityManager, atLeastOnce()).getNetworkInfo(anyInt());
    verify(mConnectivityManager, times(1)).requestNetwork(any(NetworkRequest.class), any(NetworkCallback.class), eq(0), anyInt(), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(ConnectivityManager.TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).setWifiApEnabled(null, false);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#end_block

#method_before
private static byte getRandomNonZeroByte() {
    final byte random = (byte) (new Random()).nextInt();
    return (random != 0) ? random : 0x1;
}
#method_after
private static byte getRandomNonZeroByte() {
    final byte random = (byte) (new Random()).nextInt();
    // in use on the upstream already.
    return (random != 0) ? random : 0x1;
}
#end_block

#method_before
public int tether(String iface) {
    return tether(iface, Mode.TETHERING);
}
#method_after
public int tether(String iface) {
    return tether(iface, IControlsTethering.STATE_TETHERED);
}
#end_block

#method_before
private int tether(String iface, Mode mode) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, (Object) mode);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
private int tether(String iface, int requestedState) {
    if (DBG)
        Log.d(TAG, "Tethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Tether an unknown iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        // the errors are referring to past tethering attempts anyway.
        if (tetherState.lastState != IControlsTethering.STATE_AVAILABLE) {
            Log.e(TAG, "Tried to Tether an unavailable iface: " + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        // NOTE: If a CMD_TETHER_REQUESTED message is already in the TISM's
        // queue but not yet processed, this will be a no-op and it will not
        // return an error.
        // 
        // TODO: reexamine the threading and messaging model.
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, requestedState);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (tetherState.lastState != IControlsTethering.STATE_TETHERED) {
            Log.e(TAG, "Tried to untether an untethered iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#method_after
public int untether(String iface) {
    if (DBG)
        Log.d(TAG, "Untethering " + iface);
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState == null) {
            Log.e(TAG, "Tried to Untether an unknown iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE;
        }
        if (!tetherState.isCurrentlyServing()) {
            Log.e(TAG, "Tried to untether an inactive iface :" + iface + ", ignoring");
            return ConnectivityManager.TETHER_ERROR_UNAVAIL_IFACE;
        }
        tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
        return ConnectivityManager.TETHER_ERROR_NO_ERROR;
    }
}
#end_block

#method_before
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    synchronized (Tethering.this.mPublicSync) {
        mRndisEnabled = rndisEnabled;
        // start tethering if we have a request pending
        if (usbConnected && mRndisEnabled && mUsbTetherRequested) {
            tetherMatchingInterfaces(Mode.TETHERING, ConnectivityManager.TETHERING_USB);
        }
        mUsbTetherRequested = false;
    }
}
#method_after
private void handleUsbAction(Intent intent) {
    final boolean usbConnected = intent.getBooleanExtra(USB_CONNECTED, false);
    final boolean rndisEnabled = intent.getBooleanExtra(USB_FUNCTION_RNDIS, false);
    synchronized (Tethering.this.mPublicSync) {
        mRndisEnabled = rndisEnabled;
        // start tethering if we have a request pending
        if (usbConnected && mRndisEnabled && mUsbTetherRequested) {
            tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, ConnectivityManager.TETHERING_USB);
        }
        mUsbTetherRequested = false;
    }
}
#end_block

#method_before
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                // When the AP comes up and we've been requested to tether it, do so.
                // Otherwise, assume it's a local-only hotspot request.
                final Mode mode = mWifiTetherRequested ? Mode.TETHERING : Mode.LOCAL_HOTSPOT;
                tetherMatchingInterfaces(mode, ConnectivityManager.TETHERING_WIFI);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                if (DBG) {
                    Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                }
                // themselves down.
                for (int i = 0; i < mTetherStates.size(); i++) {
                    TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
                    if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                        tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                        // There should be at most one of these.
                        break;
                    }
                }
                // Regardless of whether we requested this transition, the AP has gone
                // down.  Don't try to tether again unless we're requested to do so.
                mWifiTetherRequested = false;
                break;
        }
    }
}
#method_after
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                // When the AP comes up and we've been requested to tether it, do so.
                // Otherwise, assume it's a local-only hotspot request.
                final int state = mWifiTetherRequested ? IControlsTethering.STATE_TETHERED : IControlsTethering.STATE_LOCAL_HOTSPOT;
                tetherMatchingInterfaces(state, ConnectivityManager.TETHERING_WIFI);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                if (DBG) {
                    Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                }
                // themselves down.
                for (int i = 0; i < mTetherStates.size(); i++) {
                    TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
                    if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                        tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                        // There should be at most one of these.
                        break;
                    }
                }
                // Regardless of whether we requested this transition, the AP has gone
                // down.  Don't try to tether again unless we're requested to do so.
                mWifiTetherRequested = false;
                break;
        }
    }
}
#end_block

#method_before
private void tetherMatchingInterfaces(Mode mode, int interfaceType) {
    if (VDBG) {
        Log.d(TAG, "tetherMatchingInterfaces(" + mode.description + ", " + interfaceType + ")");
    }
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    int result = (mode != Mode.IDLE ? tether(chosenIface, mode) : untether(chosenIface));
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#method_after
// TODO: Consider renaming to something more accurate in its description.
// This method:
// - allows requesting either tethering or local hotspot serving states
// - handles both enabling and disabling serving states
// - only tethers the first matching interface in listInterfaces()
private void tetherMatchingInterfaces(int requestedState, int interfaceType) {
    if (VDBG) {
        Log.d(TAG, "tetherMatchingInterfaces(" + requestedState + ", " + interfaceType + ")");
    }
    String[] ifaces = null;
    try {
        ifaces = mNMService.listInterfaces();
    } catch (Exception e) {
        Log.e(TAG, "Error listing Interfaces", e);
        return;
    }
    String chosenIface = null;
    if (ifaces != null) {
        for (String iface : ifaces) {
            if (ifaceNameToType(iface) == interfaceType) {
                chosenIface = iface;
                break;
            }
        }
    }
    if (chosenIface == null) {
        Log.e(TAG, "could not find iface of type " + interfaceType);
        return;
    }
    final int result;
    switch(requestedState) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            result = untether(chosenIface);
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_HOTSPOT:
            result = tether(chosenIface, requestedState);
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + requestedState);
            return;
    }
    if (result != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
        Log.e(TAG, "unable start or stop tethering on iface " + chosenIface);
        return;
    }
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = mContext.getSystemService(UsbManager.class);
    synchronized (mPublicSync) {
        if (enable) {
            if (mRndisEnabled) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    tetherMatchingInterfaces(Mode.TETHERING, ConnectivityManager.TETHERING_USB);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            } else {
                mUsbTetherRequested = true;
                usbManager.setCurrentFunction(UsbManager.USB_FUNCTION_RNDIS, false);
            }
        } else {
            final long ident = Binder.clearCallingIdentity();
            try {
                tetherMatchingInterfaces(Mode.IDLE, ConnectivityManager.TETHERING_USB);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            if (mRndisEnabled) {
                usbManager.setCurrentFunction(null, false);
            }
            mUsbTetherRequested = false;
        }
    }
    return ConnectivityManager.TETHER_ERROR_NO_ERROR;
}
#method_after
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = mContext.getSystemService(UsbManager.class);
    synchronized (mPublicSync) {
        if (enable) {
            if (mRndisEnabled) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    tetherMatchingInterfaces(IControlsTethering.STATE_TETHERED, ConnectivityManager.TETHERING_USB);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            } else {
                mUsbTetherRequested = true;
                usbManager.setCurrentFunction(UsbManager.USB_FUNCTION_RNDIS, false);
            }
        } else {
            final long ident = Binder.clearCallingIdentity();
            try {
                tetherMatchingInterfaces(IControlsTethering.STATE_AVAILABLE, ConnectivityManager.TETHERING_USB);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            if (mRndisEnabled) {
                usbManager.setCurrentFunction(null, false);
            }
            mUsbTetherRequested = false;
        }
    }
    return ConnectivityManager.TETHER_ERROR_NO_ERROR;
}
#end_block

#method_before
private boolean upstreamWanted() {
    synchronized (mPublicSync) {
        for (Map.Entry<String, TetherState> e : mTetherStates.entrySet()) {
            if (e.getValue().stateMachine.mode() == Mode.TETHERING) {
                return true;
            }
        }
        return mUsbTetherRequested || mWifiTetherRequested;
    }
}
#method_after
private boolean upstreamWanted() {
    if (!mForwardedDownstreams.isEmpty())
        return true;
    synchronized (mPublicSync) {
        return mUsbTetherRequested || mWifiTetherRequested;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimAbsentSeen=" + mSimAbsentSeen);
    if (isSimCardAbsent(state)) {
        if (!mSimAbsentSeen)
            mSimAbsentSeen = true;
        return;
    }
    if (isSimCardLoaded(state) && mSimAbsentSeen) {
        mSimAbsentSeen = false;
        if (!hasMobileHotspotProvisionApp())
            return;
        ArrayList<Integer> tethered = new ArrayList<Integer>();
        synchronized (mPublicSync) {
            for (int i = 0; i < mTetherStates.size(); i++) {
                TetherState tetherState = mTetherStates.valueAt(i);
                if (tetherState.lastState != IControlsTethering.STATE_TETHERED) {
                    // Skip interfaces that aren't tethered.
                    continue;
                }
                String iface = mTetherStates.keyAt(i);
                int interfaceType = ifaceNameToType(iface);
                if (interfaceType != ConnectivityManager.TETHERING_INVALID) {
                    tethered.add(new Integer(interfaceType));
                }
            }
        }
        for (int tetherType : tethered) {
            startProvisionIntent(tetherType);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    final int currentGenerationNumber = mSimBcastGenerationNumber.get();
    if (DBG) {
        Log.d(TAG, "simchange mGenerationNumber=" + mGenerationNumber + ", current generationNumber=" + currentGenerationNumber);
    }
    if (mGenerationNumber != currentGenerationNumber)
        return;
    final String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
    Log.d(TAG, "got Sim changed to state " + state + ", mSimNotLoadedSeen=" + mSimNotLoadedSeen);
    if (!isSimCardLoaded(state)) {
        if (!mSimNotLoadedSeen)
            mSimNotLoadedSeen = true;
        return;
    }
    if (isSimCardLoaded(state) && mSimNotLoadedSeen) {
        mSimNotLoadedSeen = false;
        if (!hasMobileHotspotProvisionApp())
            return;
        ArrayList<Integer> tethered = new ArrayList<Integer>();
        synchronized (mPublicSync) {
            for (int i = 0; i < mTetherStates.size(); i++) {
                TetherState tetherState = mTetherStates.valueAt(i);
                if (tetherState.lastState != IControlsTethering.STATE_TETHERED) {
                    // Skip interfaces that aren't tethered.
                    continue;
                }
                String iface = mTetherStates.keyAt(i);
                int interfaceType = ifaceNameToType(iface);
                if (interfaceType != ConnectivityManager.TETHERING_INVALID) {
                    tethered.add(new Integer(interfaceType));
                }
            }
        }
        for (int tetherType : tethered) {
            startProvisionIntent(tetherType);
        }
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            if (mNotifyList.indexOf(who) < 0) {
                mNotifyList.add(who);
                mIPv6TetheringCoordinator.addActiveDownstream(who);
            }
            transitionTo(mTetherModeAliveState);
            break;
        case CMD_TETHER_MODE_UNREQUESTED:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            mNotifyList.remove(who);
            mIPv6TetheringCoordinator.removeActiveDownstream(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                if (mNotifyList.indexOf(who) < 0) {
                    mNotifyList.add(who);
                    mIPv6TetheringCoordinator.addActiveDownstream(who);
                }
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case CMD_TETHER_MODE_UNREQUESTED:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                if (mNotifyList.remove(who)) {
                    if (DBG)
                        Log.d(TAG, "TetherModeAlive removing notifyee " + who);
                    if (mNotifyList.isEmpty()) {
                        // transitions appropriately
                        turnOffMasterTetherSettings();
                    } else {
                        if (DBG) {
                            Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                            for (TetherInterfaceStateMachine o : mNotifyList) {
                                Log.d(TAG, "  " + o);
                            }
                        }
                    }
                } else {
                    Log.e(TAG, "TetherModeAliveState UNREQUESTED has unknown who: " + who);
                }
                mIPv6TetheringCoordinator.removeActiveDownstream(who);
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // transitions appropriately
                    turnOffMasterTetherSettings();
                } else {
                    if (DBG) {
                        Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                        for (TetherInterfaceStateMachine o : mNotifyList) {
                            Log.d(TAG, "  " + o);
                        }
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            who.sendMessage(mErrorNotification);
            break;
        case CMD_CLEAR_ERROR:
            mErrorNotification = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState: " + tetherState.stateMachine.mode().description);
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    // Binder.java closes the resource for us.
    @SuppressWarnings("resource")
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService.Tether " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    pw.println("Tethering:");
    pw.increaseIndent();
    pw.println("Configuration:");
    pw.increaseIndent();
    final TetheringConfiguration cfg = mConfig;
    cfg.dump(pw);
    pw.decreaseIndent();
    synchronized (mPublicSync) {
        pw.println("Tether state:");
        pw.increaseIndent();
        for (int i = 0; i < mTetherStates.size(); i++) {
            final String iface = mTetherStates.keyAt(i);
            final TetherState tetherState = mTetherStates.valueAt(i);
            pw.print(iface + " - ");
            switch(tetherState.lastState) {
                case IControlsTethering.STATE_UNAVAILABLE:
                    pw.print("UnavailableState");
                    break;
                case IControlsTethering.STATE_AVAILABLE:
                    pw.print("AvailableState");
                    break;
                case IControlsTethering.STATE_TETHERED:
                    pw.print("TetheredState");
                    break;
                case IControlsTethering.STATE_LOCAL_HOTSPOT:
                    pw.print("LocalHotspotState");
                    break;
                default:
                    pw.print("UnknownState");
                    break;
            }
            pw.println(" - lastError = " + tetherState.lastError);
        }
        pw.println("Upstream wanted: " + upstreamWanted());
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_UNREQUESTED, who);
            break;
        case IControlsTethering.STATE_TETHERED:
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, who);
            break;
    }
    sendTetherStateChangedBroadcast();
}
#method_after
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    if (DBG) {
        Log.d(TAG, "iface " + iface + " notified that it was in state " + state + " with error " + error);
    }
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_HOTSPOT:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
@Override
public void enter() {
    mMode = Mode.IDLE;
    mTetherController.notifyInterfaceStateChange(mIfaceName, TetherInterfaceStateMachine.this, IControlsTethering.STATE_AVAILABLE, mLastError);
}
#method_after
@Override
public void enter() {
    sendInterfaceState(IControlsTethering.STATE_AVAILABLE);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            mMode = (message.obj != null) ? (Mode) message.obj : Mode.TETHERING;
            transitionTo(mTetheredState);
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_HOTSPOT:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    Log.e(TAG, "Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Tethering: " + mIfaceName + ", mode: " + mMode.description);
    if (!configureIfaceIp(true)) {
        mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;
        transitionTo(mInitialState);
        return;
    }
    try {
        mNMService.tetherInterface(mIfaceName);
    } catch (Exception e) {
        Log.e(TAG, "Error Tethering: " + e.toString());
        mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
        transitionTo(mInitialState);
        return;
    }
    if (!mIPv6TetherSvc.start()) {
        Log.e(TAG, "Failed to start IPv6TetheringInterfaceServices");
    }
    if (DBG)
        Log.d(TAG, "Tethered " + mIfaceName);
    mTetherController.notifyInterfaceStateChange(mIfaceName, TetherInterfaceStateMachine.this, IControlsTethering.STATE_TETHERED, mLastError);
}
#method_after
@Override
public void enter() {
    if (DBG)
        Log.d(TAG, "Tethered " + mIfaceName);
    sendInterfaceState(IControlsTethering.STATE_TETHERED);
}
#end_block

#method_before
@Override
public void exit() {
    // Note that at this point, we're leaving the tethered state.  We can fail any
    // of these operations, but it doesn't really change that we have to try them
    // all in sequence.
    mIPv6TetherSvc.stop();
    cleanupUpstream();
    try {
        mNMService.untetherInterface(mIfaceName);
    } catch (Exception ee) {
        mLastError = ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
        Log.e(TAG, "Failed to untether interface: " + ee.toString());
    }
    configureIfaceIp(false);
}
#method_after
@Override
public void exit() {
    cleanupUpstream();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_UNREQUESTED:
            transitionTo(mInitialState);
            if (DBG)
                Log.d(TAG, "Untethered (unrequested)" + mIfaceName);
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            if (DBG)
                Log.d(TAG, "Untethered (ifdown)" + mIfaceName);
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            if (mMode != Mode.TETHERING) {
                // Upstream changes are not of interest in our current mode.
                break;
            }
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    Log.e(TAG, "Exception enabling Nat: " + e.toString());
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        case CMD_IP_FORWARDING_ENABLE_ERROR:
        case CMD_IP_FORWARDING_DISABLE_ERROR:
        case CMD_START_TETHERING_ERROR:
        case CMD_STOP_TETHERING_ERROR:
        case CMD_SET_DNS_FORWARDERS_ERROR:
            mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            Log.e(TAG, "CMD_TETHER_REQUESTED while already tethering.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    Log.e(TAG, "Exception enabling Nat: " + e.toString());
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void enter() {
    mMode = Mode.IDLE;
    mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
    mTetherController.notifyInterfaceStateChange(mIfaceName, TetherInterfaceStateMachine.this, IControlsTethering.STATE_UNAVAILABLE, mLastError);
}
#method_after
@Override
public void enter() {
    mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
    sendInterfaceState(IControlsTethering.STATE_UNAVAILABLE);
}
#end_block

#method_before
public void buildNewRa(RaParams deprecatedParams, RaParams newParams) {
    synchronized (mLock) {
        if (deprecatedParams != null) {
            // Make a local copy, so we can modify it.
            final RaParams deprecated = new RaParams(deprecatedParams);
            // Remove any ULA DNS servers.
            removeULAs(deprecated.dnses);
            // Process newly deprecated information.
            mDeprecatedInfoTracker.putPrefixes(deprecated.prefixes);
            mDeprecatedInfoTracker.putDnses(deprecated.dnses);
        }
        // Make a local copy, so we can modify it.
        final RaParams params = (newParams != null) ? new RaParams(newParams) : null;
        if (params != null) {
            // Remove any ULA DNS servers.
            removeULAs(params.dnses);
            // Process information that is no longer deprecated.
            mDeprecatedInfoTracker.removePrefixes(params.prefixes);
            mDeprecatedInfoTracker.removeDnses(params.dnses);
        }
        mRaParams = params;
        assembleRaLocked();
    }
    maybeNotifyMulticastTransmitter();
}
#method_after
public void buildNewRa(RaParams deprecatedParams, RaParams newParams) {
    synchronized (mLock) {
        if (deprecatedParams != null) {
            mDeprecatedInfoTracker.putPrefixes(deprecatedParams.prefixes);
            mDeprecatedInfoTracker.putDnses(deprecatedParams.dnses);
        }
        if (newParams != null) {
            // Process information that is no longer deprecated.
            mDeprecatedInfoTracker.removePrefixes(newParams.prefixes);
            mDeprecatedInfoTracker.removeDnses(newParams.dnses);
        }
        mRaParams = newParams;
        assembleRaLocked();
    }
    maybeNotifyMulticastTransmitter();
}
#end_block

#method_before
private static void putRdnss(ByteBuffer ra, Set<Inet6Address> dnses, int lifetime) {
    /**
     *            Recursive DNS Server (RDNSS) Option
     *
     *             0                   1                   2                   3
     *             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |     Type      |     Length    |           Reserved            |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |                           Lifetime                            |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |                                                               |
     *            :            Addresses of IPv6 Recursive DNS Servers            :
     *            |                                                               |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    final byte ND_OPTION_RDNSS = 25;
    final byte RDNSS_NUM_8OCTETS = asByte(dnses.size() * 2 + 1);
    ra.put(ND_OPTION_RDNSS).put(RDNSS_NUM_8OCTETS).putShort(asShort(0)).putInt(lifetime);
    for (Inet6Address dns : dnses) {
        // NOTE: If the full of list DNS servers doesn't fit in the packet,
        // this code will cause a buffer overflow and the RA won't include
        // this instance of the option at all.
        // 
        // TODO: Consider looking at ra.remaining() to determine how many
        // DNS servers will fit, and adding only those.
        ra.put(dns.getAddress());
    }
}
#method_after
private static void putRdnss(ByteBuffer ra, Set<Inet6Address> dnses, int lifetime) {
    /**
     *            Recursive DNS Server (RDNSS) Option
     *
     *             0                   1                   2                   3
     *             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |     Type      |     Length    |           Reserved            |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |                           Lifetime                            |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *            |                                                               |
     *            :            Addresses of IPv6 Recursive DNS Servers            :
     *            |                                                               |
     *            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     */
    final HashSet<Inet6Address> filteredDnses = new HashSet<>();
    for (Inet6Address dns : dnses) {
        if ((new LinkAddress(dns, RFC7421_PREFIX_LENGTH)).isGlobalPreferred()) {
            filteredDnses.add(dns);
        }
    }
    if (filteredDnses.isEmpty())
        return;
    final byte ND_OPTION_RDNSS = 25;
    final byte RDNSS_NUM_8OCTETS = asByte(dnses.size() * 2 + 1);
    ra.put(ND_OPTION_RDNSS).put(RDNSS_NUM_8OCTETS).putShort(asShort(0)).putInt(lifetime);
    for (Inet6Address dns : filteredDnses) {
        // NOTE: If the full of list DNS servers doesn't fit in the packet,
        // this code will cause a buffer overflow and the RA won't include
        // this instance of the option at all.
        // 
        // TODO: Consider looking at ra.remaining() to determine how many
        // DNS servers will fit, and adding only those.
        ra.put(dns.getAddress());
    }
}
#end_block

#method_before
public void addActiveDownstream(TetherInterfaceStateMachine downstream) {
    if (findDownstream(downstream) == null) {
        // Adding a new downstream appends it to the list. Adding a
        // downstream a second time without first removing it has no effect.
        mActiveDownstreams.offer(new Downstream(downstream, mNextSubnetId++));
        // Try to wrap cleanly after 2^15 downstreams added since boot.
        if (mNextSubnetId < 0)
            mNextSubnetId = 0;
        updateIPv6TetheringInterfaces();
    }
}
#method_after
public void addActiveDownstream(TetherInterfaceStateMachine downstream, int mode) {
    if (findDownstream(downstream) == null) {
        // it and then re-adding it (with its new mode specified);
        if (mActiveDownstreams.offer(new Downstream(downstream, mode, mNextSubnetId))) {
            // Make sure subnet IDs are always positive. They are appended
            // to a ULA /48 to make a ULA /64 for local use.
            mNextSubnetId = (short) Math.max(0, mNextSubnetId + 1);
        }
        updateIPv6TetheringInterfaces();
    }
}
#end_block

#method_before
private LinkProperties getInterfaceIPv6LinkProperties(TetherInterfaceStateMachine sm) {
    if (sm.interfaceType() == ConnectivityManager.TETHERING_BLUETOOTH) {
        // TODO: Figure out IPv6 support on PAN interfaces.
        return null;
    }
    if (sm.mode() == Mode.LOCAL_HOTSPOT) {
        final Downstream ds = findDownstream(sm);
        if (ds == null)
            return null;
        // Build a Unique Locally-assigned Prefix configuration.
        return getUniqueLocalConfig(mUniqueLocalPrefix, ds.subnetId);
    }
    if (mUpstreamNetworkState == null || mUpstreamNetworkState.linkProperties == null) {
        return null;
    }
    // NOTE: Here, in future, we would have policies to decide how to divvy
    // up the available dedicated prefixes among downstream interfaces.
    // At this time we have no such mechanism--we only support tethering
    // IPv6 toward the oldest (first requested) active downstream.
    final Downstream currentActive = mActiveDownstreams.peek();
    if (currentActive != null && currentActive.tism == sm) {
        final LinkProperties lp = getIPv6OnlyLinkProperties(mUpstreamNetworkState.linkProperties);
        if (lp.hasIPv6DefaultRoute() && lp.hasGlobalIPv6Address()) {
            return lp;
        }
    }
    return null;
}
#method_after
private LinkProperties getInterfaceIPv6LinkProperties(TetherInterfaceStateMachine sm) {
    if (sm.interfaceType() == ConnectivityManager.TETHERING_BLUETOOTH) {
        // TODO: Figure out IPv6 support on PAN interfaces.
        return null;
    }
    final Downstream ds = findDownstream(sm);
    if (ds == null)
        return null;
    if (ds.mode == IControlsTethering.STATE_LOCAL_HOTSPOT) {
        // Build a Unique Locally-assigned Prefix configuration.
        return getUniqueLocalConfig(mUniqueLocalPrefix, ds.subnetId);
    }
    // This downstream is in IControlsTethering.STATE_TETHERED mode.
    if (mUpstreamNetworkState == null || mUpstreamNetworkState.linkProperties == null) {
        return null;
    }
    // NOTE: Here, in future, we would have policies to decide how to divvy
    // up the available dedicated prefixes among downstream interfaces.
    // At this time we have no such mechanism--we only support tethering
    // IPv6 toward the oldest (first requested) active downstream.
    final Downstream currentActive = mActiveDownstreams.peek();
    if (currentActive != null && currentActive.tism == sm) {
        final LinkProperties lp = getIPv6OnlyLinkProperties(mUpstreamNetworkState.linkProperties);
        if (lp.hasIPv6DefaultRoute() && lp.hasGlobalIPv6Address()) {
            return lp;
        }
    }
    return null;
}
#end_block

#method_before
private static LinkProperties getUniqueLocalConfig(byte[] ulp, short subnetId) {
    final LinkProperties lp = new LinkProperties();
    final IpPrefix local48 = getUniqueLocalPrefix(ulp, (short) 0, 48);
    lp.addRoute(new RouteInfo(local48, null, null));
    final IpPrefix local64 = getUniqueLocalPrefix(ulp, subnetId, 64);
    lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64));
    return lp;
}
#method_after
private static LinkProperties getUniqueLocalConfig(byte[] ulp, short subnetId) {
    final LinkProperties lp = new LinkProperties();
    final IpPrefix local48 = makeUniqueLocalPrefix(ulp, (short) 0, 48);
    lp.addRoute(new RouteInfo(local48, null, null));
    final IpPrefix local64 = makeUniqueLocalPrefix(ulp, subnetId, 64);
    // Because this is a locally-generated ULA, we don't have an upstream
    // address. But because the downstream IP address management code gets
    // its prefix from the upstream's IP address, we create a fake one here.
    lp.addLinkAddress(new LinkAddress(local64.getAddress(), 64));
    lp.setMtu(NetworkConstants.ETHER_MTU);
    return lp;
}
#end_block

#method_before
private void sendDnsProbe(String host) {
    if (TextUtils.isEmpty(host)) {
        return;
    }
    final String name = ValidationProbeEvent.getProbeName(ValidationProbeEvent.PROBE_DNS);
    final Stopwatch watch = new Stopwatch().start();
    InetAddress[] addresses = null;
    int result = ValidationProbeEvent.DNS_FAILURE;
    try {
        addresses = mNetworkAgentInfo.network.getAllByName(host);
        result = ValidationProbeEvent.DNS_SUCCESS;
    } catch (UnknownHostException e) {
    // failure logged below
    }
    final long latency = watch.stop();
    String resultString = (ValidationProbeEvent.DNS_SUCCESS == result) ? "OK" : "FAIL";
    validationLog(ValidationProbeEvent.PROBE_DNS, host, String.format("%s %dms, %s", resultString, latency, Arrays.toString(addresses)));
    logValidationProbe(latency, ValidationProbeEvent.PROBE_DNS, result);
}
#method_after
private void sendDnsProbe(String host) {
    if (TextUtils.isEmpty(host)) {
        return;
    }
    final String name = ValidationProbeEvent.getProbeName(ValidationProbeEvent.PROBE_DNS);
    final Stopwatch watch = new Stopwatch().start();
    int result;
    String connectInfo;
    try {
        InetAddress[] addresses = mNetworkAgentInfo.network.getAllByName(host);
        StringBuffer buffer = new StringBuffer();
        for (InetAddress address : addresses) {
            buffer.append(',').append(address.getHostAddress());
        }
        result = ValidationProbeEvent.DNS_SUCCESS;
        connectInfo = "OK " + buffer.substring(1);
    } catch (UnknownHostException e) {
        result = ValidationProbeEvent.DNS_FAILURE;
        connectInfo = "FAIL";
    }
    final long latency = watch.stop();
    validationLog(ValidationProbeEvent.PROBE_DNS, host, String.format("%dms %s", latency, connectInfo));
    logValidationProbe(latency, ValidationProbeEvent.PROBE_DNS, result);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DecimalFormatSymbols other = (DecimalFormatSymbols) obj;
    return (zeroDigit == other.zeroDigit && groupingSeparator == other.groupingSeparator && decimalSeparator == other.decimalSeparator && percent == other.percent && perMill == other.perMill && digit == other.digit && minusSign == other.minusSign && patternSeparator == other.patternSeparator && infinity.equals(other.infinity) && NaN.equals(other.NaN) && currencySymbol.equals(other.currencySymbol) && intlCurrencySymbol.equals(other.intlCurrencySymbol) && currency == other.currency && monetarySeparator == other.monetarySeparator && exponentialSeparator.equals(other.exponentialSeparator) && locale.equals(other.locale));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null)
        return false;
    if (this == obj)
        return true;
    if (getClass() != obj.getClass())
        return false;
    DecimalFormatSymbols other = (DecimalFormatSymbols) obj;
    return (zeroDigit == other.zeroDigit && groupingSeparator == other.groupingSeparator && decimalSeparator == other.decimalSeparator && percent == other.percent && perMill == other.perMill && digit == other.digit && minusSign == other.minusSign && patternSeparator == other.patternSeparator && infinity.equals(other.infinity) && NaN.equals(other.NaN) && currencySymbol.equals(other.currencySymbol) && intlCurrencySymbol.equals(other.intlCurrencySymbol) && currency == other.currency && monetarySeparator == other.monetarySeparator && exponentialSeparator.equals(other.exponentialSeparator) && locale.equals(other.locale));
}
#end_block

#method_before
// Android-changed: maybeStripMarkers added in b/26207216, fixed in b/32465689.
private static char maybeStripMarkers(String symbol, char fallback) {
    final int length = symbol.length();
    if (length == 1) {
        return symbol.charAt(0);
    }
    if (length > 1) {
        char first = symbol.charAt(0);
        char second = symbol.charAt(1);
        if (first == '\u200E' || first == '\u200F' || first == '\u061C') {
            return second;
        }
        if (length == 2 && (second == '\u200E' || second == '\u200F' || second == '\u061C')) {
            return first;
        }
    }
    return fallback;
}
#method_after
// Android-changed: maybeStripMarkers added in b/26207216, fixed in b/32465689.
/**
 * Attempts to strip RTL, LTR and Arabic letter markers from {@code symbol}.
 * If the string contains a single non-marker character (and any number of marker characters),
 * then that character is returned, otherwise {@code fallback} is returned.
 *
 * @hide
 */
public static char maybeStripMarkers(String symbol, char fallback) {
    final int length = symbol.length();
    if (length >= 1) {
        boolean sawNonMarker = false;
        char nonMarker = 0;
        for (int i = 0; i < length; i++) {
            final char c = symbol.charAt(i);
            if (c == '\u200E' || c == '\u200F' || c == '\u061C') {
                continue;
            }
            if (sawNonMarker) {
                // More than one non-marker character.
                return fallback;
            }
            sawNonMarker = true;
            nonMarker = c;
        }
        if (sawNonMarker) {
            return nonMarker;
        }
    }
    return fallback;
}
#end_block

#method_before
public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId) {
    if (VDBG)
        logd("putPhoneIdAndSubIdExtra: phoneId=" + phoneId + " subId=" + subId);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(PhoneConstants.PHONE_KEY, phoneId);
    // FIXME this is using phoneId and slotIndex interchangeably
    // Eventually, this should be removed as it is not the slot id
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
}
#method_after
public static void putPhoneIdAndSubIdExtra(Intent intent, int phoneId, int subId) {
    if (VDBG)
        logd("putPhoneIdAndSubIdExtra: phoneId=" + phoneId + " subId=" + subId);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(Intent.EXTRA_SUBSCRIPTION_INDEX, subId);
    intent.putExtra(PhoneConstants.PHONE_KEY, phoneId);
    // FIXME this is using phoneId and slotIndex interchangeably
    // Eventually, this should be removed as it is not the slot id
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(BluetoothDevicePicker.ACTION_DEVICE_SELECTED)) {
        BluetoothOppManager mOppManager = BluetoothOppManager.getInstance(context);
        BluetoothDevice remoteDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (V)
            Log.v(TAG, "Received BT device selected intent, bt device: " + remoteDevice);
        // Insert transfer session record to database
        mOppManager.startTransfer(remoteDevice);
        // Display toast message
        String deviceName = mOppManager.getDeviceName(remoteDevice);
        String toastMsg;
        int batchSize = mOppManager.getBatchSize();
        if (mOppManager.mMultipleFlag) {
            toastMsg = context.getString(R.string.bt_toast_5, Integer.toString(batchSize), deviceName);
        } else {
            toastMsg = context.getString(R.string.bt_toast_4, deviceName);
        }
        Toast.makeText(context, toastMsg, Toast.LENGTH_SHORT).show();
    } else if (action.equals(BluetoothDevicePicker.ACTION_DEVICE_NOT_SELECTED)) {
        if (V)
            Log.v(TAG, "ACTION_DEVICE_NOT_SELECTED");
        BluetoothOppManager mOppManager = BluetoothOppManager.getInstance(context);
        mOppManager.cleanUpSendingFileInfo();
    } else if (action.equals(Constants.ACTION_INCOMING_FILE_CONFIRM)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_INCOMING_FILE_CONFIRM");
        Uri uri = intent.getData();
        Intent in = new Intent(context, BluetoothOppIncomingFileConfirmActivity.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        in.setDataAndNormalize(uri);
        context.startActivity(in);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_DECLINE)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_DECLINE");
        Uri uri = intent.getData();
        ContentValues values = new ContentValues();
        values.put(BluetoothShare.USER_CONFIRMATION, BluetoothShare.USER_CONFIRMATION_DENIED);
        context.getContentResolver().update(uri, values, null, null);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_ACCEPT)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_ACCEPT");
        Uri uri = intent.getData();
        ContentValues values = new ContentValues();
        values.put(BluetoothShare.USER_CONFIRMATION, BluetoothShare.USER_CONFIRMATION_CONFIRMED);
        context.getContentResolver().update(uri, values, null, null);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_OPEN) || action.equals(Constants.ACTION_LIST)) {
        if (V) {
            if (action.equals(Constants.ACTION_OPEN)) {
                Log.v(TAG, "Receiver open for " + intent.getData());
            } else {
                Log.v(TAG, "Receiver list for " + intent.getData());
            }
        }
        BluetoothOppTransferInfo transInfo = new BluetoothOppTransferInfo();
        Uri uri = intent.getData();
        transInfo = BluetoothOppUtility.queryRecord(context, uri);
        if (transInfo == null) {
            Log.e(TAG, "Error: Can not get data from db");
            return;
        }
        if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND && BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
            // if received file successfully, open this file
            BluetoothOppUtility.openReceivedFile(context, transInfo.mFileName, transInfo.mFileType, transInfo.mTimeStamp, uri);
            BluetoothOppUtility.updateVisibilityToHidden(context, uri);
        } else {
            Intent in = new Intent(context, BluetoothOppTransferActivity.class);
            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            in.setDataAndNormalize(uri);
            context.startActivity(in);
        }
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_OPEN_OUTBOUND_TRANSFER)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_OUTBOUND_TRANSFER.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_OUTBOUND);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_OPEN_INBOUND_TRANSFER)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_INBOUND_TRANSFER.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_INBOUND);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_OPEN_RECEIVED_FILES)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_RECEIVED_FILES.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_INBOUND);
        in.putExtra(Constants.EXTRA_SHOW_ALL_FILES, true);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_HIDE)) {
        if (V)
            Log.v(TAG, "Receiver hide for " + intent.getData());
        Cursor cursor = context.getContentResolver().query(intent.getData(), null, null, null, null);
        if (cursor != null) {
            if (cursor.moveToFirst()) {
                int statusColumn = cursor.getColumnIndexOrThrow(BluetoothShare.STATUS);
                int status = cursor.getInt(statusColumn);
                int visibilityColumn = cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY);
                int visibility = cursor.getInt(visibilityColumn);
                int userConfirmationColumn = cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION);
                int userConfirmation = cursor.getInt(userConfirmationColumn);
                if (((userConfirmation == BluetoothShare.USER_CONFIRMATION_PENDING)) && visibility == BluetoothShare.VISIBILITY_VISIBLE) {
                    ContentValues values = new ContentValues();
                    values.put(BluetoothShare.VISIBILITY, BluetoothShare.VISIBILITY_HIDDEN);
                    context.getContentResolver().update(intent.getData(), values, null, null);
                    if (V)
                        Log.v(TAG, "Action_hide received and db updated");
                }
            }
            cursor.close();
        }
    } else if (action.equals(Constants.ACTION_COMPLETE_HIDE)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_COMPLETE_HIDE");
        ContentValues updateValues = new ContentValues();
        updateValues.put(BluetoothShare.VISIBILITY, BluetoothShare.VISIBILITY_HIDDEN);
        context.getContentResolver().update(BluetoothShare.CONTENT_URI, updateValues, BluetoothOppNotification.WHERE_COMPLETED, null);
    } else if (action.equals(BluetoothShare.TRANSFER_COMPLETED_ACTION)) {
        if (V)
            Log.v(TAG, "Receiver Transfer Complete Intent for " + intent.getData());
        String toastMsg = null;
        BluetoothOppTransferInfo transInfo = new BluetoothOppTransferInfo();
        transInfo = BluetoothOppUtility.queryRecord(context, intent.getData());
        if (transInfo == null) {
            Log.e(TAG, "Error: Can not get data from db");
            return;
        }
        if (transInfo.mHandoverInitiated) {
            // Deal with handover-initiated transfers separately
            Intent handoverIntent = new Intent(Constants.ACTION_BT_OPP_TRANSFER_DONE);
            if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_INCOMING);
            } else {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_OUTGOING);
            }
            handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_ID, transInfo.mID);
            handoverIntent.putExtra(Constants.EXTRA_BT_OPP_ADDRESS, transInfo.mDestAddr);
            if (BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_STATUS, Constants.HANDOVER_TRANSFER_STATUS_SUCCESS);
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_URI, transInfo.mFileName);
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_MIMETYPE, transInfo.mFileType);
            } else {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_STATUS, Constants.HANDOVER_TRANSFER_STATUS_FAILURE);
            }
            context.sendBroadcast(handoverIntent, Constants.HANDOVER_STATUS_PERMISSION);
            return;
        }
        if (BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
            if (transInfo.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                toastMsg = context.getString(R.string.notification_sent, transInfo.mFileName);
            } else if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                toastMsg = context.getString(R.string.notification_received, transInfo.mFileName);
            }
        } else if (BluetoothShare.isStatusError(transInfo.mStatus)) {
            if (transInfo.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                toastMsg = context.getString(R.string.notification_sent_fail, transInfo.mFileName);
            } else if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                toastMsg = context.getString(R.string.download_fail_line1);
            }
        }
        if (V)
            Log.v(TAG, "Toast msg == " + toastMsg);
        if (toastMsg != null) {
            Toast.makeText(context, toastMsg, Toast.LENGTH_SHORT).show();
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(BluetoothDevicePicker.ACTION_DEVICE_SELECTED)) {
        BluetoothOppManager mOppManager = BluetoothOppManager.getInstance(context);
        BluetoothDevice remoteDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (D)
            Log.d(TAG, "Received BT device selected intent, bt device: " + remoteDevice);
        if (remoteDevice == null) {
            mOppManager.cleanUpSendingFileInfo();
            return;
        }
        // Insert transfer session record to database
        mOppManager.startTransfer(remoteDevice);
        // Display toast message
        String deviceName = mOppManager.getDeviceName(remoteDevice);
        String toastMsg;
        int batchSize = mOppManager.getBatchSize();
        if (mOppManager.mMultipleFlag) {
            toastMsg = context.getString(R.string.bt_toast_5, Integer.toString(batchSize), deviceName);
        } else {
            toastMsg = context.getString(R.string.bt_toast_4, deviceName);
        }
        Toast.makeText(context, toastMsg, Toast.LENGTH_SHORT).show();
    } else if (action.equals(Constants.ACTION_INCOMING_FILE_CONFIRM)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_INCOMING_FILE_CONFIRM");
        Uri uri = intent.getData();
        Intent in = new Intent(context, BluetoothOppIncomingFileConfirmActivity.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        in.setDataAndNormalize(uri);
        context.startActivity(in);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_DECLINE)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_DECLINE");
        Uri uri = intent.getData();
        ContentValues values = new ContentValues();
        values.put(BluetoothShare.USER_CONFIRMATION, BluetoothShare.USER_CONFIRMATION_DENIED);
        context.getContentResolver().update(uri, values, null, null);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_ACCEPT)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_ACCEPT");
        Uri uri = intent.getData();
        ContentValues values = new ContentValues();
        values.put(BluetoothShare.USER_CONFIRMATION, BluetoothShare.USER_CONFIRMATION_CONFIRMED);
        context.getContentResolver().update(uri, values, null, null);
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_OPEN) || action.equals(Constants.ACTION_LIST)) {
        if (V) {
            if (action.equals(Constants.ACTION_OPEN)) {
                Log.v(TAG, "Receiver open for " + intent.getData());
            } else {
                Log.v(TAG, "Receiver list for " + intent.getData());
            }
        }
        BluetoothOppTransferInfo transInfo = new BluetoothOppTransferInfo();
        Uri uri = intent.getData();
        transInfo = BluetoothOppUtility.queryRecord(context, uri);
        if (transInfo == null) {
            Log.e(TAG, "Error: Can not get data from db");
            return;
        }
        if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND && BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
            // if received file successfully, open this file
            BluetoothOppUtility.openReceivedFile(context, transInfo.mFileName, transInfo.mFileType, transInfo.mTimeStamp, uri);
            BluetoothOppUtility.updateVisibilityToHidden(context, uri);
        } else {
            Intent in = new Intent(context, BluetoothOppTransferActivity.class);
            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            in.setDataAndNormalize(uri);
            context.startActivity(in);
        }
        cancelNotification(context, uri);
    } else if (action.equals(Constants.ACTION_OPEN_OUTBOUND_TRANSFER)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_OUTBOUND_TRANSFER.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_OUTBOUND);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_OPEN_INBOUND_TRANSFER)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_INBOUND_TRANSFER.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_INBOUND);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_OPEN_RECEIVED_FILES)) {
        if (V)
            Log.v(TAG, "Received ACTION_OPEN_RECEIVED_FILES.");
        Intent in = new Intent(context, BluetoothOppTransferHistory.class);
        in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        in.putExtra("direction", BluetoothShare.DIRECTION_INBOUND);
        in.putExtra(Constants.EXTRA_SHOW_ALL_FILES, true);
        context.startActivity(in);
    } else if (action.equals(Constants.ACTION_HIDE)) {
        if (V)
            Log.v(TAG, "Receiver hide for " + intent.getData());
        Cursor cursor = context.getContentResolver().query(intent.getData(), null, null, null, null);
        if (cursor != null) {
            if (cursor.moveToFirst()) {
                int visibilityColumn = cursor.getColumnIndexOrThrow(BluetoothShare.VISIBILITY);
                int visibility = cursor.getInt(visibilityColumn);
                int userConfirmationColumn = cursor.getColumnIndexOrThrow(BluetoothShare.USER_CONFIRMATION);
                int userConfirmation = cursor.getInt(userConfirmationColumn);
                if (((userConfirmation == BluetoothShare.USER_CONFIRMATION_PENDING)) && visibility == BluetoothShare.VISIBILITY_VISIBLE) {
                    ContentValues values = new ContentValues();
                    values.put(BluetoothShare.VISIBILITY, BluetoothShare.VISIBILITY_HIDDEN);
                    context.getContentResolver().update(intent.getData(), values, null, null);
                    if (V)
                        Log.v(TAG, "Action_hide received and db updated");
                }
            }
            cursor.close();
        }
    } else if (action.equals(Constants.ACTION_COMPLETE_HIDE)) {
        if (V)
            Log.v(TAG, "Receiver ACTION_COMPLETE_HIDE");
        ContentValues updateValues = new ContentValues();
        updateValues.put(BluetoothShare.VISIBILITY, BluetoothShare.VISIBILITY_HIDDEN);
        context.getContentResolver().update(BluetoothShare.CONTENT_URI, updateValues, BluetoothOppNotification.WHERE_COMPLETED, null);
    } else if (action.equals(BluetoothShare.TRANSFER_COMPLETED_ACTION)) {
        if (V)
            Log.v(TAG, "Receiver Transfer Complete Intent for " + intent.getData());
        String toastMsg = null;
        BluetoothOppTransferInfo transInfo = new BluetoothOppTransferInfo();
        transInfo = BluetoothOppUtility.queryRecord(context, intent.getData());
        if (transInfo == null) {
            Log.e(TAG, "Error: Can not get data from db");
            return;
        }
        if (transInfo.mHandoverInitiated) {
            // Deal with handover-initiated transfers separately
            Intent handoverIntent = new Intent(Constants.ACTION_BT_OPP_TRANSFER_DONE);
            if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_INCOMING);
            } else {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_DIRECTION, Constants.DIRECTION_BLUETOOTH_OUTGOING);
            }
            handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_ID, transInfo.mID);
            handoverIntent.putExtra(Constants.EXTRA_BT_OPP_ADDRESS, transInfo.mDestAddr);
            if (BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_STATUS, Constants.HANDOVER_TRANSFER_STATUS_SUCCESS);
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_URI, transInfo.mFileName);
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_MIMETYPE, transInfo.mFileType);
            } else {
                handoverIntent.putExtra(Constants.EXTRA_BT_OPP_TRANSFER_STATUS, Constants.HANDOVER_TRANSFER_STATUS_FAILURE);
            }
            context.sendBroadcast(handoverIntent, Constants.HANDOVER_STATUS_PERMISSION);
            return;
        }
        if (BluetoothShare.isStatusSuccess(transInfo.mStatus)) {
            if (transInfo.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                toastMsg = context.getString(R.string.notification_sent, transInfo.mFileName);
            } else if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                toastMsg = context.getString(R.string.notification_received, transInfo.mFileName);
            }
        } else if (BluetoothShare.isStatusError(transInfo.mStatus)) {
            if (transInfo.mDirection == BluetoothShare.DIRECTION_OUTBOUND) {
                toastMsg = context.getString(R.string.notification_sent_fail, transInfo.mFileName);
            } else if (transInfo.mDirection == BluetoothShare.DIRECTION_INBOUND) {
                toastMsg = context.getString(R.string.download_fail_line1);
            }
        }
        if (V)
            Log.v(TAG, "Toast msg == " + toastMsg);
        if (toastMsg != null) {
            Toast.makeText(context, toastMsg, Toast.LENGTH_SHORT).show();
        }
    }
}
#end_block

#method_before
public void cleanUpSendingFileInfo() {
    synchronized (BluetoothOppManager.this) {
        Uri uri;
        if (V)
            Log.v(TAG, "cleanUpSendingFileInfo: mMultipleFlag = " + mMultipleFlag);
        if (!mMultipleFlag && (mUriOfSendingFile != null)) {
            uri = Uri.parse(mUriOfSendingFile);
            if (V)
                Log.v(TAG, "cleanUpSendingFileInfo: " + "closeSendFileInfo for uri = " + uri);
            BluetoothOppUtility.closeSendFileInfo(uri);
        } else if (mUrisOfSendingFiles != null) {
            for (int i = 0, count = mUrisOfSendingFiles.size(); i < count; i++) {
                uri = mUrisOfSendingFiles.get(i);
                if (V)
                    Log.v(TAG, "cleanUpSendingFileInfo: " + "closeSendFileInfo for uri = " + uri);
                BluetoothOppUtility.closeSendFileInfo(uri);
            }
        }
    }
}
#method_after
void cleanUpSendingFileInfo() {
    synchronized (BluetoothOppManager.this) {
        if (V)
            Log.v(TAG, "cleanUpSendingFileInfo: mMultipleFlag = " + mMultipleFlag);
        if (!mMultipleFlag && (mUriOfSendingFile != null)) {
            Uri uri = Uri.parse(mUriOfSendingFile);
            BluetoothOppUtility.closeSendFileInfo(uri);
        } else if (mUrisOfSendingFiles != null) {
            for (Uri uri : mUrisOfSendingFiles) {
                BluetoothOppUtility.closeSendFileInfo(uri);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Set up the "dialog"
    mOppManager = BluetoothOppManager.getInstance(this);
    mBtEnabled = false;
    final AlertController.AlertParams p = mAlertParams;
    p.mIconAttrId = android.R.attr.alertDialogIcon;
    p.mTitle = getString(R.string.bt_enable_title);
    p.mView = createView();
    p.mPositiveButtonText = getString(R.string.bt_enable_ok);
    p.mPositiveButtonListener = this;
    p.mNegativeButtonText = getString(R.string.bt_enable_cancel);
    p.mNegativeButtonListener = this;
    setupAlert();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Set up the "dialog"
    mOppManager = BluetoothOppManager.getInstance(this);
    mOppManager.mSendingFlag = false;
    final AlertController.AlertParams p = mAlertParams;
    p.mIconAttrId = android.R.attr.alertDialogIcon;
    p.mTitle = getString(R.string.bt_enable_title);
    p.mView = createView();
    p.mPositiveButtonText = getString(R.string.bt_enable_ok);
    p.mPositiveButtonListener = this;
    p.mNegativeButtonText = getString(R.string.bt_enable_cancel);
    p.mNegativeButtonListener = this;
    setupAlert();
}
#end_block

#method_before
public void onClick(DialogInterface dialog, int which) {
    switch(which) {
        case DialogInterface.BUTTON_POSITIVE:
            // this is an asyn call
            mOppManager.enableBluetooth();
            mOppManager.mSendingFlag = true;
            mBtEnabled = true;
            Toast.makeText(this, getString(R.string.enabling_progress_content), Toast.LENGTH_SHORT).show();
            Intent in = new Intent(this, BluetoothOppBtEnablingActivity.class);
            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            this.startActivity(in);
            finish();
            break;
        case DialogInterface.BUTTON_NEGATIVE:
            finish();
            break;
    }
}
#method_after
public void onClick(DialogInterface dialog, int which) {
    switch(which) {
        case DialogInterface.BUTTON_POSITIVE:
            // this is an asyn call
            mOppManager.enableBluetooth();
            mOppManager.mSendingFlag = true;
            Toast.makeText(this, getString(R.string.enabling_progress_content), Toast.LENGTH_SHORT).show();
            Intent in = new Intent(this, BluetoothOppBtEnablingActivity.class);
            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            this.startActivity(in);
            finish();
            break;
        case DialogInterface.BUTTON_NEGATIVE:
            finish();
            break;
    }
}
#end_block

#method_before
@Override
public void onPause() {
    super.onPause();
    if (!mBtEnabled) {
        mOppManager.cleanUpSendingFileInfo();
    }
}
#method_after
@Override
public void onPause() {
    super.onPause();
    if (!mOppManager.mSendingFlag) {
        mOppManager.cleanUpSendingFileInfo();
    }
}
#end_block

#method_before
@Override
public void close() throws IOException {
    if (DBG)
        Log.d(TAG, "close() in, this: " + this + ", channel: " + mPort + ", state: " + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (DBG)
                Log.d(TAG, "close() this: " + this + ", channel: " + mPort + ", mSocketIS: " + mSocketIS + ", mSocketOS: " + mSocketOS + "mSocket: " + mSocket + ", mSocketState: " + mSocketState);
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, "Closing mSocket: " + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}
#method_after
@Override
public void close() throws IOException {
    Log.d(TAG, "close() this: " + this + ", channel: " + mPort + ", mSocketIS: " + mSocketIS + ", mSocketOS: " + mSocketOS + "mSocket: " + mSocket + ", mSocketState: " + mSocketState);
    if (mSocketState == SocketState.CLOSED)
        return;
    else {
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                return;
            mSocketState = SocketState.CLOSED;
            if (mSocket != null) {
                if (DBG)
                    Log.d(TAG, "Closing mSocket: " + mSocket);
                mSocket.shutdownInput();
                mSocket.shutdownOutput();
                mSocket.close();
                mSocket = null;
            }
            if (mPfd != null) {
                mPfd.close();
                mPfd = null;
            }
        }
    }
}
#end_block

#method_before
public void startAdvertising(AdvertiseSettings settings, AdvertiseData advertiseData, AdvertiseData scanResponse, final AdvertiseCallback callback) {
    synchronized (mLegacyAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException("callback cannot be null");
        }
        boolean isConnectable = settings.isConnectable();
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES || totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLegacyAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        AdvertisingSetParameters.Builder parameters = new AdvertisingSetParameters.Builder();
        parameters.setLegacyMode(true);
        parameters.setConnectable(isConnectable);
        // legacy advertisements we support are always scannable
        parameters.setScannable(true);
        if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_POWER) {
            // 1s
            parameters.setInterval(1600);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_BALANCED) {
            // 250ms
            parameters.setInterval(400);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY) {
            // 100ms
            parameters.setInterval(160);
        }
        if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW) {
            parameters.setTxPowerLevel(-21);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_LOW) {
            parameters.setTxPowerLevel(-15);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM) {
            parameters.setTxPowerLevel(-7);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_HIGH) {
            parameters.setTxPowerLevel(1);
        }
        int duration = 0;
        int timeoutMillis = settings.getTimeout();
        if (timeoutMillis > 0) {
            duration = (timeoutMillis < 10) ? 1 : timeoutMillis / 10;
        }
        AdvertisingSetCallback wrapped = wrapOldCallback(callback, settings);
        mLegacyAdvertisers.put(callback, wrapped);
        startAdvertisingSet(parameters.build(), advertiseData, scanResponse, null, null, duration, 0, wrapped);
    }
}
#method_after
public void startAdvertising(AdvertiseSettings settings, AdvertiseData advertiseData, AdvertiseData scanResponse, final AdvertiseCallback callback) {
    synchronized (mLegacyAdvertisers) {
        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
        if (callback == null) {
            throw new IllegalArgumentException("callback cannot be null");
        }
        boolean isConnectable = settings.isConnectable();
        if (totalBytes(advertiseData, isConnectable) > MAX_ADVERTISING_DATA_BYTES || totalBytes(scanResponse, false) > MAX_ADVERTISING_DATA_BYTES) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);
            return;
        }
        if (mLegacyAdvertisers.containsKey(callback)) {
            postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);
            return;
        }
        AdvertisingSetParameters.Builder parameters = new AdvertisingSetParameters.Builder();
        parameters.setLegacyMode(true);
        parameters.setConnectable(isConnectable);
        // legacy advertisements we support are always scannable
        parameters.setScannable(true);
        if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_POWER) {
            // 1s
            parameters.setInterval(1600);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_BALANCED) {
            // 250ms
            parameters.setInterval(400);
        } else if (settings.getMode() == AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY) {
            // 100ms
            parameters.setInterval(160);
        }
        if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW) {
            parameters.setTxPowerLevel(-21);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_LOW) {
            parameters.setTxPowerLevel(-15);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM) {
            parameters.setTxPowerLevel(-7);
        } else if (settings.getTxPowerLevel() == AdvertiseSettings.ADVERTISE_TX_POWER_HIGH) {
            parameters.setTxPowerLevel(1);
        }
        AdvertisingSetCallback wrapped = wrapOldCallback(callback, settings);
        mLegacyAdvertisers.put(callback, wrapped);
        startAdvertisingSet(parameters.build(), advertiseData, scanResponse, null, null, settings.getTimeout(), wrapped);
    }
}
#end_block

#method_before
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, AdvertisingSetCallback callback) {
    startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, 0, 0, callback, new Handler(Looper.getMainLooper()));
}
#method_after
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, AdvertisingSetCallback callback) {
    startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, 0, callback, new Handler(Looper.getMainLooper()));
}
#end_block

#method_before
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, AdvertisingSetCallback callback, Handler handler) {
    startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, 0, 0, callback, handler);
}
#method_after
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, AdvertisingSetCallback callback, Handler handler) {
    startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, 0, callback, handler);
}
#end_block

#method_before
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, int duration, int maxExtendedAdvertisingEvents, AdvertisingSetCallback callback, Handler handler) {
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException("callback cannot be null");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy advertising data too big");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy scan response data too big");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == AdvertisingSetParameters.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException("Unsupported primary PHY selected");
        }
        if ((sphy == AdvertisingSetParameters.PHY_LE_CODED && !supportCodedPhy) || (sphy == AdvertisingSetParameters.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException("Unsupported secondary PHY selected");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException("Advertising data too big");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException("Scan response data too big");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException("Periodic advertising data too big");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && periodicParameters.getEnable() && !supportPeriodic) {
            throw new IllegalArgumentException("Controller does not support LE Periodic Advertising");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException("maxExtendedAdvertisingEvents out of range: " + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException("Can't use maxExtendedAdvertisingEvents with controller that don't support " + "LE Extended Advertising");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException("duration out of range: " + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to get Bluetooth gatt - ", e);
        throw new IllegalStateException("Failed to get Bluetooth");
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException("callback instance already associated with advertising");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to start advertising set - ", e);
        throw new IllegalStateException("Failed to start advertising set");
    }
}
#method_after
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, int timeoutMillis, AdvertisingSetCallback callback) {
    startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, timeoutMillis, callback, new Handler(Looper.getMainLooper()));
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(Intents.SMS_DELIVER_ACTION)) {
        // Now dispatch the notification only intent
        intent.setAction(Intents.SMS_RECEIVED_ACTION);
        // Allow other registered broadcast receivers to get this intent even
        // when they are in the background.
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        intent.setComponent(null);
        // All running users will be notified of the received sms.
        Bundle options = handleSmsWhitelisting(null);
        dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS, AppOpsManager.OP_RECEIVE_SMS, options, this, UserHandle.ALL);
    } else if (action.equals(Intents.WAP_PUSH_DELIVER_ACTION)) {
        // Now dispatch the notification only intent
        intent.setAction(Intents.WAP_PUSH_RECEIVED_ACTION);
        intent.setComponent(null);
        // Allow other registered broadcast receivers to get this intent even
        // when they are in the background.
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        // Only the primary user will receive notification of incoming mms.
        // That app will do the actual downloading of the mms.
        Bundle options = null;
        try {
            long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(mContext.getPackageName(), 0, "mms-broadcast");
            BroadcastOptions bopts = BroadcastOptions.makeBasic();
            bopts.setTemporaryAppWhitelistDuration(duration);
            options = bopts.toBundle();
        } catch (RemoteException e) {
        }
        String mimeType = intent.getType();
        dispatchIntent(intent, WapPushOverSms.getPermissionForType(mimeType), WapPushOverSms.getAppOpsPermissionForIntent(mimeType), options, this, UserHandle.SYSTEM);
    } else {
        // Now that the intents have been deleted we can clean up the PDU data.
        if (!Intents.DATA_SMS_RECEIVED_ACTION.equals(action) && !Intents.SMS_RECEIVED_ACTION.equals(action) && !Intents.DATA_SMS_RECEIVED_ACTION.equals(action) && !Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
            loge("unexpected BroadcastReceiver action: " + action);
        }
        int rc = getResultCode();
        if ((rc != Activity.RESULT_OK) && (rc != Intents.RESULT_SMS_HANDLED)) {
            loge("a broadcast receiver set the result code to " + rc + ", deleting from raw table anyway!");
        } else if (DBG) {
            log("successful broadcast, deleting from raw table.");
        }
        deleteFromRawTable(mDeleteWhere, mDeleteWhereArgs, MARK_DELETED);
        sendMessage(EVENT_BROADCAST_COMPLETE);
        int durationMillis = (int) ((System.nanoTime() - mBroadcastTimeNano) / 1000000);
        if (durationMillis >= 5000) {
            loge("Slow ordered broadcast completion time: " + durationMillis + " ms");
        } else if (DBG) {
            log("ordered broadcast completed in: " + durationMillis + " ms");
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    if (action.equals(Intents.SMS_DELIVER_ACTION)) {
        // Now dispatch the notification only intent
        intent.setAction(Intents.SMS_RECEIVED_ACTION);
        // Allow registered broadcast receivers to get this intent even
        // when they are in the background.
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        intent.setComponent(null);
        // All running users will be notified of the received sms.
        Bundle options = handleSmsWhitelisting(null);
        dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS, AppOpsManager.OP_RECEIVE_SMS, options, this, UserHandle.ALL);
    } else if (action.equals(Intents.WAP_PUSH_DELIVER_ACTION)) {
        // Now dispatch the notification only intent
        intent.setAction(Intents.WAP_PUSH_RECEIVED_ACTION);
        intent.setComponent(null);
        // Allow registered broadcast receivers to get this intent even
        // when they are in the background.
        intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
        // Only the primary user will receive notification of incoming mms.
        // That app will do the actual downloading of the mms.
        Bundle options = null;
        try {
            long duration = mDeviceIdleController.addPowerSaveTempWhitelistAppForMms(mContext.getPackageName(), 0, "mms-broadcast");
            BroadcastOptions bopts = BroadcastOptions.makeBasic();
            bopts.setTemporaryAppWhitelistDuration(duration);
            options = bopts.toBundle();
        } catch (RemoteException e) {
        }
        String mimeType = intent.getType();
        dispatchIntent(intent, WapPushOverSms.getPermissionForType(mimeType), WapPushOverSms.getAppOpsPermissionForIntent(mimeType), options, this, UserHandle.SYSTEM);
    } else {
        // Now that the intents have been deleted we can clean up the PDU data.
        if (!Intents.DATA_SMS_RECEIVED_ACTION.equals(action) && !Intents.SMS_RECEIVED_ACTION.equals(action) && !Intents.DATA_SMS_RECEIVED_ACTION.equals(action) && !Intents.WAP_PUSH_RECEIVED_ACTION.equals(action)) {
            loge("unexpected BroadcastReceiver action: " + action);
        }
        int rc = getResultCode();
        if ((rc != Activity.RESULT_OK) && (rc != Intents.RESULT_SMS_HANDLED)) {
            loge("a broadcast receiver set the result code to " + rc + ", deleting from raw table anyway!");
        } else if (DBG) {
            log("successful broadcast, deleting from raw table.");
        }
        deleteFromRawTable(mDeleteWhere, mDeleteWhereArgs, MARK_DELETED);
        sendMessage(EVENT_BROADCAST_COMPLETE);
        int durationMillis = (int) ((System.nanoTime() - mBroadcastTimeNano) / 1000000);
        if (durationMillis >= 5000) {
            loge("Slow ordered broadcast completion time: " + durationMillis + " ms");
        } else if (DBG) {
            log("ordered broadcast completed in: " + durationMillis + " ms");
        }
    }
}
#end_block

#method_before
void aclStateChangeCallback(int status, byte[] address, int newState) {
    BluetoothDevice device = getDevice(address);
    if (device == null) {
        errorLog("aclStateChangeCallback: Device is NULL");
        return;
    }
    int state = mAdapterService.getState();
    Intent intent = null;
    if (newState == AbstractionLayer.BT_ACL_STATE_CONNECTED) {
        if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_TURNING_ON) {
            intent = new Intent(BluetoothDevice.ACTION_ACL_CONNECTED);
        } else if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON) {
            intent = new Intent(BluetoothAdapter.ACTION_BLE_ACL_CONNECTED);
        }
        debugLog("aclStateChangeCallback: From: " + BluetoothAdapter.nameForState(state) + " to Connected: " + device);
    } else {
        if (device.getBondState() == BluetoothDevice.BOND_BONDING) {
            // Send PAIRING_CANCEL intent to dismiss any dialog requesting bonding.
            intent = new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
            intent.setPackage(mAdapterService.getString(R.string.pairing_ui_package));
            mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);
        }
        if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_TURNING_OFF) {
            intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED);
        } else if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
            intent = new Intent(BluetoothAdapter.ACTION_BLE_ACL_DISCONNECTED);
        }
        debugLog("aclStateChangeCallback: From: " + BluetoothAdapter.nameForState(state) + " to Disconnected: " + device);
    }
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);
}
#method_after
void aclStateChangeCallback(int status, byte[] address, int newState) {
    BluetoothDevice device = getDevice(address);
    if (device == null) {
        errorLog("aclStateChangeCallback: Device is NULL");
        return;
    }
    int state = mAdapterService.getState();
    Intent intent = null;
    if (newState == AbstractionLayer.BT_ACL_STATE_CONNECTED) {
        if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_TURNING_ON) {
            intent = new Intent(BluetoothDevice.ACTION_ACL_CONNECTED);
        } else if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON) {
            intent = new Intent(BluetoothAdapter.ACTION_BLE_ACL_CONNECTED);
        }
        debugLog("aclStateChangeCallback: Adapter State: " + BluetoothAdapter.nameForState(state) + " Connected: " + device);
    } else {
        if (device.getBondState() == BluetoothDevice.BOND_BONDING) {
            // Send PAIRING_CANCEL intent to dismiss any dialog requesting bonding.
            intent = new Intent(BluetoothDevice.ACTION_PAIRING_CANCEL);
            intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
            intent.setPackage(mAdapterService.getString(R.string.pairing_ui_package));
            mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);
        }
        if (state == BluetoothAdapter.STATE_ON || state == BluetoothAdapter.STATE_TURNING_OFF) {
            intent = new Intent(BluetoothDevice.ACTION_ACL_DISCONNECTED);
        } else if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
            intent = new Intent(BluetoothAdapter.ACTION_BLE_ACL_DISCONNECTED);
        }
        debugLog("aclStateChangeCallback: Adapter State: " + BluetoothAdapter.nameForState(state) + " Disconnected: " + device);
    }
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mAdapterService.sendBroadcast(intent, mAdapterService.BLUETOOTH_PERM);
}
#end_block

#method_before
public static INetd get() {
    for (int i = 0; ; i++) {
        final INetd netdInstance = getInstance();
        if (netdInstance != null) {
            return netdInstance;
        }
        // No netdInstance was received; sleep and retry.
        final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS;
        try {
            Thread.sleep(timeoutMs);
        } catch (InterruptedException e) {
        }
    }
}
#method_after
public static INetd get(long maxTimeoutMs) {
    if (maxTimeoutMs == 0)
        return getInstance();
    final long stop = (maxTimeoutMs > 0) ? SystemClock.elapsedRealtime() + maxTimeoutMs : Long.MAX_VALUE;
    long timeoutMs = 0;
    while (true) {
        final INetd netdInstance = getInstance();
        if (netdInstance != null) {
            return netdInstance;
        }
        final long remaining = stop - SystemClock.elapsedRealtime();
        if (remaining <= 0)
            break;
        // No netdInstance was received; sleep and retry.
        timeoutMs = Math.min(timeoutMs + BASE_TIMEOUT_MS, MAX_TIMEOUT_MS);
        timeoutMs = Math.min(timeoutMs, remaining);
        try {
            Thread.sleep(timeoutMs);
        } catch (InterruptedException e) {
        }
    }
    return null;
}
#end_block

#method_before
public static INetd get() {
    for (int i = 0; ; i++) {
        final INetd netdInstance = getInstance();
        if (netdInstance != null) {
            return netdInstance;
        }
        // No netdInstance was received; sleep and retry.
        final int timeoutMs = (i < (MAX_TIMEOUT_MS / BASE_TIMEOUT_MS)) ? (i * BASE_TIMEOUT_MS) : MAX_TIMEOUT_MS;
        try {
            Thread.sleep(timeoutMs);
        } catch (InterruptedException e) {
        }
    }
}
#method_after
public static INetd get() {
    return get(-1);
}
#end_block

#method_before
public static void run(NetdCommand cmd) {
    while (true) {
        try {
            cmd.run(get());
            return;
        } catch (RemoteException re) {
        }
    }
}
#method_after
public static void run(NetdCommand cmd) {
    while (true) {
        try {
            cmd.run(get());
            return;
        } catch (RemoteException re) {
            Log.e(TAG, "error communicating with netd: " + re);
        }
    }
}
#end_block

#method_before
public void setSupplicantLogLevel(boolean turnOnVerbose) {
    int logLevel = turnOnVerbose ? SupplicantStaIfaceHal.LOG_LEVEL_DEBUG : SupplicantStaIfaceHal.LOG_LEVEL_INFO;
    mSupplicantStaIfaceHal.setLogLevel(logLevel);
}
#method_after
public void setSupplicantLogLevel(boolean turnOnVerbose) {
    mSupplicantStaIfaceHal.setLogLevel(turnOnVerbose);
}
#end_block

#method_before
public boolean startFilteringMulticastV4Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#method_after
public boolean startFilteringMulticastV4Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#end_block

#method_before
public boolean stopFilteringMulticastV4Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#method_after
public boolean stopFilteringMulticastV4Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(RX_FILTER_TYPE_V4_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#end_block

#method_before
public boolean startFilteringMulticastV6Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#method_after
public boolean startFilteringMulticastV6Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.removeRxFilter(RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#end_block

#method_before
public boolean stopFilteringMulticastV6Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(SupplicantStaIfaceHal.RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#method_after
public boolean stopFilteringMulticastV6Packets() {
    return mSupplicantStaIfaceHal.stopRxFilter() && mSupplicantStaIfaceHal.addRxFilter(RX_FILTER_TYPE_V6_MULTICAST) && mSupplicantStaIfaceHal.startRxFilter();
}
#end_block

#method_before
public boolean setBluetoothCoexistenceMode(int mode) {
    return mSupplicantStaIfaceHal.setBtCoexistenceMode((byte) mode);
}
#method_after
public boolean setBluetoothCoexistenceMode(int mode) {
    return mSupplicantStaIfaceHal.setBtCoexistenceMode(mode);
}
#end_block

#method_before
/**
 * *****************************************************
 *  Vendor HAL operations
 * ******************************************************
 */
public boolean initializeVendorHal() {
    return mWifiVendorHal.initialize();
}
#method_after
public boolean initializeVendorHal(VendorHalDeathEventHandler handler) {
    return mWifiVendorHal.initialize(handler);
}
#end_block

#method_before
public boolean initialize() {
    mHalDeviceManager.initialize();
    mHalDeviceManager.registerStatusListener(mHalDeviceManagerStatusCallbacks, mWifiStateMachineHandlerThread.getLooper());
    return true;
}
#method_after
public boolean initialize(WifiNative.VendorHalDeathEventHandler handler) {
    synchronized (sLock) {
        mHalDeviceManager.initialize();
        mHalDeviceManager.registerStatusListener(mHalDeviceManagerStatusCallbacks, mLooper);
        mDeathEventHandler = handler;
        return true;
    }
}
#end_block

#method_before
@VisibleForTesting
static ArrayList<RttConfig> halRttConfigArrayFromFrameworkRttParamsArray(RttManager.RttParams[] params) {
    final int length = params.length;
    ArrayList<RttConfig> config = new ArrayList<RttConfig>(length);
    for (int i = 0; i < length; i++) {
        config.add(halRttConfigFromFrameworkRttParams(params[i]));
    }
    return config;
}
#method_after
@VisibleForTesting
static ArrayList<RttConfig> halRttConfigArrayFromFrameworkRttParamsArray(RttManager.RttParams[] params) {
    final int length = params.length;
    ArrayList<RttConfig> configs = new ArrayList<RttConfig>(length);
    for (int i = 0; i < length; i++) {
        RttConfig config = halRttConfigFromFrameworkRttParams(params[i]);
        if (config != null) {
            configs.add(config);
        }
    }
    return configs;
}
#end_block

#method_before
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return boolResult(false);
        if (mRttCmdId != 0)
            return boolResult(false);
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (ok(status)) {
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (ok(status))
                return true;
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    ArrayList<RttConfig> rttConfigs;
    try {
        rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    } catch (IllegalArgumentException e) {
        mLog.err("Illegal argument for RTT request").c(e.toString()).flush();
        return false;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return boolResult(false);
        if (mRttCmdId != 0)
            return boolResult(false);
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (ok(status)) {
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (ok(status))
                return true;
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    if (handler == null)
        return boolResult(false);
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mVerboseLogEventHandler != null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (!ok(status))
                return false;
            mVerboseLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean setLoggingEventHandler(WifiNative.WifiLoggerEventHandler handler) {
    if (handler == null)
        return boolResult(false);
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mLogEventHandler != null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(true);
            if (!ok(status))
                return false;
            mLogEventHandler = handler;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean resetLogHandler() {
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mVerboseLogEventHandler == null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (!ok(status))
                return false;
            status = mIWifiChip.stopLoggingToDebugRingBuffer();
            if (!ok(status))
                return false;
            mVerboseLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean resetLogHandler() {
    synchronized (sLock) {
        if (mIWifiChip == null)
            return boolResult(false);
        if (mLogEventHandler == null)
            return boolResult(false);
        try {
            WifiStatus status = mIWifiChip.enableDebugErrorAlerts(false);
            if (!ok(status))
                return false;
            status = mIWifiChip.stopLoggingToDebugRingBuffer();
            if (!ok(status))
                return false;
            mLogEventHandler = null;
            return true;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
        return true;
    }
}
#method_after
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        } catch (IllegalArgumentException e) {
            mLog.err("Illegal argument for roaming configuration").c(e.toString()).flush();
            return false;
        }
        return true;
    }
}
#end_block

#method_before
@Override
public void onDebugRingBufferDataAvailable(WifiDebugRingBufferStatus status, java.util.ArrayList<Byte> data) {
    // TODO(b/35875078) Reinstate logging when execessive callbacks are fixed
    // mVerboseLog.d("onDebugRingBufferDataAvailable " + status);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mVerboseLogEventHandler == null || status == null || data == null)
            return;
        eventHandler = mVerboseLogEventHandler;
    }
    eventHandler.onRingBufferData(ringBufferStatus(status), NativeUtil.byteArrayFromArrayList(data));
}
#method_after
@Override
public void onDebugRingBufferDataAvailable(WifiDebugRingBufferStatus status, java.util.ArrayList<Byte> data) {
    // TODO(b/35875078) Reinstate logging when execessive callbacks are fixed
    // mVerboseLog.d("onDebugRingBufferDataAvailable " + status);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mLogEventHandler == null || status == null || data == null)
            return;
        eventHandler = mLogEventHandler;
    }
    eventHandler.onRingBufferData(ringBufferStatus(status), NativeUtil.byteArrayFromArrayList(data));
}
#end_block

#method_before
@Override
public void onDebugErrorAlert(int errorCode, java.util.ArrayList<Byte> debugData) {
    mVerboseLog.d("onDebugErrorAlert " + errorCode);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mVerboseLogEventHandler == null || debugData == null)
            return;
        eventHandler = mVerboseLogEventHandler;
    }
    eventHandler.onWifiAlert(errorCode, NativeUtil.byteArrayFromArrayList(debugData));
}
#method_after
@Override
public void onDebugErrorAlert(int errorCode, java.util.ArrayList<Byte> debugData) {
    mVerboseLog.d("onDebugErrorAlert " + errorCode);
    WifiNative.WifiLoggerEventHandler eventHandler;
    synchronized (sLock) {
        if (mLogEventHandler == null || debugData == null)
            return;
        eventHandler = mLogEventHandler;
    }
    eventHandler.onWifiAlert(errorCode, NativeUtil.byteArrayFromArrayList(debugData));
}
#end_block

#method_before
@Override
public void onStatusChanged() {
    boolean isReady = mHalDeviceManager.isReady();
    boolean isStarted = mHalDeviceManager.isStarted();
    mVerboseLog.i("Device Manager onStatusChanged. isReady(): " + isReady + ", isStarted(): " + isStarted);
    if (!isReady) {
        // Probably something unpleasant, e.g. the server died
        synchronized (sLock) {
            clearState();
        }
    }
}
#method_after
@Override
public void onStatusChanged() {
    boolean isReady = mHalDeviceManager.isReady();
    boolean isStarted = mHalDeviceManager.isStarted();
    mVerboseLog.i("Device Manager onStatusChanged. isReady(): " + isReady + ", isStarted(): " + isStarted);
    if (!isReady) {
        // Probably something unpleasant, e.g. the server died
        WifiNative.VendorHalDeathEventHandler handler;
        synchronized (sLock) {
            clearState();
            handler = mDeathEventHandler;
        }
        if (handler != null) {
            handler.onDeath();
        }
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG)
        localLog("DefaultState");
}
#method_after
@Override
public void enter() {
    mActiveScans.clear();
    mPendingScans.clear();
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            transitionTo(mStartedState);
            break;
        case CMD_DRIVER_UNLOADED:
            transitionTo(mDefaultState);
            break;
        case WifiScanner.CMD_START_PNO_SCAN:
        case WifiScanner.CMD_STOP_PNO_SCAN:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "not available");
            break;
        case CMD_PNO_NETWORK_FOUND:
        case CMD_PNO_SCAN_FAILED:
        case WifiScanner.CMD_SCAN_RESULT:
        case WifiScanner.CMD_OP_FAILED:
            loge("Unexpected message " + msg.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            transitionTo(mIdleState);
            return HANDLED;
        case CMD_DRIVER_UNLOADED:
            transitionTo(mDefaultState);
            return HANDLED;
        case WifiScanner.CMD_START_SINGLE_SCAN:
        case WifiScanner.CMD_STOP_SINGLE_SCAN:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "not available");
            return HANDLED;
        case CMD_SCAN_RESULTS_AVAILABLE:
            if (DBG)
                localLog("ignored scan results available event");
            return HANDLED;
        case CMD_FULL_SCAN_RESULTS:
            if (DBG)
                localLog("ignored full scan result event");
            return HANDLED;
        case WifiScanner.CMD_GET_SINGLE_SCAN_RESULTS:
            msg.obj = new WifiScanner.ParcelableScanResults(mCachedScanResults.clone());
            replySucceeded(msg);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
@Override
public void enter() {
    if (DBG)
        localLog("DefaultState");
}
#method_after
@Override
public void enter() {
    if (DBG)
        localLog("DefaultState");
    mActiveBackgroundScans.clear();
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            transitionTo(mStartedState);
            break;
        case CMD_DRIVER_UNLOADED:
            transitionTo(mDefaultState);
            break;
        case WifiScanner.CMD_START_PNO_SCAN:
        case WifiScanner.CMD_STOP_PNO_SCAN:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "not available");
            break;
        case CMD_PNO_NETWORK_FOUND:
        case CMD_PNO_SCAN_FAILED:
        case WifiScanner.CMD_SCAN_RESULT:
        case WifiScanner.CMD_OP_FAILED:
            loge("Unexpected message " + msg.what);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            // is sent to this state machine first.
            if (mScannerImpl == null) {
                mScannerImpl = mScannerImplFactory.create(mContext, mLooper, mClock);
                mChannelHelper = mScannerImpl.getChannelHelper();
            }
            mBackgroundScheduler = new BackgroundScanScheduler(mChannelHelper);
            WifiNative.ScanCapabilities capabilities = new WifiNative.ScanCapabilities();
            if (!mScannerImpl.getScanCapabilities(capabilities)) {
                loge("could not get scan capabilities");
                return HANDLED;
            }
            if (capabilities.max_scan_buckets <= 0) {
                loge("invalid max buckets in scan capabilities " + capabilities.max_scan_buckets);
                return HANDLED;
            }
            mBackgroundScheduler.setMaxBuckets(capabilities.max_scan_buckets);
            mBackgroundScheduler.setMaxApPerScan(capabilities.max_ap_cache_per_scan);
            Log.i(TAG, "wifi driver loaded with scan capabilities: " + "max buckets=" + capabilities.max_scan_buckets);
            transitionTo(mStartedState);
            return HANDLED;
        case CMD_DRIVER_UNLOADED:
            Log.i(TAG, "wifi driver unloaded");
            transitionTo(mDefaultState);
            break;
        case WifiScanner.CMD_START_BACKGROUND_SCAN:
        case WifiScanner.CMD_STOP_BACKGROUND_SCAN:
        case WifiScanner.CMD_START_SINGLE_SCAN:
        case WifiScanner.CMD_STOP_SINGLE_SCAN:
        case WifiScanner.CMD_GET_SCAN_RESULTS:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "not available");
            break;
        case CMD_SCAN_RESULTS_AVAILABLE:
            if (DBG)
                localLog("ignored scan results available event");
            break;
        case CMD_FULL_SCAN_RESULTS:
            if (DBG)
                localLog("ignored full scan result event");
            break;
        default:
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void exit() {
    sendPnoScanFailedToAllAndClear(WifiScanner.REASON_UNSPECIFIED, "Scan was interrupted");
}
#method_after
@Override
public void exit() {
    sendBackgroundScanFailedToAllAndClear(WifiScanner.REASON_UNSPECIFIED, "Scan was interrupted");
    mScannerImpl.cleanup();
}
#end_block

#method_before
@Override
public boolean processMessage(Message msg) {
    ClientInfo ci = mClients.get(msg.replyTo);
    switch(msg.what) {
        case WifiScanner.CMD_START_PNO_SCAN:
            Bundle pnoParams = (Bundle) msg.obj;
            if (pnoParams == null) {
                replyFailed(msg, WifiScanner.REASON_INVALID_REQUEST, "params null");
                return HANDLED;
            }
            pnoParams.setDefusable(true);
            PnoSettings pnoSettings = pnoParams.getParcelable(WifiScanner.PNO_PARAMS_PNO_SETTINGS_KEY);
            // This message is handled after the transition to SwPnoScan/HwPnoScan state
            deferMessage(msg);
            if (mScannerImpl.isHwPnoSupported(pnoSettings.isConnected)) {
                transitionTo(mHwPnoScanState);
            } else {
                transitionTo(mSwPnoScanState);
            }
            break;
        case WifiScanner.CMD_STOP_PNO_SCAN:
            replyFailed(msg, WifiScanner.REASON_UNSPECIFIED, "no scan running");
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message msg) {
    ClientInfo ci = mClients.get(msg.replyTo);
    switch(msg.what) {
        case CMD_DRIVER_LOADED:
            return NOT_HANDLED;
        case CMD_DRIVER_UNLOADED:
            return NOT_HANDLED;
        case WifiScanner.CMD_START_BACKGROUND_SCAN:
            {
                mWifiMetrics.incrementBackgroundScanCount();
                Bundle scanParams = (Bundle) msg.obj;
                if (scanParams == null) {
                    replyFailed(msg, WifiScanner.REASON_INVALID_REQUEST, "params null");
                    return HANDLED;
                }
                scanParams.setDefusable(true);
                ScanSettings scanSettings = scanParams.getParcelable(WifiScanner.SCAN_PARAMS_SCAN_SETTINGS_KEY);
                WorkSource workSource = scanParams.getParcelable(WifiScanner.SCAN_PARAMS_WORK_SOURCE_KEY);
                if (addBackgroundScanRequest(ci, msg.arg2, scanSettings, workSource)) {
                    replySucceeded(msg);
                } else {
                    replyFailed(msg, WifiScanner.REASON_INVALID_REQUEST, "bad request");
                }
                break;
            }
        case WifiScanner.CMD_STOP_BACKGROUND_SCAN:
            removeBackgroundScanRequest(ci, msg.arg2);
            break;
        case WifiScanner.CMD_GET_SCAN_RESULTS:
            reportScanResults(mScannerImpl.getLatestBatchedScanResults(true));
            replySucceeded(msg);
            break;
        case CMD_SCAN_RESULTS_AVAILABLE:
            reportScanResults(mScannerImpl.getLatestBatchedScanResults(true));
            break;
        case CMD_FULL_SCAN_RESULTS:
            reportFullScanResult((ScanResult) msg.obj, /* bucketsScanned */
            msg.arg2);
            break;
        case CMD_SCAN_PAUSED:
            reportScanResults((ScanData[]) msg.obj);
            transitionTo(mPausedState);
            break;
        case CMD_SCAN_FAILED:
            Log.e(TAG, "WifiScanner background scan gave CMD_SCAN_FAILED");
            sendBackgroundScanFailedToAllAndClear(WifiScanner.REASON_UNSPECIFIED, "Background Scan failed");
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
public static IpSecService create(Context context) throws InterruptedException {
    return create(context, NETD_SERVICE_NAME);
}
#method_after
static IpSecService create(Context context) throws InterruptedException {
    final IpSecService service = new IpSecService(context);
    service.connectNativeNetdService();
    return service;
}
#end_block

#method_before
public void systemReady() {
    if (DBG) {
        final long start = System.currentTimeMillis();
        prepareNativeDaemon();
        final long delta = System.currentTimeMillis() - start;
        Log.d(TAG, "Prepared in " + delta + "ms");
        return;
    } else {
        prepareNativeDaemon();
    }
}
#method_after
public void systemReady() {
    if (isNetdAlive()) {
        Slog.d(TAG, "IpSecService is ready");
    } else {
        Slog.wtf(TAG, "IpSecService not ready: failed to connect to NetD Native Service!");
    }
}
#end_block

#method_before
private void connectNativeNetdService() {
    mNetdService = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME));
    if (!isNetdAlive()) {
        Log.wtf(TAG, "Can't connect to NativeNetdService " + NETD_SERVICE_NAME);
    }
}
#method_after
private void connectNativeNetdService() {
    // Avoid blocking the system server to do this
    Thread t = new Thread(new Runnable() {

        @Override
        public void run() {
            synchronized (mLock) {
                NetdService.get(NETD_FETCH_TIMEOUT);
            }
        }
    });
    t.run();
}
#end_block

#method_before
boolean isNetdAlive() {
    if (mNetdService == null) {
        return false;
    }
    try {
        return mNetdService.isAlive();
    } catch (RemoteException re) {
        return false;
    }
}
#method_after
boolean isNetdAlive() {
    synchronized (mLock) {
        final INetd netd = getNetdInstance();
        if (netd == null) {
            return false;
        }
        try {
            return netd.isAlive();
        } catch (RemoteException re) {
            return false;
        }
    }
}
#end_block

#method_before
private void run() {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "InitBeforeStartServices");
        // hope that time from cell towers or NTP fixes it shortly.
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, "System clock is before 1970; setting to 1970.");
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }
        // core/jni/AndroidRuntime.cpp
        if (!SystemProperties.get("persist.sys.language").isEmpty()) {
            final String languageTag = Locale.getDefault().toLanguageTag();
            SystemProperties.set("persist.sys.locale", languageTag);
            SystemProperties.set("persist.sys.language", "");
            SystemProperties.set("persist.sys.country", "");
            SystemProperties.set("persist.sys.localevar", "");
        }
        // Here we go!
        Slog.i(TAG, "Entered the Android system server!");
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
        // In case the runtime switched since last boot (such as when
        // the old runtime was removed in an OTA), set the system
        // property so that it is in sync. We can't do this in
        // libnativehelper's JniInvocation::Init code where we already
        // had to fallback to a different runtime because it is
        // running as root and we need to be the system user to set
        // the property. http://b/11463182
        SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());
        // Enable the sampling profiler.
        if (SamplingProfilerIntegration.isEnabled()) {
            SamplingProfilerIntegration.start();
            mProfilerSnapshotTimer = new Timer();
            mProfilerSnapshotTimer.schedule(new TimerTask() {

                @Override
                public void run() {
                    SamplingProfilerIntegration.writeSnapshot("system_server", null);
                }
            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);
        }
        // Mmmmmm... more memory!
        VMRuntime.getRuntime().clearGrowthLimit();
        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
        // Some devices rely on runtime fingerprint generation, so make sure
        // we've defined it before booting further.
        Build.ensureFingerprintProperty();
        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);
        // Within the system server, any incoming Bundles should be defused
        // to avoid throwing BadParcelableException.
        BaseBundle.setShouldDefuse(true);
        // Ensure binder calls into the system always run at foreground priority.
        BinderInternal.disableBackgroundScheduling(true);
        // Increase the number of binder threads in system_server
        BinderInternal.setMaxThreads(sMaxBinderThreads);
        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
        android.os.Process.setCanSelfBackground(false);
        Looper.prepareMainLooper();
        // Initialize native services.
        System.loadLibrary("android_servers");
        // Check whether we failed to shut down last time we tried.
        // This call may not return.
        performPendingShutdown();
        // Initialize the system context.
        createSystemContext();
        // Create the system service manager.
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    // Start services.
    try {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices");
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
    } catch (Throwable ex) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting system services", ex);
        throw ex;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    // Loop forever.
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#method_after
private void run() {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "InitBeforeStartServices");
        // hope that time from cell towers or NTP fixes it shortly.
        if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
            Slog.w(TAG, "System clock is before 1970; setting to 1970.");
            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
        }
        // 
        // Default the timezone property to GMT if not set.
        // 
        String timezoneProperty = SystemProperties.get("persist.sys.timezone");
        if (timezoneProperty == null || timezoneProperty.isEmpty()) {
            Slog.w(TAG, "Timezone not set; setting to GMT.");
            SystemProperties.set("persist.sys.timezone", "GMT");
        }
        // core/jni/AndroidRuntime.cpp
        if (!SystemProperties.get("persist.sys.language").isEmpty()) {
            final String languageTag = Locale.getDefault().toLanguageTag();
            SystemProperties.set("persist.sys.locale", languageTag);
            SystemProperties.set("persist.sys.language", "");
            SystemProperties.set("persist.sys.country", "");
            SystemProperties.set("persist.sys.localevar", "");
        }
        // Here we go!
        Slog.i(TAG, "Entered the Android system server!");
        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis());
        // In case the runtime switched since last boot (such as when
        // the old runtime was removed in an OTA), set the system
        // property so that it is in sync. We can't do this in
        // libnativehelper's JniInvocation::Init code where we already
        // had to fallback to a different runtime because it is
        // running as root and we need to be the system user to set
        // the property. http://b/11463182
        SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());
        // Enable the sampling profiler.
        if (SamplingProfilerIntegration.isEnabled()) {
            SamplingProfilerIntegration.start();
            mProfilerSnapshotTimer = new Timer();
            mProfilerSnapshotTimer.schedule(new TimerTask() {

                @Override
                public void run() {
                    SamplingProfilerIntegration.writeSnapshot("system_server", null);
                }
            }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);
        }
        // Mmmmmm... more memory!
        VMRuntime.getRuntime().clearGrowthLimit();
        // The system server has to run all of the time, so it needs to be
        // as efficient as possible with its memory usage.
        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
        // Some devices rely on runtime fingerprint generation, so make sure
        // we've defined it before booting further.
        Build.ensureFingerprintProperty();
        // Within the system server, it is an error to access Environment paths without
        // explicitly specifying a user.
        Environment.setUserRequired(true);
        // Within the system server, any incoming Bundles should be defused
        // to avoid throwing BadParcelableException.
        BaseBundle.setShouldDefuse(true);
        // Ensure binder calls into the system always run at foreground priority.
        BinderInternal.disableBackgroundScheduling(true);
        // Increase the number of binder threads in system_server
        BinderInternal.setMaxThreads(sMaxBinderThreads);
        // Prepare the main looper thread (this thread).
        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);
        android.os.Process.setCanSelfBackground(false);
        Looper.prepareMainLooper();
        // Initialize native services.
        System.loadLibrary("android_servers");
        // Check whether we failed to shut down last time we tried.
        // This call may not return.
        performPendingShutdown();
        // Initialize the system context.
        createSystemContext();
        // Create the system service manager.
        mSystemServiceManager = new SystemServiceManager(mSystemContext);
        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    // Start services.
    try {
        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "StartServices");
        startBootstrapServices();
        startCoreServices();
        startOtherServices();
    } catch (Throwable ex) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting system services", ex);
        throw ex;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
    }
    // For debug builds, log event loop stalls to dropbox for analysis.
    if (StrictMode.conditionallyEnableDebugLogging()) {
        Slog.i(TAG, "Enabled StrictMode for system server main thread.");
    }
    // Loop forever.
    Looper.loop();
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
#end_block

#method_before
public SecurityParameterIndex reserveSecurityParameterIndex(InetAddress destinationAddress, int requestedSpi) throws SpiUnavailableException, ResourceUnavailableException {
    return new SecurityParameterIndex(mContext, destinationAddress, requestedSpi);
}
#method_after
public SecurityParameterIndex reserveSecurityParameterIndex(InetAddress destinationAddress, int requestedSpi) throws SpiUnavailableException, ResourceUnavailableException {
    return new SecurityParameterIndex(mService, destinationAddress, requestedSpi);
}
#end_block

#method_before
/**
 * Open a socket that is bound to a free UDP port on the system.
 *
 * <p>By binding in this manner and holding the FileDescriptor, the socket cannot be un-bound by
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP
 * Encapsulation port.
 *
 * <p>This socket reservation works in conjunction with IpSecTransforms, which may re-use the
 * socket port. Explicitly opening this port is only necessary if communication is desired on
 * that port.
 *
 * @param port a local UDP port to be reserved for UDP Encapsulation. is provided, then this
 *     method will bind to the specified port or fail. To retrieve the port number, call {@link
 *     android.system.Os#getsockname(FileDescriptor)}.
 * @return a {@link UdpEncapsulationSocket} that is bound to the requested port for the lifetime
 *     of the object.
 */
// Returning a socket in this fashion that has been created and bound by the system
// is the only safe way to ensure that a socket is both accessible to the user and
// safely usable for Encapsulation without allowing a user to possibly unbind from/close
// the port, which could potentially impact the traffic of the next user who binds to that
public UdpEncapsulationSocket openUdpEncapsulationSocket(int port) throws IOException, ResourceUnavailableException {
    // Temporary code
    return new UdpEncapsulationSocket(mContext, port);
}
#method_after
/**
 * Open a socket that is bound to a free UDP port on the system.
 *
 * <p>By binding in this manner and holding the FileDescriptor, the socket cannot be un-bound by
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP
 * Encapsulation port.
 *
 * <p>This socket reservation works in conjunction with IpSecTransforms, which may re-use the
 * socket port. Explicitly opening this port is only necessary if communication is desired on
 * that port.
 *
 * @param port a local UDP port to be reserved for UDP Encapsulation. is provided, then this
 *     method will bind to the specified port or fail. To retrieve the port number, call {@link
 *     android.system.Os#getsockname(FileDescriptor)}.
 * @return a {@link UdpEncapsulationSocket} that is bound to the requested port for the lifetime
 *     of the object.
 */
// Returning a socket in this fashion that has been created and bound by the system
// is the only safe way to ensure that a socket is both accessible to the user and
// safely usable for Encapsulation without allowing a user to possibly unbind from/close
// the port, which could potentially impact the traffic of the next user who binds to that
public UdpEncapsulationSocket openUdpEncapsulationSocket(int port) throws IOException, ResourceUnavailableException {
    // Temporary code
    return new UdpEncapsulationSocket(mService, port);
}
#end_block

#method_before
/**
 * Open a socket that is bound to a port selected by the system.
 *
 * <p>By binding in this manner and holding the FileDescriptor, the socket cannot be un-bound by
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP
 * Encapsulation port.
 *
 * <p>This socket reservation works in conjunction with IpSecTransforms, which may re-use the
 * socket port. Explicitly opening this port is only necessary if communication is desired on
 * that port.
 *
 * @return a {@link UdpEncapsulationSocket} that is bound to an arbitrarily selected port
 */
// Returning a socket in this fashion that has been created and bound by the system
// is the only safe way to ensure that a socket is both accessible to the user and
// safely usable for Encapsulation without allowing a user to possibly unbind from/close
// the port, which could potentially impact the traffic of the next user who binds to that
public UdpEncapsulationSocket openUdpEncapsulationSocket() throws IOException, ResourceUnavailableException {
    // Temporary code
    return new UdpEncapsulationSocket(mContext);
}
#method_after
/**
 * Open a socket that is bound to a port selected by the system.
 *
 * <p>By binding in this manner and holding the FileDescriptor, the socket cannot be un-bound by
 * the caller. This provides safe access to a socket on a port that can later be used as a UDP
 * Encapsulation port.
 *
 * <p>This socket reservation works in conjunction with IpSecTransforms, which may re-use the
 * socket port. Explicitly opening this port is only necessary if communication is desired on
 * that port.
 *
 * @return a {@link UdpEncapsulationSocket} that is bound to an arbitrarily selected port
 */
// Returning a socket in this fashion that has been created and bound by the system
// is the only safe way to ensure that a socket is both accessible to the user and
// safely usable for Encapsulation without allowing a user to possibly unbind from/close
// the port, which could potentially impact the traffic of the next user who binds to that
public UdpEncapsulationSocket openUdpEncapsulationSocket() throws IOException, ResourceUnavailableException {
    // Temporary code
    return new UdpEncapsulationSocket(mService);
}
#end_block

#method_before
public void setWfcSettingForSlot(boolean enabled) {
    int value = enabled ? 1 : 0;
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value);
    setWfcSettingInternalForSlot(enabled, getWfcModeForSlot());
}
#method_after
public void setWfcSettingForSlot(boolean enabled) {
    int value = enabled ? 1 : 0;
    android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.WFC_IMS_ENABLED, value);
    setWfcNonPersistentForSlot(enabled, getWfcModeForSlot());
}
#end_block

#method_before
@Test
@SmallTest
public void testAddressUpdate() {
    String[][] testAddressMappingSet = { /* {"inputAddress", "updateAddress", "ExpectResult"} */
    { "12345", "12345", "12345" }, { "12345", "67890", "67890" }, { "12345*00000", "12345", "12345*00000" }, { "12345*00000", "67890", "67890" }, { "12345*00000", "12345*00000", "12345*00000" }, { "12345;11111*00000", "12345", "12345" }, { "12345*00000;11111", "12345", "12345*00000" }, { "18412345*00000", "18412345", "18412345*00000" }, { "+8112345*00000", "+8112345", "+8112345*00000" } };
    for (String[] testAddress : testAddressMappingSet) {
        mConnectionUT = new ImsPhoneConnection(mImsPhone, testAddress[0], mImsCT, mForeGroundCall, false);
        doReturn(testAddress[1]).when(mImsCallProfile).getCallExtra(eq(ImsCallProfile.EXTRA_OI));
        mConnectionUT.updateAddressDisplay(mImsCall);
        assertEquals(testAddress[2], mConnectionUT.getAddress());
    }
}
#method_after
@Test
@SmallTest
public void testAddressUpdate() {
    String[][] testAddressMappingSet = { /* {"inputAddress", "updateAddress", "ExpectResult"} */
    { "12345", "12345", "12345" }, { "12345", "67890", "67890" }, { "12345*00000", "12345", "12345*00000" }, { "12345*00000", "67890", "67890" }, { "12345*00000", "12345*00000", "12345*00000" }, { "12345;11111*00000", "12345", "12345" }, { "12345*00000;11111", "12345", "12345*00000" }, { "18412345*00000", "18412345", "18412345*00000" }, { "+8112345*00000", "+8112345", "+8112345*00000" }, { "12345*00000", "12346", "12346" } };
    for (String[] testAddress : testAddressMappingSet) {
        mConnectionUT = new ImsPhoneConnection(mImsPhone, testAddress[0], mImsCT, mForeGroundCall, false);
        doReturn(testAddress[1]).when(mImsCallProfile).getCallExtra(eq(ImsCallProfile.EXTRA_OI));
        mConnectionUT.updateAddressDisplay(mImsCall);
        assertEquals(testAddress[2], mConnectionUT.getAddress());
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        Log.i(getTag(), "Starting");
        // If anything needs to be obtained using the network, get it now.
        // This greatly reduces the complexity of seamless handover, which
        // tries to recreate the tunnel without shutting down everything.
        // In this demo, all we need to know is the server address.
        final SocketAddress serverAddress = new InetSocketAddress(mServerName, mServerPort);
        // Here we just use a counter to keep things simple.
        for (int attempt = 0; attempt < 10; ++attempt) {
            // Reset the counter if we were connected.
            if (run(serverAddress)) {
                attempt = 0;
            }
            // Sleep for a while. This also checks if we got interrupted.
            Thread.sleep(3000);
        }
        Log.i(getTag(), "Giving up");
    } catch (Exception e) {
        Log.e(getTag(), "Connection failed, exiting", e);
    }
    mListener.onDisconnect(mConnectionId);
}
#method_after
@Override
public void run() {
    try {
        Log.i(getTag(), "Starting");
        // If anything needs to be obtained using the network, get it now.
        // This greatly reduces the complexity of seamless handover, which
        // tries to recreate the tunnel without shutting down everything.
        // In this demo, all we need to know is the server address.
        final SocketAddress serverAddress = new InetSocketAddress(mServerName, mServerPort);
        // Here we just use a counter to keep things simple.
        for (int attempt = 0; attempt < 10; ++attempt) {
            // Reset the counter if we were connected.
            if (run(serverAddress)) {
                attempt = 0;
            }
            // Sleep for a while. This also checks if we got interrupted.
            Thread.sleep(3000);
        }
        Log.i(getTag(), "Giving up");
    } catch (IOException | InterruptedException | IllegalArgumentException e) {
        Log.e(getTag(), "Connection failed, exiting", e);
    }
}
#end_block

#method_before
private boolean run(SocketAddress server) throws Exception {
    ParcelFileDescriptor iface = null;
    boolean connected = false;
    // Create a DatagramChannel as the VPN tunnel.
    try (DatagramChannel tunnel = DatagramChannel.open()) {
        // Protect the tunnel before connecting to avoid loopback.
        if (!mService.protect(tunnel.socket())) {
            throw new IllegalStateException("Cannot protect the tunnel for");
        }
        // Connect to the server.
        tunnel.connect(server);
        // For simplicity, we use the same thread for both reading and
        // writing. Here we put the tunnel into non-blocking mode.
        tunnel.configureBlocking(false);
        // Authenticate and configure the virtual network interface.
        iface = handshake(tunnel);
        // Now we are connected. Set the flag.
        connected = true;
        // Packets to be sent are queued in this input stream.
        FileInputStream in = new FileInputStream(iface.getFileDescriptor());
        // Packets received need to be written to this output stream.
        FileOutputStream out = new FileOutputStream(iface.getFileDescriptor());
        // Allocate the buffer for a single packet.
        ByteBuffer packet = ByteBuffer.allocate(MAX_PACKET_SIZE);
        // Timeouts:
        // - when data has not been sent in a while, send empty keepalive messages.
        // - when data has not been received in a while, assume the connection is broken.
        long lastSendTime = System.currentTimeMillis();
        long lastReceiveTime = System.currentTimeMillis();
        // We keep forwarding packets till something goes wrong.
        while (true) {
            // Assume that we did not make any progress in this iteration.
            boolean idle = true;
            // Read the outgoing packet from the input stream.
            int length = in.read(packet.array());
            if (length > 0) {
                // Write the outgoing packet to the tunnel.
                packet.limit(length);
                tunnel.write(packet);
                packet.clear();
                // There might be more outgoing packets.
                idle = false;
                lastReceiveTime = System.currentTimeMillis();
            }
            // Read the incoming packet from the tunnel.
            length = tunnel.read(packet);
            if (length > 0) {
                // Ignore control messages, which start with zero.
                if (packet.get(0) != 0) {
                    // Write the incoming packet to the output stream.
                    out.write(packet.array(), 0, length);
                }
                packet.clear();
                // There might be more incoming packets.
                idle = false;
                lastSendTime = System.currentTimeMillis();
            }
            // fraction of time to avoid busy looping.
            if (idle) {
                Thread.sleep(IDLE_INTERVAL_MS);
                final long timeNow = System.currentTimeMillis();
                if (lastSendTime + KEEPALIVE_INTERVAL_MS <= timeNow) {
                    // We are receiving for a long time but not sending.
                    // Send empty control messages.
                    packet.put((byte) 0).limit(1);
                    for (int i = 0; i < 3; ++i) {
                        packet.position(0);
                        tunnel.write(packet);
                    }
                    packet.clear();
                    lastSendTime = timeNow;
                } else if (lastReceiveTime + RECEIVE_TIMEOUT_MS <= timeNow) {
                    // We are sending for a long time but not receiving.
                    throw new IllegalStateException("Timed out");
                }
            }
        }
    } catch (SocketException e) {
        Log.e(getTag(), "Cannot use socket", e);
    } catch (Exception e) {
        throw e;
    } finally {
        if (iface != null) {
            try {
                iface.close();
            } catch (Exception e) {
                Log.e(getTag(), "Unable to close interface", e);
            }
        }
    }
    return connected;
}
#method_after
private boolean run(SocketAddress server) throws IOException, InterruptedException, IllegalArgumentException {
    ParcelFileDescriptor iface = null;
    boolean connected = false;
    // Create a DatagramChannel as the VPN tunnel.
    try (DatagramChannel tunnel = DatagramChannel.open()) {
        // Protect the tunnel before connecting to avoid loopback.
        if (!mService.protect(tunnel.socket())) {
            throw new IllegalStateException("Cannot protect the tunnel");
        }
        // Connect to the server.
        tunnel.connect(server);
        // For simplicity, we use the same thread for both reading and
        // writing. Here we put the tunnel into non-blocking mode.
        tunnel.configureBlocking(false);
        // Authenticate and configure the virtual network interface.
        iface = handshake(tunnel);
        // Now we are connected. Set the flag.
        connected = true;
        // Packets to be sent are queued in this input stream.
        FileInputStream in = new FileInputStream(iface.getFileDescriptor());
        // Packets received need to be written to this output stream.
        FileOutputStream out = new FileOutputStream(iface.getFileDescriptor());
        // Allocate the buffer for a single packet.
        ByteBuffer packet = ByteBuffer.allocate(MAX_PACKET_SIZE);
        // Timeouts:
        // - when data has not been sent in a while, send empty keepalive messages.
        // - when data has not been received in a while, assume the connection is broken.
        long lastSendTime = System.currentTimeMillis();
        long lastReceiveTime = System.currentTimeMillis();
        // We keep forwarding packets till something goes wrong.
        while (true) {
            // Assume that we did not make any progress in this iteration.
            boolean idle = true;
            // Read the outgoing packet from the input stream.
            int length = in.read(packet.array());
            if (length > 0) {
                // Write the outgoing packet to the tunnel.
                packet.limit(length);
                tunnel.write(packet);
                packet.clear();
                // There might be more outgoing packets.
                idle = false;
                lastReceiveTime = System.currentTimeMillis();
            }
            // Read the incoming packet from the tunnel.
            length = tunnel.read(packet);
            if (length > 0) {
                // Ignore control messages, which start with zero.
                if (packet.get(0) != 0) {
                    // Write the incoming packet to the output stream.
                    out.write(packet.array(), 0, length);
                }
                packet.clear();
                // There might be more incoming packets.
                idle = false;
                lastSendTime = System.currentTimeMillis();
            }
            // fraction of time to avoid busy looping.
            if (idle) {
                Thread.sleep(IDLE_INTERVAL_MS);
                final long timeNow = System.currentTimeMillis();
                if (lastSendTime + KEEPALIVE_INTERVAL_MS <= timeNow) {
                    // We are receiving for a long time but not sending.
                    // Send empty control messages.
                    packet.put((byte) 0).limit(1);
                    for (int i = 0; i < 3; ++i) {
                        packet.position(0);
                        tunnel.write(packet);
                    }
                    packet.clear();
                    lastSendTime = timeNow;
                } else if (lastReceiveTime + RECEIVE_TIMEOUT_MS <= timeNow) {
                    // We are sending for a long time but not receiving.
                    throw new IllegalStateException("Timed out");
                }
            }
        }
    } catch (SocketException e) {
        Log.e(getTag(), "Cannot use socket", e);
    } finally {
        if (iface != null) {
            try {
                iface.close();
            } catch (IOException e) {
                Log.e(getTag(), "Unable to close interface", e);
            }
        }
    }
    return connected;
}
#end_block

#method_before
private ParcelFileDescriptor handshake(DatagramChannel tunnel) throws Exception {
    // To build a secured tunnel, we should perform mutual authentication
    // and exchange session keys for encryption. To keep things simple in
    // this demo, we just send the shared secret in plaintext and wait
    // for the server to send the parameters.
    // Allocate the buffer for handshaking.
    ByteBuffer packet = ByteBuffer.allocate(1024);
    // Control messages always start with zero.
    packet.put((byte) 0).put(mSharedSecret).flip();
    // Send the secret several times in case of packet loss.
    for (int i = 0; i < 3; ++i) {
        packet.position(0);
        tunnel.write(packet);
    }
    packet.clear();
    // Wait for the parameters within a limited time.
    for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) {
        Thread.sleep(IDLE_INTERVAL_MS);
        // Normally we should not receive random packets.
        int length = tunnel.read(packet);
        if (length > 0 && packet.get(0) == 0) {
            return configure(new String(packet.array(), 1, length - 1).trim());
        }
    }
    throw new IllegalStateException("Timed out");
}
#method_after
private ParcelFileDescriptor handshake(DatagramChannel tunnel) throws IOException, InterruptedException {
    // To build a secured tunnel, we should perform mutual authentication
    // and exchange session keys for encryption. To keep things simple in
    // this demo, we just send the shared secret in plaintext and wait
    // for the server to send the parameters.
    // Allocate the buffer for handshaking. We have a hardcoded maximum
    // handshake size of 1024 bytes, which should be enough for demo
    // purposes.
    ByteBuffer packet = ByteBuffer.allocate(1024);
    // Control messages always start with zero.
    packet.put((byte) 0).put(mSharedSecret).flip();
    // Send the secret several times in case of packet loss.
    for (int i = 0; i < 3; ++i) {
        packet.position(0);
        tunnel.write(packet);
    }
    packet.clear();
    // Wait for the parameters within a limited time.
    for (int i = 0; i < MAX_HANDSHAKE_ATTEMPTS; ++i) {
        Thread.sleep(IDLE_INTERVAL_MS);
        // Normally we should not receive random packets. Check that the first
        // byte is 0 as expected.
        int length = tunnel.read(packet);
        if (length > 0 && packet.get(0) == 0) {
            return configure(new String(packet.array(), 1, length - 1, US_ASCII).trim());
        }
    }
    throw new IOException("Timed out");
}
#end_block

#method_before
private ParcelFileDescriptor configure(String parameters) throws Exception {
    // Configure a builder while parsing the parameters.
    VpnService.Builder builder = mService.new Builder();
    for (String parameter : parameters.split(" ")) {
        String[] fields = parameter.split(",");
        try {
            switch(fields[0].charAt(0)) {
                case 'm':
                    builder.setMtu(Short.parseShort(fields[1]));
                    break;
                case 'a':
                    builder.addAddress(fields[1], Integer.parseInt(fields[2]));
                    break;
                case 'r':
                    builder.addRoute(fields[1], Integer.parseInt(fields[2]));
                    break;
                case 'd':
                    builder.addDnsServer(fields[1]);
                    break;
                case 's':
                    builder.addSearchDomain(fields[1]);
                    break;
            }
        } catch (Exception e) {
            throw new IllegalArgumentException("Bad parameter: " + parameter);
        }
    }
    // Create a new interface using the builder and save the parameters.
    final ParcelFileDescriptor vpnInterface;
    synchronized (mService) {
        vpnInterface = builder.setSession(mServerName).setConfigureIntent(mConfigureIntent).establish();
        mListener.onEstablish(mConnectionId, vpnInterface);
    }
    Log.i(getTag(), "New interface: " + vpnInterface + " (" + parameters + ")");
    return vpnInterface;
}
#method_after
private ParcelFileDescriptor configure(String parameters) throws IllegalArgumentException {
    // Configure a builder while parsing the parameters.
    VpnService.Builder builder = mService.new Builder();
    for (String parameter : parameters.split(" ")) {
        String[] fields = parameter.split(",");
        try {
            switch(fields[0].charAt(0)) {
                case 'm':
                    builder.setMtu(Short.parseShort(fields[1]));
                    break;
                case 'a':
                    builder.addAddress(fields[1], Integer.parseInt(fields[2]));
                    break;
                case 'r':
                    builder.addRoute(fields[1], Integer.parseInt(fields[2]));
                    break;
                case 'd':
                    builder.addDnsServer(fields[1]);
                    break;
                case 's':
                    builder.addSearchDomain(fields[1]);
                    break;
            }
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Bad parameter: " + parameter);
        }
    }
    // Create a new interface using the builder and save the parameters.
    final ParcelFileDescriptor vpnInterface;
    synchronized (mService) {
        vpnInterface = builder.setSession(mServerName).setConfigureIntent(mConfigureIntent).establish();
        if (mOnEstablishListener != null) {
            mOnEstablishListener.onEstablish(vpnInterface);
        }
    }
    Log.i(getTag(), "New interface: " + vpnInterface + " (" + parameters + ")");
    return vpnInterface;
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (ACTION_DISCONNECT.equals(intent.getAction())) {
        disconnect();
    } else {
        connect();
    }
    return START_STICKY;
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (intent != null && ACTION_DISCONNECT.equals(intent.getAction())) {
        disconnect();
        return START_NOT_STICKY;
    } else {
        connect();
        return START_STICKY;
    }
}
#end_block

#method_before
@Override
public boolean handleMessage(Message message) {
    if (message != null) {
        Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show();
        if (message.what != R.string.disconnected) {
            updateForegroundNotification(message.what);
        }
    }
    return true;
}
#method_after
@Override
public boolean handleMessage(Message message) {
    Toast.makeText(this, message.what, Toast.LENGTH_SHORT).show();
    if (message.what != R.string.disconnected) {
        updateForegroundNotification(message.what);
    }
    return true;
}
#end_block

#method_before
private synchronized void connect() {
    // Become a foreground service. Background services can be VPN services too, but they can
    // be killed by background check before getting a chance to receive onRevoke().
    updateForegroundNotification(R.string.connecting);
    mHandler.sendEmptyMessage(R.string.connecting);
    final SharedPreferences prefs = getSharedPreferences(ToyVpnClient.Prefs.NAME, MODE_PRIVATE);
    final ToyVpnConnection connection;
    try {
        // Extract information from the shared preferences.
        connection = new ToyVpnConnection(this, this, mNextConnectionId, prefs.getString(ToyVpnClient.Prefs.SERVER_ADDRESS, ""), Integer.parseInt(prefs.getString(ToyVpnClient.Prefs.SERVER_PORT, "")), prefs.getString(ToyVpnClient.Prefs.SHARED_SECRET, "").getBytes());
    } catch (NumberFormatException e) {
        Log.e(TAG, "Bad port: " + prefs.getString(ToyVpnClient.Prefs.SERVER_PORT, null), e);
        return;
    }
    connection.setConfigureIntent(mConfigureIntent);
    final Thread thread = new Thread(connection, "ToyVpnThread");
    mThreads.put(mNextConnectionId, thread);
    thread.start();
    ++mNextConnectionId;
}
#method_after
private void connect() {
    // Become a foreground service. Background services can be VPN services too, but they can
    // be killed by background check before getting a chance to receive onRevoke().
    updateForegroundNotification(R.string.connecting);
    mHandler.sendEmptyMessage(R.string.connecting);
    // Extract information from the shared preferences.
    final SharedPreferences prefs = getSharedPreferences(ToyVpnClient.Prefs.NAME, MODE_PRIVATE);
    final String server = prefs.getString(ToyVpnClient.Prefs.SERVER_ADDRESS, "");
    final byte[] secret = prefs.getString(ToyVpnClient.Prefs.SHARED_SECRET, "").getBytes();
    final int port;
    try {
        port = Integer.parseInt(prefs.getString(ToyVpnClient.Prefs.SERVER_PORT, ""));
    } catch (NumberFormatException e) {
        Log.e(TAG, "Bad port: " + prefs.getString(ToyVpnClient.Prefs.SERVER_PORT, null), e);
        return;
    }
    // Kick off a connection.
    startConnection(new ToyVpnConnection(this, mNextConnectionId.getAndIncrement(), server, port, secret));
}
#end_block

#method_before
private synchronized void disconnect() {
    mHandler.sendEmptyMessage(R.string.disconnected);
    try {
        mThreads.values().forEach(x -> x.interrupt());
    } catch (Exception e) {
        Log.e(TAG, "Interrupting thread", e);
    }
    mThreads.clear();
    // Close the connection so ConnectivityManager unbinds, taking the app out of foreground.
    onEstablish(-1, null);
    stopForeground(true);
}
#method_after
private void disconnect() {
    mHandler.sendEmptyMessage(R.string.disconnected);
    setConnectingThread(null);
    setConnection(null);
    stopForeground(true);
}
#end_block

#method_before
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null) {
            Log.e(TAG, "Invalid SSID postfix value (null).");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(NativeUtil.decodeSsid("\"" + postfix + "\"")));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        } catch (Exception e) {
            Log.e(TAG, "Could not decode SSID.", e);
            return false;
        }
        return result.isSuccess();
    }
}
#method_after
public boolean setSsidPostfix(String postfix) {
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("setSsidPostfix"))
            return false;
        // Basic checking here. Leave actual parameter validation to supplicant.
        if (postfix == null) {
            Log.e(TAG, "Invalid SSID postfix value (null).");
            return false;
        }
        SupplicantResult<Void> result = new SupplicantResult("setSsidPostfix(" + postfix + ")");
        try {
            result.setResult(mISupplicantP2pIface.setSsidPostfix(NativeUtil.decodeSsid("\"" + postfix + "\"")));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not decode SSID.", e);
            return false;
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean initiatorReportNfcHandover(String selectMessage) {
    if (selectMessage == null)
        return false;
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("initiatorReportNfcHandover"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("initiatorReportNfcHandover(" + selectMessage + ")");
        try {
            result.setResult(mISupplicantP2pIface.reportNfcHandoverInitiation(NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(selectMessage))));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        }
        return result.isSuccess();
    }
}
#method_after
public boolean initiatorReportNfcHandover(String selectMessage) {
    if (selectMessage == null)
        return false;
    synchronized (mLock) {
        if (!checkSupplicantP2pIfaceAndLogFailure("initiatorReportNfcHandover"))
            return false;
        SupplicantResult<Void> result = new SupplicantResult("initiatorReportNfcHandover(" + selectMessage + ")");
        try {
            result.setResult(mISupplicantP2pIface.reportNfcHandoverInitiation(NativeUtil.byteArrayToArrayList(NativeUtil.hexStringToByteArray(selectMessage))));
        } catch (RemoteException e) {
            Log.e(TAG, "ISupplicantP2pIface exception: " + e);
            supplicantServiceDiedHandler();
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Illegal argument " + selectMessage, e);
            return false;
        }
        return result.isSuccess();
    }
}
#end_block

#method_before
public boolean connectToNetwork(WifiConfiguration config, boolean shouldDisconnect) {
    mFrameworkNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mCurrentNetwork = null;
    logd("connectToNetwork " + config.configKey() + " (shouldDisconnect " + shouldDisconnect + ")");
    if (shouldDisconnect && !disconnect()) {
        loge("Failed to trigger disconnect");
        return false;
    }
    if (!removeAllNetworks()) {
        loge("Failed to remove existing networks");
        return false;
    }
    mCurrentNetwork = addNetworkAndSaveConfig(config);
    if (mCurrentNetwork == null) {
        loge("Failed to add/save network configuration: " + config.configKey());
        return false;
    }
    if (!mCurrentNetwork.select()) {
        loge("Failed to select network configuration: " + config.configKey());
        return false;
    }
    mFrameworkNetworkId = config.networkId;
    return true;
}
#method_after
public boolean connectToNetwork(WifiConfiguration config) {
    mFrameworkNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mCurrentNetwork = null;
    logd("connectToNetwork " + config.configKey());
    if (!removeAllNetworks()) {
        loge("Failed to remove existing networks");
        return false;
    }
    mCurrentNetwork = addNetworkAndSaveConfig(config);
    if (mCurrentNetwork == null) {
        loge("Failed to add/save network configuration: " + config.configKey());
        return false;
    }
    if (!mCurrentNetwork.select()) {
        loge("Failed to select network configuration: " + config.configKey());
        return false;
    }
    mFrameworkNetworkId = config.networkId;
    return true;
}
#end_block

#method_before
public boolean roamToNetwork(WifiConfiguration config) {
    if (mFrameworkNetworkId != config.networkId || mCurrentNetwork == null) {
        Log.w(TAG, "Cannot roam to a different network, initiate new connection. " + "Current network ID: " + mFrameworkNetworkId);
        return connectToNetwork(config, false);
    }
    String bssid = config.getNetworkSelectionStatus().getNetworkSelectionBSSID();
    logd("roamToNetwork" + config.configKey() + " (bssid " + bssid + ")");
    if (!mCurrentNetwork.setBssid(bssid)) {
        loge("Failed to set new bssid on network: " + config.configKey());
        return false;
    }
    if (!reassociate()) {
        loge("Failed to trigger reassociate");
        return false;
    }
    return true;
}
#method_after
public boolean roamToNetwork(WifiConfiguration config) {
    if (mFrameworkNetworkId != config.networkId || mCurrentNetwork == null) {
        Log.w(TAG, "Cannot roam to a different network, initiate new connection. " + "Current network ID: " + mFrameworkNetworkId);
        return connectToNetwork(config);
    }
    String bssid = config.getNetworkSelectionStatus().getNetworkSelectionBSSID();
    logd("roamToNetwork" + config.configKey() + " (bssid " + bssid + ")");
    if (!mCurrentNetwork.setBssid(bssid)) {
        loge("Failed to set new bssid on network: " + config.configKey());
        return false;
    }
    if (!reassociate()) {
        loge("Failed to trigger reassociate");
        return false;
    }
    return true;
}
#end_block

#method_before
@VisibleForTesting
static RttConfig halRttConfigFromFrameworkRttParams(RttManager.RttParams params) {
    try {
        RttConfig rttConfig = new RttConfig();
        if (params.bssid != null) {
            byte[] addr = NativeUtil.macAddressToByteArray(params.bssid);
            for (int i = 0; i < rttConfig.addr.length; i++) {
                rttConfig.addr[i] = addr[i];
            }
        }
        rttConfig.type = halRttTypeFromFrameworkRttType(params.requestType);
        rttConfig.peer = halPeerFromFrameworkPeer(params.deviceType);
        rttConfig.channel.width = halChannelWidthFromFrameworkChannelWidth(params.channelWidth);
        rttConfig.channel.centerFreq = params.frequency;
        rttConfig.channel.centerFreq0 = params.centerFreq0;
        rttConfig.channel.centerFreq1 = params.centerFreq1;
        // In 100ms units, 0 means no specific
        rttConfig.burstPeriod = params.interval;
        rttConfig.numBurst = params.numberBurst;
        rttConfig.numFramesPerBurst = params.numSamplesPerBurst;
        rttConfig.numRetriesPerRttFrame = params.numRetriesPerMeasurementFrame;
        rttConfig.numRetriesPerFtmr = params.numRetriesPerFTMR;
        rttConfig.mustRequestLci = params.LCIRequest;
        rttConfig.mustRequestLcr = params.LCRRequest;
        rttConfig.burstDuration = params.burstTimeout;
        rttConfig.preamble = halPreambleFromFrameworkPreamble(params.preamble);
        rttConfig.bw = halBwFromFrameworkBw(params.bandwidth);
        return rttConfig;
    } catch (IllegalArgumentException e) {
        return null;
    }
}
#method_after
@VisibleForTesting
static RttConfig halRttConfigFromFrameworkRttParams(RttManager.RttParams params) {
    RttConfig rttConfig = new RttConfig();
    if (params.bssid != null) {
        byte[] addr = NativeUtil.macAddressToByteArray(params.bssid);
        for (int i = 0; i < rttConfig.addr.length; i++) {
            rttConfig.addr[i] = addr[i];
        }
    }
    rttConfig.type = halRttTypeFromFrameworkRttType(params.requestType);
    rttConfig.peer = halPeerFromFrameworkPeer(params.deviceType);
    rttConfig.channel.width = halChannelWidthFromFrameworkChannelWidth(params.channelWidth);
    rttConfig.channel.centerFreq = params.frequency;
    rttConfig.channel.centerFreq0 = params.centerFreq0;
    rttConfig.channel.centerFreq1 = params.centerFreq1;
    // In 100ms units, 0 means no specific
    rttConfig.burstPeriod = params.interval;
    rttConfig.numBurst = params.numberBurst;
    rttConfig.numFramesPerBurst = params.numSamplesPerBurst;
    rttConfig.numRetriesPerRttFrame = params.numRetriesPerMeasurementFrame;
    rttConfig.numRetriesPerFtmr = params.numRetriesPerFTMR;
    rttConfig.mustRequestLci = params.LCIRequest;
    rttConfig.mustRequestLcr = params.LCRRequest;
    rttConfig.burstDuration = params.burstTimeout;
    rttConfig.preamble = halPreambleFromFrameworkPreamble(params.preamble);
    rttConfig.bw = halBwFromFrameworkBw(params.bandwidth);
    return rttConfig;
}
#end_block

#method_before
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    ArrayList<RttConfig> rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return boolResult(false);
        if (mRttCmdId != 0)
            return boolResult(false);
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (ok(status)) {
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (ok(status))
                return true;
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#method_after
public boolean requestRtt(RttManager.RttParams[] params, WifiNative.RttEventHandler handler) {
    ArrayList<RttConfig> rttConfigs;
    try {
        rttConfigs = halRttConfigArrayFromFrameworkRttParamsArray(params);
    } catch (IllegalArgumentException e) {
        mLog.err("Illegal argument for RTT request").c(e.toString()).flush();
        return false;
    }
    synchronized (sLock) {
        if (mIWifiRttController == null)
            return boolResult(false);
        if (mRttCmdId != 0)
            return boolResult(false);
        mRttCmdId = mRttCmdIdNext++;
        if (mRttCmdIdNext <= 0)
            mRttCmdIdNext = 1;
        try {
            mRttEventCallback = new RttEventCallback(mRttCmdId, handler);
            WifiStatus status = mIWifiRttController.rangeRequest(mRttCmdId, rttConfigs);
            if (ok(status)) {
                status = mIWifiRttController.registerEventCallback(mRttEventCallback);
            }
            if (ok(status))
                return true;
            mRttCmdId = 0;
            return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        }
    }
}
#end_block

#method_before
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        } catch (IllegalArgumentException e) {
            mLog.err("Illegal argument").flush();
            return false;
        }
        return true;
    }
}
#method_after
public boolean configureRoaming(WifiNative.RoamingConfig config) {
    synchronized (sLock) {
        if (mIWifiStaIface == null)
            return boolResult(false);
        try {
            StaRoamingConfig roamingConfig = new StaRoamingConfig();
            // parse the blacklist BSSIDs if any
            if (config.blacklistBssids != null) {
                for (String bssid : config.blacklistBssids) {
                    byte[] mac = NativeUtil.macAddressToByteArray(bssid);
                    roamingConfig.bssidBlacklist.add(mac);
                }
            }
            // parse the whitelist SSIDs if any
            if (config.whitelistSsids != null) {
                for (String ssidStr : config.whitelistSsids) {
                    String unquotedSsidStr = WifiInfo.removeDoubleQuotes(ssidStr);
                    int len = unquotedSsidStr.length();
                    if (len > 32) {
                        mLog.err("configureRoaming: skip invalid SSID %").r(unquotedSsidStr).flush();
                        continue;
                    }
                    byte[] ssid = new byte[len];
                    for (int i = 0; i < len; i++) {
                        ssid[i] = (byte) unquotedSsidStr.charAt(i);
                    }
                    roamingConfig.ssidWhitelist.add(ssid);
                }
            }
            WifiStatus status = mIWifiStaIface.configureRoaming(roamingConfig);
            if (!ok(status))
                return false;
        } catch (RemoteException e) {
            handleRemoteException(e);
            return false;
        } catch (IllegalArgumentException e) {
            mLog.err("Illegal argument for roaming configuration").c(e.toString()).flush();
            return false;
        }
        return true;
    }
}
#end_block

