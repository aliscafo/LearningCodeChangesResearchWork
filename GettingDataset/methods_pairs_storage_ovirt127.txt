882
#method_before
@Override
public String toString() {
    String AddInfo = getAdditionalInformation();
    return String.format("%s(%s %s)", super.toString(), (!StringUtils.isEmpty(AddInfo) ? AddInfo + "," : ""), (getParameters() != null ? getParameters().toString() : "null"));
}
#method_after
@Override
public String toString() {
    String AddInfo = getAdditionalInformation();
    return String.format("%s(%s %s)", super.toString(), (!AddInfo.isEmpty() ? AddInfo + "," : ""), (getParameters() != null ? getParameters().toString() : "null"));
}
#end_block

#method_before
@Override
protected String getAdditionalInformation() {
    if (getVds() != null) {
        return String.format("Vds=%1$s", getVds().getvds_name());
    } else {
        return super.getAdditionalInformation();
    }
}
#method_after
@Override
protected String getAdditionalInformation() {
    if (getVds() != null) {
        return String.format("Vds = %1$s", getVds().getvds_name());
    } else {
        return super.getAdditionalInformation();
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), new java.util.ArrayList<Guid>(java.util.Arrays.asList(new Guid[] { getStorageDomain().getId() })), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            setSucceeded(getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext())).getSucceeded());
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new storage_pool_iso_map(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                ConnectAllHostsToPool();
                VDSReturnValue returnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                DiconnectAllHostsInPool();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getstorage_domain_type();
                        getCompensationContext().snapshotEntityStatus(map, map.getstatus());
                        map.setstatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            final StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDAO();
                            final storage_domain_static domain = sdStatDao.get(getStorageDomain().getId());
                            final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
                            if (domain.getStorageFormat() != targetFormat) {
                                log.infoFormat("Updating storage domain {0} (type {1}) to format {2}", getStorageDomain().getId(), sdType, targetFormat);
                                domain.setStorageFormat(targetFormat);
                                sdStatDao.update(domain);
                            }
                        }
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                setSucceeded(returnValue.getSucceeded());
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain() != null) {
        if (getStoragePool().getstatus() == StoragePoolStatus.Uninitialized) {
            StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), new java.util.ArrayList<Guid>(java.util.Arrays.asList(new Guid[] { getStorageDomain().getId() })), getParameters().getSessionId());
            parameters.setIsInternal(true);
            parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
            setSucceeded(getBackend().runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters, new CommandContext(getCompensationContext())).getSucceeded());
        } else {
            map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
            if (map == null) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        map = new storage_pool_iso_map(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().save(map);
                        getCompensationContext().snapshotNewEntity(map);
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
                ConnectAllHostsToPool();
                VDSReturnValue returnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
                DiconnectAllHostsInPool();
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        final StorageDomainType sdType = getStorageDomain().getstorage_domain_type();
                        map.setstatus(StorageDomainStatus.Maintenance);
                        getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getstatus());
                        if (sdType == StorageDomainType.Master) {
                            calcStoragePoolStatusByDomainsStatus();
                        }
                        // upgrade the domain format to the storage pool format
                        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
                            final storage_domain_static domain = getStorageDomain().getStorageStaticData();
                            final StorageFormatType targetFormat = getStoragePool().getStoragePoolFormatType();
                            if (domain.getStorageFormat() != targetFormat) {
                                log.infoFormat("Updating storage domain {0} (type {1}) to format {2}", getStorageDomain().getId(), sdType, targetFormat);
                                domain.setStorageFormat(targetFormat);
                                getStorageDomainStaticDAO().update(domain);
                            }
                        }
                        return null;
                    }
                });
                setSucceeded(returnValue.getSucceeded());
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IrsErrorIrsDbMissing ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            failover();
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSNetworkException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("Storage Domain server not found", ex);
        } catch (IRSUnicodeArgumentException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError.equals(ex.getVdsError().getCode())) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IrsOperationFailedNoFailoverException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            getVDSReturnValue().setSucceeded(false);
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            if (_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
                getCurrentIrsProxyData().getTriedVdssList().clear();
            }
            if (!getCurrentIrsProxyData().getIsValidWithoutSpmStart()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void ExecuteVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IrsErrorIrsDbMissing ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            failover();
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSNetworkException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("Storage Domain server not found", ex);
        } catch (IRSUnicodeArgumentException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IrsOperationFailedNoFailoverException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            getVDSReturnValue().setSucceeded(false);
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            if (_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
                getCurrentIrsProxyData().getTriedVdssList().clear();
            }
            if (!getCurrentIrsProxyData().getIsValidWithoutSpmStart()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#end_block

#method_before
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if (StringHelper.EqOp(fieldName, "TYPE")) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    } else {
    }
    return retval;
}
#method_after
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if ("TYPE".equals(fieldName)) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    }
    return retval;
}
#end_block

#method_before
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vLanVmMtu9000");
    newNet.setMtu(9000);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNic("nic0", net.getName());
    nic.setBridged(false);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), 100, newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#method_after
@Test
public void networkWithTheSameMTUAddedToNic() {
    Network net = createNetwork("nonVmMtu9000");
    net.setVmNetwork(false);
    net.setMtu(9000);
    Network newNet = createNetwork("vlanVmMtu9000");
    newNet.setMtu(9000);
    newNet.setvlan_id(100);
    mockExistingNetworks(net, newNet);
    VdsNetworkInterface nic = createNicSyncedWithNetwork("nic0", net);
    mockExistingIfaces(nic);
    SetupNetworksHelper helper = createHelper(createParametersForNics(nic, createVlan(nic.getName(), newNet.getvlan_id(), newNet.getName())));
    validateAndExpectNoViolations(helper);
}
#end_block

#method_before
private void validateMTU() {
    Map<String, VdsNetworkInterface> ifacesByNetworkName = Entities.interfacesByNetworkName(params.getInterfaces());
    Set<String> checkedNetworks = new HashSet<String>(getNetworks().size());
    for (Network network : getNetworks()) {
        if (!checkedNetworks.contains(network.getName())) {
            List<Network> networksOnInterface = findNetworksOnInterface(ifacesByNetworkName.get(network.getName()));
            boolean mtuDifferenceExists = false;
            for (Network net : networksOnInterface) {
                checkedNetworks.add(net.getName());
                if (net.getMtu() != network.getMtu() && (!network.isVmNetwork() || !net.isVmNetwork())) {
                    mtuDifferenceExists = true;
                }
            }
            if (mtuDifferenceExists) {
                reportMTUDifferences(networksOnInterface);
            }
        }
    }
}
#method_after
private void validateMTU() {
    Map<String, VdsNetworkInterface> ifacesByNetworkName = Entities.interfacesByNetworkName(params.getInterfaces());
    Set<String> checkedNetworks = new HashSet<String>(getNetworks().size());
    for (Network network : getNetworks()) {
        if (!checkedNetworks.contains(network.getName())) {
            List<Network> networksOnInterface = findNetworksOnInterface(ifacesByNetworkName.get(network.getName()));
            boolean mtuMismatched = false;
            for (Network net : networksOnInterface) {
                checkedNetworks.add(net.getName());
                if (net.getMtu() != network.getMtu() && (NetworkUtils.isNonVmNetworkWithNoVlan(network) || NetworkUtils.isNonVmNetworkWithNoVlan(net))) {
                    mtuMismatched = true;
                }
            }
            if (mtuMismatched) {
                reportMTUDifferences(networksOnInterface);
            }
        }
    }
}
#end_block

#method_before
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<String>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%d)", net.getName(), net.getMtu()));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#method_after
private void reportMTUDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<String>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#end_block

#method_before
private List<Network> findNetworksOnInterface(VdsNetworkInterface iface) {
    String nameWithoutVlanId = NetworkUtils.StripVlan(iface.getName());
    List<Network> networks = new ArrayList<Network>();
    for (VdsNetworkInterface tmp : params.getInterfaces()) {
        if (NetworkUtils.StripVlan(tmp.getName()).equals(nameWithoutVlanId) && tmp.getNetworkName() != null) {
            if (existingClusterNetworks.containsKey(tmp.getNetworkName())) {
                networks.add(existingClusterNetworks.get(tmp.getNetworkName()));
            }
        }
    }
    return networks;
}
#method_after
private List<Network> findNetworksOnInterface(VdsNetworkInterface iface) {
    String nameWithoutVlanId = NetworkUtils.StripVlan(iface.getName());
    List<Network> networks = new ArrayList<Network>();
    for (VdsNetworkInterface tmp : params.getInterfaces()) {
        if (NetworkUtils.StripVlan(tmp.getName()).equals(nameWithoutVlanId) && tmp.getNetworkName() != null) {
            if (getExistingClusterNetworks().containsKey(tmp.getNetworkName())) {
                networks.add(getExistingClusterNetworks().get(tmp.getNetworkName()));
            }
        }
    }
    return networks;
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
            }
        } else if (unmanagedNetworkChanged(iface)) {
            addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getvlan_id(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice vmDevice = VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), getParameters().getInterface().isActive());
    boolean succeded = true;
    VmDynamic vmDynamic = getVm().getDynamicData();
    if (getParameters().getInterface().isActive() && VmHandler.isHotPlugNicAllowedForVmStatus(vmDynamic.getstatus())) {
        succeded = hotPlugNic(vmDevice, vmDynamic);
        if (!succeded) {
            getReturnValue().getExecuteFailedMessages().add("Failed hot-plugging nic to VM");
        }
    }
    setSucceeded(succeded);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (getParameters().getInterface().isActive()) {
        if (getVm().getstatus() == VMStatus.Up && !canPerformHotPlug()) {
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (ImagesHandler.isVmInPreview(getVmId())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
private void rollbackDisksQuota() {
    List<Guid> quotaList = new ArrayList<Guid>();
    for (DiskImage image : imageTemplates) {
        quotaList.add(image.getQuotaId());
    }
    getQuotaManager().rollbackQuota(getStoragePool(), quotaList);
}
#method_after
private void rollbackDisksQuota() {
    List<Guid> quotaList = new ArrayList<Guid>();
    if (imageTemplates != null) {
        for (DiskImage image : imageTemplates) {
            quotaList.add(image.getQuotaId());
        }
        getQuotaManager().rollbackQuota(getStoragePool(), quotaList);
    }
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (Disk disk : getVm().getDiskMap().values()) {
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new StorageQuotaValidationParameter(diskImage.getQuotaId(), // TODO: handle import more than once;
            imageToDestinationDomainMap.get(diskImage.getId()), diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (Disk disk : getParameters().getVm().getDiskMap().values()) {
        if (disk instanceof DiskImage) {
            DiskImage diskImage = (DiskImage) disk;
            list.add(new StorageQuotaValidationParameter(diskImage.getQuotaId(), // TODO: handle import more than once;
            imageToDestinationDomainMap.get(diskImage.getId()), diskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int i = 0;
            for (DiskImage disk : disks) {
                Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getvolume_type());
                tempVar.setVolumeFormat(disk.getvolume_format());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setPostZero(disk.isWipeAfterDelete());
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(true);
                tempVar.setImportEntity(true);
                tempVar.setEntityId(disk.getImageId());
                tempVar.setQuotaId(disk.getQuotaId());
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParemeters(getParameters());
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getParameters().getImagesParameters().add(p);
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
                i++;
            }
            return null;
        }
    });
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            int i = 0;
            for (DiskImage disk : disks) {
                Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
                MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
                tempVar.setParentCommand(getActionType());
                tempVar.setUseCopyCollapse(true);
                tempVar.setVolumeType(disk.getvolume_type());
                tempVar.setVolumeFormat(disk.getvolume_format());
                tempVar.setCopyVolumeType(CopyVolumeType.SharedVol);
                tempVar.setPostZero(disk.isWipeAfterDelete());
                tempVar.setSourceDomainId(getParameters().getSourceDomainId());
                tempVar.setForceOverride(true);
                tempVar.setImportEntity(true);
                tempVar.setEntityId(disk.getImageId());
                for (DiskImage diskImage : getParameters().getVmTemplate().getDiskList()) {
                    if (diskGuidList.get(i).equals(diskImage.getId())) {
                        tempVar.setQuotaId(diskImage.getQuotaId());
                        break;
                    }
                }
                MoveOrCopyImageGroupParameters p = tempVar;
                p.setParentParemeters(getParameters());
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw ((vdcRetValue.getFault() != null) ? new VdcBLLException(vdcRetValue.getFault().getError()) : new VdcBLLException(VdcBllErrors.ENGINE));
                }
                getParameters().getImagesParameters().add(p);
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
                i++;
            }
            return null;
        }
    });
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : getParameters().getImages()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId(), // TODO: handle import more than once;
        imageToDestinationDomainMap.get(disk.getId()), disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId(), // TODO: handle import more than once;
        imageToDestinationDomainMap.get(disk.getId()), disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        Map<Guid, Guid> quotaMap = new HashMap<Guid, Guid>();
        quotaMap.put(getQuotaId(), getQuotaId());
        for (DiskImage disk : getParameters().getImages()) {
            if (disk.getQuotaId() != null && !quotaMap.containsKey(disk.getQuotaId())) {
                quotaPermissionList.add(new PermissionSubject(disk.getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                quotaMap.put(disk.getQuotaId(), disk.getQuotaId());
            }
        }
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        Map<Guid, Guid> quotaMap = new HashMap<Guid, Guid>();
        quotaMap.put(getQuotaId(), getQuotaId());
        for (DiskImage disk : getParameters().getVmTemplate().getDiskList()) {
            if (disk.getQuotaId() != null && !quotaMap.containsKey(disk.getQuotaId())) {
                quotaPermissionList.add(new PermissionSubject(disk.getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                quotaMap.put(disk.getQuotaId(), disk.getQuotaId());
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean validateAndSetQuota() {
    return getQuotaManager().validateAndSetStorageQuota(getStoragePool(), getStorageQuotaListParameters(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
public boolean validateAndSetQuota() {
    if (isInternalExecution()) {
        return true;
    }
    return getQuotaManager().validateAndSetStorageQuota(getStoragePool(), getStorageQuotaListParameters(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public void rollbackQuota() {
    getQuotaManager().rollbackQuota(getStoragePool(), getQuotaManager().getQuotaListFromParameters(getStorageQuotaListParameters()));
}
#method_after
@Override
public void rollbackQuota() {
    if (isInternalExecution()) {
        return;
    }
    getQuotaManager().rollbackQuota(getStoragePool(), getQuotaManager().getQuotaListFromParameters(getStorageQuotaListParameters()));
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && getVm().getstatus() != VMStatus.Suspended) {
                if (getVm().getDiskList().isEmpty()) {
                    // If there are no snappable disks, there is no meaning for
                    // running as stateless, log a warning and run normally
                    warnIfNotAllDisksPermitSnapshots();
                    RunVm();
                } else {
                    StatelessVmTreatment();
                }
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(VdcActionType.RunVm, getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.EndSuccessfully();
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.EndSuccessfully();
    }
}
#end_block

#method_before
@Override
public boolean validateAndSetQuota() {
    return getQuotaManager().validateAndSetClusterQuota(getStoragePool(), getVm().getvds_group_id(), getQuotaId(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
public boolean validateAndSetQuota() {
    boolean canDoAction = getQuotaManager().validateAndSetClusterQuota(getStoragePool(), getVm().getvds_group_id(), getQuotaId(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages());
    getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
    return canDoAction;
}
#end_block

#method_before
@Override
public NGuid getStorageDomainId() {
    return getParameters() != null ? !getParameters().getStorageDomainId().equals(Guid.Empty) ? getParameters().getStorageDomainId() : super.getStorageDomainId() : super.getStorageDomainId();
}
#method_after
@Override
public NGuid getStorageDomainId() {
    return getParameters() != null ? !Guid.Empty.equals(getParameters().getStorageDomainId()) ? getParameters().getStorageDomainId() : super.getStorageDomainId() : super.getStorageDomainId();
}
#end_block

#method_before
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        getBackend().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
    }
}
#method_after
protected void RefreshAllVdssInPool(boolean connect) {
    java.util.ArrayList<Guid> vdsIdsToSetNonOperational = new java.util.ArrayList<Guid>();
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE);
        tempVar.setSaveToDb(true);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        getBackend().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    if (this instanceof Quotable) {
        ((Quotable) this).rollbackQuota();
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (this instanceof Quotable) {
            ((Quotable) this).rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private boolean InternalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = IsUserAutorizedToRunAction() && IsBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction();
            if (this instanceof Quotable) {
                returnValue &= ((Quotable) this).validateAndSetQuota();
            }
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean InternalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = IsUserAutorizedToRunAction() && IsBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction();
            if (returnValue && this instanceof Quotable) {
                returnValue &= ((Quotable) this).validateAndSetQuota();
            }
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons:{1}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (this instanceof Quotable) {
        ((Quotable) this).addQuotaPermissionSubject(permSubjects);
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
            if (permSubject.getMessage() != null) {
                addCanDoActionMessage(permSubject.getMessage());
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            }
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#method_after
protected boolean IsUserAutorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (this instanceof Quotable) {
        ((Quotable) this).addQuotaPermissionSubject(permSubjects);
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(permSubject.getMessage());
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#end_block

#method_before
@Override
public void Rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    if (this instanceof Quotable) {
        ((Quotable) this).rollbackQuota();
    }
    cancelTasks();
}
#method_after
@Override
public void Rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (this instanceof Quotable) {
            ((Quotable) this).rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    returnValue = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (returnValue && vm != null && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomainId().getValue(), vm.getstorage_pool_id())) == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    returnValue = returnValue && checkImageConfiguration() && (vm == null || isDiskPassPCIAndIDELimit(getParameters().getDiskInfo()));
    returnValue = returnValue && (vm == null || performImagesChecks(vm));
    if (returnValue && !hasFreeSpace(getStorageDomain())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    if (returnValue && isExceedMaxBlockDiskSize()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
        getReturnValue().getCanDoActionMessages().add(String.format("$max_disk_size %1$s", Config.<Integer>GetValue(ConfigValues.MaxBlockDiskSize)));
        returnValue = false;
    }
    if (returnValue && getParameters().getDiskInfo().isShareable() && !Config.<Boolean>GetValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return returnValue && (vm == null || validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId())));
}
#method_after
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    returnValue = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (returnValue && vm != null && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomainId().getValue(), vm.getstorage_pool_id())) == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    returnValue = returnValue && checkImageConfiguration() && (vm == null || isDiskPassPCIAndIDELimit(getParameters().getDiskInfo()));
    returnValue = returnValue && (vm == null || performImagesChecks(vm));
    if (returnValue && !hasFreeSpace(getStorageDomain())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    if (returnValue && isExceedMaxBlockDiskSize()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
        getReturnValue().getCanDoActionMessages().add(String.format("$max_disk_size %1$s", Config.<Integer>GetValue(ConfigValues.MaxBlockDiskSize)));
        returnValue = false;
    }
    if (returnValue && getParameters().getDiskInfo().isShareable()) {
        if (!Config.<Boolean>GetValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        } else if (!isVolumeFormatSupportedForShareable(((DiskImage) getParameters().getDiskInfo()).getvolume_format())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    }
    return returnValue && (vm == null || validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId())));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDAO().getByName(getVdsGroup().getname()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getstorage_pool_id() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__CREATE.toString());
    if (DbFacade.getInstance().getVdsGroupDAO().getByName(getVdsGroup().getname()) != null) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
        result = false;
    } else if (getVdsGroup().supportsVirtService() && !CpuFlagsManagerHandler.CheckIfCpusExist(getVdsGroup().getcpu_name(), getVdsGroup().getcompatibility_version())) {
        // cpu check required only if the cluster supports Virt service
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    } else if (getVdsGroup().getstorage_pool_id() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id());
        if (getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(getVdsGroup().getcompatibility_version()) > 0) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_COMPATIBILITY_VERSION_WITH_LOWER_STORAGE_POOL.toString());
            result = false;
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        // breaking Fk_vds_groups_storage_pool_id
        if (storagePool == null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString());
            result = false;
        } else if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add("type", "interface");
    map.add("device", "bridge");
    map.add("macAddr", nic.getMacAddress());
    map.add("network", nic.getNetworkName());
    addAddress(map, vmDevice.getAddress());
    map.add("specParams", vmDevice.getSpecParams());
    map.add("nicModel", VmInterfaceType.forValue(nic.getType()).name());
    if (vmDevice.getBootOrder() > 0) {
        map.add("bootOrder", String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        struct.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    }
    return map;
}
#method_after
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add("type", "interface");
    map.add("device", "bridge");
    map.add("macAddr", nic.getMacAddress());
    map.add("network", nic.getNetworkName());
    addAddress(map, vmDevice.getAddress());
    map.add("specParams", vmDevice.getSpecParams());
    map.add("nicModel", VmInterfaceType.forValue(nic.getType()).name());
    if (vmDevice.getBootOrder() > 0) {
        map.add("bootOrder", String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        map.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    }
    return map;
}
#end_block

#method_before
private void validateEnumParameters(GlusterVolume volume) {
    validateEnum(GlusterVolumeType.class, volume.getVolumeType().toUpperCase());
    if (volume.isSetTransportTypes()) {
        validateEnums(TransportType.class, convertToUppercase(volume.getTransportTypes().getTransportTypes()));
    }
    if (volume.isSetAccessProtocols()) {
        validateEnums(AccessProtocol.class, convertToUppercase(volume.getAccessProtocols().getAccessProtocols()));
    }
}
#method_after
private void validateEnumParameters(GlusterVolume volume) {
    validateEnum(GlusterVolumeType.class, volume.getVolumeType().toUpperCase());
    if (volume.isSetTransportTypes()) {
        validateEnumValues(TransportType.class, convertToUppercase(volume.getTransportTypes().getTransportTypes()));
    }
    if (volume.isSetAccessProtocols()) {
        validateEnumValues(AccessProtocol.class, convertToUppercase(volume.getAccessProtocols().getAccessProtocols()));
    }
}
#end_block

#method_before
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setState(fromBrick.getStatus().name().toLowerCase());
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#method_after
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setStatus(StatusUtils.create(map(fromBrick.getStatus(), null)));
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#end_block

#method_before
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getId() != null) {
        brick.setId(fromBrick.getId().toString());
    }
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setState(fromBrick.getStatus().name().toLowerCase());
    }
    if (fromBrick.getVolumeId() != null) {
        brick.setGlusterVolume(new GlusterVolume());
        brick.getGlusterVolume().setId(fromBrick.getVolumeId().toString());
    }
    return brick;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus.class, to = GlusterState.class)
public static GlusterState map(org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus glusterVolumeStatus, String template) {
    switch(glusterVolumeStatus) {
        case UP:
            return GlusterState.UP;
        case DOWN:
            return GlusterState.DOWN;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    if (fromVolume.getId() != null) {
        volume.setId(fromVolume.getId().toString());
    }
    if (fromVolume.getName() != null) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.getVolumeType() != null) {
        volume.setVolumeType(map(fromVolume.getVolumeType(), null).toLowerCase());
    }
    if (fromVolume.getTransportTypes() != null) {
        ArrayList<String> transportTypeList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType : fromVolume.getTransportTypes()) {
            transportTypeList.add(map(transportType, null).toLowerCase());
        }
        volume.setTransportTypes(new TransportTypes());
        volume.getTransportTypes().getTransportTypes().addAll(transportTypeList);
    }
    if (fromVolume.getAccessProtocols() != null) {
        ArrayList<String> accessProtocolList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol : fromVolume.getAccessProtocols()) {
            accessProtocolList.add(map(accessProtocol, null).toLowerCase());
        }
        volume.setAccessProtocols(new AccessProtocols());
        volume.getAccessProtocols().getAccessProtocols().addAll(accessProtocolList);
    }
    if (fromVolume.getAccessControlList() != null) {
        volume.setAccessControlList(new AccessControlList());
        volume.getAccessControlList().getAccessControlList().addAll(Arrays.asList(fromVolume.getAccessControlList().split(",")));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() != null) {
        volume.setState(fromVolume.getStatus().name().toLowerCase());
    }
    if (fromVolume.getOptions() != null) {
        Options glusterOptions = new Options();
        List<Option> options = glusterOptions.getOptions();
        for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
            options.add(mapOption(option));
        }
        volume.setOptions(glusterOptions);
    }
    return volume;
}
#method_after
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    if (fromVolume.getId() != null) {
        volume.setId(fromVolume.getId().toString());
    }
    if (fromVolume.getName() != null) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.getVolumeType() != null) {
        volume.setVolumeType(map(fromVolume.getVolumeType(), null));
    }
    if (fromVolume.getTransportTypes() != null) {
        ArrayList<String> transportTypeList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType : fromVolume.getTransportTypes()) {
            transportTypeList.add(map(transportType, null));
        }
        volume.setTransportTypes(new TransportTypes());
        volume.getTransportTypes().getTransportTypes().addAll(transportTypeList);
    }
    if (fromVolume.getAccessProtocols() != null) {
        ArrayList<String> accessProtocolList = new ArrayList<String>();
        for (org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol : fromVolume.getAccessProtocols()) {
            accessProtocolList.add(map(accessProtocol, null));
        }
        volume.setAccessProtocols(new AccessProtocols());
        volume.getAccessProtocols().getAccessProtocols().addAll(accessProtocolList);
    }
    if (fromVolume.getAccessControlList() != null) {
        volume.setAccessControlList(new AccessControlList());
        volume.getAccessControlList().getAccessControlList().addAll(Arrays.asList(fromVolume.getAccessControlList().split(",")));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() != null) {
        volume.setStatus(StatusUtils.create(map(fromVolume.getStatus(), null)));
    }
    if (fromVolume.getOptions() != null) {
        Options glusterOptions = new Options();
        List<Option> options = glusterOptions.getOptions();
        for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
            options.add(mapOption(option));
        }
        volume.setOptions(glusterOptions);
    }
    return volume;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType glusterVolumeType, String template) {
    switch(glusterVolumeType) {
        case DISTRIBUTE:
            return GlusterVolumeType.DISTRIBUTE.name();
        case REPLICATE:
            return GlusterVolumeType.REPLICATE.name();
        case DISTRIBUTED_REPLICATE:
            return GlusterVolumeType.DISTRIBUTED_REPLICATE.name();
        case STRIPE:
            return GlusterVolumeType.STRIPE.name();
        case DISTRIBUTED_STRIPE:
            return GlusterVolumeType.DISTRIBUTED_STRIPE.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.GlusterVolumeType glusterVolumeType, String template) {
    switch(glusterVolumeType) {
        case DISTRIBUTE:
            return GlusterVolumeType.DISTRIBUTE.value();
        case REPLICATE:
            return GlusterVolumeType.REPLICATE.value();
        case DISTRIBUTED_REPLICATE:
            return GlusterVolumeType.DISTRIBUTED_REPLICATE.value();
        case STRIPE:
            return GlusterVolumeType.STRIPE.value();
        case DISTRIBUTED_STRIPE:
            return GlusterVolumeType.DISTRIBUTED_STRIPE.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.TransportType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType, String template) {
    switch(transportType) {
        case TCP:
            return TransportType.TCP.name();
        case RDMA:
            return TransportType.RDMA.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.TransportType.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.TransportType transportType, String template) {
    switch(transportType) {
        case TCP:
            return TransportType.TCP.value();
        case RDMA:
            return TransportType.RDMA.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.name();
        case NFS:
            return AccessProtocol.NFS.name();
        case CIFS:
            return AccessProtocol.CIFS.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.value();
        case NFS:
            return AccessProtocol.NFS.value();
        case CIFS:
            return AccessProtocol.CIFS.value();
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.name();
        case NFS:
            return AccessProtocol.NFS.name();
        case CIFS:
            return AccessProtocol.CIFS.name();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus.class, to = GlusterState.class)
public static GlusterState map(org.ovirt.engine.core.common.businessentities.gluster.GlusterStatus glusterVolumeStatus, String template) {
    switch(glusterVolumeStatus) {
        case UP:
            return GlusterState.UP;
        case DOWN:
            return GlusterState.DOWN;
        default:
            return null;
    }
}
#end_block

#method_before
@Test
public void testFromBackendToRest() {
    testStatusMapping(GlusterVolumeStatus.UP, GlusterState.UP);
    testStatusMapping(GlusterVolumeStatus.DOWN, GlusterState.DOWN);
}
#method_after
@Test
public void testFromBackendToRest() {
    testStatusMapping(GlusterStatus.UP, GlusterState.UP);
    testStatusMapping(GlusterStatus.DOWN, GlusterState.DOWN);
}
#end_block

#method_before
private void testStatusMapping(GlusterVolumeStatus backendStatus, GlusterState restStatus) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setStatus(backendStatus);
    GlusterVolume restVolume = GlusterVolumeMapper.map(volume, null);
    assertEquals(restVolume.getState(), restStatus.value());
}
#method_after
private void testStatusMapping(GlusterStatus backendStatus, GlusterState restStatus) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setStatus(backendStatus);
    GlusterVolume restVolume = GlusterVolumeMapper.map(volume, null);
    assertEquals(restVolume.getStatus().getState(), restStatus.value());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void removeImageFromDB() {
    final DiskImage diskImage = getDiskImage();
    updateSnapshotConfigWithoutImage(diskImage.getId());
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getDiskImageDynamicDAO().remove(diskImage.getImageId());
            Guid imageTemplate = diskImage.getit_guid();
            Guid currentGuid = diskImage.getImageId();
            // the storage).
            while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                RemoveChildren(currentGuid);
                DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                if (image != null) {
                    RemoveSnapshot(image);
                    currentGuid = image.getParentId();
                } else {
                    currentGuid = Guid.Empty;
                    log.warnFormat("'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                }
            }
            getBaseDiskDao().remove(diskImage.getId());
            getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
            return null;
        }
    });
}
#method_after
private void removeImageFromDB(boolean isLockOnSnapshotsNeeded) {
    final DiskImage diskImage = getDiskImage();
    final List<Snapshot> updatedSnapshots;
    final boolean shouldPerformOpOnVmSnapshots = isLockOnSnapshotsNeeded && !diskImage.isShareable();
    try {
        if (shouldPerformOpOnVmSnapshots) {
            VM vm = getVmForNonShareableDiskImage(diskImage);
            lockVmSnapshotsWithWait(vm);
            updatedSnapshots = prepareSnapshotConfigWithoutImage(diskImage.getId());
        } else {
            updatedSnapshots = Collections.emptyList();
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getDiskImageDynamicDAO().remove(diskImage.getImageId());
                Guid imageTemplate = diskImage.getit_guid();
                Guid currentGuid = diskImage.getImageId();
                // the storage).
                while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                    RemoveChildren(currentGuid);
                    DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                    if (image != null) {
                        RemoveSnapshot(image);
                        currentGuid = image.getParentId();
                    } else {
                        currentGuid = Guid.Empty;
                        log.warnFormat("'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                    }
                }
                getBaseDiskDao().remove(diskImage.getId());
                getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
                for (Snapshot s : updatedSnapshots) {
                    getSnapshotDao().update(s);
                }
                return null;
            }
        });
    } finally {
        if (snapshotsEngineLock != null) {
            getLockManager().releaseLock(snapshotsEngineLock);
        }
    }
}
#end_block

#method_before
private void endCommand() {
    if (getParameters().getRemoveFromDB()) {
        removeImageFromDB();
    } else {
        getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(getParameters().getImageId(), getParameters().getStorageDomainId()));
        UnLockImage();
    }
    setSucceeded(true);
}
#method_after
private void endCommand() {
    if (getParameters().getRemoveFromDB()) {
        removeImageFromDB(true);
    } else {
        getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(getParameters().getImageId(), getParameters().getStorageDomainId()));
        UnLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
        throw new RuntimeException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
        throw new DirectoryServiceException(e);
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    int timeLimit = Config.<Integer>GetValue(ConfigValues.LDAPQueryTimeout) * 1000;
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(timeLimit));
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(timeLimit);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    LdapBrokerUtils.addLdapConfigValues(env);
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        searchControls.setTimeLimit(Config.<Integer>GetValue(ConfigValues.LDAPOperationTimeout) * 1000);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (ImagesHandler.isVmInPreview(getVmId())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        if (canPerformQuotaValidation()) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#end_block

#method_before
private String getPrintableConnectionsList() {
    StringBuilder sb = new StringBuilder();
    for (storage_server_connections con : getConnectionList()) {
        sb.append("{ id: ");
        sb.append(con.getid());
        sb.append(", connection: ");
        sb.append(con.getconnection());
        sb.append(", iqn: ");
        sb.append(con.getiqn());
        sb.append(", vfsType: ");
        sb.append(con.getVfsType());
        sb.append(", mountOptions: ");
        sb.append(con.getMountOptions());
        sb.append(", nfsVersion: ");
        sb.append(con.getNfsVersion());
        sb.append(", nfsRetrans: ");
        sb.append(con.getNfsRetrans());
        sb.append(", nfsTimeo: ");
        sb.append(con.getNfsTimeo());
        sb.append(" };");
    }
    return sb.toString();
}
#method_after
private String getPrintableConnectionsList() {
    StringBuilder sb = new StringBuilder();
    for (storage_server_connections con : getConnectionList()) {
        sb.append(con);
    }
    return sb.toString();
}
#end_block

#method_before
private VolumeType getVolumeType() {
    return (getStoragePool().getstorage_pool_type() == StorageType.NFS || getStoragePool().getstorage_pool_type() == StorageType.LOCALFS) ? VolumeType.Sparse : VolumeType.Preallocated;
}
#method_after
private VolumeType getVolumeType() {
    return (getStoragePool().getstorage_pool_type().isFileDomain()) ? VolumeType.Sparse : VolumeType.Preallocated;
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VM vm = DbFacade.getInstance().getVmDAO().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // update number of monitors
            updateNumOfMonitorsInVmDevice(null, vmBase);
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
            // skip other Blank template devices
            break;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        } else if (VmDeviceType.BALLOON.getName().equals(device.getType())) {
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VM vm = DbFacade.getInstance().getVmDAO().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            if (isVm) {
                // to the new VMStatic params
                continue;
            } else {
                specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
            }
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        } else if (VmDeviceType.BALLOON.getName().equals(device.getType())) {
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
        int numOfMonitors = (vm.getdisplay_type() == DisplayType.vnc) ? Math.max(1, vm.getnum_of_monitors()) : vm.getnum_of_monitors();
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vm);
        }
    }
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, getDeviceDisplayType(newStatic.getdefault_display_type()), getMemExpr(newStatic.getnum_of_monitors()), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        removeNumberOfDevices(list, prevNumOfMonitors - newStatic.getnum_of_monitors());
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmBase oldVmBase, VmBase newStatic) {
    int prevNumOfMonitors = 0;
    if (oldVmBase != null) {
        prevNumOfMonitors = oldVmBase.getnum_of_monitors();
    }
    if (newStatic.getnum_of_monitors() > prevNumOfMonitors) {
        // monitors were added
        for (int i = prevNumOfMonitors; i < newStatic.getnum_of_monitors(); i++) {
            Guid newId = Guid.NewGuid();
            VmDeviceUtils.addManagedDevice(new VmDeviceId(newId, newStatic.getId()), VmDeviceType.VIDEO, VmDeviceType.QXL, getMemExpr(newStatic.getnum_of_monitors()), true, false);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.VIDEO.getName());
        removeNumberOfDevices(list, prevNumOfMonitors - newStatic.getnum_of_monitors());
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    lockVmWithCompensationIfNeeded();
    if (!isInternalExecution()) {
        freeLock();
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    VdcReturnValueBase returnValue = null;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
        }
    }
    if (getImagesList().size() > 0) {
        // change its status from Image lock.
        if (getTaskIdList().size() == 0) {
            log.errorFormat("Can't restore snapshot for VM, since no destroyImage task could be established in the VDSM.");
            if (returnValue != null) {
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
        } else {
            setSucceeded(true);
        }
        deleteOrphanedImages();
        removeSnapshotsFromDB();
    } else {
        removeSnapshotsFromDB();
        EndVmCommand();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        endActionOnVmConfiguration();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getimage_group_id())) {
            deletedDisksIds.add(image.getimage_group_id());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#method_after
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#end_block

#method_before
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDAO().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDAO().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (snapshotToRemove != null && !snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDAO().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#method_after
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDAO().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDAO().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (!snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDAO().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!VmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        macAdded = vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        macAdded = vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
protected void AddVmInterfaces() {
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (VmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(StringUtils.EMPTY);
        }
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDAO().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void AddVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(StringUtils.EMPTY);
        }
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDAO().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDAO().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
protected AuditLogType getAuditLogTypeForInvalidInterfaces() {
    // Functionality must be implemented in subclasses
    throw new NotImplementedException();
}
#method_after
protected AuditLogType getAuditLogTypeForInvalidInterfaces() {
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
@NotTransactional
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        dataSource = createDataSource();
        Connection con = dataSource.getConnection();
        con.setAutoCommit(false);
        dataset = initDataSet();
        dbFacade = new DbFacade();
        dbFacade.setDbEngineDialect(DbFacadeLocator.loadDbEngineDialect());
        dbFacade.setTemplate(dbFacade.getDbEngineDialect().createJdbcTemplate(dataSource));
        // load data from fixtures to DB
        DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
        con.commit();
    }
}
#method_after
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        dataSource = createDataSource();
        dataset = initDataSet();
        dbFacade = new DbFacade();
        dbFacade.setDbEngineDialect(DbFacadeLocator.loadDbEngineDialect());
        dbFacade.setTemplate(dbFacade.getDbEngineDialect().createJdbcTemplate(dataSource));
        // load data from fixtures to DB
        DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
    }
}
#end_block

#method_before
public static String getEngineSSHKeyFingerprint() {
    String fingerprint = null;
    String keystoreFile = Config.<String>GetValue(ConfigValues.keystoreUrl);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias);
    InputStream in = null;
    try {
        in = new FileInputStream(keystoreFile);
        KeyStore ks = KeyStore.getInstance("JKS");
        ks.load(in, Config.<String>GetValue(ConfigValues.keystorePass).toCharArray());
        Certificate cert = ks.getCertificate(alias);
        if (cert == null) {
            throw new KeyStoreException(String.format("Failed to find certificate store '%1$s' using alias '%2%s'", keystoreFile, alias));
        }
        fingerprint = OpenSSHUtils.getKeyString(cert.getPublicKey(), "ovirt-engine");
    } catch (Exception e) {
        log.error(String.format("Failed to send own public key from store '%1$s' using alias '%2%s'", keystoreFile, alias), e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    return fingerprint;
}
#method_after
static public String getEngineSSHKeyFingerprint() {
    String fingerprint = null;
    InputStream in = null;
    try {
        in = new FileInputStream(Config.<String>GetValue(ConfigValues.keystoreUrl));
        KeyStore ks = KeyStore.getInstance("JKS");
        ks.load(in, Config.<String>GetValue(ConfigValues.keystorePass).toCharArray());
        fingerprint = OpenSSHUtils.getKeyString(ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey(), "ovirt-engine");
    } catch (Exception e) {
        log.error("Failed to send own public key from store", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    return fingerprint;
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (doFinal && !_rebootAfterInstallation) {
        command = command.replace(" -b ", " ");
    }
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = s_bootstrapPackage.getStream();
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    Boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (doFinal && !_rebootAfterInstallation) {
        command = command.replace(" -b ", " ");
    }
    String bootstrap = Config.<String>GetValue(ConfigValues.BootstrapInstallerFileName);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, bootstrap, getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(bootstrap);
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat(" RunScript ended:" + fRes.toString());
    return fRes;
}
#end_block

#method_before
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String thumbprint = VdsInstallerSSH.getEngineSSHKeyFingerprint();
                if (thumbprint == null) {
                    _executionSucceded = false;
                } else {
                    _executionSucceded = uploadStringAsFile(thumbprint, _remoteSSHKey);
                }
                if (_executionSucceded && isOverrideFirewallAllowed()) {
                    String ipTablesConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
                    if (StringUtils.isNotEmpty(ipTablesConfig)) {
                        _executionSucceded = uploadStringAsFile(ipTablesConfig, remoteFwRulesFilePath);
                    }
                }
                if (_executionSucceded) {
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                }
                break;
            }
        case RunScript:
            {
                runBootstrapCommand(false);
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                runBootstrapCommand(true);
                break;
            }
    }
}
#method_after
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String thumbprint = VdsInstallerSSH.getEngineSSHKeyFingerprint();
                if (thumbprint == null) {
                    _executionSucceded = false;
                } else {
                    _executionSucceded = uploadStringAsFile(thumbprint, _remoteSSHKey);
                }
                if (_executionSucceded && isOverrideFirewallAllowed()) {
                    String ipTableConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
                    if (StringUtils.isNotEmpty(ipTableConfig)) {
                        _executionSucceded = uploadStringAsFile(ipTableConfig, remoteFwRulesFilePath);
                    }
                }
                if (_executionSucceded) {
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                }
                break;
            }
        case RunScript:
            {
                runBootstrapCommand(false);
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                runBootstrapCommand(true);
                break;
            }
    }
}
#end_block

#method_before
@Override
public void endTransfer() {
    if (// iso upload
    _currentInstallStage == VdsInstallStages.UploadScript || _currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#method_after
@Override
public void endTransfer() {
    if (_currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#end_block

#method_before
@Test
public void testCommandOKTar() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    InputStream is = null;
    try {
        is = new FileInputStream("src/test/resources/tarball.tar");
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertTrue(vssh.executeCommand(String.format(("rm -fr /tmp/vssh-%1$d && " + "mkdir /tmp/vssh-%1$d && " + "tar -C /tmp/vssh-%1$d -x && " + "/tmp/vssh-%1$d/script; " + "rm -fr /tmp/vssh-%1$d"), Thread.currentThread().getId()), is));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertEquals("ok\n", callbacks.message);
        assertNull(callbacks.error);
        assertNull(callbacks.fail);
    } finally {
        if (is != null) {
            try {
                is.close();
            } catch (Exception e) {
            // ignore we want test exception
            }
        }
        vssh.shutdown();
        vssh = null;
    }
}
#method_after
@Test
public void testCommandOKTar() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    try {
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertTrue(vssh.executeCommand(String.format(("rm -fr /tmp/vssh-%1$d && " + "mkdir /tmp/vssh-%1$d && " + "tar -C /tmp/vssh-%1$d -x && " + "/tmp/vssh-%1$d/script; " + "rm -fr /tmp/vssh-%1$d"), Thread.currentThread().getId()), new FileInputStream("src/test/resources/tarball.tar")));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertEquals("ok\n", callbacks.message);
        assertNull(callbacks.error);
        assertNull(callbacks.fail);
    } finally {
        vssh.shutdown();
        vssh = null;
    }
}
#end_block

#method_before
private AuditLogableBase getLoggableQuotaStorageParams(String quotaName, double storageUsagePercentage, double storageRequestedPercentage) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.getUserName();
    logable.AddCustomValue("QuotaName", quotaName);
    logable.AddCustomValue("CurrentStorage", String.valueOf((int) storageUsagePercentage));
    logable.AddCustomValue("Requested", String.valueOf((int) storageRequestedPercentage));
    return logable;
}
#method_after
private AuditLogableBase getLoggableQuotaStorageParams(String quotaName, double storageUsagePercentage, double storageRequestedPercentage) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("QuotaName", quotaName);
    logable.AddCustomValue("CurrentStorage", percentageFormatter.format(storageUsagePercentage));
    logable.AddCustomValue("Requested", percentageFormatter.format(storageRequestedPercentage));
    return logable;
}
#end_block

#method_before
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, ArrayList<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    if (memLimit == UNLIMITED && cpuLimit == UNLIMITED) {
        // if both cpu and mem are unlimited
        // cache
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
        return true;
    } else if (// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) {
        // cache
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
        return true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        log.setSecond(getLoggableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage()));
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the grace)
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        log.setSecond(getLoggableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100));
    } else {
        // passed the grace
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        log.setSecond(getLoggableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100));
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(quotaEnforcementTypeEnum)) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            return false;
        }
    }
    // cache
    cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    return true;
}
#method_after
private boolean checkQuotaClusterLimits(QuotaEnforcementTypeEnum quotaEnforcementTypeEnum, Quota quota, QuotaVdsGroup quotaVdsGroup, long memToAdd, int vcpuToAdd, ArrayList<String> canDoActionMessages, Pair<AuditLogType, AuditLogableBase> log) {
    if (quotaVdsGroup.getVirtualCpu() == 0 || quotaVdsGroup.getMemSizeMB() == 0) {
        return false;
    }
    double vcpuToAddPercentage = (double) vcpuToAdd / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double vcpuCurrentPercentage = (double) quotaVdsGroup.getVirtualCpuUsage() / (double) quotaVdsGroup.getVirtualCpu() * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memToAdd / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double memCurrentPercentage = (double) quotaVdsGroup.getMemSizeMBUsage() / (double) quotaVdsGroup.getMemSizeMB() * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    long newMemory = memToAdd + quotaVdsGroup.getMemSizeMBUsage();
    int newVcpu = vcpuToAdd + quotaVdsGroup.getVirtualCpuUsage();
    long memLimit = quotaVdsGroup.getMemSizeMB();
    int cpuLimit = quotaVdsGroup.getVirtualCpu();
    if (memLimit == UNLIMITED && cpuLimit == UNLIMITED) {
        // if both cpu and mem are unlimited
        // cache
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
        return true;
    } else if (// if cpu and mem usages are under the limit
    newVcpuPercent <= quota.getThresholdVdsGroupPercentage() && newMemoryPercent <= quota.getThresholdVdsGroupPercentage()) {
        // cache
        cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
        return true;
    } else if (newVcpuPercent <= 100 && newMemoryPercent <= 100) {
        // passed the threshold (not the quota limit)
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD);
        log.setSecond(getLogableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > quota.getThresholdVdsGroupPercentage(), newMemoryPercent > quota.getThresholdVdsGroupPercentage()));
    } else if (newVcpuPercent <= quota.getGraceVdsGroupPercentage() + 100 && newMemoryPercent <= quota.getGraceVdsGroupPercentage() + 100) {
        // passed the quota limit (not the
        // grace)
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT);
        log.setSecond(getLogableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100));
    } else {
        // passed the grace
        log.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT);
        log.setSecond(getLogableQuotaVdsGroupParams(quota.getQuotaName(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > quota.getGraceVdsGroupPercentage() + 100, newMemoryPercent > quota.getGraceVdsGroupPercentage() + 100));
        if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(quotaEnforcementTypeEnum)) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_VDS_GROUP_LIMIT_EXCEEDED.toString());
            return false;
        }
    }
    // cache
    cacheNewValues(quotaVdsGroup, newMemory, newVcpu);
    return true;
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        VmTemplate template = getVmTemplateDAO().get(getVmTemplateId());
        if (template != null && !getQuotaId().equals(template.getQuotaId())) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        VmTemplate template = getVmTemplate();
        if (template != null && !getQuotaId().equals(template.getQuotaId())) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#end_block

#method_before
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        VM vm = getVmDAO().get(getVmId());
        if (vm != null && !getQuotaId().equals(vm.getQuotaId())) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#method_after
@Override
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (getStoragePool() != null && getQuotaId() != null && !getStoragePool().getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        VM vm = getVm();
        if (vm != null && !getQuotaId().equals(vm.getQuotaId())) {
            quotaPermissionList.add(new PermissionSubject(getQuotaId(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
        }
    }
}
#end_block

#method_before
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if (StringUtils.equals(fieldName, "TYPE")) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    } else {
    }
    return retval;
}
#method_after
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if ("TYPE".equals(fieldName)) {
        retval = new EnumValueAutoCompleter(VmPoolType.class);
    }
    return retval;
}
#end_block

#method_before
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(_getUniqueIdCommand);
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    String ipTableConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
                    if (StringUtils.isNotEmpty(ipTableConfig)) {
                        _executionSucceded = uploadString(ipTableConfig, remoteFwRulesFilePath);
                    }
                    if (_executionSucceded) {
                        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                    }
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#method_after
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    String ipTableConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
                    if (StringUtils.isNotEmpty(ipTableConfig)) {
                        _executionSucceded = uploadStringAsFile(ipTableConfig, remoteFwRulesFilePath);
                    }
                    if (_executionSucceded) {
                        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                    }
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#end_block

#method_before
@Override
public void initTable(final CommonApplicationConstants constants) {
    // $NON-NLS-1$
    getTable().addColumn(new NicActivateStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VmNetworkInterface> nameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    getTable().addColumn(nameColumn, constants.nameInterface());
    TextColumnWithTooltip<VmNetworkInterface> networkNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    getTable().addColumn(networkNameColumn, constants.networkNameInterface());
    TextColumnWithTooltip<VmNetworkInterface> typeColumn = new EnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    getTable().addColumn(typeColumn, constants.typeInterface());
    TextColumnWithTooltip<VmNetworkInterface> macColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    getTable().addColumn(macColumn, constants.macInterface());
    TextColumnWithTooltip<VmNetworkInterface> speedColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> rxColumn = new RxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(rxColumn, templates.sub(constants.rxInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> txColumn = new RxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(txColumn, templates.sub(constants.txInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> dropsColumn = new SumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            return new Double[] { object.getStatistics().getReceiveDropRate(), object.getStatistics().getTransmitDropRate() };
        }
    };
    getTable().addColumnWithHtmlHeader(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()).asString());
    TextColumnWithTooltip<VmNetworkInterface> portMirroringColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.isPortMirroring()) {
                return constants.portMirroringEnabled();
            } else {
                return "";
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(portMirroringColumn, constants.portMirroring(), "60px");
}
#method_after
@Override
public void initTable(final CommonApplicationConstants constants) {
    // $NON-NLS-1$
    getTable().addColumn(new NicActivateStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VmNetworkInterface> nameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    getTable().addColumn(nameColumn, constants.nameInterface());
    TextColumnWithTooltip<VmNetworkInterface> networkNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    getTable().addColumn(networkNameColumn, constants.networkNameInterface());
    TextColumnWithTooltip<VmNetworkInterface> typeColumn = new EnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    getTable().addColumn(typeColumn, constants.typeInterface());
    TextColumnWithTooltip<VmNetworkInterface> macColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    getTable().addColumn(macColumn, constants.macInterface());
    TextColumnWithTooltip<VmNetworkInterface> speedColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> rxColumn = new RxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getReceiveRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(rxColumn, templates.sub(constants.rxInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> txColumn = new RxTxRateColumn<VmNetworkInterface>() {

        @Override
        protected Double getRate(VmNetworkInterface object) {
            return object.getStatistics().getTransmitRate();
        }

        @Override
        protected Double getSpeed(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().doubleValue();
            } else {
                return null;
            }
        }
    };
    getTable().addColumnWithHtmlHeader(txColumn, templates.sub(constants.txInterface(), constants.mbps()).asString());
    TextColumnWithTooltip<VmNetworkInterface> dropsColumn = new SumUpColumn<VmNetworkInterface>() {

        @Override
        protected Double[] getRawValue(VmNetworkInterface object) {
            return new Double[] { object.getStatistics().getReceiveDropRate(), object.getStatistics().getTransmitDropRate() };
        }
    };
    getTable().addColumnWithHtmlHeader(dropsColumn, templates.sub(constants.dropsInterface(), constants.pkts()).asString());
}
#end_block

#method_before
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, "Verify that postgresql service is up and check DB configurations", e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, "Verify that postgresql service is up and check DB configurations", e.getMessage());
    }
}
#method_after
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl();
    } catch (SQLException e) {
        throw new ManageDomainsResult("Please verify the following:\n1. Your database credentials are valid.\n2. The database machine is accessible.\n3. The database service is running", ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#end_block

#method_before
private void createConfigurationProvider(String engineConfigProperties) throws ManageDomainsResult {
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, "Verify that postgresql service is up and check DB configurations", e.getMessage());
    }
}
#method_after
private void createConfigurationProvider(String engineConfigProperties) throws ManageDomainsResult {
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, "Invalid action, verify DB connection", action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), REMOTE_LOCATION, getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, "Invalid action, verify DB connection", action);
    }
}
#method_after
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), REMOTE_LOCATION, getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#end_block

#method_before
protected LdapProviderType getLdapProviderType(CLIParser parser) throws ManageDomainsResult {
    try {
        return LdapProviderType.valueOfIgnoreCase(parser.getArg(Arguments.provider.name()));
    } catch (IllegalArgumentException i) {
    // continue and print message
    } catch (NullPointerException e) {
    // continue and print message
    }
    StringBuffer sb = new StringBuffer();
    sb.append(parser.getArg(Arguments.provider.name()) + ". Supported provider types are:\n");
    for (LdapProviderType t : LdapProviderType.values()) {
        sb.append(" " + t.name() + "\n");
    }
    throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Check Db Connection, getLdapProviderType received empty parameter", sb.toString());
}
#method_after
protected LdapProviderType getLdapProviderType(CLIParser parser) throws ManageDomainsResult {
    try {
        return LdapProviderType.valueOfIgnoreCase(parser.getArg(Arguments.provider.name()));
    } catch (IllegalArgumentException i) {
    // continue and print message
    } catch (NullPointerException e) {
    // continue and print message
    }
    StringBuffer sb = new StringBuffer();
    sb.append(parser.getArg(Arguments.provider.name()) + ". Supported provider types are:\n");
    for (LdapProviderType t : LdapProviderType.values()) {
        sb.append(" " + t.name() + "\n");
    }
    throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, sb.toString());
}
#end_block

#method_before
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, "Check DB connection. Error during reading password file", e.getMessage());
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
public void addDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, "Error during verified domain name. Empty name or DB connection error", domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#method_after
public void addDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#end_block

#method_before
private ManageDomainsResult updatePermissionsTable(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            String guid = adUseridEntry.getValueForDomain(currDomain);
            daoImpl.updatePermissionsTable(guid, currUser, currDomain);
        }
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, "Check connection to DB, failed during applying changes", e.getMessage());
    }
}
#method_after
private ManageDomainsResult updatePermissionsTable(DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adUseridEntry) {
    try {
        Set<Entry<String, String>> userNameValues = adUserNameEntry.getValues();
        for (Entry<String, String> currUserEntry : userNameValues) {
            String currDomain = currUserEntry.getKey();
            String currUser = currUserEntry.getValue();
            String guid = adUseridEntry.getValueForDomain(currDomain);
            daoImpl.updatePermissionsTable(guid, currUser, currDomain);
        }
        return OK_RESULT;
    } catch (SQLException e) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_CHANGES_IN_DATABASE, e.getMessage());
    }
}
#end_block

#method_before
public void editDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, "Error during verified domain name. Empty name or DB connection error", domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#method_after
public void editDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#end_block

#method_before
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            krbConfCreator = new KrbConfCreator(gssapiDomainsString);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, "Check network Connection to DB, failed during configure kerberos.", ex.getMessage());
            throw result;
        }
    }
}
#method_after
private void createKerberosConfiguration(DomainsConfigurationEntry gssapiDomains) throws ManageDomainsResult {
    if (!gssapiDomains.isEntryEmpty()) {
        String gssapiDomainsString = gssapiDomains.getDomainsConfigurationEntry();
        KrbConfCreator krbConfCreator;
        try {
            log.info("Creating kerberos configuration for domain(s): " + gssapiDomainsString);
            krbConfCreator = new KrbConfCreator(gssapiDomainsString);
            StringBuffer buffer = null;
            buffer = krbConfCreator.parse("y");
            krbConfCreator.toFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, buffer);
            log.info("Successfully created kerberos configuration for domain(s): " + gssapiDomainsString);
        } catch (Exception ex) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_CREATING_KERBEROS_CONFIGURATION, ex.getMessage());
            throw result;
        }
    }
}
#end_block

#method_before
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, String kerberosConfigFile, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck();
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, "Check DB Connection, failed during testing domain", new String[] { domain, e.getMessage() });
            if ((isValidate && reportAllErrors) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#method_after
private void checkKerberosConfiguration(String domainName, DomainsConfigurationEntry users, DomainsConfigurationEntry passwords, DomainsConfigurationEntry gssapiDomains, DomainsConfigurationEntry userIds, DomainsConfigurationEntry ldapProviderTypes, String kerberosConfigFile, boolean isValidate) throws ManageDomainsResult {
    Set<Entry<String, String>> gssapiDomainValues = gssapiDomains.getValues();
    for (Entry<String, String> currDomain : gssapiDomainValues) {
        String domain = currDomain.getKey();
        String currUserName = users.getValueForDomain(domain);
        users.setValueForDomain(domain, constructUPN(currUserName, domain));
        try {
            log.info("Testing kerberos configuration for domain: " + domain);
            KerberosConfigCheck kerberosConfigCheck = new KerberosConfigCheck();
            StringBuffer userGuid = new StringBuffer();
            kerberosConfigCheck.checkInstallation(domain, users.getValueForDomain(domain), passwords.getValueForDomain(domain), utilityConfiguration.getJaasFilePath(), kerberosConfigFile, userGuid, LdapProviderType.valueOf(ldapProviderTypes.getValueForDomain(domain)));
            userIds.setValueForDomain(domain, userGuid.toString());
            if (isValidate) {
                System.out.println("Domain " + domain + " is valid.");
            }
            log.info("Successfully tested kerberos configuration for domain: " + domain);
        } catch (Exception e) {
            ManageDomainsResult result = new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, e.getMessage() });
            if ((isValidate && reportAllErrors) || ((domainName != null) && !domain.equals(domainName))) {
                System.out.println("WARNING, domain: " + domain + " may not be functional: " + result.getDetailedMessage());
            } else {
                throw result;
            }
        }
    }
}
#end_block

#method_before
private void applyKerberosConfiguration() throws ManageDomainsResult {
    try {
        // We backup the kerberos configuration file in case it already exists
        if (FileUtil.fileExists(utilityConfiguration.getkrb5confFilePath())) {
            SimpleDateFormat ft = new SimpleDateFormat("yyyyMMddhhmmsszzz");
            String destFileName = utilityConfiguration.getkrb5confFilePath() + ".backup_" + ft.format(new Date());
            log.info("Performing backup of kerberos configuration file to " + destFileName);
            FileUtil.copyFile(utilityConfiguration.getkrb5confFilePath(), destFileName);
        }
        log.info("Applying kerberos configuration");
        FileUtil.copyFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, utilityConfiguration.getkrb5confFilePath());
        FileUtil.deleteFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX);
    } catch (IOException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_KERBEROS_CONFIGURATION, "Check Connection to DB, kerberos configuration couldn't been saved", e.getMessage());
    }
}
#method_after
private void applyKerberosConfiguration() throws ManageDomainsResult {
    try {
        // We backup the kerberos configuration file in case it already exists
        if (FileUtil.fileExists(utilityConfiguration.getkrb5confFilePath())) {
            SimpleDateFormat ft = new SimpleDateFormat("yyyyMMddhhmmsszzz");
            String destFileName = utilityConfiguration.getkrb5confFilePath() + ".backup_" + ft.format(new Date());
            log.info("Performing backup of kerberos configuration file to " + destFileName);
            FileUtil.copyFile(utilityConfiguration.getkrb5confFilePath(), destFileName);
        }
        log.info("Applying kerberos configuration");
        FileUtil.copyFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX, utilityConfiguration.getkrb5confFilePath());
        FileUtil.deleteFile(utilityConfiguration.getkrb5confFilePath() + TESTING_KRB5_CONF_SUFFIX);
    } catch (IOException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_APPLYING_KERBEROS_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private ManageDomainsResult checkSimple(String domain, String userName, String password, String address, StringBuffer userGuid, LdapProviderType ldapProviderType) {
    log.info("Testing domain " + domain);
    SimpleAuthenticationCheck simpleAuthenticationCheck = new SimpleAuthenticationCheck();
    ReturnStatus returnStatus = simpleAuthenticationCheck.printUserGuid(domain, userName, password, address, userGuid, ldapProviderType);
    if (!returnStatus.equals(ReturnStatus.OK)) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, "Checking domain configuration failed, check network connection.", new String[] { domain, returnStatus.getDetailedMessage() });
    }
    log.info("Successfully tested domain " + domain);
    return OK_RESULT;
}
#method_after
private ManageDomainsResult checkSimple(String domain, String userName, String password, String address, StringBuffer userGuid, LdapProviderType ldapProviderType) {
    log.info("Testing domain " + domain);
    SimpleAuthenticationCheck simpleAuthenticationCheck = new SimpleAuthenticationCheck();
    ReturnStatus returnStatus = simpleAuthenticationCheck.printUserGuid(domain, userName, password, address, userGuid, ldapProviderType);
    if (!returnStatus.equals(ReturnStatus.OK)) {
        return new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_WHILE_TESTING_DOMAIN, new String[] { domain, returnStatus.getDetailedMessage() });
    }
    log.info("Successfully tested domain " + domain);
    return OK_RESULT;
}
#end_block

#method_before
public void deleteDomain(String domainName) throws ManageDomainsResult {
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, "Error during verified domain name. Empty name or DB connection error", domainName);
    }
    domainNameEntry.removeValueForDomain(domainName);
    if (domainNameEntry.isEntryEmpty()) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#method_after
public void deleteDomain(String domainName) throws ManageDomainsResult {
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.removeValueForDomain(domainName);
    if (domainNameEntry.isEntryEmpty()) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#end_block

#method_before
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, "Invalid DB action, check DB connection", action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#method_after
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#end_block

#method_before
private void requireArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (!parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, "Missing argument for command", arg.name());
        }
    }
}
#method_after
private void requireArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (!parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, arg.name());
        }
    }
}
#end_block

#method_before
private void requireAtLeastOneArg(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            return;
        }
    }
    throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, "Missing argument for command", Arrays.deepToString(args));
}
#method_after
private void requireAtLeastOneArg(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            return;
        }
    }
    throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, Arrays.deepToString(args));
}
#end_block

#method_before
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Empty argument pass. Verify command", arg.name());
        }
    }
}
#method_after
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arg.name());
        }
    }
}
#end_block

#method_before
public void setConfigValue(ConfigValues enumValue, DomainsConfigurationEntry entry, boolean passedAsValue) throws ManageDomainsResult {
    log.info("Setting value for " + enumValue.toString() + " to " + entry.getDomainsLoggingEntry());
    File passFile = null;
    try {
        passFile = createPassFile(entry.getDomainsConfigurationEntry());
        Process engineConfigProcess = Runtime.getRuntime().exec(engineConfigExecutable + " -s " + enumValue.name() + ((passedAsValue) ? "=" + entry.getDomainsConfigurationEntry() : " --admin-pass-file " + passFile.getAbsolutePath()) + " -p " + engineConfigProperties);
        int retVal = engineConfigProcess.waitFor();
        if (retVal != 0) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_SETTING_CONFIGURATION_VALUE_FOR_OPTION, "Verify Connection to Db, Check if DB service is running", enumValue.name());
        }
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_SETTING_CONFIGURATION_VALUE_FOR_OPTION_WITH_DETAILS, "Verify Connection to Db, Check if DB service is running", new String[] { enumValue.name(), e.getMessage() });
    } finally {
        disposePassFile(passFile);
    }
}
#method_after
public void setConfigValue(ConfigValues enumValue, DomainsConfigurationEntry entry, boolean passedAsValue) throws ManageDomainsResult {
    log.info("Setting value for " + enumValue.toString() + " to " + entry.getDomainsLoggingEntry());
    File passFile = null;
    try {
        passFile = createPassFile(entry.getDomainsConfigurationEntry());
        Process engineConfigProcess = Runtime.getRuntime().exec(engineConfigExecutable + " -s " + enumValue.name() + ((passedAsValue) ? "=" + entry.getDomainsConfigurationEntry() : " --admin-pass-file " + passFile.getAbsolutePath()) + " -p " + engineConfigProperties);
        int retVal = engineConfigProcess.waitFor();
        if (retVal != 0) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_SETTING_CONFIGURATION_VALUE_FOR_OPTION, enumValue.name());
        }
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_SETTING_CONFIGURATION_VALUE_FOR_OPTION_WITH_DETAILS, new String[] { enumValue.name(), e.getMessage() });
    } finally {
        disposePassFile(passFile);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVm() == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    retVal = retVal && targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (retVal && getParameters().getTemplateMustExists()) {
        retVal = CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
        }
    }
    if (retVal) {
        Map<Guid, ? extends Disk> images = getVm().getDiskMap();
        // check that the images requested format are valid (COW+Sparse)
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages());
        if (retVal && getParameters().getCopyCollapse()) {
            for (DiskImage img : getDisksBasedOnImage()) {
                if (images.containsKey(img.getId())) {
                    // mode)
                    if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                        retVal = false;
                    }
                }
            }
        }
    }
    // check destination storage is Export domain
    if (retVal && getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        retVal = false;
    }
    // check destination storage have free space
    if (retVal) {
        int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
        retVal = StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB);
        if (!retVal)
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    retVal = CheckVmInStorageDomain() && retVal && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage());
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
            return false;
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : getDisksBasedOnImage()) {
            if (images.containsKey(img.getId())) {
                // mode)
                if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        return false;
    }
    // check destination storage have free space
    int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
    if (!StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
        return false;
    }
    if (!(CheckVmInStorageDomain() && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    getDisksBasedOnImage();
    // immediately after the execution of the previous steps
    if (disksImages.isEmpty()) {
        endSuccessfullySynchronous();
    } else {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                MoveOrCopyAllImageGroups();
                return null;
            }
        });
        if (!getReturnValue().getTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
    freeLock();
    // immediately after the execution of the previous steps
    if (!hasSnappableDisks()) {
        endSuccessfullySynchronous();
    } else {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                MoveOrCopyAllImageGroups();
                return null;
            }
        });
        if (!getReturnValue().getTaskIdList().isEmpty()) {
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    VM vm = getVm();
    if (vm != null) {
        VmHandler.UnLockVm(vm.getId());
        endDiskRelatedActions(vm);
        if (getParameters().getCopyCollapse()) {
            this.endCopyCollapseOps(vm);
        } else {
            this.endDefaultOps(vm);
        }
        setSucceeded(true);
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ExportVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    EndActionOnAllImageGroups();
    VM vm = getVm();
    VmHandler.UnLockVm(vm);
    endDiskRelatedActions(vm);
    if (getParameters().getCopyCollapse()) {
        endCopyCollapseOperations(vm);
    } else {
        updateSnapshotOvf(vm);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endDiskRelatedActions(VM vm) {
    EndActionOnAllImageGroups();
    VmHandler.updateDisksFromDb(vm);
    VmDeviceUtils.setVmDevices(vm.getStaticData());
}
#method_after
private void endDiskRelatedActions(VM vm) {
    VmHandler.updateDisksFromDb(vm);
    VmDeviceUtils.setVmDevices(vm.getStaticData());
}
#end_block

#method_before
protected void endSuccessfullySynchronous() {
    VM vm = getVm();
    if (vm != null) {
        VmHandler.UnLockVm(vm.getId());
        this.endDefaultOps(vm);
        setSucceeded(true);
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ExportVmCommand::EndSuccessfullySynchronous: Vm is null - not performing full EndAction");
    }
}
#method_after
protected void endSuccessfullySynchronous() {
    VM vm = getVm();
    VmHandler.UnLockVm(vm.getId());
    this.updateSnapshotOvf(vm);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    EndActionOnAllImageGroups();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        VmHandler.updateDisksFromDb(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ExportVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    EndActionOnAllImageGroups();
    VM vm = getVm();
    VmHandler.UnLockVm(vm);
    VmHandler.updateDisksFromDb(vm);
    setSucceeded(true);
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
        String mac = MacPoolManager.getInstance().allocateNewMac();
        iface.setMacAddress(mac);
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#end_block

#method_before
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getVm().getDiskMap() != null) {
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        retVal = VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(vm.getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        VmHandler.updateImportedVmUsbPolicy(vm.getStaticData());
        retVal = VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    addVmToDb();
    VM vm = getVm();
    // vm related ops
    if (vm.getImages().isEmpty()) {
        endVmRelatedOps();
    } else {
        processImages();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    addVmToDb();
    VM vm = getVm();
    // vm related ops
    if (!hasSnappableDisks(vm)) {
        endVmRelatedOps();
    } else {
        processImages();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    int i = 0;
    for (DiskImage disk : disks) {
        Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
        MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
        p.setParentCommand(getActionType());
        p.setUseCopyCollapse(getParameters().getCopyCollapse());
        p.setCopyVolumeType(CopyVolumeType.LeafVol);
        p.setPostZero(disk.isWipeAfterDelete());
        p.setForceOverride(true);
        p.setSourceDomainId(getParameters().getSourceDomainId());
        p.setStoragePoolId(getParameters().getStoragePoolId());
        p.setImportEntity(true);
        p.setEntityId(disk.getImageId());
        if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(diskGuidList.get(i))) {
            DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(diskGuidList.get(i));
            p.setVolumeType(diskImageBase.getvolume_type());
            p.setVolumeFormat(diskImageBase.getvolume_format());
        }
        p.setParentParemeters(getParameters());
        p.setAddImageDomainMapping(getParameters().isImportAsNewEntity());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
        i++;
    }
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    int i = 0;
    for (DiskImage disk : disks) {
        Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
        MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
        p.setParentCommand(getActionType());
        p.setUseCopyCollapse(getParameters().getCopyCollapse());
        p.setCopyVolumeType(CopyVolumeType.LeafVol);
        p.setPostZero(disk.isWipeAfterDelete());
        p.setForceOverride(true);
        p.setSourceDomainId(getParameters().getSourceDomainId());
        p.setStoragePoolId(getParameters().getStoragePoolId());
        p.setImportEntity(true);
        p.setEntityId(disk.getImageId());
        p.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getQuotaId());
        if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(diskGuidList.get(i))) {
            DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(diskGuidList.get(i));
            p.setVolumeType(diskImageBase.getvolume_type());
            p.setVolumeFormat(diskImageBase.getvolume_format());
        }
        p.setParentParemeters(getParameters());
        p.setAddImageDomainMapping(getParameters().isImportAsNewEntity());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
        i++;
    }
}
#end_block

#method_before
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                    list.get(i).setvm_guid(getVmId());
                }
            }
            disk.setvm_guid(getVmId());
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#method_after
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#end_block

#method_before
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        fillMacAddressIfMissing(iface);
        iface.setVmTemplateId(null);
        iface.setVmId(getVmId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext());
    }
}
#method_after
private void addInterfacesFromTemplate() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        fillMacAddressIfMissing(iface);
        iface.setVmTemplateId(null);
        iface.setVmId(getVmId());
        iface.setVmName(getVm().getvm_name());
        macAdded = vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void EndWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#end_block

#method_before
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm().getId());
        UpdateVmImSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        updateVmInSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#end_block

#method_before
private void UpdateSpmPriority(Integer value) {
    List<EntityModel> items = new ArrayList<EntityModel>();
    if (value == null) {
        value = defaultSpmPriority;
    }
    int neverValue = -1;
    // $NON-NLS-1$
    EntityModel neverItem = new EntityModel("Never", neverValue);
    items.add(neverItem);
    int lowValue = defaultSpmPriority / 2;
    // $NON-NLS-1$ //$NON-NLS-2$
    items.add(new EntityModel("Low", lowValue));
    // $NON-NLS-1$ //$NON-NLS-2$
    items.add(new EntityModel("Normal", defaultSpmPriority));
    int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
    // $NON-NLS-1$ //$NON-NLS-2$
    items.add(new EntityModel("High", highValue));
    // Determine whether to set custom SPM priority, and where.
    EntityModel selectedItem = null;
    int[] values = new int[] { neverValue, lowValue, defaultSpmPriority, highValue, maxSpmPriority + 1 };
    Integer prevValue = null;
    for (int i = 0; i < values.length; i++) {
        int currentValue = values[i];
        if (value == currentValue) {
            selectedItem = items.get(i);
            break;
        } else if (prevValue != null && value > prevValue && value < currentValue) {
            // $NON-NLS-1$ //$NON-NLS-2$
            EntityModel customItem = new EntityModel("Custom", value);
            items.add(i, customItem);
            selectedItem = customItem;
            break;
        }
        prevValue = currentValue;
    }
    // Delete 'never' item if it's not selected.
    if (selectedItem != neverItem) {
        items.remove(neverItem);
    }
    getSpmPriority().setItems(items);
    getSpmPriority().setSelectedItem(selectedItem);
}
#method_after
private void UpdateSpmPriority(Integer value) {
    List<EntityModel> items = new ArrayList<EntityModel>();
    if (value == null) {
        value = defaultSpmPriority;
    }
    int neverValue = -1;
    EntityModel neverItem = new EntityModel(constants.neverTitle(), neverValue);
    items.add(neverItem);
    int lowValue = defaultSpmPriority / 2;
    items.add(new EntityModel(constants.lowTitle(), lowValue));
    items.add(new EntityModel(constants.normalTitle(), defaultSpmPriority));
    int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
    items.add(new EntityModel(constants.highTitle(), highValue));
    // Determine whether to set custom SPM priority, and where.
    EntityModel selectedItem = null;
    int[] values = new int[] { neverValue, lowValue, defaultSpmPriority, highValue, maxSpmPriority + 1 };
    Integer prevValue = null;
    for (int i = 0; i < values.length; i++) {
        int currentValue = values[i];
        if (value == currentValue) {
            selectedItem = items.get(i);
            break;
        } else if (prevValue != null && value > prevValue && value < currentValue) {
            // $NON-NLS-1$ //$NON-NLS-2$
            EntityModel customItem = new EntityModel("Custom (" + value + ")", value);
            items.add(i, customItem);
            selectedItem = customItem;
            break;
        }
        prevValue = currentValue;
    }
    // Delete 'never' item if it's not selected.
    if (selectedItem != neverItem) {
        items.remove(neverItem);
    }
    getSpmPriority().setItems(items);
    getSpmPriority().setSelectedItem(selectedItem);
}
#end_block

#method_before
void initTable() {
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    getTable().addColumn(nameColumn, constants.nameHost());
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    getTable().addColumn(hostColumn, constants.ipHost());
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    getTable().addColumn(clusterColumn, constants.clusterHost());
    TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getstorage_pool_name();
        }
    };
    getTable().addColumn(dcColumn, constants.dcHost());
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, constants.statusHost());
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        ProgressBarColumn<VDS> loadColumn = new ProgressBarColumn<VDS>() {

            @Override
            protected String getProgressText(VDS object) {
                int numOfActiveVMs = object.getvm_active() != null ? object.getvm_active() : 0;
                // $NON-NLS-1$
                return numOfActiveVMs + " VMs";
            }

            @Override
            protected Integer getProgressValue(VDS object) {
                return object.getvm_active();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadHost(), "100px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    return constants.spmHighText();
                }
                // $NON-NLS-1$ //$NON-NLS-2$
                return "Custom";
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "80px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#method_after
void initTable() {
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    getTable().addColumn(nameColumn, constants.nameHost());
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    getTable().addColumn(hostColumn, constants.ipHost());
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    getTable().addColumn(clusterColumn, constants.clusterHost());
    TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getstorage_pool_name();
        }
    };
    getTable().addColumn(dcColumn, constants.dcHost());
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, constants.statusHost());
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        ProgressBarColumn<VDS> loadColumn = new ProgressBarColumn<VDS>() {

            @Override
            protected String getProgressText(VDS object) {
                int numOfActiveVMs = object.getvm_active() != null ? object.getvm_active() : 0;
                // $NON-NLS-1$
                return numOfActiveVMs + " VMs";
            }

            @Override
            protected Integer getProgressValue(VDS object) {
                return object.getvm_active();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadHost(), "100px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "80px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#end_block

#method_before
public static String getKeyString(final PublicKey key, String alias) {
    // Get the serialized version of the key:
    final byte[] keyBytes = getKeyBytes(key);
    if (keyBytes == null) {
        log.error("Can't get key bytes, will return null.");
        return null;
    }
    // Encode it using BASE64:
    final Base64 encoder = new Base64(0);
    final String encoding = encoder.encodeToString(keyBytes);
    if (log.isDebugEnabled()) {
        log.debug("Key encoding is \"" + encoding + "\".");
    }
    // Return the generated SSH public key:
    final StringBuilder buffer = new StringBuilder(SSH_RSA.length() + 1 + encoding.length() + (alias != null ? 1 + alias.length() : 0));
    buffer.append(SSH_RSA);
    buffer.append(" ");
    buffer.append(encoding);
    if (alias != null) {
        buffer.append(" ");
        buffer.append(alias);
    }
    buffer.append('\n');
    final String keyString = buffer.toString();
    if (log.isDebugEnabled()) {
        log.debug("Key string is \"" + keyString + "\".");
    }
    return keyString;
}
#method_after
public static String getKeyString(final PublicKey key, String alias) {
    // Get the serialized version of the key:
    final byte[] keyBytes = getKeyBytes(key);
    if (keyBytes == null) {
        log.error("Can't get key bytes, will return null.");
        return null;
    }
    // Encode it using BASE64:
    final Base64 encoder = new Base64(0);
    final String encoding = encoder.encodeToString(keyBytes);
    if (log.isDebugEnabled()) {
        log.debug("Key encoding is \"" + encoding + "\".");
    }
    // Return the generated SSH public key:
    final StringBuilder buffer = new StringBuilder(SSH_RSA.length() + 1 + encoding.length() + (alias != null ? 1 + alias.length() : 0) + 1);
    buffer.append(SSH_RSA);
    buffer.append(" ");
    buffer.append(encoding);
    if (alias != null) {
        buffer.append(" ");
        buffer.append(alias);
    }
    buffer.append('\n');
    final String keyString = buffer.toString();
    if (log.isDebugEnabled()) {
        log.debug("Key string is \"" + keyString + "\".");
    }
    return keyString;
}
#end_block

#method_before
// TODO: there might be a race condition here - the list of vm's is loaded
// and only afterwards a lock is performed - so we can't be aware to changes
private void buildSharedLockMap() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        List<VM> listVms = getVmsForDiskId();
        if (!listVms.isEmpty()) {
            sharedLockMap = new HashMap<String, String>();
            for (VM vm : listVms) {
                sharedLockMap.put(vm.getId().toString(), LockingGroup.VM.name());
            }
        }
    } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
        sharedLockMap = Collections.singletonMap(disk.getvm_guid().toString(), LockingGroup.TEMPLATE.name());
    }
}
#method_after
private void buildSharedLockMap() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        List<VM> listVms = getVmsForDiskId();
        if (!listVms.isEmpty()) {
            sharedLockMap = new HashMap<String, String>();
            for (VM vm : listVms) {
                sharedLockMap.put(vm.getId().toString(), LockingGroup.VM.name());
            }
        }
    } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
        setVmTemplateIdParameter();
        sharedLockMap = Collections.singletonMap(getVmTemplateId().toString(), LockingGroup.TEMPLATE.name());
    }
}
#end_block

#method_before
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    setVmTemplateId(diskImage.getvm_guid());
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDAO().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getvm_name());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDAO().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getvm_name());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#end_block

#method_before
// TODO: need to verify that this list of vms cannot differ from the one
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    VmCommand.UpdateVmInSpm(getStoragePoolId().getValue(), listVms);
    setSucceeded(true);
}
#method_after
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    VmCommand.UpdateVmInSpm(getStoragePoolId().getValue(), listVms);
    setSucceeded(true);
}
#end_block

#method_before
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getVm().getDiskMap() != null) {
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        retVal = VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(vm.getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        // Enforce disabled USB policy for Linux OS with legacy policy.
        if (vm.getos().isLinux() && vm.getusb_policy().equals(UsbPolicy.ENABLED_LEGACY)) {
            vm.setusb_policy(UsbPolicy.DISABLED);
        }
        retVal = VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    addVmToDb();
    VM vm = getVm();
    // vm related ops
    if (vm.getImages().isEmpty()) {
        endVmRelatedOps();
    } else {
        processImages();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    addVmToDb();
    processImages();
    setSucceeded(true);
}
#end_block

#method_before
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                    list.get(i).setvm_guid(getVmId());
                }
            }
            disk.setvm_guid(getVmId());
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#method_after
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    EndActionOnAllImageGroups();
    endVmRelatedOps();
    setSucceeded(true);
}
#method_after
@Override
protected void EndSuccessfully() {
    EndImportCommand();
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // Going to try and refresh the VM by re-loading
    // it form DB
    VM vm = getUpdatedVmForOperation();
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(vm.getId());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(vm.getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#method_after
@Override
protected void EndWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VM.name().toLowerCase(), (getVmName() == null) ? "" : getVmName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VM.name().toLowerCase(), (getVmName() == null) ? "" : getVmName());
        jobProperties.put(VdcObjectType.VdsGroups.name().toLowerCase(), getVdsGroupName());
    }
    return jobProperties;
}
#end_block

#method_before
@Before
public void setUp() {
    client = new OvirtSSH();
    client.setSoftTimeout(10 * 1000);
    client.setHardTimeout(60 * 1000);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
}
#method_after
@Before
public void setUp() {
    client = new SSHClient();
    client.setSoftTimeout(10 * 1000);
    client.setHardTimeout(60 * 1000);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
}
#end_block

#method_before
@Test(expected = TimeLimitExceededException.class)
public void testConnectTimeout() throws Exception {
    OvirtSSH _client = spy(client);
    SshClient ssh = spy(SshClient.setUpDefaultClient());
    ConnectFuture future = mock(ConnectFuture.class);
    doReturn(ssh).when(_client)._createSshClient();
    doReturn(future).when(ssh).connect(anyString(), anyInt());
    when(future.await(anyLong())).thenReturn(false);
    _client.connect();
}
#method_after
@Test(expected = TimeLimitExceededException.class)
public void testConnectTimeout() throws Exception {
    SSHClient _client = spy(client);
    SshClient ssh = spy(SshClient.setUpDefaultClient());
    ConnectFuture future = mock(ConnectFuture.class);
    doReturn(ssh).when(_client)._createSshClient();
    doReturn(future).when(ssh).connect(anyString(), anyInt());
    when(future.await(anyLong())).thenReturn(false);
    _client.connect();
}
#end_block

#method_before
@Test(expected = TimeLimitExceededException.class)
public void testPasswordTimeout() throws Exception {
    OvirtSSH _client = spy(client);
    SshClient ssh = spy(SshClient.setUpDefaultClient());
    ConnectFuture future = mock(ConnectFuture.class);
    ClientSession session = mock(ClientSession.class);
    doReturn(ssh).when(_client)._createSshClient();
    doReturn(future).when(ssh).connect(anyString(), anyInt());
    when(future.await(anyLong())).thenReturn(true);
    when(future.getSession()).thenReturn(session);
    AuthFuture authFuture = mock(AuthFuture.class);
    when(authFuture.await(anyLong())).thenReturn(false);
    when(session.authPassword(anyString(), anyString())).thenReturn(authFuture);
    _client.connect();
}
#method_after
@Test(expected = TimeLimitExceededException.class)
public void testPasswordTimeout() throws Exception {
    SSHClient _client = spy(client);
    SshClient ssh = spy(SshClient.setUpDefaultClient());
    ConnectFuture future = mock(ConnectFuture.class);
    ClientSession session = mock(ClientSession.class);
    doReturn(ssh).when(_client)._createSshClient();
    doReturn(future).when(ssh).connect(anyString(), anyInt());
    when(future.await(anyLong())).thenReturn(true);
    when(future.getSession()).thenReturn(session);
    AuthFuture authFuture = mock(AuthFuture.class);
    when(authFuture.await(anyLong())).thenReturn(false);
    when(session.authPassword(anyString(), anyString())).thenReturn(authFuture);
    _client.connect();
    _client.authenticate();
}
#end_block

#method_before
@Before
public void setUp() throws IOException, Exception {
    remote = String.format("/tmp/ssh-test-%1$s.tmp", System.currentTimeMillis());
    local2 = File.createTempFile("ssh-test-", ".tmp");
    client = new OvirtSSH();
    client.setSoftTimeout(5 * 60 * 1000);
    client.setHardTimeout(TestCommon.largeTestHardTimeout);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
    client.connect();
}
#method_after
@Before
public void setUp() throws IOException, Exception {
    remote = String.format("/tmp/ssh-test-%1$s.tmp", System.currentTimeMillis());
    local2 = File.createTempFile("ssh-test-", ".tmp");
    client = new SSHClient();
    client.setSoftTimeout(5 * 60 * 1000);
    client.setHardTimeout(TestCommon.largeTestHardTimeout);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
    client.connect();
    client.authenticate();
}
#end_block

#method_before
@After
public void tearDown() {
    if (client != null) {
        try {
            client.execute(String.format("rm -f '%1$s'", remote), null, null, null);
        } catch (Exception e) {
        }
        try {
            client.disconnect();
        } catch (Exception e) {
        }
        client = null;
    }
    if (local2 != null) {
        local2.delete();
        local2 = null;
    }
}
#method_after
@After
public void tearDown() {
    if (client != null) {
        try {
            client.executeCommand(String.format("rm -f '%1$s'", remote), null, null, null);
        } catch (Exception e) {
        }
        try {
            client.disconnect();
        } catch (Exception e) {
        }
        client = null;
    }
    if (local2 != null) {
        local2.delete();
        local2 = null;
    }
}
#end_block

#method_before
@Before
public void setUp() {
    client = new OvirtSSH();
    client.setSoftTimeout(30 * 1000);
    client.setHardTimeout(5 * 60 * 1000);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
}
#method_after
@Before
public void setUp() {
    client = new SSHClient();
    client.setSoftTimeout(30 * 1000);
    client.setHardTimeout(5 * 60 * 1000);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
}
#end_block

#method_before
@Test(expected = AuthenticationException.class)
public void testWrongPassword() throws Exception {
    client.setPassword(TestCommon.password + "A");
    client.connect();
    client.execute(hello_command, null, null, null);
}
#method_after
@Test(expected = AuthenticationException.class)
public void testWrongPassword() throws Exception {
    client.setPassword(TestCommon.password + "A");
    client.connect();
    client.authenticate();
    client.executeCommand(hello_command, null, null, null);
}
#end_block

#method_before
@Test(expected = AuthenticationException.class)
public void testWrongKey() throws Exception {
    KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
    KeyPair badKeyPair = generator.generateKeyPair();
    client.setKeyPair(badKeyPair);
    client.connect();
    client.execute(hello_command, null, null, null);
}
#method_after
@Test(expected = AuthenticationException.class)
public void testWrongKey() throws Exception {
    KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
    KeyPair badKeyPair = generator.generateKeyPair();
    client.setKeyPair(badKeyPair);
    client.connect();
    client.authenticate();
    client.executeCommand(hello_command, null, null, null);
}
#end_block

#method_before
@Test
public void testPassword() throws Exception {
    client.setPassword(TestCommon.password);
    client.connect();
    ByteArrayOutputStream out = new OvirtSSH.ConstraintByteArrayOutputStream(500);
    client.execute(hello_command, null, out, null);
    assertEquals(hello_result, new String(out.toByteArray(), "UTF-8"));
}
#method_after
@Test
public void testPassword() throws Exception {
    client.setPassword(TestCommon.password);
    client.connect();
    client.authenticate();
    ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(500);
    client.executeCommand(hello_command, null, out, null);
    assertEquals(hello_result, new String(out.toByteArray(), "UTF-8"));
}
#end_block

#method_before
@Test
public void testPK() throws Exception {
    client.setKeyPair(TestCommon.keyPair);
    client.connect();
    ByteArrayOutputStream out = new OvirtSSH.ConstraintByteArrayOutputStream(500);
    client.execute(hello_command, null, out, null);
    assertEquals(hello_result, new String(out.toByteArray(), "UTF-8"));
}
#method_after
@Test
public void testPK() throws Exception {
    client.setKeyPair(TestCommon.keyPair);
    client.connect();
    client.authenticate();
    ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(500);
    client.executeCommand(hello_command, null, out, null);
    assertEquals(hello_result, new String(out.toByteArray(), "UTF-8"));
}
#end_block

#method_before
@Test
public void testLimit() throws IOException {
    int limit = 1000;
    ByteArrayOutputStream os = new OvirtSSH.ConstraintByteArrayOutputStream(limit);
    byte[] buffer = new byte[100];
    for (int i = 0; i < limit * 5 / buffer.length; i++) {
        os.write(buffer);
    }
    assertTrue(os.size() >= limit);
    assertTrue(os.size() < limit * 3 / 2);
}
#method_after
@Test
public void testLimit() throws IOException {
    int limit = 1000;
    ByteArrayOutputStream os = new ConstraintByteArrayOutputStream(limit);
    byte[] buffer = new byte[100];
    for (int i = 0; i < limit * 5 / buffer.length; i++) {
        os.write(buffer);
    }
    assertTrue(os.size() >= limit);
    assertTrue(os.size() < limit * 3 / 2);
}
#end_block

#method_before
@Before
public void setUp() throws IOException, Exception {
    client = new OvirtSSH();
    client.setSoftTimeout(softTimeout);
    client.setHardTimeout(hardTimeout);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
    client.connect();
}
#method_after
@Before
public void setUp() throws IOException, Exception {
    client = new SSHClient();
    client.setSoftTimeout(softTimeout);
    client.setHardTimeout(hardTimeout);
    client.setHost(TestCommon.host, TestCommon.port);
    client.setUser(TestCommon.user);
    client.setPassword(TestCommon.password);
    client.connect();
    client.authenticate();
}
#end_block

#method_before
@Test
public void testCommandZero() throws Exception {
    client.execute("true", null, null, null);
}
#method_after
@Test
public void testCommandZero() throws Exception {
    client.executeCommand("true", null, null, null);
}
#end_block

#method_before
@Test(expected = IOException.class)
public void testCommandNonZero() throws Exception {
    client.execute("false", null, null, null);
}
#method_after
@Test(expected = IOException.class)
public void testCommandNonZero() throws Exception {
    client.executeCommand("false", null, null, null);
}
#end_block

#method_before
@Test(expected = IOException.class)
public void testCommandSignal() throws Exception {
    client.execute("kill $$ ; sleep 10", null, null, null);
}
#method_after
@Test(expected = IOException.class)
public void testCommandSignal() throws Exception {
    client.executeCommand("kill $$ ; sleep 10", null, null, null);
}
#end_block

#method_before
@Test
public void testEchoStdout() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.execute("cat", stdin, stdout, stderr);
    assertEquals(content, new String(stdout.toByteArray(), "UTF-8"));
    assertEquals(0, stderr.size());
}
#method_after
@Test
public void testEchoStdout() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.executeCommand("cat", stdin, stdout, stderr);
    assertEquals(content, new String(stdout.toByteArray(), "UTF-8"));
    assertEquals(0, stderr.size());
}
#end_block

#method_before
@Test
public void testEchoStderr() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.execute("cat >&2", stdin, stdout, stderr);
    assertEquals(content, new String(stderr.toByteArray(), "UTF-8"));
    assertEquals(0, stdout.size());
}
#method_after
@Test
public void testEchoStderr() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.executeCommand("cat >&2", stdin, stdout, stderr);
    assertEquals(content, new String(stderr.toByteArray(), "UTF-8"));
    assertEquals(0, stdout.size());
}
#end_block

#method_before
@Test
public void testEchoBoth() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.execute("cat | tee /proc/self/fd/2", stdin, stdout, stderr);
    assertEquals(content, new String(stdout.toByteArray(), "UTF-8"));
    assertEquals(content, new String(stderr.toByteArray(), "UTF-8"));
}
#method_after
@Test
public void testEchoBoth() throws Exception {
    String content = "hello\nworld!\nother\ndata";
    InputStream stdin = new ByteArrayInputStream(content.getBytes("UTF-8"));
    ByteArrayOutputStream stdout = new ByteArrayOutputStream();
    ByteArrayOutputStream stderr = new ByteArrayOutputStream();
    client.executeCommand("cat | tee /proc/self/fd/2", stdin, stdout, stderr);
    assertEquals(content, new String(stdout.toByteArray(), "UTF-8"));
    assertEquals(content, new String(stderr.toByteArray(), "UTF-8"));
}
#end_block

#method_before
@Test
public void testSoftTimeout() throws Exception {
    long start = System.currentTimeMillis();
    try {
        client.execute(String.format("sleep %d", softTimeout / 1000 * 4), null, null, null);
    } catch (TimeLimitExceededException e) {
        assertTrue(System.currentTimeMillis() - start >= softTimeout);
        assertTrue(System.currentTimeMillis() - start < softTimeout * 3 / 2);
    }
}
#method_after
@Test
public void testSoftTimeout() throws Exception {
    long start = System.currentTimeMillis();
    try {
        client.executeCommand(String.format("sleep %d", softTimeout / 1000 * 4), null, null, null);
    } catch (TimeLimitExceededException e) {
        assertTrue(System.currentTimeMillis() - start >= softTimeout);
        assertTrue(System.currentTimeMillis() - start < softTimeout * 3 / 2);
    }
}
#end_block

#method_before
@Test(timeout = 120 * 1000)
public void testHardTimeout() throws Exception {
    long start = System.currentTimeMillis();
    try {
        client.execute(String.format("while true; do echo sleeping; sleep %d; done", softTimeout / 1000 / 2), null, null, null);
    } catch (TimeLimitExceededException e) {
        assertTrue(System.currentTimeMillis() - start >= hardTimeout);
        assertTrue(System.currentTimeMillis() - start < hardTimeout * 3 / 2);
    }
}
#method_after
@Test(timeout = 120 * 1000)
public void testHardTimeout() throws Exception {
    long start = System.currentTimeMillis();
    try {
        client.executeCommand(String.format("while true; do echo sleeping; sleep %d; done", softTimeout / 1000 / 2), null, null, null);
    } catch (TimeLimitExceededException e) {
        assertTrue(System.currentTimeMillis() - start >= hardTimeout);
        assertTrue(System.currentTimeMillis() - start < hardTimeout * 3 / 2);
    }
}
#end_block

#method_before
public static void initialize() {
    host = System.getProperty("ssh-host");
    if (host == null) {
        System.out.println("WARNING: using internal daemon");
        try {
            keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        host = "localhost";
        user = "root";
        password = "password";
        SSHD sshd = new SSHD();
        sshd.setUser(user, password, keyPair.getPublic());
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
        String p12 = System.getProperty("ssh-test-p12");
        String p12_password = System.getProperty("ssh-test-p12-password", "password");
        try {
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream(p12), p12_password.toCharArray());
            KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry) keyStore.getEntry("1", new KeyStore.PasswordProtection(p12_password.toCharArray()));
            keyPair = new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey());
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
    largeTestFileSize = Long.parseLong(System.getProperty("ssh-test-large-file-size", "50000000"));
    largeTestHardTimeout = Long.parseLong(System.getProperty("ssh-test-long-hard-timeout", "0"));
}
#method_after
public static void initialize() {
    host = System.getProperty("ssh-host");
    if (host == null) {
        System.out.println("WARNING: using internal daemon");
        try {
            keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        sshd.setUser(user, password, keyPair.getPublic());
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
        String p12 = System.getProperty("ssh-test-p12");
        String p12_password = System.getProperty("ssh-test-p12-password", "password");
        try {
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(new FileInputStream(p12), p12_password.toCharArray());
            KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry) keyStore.getEntry("1", new KeyStore.PasswordProtection(p12_password.toCharArray()));
            keyPair = new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey());
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
    }
    largeTestFileSize = Long.parseLong(System.getProperty("ssh-test-large-file-size", "50000000"));
    largeTestHardTimeout = Long.parseLong(System.getProperty("ssh-test-long-hard-timeout", "0"));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // only on non vds installation mode.
        if (getVdsGroup().supportsGlusterService() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                return;
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // only on non vds installation mode.
        if (getVdsGroup().supportsGlusterService() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
                return;
            }
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_ADD_VDS : AuditLogType.USER_FAILED_ADD_VDS;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_ADD_VDS : errorType;
}
#end_block

#method_before
public String getServerUniqueId() {
    wrapper.execute(VdsInstaller._getUniqueIdCommand);
    return callback.serverUniqueId;
}
#method_after
public String getServerUniqueId() {
    wrapper.executeCommand(VdsInstaller._getUniqueIdCommand);
    return callback.serverUniqueId;
}
#end_block

#method_before
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.execute(_getUniqueIdCommand);
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    _currentInstallStage = VdsInstallStages.UploadScript;
                    _executionSucceded = uploadFirewallRulesConfFile();
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.execute(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.execute(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#method_after
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(_getUniqueIdCommand);
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    _currentInstallStage = VdsInstallStages.UploadScript;
                    _executionSucceded = uploadFirewallRulesConfFile();
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#end_block

#method_before
@Override
protected void RunStage() {
    switch(_currentInstallStage) {
        case Start:
            {
                log.infoFormat("Installation of {0}. Executing oVirt reinstall/upgrade stage. (Stage: {1})", _serverName, getCurrentInstallStage());
                super.RunStage();
                break;
            }
        // (relies on public key existing on cbc image)
        case ConnectToServer:
            {
                log.infoFormat("Installation of {0}. Executing oVirt reinstall/upgrade stage. (Stage: {1})", _serverName, getCurrentInstallStage());
                _executionSucceded = _wrapper.connect(_serverName);
                break;
            }
        case UploadScript:
            log.infoFormat("Installation of {0}. Executing oVirt reinstall/upgrade stage. (Stage: {1})", _serverName, getCurrentInstallStage());
            String path = Path.Combine(Config.resolveOVirtISOsRepositoryPath(), _oVirtISOFile);
            _executionSucceded = _wrapper.sendFile(path, Config.<String>GetValue(ConfigValues.oVirtUploadPath));
            break;
        case RunScript:
            log.infoFormat("Installation of {0}. Executing oVirt reinstall/upgrade stage. (Stage: {1})", _serverName, getCurrentInstallStage());
            _wrapper.execute(runUpgradeCommand);
            break;
        // Skip unused states
        default:
            {
                _executionSucceded = true;
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                break;
            }
    }
}
#method_after
@Override
protected void RunStage() {
    switch(_currentInstallStage) {
        // Keep base logic for following states
        case Start:
        case SignCertificateRequest:
        case UploadSignedCertificate:
        case UploadCA:
        case DownloadCertificateRequest:
            {
                log.infoFormat("Installation of {0}. Executing oVirt installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
                super.RunStage();
                break;
            }
        case ConnectToServer:
            {
                log.infoFormat("Installation of {0}. Executing oVirt installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
                _executionSucceded = _wrapper.connect(_serverName);
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Executing oVirt installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
                _wrapper.executeCommand(createCertReqCommand);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Executing oVirt installation stage, sending SSH Command {1}. (Stage: {2})", _serverName, finishCommandInitial, getCurrentInstallStage());
                _wrapper.executeCommand(finishCommandInitial);
                break;
            }
        // VdsInstallStages.CheckUniqueVds
        default:
            {
                _executionSucceded = true;
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                break;
            }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    } else if (getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    return (updateBrickServerNames(getParameters().getBricks(), true) && isValidBricks(getParameters().getBricks()));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    } else if (getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    return (updateBrickServerNames(getParameters().getBricks(), true) && validateBricks(getParameters().getBricks()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks());
        getReturnValue().setActionReturnValue(getBrickIds(getParameters().getBricks()));
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks());
        getReturnValue().setActionReturnValue(getBrickIds(getParameters().getBricks()));
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringHelper.isNullOrEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

#method_before
private boolean validateHostUniqueNameAndAddress(VdsStatic vdsStaticData) {
    // having oVirt in pending approval state allows having a host with same name and address
    Guid vdsForUniqueId = getParameters().getVdsForUniqueId();
    if (vdsForUniqueId == null) {
        return !VdsHandler.isVdsExist(getParameters().getVdsStaticData(), getReturnValue().getCanDoActionMessages());
    } else {
        return !VdsHandler.isVdsExistForPendingOvirt(getParameters().getVdsStaticData(), getReturnValue().getCanDoActionMessages(), vdsForUniqueId);
    }
}
#method_after
private boolean validateHostUniqueNameAndAddress(VdsStatic vdsStaticData) {
    // having oVirt in pending approval state allows having a host with same name and address
    Guid vdsForUniqueId = getParameters().getVdsForUniqueId();
    if (vdsForUniqueId == null) {
        return !VdsHandler.isVdsExist(vdsStaticData, getReturnValue().getCanDoActionMessages());
    }
    return !VdsHandler.isVdsExistForPendingOvirt(vdsStaticData, getReturnValue().getCanDoActionMessages(), vdsForUniqueId);
}
#end_block

#method_before
private static void initVMsPoolSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initVMsPoolSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_POOL_WITH_VMS_ADD_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_AD_GROUP_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_AD_GROUP_FROM_TIME_LEASED_POOL_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_USER_TO_TIME_LEASED_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.NORMAL);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORK_MTU_DIFFER_FROM_LOGICAL_NETWORK, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        if ((message = mMessages.get(logType)) != null) {
            String resolvedMessage = resolveMessage(message, auditLogable);
            AuditLogSeverity severity = AuditLogSeverity.forValue(0);
            if (!((severity = mSeverities.get(logType)) != null)) {
                severity = AuditLogSeverity.NORMAL;
                log.infoFormat("No severity for {0} type", logType);
            }
            AuditLog auditLog;
            if (auditLogable != null) {
                AuditLog tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setQuotaId(auditLogable.getQuotaId());
                tempVar.setQuotaName(auditLogable.getQuotaName());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                auditLog = tempVar;
            } else {
                auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
            }
            getDbFacadeInstance().getAuditLogDAO().save(auditLog);
            if (!StringHelper.EqOp(loggerString, "")) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        } else if (auditLogable != null) {
            log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
            defaultLog(auditLogable);
        }
    }
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        if ((message = mMessages.get(logType)) != null) {
            String resolvedMessage = resolveMessage(message, auditLogable);
            AuditLogSeverity severity = AuditLogSeverity.forValue(0);
            if (!((severity = mSeverities.get(logType)) != null)) {
                severity = AuditLogSeverity.NORMAL;
                log.infoFormat("No severity for {0} type", logType);
            }
            AuditLog auditLog;
            if (auditLogable != null) {
                AuditLog tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                if (tempVar instanceof Quotable) {
                    Quotable quotable = (Quotable) tempVar;
                    tempVar.setQuotaId(quotable.getQuotaId());
                }
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                auditLog = tempVar;
            } else {
                auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
            }
            getDbFacadeInstance().getAuditLogDAO().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        } else if (auditLogable != null) {
            log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
            defaultLog(auditLogable);
        }
    }
}
#end_block

#method_before
static String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvalableValues(logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#method_after
static String resolveMessage(String message, AuditLogableBase logable) {
    String returnValue = message;
    if (logable != null) {
        Map<String, String> map = getAvailableValues(logable);
        returnValue = resolveMessage(message, map);
    }
    return returnValue;
}
#end_block

#method_before
public static String resolveMessage(String message, Map<String, String> values) {
    Matcher matcher = pattern.matcher(message);
    StringBuffer buffer = new StringBuffer();
    String value;
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${
        token = token.substring(2);
        // remove trailing }
        token = token.substring(0, token.length() - 1);
        // get value from value map
        value = values.get(token.toLowerCase());
        if (value == null || value.isEmpty()) {
            // replace value with token if value not defined
            value = token;
        }
        // put the value into message
        matcher.appendReplacement(buffer, Matcher.quoteReplacement(value));
    }
    // append the rest of the message
    matcher.appendTail(buffer);
    return buffer.toString();
}
#method_after
public static String resolveMessage(String message, Map<String, String> values) {
    Matcher matcher = pattern.matcher(message);
    StringBuffer buffer = new StringBuffer();
    String value;
    String token;
    while (matcher.find()) {
        token = matcher.group();
        // remove leading ${
        token = token.substring(2);
        // remove trailing }
        token = token.substring(0, token.length() - 1);
        // get value from value map
        value = values.get(token.toLowerCase());
        if (value == null || value.isEmpty()) {
            // replace value with UNKNOWN_VARIABLE_VALUE if value not defined
            value = UNKNOWN_VARIABLE_VALUE;
        }
        // put the value into message
        matcher.appendReplacement(buffer, Matcher.quoteReplacement(value));
    }
    // append the rest of the message
    matcher.appendTail(buffer);
    return buffer.toString();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    VDSGroup targetCluster = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getClusterId());
    if (targetCluster == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDAO().getForVdsGroup(targetCluster.getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getClusterUtils().hasVolumeOnServer(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (getClusterUtils().hasMultipleServers(getVdsGroupId()) && getClusterUtils().getUpServer(getVdsGroupId()) == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_UP_SERVER_FOUND);
            return false;
        }
    }
    if (getVdsGroup(getParameters().getClusterId()).supportsGlusterService()) {
        if (getClusterUtils().hasServers(getParameters().getClusterId()) && getClusterUtils().getUpServer(getParameters().getClusterId()) == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDAO().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getSourceCluster().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServer(getTargetCluster())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup sourceCluster = getVdsGroup();
    final Guid targetClusterId = getParameters().getClusterId();
    if (sourceCluster.getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDAO().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (sourceCluster.getstorage_pool_id() != null) {
        if (sourceCluster.supportsGlusterService()) {
            glusterHostRemove(sourceCluster.getId());
            if (!getSucceeded()) {
                return;
            }
        }
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
        if (getVdsGroup(getParameters().getClusterId()).supportsGlusterService()) {
            glusterHostAdd(getParameters().getClusterId());
            if (!getSucceeded()) {
                return;
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDAO().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (getSourceCluster().getstorage_pool_id() != null) {
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private void glusterHostRemove(Guid sourceClusterId) {
    // UI will implement forceAction later
    // Now assume that the force option is false
    boolean forceAction = false;
    if (getClusterUtils().hasServers(sourceClusterId) && !getClusterUtils().hasVolumeOnServer(getVdsId())) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((getClusterUtils().getUpServer(sourceClusterId)).getId(), getVds().gethost_name(), forceAction));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
            return;
        }
    } else {
        setSucceeded(true);
    }
}
#method_after
private boolean glusterHostRemove(Guid sourceClusterId) {
    String hostName = (getVds().gethost_name().isEmpty()) ? getVds().getManagmentIp() : getVds().gethost_name();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((getClusterUtils().getUpServer(sourceClusterId)).getId(), hostName, false));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
        return false;
    }
    return true;
}
#end_block

#method_before
private void glusterHostAdd(Guid targetClusterId) {
    // If cluster supports gluster service do gluster peer probe
    if (getClusterUtils().hasMultipleServers(targetClusterId)) {
        String hostName = (getVds().gethost_name().isEmpty()) ? getVds().getManagmentIp() : getVds().gethost_name();
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(getClusterUtils().getUpServer(targetClusterId).getId(), hostName));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
            return;
        }
    } else {
        setSucceeded(true);
    }
}
#method_after
private boolean glusterHostAdd(Guid targetClusterId) {
    String hostName = (getVds().gethost_name().isEmpty()) ? getVds().getManagmentIp() : getVds().gethost_name();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(getClusterUtils().getUpServer(targetClusterId).getId(), hostName));
    if (!returnValue.getSucceeded()) {
        handleVdsError(returnValue);
        errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testUpdateImageVmSnapshotId() {
    dao.updateImageVmSnapshotId(EXISTING_IMAGE_ID, EXISTING_SNAPSHOT_ID);
    Image imageFromDb = dao.get(EXISTING_IMAGE_ID);
    assertNotNull(imageFromDb);
    assertEquals("Image snapshot id wasn't updated properly", EXISTING_SNAPSHOT_ID, imageFromDb.getSnapshotId());
}
#method_after
@Test
public void testUpdateImageVmSnapshotId() {
    Guid guid = Guid.NewGuid();
    dao.updateImageVmSnapshotId(EXISTING_IMAGE_ID, guid);
    Image imageFromDb = dao.get(EXISTING_IMAGE_ID);
    assertNotNull(imageFromDb);
    assertEquals("Image snapshot id wasn't updated properly", guid, imageFromDb.getSnapshotId());
}
#end_block

#method_before
private void updateDiskVmSnapshotId() {
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        Guid snapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
        getImageDao().updateImageVmSnapshotId(disk.getId(), snapshotId);
        ((DiskImage) disk).setvm_snapshot_id(snapshotId);
    }
}
#method_after
private void updateDiskVmSnapshotId() {
    Guid snapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = ((DiskImage) disk);
        getImageDao().updateImageVmSnapshotId(diskImage.getImageId(), snapshotId);
    } else {
        throw new VdcBLLException(VdcBllErrors.StorageException, "update of snapshot id was initiated for unsupported disk type");
    }
}
#end_block

#method_before
@Override
protected Map<Guid, String> getExclusiveLocks() {
    if (disk.isBoot()) {
        return Collections.singletonMap(getParameters().getVmId(), LockingGroup.VM_DISK_BOOT.name());
    }
    return null;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (disk.isBoot()) {
        return Collections.singletonMap(getParameters().getVmId().toString(), LockingGroup.VM_DISK_BOOT.name());
    }
    return null;
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", "num_of_cpus" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties", "images", "interfaces" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties", "images", "interfaces" }));
}
#end_block

#method_before
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else if (reasons != null) {
            reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
public static void unlockVm(final VmDynamic vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm, vm.getstatus());
            vm.setstatus(VMStatus.Down);
            UnLockVm(vm.getId());
            compensationContext.stateChanged();
            return null;
        }
    });
}
#method_after
public static void unlockVm(final VM vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm, vm.getstatus());
            UnLockVm(vm);
            compensationContext.stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
public static void UnLockVm(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDAO().get(vmId);
    if (vm.getstatus() == VMStatus.ImageLocked) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vmId, VMStatus.Down));
    } else {
        log.errorFormat("Trying to unlock vm {0} in status {1} - not moving to down!", vm.getvm_name(), vm.getstatus());
    }
}
#method_after
public static void UnLockVm(VM vm) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
    vm.setstatus(VMStatus.Down);
}
#end_block

#method_before
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type == GlusterVolumeType.STRIPE || type == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    } else if (type == GlusterVolumeType.REPLICATE || type == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.TCP);
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.RDMA);
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity())
        volume.enableNFS();
    else
        volume.disableNFS();
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity())
        volume.enableCifs();
    else
        volume.disableCifs();
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.StartProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume);
    Frontend.RunAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onCreateVolume() {
    VolumeModel volumeModel = (VolumeModel) getWindow();
    if (!volumeModel.validate()) {
        return;
    }
    Guid clusterId = ((VDSGroup) volumeModel.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) volumeModel.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) volumeModel.getTypeList().getSelectedItem();
    if (type == GlusterVolumeType.STRIPE || type == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        volume.setStripeCount(volumeModel.getStripeCountValue());
    } else if (type == GlusterVolumeType.REPLICATE || type == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        volume.setReplicaCount(volumeModel.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) volumeModel.getTcpTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.TCP);
    }
    if ((Boolean) volumeModel.getRdmaTransportType().getEntity()) {
        volume.getTransportTypes().add(TransportType.RDMA);
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object model : volumeModel.getBricks().getItems()) {
        brickList.add((GlusterBrickEntity) ((EntityModel) model).getEntity());
    }
    volume.setBricks(brickList);
    if ((Boolean) volumeModel.getNfs_accecssProtocol().getEntity()) {
        volume.enableNFS();
    } else {
        volume.disableNFS();
    }
    if ((Boolean) volumeModel.getCifs_accecssProtocol().getEntity()) {
        volume.enableCifs();
    } else {
        volume.disableCifs();
    }
    volume.setAccessControlList((String) volumeModel.getAllowAccess().getEntity());
    volumeModel.StartProgress(null);
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume);
    Frontend.RunAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VolumeListModel localModel = (VolumeListModel) result.getState();
            localModel.postOnCreateVolume(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter == null ? null : (NGuid) (selectedDataCenter.getId()));
}
#method_after
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            } else {
                clusterModel.getVersion().setSelectedItem(Linq.FirstOrDefault(versions, new Linq.VersionPredicate(((VDSGroup) getEntity()).getcompatibility_version())));
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter == null ? null : (NGuid) (selectedDataCenter.getId()));
}
#end_block

#method_before
private void SetDefaultNames8() {
    VDS host = context.host;
    ArrayList<storage_pool> dataCenters = context.dataCenterList;
    ArrayList<VDSGroup> clusters = context.clusterList;
    // $NON-NLS-1$
    setCommonName(StringFormat.format("%1$s-Local", host.getvds_name().replace('.', '-')));
    storage_pool candidate = null;
    // Check if current settings suitable for local setup (in case just SD creation failed - re-using the same
    // setup)
    boolean useCurrentSettings = false;
    if (host.getstorage_pool_id() != null) {
        storage_pool tempCandidate = context.hostDataCenter;
        if (IsLocalDataCenterEmpty(tempCandidate)) {
            candidate = tempCandidate;
            useCurrentSettings = true;
        } else {
            if (tempCandidate != null && tempCandidate.getstorage_pool_type() == StorageType.LOCALFS) {
                setMessage(ConstantsManager.getInstance().getConstants().noteLocalStorageAlreadyConfiguredForThisHostMsg() + " " + host.getstorage_pool_name() + " " + // $NON-NLS-1$ //$NON-NLS-2$
                ConstantsManager.getInstance().getConstants().withLocalStorageDomainMsg());
            }
        }
    }
    // Check if there is other DC suitable for re-use
    if (candidate == null) {
        for (storage_pool dataCenter : dataCenters) {
            // Need to check if the new DC is without host.
            if (IsLocalDataCenterEmpty(dataCenter) && context.localStorageHostByDataCenterMap.get(dataCenter) == null) {
                candidate = dataCenter;
                break;
            }
        }
    }
    ArrayList<String> names;
    // In case we found a suitable candidate for re-use:
    if (candidate != null) {
        getDataCenter().setDataCenterId(candidate.getId());
        getDataCenter().getName().setEntity(candidate.getname());
        getDataCenter().getDescription().setEntity(candidate.getdescription());
        Version version = candidate.getcompatibility_version();
        getDataCenter().getVersion().setSelectedItem(version);
        getCluster().getVersion().setSelectedItem(version);
        setCandidateDataCenter(candidate);
        // If we use current settings there is no need to create cluster.
        if (useCurrentSettings) {
            getCluster().setClusterId(host.getvds_group_id().getValue());
            getCluster().getName().setEntity(host.getvds_group_name());
            VDSGroup cluster = context.hostCluster;
            if (cluster != null) {
                getCluster().getDescription().setEntity(cluster.getdescription());
                ServerCpu cpu = new ServerCpu();
                cpu.setCpuName(cluster.getcpu_name());
                getCluster().getCPU().setSelectedItem(cpu);
            }
            setCandidateCluster(cluster);
        } else // Use different cluster
        {
            // Check the DC cluster list (for re-use)
            clusters = context.clusterListByDataCenterMap.get(candidate);
            // No clusters available - pick up new name.
            if (clusters == null || clusters.isEmpty()) {
                names = new ArrayList<String>();
                ArrayList<VDSGroup> listClusters = context.clusterList;
                for (VDSGroup cluster : listClusters) {
                    names.add(cluster.getname());
                }
                getCluster().getName().setEntity(AvailableName(names));
            } else {
                // Use the DC cluster.
                VDSGroup cluster = Linq.FirstOrDefault(clusters);
                getCluster().setClusterId(cluster.getId());
                getCluster().getName().setEntity(cluster.getname());
                getCluster().getDescription().setEntity(cluster.getdescription());
                cluster = Linq.FirstOrDefault(context.clusterList, new Linq.ClusterPredicate(getCluster().getClusterId().getValue()));
                if (cluster != null) {
                    ServerCpu cpu = new ServerCpu();
                    cpu.setCpuName(cluster.getcpu_name());
                    getCluster().getCPU().setSelectedItem(cpu);
                }
                setCandidateCluster(cluster);
            }
        }
    } else {
        // Didn't found DC to re-use, so we select new names.
        names = new ArrayList<String>();
        for (storage_pool dataCenter : dataCenters) {
            names.add(dataCenter.getname());
        }
        getDataCenter().getName().setEntity(AvailableName(names));
        // Choose a Data Center version corresponding to the host.
        if (!StringHelper.isNullOrEmpty(host.getsupported_cluster_levels())) {
            // The supported_cluster_levels are sorted.
            // $NON-NLS-1$
            String[] array = host.getsupported_cluster_levels().split("[,]", -1);
            Version maxVersion = null;
            for (int i = 0; i < array.length; i++) {
                Version vdsVersion = new Version(array[i]);
                for (Version version : (List<Version>) getDataCenter().getVersion().getItems()) {
                    if (version.equals(vdsVersion) && version.compareTo(maxVersion) > 0) {
                        maxVersion = version;
                    }
                }
            }
            if (maxVersion != null) {
                getDataCenter().getVersion().setSelectedItem(maxVersion);
                getCluster().getVersion().setSelectedItem(maxVersion);
            }
        }
        names = new ArrayList<String>();
        if (clusters == null) {
            clusters = context.clusterList;
        } else {
            for (VDSGroup cluster : clusters) {
                names.add(cluster.getname());
            }
        }
        getCluster().getName().setEntity(AvailableName(names));
    }
    // Choose default CPU name to match host.
    if (host.getCpuName() != null && getCluster().getCPU().getSelectedItem() != null) {
        getCluster().getCPU().setSelectedItem(Linq.FirstOrDefault((List<ServerCpu>) getCluster().getCPU().getItems(), new Linq.ServerCpuPredicate(host.getCpuName().getCpuName())));
    }
    // Always choose a available storage name.
    ArrayList<storage_domains> storages = context.storageList;
    names = new ArrayList<String>();
    for (storage_domains storageDomain : storages) {
        names.add(storageDomain.getstorage_name());
    }
    getFormattedStorageName().setEntity(AvailableName(names));
}
#method_after
private void SetDefaultNames8() {
    VDS host = context.host;
    ArrayList<storage_pool> dataCenters = context.dataCenterList;
    ArrayList<VDSGroup> clusters = context.clusterList;
    // $NON-NLS-1$
    setCommonName(StringFormat.format("%1$s-Local", host.getvds_name().replace('.', '-')));
    storage_pool candidate = null;
    // Check if current settings suitable for local setup (in case just SD creation failed - re-using the same
    // setup)
    boolean useCurrentSettings = false;
    if (host.getstorage_pool_id() != null) {
        storage_pool tempCandidate = context.hostDataCenter;
        if (IsLocalDataCenterEmpty(tempCandidate)) {
            candidate = tempCandidate;
            useCurrentSettings = true;
        } else {
            if (tempCandidate != null && tempCandidate.getstorage_pool_type() == StorageType.LOCALFS) {
                setMessage(ConstantsManager.getInstance().getConstants().noteLocalStorageAlreadyConfiguredForThisHostMsg() + " " + host.getstorage_pool_name() + " " + // $NON-NLS-1$ //$NON-NLS-2$
                ConstantsManager.getInstance().getConstants().withLocalStorageDomainMsg());
            }
        }
    }
    // Check if there is other DC suitable for re-use
    if (candidate == null) {
        for (storage_pool dataCenter : dataCenters) {
            // Need to check if the new DC is without host.
            if (IsLocalDataCenterEmpty(dataCenter) && context.localStorageHostByDataCenterMap.get(dataCenter) == null) {
                candidate = dataCenter;
                break;
            }
        }
    }
    ArrayList<String> names;
    // In case we found a suitable candidate for re-use:
    if (candidate != null) {
        getDataCenter().setDataCenterId(candidate.getId());
        getDataCenter().getName().setEntity(candidate.getname());
        getDataCenter().getDescription().setEntity(candidate.getdescription());
        Version version = candidate.getcompatibility_version();
        getDataCenter().getVersion().setSelectedItem(version);
        getCluster().getVersion().setSelectedItem(version);
        setCandidateDataCenter(candidate);
        // If we use current settings there is no need to create cluster.
        if (useCurrentSettings) {
            getCluster().setClusterId(host.getvds_group_id().getValue());
            getCluster().getName().setEntity(host.getvds_group_name());
            VDSGroup cluster = context.hostCluster;
            if (cluster != null) {
                getCluster().getDescription().setEntity(cluster.getdescription());
                ServerCpu cpu = new ServerCpu();
                cpu.setCpuName(cluster.getcpu_name());
                getCluster().getCPU().setSelectedItem(cpu);
            }
            setCandidateCluster(cluster);
        } else // Use different cluster
        {
            // Check the DC cluster list (for re-use)
            clusters = context.clusterListByDataCenterMap.get(candidate);
            // No clusters available - pick up new name.
            if (clusters == null || clusters.isEmpty()) {
                names = new ArrayList<String>();
                ArrayList<VDSGroup> listClusters = context.clusterList;
                for (VDSGroup cluster : listClusters) {
                    names.add(cluster.getname());
                }
                getCluster().getName().setEntity(AvailableName(names));
            } else {
                // Use the DC cluster.
                VDSGroup cluster = Linq.FirstOrDefault(clusters);
                getCluster().setClusterId(cluster.getId());
                getCluster().getName().setEntity(cluster.getname());
                getCluster().getDescription().setEntity(cluster.getdescription());
                cluster = Linq.FirstOrDefault(context.clusterList, new Linq.ClusterPredicate(getCluster().getClusterId().getValue()));
                if (cluster != null) {
                    ServerCpu cpu = new ServerCpu();
                    cpu.setCpuName(cluster.getcpu_name());
                    getCluster().getCPU().setSelectedItem(cpu);
                }
                setCandidateCluster(cluster);
            }
        }
    } else {
        // Didn't found DC to re-use, so we select new names.
        names = new ArrayList<String>();
        for (storage_pool dataCenter : dataCenters) {
            names.add(dataCenter.getname());
        }
        getDataCenter().getName().setEntity(AvailableName(names));
        // Choose a Data Center version corresponding to the host.
        if (!StringHelper.isNullOrEmpty(host.getsupported_cluster_levels())) {
            // The supported_cluster_levels are sorted.
            // $NON-NLS-1$
            String[] array = host.getsupported_cluster_levels().split("[,]", -1);
            Version maxVersion = null;
            for (int i = 0; i < array.length; i++) {
                Version vdsVersion = new Version(array[i]);
                for (Version version : (List<Version>) getDataCenter().getVersion().getItems()) {
                    if (version.equals(vdsVersion) && version.compareTo(maxVersion) > 0) {
                        maxVersion = version;
                    }
                }
            }
            if (maxVersion != null) {
                getDataCenter().getVersion().setSelectedItem(maxVersion);
                getCluster().getVersion().setSelectedItem(maxVersion);
            }
        }
        names = new ArrayList<String>();
        if (clusters == null) {
            clusters = context.clusterList;
        } else {
            for (VDSGroup cluster : clusters) {
                names.add(cluster.getname());
            }
        }
        getCluster().getName().setEntity(AvailableName(names));
    }
    // Choose default CPU name to match host.
    List<ServerCpu> serverCpus = (List<ServerCpu>) getCluster().getCPU().getItems();
    if (host.getCpuName() != null) {
        getCluster().getCPU().setSelectedItem(Linq.FirstOrDefault(serverCpus, new Linq.ServerCpuPredicate(host.getCpuName().getCpuName())));
    } else {
        getCluster().getCPU().setSelectedItem(serverCpus.isEmpty() ? null : serverCpus.get(0));
    }
    // Always choose a available storage name.
    ArrayList<storage_domains> storages = context.storageList;
    names = new ArrayList<String>();
    for (storage_domains storageDomain : storages) {
        names.add(storageDomain.getstorage_name());
    }
    getFormattedStorageName().setEntity(AvailableName(names));
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterPolicyModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new ClusterNetworkListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterPolicyModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
private List<Snapshot> prepareSnapshotConfigWithoutImage(Guid imageGroupToRemove) {
    List<Snapshot> result = new LinkedList<Snapshot>();
    List<DiskImage> snapshotDisks = getDiskImageDao().getAllSnapshotsForImageGroup(imageGroupToRemove);
    for (DiskImage snapshotDisk : snapshotDisks) {
        NGuid vmSnapshotId = snapshotDisk.getvm_snapshot_id();
        if (vmSnapshotId != null && !Guid.Empty.equals(vmSnapshotId.getValue())) {
            Snapshot updated = prepareSnapshotConfigWithoutImageSingleImage(snapshotDisk.getvm_snapshot_id().getValue(), snapshotDisk.getImageId());
            if (updated != null) {
                result.add(updated);
            }
        }
    }
    return result;
}
#method_after
private List<Snapshot> prepareSnapshotConfigWithoutImage(Guid imageGroupToRemove) {
    List<Snapshot> result = new LinkedList<Snapshot>();
    List<DiskImage> snapshotDisks = getDiskImageDao().getAllSnapshotsForImageGroup(imageGroupToRemove);
    for (DiskImage snapshotDisk : snapshotDisks) {
        NGuid vmSnapshotId = snapshotDisk.getvm_snapshot_id();
        if (vmSnapshotId != null && !Guid.Empty.equals(vmSnapshotId.getValue())) {
            Snapshot updated = prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId.getValue(), snapshotDisk.getImageId());
            if (updated != null) {
                result.add(updated);
            }
        }
    }
    return result;
}
#end_block

#method_before
private HttpURLConnection createURLConnection() throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException, KeyManagementException {
    boolean secured = servletURL.startsWith("https");
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection;
    if (secured) {
        if (trustStorePassword == null || trustStorePath == null) {
            logger.error("The Supplied URL is secured, however no trust store path or password were supplied.");
            return null;
        }
        HttpsURLConnection securedConnection = (HttpsURLConnection) url.openConnection();
        KeyStore trustStore = KeyStore.getInstance(trustStoreType);
        trustStore.load(new FileInputStream(trustStorePath), trustStorePassword.toCharArray());
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(trustStore);
        SSLContext ctx = SSLContext.getInstance(sslProtocol);
        if (sslIgnoreCertErrors) {
            logger.debug("sslIgnoreCertErrors mode");
            ctx.init(null, new TrustManager[] { new X509TrustManager() {

                @Override
                public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }
            } }, null);
        } else {
            ctx.init(null, trustManagerFactory.getTrustManagers(), null);
        }
        securedConnection.setSSLSocketFactory(ctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            logger.debug("sslIgnoreHostVerification mode");
            securedConnection.setHostnameVerifier(IgnoredHostnameVerifier);
        }
        servletConnection = securedConnection;
    } else {
        servletConnection = (HttpURLConnection) url.openConnection();
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#method_after
private HttpURLConnection createURLConnection() throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException, KeyManagementException {
    boolean secured = servletURL.startsWith("https");
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection;
    if (secured) {
        if (trustStorePassword == null || trustStorePath == null) {
            logger.error("The Supplied URL is secured, however no trust store path or password were supplied.");
            return null;
        }
        HttpsURLConnection securedConnection = (HttpsURLConnection) url.openConnection();
        KeyStore trustStore = KeyStore.getInstance(trustStoreType);
        trustStore.load(new FileInputStream(trustStorePath), trustStorePassword.toCharArray());
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(trustStore);
        SSLContext ctx = SSLContext.getInstance(sslProtocol);
        initSslcontext(ctx, trustManagerFactory);
        securedConnection.setSSLSocketFactory(ctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            logger.debug("sslIgnoreHostVerification mode");
            securedConnection.setHostnameVerifier(IgnoredHostnameVerifier);
        }
        servletConnection = securedConnection;
    } else {
        servletConnection = (HttpURLConnection) url.openConnection();
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#end_block

#method_before
public static void GetInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final RefObject<String> defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces:
        // ifacesOptions.RemoveAll(
        // delegate(Interface i)
        // {
        // return InterfaceHasChildVlanInterfaces(vdsID, i);
        // });
        ArrayList<GetAllChildVlanInterfacesQueryParameters> parametersList = new ArrayList<GetAllChildVlanInterfacesQueryParameters>();
        ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
        GetAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    ArrayList<VdsNetworkInterface> childVlanInterfaces = new ArrayList<VdsNetworkInterface>();
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // ifacesOptions.AddRange(interfaceList.Where(a => a.bond_name == originalInterface.name).ToList());
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.argvalue = originalInterface.getName();
                asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        GetVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    InterfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void OnSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // ifacesOptions.AddRange(interfaceList.Where(a => a.bond_name == vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.argvalue = vlanParent.getName();
                            asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
                        }
                    }));
                } else {
                    // the vlanParent should already be in ifacesOptions
                    // (since it has no network_name or bond_name).
                    defaultInterfaceName.argvalue = vlanParent.getName();
                    asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void GetInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        ArrayList<GetAllChildVlanInterfacesQueryParameters> parametersList = new ArrayList<GetAllChildVlanInterfacesQueryParameters>();
        ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
        GetAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    ArrayList<VdsNetworkInterface> childVlanInterfaces = new ArrayList<VdsNetworkInterface>();
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        GetVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    InterfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void OnSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // ifacesOptions.AddRange(interfaceList.Where(a => a.bond_name == vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
                        }
                    }));
                } else {
                    // the vlanParent should already be in ifacesOptions
                    // (since it has no network_name or bond_name).
                    defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.OnSuccess(asyncQuery.Model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public void EditManagementNetwork() {
    if (getWindow() != null) {
        return;
    }
    HostManagementNetworkModel managementNicModel = new HostManagementNetworkModel();
    setWindow(managementNicModel);
    managementNicModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
    // $NON-NLS-1$
    managementNicModel.setHashName("edit_management_network");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> clusterNetworks = (ArrayList<Network>) ReturnValue;
            final VdsNetworkInterface item = (VdsNetworkInterface) hostInterfaceListModel.getSelectedItem();
            final HostManagementNetworkModel managementModel = (HostManagementNetworkModel) hostInterfaceListModel.getWindow();
            Network networkToEdit = Linq.FindNetworkByName(clusterNetworks, item.getNetworkName());
            managementModel.setEntity(networkToEdit);
            managementModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            managementModel.setBootProtocol(!managementModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.None ? NetworkBootProtocol.Dhcp : item.getBootProtocol());
            managementModel.getAddress().setEntity(item.getAddress());
            managementModel.getSubnet().setEntity(item.getSubnet());
            managementModel.getGateway().setEntity(item.getGateway());
            final RefObject<String> tempRef_defaultInterfaceName = new RefObject<String>(null);
            AsyncDataProvider.GetInterfaceOptionsForEditNetwork(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object returnValue) {
                    ArrayList<VdsNetworkInterface> interfaces = (ArrayList<VdsNetworkInterface>) returnValue;
                    String defaultInterfaceName = tempRef_defaultInterfaceName.argvalue;
                    managementModel.getInterface().setItems(interfaces);
                    managementModel.getInterface().setSelectedItem(Linq.FindInterfaceByName(Linq.VdsNetworkInterfaceListToBase(interfaces), defaultInterfaceName));
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getInterface().setTitle(ConstantsManager.getInstance().getConstants().interfaceListTitle());
                        managementModel.getInterface().getSelectedItemChangedEvent().addListener(hostInterfaceListModel);
                    }
                    managementModel.getCheckConnectivity().setIsAvailable(true);
                    managementModel.getCheckConnectivity().setIsChangable(true);
                    // currently, always should be
                    managementModel.getCheckConnectivity().setEntity(item.getIsManagement());
                    // true
                    managementModel.getBondingOptions().setIsAvailable(false);
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getBondingOptions().setIsAvailable(true);
                        Map.Entry<String, EntityModel> defaultItem = null;
                        RefObject<Map.Entry<String, EntityModel>> tempRef_defaultItem = new RefObject<Map.Entry<String, EntityModel>>(defaultItem);
                        ArrayList<Map.Entry<String, EntityModel>> list = DataProvider.GetBondingOptionList(tempRef_defaultItem);
                        defaultItem = tempRef_defaultItem.argvalue;
                        Map.Entry<String, EntityModel> selectBondingOpt = new KeyValuePairCompat<String, EntityModel>();
                        boolean containsSelectBondingOpt = false;
                        managementModel.getBondingOptions().setItems(list);
                        for (int i = 0; i < list.size(); i++) {
                            if (StringHelper.stringsEqual(list.get(i).getKey(), item.getBondOptions())) {
                                selectBondingOpt = list.get(i);
                                containsSelectBondingOpt = true;
                                break;
                            }
                        }
                        if (containsSelectBondingOpt == false) {
                            if (StringHelper.stringsEqual(item.getBondOptions(), DataProvider.GetDefaultBondingOption())) {
                                selectBondingOpt = defaultItem;
                            } else {
                                selectBondingOpt = list.get(list.size() - 1);
                                EntityModel entityModel = selectBondingOpt.getValue();
                                entityModel.setEntity(item.getBondOptions());
                            }
                        }
                        managementModel.getBondingOptions().setSelectedItem(selectBondingOpt);
                    }
                    // $NON-NLS-1$
                    UICommand tempVar = new UICommand("OnEditManagementNetworkConfirmation", hostInterfaceListModel);
                    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
                    tempVar.setIsDefault(true);
                    managementModel.getCommands().add(tempVar);
                    // $NON-NLS-1$
                    UICommand tempVar2 = new UICommand("Cancel", hostInterfaceListModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                    tempVar2.setIsCancel(true);
                    managementModel.getCommands().add(tempVar2);
                }
            }), getOriginalItems(), item, networkToEdit, getEntity().getId(), tempRef_defaultInterfaceName);
        }
    };
    AsyncDataProvider.GetClusterNetworkList(_asyncQuery, getEntity().getvds_group_id());
}
#method_after
public void EditManagementNetwork() {
    if (getWindow() != null) {
        return;
    }
    HostManagementNetworkModel managementNicModel = new HostManagementNetworkModel();
    setWindow(managementNicModel);
    managementNicModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
    // $NON-NLS-1$
    managementNicModel.setHashName("edit_management_network");
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            final HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) model;
            ArrayList<Network> clusterNetworks = (ArrayList<Network>) ReturnValue;
            final VdsNetworkInterface item = (VdsNetworkInterface) hostInterfaceListModel.getSelectedItem();
            final HostManagementNetworkModel managementModel = (HostManagementNetworkModel) hostInterfaceListModel.getWindow();
            Network networkToEdit = Linq.FindNetworkByName(clusterNetworks, item.getNetworkName());
            managementModel.setEntity(networkToEdit);
            managementModel.setNoneBootProtocolAvailable(!item.getIsManagement());
            managementModel.setBootProtocol(!managementModel.getNoneBootProtocolAvailable() && item.getBootProtocol() == NetworkBootProtocol.None ? NetworkBootProtocol.Dhcp : item.getBootProtocol());
            managementModel.getAddress().setEntity(item.getAddress());
            managementModel.getSubnet().setEntity(item.getSubnet());
            managementModel.getGateway().setEntity(item.getGateway());
            final StringBuilder tmpDefaultInterfaceName = new StringBuilder();
            AsyncDataProvider.GetInterfaceOptionsForEditNetwork(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object returnValue) {
                    ArrayList<VdsNetworkInterface> interfaces = (ArrayList<VdsNetworkInterface>) returnValue;
                    String defaultInterfaceName = tmpDefaultInterfaceName.toString();
                    managementModel.getInterface().setItems(interfaces);
                    managementModel.getInterface().setSelectedItem(Linq.FindInterfaceByName(Linq.VdsNetworkInterfaceListToBase(interfaces), defaultInterfaceName));
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getInterface().setTitle(ConstantsManager.getInstance().getConstants().interfaceListTitle());
                        managementModel.getInterface().getSelectedItemChangedEvent().addListener(hostInterfaceListModel);
                    }
                    managementModel.getCheckConnectivity().setIsAvailable(true);
                    managementModel.getCheckConnectivity().setIsChangable(true);
                    // currently, always should be
                    managementModel.getCheckConnectivity().setEntity(item.getIsManagement());
                    // true
                    managementModel.getBondingOptions().setIsAvailable(false);
                    if (item.getBonded() != null && item.getBonded().equals(true)) {
                        managementModel.getBondingOptions().setIsAvailable(true);
                        Map.Entry<String, EntityModel> defaultItem = null;
                        RefObject<Map.Entry<String, EntityModel>> tempRef_defaultItem = new RefObject<Map.Entry<String, EntityModel>>(defaultItem);
                        ArrayList<Map.Entry<String, EntityModel>> list = DataProvider.GetBondingOptionList(tempRef_defaultItem);
                        defaultItem = tempRef_defaultItem.argvalue;
                        Map.Entry<String, EntityModel> selectBondingOpt = new KeyValuePairCompat<String, EntityModel>();
                        boolean containsSelectBondingOpt = false;
                        managementModel.getBondingOptions().setItems(list);
                        for (int i = 0; i < list.size(); i++) {
                            if (StringHelper.stringsEqual(list.get(i).getKey(), item.getBondOptions())) {
                                selectBondingOpt = list.get(i);
                                containsSelectBondingOpt = true;
                                break;
                            }
                        }
                        if (containsSelectBondingOpt == false) {
                            if (StringHelper.stringsEqual(item.getBondOptions(), DataProvider.GetDefaultBondingOption())) {
                                selectBondingOpt = defaultItem;
                            } else {
                                selectBondingOpt = list.get(list.size() - 1);
                                EntityModel entityModel = selectBondingOpt.getValue();
                                entityModel.setEntity(item.getBondOptions());
                            }
                        }
                        managementModel.getBondingOptions().setSelectedItem(selectBondingOpt);
                    }
                    // $NON-NLS-1$
                    UICommand tempVar = new UICommand("OnEditManagementNetworkConfirmation", hostInterfaceListModel);
                    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
                    tempVar.setIsDefault(true);
                    managementModel.getCommands().add(tempVar);
                    // $NON-NLS-1$
                    UICommand tempVar2 = new UICommand("Cancel", hostInterfaceListModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                    tempVar2.setIsCancel(true);
                    managementModel.getCommands().add(tempVar2);
                }
            }), getOriginalItems(), item, networkToEdit, getEntity().getId(), tmpDefaultInterfaceName);
        }
    };
    AsyncDataProvider.GetClusterNetworkList(_asyncQuery, getEntity().getvds_group_id());
}
#end_block

#method_before
@Override
protected void templateInited() {
    super.templateInited();
    setupWindowModelFrom(pool.getStaticData());
}
#method_after
protected void templateInited() {
    super.templateInited();
    setupWindowModelFrom(pool.getStaticData());
}
#end_block

#method_before
private void OnCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        Cancel();
        return;
    }
    if (!model.Validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setvm_type(model.getVmType());
    getcurrentVm().setvmt_guid(template.getId());
    getcurrentVm().setvm_name(name);
    getcurrentVm().setvm_os((VmOsType) model.getOSType().getSelectedItem());
    getcurrentVm().setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setvm_description((String) model.getDescription().getEntity());
    getcurrentVm().setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    getcurrentVm().setvds_group_id(newClusterID);
    getcurrentVm().settime_zone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setnum_of_sockets((Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setcpu_per_socket((Integer) model.getTotalCPUCores().getEntity() / (Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setusb_policy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setis_auto_suspend(false);
    getcurrentVm().setis_stateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setdefault_boot_sequence(model.getBootSequence());
    getcurrentVm().setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setinitrd_url((String) model.getInitrd_path().getEntity());
    getcurrentVm().setkernel_url((String) model.getKernel_path().getEntity());
    getcurrentVm().setkernel_params((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties((String) model.getCustomProperties().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setpriority((Integer) prioritySelectedItem.getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    getcurrentVm().setdedicated_vm_for_vds((Boolean) model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    storage_domains storageDomain = ((storage_domains) model.getDisksAllocationModel().getStorageDomain().getSelectedItem());
    ArrayList<DiskImage> diskInfoList = CreateDiskInfoList();
    if ((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()) {
        for (Guid key : imageToDestinationDomainMap.keySet()) {
            ArrayList<Guid> storageIdList = new ArrayList<Guid>();
            storageIdList.add(storageDomain.getId());
            DiskImage diskImage = new DiskImage();
            diskImage.setstorage_ids(storageIdList);
            imageToDestinationDomainMap.put(key, diskImage);
        }
    }
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.Cancel();
                vmSnapshotListModel.UpdateActionAvailability();
            }
        }
    }, this);
}
#method_after
private void OnCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        Cancel();
        return;
    }
    if (!model.Validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setvm_type(model.getVmType());
    getcurrentVm().setvmt_guid(template.getId());
    getcurrentVm().setvm_name(name);
    getcurrentVm().setvm_os((VmOsType) model.getOSType().getSelectedItem());
    getcurrentVm().setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setvm_description((String) model.getDescription().getEntity());
    getcurrentVm().setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    getcurrentVm().setvds_group_id(newClusterID);
    getcurrentVm().settime_zone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setnum_of_sockets((Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setcpu_per_socket((Integer) model.getTotalCPUCores().getEntity() / (Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setusb_policy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setis_auto_suspend(false);
    getcurrentVm().setis_stateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setdefault_boot_sequence(model.getBootSequence());
    getcurrentVm().setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setinitrd_url((String) model.getInitrd_path().getEntity());
    getcurrentVm().setkernel_url((String) model.getKernel_path().getEntity());
    getcurrentVm().setkernel_params((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties((String) model.getCustomProperties().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setpriority((Integer) prioritySelectedItem.getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    getcurrentVm().setdedicated_vm_for_vds((Boolean) model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    storage_domains storageDomain = ((storage_domains) model.getDisksAllocationModel().getStorageDomain().getSelectedItem());
    ArrayList<DiskImage> diskInfoList = CreateDiskInfoList();
    if ((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()) {
        for (Guid key : imageToDestinationDomainMap.keySet()) {
            ArrayList<Guid> storageIdList = new ArrayList<Guid>();
            storageIdList.add(storageDomain.getId());
            DiskImage diskImage = new DiskImage();
            diskImage.setstorage_ids(storageIdList);
            imageToDestinationDomainMap.put(key, diskImage);
        }
    }
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.Cancel();
                vmSnapshotListModel.UpdateActionAvailability();
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    EndActionOnDisks();
    if (getVm() != null) {
        tryBackToVmConfigurationSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndSuccessfully() {
    EndActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm().getDynamicData(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    Guid previousActiveSnapshotId = TransactionSupport.executeInNewTransaction(new TransactionMethod<Guid>() {

        @Override
        public Guid runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId);
            getCompensationContext().stateChanged();
            return previousActiveSnapshotId;
        }
    });
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParemeters(getParameters());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    } else {
        freeLock();
        tryBackToVmConfigurationSnapshot();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    Guid previousActiveSnapshotId = TransactionSupport.executeInNewTransaction(new TransactionMethod<Guid>() {

        @Override
        public Guid runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId);
            getCompensationContext().stateChanged();
            return previousActiveSnapshotId;
        }
    });
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParemeters(getParameters());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    } else {
        restoreVmConfigFromSnapshot();
        freeLock();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    getVmDAO().get(getVmId());
    getReturnValue().setCanDoAction(validate(validateVmNotDuringSnapshot()));
    if (!validateSnapshotExists()) {
        getReturnValue().setCanDoAction(false);
    }
    if (!validateImages()) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (!validateImageNotInTemplate()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (!validateImageNotActive()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initializeObjectState();
    if (!validateVmNotDuringSnapshot()) {
        handleCanDoActionFailure();
        return false;
    }
    if (!validateSnapshotExists()) {
        handleCanDoActionFailure();
        return false;
    }
    if (!validateImagesAndVMStates()) {
        handleCanDoActionFailure();
        return false;
    }
    if (hasImages()) {
        // check that we are not deleting the template
        if (!validateImageNotInTemplate()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
            handleCanDoActionFailure();
            return false;
        }
        // check that we are not deleting the vm working snapshot
        if (!validateImageNotActive()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
            handleCanDoActionFailure();
            return false;
        }
    }
    getReturnValue().setCanDoAction(true);
    return true;
}
#end_block

#method_before
protected ValidationResult validateVmNotDuringSnapshot() {
    return createSnapshotValidator().vmNotDuringSnapshot(getVmId());
}
#method_after
protected boolean validateVmNotDuringSnapshot() {
    return validate(createSnapshotValidator().vmNotDuringSnapshot(getVmId()));
}
#end_block

#method_before
protected boolean validateImageNotInTemplate() {
    if (!hasImages()) {
        return true;
    }
    return getVmTemplateDAO().get(getRepresentativeSourceImageId()) == null;
}
#method_after
protected boolean validateImageNotInTemplate() {
    return getVmTemplateDAO().get(getRepresentativeSourceImageId()) == null;
}
#end_block

#method_before
protected boolean validateImageNotActive() {
    if (!hasImages()) {
        return true;
    }
    return getDiskImageDAO().get(getRepresentativeSourceImageId()) == null;
}
#method_after
protected boolean validateImageNotActive() {
    return getDiskImageDAO().get(getRepresentativeSourceImageId()) == null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    initializeObjectState();
    // Since 'VmId' is overriden, 'Vm' should be retrieved manually.
    getVmDAO().get(getVmId());
    getReturnValue().setCanDoAction(validate(validateVmNotDuringSnapshot()));
    if (!validateSnapshotExists()) {
        getReturnValue().setCanDoAction(false);
    }
    if (!validateImages()) {
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the template
    if (!validateImageNotInTemplate()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        getReturnValue().setCanDoAction(false);
    }
    // check that we are not deleting the vm working snapshot
    if (!validateImageNotActive()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        getReturnValue().setCanDoAction(false);
    }
    if (!getReturnValue().getCanDoAction()) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    }
    return getReturnValue().getCanDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    initializeObjectState();
    if (!validateVmNotDuringSnapshot()) {
        handleCanDoActionFailure();
        return false;
    }
    if (!validateSnapshotExists()) {
        handleCanDoActionFailure();
        return false;
    }
    if (!validateImages()) {
        handleCanDoActionFailure();
        return false;
    }
    // check that we are not deleting the template
    if (!validateImageNotInTemplate()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_IMAGE_TEMPLATE);
        handleCanDoActionFailure();
        return false;
    }
    // check that we are not deleting the vm working snapshot
    if (!validateImageNotActive()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_ACTIVE_IMAGE);
        handleCanDoActionFailure();
        return false;
    }
    getReturnValue().setCanDoAction(true);
    return true;
}
#end_block

#method_before
protected ValidationResult validateVmNotDuringSnapshot() {
    return createSnapshotValidator().vmNotDuringSnapshot(getVmId());
}
#method_after
protected boolean validateVmNotDuringSnapshot() {
    return validate(createSnapshotValidator().vmNotDuringSnapshot(getVmId()));
}
#end_block

#method_before
protected boolean HandleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean HandleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p);
    return taskID;
}
#method_after
@Override
protected SPMAsyncTask ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p);
}
#end_block

#method_before
protected void initStorageDomainId() {
    if (GuidUtils.isEmpty(getParameters().getStorageDomainId()) && hasDiskImage()) {
        setStorageDomainId(getDiskImage().getstorage_ids().get(0));
    }
}
#method_after
protected void initStorageDomainId() {
    if ((getParameters().getStorageDomainId() == null || Guid.Empty.equals(getParameters().getStorageDomainId())) && getDiskImage() != null) {
        setStorageDomainId(getDiskImage().getstorage_ids().get(0));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (hasDiskImage()) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB();
        }
    } else {
        log.warn("RemoveImageCommand::ExecuteCommand: DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParametersForTask(parentCommand, getParameters()), asyncTaskCreationInfo.getStepId(), getCommandId()));
    p.setEntityId(getParameters().getEntityId());
    Guid ret = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p);
    return ret;
}
#method_after
@Override
protected SPMAsyncTask ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParametersForTask(parentCommand, getParameters()), asyncTaskCreationInfo.getStepId(), getCommandId()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p);
}
#end_block

#method_before
private void removeImageFromDB() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            DiskImage diskImage = getDiskImage();
            if (diskImage != null) {
                getDiskImageDynamicDAO().remove(diskImage.getImageId());
                Guid imageTemplate = diskImage.getit_guid();
                Guid currentGuid = diskImage.getImageId();
                // the storage).
                while (!imageTemplate.equals(currentGuid) && !currentGuid.equals(Guid.Empty)) {
                    RemoveChildren(currentGuid);
                    DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                    if (image != null) {
                        RemoveSnapshot(image);
                        removeImageFromSnapshotConfiguration(image.getvm_snapshot_id().getValue(), currentGuid);
                        currentGuid = image.getParentId();
                    } else {
                        currentGuid = Guid.Empty;
                        log.warnFormat("RemoveImageCommand::RemoveImageFromDB: 'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                    }
                }
                getBaseDiskDao().remove(diskImage.getId());
                getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
            } else {
                log.warn("RemoveImageCommand::RemoveImageFromDB: DiskImage is null, nothing to remove.");
            }
            return null;
        }
    });
}
#method_after
private void removeImageFromDB() {
    final DiskImage diskImage = getDiskImage();
    final List<Snapshot> updatedSnapshots = prepareSnapshotConfigWithoutImage(diskImage.getId());
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getDiskImageDynamicDAO().remove(diskImage.getImageId());
            Guid imageTemplate = diskImage.getit_guid();
            Guid currentGuid = diskImage.getImageId();
            // the storage).
            while (!currentGuid.equals(imageTemplate) && !currentGuid.equals(Guid.Empty)) {
                RemoveChildren(currentGuid);
                DiskImage image = getDiskImageDao().getSnapshotById(currentGuid);
                if (image != null) {
                    RemoveSnapshot(image);
                    currentGuid = image.getParentId();
                } else {
                    currentGuid = Guid.Empty;
                    log.warnFormat("'image' (snapshot of image '{0}') is null, cannot remove it.", diskImage.getImageId());
                }
            }
            getBaseDiskDao().remove(diskImage.getId());
            getVmDeviceDAO().remove(new VmDeviceId(diskImage.getId(), null));
            for (Snapshot s : updatedSnapshots) {
                getSnapshotDao().update(s);
            }
            return null;
        }
    });
}
#end_block

#method_before
@SuppressWarnings("serial")
@Before
public void setUp() {
    RemoveImageParameters params = new RemoveImageParameters(Guid.NewGuid());
    cmd = spy(new RemoveImageCommand<RemoveImageParameters>(params) {

        @Override
        protected void initStoragePoolId() {
        // Stub implementation for testing
        }

        @Override
        protected void initStoragePoolByDiskImage() {
        // Stub implementation for testing
        }

        @Override
        protected void initStorageDomainId() {
        // Stub implementation for testing
        }

        @Override
        protected void initDiskImage() {
        // Stub implementation for testing
        }
    });
    doReturn(snapshotDAO).when(cmd).getSnapshotDAO();
}
#method_after
@SuppressWarnings("serial")
@Before
public void setUp() {
    RemoveImageParameters params = new RemoveImageParameters(Guid.NewGuid());
    cmd = spy(new RemoveImageCommand<RemoveImageParameters>(params) {

        @Override
        protected void initImage() {
        // Stub implementation for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub implementation for testing
        }

        @Override
        protected void initStorageDomainId() {
        // Stub implementation for testing
        }

        @Override
        protected void initContainerDetails(ImagesContainterParametersBase parameters) {
        // Stub implementation for testing
        }
    });
    doReturn(snapshotDAO).when(cmd).getSnapshotDao();
}
#end_block

#method_before
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.NewGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setstorage_pool_id(Guid.NewGuid());
    vm.setvmt_name(RandomUtils.instance().nextString(10));
    vm.setorigin(OriginType.OVIRT);
    Guid vmSnapshotId = Guid.NewGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    cmd.removeImageFromSnapshotConfiguration(vmSnapshotId, disk2.getImageId());
    ArgumentCaptor<Snapshot> snapCapture = ArgumentCaptor.forClass(Snapshot.class);
    verify(snapshotDAO).update(snapCapture.capture());
    String actualOvf = snapCapture.getValue().getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#method_after
@Test
public void testRemoveImageFromSnapshotConfiguration() throws OvfReaderException {
    Guid vmId = Guid.NewGuid();
    VM vm = new VM();
    vm.setId(vmId);
    vm.setstorage_pool_id(Guid.NewGuid());
    vm.setvmt_name(RandomUtils.instance().nextString(10));
    vm.setorigin(OriginType.OVIRT);
    Guid vmSnapshotId = Guid.NewGuid();
    DiskImage disk1 = addTestDisk(vm, vmSnapshotId);
    DiskImage disk2 = addTestDisk(vm, vmSnapshotId);
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> disks = new ArrayList<DiskImage>(Arrays.asList(disk1, disk2));
    String ovf = ovfManager.ExportVm(vm, disks);
    Snapshot snap = new Snapshot();
    snap.setVmConfiguration(ovf);
    snap.setId(vmSnapshotId);
    when(snapshotDAO.get(vmSnapshotId)).thenReturn(snap);
    doReturn(disk2).when(cmd).getDiskImage();
    doReturn(disk2).when(cmd).getImage();
    doReturn(disk2.getId()).when(cmd).getImageId();
    Snapshot actual = cmd.prepareSnapshotConfigWithoutImageSingleImage(vmSnapshotId, disk2.getImageId());
    String actualOvf = actual.getVmConfiguration();
    ArrayList<DiskImage> actualImages = new ArrayList<DiskImage>();
    ovfManager.ImportVm(actualOvf, new VM(), actualImages, new ArrayList<VmNetworkInterface>());
    assertEquals("Wrong number of disks", 1, actualImages.size());
    assertEquals("Wrong disk", disk1, actualImages.get(0));
}
#end_block

#method_before
private static DiskImage addTestDisk(VM vm, Guid snapshotId) {
    Guid imageId = Guid.NewGuid();
    DiskImage disk = new DiskImage();
    disk.setImageId(imageId);
    disk.setId(Guid.NewGuid());
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setstorage_pool_id(vm.getstorage_pool_id());
    disk.setAllowSnapshot(true);
    disk.setactive(Boolean.TRUE);
    disk.setvm_snapshot_id(snapshotId);
    disk.setvm_guid(vm.getId());
    disk.setimageStatus(ImageStatus.OK);
    disk.setappList("");
    disk.setdescription("");
    vm.getDiskList().add(disk);
    vm.getDiskMap().put(imageId, disk);
    return disk;
}
#method_after
private static DiskImage addTestDisk(VM vm, Guid snapshotId) {
    Guid imageId = Guid.NewGuid();
    DiskImage disk = new DiskImage();
    disk.setImageId(imageId);
    disk.setId(Guid.NewGuid());
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setstorage_pool_id(vm.getstorage_pool_id());
    disk.setactive(Boolean.TRUE);
    disk.setvm_snapshot_id(snapshotId);
    disk.setvm_guid(vm.getId());
    disk.setimageStatus(ImageStatus.OK);
    disk.setappList("");
    disk.setdescription("");
    vm.getDiskList().add(disk);
    vm.getDiskMap().put(imageId, disk);
    return disk;
}
#end_block

#method_before
protected void RemoveChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<Guid>();
    GetImageChildren(snapshot, children);
    Collections.reverse(children);
    for (Guid child : children) {
        RemoveSnapshot(getDiskImageDao().getSnapshotById(child));
    }
}
#method_after
private void RemoveChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<Guid>();
    GetImageChildren(snapshot, children);
    Collections.reverse(children);
    for (Guid child : children) {
        RemoveSnapshot(getDiskImageDao().getSnapshotById(child));
    }
}
#end_block

#method_before
protected void RemoveChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<Guid>();
    GetImageChildren(snapshot, children);
    Collections.reverse(children);
    for (Guid child : children) {
        RemoveSnapshot(getDiskImageDao().getSnapshotById(child));
    }
}
#method_after
private void RemoveChildren(Guid snapshot) {
    List<Guid> children = new ArrayList<Guid>();
    GetImageChildren(snapshot, children);
    Collections.reverse(children);
    for (Guid child : children) {
        RemoveSnapshot(getDiskImageDao().getSnapshotById(child));
    }
}
#end_block

#method_before
protected void UndoActionOnSourceAndDestination() {
    if (getDestinationDiskImage() != null) {
        RemoveSnapshotFromDB(getDestinationDiskImage());
    }
    if (getDiskImage() != null) {
        // Unlock source image:
        UnLockImage();
    }
}
#method_after
protected void UndoActionOnSourceAndDestination() {
    if (getDestinationDiskImage() != null) {
        RemoveSnapshot(getDestinationDiskImage());
    }
    if (getDiskImage() != null) {
        // Unlock source image:
        UnLockImage();
    }
}
#end_block

#method_before
/**
 * Vitaly TODO: move it other class in hierarchy
 */
protected void RemoveSnapshot(DiskImage snapshot) {
    RemoveSnapshotFromDB(snapshot);
    AdditionalImageRemoveTreatment(snapshot);
}
#method_after
/**
 * Vitaly TODO: move it other class in hierarchy
 */
protected void RemoveSnapshot(DiskImage snapshot) {
    DbFacade.getInstance().getImageStorageDomainMapDao().remove(snapshot.getImageId());
    getImageDao().remove(snapshot.getImageId());
    List<DiskImage> imagesForDisk = getDiskImageDao().getAllSnapshotsForImageGroup(snapshot.getId());
    if (imagesForDisk == null || imagesForDisk.isEmpty()) {
        getBaseDiskDao().remove(snapshot.getId());
    }
}
#end_block

#method_before
protected void UndoActionOnSourceAndDestination() {
    if (getDestinationDiskImage() != null) {
        RemoveSnapshotFromDB(getDestinationDiskImage());
    }
    if (getDiskImage() != null) {
        // Unlock source image:
        UnLockImage();
    }
}
#method_after
protected void UndoActionOnSourceAndDestination() {
    if (getDestinationDiskImage() != null) {
        RemoveSnapshot(getDestinationDiskImage());
    }
    if (getDiskImage() != null) {
        // Unlock source image:
        UnLockImage();
    }
}
#end_block

#method_before
/**
 * Vitaly TODO: move it other class in hierarchy
 */
protected void RemoveSnapshot(DiskImage snapshot) {
    RemoveSnapshotFromDB(snapshot);
    AdditionalImageRemoveTreatment(snapshot);
}
#method_after
/**
 * Vitaly TODO: move it other class in hierarchy
 */
protected void RemoveSnapshot(DiskImage snapshot) {
    DbFacade.getInstance().getImageStorageDomainMapDao().remove(snapshot.getImageId());
    getImageDao().remove(snapshot.getImageId());
    List<DiskImage> imagesForDisk = getDiskImageDao().getAllSnapshotsForImageGroup(snapshot.getId());
    if (imagesForDisk == null || imagesForDisk.isEmpty()) {
        getBaseDiskDao().remove(snapshot.getId());
    }
}
#end_block

#method_before
@Override
protected boolean validateInputs() {
    if (!super.validateInputs()) {
        return false;
    }
    VdcQueryReturnValue returnValue = getQueryReturnValue();
    returnValue.setExceptionString("");
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isBlank(hostName)) {
            returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
            return false;
        }
        List<VDS> vdssByUniqueId = getVdssByUniqueId();
        if (vdssByUniqueId.size() > 1) {
            returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
            return false;
        }
        if (vdssByUniqueId.size() == 1) {
            VDS vds = vdssByUniqueId.get(0);
            if (!VdsHandler.isPendingOvirt(vds)) {
                returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                return false;
            }
            Long otp = getParameters().getOtp();
            if (otp != null && !isValidOtp(vds, otp)) {
                returnValue.setExceptionString(String.format("Invalid OTP for host %s", hostName));
                return false;
            }
        }
    } catch (RuntimeException ex) {
        log.error(ex);
        returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validateInputs() {
    if (!super.validateInputs()) {
        return false;
    }
    VdcQueryReturnValue returnValue = getQueryReturnValue();
    returnValue.setExceptionString("");
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isEmpty(hostName)) {
            returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
            return false;
        }
        List<VDS> vdssByUniqueId = getVdssByUniqueId();
        if (vdssByUniqueId.size() > 1) {
            returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
            return false;
        }
        if (vdssByUniqueId.size() == 1) {
            VDS vds = vdssByUniqueId.get(0);
            if (!VdsHandler.isPendingOvirt(vds)) {
                returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                return false;
            }
            Long otp = getParameters().getOtp();
            if (otp != null && !isValidOtp(vds, otp)) {
                returnValue.setExceptionString(String.format("Invalid OTP for host %s", hostName));
                return false;
            }
        }
    } catch (RuntimeException ex) {
        log.error(ex);
        returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
        return false;
    }
    return true;
}
#end_block

#method_before
protected void ExecuteRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringUtils.isBlank(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#method_after
protected void ExecuteRegisterVdsCommand() {
    synchronized (doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validateInputs() {
    boolean result = super.validateInputs();
    if (result) {
        returnValue.setExceptionString("");
        try {
            String hostName = getParameters().getVdsHostName();
            if (StringUtils.isBlank(hostName)) {
                returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
                result = false;
            } else {
                List<VDS> vdssByUniqueId = getVdssByUniqueId();
                if (vdssByUniqueId.size() > 1) {
                    returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
                    result = false;
                } else if (vdssByUniqueId.size() == 1) {
                    VDS vds = vdssByUniqueId.get(0);
                    if (!VdsHandler.isPendingOvirt(vds)) {
                        returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                        result = false;
                    } else {
                        Long otp = getParameters().getOtp();
                        if (otp != null && !isValidOtp(vds, otp)) {
                            returnValue.setExceptionString(String.format("Invalid OTP for host %s", hostName));
                            result = false;
                        }
                    }
                }
            }
        } catch (RuntimeException ex) {
            log.error("RegisterVdsQuery::CanDoAction: An exception has been thrown.", ex);
            returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean validateInputs() {
    if (!super.validateInputs()) {
        return false;
    }
    VdcQueryReturnValue returnValue = getQueryReturnValue();
    returnValue.setExceptionString("");
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isEmpty(hostName)) {
            returnValue.setExceptionString("Cannot register Host - no Hostname address specified.");
            return false;
        }
        List<VDS> vdssByUniqueId = getVdssByUniqueId();
        if (vdssByUniqueId.size() > 1) {
            returnValue.setExceptionString("Cannot register Host - unique id is ambigious.");
            return false;
        }
        if (vdssByUniqueId.size() == 1) {
            VDS vds = vdssByUniqueId.get(0);
            if (!VdsHandler.isPendingOvirt(vds)) {
                returnValue.setExceptionString(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name());
                return false;
            }
            Long otp = getParameters().getOtp();
            if (otp != null && !isValidOtp(vds, otp)) {
                returnValue.setExceptionString(String.format("Invalid OTP for host %s", hostName));
                return false;
            }
        }
    } catch (RuntimeException ex) {
        log.error(ex);
        returnValue.setExceptionString(String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage()));
        return false;
    }
    return true;
}
#end_block

#method_before
protected void ExecuteRegisterVdsCommand() {
    synchronized (_doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringUtils.isBlank(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        _logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#method_after
protected void ExecuteRegisterVdsCommand() {
    synchronized (_doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        _logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unused")
protected boolean canPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return true;
}
#method_after
protected boolean canPerformRollbackUsingCommand(@SuppressWarnings("unused") VdcActionType commandType, @SuppressWarnings("unused") VdcActionParametersBase params) {
    return true;
}
#end_block

#method_before
@SuppressWarnings("unused")
protected SPMAsyncTask ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#method_after
protected SPMAsyncTask ConcreteCreateTask(@SuppressWarnings("unused") AsyncTaskCreationInfo asyncTaskCreationInfo, @SuppressWarnings("unused") VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void testGetStrippedVdsUniqueIdWithUnacceptedChars() {
    RegisterVdsParameters paramsMock = getQueryParameters();
    when(paramsMock.getVdsUniqueId()).thenReturn("Test_^123^");
    String result = getQuery().getStrippedVdsUniqueId();
    assertEquals("Test_123", result);
}
#method_after
@Test
public void testGetStrippedVdsUniqueIdWithUnacceptedChars() {
    String result = this.gerStrippedVdsUniqueId("Test_123");
    assertEquals("Vds id doesn't equal to the expected value", "Test_123", result);
}
#end_block

#method_before
@Test
public void testGetStrippedVdsUniqueIdOnlyAllowrdChars() {
    RegisterVdsParameters paramsMock = getQueryParameters();
    when(paramsMock.getVdsUniqueId()).thenReturn("Test_123");
    String result = getQuery().getStrippedVdsUniqueId();
    assertEquals("Test_123", result);
}
#method_after
@Test
public void testGetStrippedVdsUniqueIdOnlyAllowrdChars() {
    String result = this.gerStrippedVdsUniqueId("Test_123");
    assertEquals("Vds id doesn't equal to the expected value", "Test_123", result);
}
#end_block

#method_before
@Test
public void testGetStrippedVdsUniqueIdWithoutValidChars() {
    RegisterVdsParameters paramsMock = getQueryParameters();
    when(paramsMock.getVdsUniqueId()).thenReturn("^%^");
    String result = getQuery().getStrippedVdsUniqueId();
    assertEquals("", result);
}
#method_after
@Test
public void testGetStrippedVdsUniqueIdWithoutValidChars() {
    String result = this.gerStrippedVdsUniqueId("^%^");
    assertEquals("Vds id is not empty as expected", "", result);
}
#end_block

#method_before
protected boolean CanDoAction(RefObject<String> errorMessage) {
    boolean returnValue = true;
    errorMessage.argvalue = "";
    Long otp = getParameters().getOtp();
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringHelper.isNullOrEmpty(hostName)) {
            errorMessage.argvalue = "Cannot register Host - no Hostname address specified.";
            returnValue = false;
        } else {
            List<VDS> vdssByUniqueId = getVdssByUniqueId();
            if (vdssByUniqueId.size() > 1) {
                errorMessage.argvalue = "Cannot register Host - unique id is ambigious.";
                returnValue = false;
            } else if (vdssByUniqueId.size() == 1) {
                VDS vds = vdssByUniqueId.get(0);
                if (!VdsHandler.isPendingOvirt(vds)) {
                    errorMessage.argvalue = String.format("Illegal Host status %s and/or type %s for host %s, expected %s type with %s status.", vds.getstatus().name(), vds.getvds_type().name(), vds.getvds_name(), VDSType.oVirtNode.name(), VDSStatus.PendingApproval.name());
                    errorMessage.argvalue = VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name();
                    returnValue = false;
                } else if (otp != null && !isValidOtp(vds, otp)) {
                    errorMessage.argvalue = "Invalid OTP for host " + hostName;
                    returnValue = false;
                }
            }
        }
    } catch (RuntimeException ex) {
        log.error("RegisterVdsQuery::CanDoAction: An exception has been thrown.", ex);
        errorMessage.argvalue = String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage());
        returnValue = false;
    }
    return returnValue;
}
#method_after
protected boolean CanDoAction(RefObject<String> errorMessage) {
    boolean returnValue = true;
    errorMessage.argvalue = "";
    Long otp = getParameters().getOtp();
    try {
        String hostName = getParameters().getVdsHostName();
        if (StringUtils.isEmpty(hostName)) {
            errorMessage.argvalue = "Cannot register Host - no Hostname address specified.";
            returnValue = false;
        } else {
            List<VDS> vdssByUniqueId = getVdssByUniqueId();
            if (vdssByUniqueId.size() > 1) {
                errorMessage.argvalue = "Cannot register Host - unique id is ambigious.";
                returnValue = false;
            } else if (vdssByUniqueId.size() == 1) {
                VDS vds = vdssByUniqueId.get(0);
                if (!VdsHandler.isPendingOvirt(vds)) {
                    errorMessage.argvalue = String.format("Illegal Host status %s and/or type %s for host %s, expected %s type with %s status.", vds.getstatus().name(), vds.getvds_type().name(), vds.getvds_name(), VDSType.oVirtNode.name(), VDSStatus.PendingApproval.name());
                    errorMessage.argvalue = VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE.name();
                    returnValue = false;
                } else if (otp != null && !isValidOtp(vds, otp)) {
                    errorMessage.argvalue = "Invalid OTP for host " + hostName;
                    returnValue = false;
                }
            }
        }
    } catch (RuntimeException ex) {
        log.error("RegisterVdsQuery::CanDoAction: An exception has been thrown.", ex);
        errorMessage.argvalue = String.format("Cannot register Host - An exception has been thrown: %1$s", ex.getMessage());
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void ExecuteRegisterVdsCommand() {
    synchronized (_doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringHelper.isNullOrEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        _logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#method_after
protected void ExecuteRegisterVdsCommand() {
    synchronized (_doubleRegistrationLock) {
        // force to reload vdss by unique ID used later on
        _vdssByUniqueId = null;
        VDS vdsByUniqueId = getVdssByUniqueId().size() != 0 ? getVdssByUniqueId().get(0) : null;
        // in case oVirt host was added for the second time - perform approval
        if (vdsByUniqueId != null && vdsByUniqueId.getstatus() == VDSStatus.PendingApproval && getParameters().getVdsType() == VDSType.oVirtNode && getParameters().getOtp() != null) {
            getQueryReturnValue().setSucceeded(dispatchOvirtApprovalCommand(vdsByUniqueId.getId()));
            return;
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.info("RegisterVdsQuery::ExecuteCommand - Entering");
        }
        if (StringUtils.isEmpty(getParameters().getVdsName())) {
            getParameters().setVdsName(getParameters().getVdsUniqueId());
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.info("RegisterVdsQuery::ExecuteCommand - VdsName empty, using VdsUnique ID as name");
            }
        }
        _logable.AddCustomValue("VdsName1", getParameters().getVdsName());
        Guid vdsGroupId;
        if (getParameters().getVdsGroupId().equals(Guid.Empty)) {
            vdsGroupId = new Guid(Config.<String>GetValue(ConfigValues.PowerClientAutoRegistrationDefaultVdsGroupID));
            if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
                log.infoFormat("RegisterVdsQuery::ExecuteCommand - VdsGroupId recieved as -1, using PowerClientAutoRegistrationDefaultVdsGroupID: {0}", vdsGroupId);
            }
        } else {
            vdsGroupId = getParameters().getVdsGroupId();
        }
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration) && vdsByUniqueId != null) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - found vds {0} with existing Unique Id {1}.  Will try to update existing vds", vdsByUniqueId.getId(), vdsByUniqueId.getUniqueId());
        }
        // TODO: always add in pending state, and if auto approve call
        // approve command action after registration
        RefObject<Boolean> isPending = new RefObject<Boolean>(Boolean.FALSE);
        getQueryReturnValue().setSucceeded(HandleOldVdssWithSameHostName(vdsByUniqueId) && HandleOldVdssWithSameName(vdsByUniqueId) && CheckAutoApprovalDefinitions(isPending) && Register(vdsByUniqueId, vdsGroupId, isPending.argvalue.booleanValue()));
        if (Config.<Boolean>GetValue(ConfigValues.LogVdsRegistration)) {
            log.infoFormat("RegisterVdsQuery::ExecuteCommand - Leaving Succeded value is {0}", getQueryReturnValue().getSucceeded());
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    if (getVm().getstatus() == VMStatus.Up) {
        runVdsCommand(getParameters().getAction().getCommandType(), new HotPlugUnplgNicVDSParameters(getVm().getrun_on_vds().getValue(), getVm().getId(), DbFacade.getInstance().getVmNetworkInterfaceDAO().get(getParameters().getNicId()), vmDevice));
    }
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    if (getVm().getstatus() == VMStatus.Up) {
        runVdsCommand(getParameters().getAction().getCommandType(), new HotPlugUnplgNicVDSParameters(getVm().getrun_on_vds().getValue(), getVm().getId(), DbFacade.getInstance().getVmNetworkInterfaceDAO().get(getParameters().getNicId()), vmDevice));
    }
    TransactionSupport.executeInNewTransaction(updateDevice());
    VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__DEACTIVATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage((getParameters().getAction() == PlugAction.PLUG) ? VdcBllMessages.VAR__ACTION__ACTIVATE : VdcBllMessages.VAR__ACTION__DEACTIVATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry.getDomainsConfigurationEntry(), adUserNameEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry.getDomainsConfigurationEntry(), adPasswordEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry.getDomainsConfigurationEntry(), ldapServersEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry.getDomainsConfigurationEntry(), adUserIdEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry.getDomainsConfigurationEntry(), authModeEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry.getDomainsConfigurationEntry(), domainNameEntry.getDomainsLoggingEntry());
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry.getDomainsConfigurationEntry(), ldapProviderTypeEntry.getDomainsLoggingEntry());
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("spUUID = %s, poolVersion = %s", getStoragePoolId().toString(), getCompatibilityVersion());
}
#method_after
@Override
public String toString() {
    return String.format("storagePoolId = %s, poolVersion = %s", getStoragePoolId(), getCompatibilityVersion());
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.createVolume(sdUUID, spUUID, imgGUID, size, volFormat, volType, diskType, volUUID, descr, srcImgGUID, srcVolUUID);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.createVolume(sdUUID, spUUID, imgGUID, size, volFormat, volType, diskType, volUUID, descr, srcImgGUID, srcVolUUID);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.copyImage(sdUUID, spUUID, vmGUID, srcImgGUID, srcVolUUID, dstImgGUID, dstVolUUID, descr, dstSdUUID, volType, volFormat, preallocate, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.copyImage(sdUUID, spUUID, vmGUID, srcImgGUID, srcVolUUID, dstImgGUID, dstVolUUID, descr, dstSdUUID, volType, volFormat, preallocate, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setVolumeDescription(sdUUID, spUUID, imgGUID, volUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setVolumeDescription(sdUUID, spUUID, imgGUID, volUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    Map<String, Object> xmlRpcReturnValue = irsServer.mergeSnapshots(sdUUID, spUUID, vmGUID, imgGUID, ancestorUUID, successorUUID, postZero);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    Map<String, Object> xmlRpcReturnValue = irsServer.mergeSnapshots(sdUUID, spUUID, vmGUID, imgGUID, ancestorUUID, successorUUID, postZero);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deleteVolume(sdUUID, spUUID, imgGUID, volUUID, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deleteVolume(sdUUID, spUUID, imgGUID, volUUID, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneImageInfoReturnForXmlRpc getVolumeInfo(String sdUUID, String spUUID, String imgGUID, String volUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVolumeInfo(sdUUID, spUUID, imgGUID, volUUID);
    OneImageInfoReturnForXmlRpc wrapper = new OneImageInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneImageInfoReturnForXmlRpc getVolumeInfo(String sdUUID, String spUUID, String imgGUID, String volUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVolumeInfo(sdUUID, spUUID, imgGUID, volUUID);
    OneImageInfoReturnForXmlRpc wrapper = new OneImageInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public IrsStatsAndStatusXmlRpc getIrsStats() {
    Map<String, Object> xmlRpcReturnValue = irsServer.getStats();
    IrsStatsAndStatusXmlRpc wrapper = new IrsStatsAndStatusXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public IrsStatsAndStatusXmlRpc getIrsStats() {
    Map<String, Object> xmlRpcReturnValue = irsServer.getStats();
    IrsStatsAndStatusXmlRpc wrapper = new IrsStatsAndStatusXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc exportCandidate(String sdUUID, String vmGUID, String[] volumesList, String vmMeta, String templateGUID, String templateVolGUID, String templateMeta, String expPath, String collapse, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.exportCandidate(sdUUID, vmGUID, volumesList, vmMeta, templateGUID, templateVolGUID, templateMeta, expPath, collapse, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc exportCandidate(String sdUUID, String vmGUID, String[] volumesList, String vmMeta, String templateGUID, String templateVolGUID, String templateMeta, String expPath, String collapse, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.exportCandidate(sdUUID, vmGUID, volumesList, vmMeta, templateGUID, templateVolGUID, templateMeta, expPath, collapse, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc importCandidate(String sdUUID, String vmGUID, String templateGUID, String templateVolGUID, String path, String type, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.importCandidate(sdUUID, vmGUID, templateGUID, templateVolGUID, path, type, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc importCandidate(String sdUUID, String vmGUID, String templateGUID, String templateVolGUID, String path, String type, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.importCandidate(sdUUID, vmGUID, templateGUID, templateVolGUID, path, type, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public IsoListReturnForXmlRpc getIsoList(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getIsoList(spUUID);
    IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public IsoListReturnForXmlRpc getIsoList(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getIsoList(spUUID);
    IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public IsoListReturnForXmlRpc getFloppyList(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getFloppyList(spUUID);
    IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public IsoListReturnForXmlRpc getFloppyList(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getFloppyList(spUUID);
    IsoListReturnForXmlRpc wrapper = new IsoListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extendVolume(String sdUUID, String spUUID, String imgGUID, String volUUID, int newSize) {
    Map<String, Object> xmlRpcReturnValue = irsServer.extendVolume(sdUUID, spUUID, imgGUID, volUUID, newSize);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc extendVolume(String sdUUID, String spUUID, String imgGUID, String volUUID, int newSize) {
    Map<String, Object> xmlRpcReturnValue = irsServer.extendVolume(sdUUID, spUUID, imgGUID, volUUID, newSize);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StorageStatusReturnForXmlRpc activateStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.activateStorageDomain(sdUUID, spUUID);
    StorageStatusReturnForXmlRpc wrapper = new StorageStatusReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StorageStatusReturnForXmlRpc activateStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.activateStorageDomain(sdUUID, spUUID);
    StorageStatusReturnForXmlRpc wrapper = new StorageStatusReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deactivateStorageDomain(sdUUID, spUUID, msdUUID, masterVersion);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deactivateStorageDomain(sdUUID, spUUID, msdUUID, masterVersion);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.detachStorageDomain(sdUUID, spUUID, msdUUID, masterVersion);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.detachStorageDomain(sdUUID, spUUID, msdUUID, masterVersion);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc forcedDetachStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.forcedDetachStorageDomain(sdUUID, spUUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc forcedDetachStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.forcedDetachStorageDomain(sdUUID, spUUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc attachStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.attachStorageDomain(sdUUID, spUUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc attachStorageDomain(String sdUUID, String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.attachStorageDomain(sdUUID, spUUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setStorageDomainDescription(String sdUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setStorageDomainDescription(sdUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc setStorageDomainDescription(String sdUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setStorageDomainDescription(sdUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc reconstructMaster(String spUUID, String msdUUID, String masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.reconstructMaster(spUUID, msdUUID, masterVersion);
    StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StorageDomainListReturnForXmlRpc reconstructMaster(String spUUID, int hostSpmId, String msdUUID, String masterVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.reconstructMaster(spUUID, hostSpmId, msdUUID, masterVersion);
    StorageDomainListReturnForXmlRpc wrapper = new StorageDomainListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extendStorageDomain(String sdUUID, String spUUID, String[] devlist) {
    Map<String, Object> xmlRpcReturnValue = irsServer.extendStorageDomain(sdUUID, spUUID, devlist);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc extendStorageDomain(String sdUUID, String spUUID, String[] devlist) {
    Map<String, Object> xmlRpcReturnValue = irsServer.extendStorageDomain(sdUUID, spUUID, devlist);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setStoragePoolDescription(String spUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setStoragePoolDescription(spUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc setStoragePoolDescription(String spUUID, String description) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setStoragePoolDescription(spUUID, description);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getStoragePoolInfo(spUUID);
    StoragePoolInfoReturnForXmlRpc wrapper = new StoragePoolInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getStoragePoolInfo(spUUID);
    StoragePoolInfoReturnForXmlRpc wrapper = new StoragePoolInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    Map<String, Object> xmlRpcReturnValue = irsServer.destroyStoragePool(spUUID, hostSpmId, SCSIKey);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    Map<String, Object> xmlRpcReturnValue = irsServer.destroyStoragePool(spUUID, hostSpmId, SCSIKey);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deleteImage(sdUUID, spUUID, imgGUID, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.deleteImage(sdUUID, spUUID, imgGUID, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.moveImage(spUUID, srcDomUUID, dstDomUUID, imgGUID, vmGUID, op, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    Map<String, Object> xmlRpcReturnValue = irsServer.moveImage(spUUID, srcDomUUID, dstDomUUID, imgGUID, vmGUID, op, postZero, force);
    OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StorageDomainGuidListReturnForXmlRpc getImageDomainsList(String spUUID, String imgUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getImageDomainsList(spUUID, imgUUID);
    StorageDomainGuidListReturnForXmlRpc wrapper = new StorageDomainGuidListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StorageDomainGuidListReturnForXmlRpc getImageDomainsList(String spUUID, String imgUUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getImageDomainsList(spUUID, imgUUID);
    StorageDomainGuidListReturnForXmlRpc wrapper = new StorageDomainGuidListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setMaxHosts(int maxHosts) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setMaxHosts(maxHosts);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc setMaxHosts(int maxHosts) {
    Map<String, Object> xmlRpcReturnValue = irsServer.setMaxHosts(maxHosts);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.removeVM(spUUID, vmGUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID) {
    Map<String, Object> xmlRpcReturnValue = irsServer.removeVM(spUUID, vmGUID);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID, String storageDomainId) {
    Map<String, Object> xmlRpcReturnValue = irsServer.removeVM(spUUID, vmGUID, storageDomainId);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID, String storageDomainId) {
    Map<String, Object> xmlRpcReturnValue = irsServer.removeVM(spUUID, vmGUID, storageDomainId);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public GetVmsInfoReturnForXmlRpc getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVmsInfo(storagePoolId, storageDomainId, VMIDList);
    GetVmsInfoReturnForXmlRpc wrapper = new GetVmsInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public GetVmsInfoReturnForXmlRpc getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVmsInfo(storagePoolId, storageDomainId, VMIDList);
    GetVmsInfoReturnForXmlRpc wrapper = new GetVmsInfoReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public GetVmsListReturnForXmlRpc getVmsList(String storagePoolId, String storageDomainId) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVmsList(storagePoolId, storageDomainId);
    GetVmsListReturnForXmlRpc wrapper = new GetVmsListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public GetVmsListReturnForXmlRpc getVmsList(String storagePoolId, String storageDomainId) {
    Map<String, Object> xmlRpcReturnValue = irsServer.getVmsList(storagePoolId, storageDomainId);
    GetVmsListReturnForXmlRpc wrapper = new GetVmsListReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc upgradeStoragePool(String storagePoolId, String targetVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.upgradeStoragePool(storagePoolId, targetVersion);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
public StatusOnlyReturnForXmlRpc upgradeStoragePool(String storagePoolId, String targetVersion) {
    Map<String, Object> xmlRpcReturnValue = irsServer.upgradeStoragePool(storagePoolId, targetVersion);
    return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
}
#end_block

#method_before
@Override
protected void ExecuteIrsBrokerCommand() {
    P params = getParameters();
    String spUUIDstr = params.getStoragePoolId().toString();
    String targetVersion = params.getCompatibilityVersion();
    log.info("-- UpgradeStoragePoolVDSCommand::ExecuteIrsBrokerCommand: calling 'upgradeStoragePool' with two new parameters: poolVersion and UUID");
    log.infoFormat("-- upgradeStoragePool parameters:\r\n" + "spUUID={0}\r\n" + "version={1}\r\n", spUUIDstr, targetVersion);
    status = getIrsProxy().upgradeStoragePool(spUUIDstr, targetVersion);
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteIrsBrokerCommand() {
    final P params = getParameters();
    final String storagePoolId = params.getStoragePoolId().toString();
    final String targetVersion = params.getCompatibilityVersion();
    log.infoFormat("Upgrading storage pool {0} to version {1}", storagePoolId, targetVersion);
    status = getIrsProxy().upgradeStoragePool(storagePoolId, targetVersion);
    ProceedProxyReturnValue();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // the default quota configuration.
    if ((_oldStoragePool.getQuotaEnforcementType() == QuotaEnforcmentTypeEnum.DISABLED) && (getStoragePool().getQuotaEnforcementType() != QuotaEnforcmentTypeEnum.DISABLED)) {
        QuotaHelper.getInstance().setDefaultQuotaAsRegularQuota(_oldStoragePool);
    }
    storage_pool storagePool = getStoragePool();
    getStoragePoolDAO().updatePartial(storagePool);
    updateStoragePoolFormatType();
    if (storagePool.getstatus() != StoragePoolStatus.Up) {
        setSucceeded(true);
        return;
    }
    String spName = storagePool.getname();
    Guid spId = storagePool.getId();
    VDSBrokerFrontend resourceManager = Backend.getInstance().getResourceManager();
    if (!StringHelper.EqOp(_oldStoragePool.getname(), spName)) {
        SetStoragePoolDescriptionVDSCommandParameters parameters = new SetStoragePoolDescriptionVDSCommandParameters(spId, spName);
        resourceManager.RunVdsCommand(VDSCommandType.SetStoragePoolDescription, parameters);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateDefaultQuota();
    if (_oldStoragePool.getstatus() == StoragePoolStatus.Up) {
        if (!StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname())) {
            runVdsCommand(VDSCommandType.SetStoragePoolDescription, new SetStoragePoolDescriptionVDSCommandParameters(getStoragePool().getId(), getStoragePool().getname()));
            getStoragePoolDAO().updatePartial(getStoragePool());
        }
    }
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    storage_pool storagePool = getStoragePool();
    Guid spId = storagePool.getId();
    VDSBrokerFrontend resourceManager = Backend.getInstance().getResourceManager();
    Version spVersion = storagePool.getcompatibility_version();
    // Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    // if (Version.OpEquality(spVersion, oldSpVersion)) {
    // return;
    // }
    StorageType spType = storagePool.getstorage_pool_type();
    if (spType != StorageType.ISCSI && spType != StorageType.FCP) {
        // We try and not change the format type for pools that aren't iSCSI/FCP
        return;
    }
    // TODO: The entire version -> format type scheme should be moved to a place
    // when everyone can utilize it.
    StorageFormatType targetFormat = StorageFormatType.V1;
    Version v2FormatChangeBar = new Version("3.0");
    if (spVersion.compareTo(v2FormatChangeBar) >= 0) {
        targetFormat = StorageFormatType.V2;
    }
    storagePool.setStoragePoolFormatType(targetFormat);
    getStoragePoolDAO().update(storagePool);
    updateMemberDomainsFormat(targetFormat);
    if (storagePool.getstatus() != StoragePoolStatus.Up) {
        return;
    }
    // There is no need to worry about "reupgrading"
    // as VDSM will silently ignore the request
    UpgradeStoragePoolVDSCommandParameters parameters = new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat);
    resourceManager.RunVdsCommand(VDSCommandType.UpgradeStoragePool, parameters);
}
#method_after
private void updateStoragePoolFormatType() {
    final storage_pool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    final StorageFormatType targetFormat;
    if (Version.OpEquality(spVersion, oldSpVersion)) {
        return;
    }
    // when everyone can utilize it.
    if (spVersion.compareTo(Version.v3_0) == 0) {
        targetFormat = StorageFormatType.V2;
    } else if (spVersion.compareTo(Version.v3_1) == 0) {
        targetFormat = StorageFormatType.V3;
    } else {
        targetFormat = StorageFormatType.V1;
    }
    StorageType spType = storagePool.getstorage_pool_type();
    if (targetFormat == StorageFormatType.V2 && spType != StorageType.ISCSI && spType != StorageType.FCP) {
        // There is no format V2 for domains that aren't ISCSI/FCP
        return;
    }
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            return null;
        }
    });
    if (_oldStoragePool.getstatus() == StoragePoolStatus.Up) {
        // No need to worry about "reupgrading" as VDSM will silently ignore
        // the request.
        runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
    }
}
#end_block

#method_before
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDAO();
    List<storage_domain_static> domains = sdStatDao.getAllForStoragePool(spId);
    log.info("DOMAINS");
    log.info(domains);
    for (storage_domain_static domain : domains) {
        StorageDomainType sdType = domain.getstorage_domain_type();
        log.info("sdType");
        log.info(sdType);
        if (sdType != StorageDomainType.Data && sdType != StorageDomainType.Master) {
            continue;
        }
        log.info("update");
        log.info(targetFormat);
        log.info(domain.getId());
        domain.setStorageFormat(targetFormat);
        sdStatDao.update(domain);
    }
}
#method_after
private void updateMemberDomainsFormat(StorageFormatType targetFormat) {
    Guid spId = getStoragePool().getId();
    StorageDomainStaticDAO sdStatDao = DbFacade.getInstance().getStorageDomainStaticDAO();
    List<storage_domain_static> domains = sdStatDao.getAllForStoragePool(spId);
    for (storage_domain_static domain : domains) {
        StorageDomainType sdType = domain.getstorage_domain_type();
        if (sdType == StorageDomainType.Data || sdType == StorageDomainType.Master) {
            log.infoFormat("Updating storage domain {0} (type {1}) to format {2}", domain.getId(), sdType, targetFormat);
            domain.setStorageFormat(targetFormat);
            sdStatDao.update(domain);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!CheckStoragePool()) {
        return false;
    }
    if (!validateStoragePoolName()) {
        return false;
    }
    if (!validateStoragePoolTypeChange()) {
        return false;
    }
    if (!CheckStoragePoolNameLengthValid()) {
        return false;
    }
    if (!validateCompatibilityVersionChange()) {
        return false;
    }
    if (!isNotLocalfsWithDefaultCluster()) {
        return false;
    }
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = super.canDoAction() && checkStoragePool();
    _oldStoragePool = getStoragePoolDAO().get(getStoragePool().getId());
    if (returnValue && !StringHelper.EqOp(_oldStoragePool.getname(), getStoragePool().getname()) && getStoragePoolDAO().getByName(getStoragePool().getname()) != null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    }
    if (returnValue && _oldStoragePool.getstorage_pool_type() != getStoragePool().getstorage_pool_type() && getStorageDomainStaticDAO().getAllForStoragePool(getStoragePool().getId()).size() > 0) {
        returnValue = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_CHANGE_STORAGE_POOL_TYPE_WITH_DOMAINS.toString());
    }
    returnValue = returnValue && CheckStoragePoolNameLengthValid();
    if (returnValue && Version.OpInequality(_oldStoragePool.getcompatibility_version(), getStoragePool().getcompatibility_version())) {
        if (!isStoragePoolVersionSupported()) {
            addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
            returnValue = false;
        } else // decreasing of compatibility version is not allowed
        if (getStoragePool().getcompatibility_version().compareTo(_oldStoragePool.getcompatibility_version()) < 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        } else {
            // check all clusters has at least the same compatibility
            // version
            List<VDSGroup> clusters = getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
            for (VDSGroup cluster : clusters) {
                if (getStoragePool().getcompatibility_version().compareTo(cluster.getcompatibility_version()) > 0) {
                    returnValue = false;
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ERROR_CANNOT_UPDATE_STORAGE_POOL_COMPATIBILITY_VERSION_BIGGER_THAN_CLUSTERS.toString());
                    break;
                }
            }
        }
    }
    StoragePoolValidator validator = createStoragePoolValidator();
    if (returnValue) {
        returnValue = validator.isNotLocalfsWithDefaultCluster();
    }
    if (returnValue) {
        returnValue = validator.isPosixDcAndMatchingCompatiblityVersion();
    }
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    return returnValue;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc reconstructMaster(String spUUID, int hostSpmId, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.reconstructMaster(spUUID, hostSpmId, poolName, masterDom, domDict, masterVersion, lockPolicy, lockRenewalIntervalSec, leaseTimeSec, ioOpTimeoutSec, leaseRetries);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.reconstructMaster(spUUID, poolName, masterDom, domDict, masterVersion, lockPolicy, lockRenewalIntervalSec, leaseTimeSec, ioOpTimeoutSec, leaseRetries, hostSpmId);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.createVG(sdUUID, deviceList);
        OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.createVG(sdUUID, deviceList, force);
        OneUuidReturnForXmlRpc wrapper = new OneUuidReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBrickForce(String volumeName, String[] brickDirectories) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeRemoveBrickForce(volumeName, brickDirectories));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBrickForce(String volumeName, String[] brickDirectories, int replicaCount) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeRemoveBrickForce(volumeName, brickDirectories, replicaCount));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RECONSTRUCT_MASTER);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN);
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RECONSTRUCT_MASTER);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN);
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                boolean commandSucceeded = false;
                final storage_pool storagePool = getStoragePool();
                final Version storagePoolVersion = storagePool.getcompatibility_version();
                final Integer vdsSpmId = getVds().getvds_spm_id();
                ProceedStorageDomainTreatmentByDomainType(true);
                // reconstruct or if its last master
                if (getParameters().getIsDeactivate()) {
                    SetStorageDomainStatus(StorageDomainStatus.InActive);
                    CalcStoragePoolStatusByDomainsStatus();
                }
                commandSucceeded = true;
                if (!_isLastMaster) {
                    // pause the timers for the domain error handling.
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
                    // if we have spm, stop spm and reset cache (resetIrs)
                    commandSucceeded = stopSpm();
                    if (storagePoolVersion.compareTo(Version.v3_1) < 0) {
                        commandSucceeded = commandSucceeded && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), storagePool.getId(), vdsSpmId)).getSucceeded();
                    }
                    if (commandSucceeded) {
                        List<storage_pool_iso_map> domains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(storagePool.getId());
                        for (storage_pool_iso_map domain : domains) {
                            if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
                                domain.setstatus(StorageDomainStatus.Active);
                            } else if (domain.getstatus() == StorageDomainStatus.Locked) {
                                throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the pool is " + "locked.");
                            }
                        }
                        commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), vdsSpmId, storagePool.getId(), storagePool.getname(), storagePoolVersion, _newMasterStorageDomainId, domains, storagePool.getmaster_domain_version())).getSucceeded();
                    }
                } else {
                    stopSpm();
                }
                return commandSucceeded;
            }
        });
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        Boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // Reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            try {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        if (!_isLastMaster && commandSucceeded) {
                            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), getMasterDomainIdFromDb(), getStoragePool().getmaster_domain_version()));
                            if (returnValue.getSucceeded()) {
                                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } else {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (getParameters().getIsDeactivate()) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            } catch (Exception ex) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
            }
            return null;
        }
    });
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            try {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        if (!_isLastMaster && commandSucceeded) {
                            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), getMasterDomainIdFromDb(), getStoragePool().getmaster_domain_version()));
                            if (returnValue.getSucceeded()) {
                                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } else {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (getParameters().isInactive()) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            } catch (Exception ex) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    Map<String, String> domains = new HashMap<String, String>();
    for (storage_pool_iso_map domain : getParameters().getDomainsList()) {
        domains.put(domain.getstorage_id().toString(), domain.getstatus() != null ? domain.getstatus() == StorageDomainStatus.InActive ? "attached" : domain.getstatus().toString().toLowerCase() : StorageDomainStatus.Unknown.toString().toLowerCase());
    }
    if (getParameters().getStoragePoolVersion().compareTo(Version.v3_1) < 0) {
        status = getBroker().reconstructMaster(getParameters().getStoragePoolId().toString(), getParameters().getStoragePoolName(), getParameters().getMasterDomainId().toString(), domains, getParameters().getMasterVersion(), Config.<String>GetValue(ConfigValues.LockPolicy), Config.<Integer>GetValue(ConfigValues.LockRenewalIntervalSec), Config.<Integer>GetValue(ConfigValues.LeaseTimeSec), Config.<Integer>GetValue(ConfigValues.IoOpTimeoutSec), Config.<Integer>GetValue(ConfigValues.LeaseRetries));
    } else {
        status = getBroker().reconstructMaster(getParameters().getStoragePoolId().toString(), getParameters().getVdsSpmId(), getParameters().getStoragePoolName(), getParameters().getMasterDomainId().toString(), domains, getParameters().getMasterVersion(), Config.<String>GetValue(ConfigValues.LockPolicy), Config.<Integer>GetValue(ConfigValues.LockRenewalIntervalSec), Config.<Integer>GetValue(ConfigValues.LeaseTimeSec), Config.<Integer>GetValue(ConfigValues.IoOpTimeoutSec), Config.<Integer>GetValue(ConfigValues.LeaseRetries));
    }
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    final Map<String, String> domains = new HashMap<String, String>();
    for (storage_pool_iso_map domain : getParameters().getDomainsList()) {
        domains.put(domain.getstorage_id().toString(), domain.getstatus() != null ? domain.getstatus() == StorageDomainStatus.InActive ? "attached" : domain.getstatus().toString().toLowerCase() : StorageDomainStatus.Unknown.toString().toLowerCase());
    }
    status = getBroker().reconstructMaster(getParameters().getStoragePoolId().toString(), getParameters().getStoragePoolName(), getParameters().getMasterDomainId().toString(), domains, getParameters().getMasterVersion(), Config.<String>GetValue(ConfigValues.LockPolicy), Config.<Integer>GetValue(ConfigValues.LockRenewalIntervalSec), Config.<Integer>GetValue(ConfigValues.LeaseTimeSec), Config.<Integer>GetValue(ConfigValues.IoOpTimeoutSec), Config.<Integer>GetValue(ConfigValues.LeaseRetries), getParameters().getVdsSpmId());
    ProceedProxyReturnValue();
}
#end_block

#method_before
public Integer getVdsSpmId() {
    return privateVdsSpmId;
}
#method_after
public int getVdsSpmId() {
    return privateVdsSpmId;
}
#end_block

#method_before
public void setVdsSpmId(Integer value) {
    privateVdsSpmId = value;
}
#method_after
public void setVdsSpmId(int value) {
    privateVdsSpmId = value;
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s, storagePoolId = %s, storagePoolName = %s, masterDomainId = %s, masterVersion = %s, domainsList = [%s]", super.toString(), getStoragePoolId(), getStoragePoolName(), getMasterDomainId(), getMasterVersion(), getPrintableDomainsList());
}
#method_after
@Override
public String toString() {
    return String.format("%s, vdsSpmId = %i, storagePoolId = %s, " + "storagePoolName = %s, masterDomainId = %s, masterVersion = %s, " + "domainsList = [%s]", super.toString(), getVdsSpmId(), getStoragePoolId(), getStoragePoolName(), getMasterDomainId(), getMasterVersion(), getPrintableDomainsList());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                boolean commandSucceeded = false;
                ProceedStorageDomainTreatmentByDomainType(true);
                // reconstruct or if its last master
                if (getParameters().getIsInactive()) {
                    SetStorageDomainStatus(StorageDomainStatus.InActive);
                    CalcStoragePoolStatusByDomainsStatus();
                }
                commandSucceeded = stopSpm();
                if (_isLastMaster) {
                    return commandSucceeded;
                }
                // pause the timers for the domain error handling.
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
                // if we have spm, stop spm and reset cache (resetIrs)
                commandSucceeded = commandSucceeded && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
                if (!commandSucceeded) {
                    return false;
                }
                List<storage_pool_iso_map> domains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                for (storage_pool_iso_map domain : domains) {
                    if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
                        domain.setstatus(StorageDomainStatus.Active);
                    } else if (domain.getstatus() == StorageDomainStatus.Locked) {
                        throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the pool is " + "locked.");
                    }
                }
                commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
                return commandSucceeded;
            }
        });
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        Boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // Reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            try {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        if (!_isLastMaster && commandSucceeded) {
                            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), getMasterDomainIdFromDb(), getStoragePool().getmaster_domain_version()));
                            if (returnValue.getSucceeded()) {
                                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } else {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (getParameters().getIsInactive()) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            } catch (Exception ex) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
            }
            return null;
        }
    });
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            try {
                for (VDS vds : getAllRunningVdssInPool()) {
                    try {
                        if (!_isLastMaster && commandSucceeded) {
                            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), getMasterDomainIdFromDb(), getStoragePool().getmaster_domain_version()));
                            if (returnValue.getSucceeded()) {
                                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } else {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (getParameters().isInactive()) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            } catch (Exception ex) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
            }
            return null;
        }
    });
}
#end_block

#method_before
private void setHost(ListModel value) {
    privateHost = value;
}
#method_after
public void setHost(ListModel value) {
    privateHost = value;
}
#end_block

#method_before
@Override
public void Initialize() {
    super.Initialize();
    setHash(getHashName() + new Date());
    InitDataCenter();
}
#method_after
@Override
public void Initialize() {
    super.Initialize();
    setHash(getHashName() + new Date());
    behavior.setHash(getHash());
    InitDataCenter();
}
#end_block

#method_before
private void Frontend_QueryStarted() {
    queryCounter++;
    if (getProgress() == null) {
        StartProgress(null);
    }
}
#method_after
public void Frontend_QueryStarted() {
    queryCounter++;
    if (getProgress() == null) {
        StartProgress(null);
    }
}
#end_block

#method_before
private void Frontend_QueryComplete() {
    queryCounter--;
    if (queryCounter == 0) {
        StopProgress();
    }
}
#method_after
public void Frontend_QueryComplete() {
    queryCounter--;
    if (queryCounter == 0) {
        StopProgress();
    }
}
#end_block

#method_before
private void DataCenter_SelectedItemChanged() {
    UpdateItemsAvailability();
    UpdateFormat();
    UpdateHost();
}
#method_after
private void DataCenter_SelectedItemChanged() {
    UpdateItemsAvailability();
}
#end_block

#method_before
private void Host_SelectedItemChanged() {
    VDS host = (VDS) getHost().getSelectedItem();
    if (getSelectedItem() != null) {
        // When changing host clear items for san storage model.
        if (getSelectedItem() instanceof SanStorageModelBase && getStorage() == null) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getSelectedItem();
            sanStorageModel.setItems(null);
        }
        if (host != null) {
            getSelectedItem().getUpdateCommand().Execute();
            VDSType vdsType = ((VDS) this.getHost().getSelectedItem()).getvds_type();
            // $NON-NLS-1$
            String prefix = vdsType.equals(VDSType.oVirtNode) ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                for (Object item : getItems()) {
                    if (item instanceof LocalStorageModel) {
                        LocalStorageModel model = (LocalStorageModel) item;
                        model.getPath().setEntity(prefix);
                        model.getPath().setIsChangable(false);
                    }
                }
            }
        }
    }
}
#method_after
private void Host_SelectedItemChanged() {
    VDS host = (VDS) getHost().getSelectedItem();
    if (getSelectedItem() != null) {
        // When changing host clear items for san storage model.
        if (getSelectedItem() instanceof SanStorageModelBase) {
            SanStorageModelBase sanStorageModel = (SanStorageModelBase) getSelectedItem();
            sanStorageModel.setHash(getHash());
            if (getStorage() == null) {
                sanStorageModel.setItems(null);
            }
        }
        if (host != null) {
            getSelectedItem().getUpdateCommand().Execute();
            VDSType vdsType = ((VDS) this.getHost().getSelectedItem()).getvds_type();
            // $NON-NLS-1$
            String prefix = vdsType.equals(VDSType.oVirtNode) ? localFSPath : "";
            if (!StringHelper.isNullOrEmpty(prefix)) {
                for (Object item : getItems()) {
                    if (item instanceof LocalStorageModel) {
                        LocalStorageModel model = (LocalStorageModel) item;
                        model.getPath().setEntity(prefix);
                        model.getPath().setIsChangable(false);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void UpdateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (getSelectedItem() instanceof LocalStorageModel && (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId))) {
        ArrayList<storage_pool> dataCenterList = (ArrayList<storage_pool>) getDataCenter().getItems();
        ArrayList<storage_pool> localDCList = new ArrayList<storage_pool>();
        // $NON-NLS-1$
        String dataCenterQueryLine = "";
        for (storage_pool storagePool : dataCenterList) {
            if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
                localDCList.add(storagePool);
            }
        }
        if (localDCList.size() > 0) {
            int i = 0;
            for (; i < localDCList.size() - 1; i++) {
                // $NON-NLS-1$ //$NON-NLS-2$
                dataCenterQueryLine += "datacenter=" + localDCList.get(i).getname() + " or ";
            }
            // $NON-NLS-1$
            dataCenterQueryLine += "datacenter=" + localDCList.get(i).getname();
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.setContext(getHash());
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object ReturnValue) {
                    StorageModel storageModel = (StorageModel) model;
                    Iterable<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    storageModel.PostUpdateHost(hosts);
                }
            };
            Frontend.RunQuery(VdcQueryType.Search, new // $NON-NLS-1$
            SearchParameters(// $NON-NLS-1$
            "Hosts: status=Up " + dataCenterQueryLine, SearchType.VDS), _asyncQuery);
        }
    } else {
        if (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId)) {
            AsyncDataProvider.GetHostList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.PostUpdateHost(hosts);
                }
            }, getHash()));
        } else {
            AsyncDataProvider.GetHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.PostUpdateHost(hosts);
                }
            }, getHash()), dataCenter.getname());
        }
    }
}
#method_after
void UpdateHost() {
    if (getDataCenter().getItems() == null) {
        return;
    }
    if (getSelectedItem() == null) {
        return;
    }
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (getSelectedItem() instanceof LocalStorageModel && (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId))) {
        ArrayList<storage_pool> dataCenterList = (ArrayList<storage_pool>) getDataCenter().getItems();
        ArrayList<storage_pool> localDCList = new ArrayList<storage_pool>();
        // $NON-NLS-1$
        String dataCenterQueryLine = "";
        for (storage_pool storagePool : dataCenterList) {
            if (storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
                localDCList.add(storagePool);
            }
        }
        if (localDCList.size() > 0) {
            int i = 0;
            for (; i < localDCList.size() - 1; i++) {
                // $NON-NLS-1$ //$NON-NLS-2$
                dataCenterQueryLine += "datacenter=" + localDCList.get(i).getname() + " or ";
            }
            // $NON-NLS-1$
            dataCenterQueryLine += "datacenter=" + localDCList.get(i).getname();
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.setContext(getHash());
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object ReturnValue) {
                    StorageModel storageModel = (StorageModel) model;
                    Iterable<VDS> hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    storageModel.PostUpdateHost(hosts);
                }
            };
            Frontend.RunQuery(VdcQueryType.Search, new // $NON-NLS-1$
            SearchParameters(// $NON-NLS-1$
            "Hosts: status=Up " + dataCenterQueryLine, SearchType.VDS), _asyncQuery);
        }
    } else {
        if (dataCenter == null || dataCenter.getId().equals(UnassignedDataCenterId)) {
            AsyncDataProvider.GetHostList(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.PostUpdateHost(hosts);
                }
            }, getHash()));
        } else {
            AsyncDataProvider.GetHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
                    storageModel.PostUpdateHost(hosts);
                }
            }, getHash()), dataCenter.getId());
        }
    }
}
#end_block

#method_before
public void PostUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.Where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getvds_group_compatibility_version().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    getHost().setItems(hosts);
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        getHost().setSelectedItem(Linq.FirstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId())));
    }
    // Try to select an SPM host when edit storage.
    if (getHost().getSelectedItem() == null && getStorage() != null) {
        for (VDS host : hosts) {
            if (host.getspm_status() == VdsSpmStatus.SPM) {
                getHost().setSelectedItem(host);
                break;
            }
        }
    }
    // Select a default - first host in the list.
    if (getHost().getSelectedItem() == null) {
        getHost().setSelectedItem(Linq.FirstOrDefault(hosts));
    }
    if (queryCounter > 0) {
        queryCounter++;
    }
    StopProgress();
    getSelectedItem().getUpdateCommand().Execute();
}
#method_after
public void PostUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.Where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getvds_group_compatibility_version().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    getHost().setItems(hosts);
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.FirstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Try to select an SPM host when edit storage.
    if (selectedItem == null && getStorage() != null) {
        for (VDS host : hosts) {
            if (host.getspm_status() == VdsSpmStatus.SPM) {
                selectedItem = host;
                break;
            }
        }
    }
    // Select a default - first host in the list.
    if (selectedItem == null) {
        selectedItem = Linq.FirstOrDefault(hosts);
    }
    getHost().setSelectedItem(selectedItem);
}
#end_block

#method_before
private void UpdateFormat() {
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(true);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if (getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.ISCSI || getSelectedItem().getType() == StorageType.FCP) && // $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.ISCSI || getSelectedItem().getType() == StorageType.FCP) && // $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_0) >= 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            }
            // If the Data Center is 3.1 we should display the V3 option
            if ((getSelectedItem().getType() == StorageType.ISCSI || getSelectedItem().getType() == StorageType.FCP) && // $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
            }
        } else // Unassigned DC:
        {
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            }
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void UpdateFormat() {
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.ISCSI || getSelectedItem().getType() == StorageType.FCP) && // $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.ISCSI || getSelectedItem().getType() == StorageType.FCP) && // $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (// $NON-NLS-1$
            dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            }
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
public void ChooseFirstItem() {
    boolean chooseFirst = false;
    if (getSelectedItem() != null) {
        Model selectedModel = (Model) getSelectedItem();
        if (!selectedModel.getIsSelectable()) {
            chooseFirst = true;
        }
        SelectStorageItem(selectedModel);
    } else {
        chooseFirst = true;
    }
    if (chooseFirst) {
        // New Domain and ISO role in case of Import Domain).
        for (IStorageModel item : Linq.<IStorageModel>Cast(getItems())) {
            Model model = (Model) item;
            if (model.getIsSelectable()) {
                setSelectedItem(item);
                SelectStorageItem(model);
                break;
            }
        }
    }
}
#method_after
public void ChooseFirstItem() {
    // first init to null
    setSelectedItem(null);
    boolean chooseFirst = false;
    if (getSelectedItem() != null) {
        Model selectedModel = (Model) getSelectedItem();
        if (!selectedModel.getIsSelectable()) {
            chooseFirst = true;
        }
        SelectStorageItem(selectedModel);
    } else {
        chooseFirst = true;
    }
    if (chooseFirst) {
        // New Domain and ISO role in case of Import Domain).
        for (IStorageModel item : Linq.<IStorageModel>Cast(getItems())) {
            Model model = (Model) item;
            if (model.getIsSelectable()) {
                setSelectedItem(item);
                SelectStorageItem(model);
                break;
            }
        }
    }
}
#end_block

#method_before
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#method_after
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#end_block

#method_before
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = spy(new AddVmCommandDummy(param));
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGB() * getVmTemplate().getDiskMap().size();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.Login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "UserName", "UserPassword", "Domain", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginAdminUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    VdcUser user = control.createMock(VdcUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.RunPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#method_after
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.Login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "UserName", "UserPassword", "Domain", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    VdcUser user = control.createMock(VdcUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.RunPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#end_block

#method_before
protected void verifyApiGlusterOnly(API api) {
    assertNotNull(api);
    assertNotNull(api.getTime());
    assertNotNull(api.getLinks());
    assertEquals(relationshipsGlusterOnly.length, api.getLinks().size());
    for (int i = 0; i < relationshipsGlusterOnly.length; i++) {
        Link l = api.getLinks().get(i);
        assertNotNull(l);
        assertEquals(relationshipsGlusterOnly[i], l.getRel());
        assertEquals(hrefsGlusterOnly[i], l.getHref());
    }
    assertNotNull(api.getSpecialObjects());
    assertContainsRootTag(api.getSpecialObjects());
    assertNotContainsBlankTemplate(api.getSpecialObjects());
    assertNotNull(api.getProductInfo());
    assertNotNull(api.getProductInfo().getVersion());
    assertEquals(MAJOR, api.getProductInfo().getVersion().getMajor().intValue());
    assertEquals(MINOR, api.getProductInfo().getVersion().getMinor().intValue());
    assertEquals(BUILD, api.getProductInfo().getVersion().getBuild().intValue());
    assertEquals(REVISION, api.getProductInfo().getVersion().getRevision().intValue());
    assertNotNull(api.getSummary());
    assertEquals(TOTAL_HOSTS, api.getSummary().getHosts().getTotal());
    assertEquals(ACTIVE_HOSTS, api.getSummary().getHosts().getActive());
    assertEquals(TOTAL_USERS, api.getSummary().getUsers().getTotal());
    assertEquals(ACTIVE_USERS, api.getSummary().getUsers().getActive());
}
#method_after
protected void verifyApiGlusterOnly(API api) {
    assertNotNull(api);
    assertNotNull(api.getTime());
    assertNotNull(api.getLinks());
    assertEquals(relationshipsGlusterOnly.length, api.getLinks().size());
    for (int i = 0; i < relationshipsGlusterOnly.length; i++) {
        Link l = api.getLinks().get(i);
        assertNotNull(l);
        assertEquals(relationshipsGlusterOnly[i], l.getRel());
        assertEquals(hrefsGlusterOnly[i], l.getHref());
    }
    assertNotNull(api.getSpecialObjects());
    assertContainsRootTag(api.getSpecialObjects());
    assertNotNull(api.getProductInfo());
    assertNotNull(api.getProductInfo().getVersion());
    assertEquals(MAJOR, api.getProductInfo().getVersion().getMajor().intValue());
    assertEquals(MINOR, api.getProductInfo().getVersion().getMinor().intValue());
    assertEquals(BUILD, api.getProductInfo().getVersion().getBuild().intValue());
    assertEquals(REVISION, api.getProductInfo().getVersion().getRevision().intValue());
    assertNotNull(api.getSummary());
    assertEquals(TOTAL_HOSTS, api.getSummary().getHosts().getTotal());
    assertEquals(ACTIVE_HOSTS, api.getSummary().getHosts().getActive());
    assertEquals(TOTAL_USERS, api.getSummary().getUsers().getTotal());
    assertEquals(ACTIVE_USERS, api.getSummary().getUsers().getActive());
}
#end_block

#method_before
@Override
public Clusters list() {
    if (isFiltered())
        return mapCollection(getBackendCollection(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase()));
    else
        return mapCollection(getBackendCollection(SearchType.Cluster));
}
#method_after
@Override
public Clusters list() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.VirtOnly) {
        return listVirtOnly();
    } else {
        return listAll();
    }
}
#end_block

#method_before
private Clusters mapCollection(List<VDSGroup> entities) {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    Clusters collection = new Clusters();
    for (org.ovirt.engine.core.common.businessentities.VDSGroup entity : entities) {
        if (appMode == ApplicationMode.VirtOnly) {
            collection.getClusters().add(addLinks(map(entity), "glusterVolumes"));
        } else {
            collection.getClusters().add(addLinks(map(entity)));
        }
    }
    return collection;
}
#method_after
private Clusters mapCollection(List<VDSGroup> entities) {
    Clusters collection = new Clusters();
    for (org.ovirt.engine.core.common.businessentities.VDSGroup entity : entities) {
        collection.getClusters().add(addLinks(map(entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
public Hosts list() {
    if (isFiltered())
        return mapCollection(getBackendCollection(VdcQueryType.GetAllHosts, new VdcQueryParametersBase()));
    else
        return mapCollection(getBackendCollection(SearchType.VDS));
}
#method_after
@Override
public Hosts list() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return listGlusterOnly();
    } else {
        return listAll();
    }
}
#end_block

#method_before
private Hosts mapCollection(List<VDS> entities) {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    Hosts collection = new Hosts();
    for (VDS entity : entities) {
        if (appMode == ApplicationMode.GlusterOnly) {
            collection.getHosts().add(addLinks(populate(map(entity), entity), "storage"));
        } else {
            collection.getHosts().add(addLinks(populate(map(entity), entity)));
        }
    }
    return collection;
}
#method_after
private Hosts mapCollection(List<VDS> entities) {
    Hosts collection = new Hosts();
    for (VDS entity : entities) {
        collection.getHosts().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
private Collection<DetailedLink> getLinks() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return getGlusterOnlyLinks();
    }
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#method_after
private Collection<DetailedLink> getLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#end_block

#method_before
private API getApi() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    API api = new API();
    api.setTime(DateMapper.map(new Date(), null));
    for (DetailedLink detailedLink : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel()));
        // when required - add extra link for search
        if (detailedLink.isSetLinkCapabilities() && detailedLink.getLinkCapabilities().isSetSearchable() && detailedLink.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel(), detailedLink.getRequest().getUrl().getParametersSets()));
        }
        // add special links
        api.setSpecialObjects(new SpecialObjects());
        if (appMode != ApplicationMode.GlusterOnly) {
            api.getSpecialObjects().getLinks().add(createBlankTemplateLink());
        }
        api.getSpecialObjects().getLinks().add(createRootTagLink());
    }
    return api;
}
#method_after
private API getApi() {
    API api = new API();
    api.setTime(DateMapper.map(new Date(), null));
    for (DetailedLink detailedLink : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel()));
        // when required - add extra link for search
        if (detailedLink.isSetLinkCapabilities() && detailedLink.getLinkCapabilities().isSetSearchable() && detailedLink.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel(), detailedLink.getRequest().getUrl().getParametersSets()));
        }
        // add special links
        api.setSpecialObjects(new SpecialObjects());
        api.getSpecialObjects().getLinks().add(createBlankTemplateLink());
        api.getSpecialObjects().getLinks().add(createRootTagLink());
    }
    return api;
}
#end_block

#method_before
private String addPath(UriBuilder uriBuilder, Link link) {
    String query = "";
    String path = relative(link);
    // otherwise UriBuilder.build() will substitute {query}
    if (path.contains("?")) {
        query = path.substring(path.indexOf("?"));
        path = path.substring(0, path.indexOf("?"));
    }
    link = JAXBHelper.clone(OBJECT_FACTORY.createLink(link));
    link.setHref(uriBuilder.clone().path(path).build() + query);
    return LinkHeader.format(link);
}
#method_after
private String addPath(UriBuilder uriBuilder, Link link) {
    String query = "";
    String matrix = "";
    String path = relative(link);
    // otherwise UriBuilder.build() will substitute {query}
    if (path.contains("?")) {
        query = path.substring(path.indexOf("?"));
        path = path.substring(0, path.indexOf("?"));
    }
    // otherwise UriBuilder.build() will substitute {matrix}
    if (path.contains(";")) {
        matrix = path.substring(path.indexOf(";"));
        path = path.substring(0, path.indexOf(";"));
    }
    link = JAXBHelper.clone(OBJECT_FACTORY.createLink(link));
    link.setHref(uriBuilder.clone().path(path).build().toString() + matrix + query);
    return LinkHeader.format(link);
}
#end_block

#method_before
@Override
public Response head() {
    API api = getApi();
    return getResponseBuilder(api).build();
}
#method_after
@Override
public Response head() {
    appMode = getCurrent().get(ApplicationMode.class);
    API api = null;
    if (appMode == ApplicationMode.GlusterOnly) {
        api = getGlusterApi();
    } else {
        api = getApi();
    }
    return getResponseBuilder(api).build();
}
#end_block

#method_before
@Override
public Response get() {
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        RSDL rsdl = addSystemVersion(getRSDL());
        return Response.ok().entity(rsdl).build();
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        BaseResource response = addSummary(addSystemVersion(getApi()));
        return getResponseBuilder(response).entity(response).build();
    }
}
#method_after
@Override
public Response get() {
    appMode = getCurrent().get(ApplicationMode.class);
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        RSDL rsdl = addSystemVersion(getRSDL());
        return Response.ok().entity(rsdl).build();
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        BaseResource response = null;
        if (appMode == ApplicationMode.GlusterOnly) {
            response = addGlusterSummary(addSystemVersion(getGlusterApi()));
        } else {
            response = addSummary(addSystemVersion(getApi()));
        }
        return getResponseBuilder(response).entity(response).build();
    }
}
#end_block

#method_before
private API addSummary(API api) {
    HashMap<String, Integer> stats = getSystemStatistics();
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    ApiSummary summary = new ApiSummary();
    if (appMode != ApplicationMode.GlusterOnly) {
        summary.setVMs(new VMs());
        summary.getVMs().setTotal(get(stats, "total_vms"));
        summary.getVMs().setActive(get(stats, "active_vms"));
    }
    summary.setHosts(new Hosts());
    summary.getHosts().setTotal(get(stats, "total_vds"));
    summary.getHosts().setActive(get(stats, "active_vds"));
    summary.setUsers(new Users());
    summary.getUsers().setTotal(get(stats, "total_users"));
    summary.getUsers().setActive(get(stats, "active_users"));
    if (appMode != ApplicationMode.GlusterOnly) {
        summary.setStorageDomains(new StorageDomains());
        summary.getStorageDomains().setTotal(get(stats, "total_storage_domains"));
        summary.getStorageDomains().setActive(get(stats, "active_storage_domains"));
    }
    api.setSummary(summary);
    return api;
}
#method_after
private API addSummary(API api) {
    HashMap<String, Integer> stats = getSystemStatistics();
    ApiSummary summary = new ApiSummary();
    summary.setVMs(new VMs());
    summary.getVMs().setTotal(get(stats, "total_vms"));
    summary.getVMs().setActive(get(stats, "active_vms"));
    summary.setHosts(new Hosts());
    summary.getHosts().setTotal(get(stats, "total_vds"));
    summary.getHosts().setActive(get(stats, "active_vds"));
    summary.setUsers(new Users());
    summary.getUsers().setTotal(get(stats, "total_users"));
    summary.getUsers().setActive(get(stats, "active_users"));
    summary.setStorageDomains(new StorageDomains());
    summary.getStorageDomains().setTotal(get(stats, "total_storage_domains"));
    summary.getStorageDomains().setActive(get(stats, "active_storage_domains"));
    api.setSummary(summary);
    return api;
}
#end_block

#method_before
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getUser(), principal.getSecret(), principal.getDomain(), null, null, null);
    params.setActionType(VdcActionType.LoginAdminUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.Login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#method_after
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getUser(), principal.getSecret(), principal.getDomain(), null, null, null);
    params.setActionType(VdcActionType.LoginUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.Login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#end_block

#method_before
public static String getRootURL() {
    String moduleURL = GWT.getModuleBaseURL();
    // $NON-NLS-1$
    int index = moduleURL.indexOf("://");
    if (index == -1) {
        // $NON-NLS-1$ $NON-NLS-2$
        GWT.log("Can't extract root URL from module URL \"" + moduleURL + "\".");
    }
    // $NON-NLS-1$
    index = moduleURL.indexOf("/", index + 3);
    if (index == -1) {
        return moduleURL;
    }
    return moduleURL.substring(0, index);
}
#method_after
public static String getRootURL() {
    String moduleURL = GWT.getModuleBaseURL();
    // $NON-NLS-1$
    String separator = "://";
    int index = moduleURL.indexOf(separator);
    if (index == -1) {
        throw new RuntimeException();
    }
    // $NON-NLS-1$
    index = moduleURL.indexOf("/", index + separator.length());
    if (index == -1) {
        return moduleURL;
    }
    return moduleURL.substring(0, index);
}
#end_block

#method_before
@Override
protected void ReadHardwareSection(XmlNode section) {
    XmlNodeList list = section.SelectNodes("Item");
    for (XmlNode node : list) {
        String resourceType = node.SelectSingleNode("rasd:ResourceType", _xmlNS).InnerText;
        if (StringHelper.EqOp(resourceType, OvfHardware.CPU)) {
            _vm.getStaticData().setnum_of_sockets(Integer.parseInt(node.SelectSingleNode("rasd:num_of_sockets", _xmlNS).InnerText));
            _vm.getStaticData().setcpu_per_socket(Integer.parseInt(node.SelectSingleNode("rasd:cpu_per_socket", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Memory)) {
            _vm.getStaticData().setmem_size_mb(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.DiskImage)) {
            final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).InnerText);
            DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

                @Override
                public boolean eval(DiskImage diskImage) {
                    return diskImage.getImageId().equals(guid);
                }
            });
            image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).InnerText));
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText)) {
                image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText));
            }
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText)) {
                image.setit_guid(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText));
            }
            image.setappList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).InnerText);
            if (node.SelectSingleNode("rasd:StorageId", _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText)) {
                image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText))));
            }
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText)) {
                image.setstorage_pool_id(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText));
            }
            final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).InnerText);
            if (creationDate == null) {
                image.setcreation_date(creationDate);
            }
            final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).InnerText);
            if (lastModified != null) {
                image.setlastModified(lastModified);
            }
            final Date last_modified_date = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:last_modified_date", _xmlNS).InnerText);
            if (last_modified_date != null) {
                image.setlast_modified_date(last_modified_date);
            }
            readVmDevice(node, _vm.getStaticData(), image.getId(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Network)) {
            VmNetworkInterface iface = getNetwotkInterface(node);
            updateSingleNic(node, iface);
            _vm.getInterfaces().add(iface);
            readVmDevice(node, _vm.getStaticData(), iface.getId(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.USB)) {
            _vm.getStaticData().setusb_policy(UsbPolicy.forStringValue(node.SelectSingleNode("rasd:UsbPolicy", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Monitor)) {
            _vm.getStaticData().setnum_of_monitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
            readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.CD)) {
            readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.OTHER)) {
            if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
                String type = String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText);
                String device = String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText);
                // special devices are treated as managed devices but still have the OTHER OVF ResourceType
                if (VmDeviceCommonUtils.isSpecialDevice(device, type)) {
                    readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
                } else {
                    readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.FALSE);
                }
            } else {
                readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.FALSE);
            }
        }
    }
}
#method_after
@Override
protected void ReadHardwareSection(XmlNode section) {
    XmlNodeList list = section.SelectNodes("Item");
    for (XmlNode node : list) {
        String resourceType = node.SelectSingleNode("rasd:ResourceType", _xmlNS).InnerText;
        if (StringHelper.EqOp(resourceType, OvfHardware.CPU)) {
            _vm.getStaticData().setnum_of_sockets(Integer.parseInt(node.SelectSingleNode("rasd:num_of_sockets", _xmlNS).InnerText));
            _vm.getStaticData().setcpu_per_socket(Integer.parseInt(node.SelectSingleNode("rasd:cpu_per_socket", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Memory)) {
            _vm.getStaticData().setmem_size_mb(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.DiskImage)) {
            final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).InnerText);
            DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

                @Override
                public boolean eval(DiskImage diskImage) {
                    return diskImage.getImageId().equals(guid);
                }
            });
            image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).InnerText));
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText)) {
                image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText));
            }
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText)) {
                image.setit_guid(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText));
            }
            image.setappList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).InnerText);
            XmlNode storageNode = node.SelectSingleNode("rasd:StorageId", _xmlNS);
            if (storageNode != null && !StringHelper.isNullOrEmpty(storageNode.InnerText)) {
                image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid(storageNode.InnerText))));
            }
            if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText)) {
                image.setstorage_pool_id(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText));
            }
            final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).InnerText);
            if (creationDate == null) {
                image.setcreation_date(creationDate);
            }
            final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).InnerText);
            if (lastModified != null) {
                image.setlastModified(lastModified);
            }
            final Date last_modified_date = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:last_modified_date", _xmlNS).InnerText);
            if (last_modified_date != null) {
                image.setlast_modified_date(last_modified_date);
            }
            readVmDevice(node, _vm.getStaticData(), image.getId(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Network)) {
            VmNetworkInterface iface = getNetwotkInterface(node);
            updateSingleNic(node, iface);
            _vm.getInterfaces().add(iface);
            readVmDevice(node, _vm.getStaticData(), iface.getId(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.USB)) {
            _vm.getStaticData().setusb_policy(UsbPolicy.forStringValue(node.SelectSingleNode("rasd:UsbPolicy", _xmlNS).InnerText));
        } else if (StringHelper.EqOp(resourceType, OvfHardware.Monitor)) {
            _vm.getStaticData().setnum_of_monitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
            readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.CD)) {
            readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
        } else if (StringHelper.EqOp(resourceType, OvfHardware.OTHER)) {
            if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
                String type = String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText);
                String device = String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText);
                // special devices are treated as managed devices but still have the OTHER OVF ResourceType
                if (VmDeviceCommonUtils.isSpecialDevice(device, type)) {
                    readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.TRUE);
                } else {
                    readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.FALSE);
                }
            } else {
                readVmDevice(node, _vm.getStaticData(), Guid.NewGuid(), Boolean.FALSE);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
    if (creationDate != null) {
        _vm.getStaticData().setcreation_date(creationDate);
    }
    node = content.SelectSingleNode("ExportDate");
    final Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
    if (exportDate != null) {
        _vm.getStaticData().setExportDate(exportDate);
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        } else if (StringUtils.equals(value, "ovf:SnapshotsSection_Type")) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#method_after
@Override
protected void ReadGeneralData() {
    // General Vm
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vm.getStaticData().setvm_name(node.InnerText);
        name = _vm.getStaticData().getvm_name();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.getStaticData().setvmt_guid(new Guid(node.InnerText));
        }
    }
    node = content.SelectSingleNode("TemplateName");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvmt_name(node.InnerText);
        }
    }
    node = content.SelectSingleNode("Description");
    if (node != null) {
        _vm.getStaticData().setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        _vm.getStaticData().setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            _vm.getStaticData().setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        final Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            _vm.getStaticData().setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsInitilized");
    if (node != null) {
        _vm.getStaticData().setis_initialized(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        _vm.getStaticData().setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        _vm.getStaticData().settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        _vm.getStaticData().setis_stateless(Boolean.parseBoolean(node.InnerText));
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        } else if (StringUtils.equals(value, "ovf:SnapshotsSection_Type")) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setkernel_params((node.InnerText));
        }
    }
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a list of all the aliases of the fields that should be logged in
    // ovd For each one of these fields, the proper value will be read from
    // the ovf and field in vm static
    List<String> aliases = handler.getAliases();
    for (String alias : aliases) {
        String value = readEventLogValue(content, alias);
        if (!StringHelper.isNullOrEmpty(value)) {
            handler.addValueForAlias(alias, value);
        }
    }
    node = content.SelectSingleNode("app_list");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setapp_list(node.InnerText);
        }
    } else // if no app list in VM, get it from one of the leafs
    if (_images != null && _images.size() > 0) {
        int root = GetFirstImage(_images, _images.get(0));
        if (root != -1) {
            for (int i = 0; i < _images.size(); i++) {
                int x = GetNextImage(_images, _images.get(i));
                if (x == -1) {
                    _vm.setapp_list(_images.get(i).getappList());
                }
            }
        } else {
            _vm.setapp_list(_images.get(0).getappList());
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("DefaultDisplayType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setdefault_display_type(DisplayType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            _vm.setMinAllocatedMem(Integer.parseInt(node.InnerText));
        }
    }
}
#end_block

#method_before
private void PostShowWarningOnExistingVms(final ExportVmModel exportModel, List<storage_pool> storagePools, VdcQueryType getVmOrTemplateQuery) {
    storage_pool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
    if (storagePool != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object result) {
                VmBaseListModel listModel = (VmBaseListModel) model;
                ExportVmModel exportModel1 = (ExportVmModel) listModel.getWindow();
                // $NON-NLS-1$
                String existingEntitiess = "";
                if (result != null) {
                    for (Object selectedItem : listModel.getSelectedItems()) {
                        Object foundVm = null;
                        VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
                        for (Object a : asIterableReturnValue(returnValue.getReturnValue())) {
                            if (entititesEqualsNullSafe(a, selectedItem)) {
                                foundVm = selectedItem;
                                break;
                            }
                        }
                        if (foundVm != null) {
                            // $NON-NLS-1$ //$NON-NLS-2$
                            existingEntitiess += "\u2022  " + extractNameFromEntity(foundVm) + "\n";
                        }
                    }
                }
                if (!StringHelper.isNullOrEmpty(existingEntitiess)) {
                    exportModel1.setMessage(composeEntityOnStorage(existingEntitiess));
                }
                exportModel.StopProgress();
            }
        };
        Guid storageDomainId = ((storage_domains) exportModel.getStorage().getSelectedItem()).getId();
        GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(storagePool.getId(), storageDomainId);
        tempVar.setGetAll(true);
        Frontend.RunQuery(getVmOrTemplateQuery, tempVar, _asyncQuery);
    } else {
        exportModel.StopProgress();
    }
}
#method_after
private void PostShowWarningOnExistingVms(final ExportVmModel exportModel, List<storage_pool> storagePools, VdcQueryType getVmOrTemplateQuery) {
    storage_pool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
    if (storagePool != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object result) {
                VmBaseListModel listModel = (VmBaseListModel) model;
                ExportVmModel exportModel1 = (ExportVmModel) listModel.getWindow();
                // $NON-NLS-1$
                String existingEntitiess = "";
                if (result != null) {
                    for (Object rawSelectedItem : listModel.getSelectedItems()) {
                        T selectedItem = (T) rawSelectedItem;
                        T foundVm = null;
                        VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
                        for (T returnValueItem : asIterableReturnValue(returnValue.getReturnValue())) {
                            if (entititesEqualsNullSafe(returnValueItem, selectedItem)) {
                                foundVm = selectedItem;
                                break;
                            }
                        }
                        if (foundVm != null) {
                            // $NON-NLS-1$ //$NON-NLS-2$
                            existingEntitiess = "\u2022  " + extractNameFromEntity(foundVm) + "\n";
                        }
                    }
                }
                if (!StringHelper.isNullOrEmpty(existingEntitiess)) {
                    exportModel1.setMessage(composeEntityOnStorage(existingEntitiess));
                }
                exportModel.StopProgress();
            }
        };
        Guid storageDomainId = ((storage_domains) exportModel.getStorage().getSelectedItem()).getId();
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), storageDomainId);
        tempVar.setGetAll(true);
        Frontend.RunQuery(getVmOrTemplateQuery, tempVar, _asyncQuery);
    } else {
        exportModel.StopProgress();
    }
}
#end_block

#method_before
protected boolean entititesEqualsNullSafe(Object e1, Object e2) {
    if (e1 instanceof VmTemplate && e2 instanceof VmTemplate) {
        return ((VmTemplate) e1).getId().equals(((VmTemplate) e2).getId());
    }
    return false;
}
#method_after
protected boolean entititesEqualsNullSafe(VmTemplate e1, VmTemplate e2) {
    return e1.getId().equals(e2.getId());
}
#end_block

#method_before
@Override
protected Iterable<?> asIterableReturnValue(Object returnValue) {
    return ((Map<?, ?>) returnValue).keySet();
}
#method_after
@Override
protected Iterable<VmTemplate> asIterableReturnValue(Object returnValue) {
    return ((Map<VmTemplate, ?>) returnValue).keySet();
}
#end_block

#method_before
@Override
protected String extractNameFromEntity(Object entity) {
    if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getname();
    }
    return "";
}
#method_after
@Override
protected String extractNameFromEntity(VmTemplate entity) {
    return ((VmTemplate) entity).getname();
}
#end_block

#method_before
private void Guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.GetVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity((VM) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void Guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.GetVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
protected String extractNameFromEntity(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getvm_name();
    }
    return "";
}
#method_after
protected String extractNameFromEntity(VM entity) {
    return entity.getvm_name();
}
#end_block

#method_before
protected boolean entititesEqualsNullSafe(Object e1, Object e2) {
    if (e1 instanceof VM && e2 instanceof VM) {
        return ((VM) e1).getId().equals(((VM) e2).getId());
    }
    return false;
}
#method_after
protected boolean entititesEqualsNullSafe(VM e1, VM e2) {
    return e1.getId().equals(e2.getId());
}
#end_block

#method_before
@Override
protected Iterable<?> asIterableReturnValue(Object returnValue) {
    return (List<?>) returnValue;
}
#method_after
@Override
protected Iterable<VM> asIterableReturnValue(Object returnValue) {
    return (List<VM>) returnValue;
}
#end_block

#method_before
private void OnSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    if (model.getIsNew() == false && selectedItem == null) {
        Cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.Validate()) {
        return;
    }
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!DataProvider.IsVmNameUnique(name) && name.compareToIgnoreCase(getcurrentVm().getvm_name()) != 0) {
        model.getName().setIsValid(false);
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setvm_type(model.getVmType());
    getcurrentVm().setvmt_guid(template.getId());
    getcurrentVm().setvm_name(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setvm_os((VmOsType) model.getOSType().getSelectedItem());
    getcurrentVm().setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setvm_description((String) model.getDescription().getEntity());
    getcurrentVm().setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    getcurrentVm().setvds_group_id(newClusterID);
    getcurrentVm().settime_zone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setnum_of_sockets((Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setcpu_per_socket((Integer) model.getTotalCPUCores().getEntity() / (Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setusb_policy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setis_auto_suspend(false);
    getcurrentVm().setis_stateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setdefault_boot_sequence(model.getBootSequence());
    getcurrentVm().setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setinitrd_url((String) model.getInitrd_path().getEntity());
    getcurrentVm().setkernel_url((String) model.getKernel_path().getEntity());
    getcurrentVm().setkernel_params((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setpriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setdedicated_vm_for_vds(null);
    } else {
        getcurrentVm().setdedicated_vm_for_vds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    if (model.getIsNew()) {
        if (getcurrentVm().getvmt_guid().equals(NGuid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), NGuid.Empty), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    vmListModel.getWindow().StopProgress();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        vmListModel.Cancel();
                        vmListModel.setGuideContext(returnValueBase.getActionReturnValue());
                        vmListModel.UpdateActionAvailability();
                        vmListModel.getGuideCommand().Execute();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.StartProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        HashMap<Guid, DiskImage> imageToDestinationDomainMap = unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap();
                        ArrayList<storage_domains> activeStorageDomains = unitVmModel.getDisksAllocationModel().getActiveStorageDomains();
                        HashMap<Guid, DiskImage> dict = unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) unitVmModel.getDisksAllocationModel().getIsSingleStorageDomain().getEntity());
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : unitVmModel.getDisksAllocationModel().getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            storage_domains storageDomain = Linq.getStorageById(imageToDestinationDomainMap.get(templateDisk.getImageId()).getstorage_ids().get(0), activeStorageDomains);
                            if (disk != null) {
                                dict.get(templateDisk.getImageId()).setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                dict.get(templateDisk.getImageId()).setvolume_format(DataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), storageDomain.getstorage_type()));
                            }
                        }
                        storage_domains storageDomain = (storage_domains) unitVmModel.getDisksAllocationModel().getStorageDomain().getSelectedItem();
                        AddVmFromTemplateParameters parameters = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), dict, storageDomain.getId());
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendActionAsyncResult result) {
                                VmListModel vmListModel1 = (VmListModel) result.getState();
                                vmListModel1.getWindow().StopProgress();
                                VdcReturnValueBase returnValueBase = result.getReturnValue();
                                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                                    vmListModel1.Cancel();
                                }
                            }
                        }, vmListModel);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.StartProgress(null);
                HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
                storage_domains storageDomain = ((storage_domains) model.getDisksAllocationModel().getStorageDomain().getSelectedItem());
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
                Frontend.RunAction(VdcActionType.AddVm, params, new IFrontendActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendActionAsyncResult result) {
                        VmListModel vmListModel = (VmListModel) result.getState();
                        vmListModel.getWindow().StopProgress();
                        VdcReturnValueBase returnValueBase = result.getReturnValue();
                        if (returnValueBase != null && returnValueBase.getSucceeded()) {
                            vmListModel.Cancel();
                        }
                    }
                }, this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getvds_group_id();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(vmListModel.getcurrentVm()), new IFrontendActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendActionAsyncResult result1) {
                                VmListModel vmListModel1 = (VmListModel) result1.getState();
                                vmListModel1.getWindow().StopProgress();
                                VdcReturnValueBase retVal = result1.getReturnValue();
                                boolean isSucceeded = retVal.getSucceeded();
                                if (retVal != null && isSucceeded) {
                                    vmListModel1.Cancel();
                                }
                            }
                        }, vmListModel);
                    } else {
                        vmListModel.getWindow().StopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(getcurrentVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    vmListModel.getWindow().StopProgress();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        vmListModel.Cancel();
                    }
                }
            }, this);
        }
    }
}
#method_after
private void OnSave() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    if (model.getIsNew() == false && selectedItem == null) {
        Cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.Validate()) {
        return;
    }
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!DataProvider.IsVmNameUnique(name) && name.compareToIgnoreCase(getcurrentVm().getvm_name()) != 0) {
        model.getName().setIsValid(false);
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setvm_type(model.getVmType());
    getcurrentVm().setvmt_guid(template.getId());
    getcurrentVm().setvm_name(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setvm_os((VmOsType) model.getOSType().getSelectedItem());
    getcurrentVm().setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setvm_description((String) model.getDescription().getEntity());
    getcurrentVm().setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    getcurrentVm().setvds_group_id(newClusterID);
    getcurrentVm().settime_zone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setnum_of_sockets((Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setcpu_per_socket((Integer) model.getTotalCPUCores().getEntity() / (Integer) model.getNumOfSockets().getEntity());
    getcurrentVm().setusb_policy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setis_auto_suspend(false);
    getcurrentVm().setis_stateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setdefault_boot_sequence(model.getBootSequence());
    getcurrentVm().setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setinitrd_url((String) model.getInitrd_path().getEntity());
    getcurrentVm().setkernel_url((String) model.getKernel_path().getEntity());
    getcurrentVm().setkernel_params((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setpriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setdedicated_vm_for_vds(null);
    } else {
        getcurrentVm().setdedicated_vm_for_vds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        getcurrentVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    if (model.getIsNew()) {
        if (getcurrentVm().getvmt_guid().equals(NGuid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), NGuid.Empty), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    vmListModel.getWindow().StopProgress();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        vmListModel.Cancel();
                        vmListModel.setGuideContext(returnValueBase.getActionReturnValue());
                        vmListModel.UpdateActionAvailability();
                        vmListModel.getGuideCommand().Execute();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.StartProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        HashMap<Guid, DiskImage> imageToDestinationDomainMap = unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap();
                        ArrayList<storage_domains> activeStorageDomains = unitVmModel.getDisksAllocationModel().getActiveStorageDomains();
                        HashMap<Guid, DiskImage> dict = unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) unitVmModel.getDisksAllocationModel().getIsSingleStorageDomain().getEntity());
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : unitVmModel.getDisksAllocationModel().getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            storage_domains storageDomain = Linq.getStorageById(imageToDestinationDomainMap.get(templateDisk.getId()).getstorage_ids().get(0), activeStorageDomains);
                            if (disk != null) {
                                dict.get(templateDisk.getId()).setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                dict.get(templateDisk.getId()).setvolume_format(DataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), storageDomain.getstorage_type()));
                            }
                        }
                        storage_domains storageDomain = (storage_domains) unitVmModel.getDisksAllocationModel().getStorageDomain().getSelectedItem();
                        AddVmFromTemplateParameters parameters = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), dict, storageDomain.getId());
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendActionAsyncResult result) {
                                VmListModel vmListModel1 = (VmListModel) result.getState();
                                vmListModel1.getWindow().StopProgress();
                                VdcReturnValueBase returnValueBase = result.getReturnValue();
                                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                                    vmListModel1.Cancel();
                                }
                            }
                        }, vmListModel);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.StartProgress(null);
                HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
                storage_domains storageDomain = ((storage_domains) model.getDisksAllocationModel().getStorageDomain().getSelectedItem());
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
                Frontend.RunAction(VdcActionType.AddVm, params, new IFrontendActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendActionAsyncResult result) {
                        VmListModel vmListModel = (VmListModel) result.getState();
                        vmListModel.getWindow().StopProgress();
                        VdcReturnValueBase returnValueBase = result.getReturnValue();
                        if (returnValueBase != null && returnValueBase.getSucceeded()) {
                            vmListModel.Cancel();
                        }
                    }
                }, this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getvds_group_id();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(vmListModel.getcurrentVm()), new IFrontendActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendActionAsyncResult result1) {
                                VmListModel vmListModel1 = (VmListModel) result1.getState();
                                vmListModel1.getWindow().StopProgress();
                                VdcReturnValueBase retVal = result1.getReturnValue();
                                boolean isSucceeded = retVal.getSucceeded();
                                if (retVal != null && isSucceeded) {
                                    vmListModel1.Cancel();
                                }
                            }
                        }, vmListModel);
                    } else {
                        vmListModel.getWindow().StopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.StartProgress(null);
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(getcurrentVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    VmListModel vmListModel = (VmListModel) result.getState();
                    vmListModel.getWindow().StopProgress();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        vmListModel.Cancel();
                    }
                }
            }, this);
        }
    }
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    getTable().addColumn(nameColumn, constants.nameClusterHost());
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    getTable().addColumn(hostColumn, constants.hostIpClusterHost());
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, constants.statusClusterHost());
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> loadColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                // $NON-NLS-1$
                return object.getvm_active() + " " + constants.vmsClusterHost();
            }
        };
        getTable().addColumn(loadColumn, constants.loadClusterHost());
    }
}
#method_after
void initTable(final ApplicationConstants constants) {
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    getTable().addColumn(nameColumn, constants.nameClusterHost());
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    getTable().addColumn(hostColumn, constants.hostIpClusterHost());
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, constants.statusClusterHost());
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        TextColumnWithTooltip<VDS> loadColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                // $NON-NLS-1$
                return object.getvm_active() + " " + constants.vmsClusterHost();
            }
        };
        getTable().addColumn(loadColumn, constants.loadClusterHost());
    }
}
#end_block

#method_before
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid", "uniqueIdentifier" });
                // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    String guid = guidFromResults(answer.next());
                    if (guid == null) {
                        break;
                    }
                    userGuid.append(guid);
                    log.debug("User guid is: " + userGuid.toString());
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#method_after
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    env.put("javax.security.sasl.qop", "auth-conf");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid", "uniqueIdentifier" });
                // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    String guid = guidFromResults(answer.next());
                    if (guid == null) {
                        break;
                    }
                    userGuid.append(guid);
                    log.debug("User guid is: " + userGuid.toString());
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
            log.error("Error from Kerberos: " + ex.getMessage());
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#end_block

#method_before
protected void setUpCommand() {
    command = createCommand();
    doReturn(true).when(command).areTemplateImagesInStorageReady(any(Guid.class));
    doReturn(true).when(command).isMemorySizeLegal(any(VDSGroup.class), any(VmStatic.class));
    doReturn(true).when(command).verifyAddVM(any(VDSGroup.class));
}
#method_after
protected void setUpCommand() {
    command = createCommand();
    doReturn(true).when(command).areTemplateImagesInStorageReady(any(Guid.class));
    doReturn(true).when(command).isMemorySizeLegal(any(Version.class));
    doReturn(true).when(command).verifyAddVM(any(Guid.class));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup grp = getVdsGroupDAO().get(getParameters().getVmPool().getvds_group_id());
    if (grp == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    VmStatic vmStaticData = getParameters().getVmStaticData();
    if (!isMemorySizeLegal(grp, vmStaticData)) {
        return false;
    }
    vm_pools pool = getVmPoolDAO().getByName(getParameters().getVmPool().getvm_pool_name());
    if (pool != null && (getActionType() == VdcActionType.AddVmPoolWithVms || !pool.getvm_pool_id().equals(getParameters().getVmPoolId()))) {
        addCanDoActionMessage(VdcBllMessages.VM_POOL_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (!((Boolean) runVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(grp.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    if (!verifyAddVM(grp)) {
        return false;
    }
    if (!ensureDestinationImageMap()) {
        return false;
    }
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskMap().values(), diskInfoDestinationMap);
    List<Guid> storageIds = new ArrayList<Guid>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getstorage_ids().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPoolWithVms && getParameters().getVmsCount() < 1) {
        addCanDoActionMessage(VdcBllMessages.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
        return false;
    }
    if (getParameters().getVmStaticData().getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getvm_assigned_count()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
        return false;
    }
    return checkFreeSpaceAndTypeOnDestDomains();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup grp = getVdsGroupDAO().get(getParameters().getVmPool().getvds_group_id());
    if (grp == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!isMemorySizeLegal(grp.getcompatibility_version())) {
        return false;
    }
    vm_pools pool = getVmPoolDAO().getByName(getParameters().getVmPool().getvm_pool_name());
    if (pool != null && (getActionType() == VdcActionType.AddVmPoolWithVms || !pool.getvm_pool_id().equals(getParameters().getVmPoolId()))) {
        addCanDoActionMessage(VdcBllMessages.VM_POOL_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    if (!((Boolean) runVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(grp.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    if (!verifyAddVM(grp.getstorage_pool_id().getValue())) {
        return false;
    }
    if (!ensureDestinationImageMap()) {
        return false;
    }
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getVmTemplate().getDiskMap().values(), diskInfoDestinationMap);
    List<Guid> storageIds = new ArrayList<Guid>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        Guid storageId = diskImage.getstorage_ids().get(0);
        if (!storageIds.contains(storageId) && !areTemplateImagesInStorageReady(storageId)) {
            return false;
        }
        storageIds.add(storageId);
    }
    if (getActionType() == VdcActionType.AddVmPoolWithVms && getParameters().getVmsCount() < 1) {
        addCanDoActionMessage(VdcBllMessages.VM_POOL_CANNOT_CREATE_WITH_NO_VMS);
        return false;
    }
    if (getParameters().getVmStaticData().getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (getParameters().getVmPool().getPrestartedVms() > getParameters().getVmPool().getvm_assigned_count()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_PRESTARTED_VMS_CANNOT_EXCEED_VMS_COUNT);
        return false;
    }
    return checkFreeSpaceAndTypeOnDestDomains();
}
#end_block

#method_before
protected boolean isMemorySizeLegal(VDSGroup grp, VmStatic vmStaticData) {
    return VmHandler.isMemorySizeLegal(vmStaticData.getos(), vmStaticData.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), grp.getcompatibility_version().toString());
}
#method_after
protected boolean isMemorySizeLegal(Version version) {
    VmStatic vmStaticData = getParameters().getVmStaticData();
    return VmHandler.isMemorySizeLegal(vmStaticData.getos(), vmStaticData.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), version.toString());
}
#end_block

#method_before
protected boolean verifyAddVM(VDSGroup grp) {
    return VmHandler.VerifyAddVm(getReturnValue().getCanDoActionMessages(), getParameters().getVmsCount() * getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplateId()).size(), getVmTemplate(), grp.getstorage_pool_id().getValue(), getParameters().getVmStaticData().getpriority());
}
#method_after
protected boolean verifyAddVM(Guid storagePoolId) {
    return VmHandler.VerifyAddVm(getReturnValue().getCanDoActionMessages(), getParameters().getVmsCount() * getVmNetworkInterfaceDAO().getAllForTemplate(getVmTemplateId()).size(), getVmTemplate(), storagePoolId, getParameters().getVmStaticData().getpriority());
}
#end_block

#method_before
public static void main(String[] args) {
    try {
        CLIParse parser = new CLIParse(args);
        if (parser.hasArg("?") || parser.hasArg("help") || args.length == 0) {
            printUsage();
            return;
        }
        if (!validate(parser)) {
            return;
        }
        String alias = "engine";
        if (parser.hasArg("alias")) {
            alias = parser.getArg("alias");
        }
        if (parser.hasArg("enc")) {
            System.out.println(EncryptionUtils.encrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias).trim().replace("\r\n", ""));
        } else if (parser.hasArg("dec")) {
            System.out.println(EncryptionUtils.decrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pvk")) {
            System.out.write(pvk(parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pubkey2ssh")) {
            System.out.println(pubkey2ssh(parser.getArg("store"), parser.getArg("pass"), alias));
        }
        System.exit(0);
    } catch (Exception e) {
        System.out.println("Operation failed!");
        System.exit(1);
    }
}
#method_after
public static void main(String[] args) {
    int exitCode = 0;
    try {
        CLIParse parser = new CLIParse(args);
        if (parser.hasArg("?") || parser.hasArg("help") || args.length == 0) {
            printUsage();
            return;
        }
        if (!validate(parser)) {
            exitCode = 1;
            return;
        }
        String alias = "engine";
        if (parser.hasArg("alias")) {
            alias = parser.getArg("alias");
        }
        if (parser.hasArg("enc")) {
            System.out.println(EncryptionUtils.encrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias).trim().replace("\r\n", ""));
        } else if (parser.hasArg("dec")) {
            System.out.println(EncryptionUtils.decrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pvk")) {
            System.out.write(pvk(parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pubkey2ssh")) {
            System.out.println(pubkey2ssh(parser.getArg("store"), parser.getArg("pass"), alias));
        }
    } catch (Exception e) {
        System.out.println("Operation failed!");
        exitCode = 1;
    } finally {
        System.exit(exitCode);
    }
}
#end_block

#method_before
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    NetworkParameters netParams = getSetupModel().getNetwork2LastDetachParams().get(getName());
    if (netParams != null) {
        targetNic.getEntity().setBootProtocol(netParams.getBootProtocol());
        targetNic.getEntity().setAddress(netParams.getAddress());
        targetNic.getEntity().setSubnet(netParams.getSubnet());
        targetNic.getEntity().setGateway(netParams.getGateway());
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setVlanId(getVlanId());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBootProtocol(targetNicEntity.getBootProtocol());
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        return null;
    }
}
#method_after
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    NetworkParameters netParams = getSetupModel().getNetworkToLastDetachParams().get(getName());
    if (netParams != null) {
        targetNic.getEntity().setBootProtocol(netParams.getBootProtocol());
        targetNic.getEntity().setAddress(netParams.getAddress());
        targetNic.getEntity().setSubnet(netParams.getSubnet());
        targetNic.getEntity().setGateway(netParams.getGateway());
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setVlanId(getVlanId());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBootProtocol(targetNicEntity.getBootProtocol());
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        return null;
    }
}
#end_block

#method_before
public void detach() {
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getEntity();
    NetworkParameters netParams = new NetworkParameters();
    netParams.setBootProtocol(nicEntity.getBootProtocol());
    netParams.setAddress(nicEntity.getAddress());
    netParams.setSubnet(nicEntity.getSubnet());
    if (isManagement()) {
        netParams.setGateway(nicEntity.getGateway());
    }
    getSetupModel().getNetwork2LastDetachParams().put(getName(), netParams);
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
        nicEntity.setBootProtocol(null);
        nicEntity.setAddress(null);
        nicEntity.setSubnet(null);
        nicEntity.setGateway(null);
    }
    setBridge(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
}
#method_after
public void detach() {
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getEntity();
    NetworkParameters netParams = new NetworkParameters();
    netParams.setBootProtocol(nicEntity.getBootProtocol());
    netParams.setAddress(nicEntity.getAddress());
    netParams.setSubnet(nicEntity.getSubnet());
    if (isManagement()) {
        netParams.setGateway(nicEntity.getGateway());
    }
    getSetupModel().getNetworkToLastDetachParams().put(getName(), netParams);
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
        nicEntity.setBootProtocol(null);
        nicEntity.setAddress(null);
        nicEntity.setSubnet(null);
        nicEntity.setGateway(null);
    }
    setBridge(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
}
#end_block

#method_before
@Override
public network getEntity() {
    return (network) super.getEntity();
}
#method_after
@Override
public Network getEntity() {
    return (Network) super.getEntity();
}
#end_block

#method_before
private LogicalNetworkModel createErrorNetworkModel(String networkName, Integer vlanId) {
    network errorNetwork = new network();
    errorNetwork.setname(networkName);
    errorNetwork.setvlan_id(vlanId);
    LogicalNetworkModel networkModel = new LogicalNetworkModel(errorNetwork, this);
    networkModel.setError(ConstantsManager.getInstance().getConstants().thisNetworkDoesNotExistInTheClusterErr());
    networkMap.put(networkName, networkModel);
    return networkModel;
}
#method_after
private LogicalNetworkModel createErrorNetworkModel(String networkName, Integer vlanId) {
    Network errorNetwork = new Network();
    errorNetwork.setname(networkName);
    errorNetwork.setvlan_id(vlanId);
    LogicalNetworkModel networkModel = new LogicalNetworkModel(errorNetwork, this);
    networkModel.setError(ConstantsManager.getInstance().getConstants().thisNetworkDoesNotExistInTheClusterErr());
    networkMap.put(networkName, networkModel);
    return networkModel;
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    for (network network : allNetworks) {
        networkModels.put(network.getname(), new LogicalNetworkModel(network, this));
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    for (Network network : allNetworks) {
        networkModels.put(network.getname(), new LogicalNetworkModel(network, this));
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            List<network> networks = (List<network>) returnValue;
            allNetworks = networks;
            initNetworkModels();
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = (VDS) getEntity();
    AsyncDataProvider.GetClusterNetworkList(asyncQuery, vds.getvds_group_id());
}
#method_after
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            List<Network> networks = (List<Network>) returnValue;
            allNetworks = networks;
            initNetworkModels();
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = (VDS) getEntity();
    AsyncDataProvider.GetClusterNetworkList(asyncQuery, vds.getvds_group_id());
}
#end_block

#method_before
public List<VdcBllMessages> validate() {
    Set<String> ifaceNames = new HashSet<String>();
    Set<String> bonds = new HashSet<String>();
    Set<String> attachedNetworksNames = new HashSet<String>();
    // key = master bond name, value = list of interfaces
    Map<String, List<VdsNetworkInterface>> bondSlaves = new HashMap<String, List<VdsNetworkInterface>>();
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        String networkName = iface.getNetworkName();
        String bondName = iface.getBondName();
        if (ifaceNames.contains(name)) {
            violations.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE);
            continue;
        } else {
            ifaceNames.add(name);
        }
        if (isBond(iface)) {
            extractBondIfModified(bonds, iface, name);
        } else {
            if (StringUtils.isNotBlank(bondName)) {
                extractBondSlave(bondSlaves, iface, bondName);
            }
            // validate the nic exists on host
            if (!getExistingIfaces().containsKey(NetworkUtils.StripVlan(name))) {
                violations.add(VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS);
            }
        }
        // validate and extract to network map
        if (violations.isEmpty() && StringUtils.isNotBlank(networkName)) {
            extractNetwork(attachedNetworksNames, iface, networkName);
        }
    }
    validateBonds(bonds, bondSlaves);
    detectSlaveChanges(bondSlaves);
    extractRemoveNetworks(attachedNetworksNames, getExisitingHostNetworkNames());
    this.removedBonds = extractRemovedBonds(bonds);
    return violations;
}
#method_after
public List<VdcBllMessages> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else {
                if (StringUtils.isNotBlank(iface.getBondName())) {
                    extractBondSlave(iface);
                }
                // validate the nic exists on host
                if (!getExistingIfaces().containsKey(NetworkUtils.StripVlan(name))) {
                    violations.add(VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS);
                }
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
            }
        }
    }
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    detectSlaveChanges();
    return violations;
}
#end_block

#method_before
private void detectSlaveChanges(Map<String, List<VdsNetworkInterface>> bondSlaves) {
    for (Map.Entry<String, List<VdsNetworkInterface>> bondEntry : bondSlaves.entrySet()) {
        String bondName = bondEntry.getKey();
        if (!modifiedBonds.containsKey(bondName)) {
            for (VdsNetworkInterface bondSlave : bondEntry.getValue()) {
                if (interfaceWasModified(bondSlave)) {
                    modifiedBonds.put(bondName, getExistingIfaces().get(bondName));
                }
            }
        }
    }
}
#method_after
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        if (!isBond(newIface) && newIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = getExistingIfaces().get(newIface.getName()).getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.contains(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#end_block

#method_before
private void extractNetwork(Set<String> attachedNetworksNames, VdsNetworkInterface iface, String networkName) {
    // check if network exists on cluster
    if (getExistingClusterNetworks().containsKey(networkName)) {
        // prevent attaching 2 interfaces to 1 network
        if (attachedNetworksNames.contains(networkName)) {
            violations.add(VdcBllMessages.NETWROK_ALREADY_ATTACHED_TO_INTERFACE);
        } else {
            attachedNetworksNames.add(networkName);
            if (interfaceWasModified(iface)) {
                modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
            }
        }
    // Interface must exist, it was checked before and we can't reach here if it does'nt exist already.
    } else if (networkName.equals(getExistingIfaces().get(iface.getName()).getNetworkName())) {
        unmanagedNetworks.add(networkName);
    } else {
        violations.add(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        violations.add(VdcBllMessages.NETWROK_ALREADY_ATTACHED_TO_INTERFACE);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            if (networkWasModified(iface)) {
                modifiedNetworks.add(getExistingClusterNetworks().get(networkName));
            }
        } else if (unmanagedNetworkChanged(iface)) {
            violations.add(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        }
    }
}
#end_block

#method_before
protected void extractBondSlave(Map<String, List<VdsNetworkInterface>> bondSlaves, VdsNetworkInterface iface, String bondName) {
    List<VdsNetworkInterface> value = new ArrayList<VdsNetworkInterface>();
    value.add(iface);
    if (bondSlaves.containsKey(bondName)) {
        value.addAll(bondSlaves.get(bondName));
    }
    bondSlaves.put(bondName, value);
}
#method_after
private void extractBondSlave(VdsNetworkInterface iface) {
    List<VdsNetworkInterface> slaves = bonds.get(iface.getBondName());
    if (slaves == null) {
        slaves = new ArrayList<VdsNetworkInterface>();
        bonds.put(iface.getBondName(), slaves);
    }
    slaves.add(iface);
}
#end_block

#method_before
protected void extractBondIfModified(Set<String> bonds, VdsNetworkInterface iface, String name) {
    if (bonds.contains(name)) {
        violations.add(VdcBllMessages.NETWORK_BOND_NAME_EXISTS);
    } else {
        bonds.add(name);
        if (interfaceWasModified(iface)) {
            modifiedBonds.put(name, iface);
        }
    }
}
#method_after
private void extractBondIfModified(VdsNetworkInterface iface, String bondName) {
    if (!bonds.containsKey(bondName)) {
        bonds.put(bondName, new ArrayList<VdsNetworkInterface>());
    }
    if (bondWasModified(iface)) {
        modifiedBonds.put(bondName, iface);
    }
}
#end_block

#method_before
protected List<VdsNetworkInterface> extractRemovedBonds(Set<String> bonds) {
    List<VdsNetworkInterface> removedBonds = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.contains(bondName)) {
            removedBonds.add(getExistingIfaces().get(bondName));
        }
    }
    return removedBonds;
}
#method_after
private void extractRemovedBonds() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.containsKey(bondName)) {
            removedBonds.add(bondName);
        }
    }
}
#end_block

#method_before
public List<String> getRemoveNetworks() {
    return removeNetworks;
}
#method_after
public List<String> getRemoveNetworks() {
    return removedNetworks;
}
#end_block

#method_before
public List<VdsNetworkInterface> getRemovedBonds() {
    return removedBonds;
}
#method_after
public Set<String> getRemovedBonds() {
    return removedBonds;
}
#end_block

#method_before
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setVlanId(getVlanId());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBootProtocol(targetNicEntity.getBootProtocol());
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        return null;
    }
}
#method_after
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
        targetNic.getEntity().setBootProtocol(NetworkBootProtocol.Dhcp);
    } else {
        targetNic.getEntity().setBootProtocol(NetworkBootProtocol.None);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setVlanId(getVlanId());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBootProtocol(targetNicEntity.getBootProtocol());
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        return null;
    }
}
#end_block

#method_before
public void detach() {
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getEntity();
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
    }
    setBridge(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
}
#method_after
public void detach() {
    assert attachedToNic != null;
    NetworkInterfaceModel attachingNic = attachedToNic;
    // this needs to be null before the NIC items are changed, because they trigger an event
    attachedToNic = null;
    List<LogicalNetworkModel> nicNetworks = attachingNic.getItems();
    nicNetworks.remove(this);
    // clear network name
    VdsNetworkInterface nicEntity = attachingNic.getEntity();
    if (!hasVlan()) {
        nicEntity.setNetworkName(null);
        nicEntity.setBootProtocol(null);
        nicEntity.setAddress(null);
        nicEntity.setSubnet(null);
        nicEntity.setGateway(null);
    }
    setBridge(null);
    // is this a management nic?
    if (nicEntity.getIsManagement()) {
        nicEntity.setType(0);
    }
}
#end_block

#method_before
private XmlRpcStruct generateNetworks() {
    XmlRpcStruct networks = new XmlRpcStruct();
    // Networks
    for (Network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        Boolean bonded = isVlan(net) ? findInterfaceByName(NetworkUtils.StripVlan(i.getName())).getBonded() : i.getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (isVlan(net)) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(BOOT_PROTOCOL, DHCP_BOOT_PROTOCOL);
                break;
            case StaticIp:
                putIfNotEmpty(opts, "ipaddr", i.getAddress());
                putIfNotEmpty(opts, "netmask", i.getSubnet());
                putIfNotEmpty(opts, "gateway", i.getGateway());
                break;
        }
        if (net.getMtu() != 0) {
            opts.put("mtu", String.valueOf(net.getMtu()));
        }
        opts.put("bridged", Boolean.toString(net.isVmNetwork()));
        networks.add(net.getname(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.add(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private XmlRpcStruct generateNetworks() {
    XmlRpcStruct networks = new XmlRpcStruct();
    for (Network net : getParameters().getNetworks()) {
        Map<String, String> opts = new HashMap<String, String>();
        VdsNetworkInterface i = findNetworkInterface(net.getname(), getParameters().getInterfaces(), getParameters().getBonds());
        Boolean bonded = isVlan(net) ? findInterfaceByName(NetworkUtils.StripVlan(i.getName())).getBonded() : i.getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, NetworkUtils.StripVlan(i.getName()));
        if (isVlan(net)) {
            opts.put("vlan", net.getvlan_id().toString());
        }
        // TODO: add bootproto to network object
        switch(i.getBootProtocol()) {
            case Dhcp:
                opts.put(BOOT_PROTOCOL, DHCP_BOOT_PROTOCOL);
                break;
            case StaticIp:
                putIfNotEmpty(opts, "ipaddr", i.getAddress());
                putIfNotEmpty(opts, "netmask", i.getSubnet());
                putIfNotEmpty(opts, "gateway", i.getGateway());
                break;
        }
        if (net.getMtu() != 0) {
            opts.put("mtu", String.valueOf(net.getMtu()));
        }
        opts.put("bridged", Boolean.toString(net.isVmNetwork()));
        networks.add(net.getname(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.add(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private XmlRpcStruct generateBonds() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add(SLAVES, getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add(BONDING_OPTIONS, bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    for (VdsNetworkInterface bond : getParameters().getRemovedBonds()) {
        bonds.add(bond.getName(), REMOVE_OBJ);
    }
    return bonds;
}
#method_after
private XmlRpcStruct generateBonds() {
    XmlRpcStruct bonds = new XmlRpcStruct();
    for (VdsNetworkInterface bond : getParameters().getBonds()) {
        XmlRpcStruct opts = new XmlRpcStruct();
        opts.add(SLAVES, getBondNics(bond, getParameters().getInterfaces()));
        if (!StringHelper.isNullOrEmpty(bond.getBondOptions())) {
            opts.add(BONDING_OPTIONS, bond.getBondOptions());
        }
        bonds.add(bond.getName(), opts);
    }
    for (String bond : getParameters().getRemovedBonds()) {
        bonds.add(bond, REMOVE_OBJ);
    }
    return bonds;
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.ExecuteVdsBrokerCommand();
    // update to db
    persistAndEnforceNetworkCompliance(getVds());
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.ExecuteVdsBrokerCommand();
    updateNetConfigDirtyFlag();
    // update to db
    persistAndEnforceNetworkCompliance(getVds());
    ProceedProxyReturnValue();
}
#end_block

#method_before
private static String getVmNetworksImplementedAsBridgeless(VDS vds, List<Network> clusterNetworks) {
    StringBuffer sb = new StringBuffer();
    Map<String, VdsNetworkInterface> interfacesByNetworkName = Entities.interfacesByNetworkName(vds.getInterfaces());
    for (Network net : clusterNetworks) {
        if (net.isVmNetwork() && interfacesByNetworkName.containsKey(net.getName()) && !interfacesByNetworkName.get(net.getName()).isBridged()) {
            sb.append(net.getname()).append(",");
        }
    }
    return sb.toString();
}
#method_after
private static String getVmNetworksImplementedAsBridgeless(VDS vds, List<Network> clusterNetworks) {
    Map<String, VdsNetworkInterface> interfacesByNetworkName = Entities.interfacesByNetworkName(vds.getInterfaces());
    List<String> networkNames = new ArrayList<String>();
    for (Network net : clusterNetworks) {
        if (net.isVmNetwork() && interfacesByNetworkName.containsKey(net.getName()) && !interfacesByNetworkName.get(net.getName()).isBridged()) {
            networkNames.add(net.getname());
        }
    }
    return StringUtils.join(networkNames, ",");
}
#end_block

#method_before
private static String getMissingOperationalClusterNetworks(VDS vds, List<Network> clusterNetworks) {
    StringBuffer sb = new StringBuffer();
    Map<String, Network> vdsNetworksByName = Entities.entitiesByName(vds.getNetworks());
    for (Network net : clusterNetworks) {
        if (net.getStatus() == Operational && net.isRequired() && !vdsNetworksByName.containsKey(net.getName())) {
            sb.append(net.getName()).append(",");
        }
    }
    return sb.toString();
}
#method_after
private static String getMissingOperationalClusterNetworks(VDS vds, List<Network> clusterNetworks) {
    Map<String, Network> vdsNetworksByName = Entities.entitiesByName(vds.getNetworks());
    List<String> networkNames = new ArrayList<String>();
    for (Network net : clusterNetworks) {
        if (net.getStatus() == Operational && net.isRequired() && !vdsNetworksByName.containsKey(net.getName())) {
            networkNames.add(net.getname());
        }
    }
    return StringUtils.join(networkNames, ",");
}
#end_block

#method_before
public static int GetDiskMaxSize() {
    VdcQueryReturnValue returnValue = GetConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxDiskSize));
    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
        return (Integer) returnValue.getReturnValue();
    }
    return 2047;
}
#method_after
public static int GetDiskMaxSize() {
    VdcQueryReturnValue returnValue = GetConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxBlockDiskSize));
    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
        return (Integer) returnValue.getReturnValue();
    }
    return 2047;
}
#end_block

#method_before
private void New() {
    VM vm = (VM) getEntity();
    if (getWindow() != null) {
        return;
    }
    ArrayList<VmNetworkInterface> interfaces = Linq.<VmNetworkInterface>Cast(getItems());
    String newNicName = DataProvider.GetNewNicName(interfaces);
    VmInterfaceModel model = new VmInterfaceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newNetworkInterfaceTitle());
    // $NON-NLS-1$
    model.setHashName("new_network_interface_vms");
    model.setIsNew(true);
    model.getNicType().setItems(DataProvider.GetNicTypeList(vm.getvm_os(), false));
    model.getNicType().setSelectedItem(DataProvider.GetDefaultNicType(vm.getvm_os()));
    model.getName().setEntity(newNicName);
    model.getMAC().setIsChangable(false);
    model.getActive().setIsChangable(isActivateSupported);
    if (isActivateSupported) {
        model.getActive().setEntity(true);
    } else {
        model.getActive().setEntity(false);
    }
    model.getPortMirroring().setEntity(false);
    // $NON-NLS-1$
    final UICommand okCommand = new UICommand("OnSave", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // wait for data to fetch
    okCommand.setIsExecutionAllowed(false);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result1) {
            VmInterfaceListModel vmInterfaceListModel = (VmInterfaceListModel) model1;
            VmInterfaceModel vmInterfaceModel = (VmInterfaceModel) vmInterfaceListModel.getWindow();
            ArrayList<Network> networks = new ArrayList<Network>();
            for (Network a : (ArrayList<Network>) result1) {
                if (a.getStatus() == NetworkStatus.Operational) {
                    networks.add(a);
                }
            }
            if (vmInterfaceModel.getIsNew()) {
                vmInterfaceModel.getNetwork().setItems(networks);
                vmInterfaceModel.getNetwork().setSelectedItem(networks.size() > 0 ? networks.get(0) : null);
            } else {
                VmNetworkInterface nic = (VmNetworkInterface) vmInterfaceListModel.getSelectedItem();
                vmInterfaceModel.getNetwork().setItems(networks);
                vmInterfaceModel.getNetwork().setSelectedItem(null);
                for (Network a : networks) {
                    if (StringHelper.stringsEqual(a.getname(), nic.getNetworkName())) {
                        vmInterfaceModel.getNetwork().setSelectedItem(a);
                        break;
                    }
                }
            }
            // fetch completed
            okCommand.setIsExecutionAllowed(true);
        }
    };
    AsyncDataProvider.GetClusterNetworkList(_asyncQuery, vm.getvds_group_id());
}
#method_after
private void New() {
    VM vm = (VM) getEntity();
    if (getWindow() != null) {
        return;
    }
    ArrayList<VmNetworkInterface> interfaces = Linq.<VmNetworkInterface>Cast(getItems());
    String newNicName = DataProvider.GetNewNicName(interfaces);
    VmInterfaceModel model = new VmInterfaceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newNetworkInterfaceTitle());
    // $NON-NLS-1$
    model.setHashName("new_network_interface_vms");
    model.setIsNew(true);
    model.getNicType().setItems(DataProvider.GetNicTypeList(vm.getvm_os(), false));
    model.getNicType().setSelectedItem(DataProvider.GetDefaultNicType(vm.getvm_os()));
    model.getName().setEntity(newNicName);
    model.getMAC().setIsChangable(false);
    model.getActive().setIsChangable(isActivateSupported);
    model.getActive().setEntity(true);
    model.getPortMirroring().setEntity(false);
    // $NON-NLS-1$
    final UICommand okCommand = new UICommand("OnSave", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // wait for data to fetch
    okCommand.setIsExecutionAllowed(false);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result1) {
            VmInterfaceListModel vmInterfaceListModel = (VmInterfaceListModel) model1;
            VmInterfaceModel vmInterfaceModel = (VmInterfaceModel) vmInterfaceListModel.getWindow();
            ArrayList<Network> networks = new ArrayList<Network>();
            for (Network a : (ArrayList<Network>) result1) {
                if (a.getStatus() == NetworkStatus.Operational) {
                    networks.add(a);
                }
            }
            if (vmInterfaceModel.getIsNew()) {
                vmInterfaceModel.getNetwork().setItems(networks);
                vmInterfaceModel.getNetwork().setSelectedItem(networks.size() > 0 ? networks.get(0) : null);
            } else {
                VmNetworkInterface nic = (VmNetworkInterface) vmInterfaceListModel.getSelectedItem();
                vmInterfaceModel.getNetwork().setItems(networks);
                vmInterfaceModel.getNetwork().setSelectedItem(null);
                for (Network a : networks) {
                    if (StringHelper.stringsEqual(a.getname(), nic.getNetworkName())) {
                        vmInterfaceModel.getNetwork().setSelectedItem(a);
                        break;
                    }
                }
            }
            // fetch completed
            okCommand.setIsExecutionAllowed(true);
        }
    };
    AsyncDataProvider.GetClusterNetworkList(_asyncQuery, vm.getvds_group_id());
}
#end_block

#method_before
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParamenters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParamenters(storagePoolId, storageDomainId);
    getAllFromExportDomainQueryParamenters.setGetAll(true);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    getAllFromExportDomainQueryParamenters.setGetAll(true);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static void GetDiskMaxSize(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 2047;
        }
    };
    GetConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxDiskSize), aQuery);
}
#method_after
public static void GetDiskMaxSize(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    GetConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxBlockDiskSize), aQuery);
}
#end_block

#method_before
public static void GetVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<DiskImage> list = new ArrayList<DiskImage>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((DiskImage) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(id), aQuery);
}
#method_after
public static void GetVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllDisksByVmId, new GetAllDisksByVmIdParameters(id), aQuery);
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel> getDataCenterNetworkListProvider(ClientGinjector ginjector, final Provider<DataCenterNetworkPopupPresenterWidget> networkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel>(ginjector, DataCenterListModel.class, DataCenterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewCommand()) {
                return networkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand.getName().equals("DetachClusters")) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel> getDataCenterNetworkListProvider(ClientGinjector ginjector, final Provider<NewDataCenterNetworkPopupPresenterWidget> newNetworkPopupProvider, final Provider<EditDataCenterNetworkPopupPresenterWidget> editNetworkPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<Network, DataCenterListModel, DataCenterNetworkListModel>(ginjector, DataCenterListModel.class, DataCenterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return newNetworkPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return editNetworkPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(DataCenterNetworkListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand.getName().equals("Apply")) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            RefObject<Boolean> tempRefObj = new RefObject<Boolean>(processHardwareCapsNeeded);
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(tempRefObj, _vds);
            processHardwareCapsNeeded = tempRefObj.argvalue;
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintanance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        RefObject<Boolean> tempRefObject = new RefObject<Boolean>(flagsChanged);
        _vdsManager.refreshCapabilities(tempRefObject, _vds);
        flagsChanged = tempRefObject.argvalue;
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintanance || _vds.getstatus() == VDSStatus.Error) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase(_vds.getId());
    logable.AddCustomValue("VdsStatus", EnumUtils.ConvertToStringWithSpaces(_vds.getstatus().toString()));
    auditLog(logable, AuditLogType.VDS_DETECTED);
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintanance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintanance || _vds.getstatus() == VDSStatus.Error) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase(_vds.getId());
    logable.AddCustomValue("VdsStatus", EnumUtils.ConvertToStringWithSpaces(_vds.getstatus().toString()));
    auditLog(logable, AuditLogType.VDS_DETECTED);
}
#end_block

#method_before
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdate.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void updateVmDevices(List<String> vmsToUpdate) {
    XmlRpcStruct[] vms = getVmInfo(vmsToUpdate);
    updateVmDevices(vms);
}
#method_after
protected void updateVmDevices(List<String> vmsToUpdate) {
    XmlRpcStruct[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (XmlRpcStruct vm : vms) {
            processVmDevices(vm);
        }
    }
}
#end_block

#method_before
private XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<FullListVDSCommandParameters>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#method_after
protected XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
    return (XmlRpcStruct[]) (new FullListVdsCommand<FullListVDSCommandParameters>(new FullListVDSCommandParameters(_vds.getId(), vmsToUpdate)).ExecuteWithReturnValue());
}
#end_block

#method_before
private void UpdateCanSpecify() {
    Network network = (Network) getNetwork().getSelectedItem();
    boolean isChangable = getIsStaticAddress() && network != null && !network.getId().equals(NGuid.Empty);
    getAddress().setIsChangable(isChangable);
    getSubnet().setIsChangable(isChangable);
}
#method_after
private void UpdateCanSpecify() {
    Network network = (Network) getNetwork().getSelectedItem();
    boolean isChangable = getIsStaticAddress();
    getAddress().setIsChangable(isChangable);
    getSubnet().setIsChangable(isChangable);
}
#end_block

#method_before
public boolean Validate() {
    getNetwork().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    Network net = (Network) getNetwork().getSelectedItem();
    if (getIsStaticAddress() && getNetwork().getSelectedItem() != null && !net.getId().equals(NGuid.Empty)) {
        getAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
    }
    return getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid();
}
#method_after
public boolean Validate() {
    getNetwork().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    Network net = (Network) getNetwork().getSelectedItem();
    if (getIsStaticAddress()) {
        getAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
    }
    return getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid();
}
#end_block

#method_before
public void Edit() {
    Network network = (Network) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    DataCenterNetworkModel networkModel = new DataCenterNetworkModel();
    setWindow(networkModel);
    networkModel.setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    // $NON-NLS-1$
    networkModel.setHashName("edit_logical_network");
    networkModel.getName().setEntity(network.getname());
    networkModel.getDescription().setEntity(network.getdescription());
    networkModel.getIsStpEnabled().setEntity(network.getstp());
    networkModel.getHasVLanTag().setEntity(network.getvlan_id() != null);
    networkModel.getVLanTag().setEntity((network.getvlan_id() == null ? 0 : network.getvlan_id()));
    networkModel.getHasMtu().setEntity(network.getMtu() != 0);
    networkModel.getMtu().setEntity(network.getMtu() != 0 ? String.valueOf(network.getMtu()) : null);
    networkModel.getIsVmNetwork().setEntity(network.isVmNetwork());
    // $NON-NLS-1$
    networkModel.setDetachAllCommand(new UICommand("DetachClusters", this));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            DataCenterNetworkListModel dcNetworkModel = (DataCenterNetworkListModel) model;
            dcNetworkModel.setClusterList((ArrayList<VDSGroup>) ReturnValue);
            dcNetworkModel.setSelectionNodeList(new ArrayList<SelectionTreeNodeModel>());
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            for (VDSGroup vdsGroup : dcNetworkModel.getClusterList()) {
                queryTypeList.add(VdcQueryType.GetAllNetworksByClusterId);
                parametersList.add(new VdsGroupQueryParamenters(vdsGroup.getId()));
                SelectionTreeNodeModel tempVar = new SelectionTreeNodeModel();
                tempVar.setIsSelectedNullable(false);
                tempVar.setEntity(vdsGroup);
                tempVar.setDescription(vdsGroup.getname());
                dcNetworkModel.getSelectionNodeList().add(tempVar);
            }
            Frontend.RunMultipleQueries(queryTypeList, parametersList, dcNetworkModel);
            DataCenterNetworkModel networkModel1 = (DataCenterNetworkModel) dcNetworkModel.getWindow();
            // cannot detach engine networks from clusters
            Network network1 = (Network) dcNetworkModel.getSelectedItem();
            if (StringHelper.stringsEqual(network1.getname(), ENGINE_NETWORK)) {
                for (SelectionTreeNodeModel nodeModel : dcNetworkModel.getSelectionNodeList()) {
                    nodeModel.setIsChangable(false);
                }
                networkModel1.getDetachAllCommand().setIsAvailable(false);
                networkModel1.getName().setIsChangable(false);
                networkModel1.setMessage(ConstantsManager.getInstance().getConstants().cannotDetachManagementNetworkFromClustersMsg());
            }
        }
    };
    AsyncDataProvider.GetClusterList(_asyncQuery, getEntity().getId());
}
#method_after
public void Edit() {
    Network network = (Network) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    DataCenterNetworkModel networkModel = new DataCenterNetworkModel();
    // $NON-NLS-1$
    networkModel.setApplyCommand(new UICommand("Apply", this));
    setWindow(networkModel);
    networkModel.setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    // $NON-NLS-1$
    networkModel.setHashName("edit_logical_network");
    networkModel.getName().setEntity(network.getname());
    networkModel.getDescription().setEntity(network.getdescription());
    networkModel.getIsStpEnabled().setEntity(network.getstp());
    networkModel.getHasVLanTag().setEntity(network.getvlan_id() != null);
    networkModel.getVLanTag().setEntity((network.getvlan_id() == null ? 0 : network.getvlan_id()));
    networkModel.getHasMtu().setEntity(network.getMtu() != 0);
    networkModel.getMtu().setEntity(network.getMtu() != 0 ? String.valueOf(network.getMtu()) : null);
    networkModel.getIsVmNetwork().setEntity(network.isVmNetwork());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            DataCenterNetworkListModel dcNetworkModel = (DataCenterNetworkListModel) model;
            dcNetworkModel.setClusterList((ArrayList<VDSGroup>) ReturnValue);
            dcNetworkModel.setNetworkClusterList(new ListModel());
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            List<NetworkClusterModel> items = new ArrayList<NetworkClusterModel>();
            for (VDSGroup vdsGroup : dcNetworkModel.getClusterList()) {
                queryTypeList.add(VdcQueryType.GetAllNetworksByClusterId);
                parametersList.add(new VdsGroupQueryParamenters(vdsGroup.getId()));
                NetworkClusterModel tempVar = new NetworkClusterModel(vdsGroup);
                tempVar.setAttached(false);
                items.add(tempVar);
            }
            dcNetworkModel.getNetworkClusterList().setItems(items);
            Frontend.RunMultipleQueries(queryTypeList, parametersList, dcNetworkModel);
            DataCenterNetworkModel networkModel1 = (DataCenterNetworkModel) dcNetworkModel.getWindow();
            // cannot detach engine networks from clusters
            Network network1 = (Network) dcNetworkModel.getSelectedItem();
            if (StringHelper.stringsEqual(network1.getname(), ENGINE_NETWORK)) {
                for (Object item : dcNetworkModel.getNetworkClusterList().getItems()) {
                    ((NetworkClusterModel) item).setIsChangable(false);
                }
                networkModel1.getApplyCommand().setIsExecutionAllowed(false);
                networkModel1.getName().setIsChangable(false);
                networkModel1.setMessage(ConstantsManager.getInstance().getConstants().cannotDetachManagementNetworkFromClustersMsg());
            }
        }
    };
    AsyncDataProvider.GetClusterList(_asyncQuery, getEntity().getId());
}
#end_block

#method_before
public void New() {
    if (getWindow() != null) {
        return;
    }
    DataCenterNetworkModel networkModel = new DataCenterNetworkModel();
    setWindow(networkModel);
    networkModel.setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    // $NON-NLS-1$
    networkModel.setHashName("new_logical_network");
    networkModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            DataCenterNetworkListModel networkListModel = (DataCenterNetworkListModel) model;
            DataCenterNetworkModel networkModel1 = (DataCenterNetworkModel) networkListModel.getWindow();
            // networkModel1.ClusterTreeNodes
            ArrayList<VDSGroup> clusterList = (ArrayList<VDSGroup>) ReturnValue;
            SelectionTreeNodeModel nodeModel;
            ArrayList<SelectionTreeNodeModel> clusterTreeNodes = new ArrayList<SelectionTreeNodeModel>();
            for (VDSGroup selectionTreeNodeModel : clusterList) {
                nodeModel = new SelectionTreeNodeModel();
                nodeModel.setEntity(selectionTreeNodeModel);
                nodeModel.setDescription(selectionTreeNodeModel.getname());
                nodeModel.setIsSelectedNullable(false);
                clusterTreeNodes.add(nodeModel);
            }
            networkModel1.setClusterTreeNodes(clusterTreeNodes);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", networkListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            networkModel1.getCommands().add(tempVar);
            // $NON-NLS-1$
            networkModel1.setDetachAllCommand(new UICommand("DetachClusters", networkListModel));
            networkModel1.getDetachAllAvailable().setEntity(false);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", networkListModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            networkModel1.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.GetClusterList(_asyncQuery, getEntity().getId());
}
#method_after
public void New() {
    if (getWindow() != null) {
        return;
    }
    DataCenterNetworkModel networkModel = new DataCenterNetworkModel();
    // $NON-NLS-1$
    networkModel.setApplyCommand(new UICommand("Apply", this));
    setWindow(networkModel);
    networkModel.setTitle(ConstantsManager.getInstance().getConstants().newLogicalNetworkTitle());
    // $NON-NLS-1$
    networkModel.setHashName("new_logical_network");
    networkModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            DataCenterNetworkListModel networkListModel = (DataCenterNetworkListModel) model;
            DataCenterNetworkModel networkModel1 = (DataCenterNetworkModel) networkListModel.getWindow();
            // networkModel1.ClusterTreeNodes
            ArrayList<VDSGroup> clusterList = (ArrayList<VDSGroup>) ReturnValue;
            NetworkClusterModel networkClusterModel;
            ListModel networkClusterList = new ListModel();
            List<NetworkClusterModel> items = new ArrayList<NetworkClusterModel>();
            for (VDSGroup cluster : clusterList) {
                networkClusterModel = new NetworkClusterModel(cluster);
                networkClusterModel.setAttached(false);
                items.add(networkClusterModel);
            }
            networkClusterList.setItems(items);
            networkModel1.setNetworkClusterList(networkClusterList);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", networkListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            networkModel1.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", networkListModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            networkModel1.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.GetClusterList(_asyncQuery, getEntity().getId());
}
#end_block

#method_before
public void OnSave() {
    DataCenterNetworkModel model = (DataCenterNetworkModel) getWindow();
    if (getEntity() == null || (!model.getIsNew() && getSelectedItem() == null)) {
        Cancel();
        return;
    }
    model.setcurrentNetwork(model.getIsNew() ? new Network(null) : (Network) Cloner.clone(getSelectedItem()));
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    model.getcurrentNetwork().setstorage_pool_id(getEntity().getId());
    model.getcurrentNetwork().setname((String) model.getName().getEntity());
    model.getcurrentNetwork().setstp((Boolean) model.getIsStpEnabled().getEntity());
    model.getcurrentNetwork().setdescription((String) model.getDescription().getEntity());
    model.getcurrentNetwork().setVmNetwork((Boolean) model.getIsVmNetwork().getEntity());
    model.getcurrentNetwork().setMtu(0);
    if (model.getMtu().getEntity() != null) {
        model.getcurrentNetwork().setMtu(Integer.parseInt(model.getMtu().getEntity().toString()));
    }
    model.getcurrentNetwork().setvlan_id(null);
    if ((Boolean) model.getHasVLanTag().getEntity()) {
        model.getcurrentNetwork().setvlan_id(Integer.parseInt(model.getVLanTag().getEntity().toString()));
    }
    model.setnewClusters(new ArrayList<VDSGroup>());
    for (SelectionTreeNodeModel selectionTreeNodeModel : model.getClusterTreeNodes()) {
        if (selectionTreeNodeModel.getIsSelectedNullable() != null && selectionTreeNodeModel.getIsSelectedNullable().equals(true)) {
            model.getnewClusters().add((VDSGroup) selectionTreeNodeModel.getEntity());
        }
    }
    ArrayList<VDSGroup> detachNetworkFromClusters = Linq.Except(model.getOriginalClusters(), model.getnewClusters());
    ArrayList<VdcActionParametersBase> actionParameters = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup detachNetworkFromCluster : detachNetworkFromClusters) {
        actionParameters.add(new AttachNetworkToVdsGroupParameter(detachNetworkFromCluster, model.getcurrentNetwork()));
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.DetachNetworkToVdsGroup, actionParameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            DataCenterNetworkListModel networkListModel = (DataCenterNetworkListModel) result.getState();
            DataCenterNetworkModel networkModel = (DataCenterNetworkModel) networkListModel.getWindow();
            Network network = networkModel.getcurrentNetwork();
            if (networkModel.getIsNew()) {
                Frontend.RunAction(VdcActionType.AddNetwork, new AddNetworkStoragePoolParameters(getEntity().getId(), network), new IFrontendActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendActionAsyncResult result1) {
                        DataCenterNetworkListModel networkListModel1 = (DataCenterNetworkListModel) result1.getState();
                        VdcReturnValueBase retVal = result1.getReturnValue();
                        boolean succeeded = false;
                        if (retVal != null && retVal.getSucceeded()) {
                            succeeded = true;
                        }
                        networkListModel1.PostNetworkAction(succeeded ? (Guid) retVal.getActionReturnValue() : null, succeeded);
                    }
                }, networkListModel);
            } else {
                if ((Boolean) networkModel.getIsEnabled().getEntity()) {
                    Frontend.RunAction(VdcActionType.UpdateNetwork, new AddNetworkStoragePoolParameters(getEntity().getId(), network), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult result1) {
                            DataCenterNetworkListModel networkListModel1 = (DataCenterNetworkListModel) result1.getState();
                            VdcReturnValueBase retVal = result1.getReturnValue();
                            networkListModel1.PostNetworkAction(null, retVal != null && retVal.getSucceeded());
                        }
                    }, networkListModel);
                } else {
                    PostNetworkAction(null, true);
                }
            }
        }
    }, this);
}
#method_after
public void OnSave() {
    DataCenterNetworkModel model = (DataCenterNetworkModel) getWindow();
    if (getEntity() == null || (!model.getIsNew() && getSelectedItem() == null)) {
        Cancel();
        return;
    }
    model.setcurrentNetwork(model.getIsNew() ? new Network(null) : (Network) Cloner.clone(getSelectedItem()));
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    model.getcurrentNetwork().setstorage_pool_id(getEntity().getId());
    model.getcurrentNetwork().setname((String) model.getName().getEntity());
    model.getcurrentNetwork().setstp((Boolean) model.getIsStpEnabled().getEntity());
    model.getcurrentNetwork().setdescription((String) model.getDescription().getEntity());
    model.getcurrentNetwork().setVmNetwork((Boolean) model.getIsVmNetwork().getEntity());
    model.getcurrentNetwork().setMtu(0);
    if (model.getMtu().getEntity() != null) {
        model.getcurrentNetwork().setMtu(Integer.parseInt(model.getMtu().getEntity().toString()));
    }
    model.getcurrentNetwork().setvlan_id(null);
    if ((Boolean) model.getHasVLanTag().getEntity()) {
        model.getcurrentNetwork().setvlan_id(Integer.parseInt(model.getVLanTag().getEntity().toString()));
    }
    model.setnewClusters(new ArrayList<VDSGroup>());
    for (Object item : model.getNetworkClusterList().getItems()) {
        NetworkClusterModel networkClusterModel = (NetworkClusterModel) item;
        if (networkClusterModel.isAttached()) {
            model.getnewClusters().add(networkClusterModel.getEntity());
        }
    }
    ArrayList<VDSGroup> detachNetworkFromClusters = Linq.Except(model.getOriginalClusters(), model.getnewClusters());
    ArrayList<VdcActionParametersBase> actionParameters = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup detachNetworkFromCluster : detachNetworkFromClusters) {
        actionParameters.add(new AttachNetworkToVdsGroupParameter(detachNetworkFromCluster, model.getcurrentNetwork()));
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.DetachNetworkToVdsGroup, actionParameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            DataCenterNetworkListModel networkListModel = (DataCenterNetworkListModel) result.getState();
            DataCenterNetworkModel networkModel = (DataCenterNetworkModel) networkListModel.getWindow();
            Network network = networkModel.getcurrentNetwork();
            if (networkModel.getIsNew()) {
                Frontend.RunAction(VdcActionType.AddNetwork, new AddNetworkStoragePoolParameters(getEntity().getId(), network), new IFrontendActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendActionAsyncResult result1) {
                        DataCenterNetworkListModel networkListModel1 = (DataCenterNetworkListModel) result1.getState();
                        VdcReturnValueBase retVal = result1.getReturnValue();
                        boolean succeeded = false;
                        if (retVal != null && retVal.getSucceeded()) {
                            succeeded = true;
                        }
                        networkListModel1.PostNetworkAction(succeeded ? (Guid) retVal.getActionReturnValue() : null, succeeded);
                    }
                }, networkListModel);
            } else {
                if ((Boolean) networkModel.getIsEnabled().getEntity()) {
                    Frontend.RunAction(VdcActionType.UpdateNetwork, new AddNetworkStoragePoolParameters(getEntity().getId(), network), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult result1) {
                            DataCenterNetworkListModel networkListModel1 = (DataCenterNetworkListModel) result1.getState();
                            VdcReturnValueBase retVal = result1.getReturnValue();
                            networkListModel1.PostNetworkAction(null, retVal != null && retVal.getSucceeded());
                        }
                    }, networkListModel);
                } else {
                    PostNetworkAction(null, true);
                }
            }
        }
    }, this);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "DetachClusters")) {
        DetachClusters();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnDetachClusters")) {
        OnDetachClusters();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Apply")) {
        Apply();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnApply")) {
        OnApply();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    }
}
#end_block

#method_before
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    Network network = (Network) getSelectedItem();
    List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
    DataCenterNetworkModel model = (DataCenterNetworkModel) getWindow();
    ArrayList<Network> clusterNetworkList = null;
    boolean networkHasAttachedClusters = false;
    for (int i = 0; i < returnValueList.size(); i++) {
        VdcQueryReturnValue returnValue = returnValueList.get(i);
        if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
            clusterNetworkList = (ArrayList<Network>) returnValue.getReturnValue();
            for (Network clusterNetwork : clusterNetworkList) {
                if (clusterNetwork.getId().equals(network.getId())) {
                    model.getOriginalClusters().add((VDSGroup) getSelectionNodeList().get(i).getEntity());
                    getSelectionNodeList().get(i).setIsSelectedNullable(true);
                    networkHasAttachedClusters = true;
                    break;
                }
            }
        }
    }
    if (networkHasAttachedClusters) {
        model.getIsEnabled().setEntity(false);
        if (!StringHelper.stringsEqual(network.getname(), ENGINE_NETWORK)) {
            model.getDetachAllAvailable().setEntity(!(Boolean) model.getIsEnabled().getEntity());
        }
    }
    model.setClusterTreeNodes(getSelectionNodeList());
    if (StringHelper.stringsEqual(network.getname(), ENGINE_NETWORK) && getSelectionNodeList().size() > 0) {
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("Cancel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
        tempVar.setIsDefault(true);
        tempVar.setIsCancel(true);
        model.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnSave", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#method_after
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    Network network = (Network) getSelectedItem();
    List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
    DataCenterNetworkModel model = (DataCenterNetworkModel) getWindow();
    List<Network> clusterNetworkList = null;
    List<NetworkClusterModel> networkClusterList = (List<NetworkClusterModel>) getNetworkClusterList().getItems();
    boolean networkHasAttachedClusters = false;
    for (int i = 0; i < returnValueList.size(); i++) {
        VdcQueryReturnValue returnValue = returnValueList.get(i);
        if (returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
            clusterNetworkList = (List<Network>) returnValue.getReturnValue();
            for (Network clusterNetwork : clusterNetworkList) {
                if (clusterNetwork.getId().equals(network.getId())) {
                    model.getOriginalClusters().add(networkClusterList.get(i).getEntity());
                    networkClusterList.get(i).setAttached(true);
                    networkHasAttachedClusters = true;
                    break;
                }
            }
        }
    }
    if (networkHasAttachedClusters) {
        model.getIsEnabled().setEntity(false);
    }
    model.setNetworkClusterList(getNetworkClusterList());
    if (StringHelper.stringsEqual(network.getname(), ENGINE_NETWORK) && networkClusterList.size() > 0) {
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("Cancel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
        tempVar.setIsDefault(true);
        tempVar.setIsCancel(true);
        model.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnSave", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#end_block

#method_before
public void OnEditManagementNetworkConfirmation(boolean isBond) {
    if (!isBond) {
        HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
        if (!model.Validate()) {
            return;
        }
        if ((Boolean) model.getCheckConnectivity().getEntity() == true) {
            OnEditManagementNetwork();
            return;
        }
    } else {
        HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
        if (!model.Validate()) {
            return;
        }
        if ((Boolean) model.getCheckConnectivity().getEntity() == true) {
            OnBond();
            return;
        }
    }
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().confirmTitle());
    confirmModel.getLatch().setEntity(true);
    if (!isBond) {
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnEditManagementNetwork", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnBond", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        confirmModel.getCommands().add(tempVar2);
    }
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("CancelConfirm", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    confirmModel.getCommands().add(tempVar3);
}
#method_after
public void OnEditManagementNetworkConfirmation(boolean isBond) {
    if (!isBond) {
        HostManagementNetworkModel model = (HostManagementNetworkModel) getWindow();
        if (!model.Validate()) {
            return;
        }
        if ((Boolean) model.getCheckConnectivity().getEntity() == true) {
            OnEditManagementNetwork();
            return;
        }
    } else {
        HostBondInterfaceModel model = (HostBondInterfaceModel) getWindow();
        if (!model.Validate()) {
            return;
        }
        if ((Boolean) model.getCheckConnectivity().getEntity() == true) {
            OnBond();
            return;
        }
    }
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().confirmTitle());
    confirmModel.getLatch().setEntity(true);
    confirmModel.getLatch().setIsAvailable(true);
    confirmModel.getLatch().setIsChangable(true);
    if (!isBond) {
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnEditManagementNetwork", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
    } else {
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnBond", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        confirmModel.getCommands().add(tempVar2);
    }
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("CancelConfirm", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    confirmModel.getCommands().add(tempVar3);
}
#end_block

#method_before
public void OnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) getWindow();
    boolean checkConnectivity = true;
    int conectivityTimeout = 60000;
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity(checkConnectivity);
    params.setConectivityTimeout(conectivityTimeout);
    params.setVdsId(getEntity().getId());
    IFrontendActionAsyncCallback callback = new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            model.StopProgress();
            VdcReturnValueBase returnValue = result.getReturnValue();
            if (returnValue != null && returnValue.getSucceeded()) {
                Cancel();
                Search();
            }
        }
    };
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.SetupNetworks, params, callback);
}
#method_after
public void OnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) getWindow();
    int conectivityTimeout = 60000;
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity((Boolean) model.getCheckConnectivity().getEntity());
    params.setConectivityTimeout(conectivityTimeout);
    params.setVdsId(getEntity().getId());
    IFrontendActionAsyncCallback callback = new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel commitChanges = model.getCommitChanges();
                if ((Boolean) commitChanges.getEntity()) {
                    SaveNetworkConfig(getEntity().getId(), HostInterfaceListModel.this);
                } else {
                    model.StopProgress();
                    Cancel();
                    Search();
                }
            } else {
                model.StopProgress();
            }
        }
    };
    setcurrentModel(model);
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.SetupNetworks, params, callback);
}
#end_block

#method_before
private void UpdateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = (VdsNetworkInterface) getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !IsAnyBond(selectedItems) && Linq.FindAllInterfaceNetworkNameNotEmpty(Linq.VdsNetworkInterfaceListToBase(selectedItems)).size() <= 1 && Linq.FindAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.FindAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getnet_config_dirty() == null ? false : host.getnet_config_dirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // Setup Networks is only available on 3.1 Clusters, all the other commands (except save network configuration) available only on less than 3.1 Clusters
    if (host != null) {
        Version v31 = new Version(3, 1);
        boolean isLessThan31 = host.getvds_group_compatibility_version().compareTo(v31) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(true);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
    }
}
#method_after
private void UpdateActionAvailability() {
    VDS host = getEntity();
    VdsNetworkInterface selectedItem = (VdsNetworkInterface) getSelectedItem();
    ArrayList<VdsNetworkInterface> selectedItems = getSelectedItems();
    getEditCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItem != null && selectedItems.size() == 1 && StringHelper.isNullOrEmpty(selectedItem.getBondName()) && !selectedItem.getIsManagement());
    getBondCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() >= 2 && !IsAnyBond(selectedItems) && Linq.FindAllInterfaceNetworkNameNotEmpty(Linq.VdsNetworkInterfaceListToBase(selectedItems)).size() <= 1 && Linq.FindAllInterfaceBondNameIsEmpty(selectedItems).size() == selectedItems.size() && Linq.FindAllInterfaceVlanIdIsEmpty(selectedItems).size() == selectedItems.size());
    // to bond, selected lines must not have more that 1 networks (vlan or not)
    if (getItems() != null) {
        ArrayList<HostInterfaceLineModel> itemList = (ArrayList<HostInterfaceLineModel>) getItems();
        // total network count cannot be more than 1
        int totalNetworkCount = 0;
        for (HostInterfaceLineModel lineModel : itemList) {
            if (lineModel.getIsSelected()) {
                int lineNetworkCount = lineModel.getVlanSize() + (lineModel.getNetworkName() != null ? 1 : 0);
                if (lineNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
                totalNetworkCount += lineNetworkCount;
                if (totalNetworkCount > 1) {
                    // bailout
                    getBondCommand().setIsExecutionAllowed(false);
                    break;
                }
            }
        }
    }
    getDetachCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && !StringHelper.isNullOrEmpty(selectedItem.getNetworkName()) && !selectedItem.getIsManagement());
    getSaveNetworkConfigCommand().setIsExecutionAllowed(host != null && (host.getnet_config_dirty() == null ? false : host.getnet_config_dirty()));
    getEditManagementNetworkCommand().setIsExecutionAllowed(host != null && host.getstatus() != VDSStatus.NonResponsive && selectedItems.size() == 1 && selectedItem != null && selectedItem.getIsManagement());
    // Setup Networks is only available on 3.1 Clusters, all the other commands (except save network configuration) available only on less than 3.1 Clusters
    if (host != null) {
        Version v31 = new Version(3, 1);
        boolean isLessThan31 = host.getvds_group_compatibility_version().compareTo(v31) < 0;
        getSetupNetworksCommand().setIsAvailable(!isLessThan31);
        getSaveNetworkConfigCommand().setIsAvailable(isLessThan31);
        getEditCommand().setIsAvailable(isLessThan31);
        getBondCommand().setIsAvailable(isLessThan31);
        getDetachCommand().setIsAvailable(isLessThan31);
        getEditManagementNetworkCommand().setIsAvailable(isLessThan31);
    }
}
#end_block

#method_before
public List<VdsNetworkInterface> getRemovedBonds() {
    return removedBonds;
}
#method_after
public Set<String> getRemovedBonds() {
    return removedBonds;
}
#end_block

#method_before
public void setRemovedBonds(List<VdsNetworkInterface> removedBonds) {
    this.removedBonds = removedBonds;
}
#method_after
public void setRemovedBonds(Set<String> removedBonds) {
    this.removedBonds = removedBonds;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String address = getParameters().getAddress();
    String subnet = StringHelper.isNullOrEmpty(getParameters().getSubnet()) ? getParameters().getNetwork().getsubnet() : getParameters().getSubnet();
    String gateway = StringHelper.isNullOrEmpty(getParameters().getGateway()) ? getParameters().getNetwork().getgateway() : getParameters().getGateway();
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(getParameters().getVdsId(), getParameters().getNetwork().getname(), getParameters().getNetwork().getvlan_id(), getParameters().getBondName(), getParameters().getNics(), address, subnet, gateway, getParameters().getNetwork().getstp(), getParameters().getBondingOptions(), getParameters().getBootProtocol());
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new VdsIdAndVdsVDSCommandParametersBase(getParameters().getVdsId()));
        if (retVal.getSucceeded()) {
            // set network status (this can change the network status to
            // operational)
            VdsStatic vdsStatic = DbFacade.getInstance().getVdsStaticDAO().get(getParameters().getVdsId());
            AttachNetworkToVdsGroupCommand.SetNetworkStatus(vdsStatic.getvds_group_id(), getParameters().getNetwork());
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    T params = getParameters();
    String address = params.getAddress();
    String subnet = StringUtils.isEmpty(params.getSubnet()) ? params.getNetwork().getsubnet() : params.getSubnet();
    String gateway = StringUtils.isEmpty(params.getGateway()) ? params.getNetwork().getgateway() : params.getGateway();
    NetworkVdsmVDSCommandParameters vdsParams = new NetworkVdsmVDSCommandParameters(params.getVdsId(), params.getNetwork(), params.getBondName(), params.getNics(), address, subnet, gateway, params.getBondingOptions(), params.getBootProtocol());
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddNetwork, vdsParams);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new VdsIdAndVdsVDSCommandParametersBase(params.getVdsId()));
        if (retVal.getSucceeded()) {
            // set network status (this can change the network status to
            // operational)
            VdsStatic vdsStatic = DbFacade.getInstance().getVdsStaticDAO().get(params.getVdsId());
            AttachNetworkToVdsGroupCommand.SetNetworkStatus(vdsStatic.getvds_group_id(), params.getNetwork());
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // check minimum 2 nics in bond
    if (getParameters().getNics().length < 2) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_PARAMETERS_INVALID);
        return false;
    }
    if (getParameters().getNetwork() == null) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_NOT_EXISTS);
        return false;
    }
    List<VdsNetworkInterface> interfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(getParameters().getVdsId());
    // check that bond exists
    VdsNetworkInterface bond = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface anInterface) {
            return anInterface.getName().equals(getParameters().getBondName());
        }
    });
    if (bond == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NAME_EXISTS);
        return false;
    }
    // check that each nic is valid
    for (final String nic : getParameters().getNics()) {
        VdsNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

            @Override
            public boolean eval(VdsNetworkInterface i) {
                return i.getName().equals(nic);
            }
        });
        if (iface == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NAME_EXISTS);
            return false;
        } else if (!StringHelper.isNullOrEmpty(iface.getBondName())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE);
            return false;
        } else if (!StringHelper.isNullOrEmpty(iface.getNetworkName())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE);
            return false;
        } else if (NetworkUtils.interfaceHasVlan(iface, interfaces)) {
            // check that one of the nics is not connected to vlan
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VLAN);
            return false;
        }
    }
    // check that the network not in use
    VdsNetworkInterface I = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface i) {
            if (i.getNetworkName() != null) {
                return i.getNetworkName().equals(getParameters().getNetwork().getname());
            }
            return false;
        }
    });
    if (I != null) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_ALREADY_ATTACHED_TO_INTERFACE);
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVds().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getNetwork().getname());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_NOT_EXISTS_IN_CLUSTER);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // check minimum 2 nics in bond
    if (getParameters().getNics().length < 2) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_PARAMETERS_INVALID);
        return false;
    }
    if (getParameters().getNetwork() == null) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_NOT_EXISTS);
        return false;
    }
    List<VdsNetworkInterface> interfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(getParameters().getVdsId());
    // check that bond exists
    VdsNetworkInterface bond = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface anInterface) {
            return anInterface.getName().equals(getParameters().getBondName());
        }
    });
    if (bond == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NAME_EXISTS);
        return false;
    }
    // check that each nic is valid
    for (final String nic : getParameters().getNics()) {
        VdsNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

            @Override
            public boolean eval(VdsNetworkInterface i) {
                return i.getName().equals(nic);
            }
        });
        if (iface == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_BOND_NAME_EXISTS);
            return false;
        } else if (StringUtils.isNotEmpty(iface.getBondName())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE);
            return false;
        } else if (StringUtils.isNotEmpty(iface.getNetworkName())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE);
            return false;
        } else if (NetworkUtils.interfaceHasVlan(iface, interfaces)) {
            // check that one of the nics is not connected to vlan
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VLAN);
            return false;
        }
    }
    // check that the network not in use
    VdsNetworkInterface I = LinqUtils.firstOrNull(interfaces, new Predicate<VdsNetworkInterface>() {

        @Override
        public boolean eval(VdsNetworkInterface i) {
            if (i.getNetworkName() != null) {
                return i.getNetworkName().equals(getParameters().getNetwork().getname());
            }
            return false;
        }
    });
    if (I != null) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_ALREADY_ATTACHED_TO_INTERFACE);
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVds().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getNetwork().getname());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWROK_NOT_EXISTS_IN_CLUSTER);
        return false;
    }
    return true;
}
#end_block

#method_before
private List<VdsNetworkInterface> getRemovedBonds() {
    return helper.getRemovedBonds();
}
#method_after
private Set<String> getRemovedBonds() {
    return helper.getRemovedBonds();
}
#end_block

#method_before
private void pollVds() {
    FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.Poll, new VdsIdVDSCommandParametersBase(getVds().getId()));
    try {
        log.debugFormat("polling host {0}", getVdsName());
        task.get(Config.<Integer>GetValue(ConfigValues.SetupNetworksPollingTimeout), TimeUnit.SECONDS);
    } catch (Exception e) {
    // ignore failure. network can go down due to VDSM changing the network
    }
}
#method_after
private void pollVds() {
    long timeBeforePoll = System.currentTimeMillis();
    FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.Poll, new VdsIdVDSCommandParametersBase(getVds().getId()));
    try {
        task.get(Config.<Integer>GetValue(ConfigValues.SetupNetworksPollingTimeout), TimeUnit.SECONDS);
        if (System.currentTimeMillis() - timeBeforePoll < POLLING_BREAK) {
            Thread.sleep(POLLING_BREAK);
        }
    } catch (Exception e) {
    // ignore failure. network can go down due to VDSM changing the network
    }
}
#end_block

#method_before
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status = null;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            if (connectLunDisks(getVdsId())) {
                status = CreateVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status = null;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            if (connectLunDisks(getVdsId())) {
                status = CreateVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            freeLock();
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_nics);
    if (nics != null) {
        for (String key : nics.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            Map<String, Object> nic = (Map<String, Object>) nics.get(key);
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setAddress((String) nic.get("addr"));
                iface.setSubnet((String) nic.get("netmask"));
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (nic.get("permhwaddr") != null) {
                    iface.setMacAddress((String) nic.get("permhwaddr"));
                }
                if (StringUtils.isNotBlank((String) nic.get(VdsProperties.mtu))) {
                    iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.mtu)));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new HashMap<String, Integer>();
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_vlans);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            Map<String, Object> vlan = (Map<String, Object>) vlans.get(key);
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.mtu))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.mtu)));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_bondings);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) bonds.get(key);
            ;
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                iface.setAddress((String) bond.get("addr"));
                iface.setSubnet((String) bond.get("netmask"));
                iface.setGateway((String) bond.get(VdsProperties.GLOBAL_GATEWAY));
                if (bond.get("slaves") != null) {
                    Object[] interfaces = (Object[]) bond.get("slaves");
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                if (StringUtils.isNotBlank((String) bond.get(VdsProperties.mtu))) {
                    iface.setMtu(Integer.parseInt((String) bond.get(VdsProperties.mtu)));
                }
                XmlRpcStruct config = (bond.get("cfg") instanceof Map) ? new XmlRpcStruct((Map<String, Object>) bond.get("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_networks);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            Map<String, Object> network = (Map<String, Object>) networks.get(key);
            if (network != null) {
                Network net = new Network();
                net.setname(key);
                net.setaddr((String) network.get("addr"));
                net.setsubnet((String) network.get("netmask"));
                net.setgateway((String) network.get(VdsProperties.GLOBAL_GATEWAY));
                if (StringUtils.isNotBlank((String) network.get(VdsProperties.mtu))) {
                    net.setMtu(Integer.parseInt((String) network.get(VdsProperties.mtu)));
                }
                // map interface to network
                if (network.get("interface") != null) {
                    updateNetwrokDetailsInInterface(vds, currVlans, networkVlans, network, net, network.get("interface").toString());
                } else {
                    Object[] ports = (Object[]) network.get("ports");
                    if (ports != null) {
                        for (Object port : ports) {
                            updateNetwrokDetailsInInterface(vds, currVlans, networkVlans, network, net, port.toString());
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
}
#method_after
public static void updateNetworkData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDAO().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    // Interfaces list
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_nics);
    if (nics != null) {
        for (String key : nics.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            // name value of nic property, i.e.: speed = 1000
            Map<String, Object> nic = (Map<String, Object>) nics.get(key);
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setAddress((String) nic.get("addr"));
                iface.setSubnet((String) nic.get("netmask"));
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                if (nic.get("permhwaddr") != null) {
                    iface.setMacAddress((String) nic.get("permhwaddr"));
                }
                if (StringUtils.isNotBlank((String) nic.get(VdsProperties.mtu))) {
                    iface.setMtu(Integer.parseInt((String) nic.get(VdsProperties.mtu)));
                }
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // interface to vlan map
    Map<String, Integer> currVlans = new HashMap<String, Integer>();
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_vlans);
    if (vlans != null) {
        for (String key : vlans.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            if (key.contains(".")) {
                String[] names = key.split("[.]", -1);
                String vlan = names[1];
                iface.setVlanId(Integer.parseInt(vlan));
                currVlans.put(key, iface.getVlanId());
            }
            Map<String, Object> vlan = (Map<String, Object>) vlans.get(key);
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.mtu))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.mtu)));
            }
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
    // bonds
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_bondings);
    if (bonds != null) {
        for (String key : bonds.keySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.NewGuid());
            iface.setId(iStats.getId());
            iface.setName(key);
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) bonds.get(key);
            ;
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                iface.setAddress((String) bond.get("addr"));
                iface.setSubnet((String) bond.get("netmask"));
                iface.setGateway((String) bond.get(VdsProperties.GLOBAL_GATEWAY));
                if (bond.get("slaves") != null) {
                    Object[] interfaces = (Object[]) bond.get("slaves");
                    iStats.setVdsId(vds.getId());
                    AddBond(vds, iface, interfaces);
                }
                if (StringUtils.isNotBlank((String) bond.get(VdsProperties.mtu))) {
                    iface.setMtu(Integer.parseInt((String) bond.get(VdsProperties.mtu)));
                }
                XmlRpcStruct config = (bond.get("cfg") instanceof Map) ? new XmlRpcStruct((Map<String, Object>) bond.get("cfg")) : null;
                if (config != null && config.getItem("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.getItem("BONDING_OPTS").toString());
                }
                AddBootProtocol(config, iface);
            }
        }
    }
    // network to vlan map
    Map<String, Integer> networkVlans = new HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.getItem(VdsProperties.network_networks);
    if (networks != null) {
        vds.getNetworks().clear();
        for (String key : networks.keySet()) {
            Map<String, Object> network = (Map<String, Object>) networks.get(key);
            if (network != null) {
                Network net = new Network();
                net.setname(key);
                net.setaddr((String) network.get("addr"));
                net.setsubnet((String) network.get("netmask"));
                net.setgateway((String) network.get(VdsProperties.GLOBAL_GATEWAY));
                if (StringUtils.isNotBlank((String) network.get(VdsProperties.mtu))) {
                    net.setMtu(Integer.parseInt((String) network.get(VdsProperties.mtu)));
                }
                // map interface to network
                if (network.get("interface") != null) {
                    updateNetwrokDetailsInInterface(vds, currVlans, networkVlans, network, net, network.get("interface").toString());
                } else {
                    Object[] ports = (Object[]) network.get("ports");
                    if (ports != null) {
                        for (Object port : ports) {
                            updateNetwrokDetailsInInterface(vds, currVlans, networkVlans, network, net, port.toString());
                        }
                    }
                }
                vds.getNetworks().add(net);
            }
        }
    }
    // Check vlans are line with Clusters vlans
    checkClusterVlans(vds, networkVlans);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setnet_config_dirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    // $NON-NLS-1$
    assert item instanceof NetworkInterfaceModel : "only nics can be edited";
    NetworkInterfaceModel nic = (NetworkInterfaceModel) item;
    // $NON-NLS-1$
    assert nic.getItems().size() > 0 : "must have at least one network to edit";
    final VdsNetworkInterface entity = nic.getEntity();
    Model editPopup;
    BaseCommandTarget okTarget;
    if (nic instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        BondNetworkInterfaceModel bondModel = (BondNetworkInterfaceModel) nic;
        editPopup = new HostBondInterfaceModel(true);
        final HostBondInterfaceModel bondDialogModel = (HostBondInterfaceModel) editPopup;
        bondDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editBondInterfaceTitle(entity.getName()));
        bondDialogModel.getBondingOptions().setIsAvailable(true);
        bondDialogModel.getBond().setIsAvailable(false);
        // this dialog has only one selected network, just put the first one
        bondDialogModel.getNetwork().setSelectedItem(nic.getItems().get(0).getEntity());
        bondDialogModel.setBootProtocol(entity.getBootProtocol());
        // bond options
        String bondOptions = entity.getBondOptions();
        List<KeyValuePairCompat<String, EntityModel>> items = (List<KeyValuePairCompat<String, EntityModel>>) bondDialogModel.getBondingOptions().getItems();
        boolean found = false;
        KeyValuePairCompat<String, EntityModel> customKey = null;
        for (KeyValuePairCompat<String, EntityModel> pair : items) {
            String key = pair.getKey();
            if (key.equals(bondOptions)) {
                bondDialogModel.getBondingOptions().setSelectedItem(pair);
                found = true;
                break;
            } else {
                if ("custom".equals(key)) {
                    // $NON-NLS-1$
                    customKey = pair;
                }
            }
        }
        if (!found) {
            EntityModel value = new EntityModel();
            value.setEntity(bondOptions);
            customKey.setValue(value);
            bondDialogModel.getBondingOptions().setSelectedItem(customKey);
        }
        // Addresses
        bondDialogModel.getAddress().setEntity(entity.getAddress());
        bondDialogModel.getSubnet().setEntity(entity.getSubnet());
        bondDialogModel.getGateway().setEntity(entity.getGateway());
        bondDialogModel.getNetwork().setIsAvailable(false);
        bondDialogModel.setNoneBootProtocolAvailable(!entity.getIsManagement());
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                if (!bondDialogModel.Validate()) {
                    return;
                }
                entity.setAddress((String) bondDialogModel.getAddress().getEntity());
                entity.setSubnet((String) bondDialogModel.getSubnet().getEntity());
                entity.setGateway((String) bondDialogModel.getGateway().getEntity());
                entity.setBootProtocol(bondDialogModel.getBootProtocol());
                setBondOptions(entity, bondDialogModel);
                hostInterfaceListModel.CancelConfirm();
            }
        };
    } else if (entity.getIsManagement()) {
        /**
         * **************
         *  Management Network Dialog
         * ***************
         */
        editPopup = new HostManagementNetworkModel(true);
        final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
        mgmntDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editManagementInterfaceTitle(entity.getName()));
        mgmntDialogModel.getAddress().setEntity(entity.getAddress());
        mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
        mgmntDialogModel.getGateway().setEntity(entity.getGateway());
        mgmntDialogModel.setNoneBootProtocolAvailable(false);
        mgmntDialogModel.getBondingOptions().setIsAvailable(false);
        mgmntDialogModel.getInterface().setIsAvailable(false);
        mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                if (!mgmntDialogModel.Validate()) {
                    return;
                }
                entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                hostInterfaceListModel.CancelConfirm();
            }
        };
    } else {
        /**
         * **************
         *  Nic Dialog
         * ***************
         */
        editPopup = new HostInterfaceModel(true);
        final HostInterfaceModel interfaceDialogModel = (HostInterfaceModel) editPopup;
        interfaceDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editInterfaceTitle(entity.getName()));
        interfaceDialogModel.getAddress().setEntity(entity.getAddress());
        interfaceDialogModel.getSubnet().setEntity(entity.getSubnet());
        interfaceDialogModel.getName().setIsAvailable(false);
        interfaceDialogModel.getNetwork().setIsAvailable(false);
        // this dialog has only one selected network, just put the first one
        interfaceDialogModel.getNetwork().setSelectedItem(nic.getItems().get(0).getEntity());
        interfaceDialogModel.setBootProtocol(entity.getBootProtocol());
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                if (!interfaceDialogModel.Validate()) {
                    return;
                }
                entity.setBootProtocol(interfaceDialogModel.getBootProtocol());
                entity.setAddress((String) interfaceDialogModel.getAddress().getEntity());
                entity.setSubnet((String) interfaceDialogModel.getSubnet().getEntity());
                hostInterfaceListModel.CancelConfirm();
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            hostInterfaceListModel.CancelConfirm();
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    editPopup.getCommands().add(okCommand);
    editPopup.getCommands().add(cancelCommand);
    hostInterfaceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new HostBondInterfaceModel(true);
        final HostBondInterfaceModel bondDialogModel = (HostBondInterfaceModel) editPopup;
        bondDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editBondInterfaceTitle(entity.getName()));
        bondDialogModel.getNetwork().setIsAvailable(false);
        bondDialogModel.getCheckConnectivity().setIsAvailable(false);
        bondDialogModel.getAddress().setIsAvailable(false);
        bondDialogModel.getSubnet().setIsAvailable(false);
        bondDialogModel.getGateway().setIsAvailable(false);
        bondDialogModel.setBootProtocolAvailable(false);
        // bond name
        bondDialogModel.getBond().setIsChangable(false);
        List<VdsNetworkInterface> bondName = Arrays.asList(entity);
        bondDialogModel.getBond().setItems(bondName);
        bondDialogModel.getBond().setSelectedItem(entity);
        // bond options
        String bondOptions = entity.getBondOptions();
        List<KeyValuePairCompat<String, EntityModel>> items = (List<KeyValuePairCompat<String, EntityModel>>) bondDialogModel.getBondingOptions().getItems();
        boolean found = false;
        KeyValuePairCompat<String, EntityModel> customKey = null;
        for (KeyValuePairCompat<String, EntityModel> pair : items) {
            String key = pair.getKey();
            if (key.equals(bondOptions)) {
                bondDialogModel.getBondingOptions().setSelectedItem(pair);
                found = true;
                break;
            } else {
                if ("custom".equals(key)) {
                    // $NON-NLS-1$
                    customKey = pair;
                }
            }
        }
        if (!found) {
            EntityModel value = new EntityModel();
            value.setEntity(bondOptions);
            customKey.setValue(value);
            bondDialogModel.getBondingOptions().setSelectedItem(customKey);
        }
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                setBondOptions(entity, bondDialogModel);
                hostInterfaceListModel.CancelConfirm();
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.getAttachedToNic().getEntity();
        if (logicalNetwork.isManagement()) {
            /**
             * **************
             *  Management Network Dialog
             * ***************
             */
            editPopup = new HostManagementNetworkModel(true);
            final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
            mgmntDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            mgmntDialogModel.setEntity(logicalNetwork.getEntity());
            mgmntDialogModel.getAddress().setEntity(entity.getAddress());
            mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
            mgmntDialogModel.getGateway().setEntity(entity.getGateway());
            mgmntDialogModel.setNoneBootProtocolAvailable(false);
            mgmntDialogModel.getBondingOptions().setIsAvailable(false);
            mgmntDialogModel.getInterface().setIsAvailable(false);
            mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!mgmntDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                    entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                    hostInterfaceListModel.CancelConfirm();
                }
            };
        } else {
            /**
             * **************
             *  Network Dialog
             * ***************
             */
            editPopup = new HostInterfaceModel(true);
            final HostInterfaceModel networkDialogModel = (HostInterfaceModel) editPopup;
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.getAddress().setEntity(entity.getAddress());
            networkDialogModel.getSubnet().setEntity(entity.getSubnet());
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getBondingOptions().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
            networkDialogModel.setBootProtocol(entity.getBootProtocol());
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void ExecuteCommand(UICommand command) {
                    if (!networkDialogModel.Validate()) {
                        return;
                    }
                    entity.setBootProtocol(networkDialogModel.getBootProtocol());
                    entity.setAddress((String) networkDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) networkDialogModel.getSubnet().getEntity());
                    hostInterfaceListModel.CancelConfirm();
                }
            };
        }
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            hostInterfaceListModel.CancelConfirm();
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    editPopup.getCommands().add(okCommand);
    editPopup.getCommands().add(cancelCommand);
    hostInterfaceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            hostInterfaceListModel.CancelConfirm();
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation == NetworkOperation.NULL_OPERATION) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH) {
        final HostBondInterfaceModel bondPopup = new HostBondInterfaceModel(true);
        bondPopup.setTitle(ConstantsManager.getInstance().getConstants().createNewBondTitle());
        bondPopup.getNetwork().setIsAvailable(false);
        bondPopup.getCheckConnectivity().setIsAvailable(false);
        bondPopup.setBootProtocol(NetworkBootProtocol.None);
        bondPopup.getAddress().setIsAvailable(false);
        bondPopup.getSubnet().setIsAvailable(false);
        bondPopup.getGateway().setIsAvailable(false);
        List<VdsNetworkInterface> freeBonds = getFreeBonds();
        if (freeBonds.isEmpty()) {
            popupWindow = new ConfirmationModel();
            popupWindow.setTitle(ConstantsManager.getInstance().getConstants().errorTitle());
            popupWindow.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoAvailableBondsMsg());
            popupWindow.getCommands().add(cancelCommand);
            hostInterfaceListModel.setConfirmWindow(popupWindow);
            return;
        }
        bondPopup.getBond().setItems(freeBonds);
        bondPopup.setBootProtocolAvailable(false);
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                hostInterfaceListModel.CancelConfirm();
                VdsNetworkInterface bond = (VdsNetworkInterface) bondPopup.getBond().getSelectedItem();
                setBondOptions(bond, bondPopup);
                networkCommand.Execute(bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.Execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    hostInterfaceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void ExecuteCommand(UICommand command) {
            hostInterfaceListModel.CancelConfirm();
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation == NetworkOperation.NULL_OPERATION) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH) {
        final HostBondInterfaceModel bondPopup = new HostBondInterfaceModel(true);
        bondPopup.setTitle(ConstantsManager.getInstance().getConstants().createNewBondTitle());
        bondPopup.getNetwork().setIsAvailable(false);
        bondPopup.getCheckConnectivity().setIsAvailable(false);
        bondPopup.setBootProtocol(NetworkBootProtocol.None);
        bondPopup.getAddress().setIsAvailable(false);
        bondPopup.getSubnet().setIsAvailable(false);
        bondPopup.getGateway().setIsAvailable(false);
        bondPopup.setBootProtocolAvailable(false);
        List<VdsNetworkInterface> freeBonds = getFreeBonds();
        if (freeBonds.isEmpty()) {
            popupWindow = new ConfirmationModel();
            popupWindow.setTitle(ConstantsManager.getInstance().getConstants().errorTitle());
            popupWindow.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoAvailableBondsMsg());
            popupWindow.getCommands().add(cancelCommand);
            hostInterfaceListModel.setConfirmWindow(popupWindow);
            return;
        }
        bondPopup.getBond().setItems(freeBonds);
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand command) {
                hostInterfaceListModel.CancelConfirm();
                VdsNetworkInterface bond = (VdsNetworkInterface) bondPopup.getBond().getSelectedItem();
                setBondOptions(bond, bondPopup);
                networkCommand.Execute(bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else {
        // just execute the command
        networkCommand.Execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    hostInterfaceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
@Before
public void setup() {
    initVds();
    mockEjbStrategy();
    initConditions();
    updater = new VdsUpdateRunTimeInfo(null, vds) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected MonitoringStrategy getMonitoringStrategyForVds(VDS param) {
            return mock(MonitoringStrategy.class);
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setlog_type(logType);
            mockAuditLogDao.save(al);
        }
    };
}
#method_after
@Before
public void setup() {
    initVds();
    mockEjbStrategy();
    initConditions();
    updater = new VdsUpdateRunTimeInfo(null, vds) {

        @Override
        public DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected MonitoringStrategy getMonitoringStrategyForVds(VDS param) {
            return mock(MonitoringStrategy.class);
        }

        @Override
        protected void auditLog(AuditLogableBase auditLogable, AuditLogType logType) {
            AuditLog al = new AuditLog();
            al.setlog_type(logType);
            mockAuditLogDao.save(al);
        }

        @Override
        protected XmlRpcStruct[] getVmInfo(List<String> vmsToUpdate) {
            return vmInfo;
        }
    };
}
#end_block

#method_before
private void initConditions() {
    when(dbFacade.getVdsGroupDAO()).thenReturn(groupDAO);
    when(dbFacade.getVmDAO()).thenReturn(vmDAO);
    when(dbFacade.getAuditLogDAO()).thenReturn(mockAuditLogDao);
    when(groupDAO.get((Guid) any())).thenReturn(cluster);
    Map<Guid, VM> emptyMap = Collections.emptyMap();
    when(vmDAO.getAllRunningByVds(vds.getId())).thenReturn(emptyMap);
}
#method_after
private void initConditions() {
    when(dbFacade.getVdsGroupDAO()).thenReturn(groupDAO);
    when(dbFacade.getVmDAO()).thenReturn(vmDAO);
    when(dbFacade.getAuditLogDAO()).thenReturn(mockAuditLogDao);
    when(dbFacade.getVmDeviceDAO()).thenReturn(vmDeviceDAO);
    when(groupDAO.get((Guid) any())).thenReturn(cluster);
    Map<Guid, VM> emptyMap = Collections.emptyMap();
    when(vmDAO.getAllRunningByVds(vds.getId())).thenReturn(emptyMap);
}
#end_block

#method_before
public void OnAddDisk() {
    if (getEntity() != null) {
        DiskModel model = (DiskModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        if (!model.Validate()) {
            return;
        }
        // Save changes.
        storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
        Disk disk;
        if ((Boolean) model.getIsInternal().getEntity()) {
            DiskImage diskImage = new DiskImage();
            diskImage.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
            diskImage.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
            diskImage.setvolume_format(model.getVolumeFormat());
            if (model.getQuota().getIsAvailable()) {
                diskImage.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
            }
            disk = diskImage;
        } else {
            LunDisk lunDisk = new LunDisk();
            lunDisk.setLun((LUNs) model.getSanStorageModel().getAddedLuns().get(0).getEntity());
            disk = lunDisk;
        }
        disk.setDiskAlias((String) model.getAlias().getEntity());
        disk.setDiskDescription((String) model.getDescription().getEntity());
        disk.setDiskInterface((DiskInterface) model.getInterface().getSelectedItem());
        disk.setWipeAfterDelete((Boolean) model.getWipeAfterDelete().getEntity());
        disk.setBoot((Boolean) model.getIsBootable().getEntity());
        disk.setShareable((Boolean) model.getIsShareable().getEntity());
        disk.setPlugged((Boolean) model.getIsPlugged().getEntity());
        disk.setPropagateErrors(PropagateErrors.Off);
        model.StartProgress(null);
        AddDiskParameters tempVar2 = new AddDiskParameters(getEntity().getId(), disk);
        tempVar2.setStorageDomainId(storageDomain.getId());
        Frontend.RunAction(VdcActionType.AddDisk, tempVar2, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmGuideModel vmGuideModel = (VmGuideModel) result.getState();
                vmGuideModel.getWindow().StopProgress();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    vmGuideModel.Cancel();
                    vmGuideModel.PostAction();
                }
            }
        }, this);
    } else {
        Cancel();
    }
}
#method_after
public void OnAddDisk() {
    if (getEntity() != null) {
        DiskModel model = (DiskModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        if (!model.Validate()) {
            return;
        }
        if ((Boolean) model.getAttachDisk().getEntity()) {
            OnAttachDisks();
            return;
        }
        // Save changes.
        storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
        Disk disk;
        if ((Boolean) model.getIsInternal().getEntity()) {
            DiskImage diskImage = new DiskImage();
            diskImage.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
            diskImage.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
            diskImage.setvolume_format(model.getVolumeFormat());
            if (model.getQuota().getIsAvailable()) {
                diskImage.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
            }
            disk = diskImage;
        } else {
            LunDisk lunDisk = new LunDisk();
            lunDisk.setLun((LUNs) model.getSanStorageModel().getAddedLuns().get(0).getEntity());
            disk = lunDisk;
        }
        disk.setDiskAlias((String) model.getAlias().getEntity());
        disk.setDiskDescription((String) model.getDescription().getEntity());
        disk.setDiskInterface((DiskInterface) model.getInterface().getSelectedItem());
        disk.setWipeAfterDelete((Boolean) model.getWipeAfterDelete().getEntity());
        disk.setBoot((Boolean) model.getIsBootable().getEntity());
        disk.setShareable((Boolean) model.getIsShareable().getEntity());
        disk.setPlugged((Boolean) model.getIsPlugged().getEntity());
        disk.setPropagateErrors(PropagateErrors.Off);
        model.StartProgress(null);
        AddDiskParameters tempVar2 = new AddDiskParameters(getEntity().getId(), disk);
        tempVar2.setStorageDomainId(storageDomain.getId());
        Frontend.RunAction(VdcActionType.AddDisk, tempVar2, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmGuideModel vmGuideModel = (VmGuideModel) result.getState();
                vmGuideModel.getWindow().StopProgress();
                VdcReturnValueBase returnValueBase = result.getReturnValue();
                if (returnValueBase != null && returnValueBase.getSucceeded()) {
                    vmGuideModel.Cancel();
                    vmGuideModel.PostAction();
                }
            }
        }, this);
    } else {
        Cancel();
    }
}
#end_block

#method_before
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.Dhcp, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(nic, vlan));
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#method_after
@Test
public void vlanOverNic() {
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.Dhcp, null);
    VdsNetworkInterface vlan = createVlan(nic, net);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(nic), Collections.<String>emptySet(), Arrays.asList(nic, vlan));
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
}
#end_block

#method_before
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<VdsNetworkInterface>emptyList(), ifaces);
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#method_after
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    Network net = createNetwork(RandomUtils.instance().nextInt(0, 4000));
    VdsNetworkInterface vlan = createVlan(bond, net);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    ifaces.add(vlan);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    assertBondWasSent(bond, slaves);
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(bond.getName(), networkStruct.get("bonding"));
}
#end_block

#method_before
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.Dhcp, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(nic));
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#method_after
@Test
public void networkWithDhcp() {
    Network net = createNetwork(null);
    VdsNetworkInterface nic = createNic("eth0", null, NetworkBootProtocol.Dhcp, net.getName());
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.singletonList(net), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Arrays.asList(nic));
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, String> networkStruct = assertNeworkWasSent(net);
    assertEquals(nic.getName(), networkStruct.get("nic"));
    assertEquals(SetupNetworksVDSCommand.DHCP_BOOT_PROTOCOL, networkStruct.get(SetupNetworksVDSCommand.BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<VdsNetworkInterface>emptyList(), ifaces);
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#method_after
@Test
public void bondModified() {
    VdsNetworkInterface bond = createBond();
    List<VdsNetworkInterface> slaves = createSlaves(bond);
    List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(slaves);
    ifaces.add(bond);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.NewGuid(), Collections.<Network>emptyList(), Collections.<String>emptyList(), Collections.singletonList(bond), Collections.<String>emptySet(), ifaces);
    createCommand(parameters).Execute();
    verifyMethodPassedToHost();
    Map<String, Object> bondMap = assertBondWasSent(bond, slaves);
    assertEquals(bond.getBondOptions(), bondMap.get(SetupNetworksVDSCommand.BONDING_OPTIONS));
}
#end_block

#method_before
@Test
public void bondWithNoNetowrkAttached() {
    VdsNetworkInterface bond = createVdsInterface("bond0", true, null, null, null);
    List<VdsNetworkInterface> ifacesToBond = createInterfacesToBond();
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    mockDaos(helper);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    when(networkDAO.getAllForCluster(any(Guid.class))).thenReturn(Collections.<Network>emptyList());
    List<VdcBllMessages> violations = helper.validate();
    assertNoViolations(violations);
    assertEquals(1, helper.getBonds().size());
    assertEquals(bond, helper.getBonds().get(0));
    assertEquals(0, helper.getNetworks().size());
}
#method_after
@Test
public void bondWithNoNetowrkAttached() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNoNetworksModified(helper);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void vlanOverBond() {
    VdsNetworkInterface bond = createVdsInterface("bond0", true, null, null, null);
    List<VdsNetworkInterface> ifacesToBond = createInterfacesToBond();
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    String networkName = "net";
    parameters.getInterfaces().add(createVdsInterface(bond.getName() + ".100", false, null, 100, networkName));
    SetupNetworksHelper helper = createHelper(parameters);
    mockDaos(helper);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    Network network = mockExistingNetwork(networkName);
    List<VdcBllMessages> violations = helper.validate();
    assertNoViolations(violations);
    assertEquals(1, helper.getBonds().size());
    assertEquals(bond, helper.getBonds().get(0));
    assertEquals(1, helper.getNetworks().size());
    assertEquals(network, helper.getNetworks().get(0));
}
#method_after
/* --- Tests for VLANs functionality --- */
@Test
public void vlanOverBond() {
    Network network = createNetwork("net");
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    mockExistingNetworks(network);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    parameters.getInterfaces().add(createVlan(bond.getName(), 100, network.getName()));
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectNoViolations(helper);
    assertBondModified(helper, bond);
    assertNetworkModified(helper, network);
    assertNoBondsRemoved(helper);
    assertNoNetworksRemoved(helper);
}
#end_block

#method_before
@Test
public void vlanBondNameMismatch() {
    VdsNetworkInterface bond = createVdsInterface("bond0", true, null, null, null);
    List<VdsNetworkInterface> ifacesToBond = createInterfacesToBond();
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    String networkName = "net";
    parameters.getInterfaces().add(createVdsInterface(bond.getName() + "0.100", false, null, 100, networkName));
    SetupNetworksHelper helper = createHelper(parameters);
    mockDaos(helper);
    mockExistingIfacesWithBond(bond, ifacesToBond);
    mockExistingNetwork(networkName);
    assertTrue(helper.validate().contains(VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS));
}
#method_after
@Test
public void vlanBondNameMismatch() {
    VdsNetworkInterface bond = createBond(BOND_NAME, null);
    List<VdsNetworkInterface> ifacesToBond = createNics(null);
    SetupNetworksParameters parameters = createParametersForBond(bond, ifacesToBond);
    parameters.getInterfaces().add(createVlan(bond.getName() + "1", 100, "net"));
    mockExistingIfacesWithBond(bond, ifacesToBond);
    SetupNetworksHelper helper = createHelper(parameters);
    validateAndExpectViolation(helper, VdcBllMessages.NETWORK_INTERFACE_NOT_EXISTS);
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(String name, Boolean bonded, String bondName, Integer vlanId, String networkName) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(Guid.NewGuid());
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    return iface;
}
#end_block

#method_before
private SetupNetworksParameters createParametersForBond(VdsNetworkInterface bond, List<VdsNetworkInterface> bondedIfaces) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.getInterfaces().add(bond);
    for (VdsNetworkInterface iface : bondedIfaces) {
        parameters.getInterfaces().add(createVdsInterface(iface.getName(), false, bond.getName(), null, null));
    }
    return parameters;
}
#method_after
private SetupNetworksParameters createParametersForBond(VdsNetworkInterface bond, List<VdsNetworkInterface> bondedIfaces) {
    SetupNetworksParameters parameters = new SetupNetworksParameters();
    parameters.getInterfaces().add(bond);
    for (VdsNetworkInterface iface : bondedIfaces) {
        parameters.getInterfaces().add(enslaveOrReleaseNIC(iface, bond.getName()));
    }
    return parameters;
}
#end_block

#method_before
private void mockExistingIfacesWithBond(VdsNetworkInterface bond, List<VdsNetworkInterface> ifacesToBond) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>(ifacesToBond);
    existingIfaces.add(createVdsInterface(bond.getName(), true, null, null, null));
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfacesWithBond(VdsNetworkInterface bond, List<VdsNetworkInterface> ifacesToBond) {
    VdsNetworkInterface[] ifaces = new VdsNetworkInterface[ifacesToBond.size() + 1];
    ifacesToBond.toArray(ifaces);
    ifaces[ifaces.length - 1] = bond;
    mockExistingIfaces(ifaces);
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params) {
    SetupNetworksHelper validator = new SetupNetworksHelper(params, Guid.Empty);
    return spy(validator);
}
#method_after
private SetupNetworksHelper createHelper(SetupNetworksParameters params) {
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, Guid.Empty));
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDAO();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDAO();
    doReturn(networkDAO).when(dbFacade).getNetworkDAO();
    return helper;
}
#end_block

#method_before
// Update IsENGINEUser flag.
public void UpdateIsENGINEUser(VdcUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.GetRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            loginModel.GetUserRoles(loginModel);
        }
    }), new Guid(ENGINEUserRoleId));
}
#method_after
// Update IsENGINEUser flag.
public void UpdateIsENGINEUser(VdcUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.GetRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            loginModel.GetUserRoles(loginModel);
        }
    }), ApplicationGuids.engineUser.asGuid());
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void GetUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.GetPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/QuotaConsumer persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.UpdateUserActionGroups(loginModel1, roleIdList);
            } else {
                CheckIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().getValue().equals(Everyone) && permission.getrole_id().getValue().equals(UserTemplateBasedVM);
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().getValue().equals(Everyone) && permission.getrole_id().getValue().equals(QuotaConsumer);
        }
    }), loginModel.getLoggedUser().getUserId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void GetUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.GetPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/QuotaConsumer persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.UpdateUserActionGroups(loginModel1, roleIdList);
            } else {
                CheckIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().getValue().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().getValue().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().getValue().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().getValue().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getUserId());
}
#end_block

#method_before
private void InitializeHelpers() {
    try {
        for (StorageType storageType : StorageType.values()) {
            Class<?> actionType = null;
            String formattedClassName = String.format("%1$s.%2$s%3$s", ACTION_TYPE_PACKAGE, storageType.name(), ACTION_TYPE_CLASS);
            try {
                actionType = Class.forName(formattedClassName);
            } catch (ClassNotFoundException cnfe) {
                if (storageType != StorageType.ALL && storageType != StorageType.UNKNOWN)
                    log.debugFormat("StorageHelperDirector Error:: the lookup for following class has failed: {0}", formattedClassName);
            }
            // if action type not exist - operation invalid
            if (actionType != null) {
                Constructor<?> info = actionType.getConstructors()[0];
                IStorageHelper currentHelper = (IStorageHelper) info.newInstance(null);
                _helpers.put(storageType, currentHelper);
            }
        }
    } catch (Exception ex) {
        log.error("StorageHelperDirector Error:: exception was encountered during InitializeHelpers() execution", ex);
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#method_after
private void InitializeHelpers() {
    try {
        for (StorageType storageType : StorageType.values()) {
            if (storageType.isConcreteStorageType()) {
                Class<?> actionType = null;
                String formattedClassName = String.format("%1$s.%2$s%3$s", ACTION_TYPE_PACKAGE, storageType.name(), ACTION_TYPE_CLASS);
                try {
                    actionType = Class.forName(formattedClassName);
                } catch (ClassNotFoundException cnfe) {
                    log.debugFormat("StorageHelperDirector Error:: the lookup for following class has failed: {0}", formattedClassName);
                }
                // if action type not exist - operation invalid
                if (actionType != null) {
                    Constructor<?> info = actionType.getConstructors()[0];
                    IStorageHelper currentHelper = (IStorageHelper) info.newInstance(null);
                    _helpers.put(storageType, currentHelper);
                }
            }
        }
    } catch (Exception ex) {
        log.error("StorageHelperDirector Error:: exception was encountered during InitializeHelpers() execution", ex);
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#end_block

#method_before
public void OnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) getWindow();
    int conectivityTimeout = 60000;
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity((Boolean) model.getCheckConnectivity().getEntity());
    params.setConectivityTimeout(conectivityTimeout);
    params.setVdsId(getEntity().getId());
    IFrontendActionAsyncCallback callback = new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            HostInterfaceListModel hostInterfaceListModel = (HostInterfaceListModel) result.getState();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel commitChanges = ((HostSetupNetworksModel) hostInterfaceListModel.getcurrentModel()).getCommitChanges();
                if ((Boolean) commitChanges.getEntity()) {
                    SaveNetworkConfig(hostInterfaceListModel.getEntity().getId(), hostInterfaceListModel);
                } else {
                    hostInterfaceListModel.getcurrentModel().StopProgress();
                    hostInterfaceListModel.Cancel();
                    hostInterfaceListModel.Search();
                }
            } else {
                hostInterfaceListModel.getcurrentModel().StopProgress();
            }
        }
    };
    model.StartProgress(null);
    setcurrentModel(model);
    Frontend.RunAction(VdcActionType.SetupNetworks, params, callback, this);
}
#method_after
public void OnSetupNetworks() {
    final HostSetupNetworksModel model = (HostSetupNetworksModel) getWindow();
    int conectivityTimeout = 60000;
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(model.getAllNics());
    params.setCheckConnectivity((Boolean) model.getCheckConnectivity().getEntity());
    params.setConectivityTimeout(conectivityTimeout);
    params.setVdsId(getEntity().getId());
    IFrontendActionAsyncCallback callback = new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                EntityModel commitChanges = model.getCommitChanges();
                if ((Boolean) commitChanges.getEntity()) {
                    SaveNetworkConfig(getEntity().getId(), HostInterfaceListModel.this);
                } else {
                    model.StopProgress();
                    Cancel();
                    Search();
                }
            } else {
                model.StopProgress();
            }
        }
    };
    setcurrentModel(model);
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.SetupNetworks, params, callback);
}
#end_block

#method_before
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    if (volume.isSetVolumeType()) {
        validateEnum(GlusterVolumeType.class, volume.getVolumeType().toUpperCase());
    }
    if (volume.isSetTransportTypes()) {
        for (String transportType : volume.getTransportTypes().getTransportTypes()) {
            validateEnum(TransportType.class, transportType.toUpperCase());
        }
    }
    if (volume.isSetAccessProtocols()) {
        for (String accessProtocol : volume.getAccessProtocols().getAccessProtocols()) {
            validateEnum(AccessProtocol.class, accessProtocol.toUpperCase());
        }
    }
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#method_after
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    validateEnumParameters(volume);
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#end_block

#method_before
private void addPermission() {
    addTemplateUserPermission(getCurrentUser().getUserId());
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addTemplateUserPermission(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID);
    }
}
#method_after
private void addPermission() {
    addPermissionForTempalte(getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTempalte(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    LockImage();
    VDSReturnValue vdsReturnValue = null;
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0), getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0), getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(CreateTask(taskCreationInfo, getParameters().getParentCommand()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    LockImage();
    VDSReturnValue vdsReturnValue = null;
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0), getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0), getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(CreateTask(taskCreationInfo, getParameters().getParentCommand()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNetworkPopupPresenterWidget.class, ClusterNetworkPopupPresenterWidget.ViewDef.class, ClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNetworkPopupPresenterWidget.class, ClusterNetworkPopupPresenterWidget.ViewDef.class, ClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
}
#end_block

#method_before
@Override
public void setInputFieldsEnabled(boolean enabled) {
    nameEditor.setEnabled(enabled);
    descriptionEditor.setEnabled(enabled);
    isVmNetworkEditor.setEnabled(enabled);
    vlanTagging.setEnabled(enabled);
    vlanTag.setEnabled(enabled);
    hasMtuEditor.setEnabled(enabled);
    mtuEditor.setEnabled(enabled);
    if (enabled) {
        messageLabel.setVisible(false);
    } else {
        messageLabel.setVisible(true);
    }
}
#method_after
@Override
public void setInputFieldsEnabled(boolean enabled) {
    nameEditor.setEnabled(enabled);
    descriptionEditor.setEnabled(enabled);
    isVmNetworkEditor.setEnabled(enabled);
    vlanTagging.setEnabled(enabled);
    vlanTag.setEnabled(enabled);
    hasMtuEditor.setEnabled(enabled);
    mtuEditor.setEnabled(enabled);
    messageLabel.setVisible(!enabled);
}
#end_block

#method_before
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.attachAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : clustersTable.getVisibleItems()) {
                NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                }
                clustersTable.redraw();
            }
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : clustersTable.getVisibleItems()) {
                NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
                if (networkClusterModel.getIsChangable()) {
                    if (!networkClusterModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : clustersTable.getVisibleItems()) {
                if (model.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    clustersTable.addEntityModelColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((NetworkClusterModel) model).getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new EntityModelCheckboxColumn(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
            networkClusterModel.setAttached(value);
            clustersTable.redrawHeaders();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((NetworkClusterModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "80px");
}
#method_after
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.attachAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            ListModel tableModel = clustersTable.flush();
            for (Object model : tableModel.getItems()) {
                NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
                if (networkClusterModel.getIsChangable()) {
                    networkClusterModel.setAttached(value);
                }
            }
            clustersTable.edit(tableModel);
        }

        @Override
        public Boolean getValue() {
            for (Object model : clustersTable.flush().getItems()) {
                NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
                if (networkClusterModel.getIsChangable()) {
                    if (!networkClusterModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (Object model : clustersTable.flush().getItems()) {
                NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
                if (networkClusterModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    clustersTable.addEntityModelColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((NetworkClusterModel) model).getName();
        }
    }, constants.nameClusterHeader());
    clustersTable.addColumn(new EntityModelCheckboxColumn(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            NetworkClusterModel networkClusterModel = (NetworkClusterModel) model;
            networkClusterModel.setAttached(value);
            clustersTable.edit(clustersTable.flush());
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((NetworkClusterModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return model.getIsChangable();
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.attach()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "80px");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void edit(M object) {
    this.listModel = object;
    // get items
    List<EntityModel> items = (List<EntityModel>) listModel.getItems();
    setRowData(items == null ? new ArrayList<EntityModel>() : items);
    // Add ItemsChangedEvent Listener
    object.getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            List<EntityModel> items = (List<EntityModel>) list.getItems();
            setRowData(items == null ? new ArrayList<EntityModel>() : items);
        }
    });
    object.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            getSelectionModel().setSelected((EntityModel) list.getSelectedItem(), true);
        }
    });
    object.getSelectedItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            if (list.getSelectedItems() != null) {
                for (Object item : list.getSelectedItems()) {
                    EntityModel entityModel = (EntityModel) item;
                    getSelectionModel().setSelected(entityModel, true);
                }
            }
        }
    });
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void edit(M object) {
    this.listModel = object;
    // Add ItemsChangedEvent Listener
    object.getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            List<EntityModel> items = (List<EntityModel>) list.getItems();
            setRowData(items == null ? new ArrayList<EntityModel>() : items);
        }
    });
    object.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            getSelectionModel().setSelected((EntityModel) list.getSelectedItem(), true);
        }
    });
    object.getSelectedItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            M list = (M) sender;
            if (list.getSelectedItems() != null) {
                for (Object item : list.getSelectedItems()) {
                    EntityModel entityModel = (EntityModel) item;
                    getSelectionModel().setSelected(entityModel, true);
                }
            }
        }
    });
    // Get items from ListModel and update table data
    List<EntityModel> items = (List<EntityModel>) listModel.getItems();
    setRowData(items == null ? new ArrayList<EntityModel>() : items);
}
#end_block

#method_before
private void InitializeHelpers() {
    try {
        for (String helperName : EnumCompat.GetNames(StorageType.class)) {
            Class<?> actionType = null;
            try {
                actionType = java.lang.Class.forName(String.format("%1$s.%2$s%3$s", "org.ovirt.engine.core.bll.storage", helperName, "StorageHelper"));
            } catch (ClassNotFoundException cnfe) {
            // eat it
            }
            /**
             * if action type not exist - operation valid
             */
            if (actionType != null) {
                Constructor<?> info = actionType.getConstructors()[0];
                Object tempVar = info.newInstance(null);
                IStorageHelper currentHelper = (IStorageHelper) ((tempVar instanceof IStorageHelper) ? tempVar : null);
                if (currentHelper != null) {
                    _helpers.put(StorageType.valueOf(helperName), currentHelper);
                }
            }
        }
    } catch (Exception ex) {
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#method_after
private void InitializeHelpers() {
    try {
        for (StorageType storageType : StorageType.values()) {
            Class<?> actionType = null;
            String formattedClassName = String.format("%1$s.%2$s%3$s", ACTION_TYPE_PACKAGE, storageType.name(), ACTION_TYPE_CLASS);
            try {
                actionType = Class.forName(formattedClassName);
            } catch (ClassNotFoundException cnfe) {
                log.error("StorageHelperDirector Error:: the lookup for following class has failed: " + formattedClassName, cnfe);
            }
            // if action type not exist - operation invalid
            if (actionType != null) {
                Constructor<?> info = actionType.getConstructors()[0];
                IStorageHelper currentHelper = (IStorageHelper) info.newInstance(null);
                _helpers.put(storageType, currentHelper);
            }
        }
    } catch (Exception ex) {
        log.error("StorageHelperDirector Error:: exception was encountered during InitializeHelpers() execution", ex);
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#end_block

#method_before
private void InitializeHelpers() {
    try {
        for (String helperName : EnumCompat.GetNames(StorageType.class)) {
            java.lang.Class actionType = null;
            try {
                actionType = java.lang.Class.forName(String.format("%1$s.%2$s%3$s", "org.ovirt.engine.core.bll.storage", helperName, "StorageHelper"));
            } catch (ClassNotFoundException cnfe) {
            // eat it
            }
            /**
             * if action type not exist - operation valid
             */
            if (actionType != null) {
                java.lang.reflect.Constructor<?> info = actionType.getConstructors()[0];
                Object tempVar = info.newInstance(null);
                IStorageHelper currentHelper = (IStorageHelper) ((tempVar instanceof IStorageHelper) ? tempVar : null);
                if (currentHelper != null) {
                    _helpers.put(StorageType.valueOf(helperName), currentHelper);
                }
            }
        }
    } catch (Exception ex) {
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#method_after
private void InitializeHelpers() {
    try {
        for (String helperName : EnumCompat.GetNames(StorageType.class)) {
            java.lang.Class<?> actionType = null;
            try {
                actionType = java.lang.Class.forName(String.format("%1$s.%2$s%3$s", "org.ovirt.engine.core.bll.storage", helperName, "StorageHelper"));
            } catch (ClassNotFoundException cnfe) {
            // eat it
            }
            /**
             * if action type not exist - operation valid
             */
            if (actionType != null) {
                java.lang.reflect.Constructor<?> info = actionType.getConstructors()[0];
                Object tempVar = info.newInstance(null);
                IStorageHelper currentHelper = (IStorageHelper) ((tempVar instanceof IStorageHelper) ? tempVar : null);
                if (currentHelper != null) {
                    _helpers.put(StorageType.valueOf(helperName), currentHelper);
                }
            }
        }
    } catch (Exception ex) {
        throw new ApplicationException("JTODO missing exception", ex);
    }
}
#end_block

#method_before
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages message = VdcBllMessages.Unassigned;
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) {
            continue;
        }
        noVDSs = false;
        message = isReadyToRun(curVds);
        if (message == null) {
            return true;
        } else {
            if (messageToReturn.getValue() < message.getValue()) {
                messageToReturn = message;
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#method_after
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) {
            continue;
        }
        noVDSs = false;
        ValidationResult result = validateHostIsReadyToRun(curVds);
        if (result.isValid()) {
            return true;
        } else {
            if (messageToReturn.getValue() < result.getMessage().getValue()) {
                messageToReturn = result.getMessage();
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    boolean authenticated = false;
    IVdcUser vdcUser = SessionDataContainer.getInstance().getUser();
    if (vdcUser == null) {
        boolean domainFound = false;
        List<String> vdcDomains = LdapBrokerUtils.getDomainsList();
        for (String domain : vdcDomains) {
            if (StringHelper.EqOp(domain.toLowerCase(), getDomain().toLowerCase())) {
                domainFound = true;
                break;
            }
        }
        if (!domainFound) {
            addCanDoActionMessage(VdcBllMessages.USER_CANNOT_LOGIN_DOMAIN_NOT_SUPPORTED);
            return false;
        }
        UserAuthenticationResult result = authenticateUser();
        // error
        if (result == null) {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
        _adUser = result.getUser();
        authenticated = result.isSuccessful();
        if ((!authenticated || _adUser == null)) {
            HandleAuthenticationError(result.getErrorMessages());
            authenticated = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
    }
    if (authenticated) {
        // After updating the database user, retreive it's MLA admin status
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        VdcUser currentUser = new VdcUser(_adUser);
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(currentUser);
        log.infoFormat("Checking if user {0} is an admin, result {1}", currentUser.getUserName(), isAdmin);
        currentUser.setAdmin(isAdmin);
        setCurrentUser(currentUser);
    }
    return authenticated;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    boolean authenticated = false;
    IVdcUser vdcUser = SessionDataContainer.getInstance().getUser();
    if (vdcUser == null) {
        boolean domainFound = false;
        List<String> vdcDomains = LdapBrokerUtils.getDomainsList();
        for (String domain : vdcDomains) {
            if (StringHelper.EqOp(domain.toLowerCase(), getDomain().toLowerCase())) {
                domainFound = true;
                break;
            }
        }
        if (!domainFound) {
            addCanDoActionMessage(VdcBllMessages.USER_CANNOT_LOGIN_DOMAIN_NOT_SUPPORTED);
            return false;
        }
        UserAuthenticationResult result = authenticateUser();
        // error
        if (result == null) {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
        _adUser = result.getUser();
        authenticated = result.isSuccessful();
        if ((!authenticated || _adUser == null)) {
            HandleAuthenticationError(result.getErrorMessages());
            authenticated = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
    }
    if (authenticated) {
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        VdcUser currentUser = new VdcUser(_adUser);
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(currentUser);
        log.infoFormat("Checking if user {0} is an admin, result {1}", currentUser.getUserName(), isAdmin);
        currentUser.setAdmin(isAdmin);
        setCurrentUser(currentUser);
    }
    return authenticated;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    return updateBrickServerNames(getParameters().getBricks(), true);
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    } else if (getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    return updateBrickServerNames(getParameters().getBricks(), true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount());
        getReturnValue().setActionReturnValue(getBrickIds(getParameters().getBricks()));
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks());
        getReturnValue().setActionReturnValue(getBrickIds(getParameters().getBricks()));
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> bricks, int replicaCount, int stripeCount) {
    for (GlusterBrickEntity brick : bricks) {
        if (getGlusterVolume().getStatus() == GlusterVolumeStatus.UP) {
            brick.setStatus(GlusterBrickStatus.UP);
        } else {
            brick.setStatus(GlusterBrickStatus.DOWN);
        }
        getGlusterBrickDao().save(brick);
    }
    if (replicaCount != 0) {
        getGlusterVolumeDao().updateReplicaCount(bricks.get(0).getVolumeId(), replicaCount);
    }
    if (stripeCount != 0) {
        getGlusterVolumeDao().updateStripeCount(bricks.get(0).getVolumeId(), stripeCount);
    }
}
#method_after
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> newBricks) {
    // Reorder the volume bricks
    GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterBrickEntity> volumeBricks = volume.getBricks();
    if (isReplicaCountIncreased() || isStripeCountIncreased()) {
        GlusterBrickEntity brick;
        int brick_num = 0;
        int count = (isReplicaCountIncreased()) ? getParameters().getReplicaCount() : getParameters().getStripeCount();
        // Updating existing brick order
        for (int i = 0; i < volumeBricks.size(); i++) {
            if (((i + 1) % count) == 0) {
                brick_num++;
            }
            brick = volumeBricks.get(i);
            brick.setBrickOrder(brick_num);
            brick_num++;
            getGlusterBrickDao().updateBrickOrder(brick.getId(), brick.getBrickOrder());
        }
        // Adding new bricks
        for (int i = 0; i < newBricks.size(); i++) {
            brick = newBricks.get(i);
            brick.setBrickOrder((i + 1) * count - 1);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    } else {
        // No change in the replica/stripe count
        int brickCount = volumeBricks.get(volumeBricks.size() - 1).getBrickOrder();
        for (GlusterBrickEntity brick : newBricks) {
            brick.setBrickOrder(++brickCount);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    }
    // Update the volume replica/stripe count
    if (isReplicaCountIncreased()) {
        volume.setReplicaCount(getParameters().getReplicaCount());
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE && getParameters().getReplicaCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    }
    if (isStripeCountIncreased()) {
        volume.setStripeCount(getParameters().getStripeCount());
    }
    if (volume.getVolumeType() == GlusterVolumeType.STRIPE && getParameters().getStripeCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_STRIPE);
    }
    getGlusterVolumeDao().updateGlusterVolume(volume);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK;
    } else {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK;
    } else {
        return errorType == null ? AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED : errorType;
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public GlusterBricks list() {
    try {
        VdcQueryReturnValue returnValue = runQuery(VdcQueryType.GetGlusterVolumeBricks, new IdQueryParameters(asGuid(getVolumeId())));
        if (!returnValue.getSucceeded()) {
            throw new BackendFailureException(localize(returnValue.getExceptionString()));
        }
        List<GlusterBrickEntity> bricks = (List<GlusterBrickEntity>) returnValue.getReturnValue();
        return mapCollection(bricks);
    } catch (Exception e) {
        return handleError(e, false);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public GlusterBricks list() {
    List<GlusterBrickEntity> bricks = getBackendCollection(VdcQueryType.GetGlusterVolumeBricks, new IdQueryParameters(asGuid(getVolumeId())));
    return mapCollection(bricks);
}
#end_block

#method_before
private List<GlusterBrickEntity> mapBricks(Guid volumeId, GlusterBricks glusterBricks) {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    for (GlusterBrick brick : glusterBricks.getGlusterBricks()) {
        GlusterBrickEntity brickEntity = getMapper(GlusterBrick.class, GlusterBrickEntity.class).map(brick, null);
        brickEntity.setVolumeId(volumeId);
        bricks.add(brickEntity);
    }
    return bricks;
}
#method_after
private List<GlusterBrickEntity> mapBricks(Guid volumeId, GlusterBricks glusterBricks) {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    if (glusterBricks.getGlusterBricks().size() > 0) {
        for (GlusterBrick brick : glusterBricks.getGlusterBricks()) {
            GlusterBrickEntity brickEntity = getMapper(GlusterBrick.class, GlusterBrickEntity.class).map(brick, null);
            brickEntity.setVolumeId(volumeId);
            bricks.add(brickEntity);
        }
    }
    return bricks;
}
#end_block

#method_before
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetNewReplicaCount() ? bricks.getNewReplicaCount() : 0;
    int stripeCount = bricks.isSetNewStripeCount() ? bricks.getNewStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    int stripeCount = bricks.isSetStripeCount() ? bricks.getStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public Response remove(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "id");
    }
    return performAction(VdcActionType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksParameters(asGuid(getVolumeId()), mapBricks(asGuid(getVolumeId()), bricks)));
}
#method_after
@Override
public Response remove(GlusterBricks bricks) {
    if (bricks.getGlusterBricks().size() > 0) {
        for (GlusterBrick brick : bricks.getGlusterBricks()) {
            validateParameters(brick, "id");
        }
    }
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    return performAction(VdcActionType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksParameters(asGuid(getVolumeId()), mapBricks(asGuid(getVolumeId()), bricks), replicaCount));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((brickOrder == null) ? 0 : brickOrder.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#end_block

#method_before
public void copyFrom(GlusterBrickEntity brick) {
    setId(brick.getId());
    setVolumeId(brick.getVolumeId());
    setServerId(brick.getServerId());
    setServerName(brick.getServerName());
    setBrickDirectory(brick.getBrickDirectory());
    setStatus(brick.getStatus());
}
#method_after
public void copyFrom(GlusterBrickEntity brick) {
    setId(brick.getId());
    setVolumeId(brick.getVolumeId());
    setServerId(brick.getServerId());
    setServerName(brick.getServerName());
    setBrickDirectory(brick.getBrickDirectory());
    setBrickOrder(brick.getBrickOrder());
    setStatus(brick.getStatus());
}
#end_block

#method_before
@Override
public void replaceBrick(GlusterBrickEntity oldBrick, GlusterBrickEntity newBrick) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", oldBrick.getId()).addValue("new_id", newBrick.getId()).addValue("new_server_id", newBrick.getServerId()).addValue("new_brick_dir", newBrick.getBrickDirectory()).addValue("new_brick_order", oldBrick.getBrickOrder()).addValue("new_status", EnumUtils.nameOrNull(newBrick.getStatus())));
}
#method_after
@Override
public void replaceBrick(GlusterBrickEntity oldBrick, GlusterBrickEntity newBrick) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", oldBrick.getId()).addValue("new_id", newBrick.getId()).addValue("new_server_id", newBrick.getServerId()).addValue("new_status", EnumUtils.nameOrNull(newBrick.getStatus())));
}
#end_block

#method_before
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(Guid.createGuidFromString(rs.getString("id")));
    brick.setVolumeId(Guid.createGuidFromString(rs.getString("volume_id")));
    Guid serverId = Guid.createGuidFromString(rs.getString("server_id"));
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(Integer.parseInt(rs.getString("brick_order")));
    brick.setStatus(GlusterBrickStatus.valueOf(rs.getString("status")));
    return brick;
}
#method_after
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(Guid.createGuidFromString(rs.getString("id")));
    brick.setVolumeId(Guid.createGuidFromString(rs.getString("volume_id")));
    Guid serverId = Guid.createGuidFromString(rs.getString("server_id"));
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterBrickStatus.valueOf(rs.getString("status")));
    return brick;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    return validateBricks(volume);
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (volumeNameExists(volume.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
        return false;
    }
    return validateBricks(volume);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    volume = getGlusterVolume();
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks());
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks());
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> newBricks) {
    // Reorder the volume bricks
    List<GlusterBrickEntity> volumeBricks = volume.getBricks();
    if (isReplicaCountIncreased() || isStripeCountIncreased()) {
        GlusterBrickEntity brick;
        int brick_num = 0;
        int count = (isReplicaCountIncreased()) ? getParameters().getReplicaCount() : getParameters().getStripeCount();
        // Updating existing brick order
        for (int i = 0; i < volumeBricks.size(); i++) {
            if (((i + 1) % count) == 0) {
                brick_num++;
            }
            brick = volumeBricks.get(i);
            brick.setBrickOrder(brick_num);
            brick_num++;
            getGlusterBrickDao().updateBrickOrder(brick.getId(), brick.getBrickOrder());
        }
        // Adding new bricks
        for (int i = 0; i < newBricks.size(); i++) {
            brick = newBricks.get(i);
            brick.setBrickOrder((i + 1) * count - 1);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    } else {
        // No change in the replica/stripe count
        int brickCount = volumeBricks.get(volumeBricks.size() - 1).getBrickOrder();
        for (GlusterBrickEntity brick : newBricks) {
            brick.setBrickOrder(++brickCount);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    }
    // Update the volume replica/stripe count
    if (isReplicaCountIncreased()) {
        volume.setReplicaCount(getParameters().getReplicaCount());
        if (volume.getVolumeType() == GlusterVolumeType.REPLICATE && getParameters().getReplicaCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
            volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
        }
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
    if (isStripeCountIncreased()) {
        volume.setStripeCount(getParameters().getStripeCount());
        if (volume.getVolumeType() == GlusterVolumeType.STRIPE && getParameters().getStripeCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
            volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_STRIPE);
        }
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
}
#method_after
private void addGlusterVolumeBricksInDb(List<GlusterBrickEntity> newBricks) {
    // Reorder the volume bricks
    GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterBrickEntity> volumeBricks = volume.getBricks();
    if (isReplicaCountIncreased() || isStripeCountIncreased()) {
        GlusterBrickEntity brick;
        int brick_num = 0;
        int count = (isReplicaCountIncreased()) ? getParameters().getReplicaCount() : getParameters().getStripeCount();
        // Updating existing brick order
        for (int i = 0; i < volumeBricks.size(); i++) {
            if (((i + 1) % count) == 0) {
                brick_num++;
            }
            brick = volumeBricks.get(i);
            brick.setBrickOrder(brick_num);
            brick_num++;
            getGlusterBrickDao().updateBrickOrder(brick.getId(), brick.getBrickOrder());
        }
        // Adding new bricks
        for (int i = 0; i < newBricks.size(); i++) {
            brick = newBricks.get(i);
            brick.setBrickOrder((i + 1) * count - 1);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    } else {
        // No change in the replica/stripe count
        int brickCount = volumeBricks.get(volumeBricks.size() - 1).getBrickOrder();
        for (GlusterBrickEntity brick : newBricks) {
            brick.setBrickOrder(++brickCount);
            brick.setStatus(getBrickStatus());
            getGlusterBrickDao().save(brick);
        }
    }
    // Update the volume replica/stripe count
    if (isReplicaCountIncreased()) {
        volume.setReplicaCount(getParameters().getReplicaCount());
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE && getParameters().getReplicaCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    }
    if (isStripeCountIncreased()) {
        volume.setStripeCount(getParameters().getStripeCount());
    }
    if (volume.getVolumeType() == GlusterVolumeType.STRIPE && getParameters().getStripeCount() < (volume.getBricks().size() + getParameters().getBricks().size())) {
        volume.setVolumeType(GlusterVolumeType.DISTRIBUTED_STRIPE);
    }
    getGlusterVolumeDao().updateGlusterVolume(volume);
}
#end_block

#method_before
private boolean isReplicaCountIncreased() {
    if ((volume.getVolumeType() == GlusterVolumeType.REPLICATE || volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && getParameters().getReplicaCount() > volume.getReplicaCount()) {
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean isReplicaCountIncreased() {
    if ((getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) && getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount()) {
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private boolean isStripeCountIncreased() {
    if ((volume.getVolumeType() == GlusterVolumeType.STRIPE || volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) && getParameters().getStripeCount() > volume.getStripeCount()) {
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean isStripeCountIncreased() {
    if ((getGlusterVolume().getVolumeType() == GlusterVolumeType.STRIPE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE) && getParameters().getStripeCount() > getGlusterVolume().getStripeCount()) {
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private GlusterBrickStatus getBrickStatus() {
    return (volume.getStatus() == GlusterVolumeStatus.UP) ? GlusterBrickStatus.UP : GlusterBrickStatus.DOWN;
}
#method_after
private GlusterBrickStatus getBrickStatus() {
    return (getGlusterVolume().getStatus() == GlusterVolumeStatus.UP) ? GlusterBrickStatus.UP : GlusterBrickStatus.DOWN;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK;
    } else {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_ADD_BRICK;
    } else {
        return errorType == null ? AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED : errorType;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getBricks().size() == 1 || getGlusterVolume().getBricks().size() <= getParameters().getBricks().size()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REMOVE_ALL_BRICKS_FROM_VOLUME);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount() - 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT);
        }
    }
    return validateBricks(getParameters().getBricks());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getBricks().size() == 1 || getGlusterVolume().getBricks().size() <= getParameters().getBricks().size()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REMOVE_ALL_BRICKS_FROM_VOLUME);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount() - 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT_MORE_THAN_ONE);
            return false;
        } else if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT);
            return false;
        }
    }
    return validateBricks(getParameters().getBricks());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), getGlusterVolumeName(), bricks, replicaCount));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(bricks);
    } else {
        getReturnValue().getExecuteFailedMessages().add(returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), getGlusterVolumeName(), bricks, replicaCount));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(bricks);
    } else {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS;
    } else {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS;
    } else {
        return errorType == null ? AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED : errorType;
    }
}
#end_block

#method_before
private void removeBricksFromVolumeInDb(List<GlusterBrickEntity> brickList) {
    GlusterVolumeEntity volume = getGlusterVolume();
    for (GlusterBrickEntity brick : brickList) {
        getGlusterBrickDao().removeBrick(brick.getId());
    }
    // Update volume type and replica/stripe count
    if (volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE && volume.getReplicaCount() == (volume.getBricks().size() - brickList.size())) {
        volume.setVolumeType(GlusterVolumeType.REPLICATE);
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE || volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        int replicaCount = (getParameters().getReplicaCount() == 0 || getParameters().getReplicaCount() == volume.getReplicaCount()) ? volume.getReplicaCount() : getParameters().getReplicaCount();
        volume.setReplicaCount(replicaCount);
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
    if (volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE && volume.getStripeCount() == (volume.getBricks().size() - brickList.size())) {
        volume.setVolumeType(GlusterVolumeType.STRIPE);
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
}
#method_after
private void removeBricksFromVolumeInDb(List<GlusterBrickEntity> brickList) {
    GlusterVolumeEntity volume = getGlusterVolume();
    for (GlusterBrickEntity brick : brickList) {
        getGlusterBrickDao().removeBrick(brick.getId());
    }
    // Update volume type and replica/stripe count
    if (volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE && volume.getReplicaCount() == (volume.getBricks().size() - brickList.size())) {
        volume.setVolumeType(GlusterVolumeType.REPLICATE);
    }
    if (volume.getVolumeType() == GlusterVolumeType.REPLICATE || volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        int replicaCount = (getParameters().getReplicaCount() == 0) ? volume.getReplicaCount() : getParameters().getReplicaCount();
        volume.setReplicaCount(replicaCount);
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
    if (volume.getVolumeType() == GlusterVolumeType.DISTRIBUTED_STRIPE && volume.getStripeCount() == (volume.getBricks().size() - brickList.size())) {
        volume.setVolumeType(GlusterVolumeType.STRIPE);
        getGlusterVolumeDao().updateGlusterVolume(volume);
    }
}
#end_block

#method_before
@Override
public boolean Validate() {
    // Revalidate name field.
    // TODO: Make maximum characters value depend on number of desktops in pool.
    // VmOsType os = (VmOsType) getModel().getOSType().getSelectedItem();
    boolean isNew = getModel().getIsNew();
    int maxAllowedVms = configurator.getMaxVmsInPool();
    int assignedVms = getModel().getAssignedVms().AsConvertible().Integer();
    getModel().getNumOfDesktops().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) });
    getModel().getPrestartedVms().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) });
    getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid());
    getModel().setIsPoolTabValid(true);
    return super.Validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid();
}
#method_after
@Override
public boolean Validate() {
    // Revalidate name field.
    // TODO: Make maximum characters value depend on number of desktops in pool.
    // VmOsType os = (VmOsType) getModel().getOSType().getSelectedItem();
    boolean isNew = getModel().getIsNew();
    int maxAllowedVms = getMaxVmsInPool();
    int assignedVms = getModel().getAssignedVms().AsConvertible().Integer();
    getModel().getNumOfDesktops().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(4), new IntegerValidation(isNew ? 1 : 0, isNew ? maxAllowedVms : maxAllowedVms - assignedVms) });
    getModel().getPrestartedVms().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, assignedVms) });
    getModel().setIsGeneralTabValid(getModel().getIsGeneralTabValid() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid());
    getModel().setIsPoolTabValid(true);
    return super.Validate() && getModel().getName().getIsValid() && getModel().getNumOfDesktops().getIsValid() && getModel().getPrestartedVms().getIsValid();
}
#end_block

#method_before
public void AfterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Map.Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void AfterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            ResourceManager.getInstance().getEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getstatus() == VDSStatus.Maintenance) {
            try {
                ResourceManager.getInstance().getEventListener().vdsMovedToMaintanance(_vds.getId());
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode. The Host status will change to Non operational status.");
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, true, Guid.Empty);
                throw ex;
            }
        } else if (_vds.getstatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getvds_name());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getvds_name());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.SuccededToRunVm(vm_guid);
        }
        // run all vms that crushed that marked with auto startup
        for (Guid vm_guid : _autoVmsToRun) {
            // Refrain from auto-start HA VM during its re-run attempts.
            if (!_vmsToRerun.contains(vm_guid)) {
                ResourceManager.getInstance().getEventListener().runFailedAutoStartVM(vm_guid);
            }
        }
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            ResourceManager.getInstance().getEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getdisplay_ip(), runningVm.getdisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            ResourceManager.getInstance().getEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getstatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Boolean> activeBonds = new HashMap<String, Boolean>();
    List<network> clusterNetworks = getDbFacade().getNetworkDAO().getAllForCluster(_vds.getvds_group_id());
    boolean setHostDown = false;
    List<String> networks = new ArrayList<String>();
    List<String> nics = new ArrayList<String>();
    Map<String, List<String>> bondNics = new HashMap<String, List<String>>();
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Map<String, network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    try {
        for (VdsNetworkInterface iface : interfaces) {
            // report if MTU value differ from cluster
            logMTUDifferences(networksByName, iface);
            // Handle nics that are non bonded and not vlan over bond
            setHostDown = isRequiredInterfaceDown(networksByName, networks, nics, iface);
            // Handle bond nics
            if (iface.getBondName() != null) {
                poplate(activeBonds, clusterNetworks, networks, bondNics, iface);
            }
        }
        // only if we didn't already set the host to down
        if (!setHostDown) {
            for (String key : activeBonds.keySet()) {
                if (!activeBonds.get(key)) {
                    setHostDown = true;
                    // add the nics name for audit log
                    for (String name : bondNics.get(key)) {
                        nics.add(name);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getvds_name()), e);
    } finally {
        if (setHostDown) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>GetValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // else remove from map (for future checks) and set the host to non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : nics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getvds_name(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.AddCustomValue("Networks", StringHelper.trimEnd(sNetworks.toString(), ',', ' '));
                logable.AddCustomValue("Interfaces", StringHelper.trimEnd(sNics.toString(), ',', ' '));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getvds_name()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getstatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Boolean> activeBonds = new HashMap<String, Boolean>();
    List<network> clusterNetworks = getDbFacade().getNetworkDAO().getAllForCluster(_vds.getvds_group_id());
    boolean setHostDown = false;
    List<String> networks = new ArrayList<String>();
    List<String> nics = new ArrayList<String>();
    Map<String, List<String>> bondNics = new HashMap<String, List<String>>();
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Map<String, network> networksByName = NetworkUtils.networksByName(clusterNetworks);
    try {
        for (VdsNetworkInterface iface : interfaces) {
            // report if MTU value differ from cluster
            logMTUDifferences(networksByName, iface);
            // Handle nics that are non bonded and not vlan over bond
            setHostDown = isRequiredInterfaceDown(networksByName, networks, nics, iface);
            // Handle bond nics
            if (iface.getBondName() != null) {
                poplate(activeBonds, clusterNetworks, networks, bondNics, iface);
            }
        }
        // only if we didn't already set the host to down
        if (!setHostDown) {
            for (String key : activeBonds.keySet()) {
                if (!activeBonds.get(key)) {
                    setHostDown = true;
                    // add the nics name for audit log
                    for (String name : bondNics.get(key)) {
                        nics.add(name);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getvds_name()), e);
    } finally {
        if (setHostDown) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            } else {
                int delay = Config.<Integer>GetValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
                if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                    // if less then 1 minutes, still waiting for DHCP
                    return;
                } else {
                    // else remove from map (for future checks) and set the host to non-operational
                    hostDownTimes.remove(_vds.getId());
                }
            }
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : nics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getvds_name(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.AddCustomValue("Networks", StringHelper.trimEnd(sNetworks.toString(), ',', ' '));
                logable.AddCustomValue("Interfaces", StringHelper.trimEnd(sNics.toString(), ',', ' '));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getvds_name()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, Map.Entry<VmDynamic, VmStatistics>>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        if (_vdssToRefresh != null) {
            for (Guid vdsToRefreshId : _vdssToRefresh) {
                VdsManager vdsm = ResourceManager.getInstance().GetVdsManager(vdsToRefreshId);
                vdsm.forceRefreshRunTimeInfo();
            }
        }
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof RepositoryException) {
            log.errorFormat("Failed to update vms status in database,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
            log.error("Exception: ", command.getVDSReturnValue().getExceptionObject());
            return;
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, Entry<VmDynamic, VmStatistics>>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        if (_vdssToRefresh != null) {
            for (Guid vdsToRefreshId : _vdssToRefresh) {
                VdsManager vdsm = ResourceManager.getInstance().GetVdsManager(vdsToRefreshId);
                vdsm.forceRefreshRunTimeInfo();
            }
        }
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof RepositoryException) {
            log.errorFormat("Failed to update vms status in database,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
            log.error("Exception: ", command.getVDSReturnValue().getExceptionObject());
            return;
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (Map.Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdate.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#method_after
private void handleVmDeviceChange() {
    List<String> vmsToUpdate = new ArrayList<String>();
    for (Entry<VmDynamic, VmStatistics> vmHelper : _runningVms.values()) {
        VmDynamic vmDynamic = vmHelper.getKey();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdate.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdate.size() > 0) {
        updateVmDevices(vmsToUpdate);
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (Map.Entry<VmDynamic, VmStatistics> runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getKey());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = null;
            vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getstatus() != runningVm.getstatus() && !(vmToUpdate.getstatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (Map.Entry<VmDynamic, VmStatistics>) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (Entry<VmDynamic, VmStatistics> runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getKey());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = null;
            vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getstatus() != runningVm.getstatus() && !(vmToUpdate.getstatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (Entry<VmDynamic, VmStatistics>) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#end_block

#method_before
private void proceedDownVms() {
    for (Map.Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getstatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDAO().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic vm = vm_helper.getKey();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getstatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDAO().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (Map.Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic runningVm = vm_helper.getKey();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getclient_ip())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getstatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getstatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getstatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getstatus() != VMStatus.Up && vmToUpdate.getstatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getstatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getstatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDAO().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (Entry<VmDynamic, VmStatistics> vm_helper : _runningVms.values()) {
        VmDynamic runningVm = vm_helper.getKey();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getclient_ip())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getstatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getstatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getstatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getstatus() != VMStatus.Up && vmToUpdate.getstatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getstatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getstatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDAO().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private void InitUsbPolicy() {
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    DisplayType displayType = (DisplayType) (getDisplayProtocol().getSelectedItem() != null ? ((EntityModel) getDisplayProtocol().getSelectedItem()).getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    if (Version.v3_0.compareTo(cluster.getcompatibility_version()) >= 0) {
        if (osType.isWindows()) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (osType.isLinux()) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
}
#method_after
private void InitUsbPolicy() {
    VDSGroup cluster = (VDSGroup) getCluster().getSelectedItem();
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    DisplayType displayType = (DisplayType) (getDisplayProtocol().getSelectedItem() != null ? ((EntityModel) getDisplayProtocol().getSelectedItem()).getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (osType.isWindows()) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (osType.isLinux()) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
}
#end_block

#method_before
@Before
public void setup() throws Exception {
    validator = ValidationUtils.getValidator();
    mockConfig(9000);
}
#method_after
@Before
public void setup() throws Exception {
    validator = ValidationUtils.getValidator();
    IConfigUtilsInterface confUtils = mock(IConfigUtilsInterface.class);
    when(confUtils.GetValue(ConfigValues.MaxMTU, Config.DefaultConfigurationVersion)).thenReturn(TEST_MAX_MTU);
    when(confUtils.GetValue(ConfigValues.ManagementNetwork, Config.DefaultConfigurationVersion)).thenReturn(TEST_MANAGEMENT_NETWORK);
    Config.setConfigUtils(confUtils);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VmTemplate> retval = DbFacade.getInstance().getVmTemplateDAO().getAll(getUserID(), getParameters().isFiltered());
    for (VmTemplate template : retval) {
        AnonymousMethod1(template);
    }
    getQueryReturnValue().setReturnValue(retval);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VmTemplate> retval = getDbFacade().getVmTemplateDAO().getAll(getUserID(), getParameters().isFiltered());
    for (VmTemplate template : retval) {
        AnonymousMethod1(template);
    }
    getQueryReturnValue().setReturnValue(retval);
}
#end_block

#method_before
public static void GetTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                VmTemplate blankTemplate = null;
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getId().equals(Guid.Empty)) {
                        blankTemplate = template;
                    } else if (template.getstatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new Linq.VmTemplateByNameComparer());
                if (blankTemplate != null) {
                    list.add(0, blankTemplate);
                }
            }
            return list;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new GetVmTemplatesByStoragePoolIdParameters(dataCenterId), aQuery);
}
#method_after
public static void GetTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.RunQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new GetVmTemplatesByStoragePoolIdParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void GetVmTemplatesWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                VmTemplate blankTemplate = null;
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getId().equals(Guid.Empty)) {
                        blankTemplate = template;
                    } else if (template.getstatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new Linq.VmTemplateByNameComparer());
                if (blankTemplate != null) {
                    list.add(0, blankTemplate);
                }
            }
            return list;
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.RunQuery(VdcQueryType.GetVmTemplatesWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public static void GetVmTemplatesWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup) {
    aQuery.converterCallback = new TemplateConverter();
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.RunQuery(VdcQueryType.GetVmTemplatesWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static <T extends VmBase> void updateVmDevices(T entity, Guid newId) {
    VmBase newVmBase = getBaseObject(entity, newId);
    if (newVmBase != null) {
        updateCdInVmDevice(newVmBase);
        updateBootOrderInVmDevice(newVmBase);
        updateNumOfMonitorsInVmDevice(null, newVmBase);
        updateUSBSlots(null, newVmBase);
        updateMemoryBalloon(null, newVmBase);
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VmBase oldVmBase) {
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getdefault_boot_sequence() != entity.getdefault_boot_sequence()) {
            updateBootOrderInVmDevice(entity);
        }
        if (oldVmBase.getnum_of_monitors() != entity.getnum_of_monitors()) {
            updateNumOfMonitorsInVmDevice(oldVmBase, entity);
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
    }
}
#end_block

#method_before
public static <T extends VmBase> void updateVmDevices(T entity) {
    VmBase vmBase = getBaseObject(entity, entity.getId());
    if (vmBase != null) {
        updateUSBSlots(vmBase, vmBase);
    }
}
#method_after
public static <T extends VmBase> void updateVmDevices(T entity) {
    if (entity != null) {
        updateUSBSlots(entity, entity);
    }
}
#end_block

#method_before
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static <T extends VmBase> void updateVmDevices(T entity, Guid newId) {
    VmBase newVmBase = getBaseObject(entity, newId);
    if (newVmBase != null) {
        updateCdInVmDevice(newVmBase);
        updateBootOrderInVmDevice(newVmBase);
        updateNumOfMonitorsInVmDevice(null, newVmBase);
        updateUSBSlots(null, newVmBase);
        updateMemoryBalloon(null, newVmBase);
    }
}
#method_after
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static <T extends VmBase> void updateVmDevices(T entity, Guid newId) {
    if (entity != null) {
        updateCdInVmDevice(entity);
        updateBootOrderInVmDevice(entity);
        updateNumOfMonitorsInVmDevice(null, entity);
        updateUSBSlots(null, entity);
        updateMemoryBalloon(null, entity, true);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VmBase vmBase = DbFacade.getInstance().getVmStaticDAO().get(dstId);
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // update number of monitors
            updateNumOfMonitorsInVmDevice(null, vmBase);
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase);
            // skip other Blank template devices
            break;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!srcCdPath.isEmpty() || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                VM vm = DbFacade.getInstance().getVmDAO().get(vmBase.getId());
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, List<DiskImage> disks, List<VmNetworkInterface> ifaces) {
    Guid id;
    VM vm = DbFacade.getInstance().getVmDAO().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    int diskCount = 0;
    int ifaceCount = 0;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDAO().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    String isoPath = vmBase.getiso_path();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceType.DISK.getName(), VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    for (VmDevice device : devices) {
        id = Guid.NewGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // update number of monitors
            updateNumOfMonitorsInVmDevice(null, vmBase);
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), dstId), VmDeviceType.DISK, VmDeviceType.CDROM, specParams, true, true);
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(null, vmBase, vm.isBalloonEnabled());
            // skip other Blank template devices
            break;
        }
        if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (diskCount < disks.size()) {
                id = (disks.get(diskCount++)).getId();
            }
        } else if (VmDeviceType.INTERFACE.getName().equals(device.getType())) {
            if (ifaceCount < ifaces.size()) {
                id = ifaces.get(ifaceCount++).getId();
            }
        } else if (VmDeviceType.VIDEO.getName().equals(device.getType())) {
            specParams.putAll(getMemExpr(vmBase.getnum_of_monitors()));
        } else if (VmDeviceType.DISK.getName().equals(device.getType()) && VmDeviceType.CDROM.getName().equals(device.getDevice())) {
            // check here is source VM had CD (Vm from snapshot)
            String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
            shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
            if (!hasAlreadyCD && shouldHaveCD) {
                setCdPath(specParams, srcCdPath, isoPath);
            } else {
                // CD already exists
                continue;
            }
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if destination is a VM , update devices boot order
    if (isVm) {
        updateBootOrderInVmDevice(vmBase);
        // create sound card for a desktop VM if not exists
        if (vmBase.getvm_type() == VmType.Desktop) {
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(vmBase.getId(), VmDeviceType.SOUND.getName());
            if (list.size() == 0) {
                String soundDevice = VmInfoBuilderBase.getSoundDevice(vm);
                addManagedDevice(new VmDeviceId(Guid.NewGuid(), vmBase.getId()), VmDeviceType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true);
            }
        }
    }
}
#end_block

#method_before
private static void updateMemoryBalloon(VmBase oldVm, VmBase newVm) {
    boolean hasBalloon = (oldVm != null && oldVm.isBalloonEnabled());
    boolean shouldHaveBalloon = newVm.isBalloonEnabled();
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.NewGuid(), newVm.getId()), VmDeviceType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newVm.getId(), VmDeviceType.BALLOON.getName());
            removeNumberOfDevices(list, 1);
        }
    }
}
#method_after
private static void updateMemoryBalloon(VmBase oldVm, VmBase newVm, boolean shouldHaveBalloon) {
    Guid id = newVm.getId();
    VM vm = vmDao.get(id);
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.NewGuid(), newVm.getId()), VmDeviceType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newVm.getId(), VmDeviceType.BALLOON.getName());
            removeNumberOfDevices(list, 1);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmMemoryBalloon() {
// TODO Auto-generated method stub
}
#method_after
@Override
protected void buildVmMemoryBalloon() {
// Not supported in old code
}
#end_block

#method_before
public boolean isBalloonEnabled() {
    return mVmStatic.isBalloonEnabled();
}
#method_after
public boolean isBalloonEnabled() {
    return balloonEnabled;
}
#end_block

#method_before
public void setBalloonEnabled(boolean isBallonEnabled) {
    mVmStatic.setBalloonEnabled(isBallonEnabled);
    OnPropertyChanged(new PropertyChangedEventArgs("is_balloon_enabled"));
}
#method_after
public void setBalloonEnabled(boolean isBallonEnabled) {
    balloonEnabled = isBallonEnabled;
    OnPropertyChanged(new PropertyChangedEventArgs("is_balloon_enabled"));
}
#end_block

#method_before
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = DbFacade.getInstance().getDbEngineDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#method_after
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = dialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#end_block

#method_before
public boolean isBalloonEnabled() {
    return this.isBalloonEnabled;
}
#method_after
public boolean isBalloonEnabled() {
    return this.balloonEnabled;
}
#end_block

#method_before
public void setBalloonEnabled(boolean isBalloonEnabled) {
    this.isBalloonEnabled = isBalloonEnabled;
}
#method_after
public void setBalloonEnabled(boolean isBalloonEnabled) {
    this.balloonEnabled = isBalloonEnabled;
}
#end_block

#method_before
private void addCpuPinning(final String compatibilityVersion) {
    final String cpuPinning = vm.getCpuPinning();
    if (Boolean.TRUE.equals(Config.<Boolean>GetValue(ConfigValues.CpuPinningEnabled, compatibilityVersion)) && cpuPinning != null) {
        final XmlRpcStruct pinDict = new XmlRpcStruct();
        for (String pin : cpuPinning.split("_")) {
            final String[] split = pin.split("#");
            pinDict.add(split[0], split[1]);
        }
        createInfo.add(VdsProperties.cpuPinning, pinDict);
    }
}
#method_after
private void addCpuPinning(final String compatibilityVersion) {
    final String cpuPinning = vm.getCpuPinning();
    if (!StringUtils.isEmpty(cpuPinning) && Boolean.TRUE.equals(Config.<Boolean>GetValue(ConfigValues.CpuPinningEnabled, compatibilityVersion)) && cpuPinning != null) {
        final XmlRpcStruct pinDict = new XmlRpcStruct();
        for (String pin : cpuPinning.split("_")) {
            final String[] split = pin.split("#");
            pinDict.add(split[0], split[1]);
        }
        createInfo.add(VdsProperties.cpuPinning, pinDict);
    }
}
#end_block

#method_before
private void addDevice(XmlRpcStruct struct, VmDevice vmDevice, String path) {
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    struct.add(VdsProperties.Path, path);
    struct.add(VdsProperties.SpecParams, specParams);
    struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(XmlRpcStruct struct, VmDevice vmDevice, String path) {
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.<String, Object>emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.add(VdsProperties.Path, path);
    }
    struct.add(VdsProperties.SpecParams, specParams);
    struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#end_block

#method_before
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "");
        XmlRpcStruct struct = new XmlRpcStruct();
        struct.add(VdsProperties.Type, vmDevice.getType());
        struct.add(VdsProperties.Device, vmDevice.getDevice());
        addDevice(struct, vmDevice, null);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addDevice(struct, vmDevice, null);
            // only one memory balloon should exist
            break;
        }
    }
}
#method_after
@Override
protected void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<String, Object>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.NewGuid(), vm.getId()), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "");
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.BALLOON.getName(), VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getvm_name());
    createInfo.add(VdsProperties.mem_size_mb, vm.getvm_mem_size_mb());
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getnum_of_cpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getcpu_per_socket())));
    }
    if (Config.<Boolean>GetValue(ConfigValues.CpuPinningEnabled) && vm.getCpuPinning() != null) {
        createInfo.add(VdsProperties.cpuPinning, vm.getCpuPinning());
    }
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, vm.getvds_group_compatibility_version().toString()));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, vm.getvds_group_compatibility_version().toString()));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getkvm_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getacpi_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.getRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.getvds_group_cpu_flags_data() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getvds_group_cpu_flags_data());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getnice_level())).toString());
    if (vm.getstatus() == VMStatus.Suspended && !StringHelper.isNullOrEmpty(vm.gethibernation_vol_handle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.gethibernation_vol_handle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getvm_os().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getdisplay_type() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.getTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getvm_name());
    createInfo.add(VdsProperties.mem_size_mb, vm.getvm_mem_size_mb());
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getnum_of_cpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getcpu_per_socket())));
    }
    final String compatibilityVersion = vm.getvds_group_compatibility_version().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getkvm_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getacpi_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.getRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.getvds_group_cpu_flags_data() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getvds_group_cpu_flags_data());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getnice_level())).toString());
    if (vm.getstatus() == VMStatus.Suspended && !StringHelper.isNullOrEmpty(vm.gethibernation_vol_handle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.gethibernation_vol_handle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getvm_os().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getdisplay_type() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.getTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
protected List<Disk> getSortedDisks() {
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<Disk> diskImages = new ArrayList<Disk>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDriveMappingComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    return diskImages;
}
#method_after
protected List<Disk> getSortedDisks() {
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<Disk> diskImages = new ArrayList<Disk>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDiskAliasComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    return diskImages;
}
#end_block

#method_before
@Test
public void stringToCpuTune() {
    CpuTune cpuTune = VmMapper.stringToCpuTune("0#0");
    assertNotNull(cpuTune);
    assertNotNull(cpuTune.getVcpupin());
    assertEquals(1, cpuTune.getVcpupin().size());
    assertEquals(0, cpuTune.getVcpupin().get(0).getVcpu());
    assertEquals("0", cpuTune.getVcpupin().get(0).getCpuset());
}
#method_after
@Test
public void stringToCpuTune() {
    CpuTune cpuTune = VmMapper.stringToCpuTune("0#0");
    assertNotNull(cpuTune);
    assertNotNull(cpuTune.getVcpuPin());
    assertEquals(1, cpuTune.getVcpuPin().size());
    assertEquals(0, cpuTune.getVcpuPin().get(0).getVcpu());
    assertEquals("0", cpuTune.getVcpuPin().get(0).getCpuSet());
}
#end_block

#method_before
@Test()
public void stringToVCpupinIntervalsList() {
    VCpuPin pin = VmMapper.stringToVCpupin("1#1-4,6");
    assertEquals(1, pin.getVcpu());
    assertEquals("1-4,6", pin.getCpuset());
}
#method_after
@Test()
public void stringToVCpupinIntervalsList() {
    VCpuPin pin = VmMapper.stringToVCpupin("1#1-4,6");
    assertEquals(1, pin.getVcpu());
    assertEquals("1-4,6", pin.getCpuSet());
}
#end_block

#method_before
@Test()
public void stringToVCpupinSimple() {
    VCpuPin pin = VmMapper.stringToVCpupin("1#1");
    assertEquals(1, pin.getVcpu());
    assertEquals("1", pin.getCpuset());
}
#method_after
@Test()
public void stringToVCpupinSimple() {
    VCpuPin pin = VmMapper.stringToVCpupin("1#1");
    assertEquals(1, pin.getVcpu());
    assertEquals("1", pin.getCpuSet());
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetTopology()) {
        if (vm.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
        }
        if (vm.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowReconnect()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowReconnect());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetCputune()) {
        staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCputune()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetTopology()) {
        if (vm.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
        }
        if (vm.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowReconnect()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowReconnect());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetCpuTune()) {
        staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCputune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdisplay_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getdisplay_type(), null));
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowReconnect(entity.getAllowConsoleReconnect());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getelapsed_time() != null) {
        if (entity.getelapsed_time() == 0) {
            model.setStartTime(null);
        } else {
            model.setStartTime(DateMapper.map(new BigDecimal(entity.getelapsed_time()), null));
        }
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdisplay_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getdisplay_type(), null));
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowReconnect(entity.getAllowConsoleReconnect());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getelapsed_time() != null) {
        if (entity.getelapsed_time() == 0) {
            model.setStartTime(null);
        } else {
            model.setStartTime(DateMapper.map(new BigDecimal(entity.getelapsed_time()), null));
        }
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVcpupin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuset());
    }
    return builder.toString();
}
#method_after
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVcpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#end_block

#method_before
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVcpupin().add(pin);
    }
    return cpuTune;
}
#method_after
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVcpuPin().add(pin);
    }
    return cpuTune;
}
#end_block

#method_before
static VCpuPin stringToVCpupin(final String strCpu) {
    final String[] strPin = strCpu.split("#");
    if (strPin.length != 2) {
        throw new IllegalArgumentException("Bad format: " + strCpu);
    }
    final VCpuPin pin = new VCpuPin();
    try {
        pin.setVcpu(Integer.parseInt(strPin[0]));
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Bad format: " + strCpu, e);
    }
    if (strPin[1].matches("\\^?(\\d(\\-\\d)?)(,\\^?((\\d(\\-\\d)?)))*")) {
        pin.setCpuset(strPin[1]);
    } else {
        throw new IllegalArgumentException("Bad format: " + strPin[1]);
    }
    return pin;
}
#method_after
static VCpuPin stringToVCpupin(final String strCpu) {
    final String[] strPin = strCpu.split("#");
    if (strPin.length != 2) {
        throw new IllegalArgumentException("Bad format: " + strCpu);
    }
    final VCpuPin pin = new VCpuPin();
    try {
        pin.setVcpu(Integer.parseInt(strPin[0]));
    } catch (NumberFormatException e) {
        throw new IllegalArgumentException("Bad format: " + strCpu, e);
    }
    if (strPin[1].matches("\\^?(\\d(\\-\\d)?)(,\\^?((\\d(\\-\\d)?)))*")) {
        pin.setCpuSet(strPin[1]);
    } else {
        throw new IllegalArgumentException("Bad format: " + strPin[1]);
    }
    return pin;
}
#end_block

#method_before
public void WriteStartElement(String namespaceURI, String localName) {
    try {
        writer.writeStartElement(namespaceURI, localName);
    } catch (XMLStreamException e) {
        throw new RuntimeException("Failed to write start element", e);
    }
}
#method_after
public void WriteStartElement(String localName) {
    try {
        writer.writeStartElement(localName);
    } catch (XMLStreamException e) {
        throw new RuntimeException("Failed to write start element", e);
    }
}
#end_block

#method_before
public void writeElement(String namespaceUri, String name, String content) {
    WriteStartElement(namespaceUri, name);
    WriteRaw(content);
    WriteEndElement();
}
#method_after
public void writeElement(String name, String content) {
    WriteStartElement(name);
    WriteRaw(content);
    WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildReference() {
    _writer.WriteStartElement(OVF_URI, "References");
    for (DiskImage image : _images) {
        _writer.WriteStartElement(OVF_URI, "File");
        _writer.WriteAttributeString(OVF_URI, "href", OvfParser.CreateImageFile(image));
        _writer.WriteAttributeString(OVF_URI, "id", image.getImageId().toString());
        _writer.WriteAttributeString(OVF_URI, "size", (new Long(image.getsize())).toString());
        _writer.WriteAttributeString(OVF_URI, "description", StringUtils.defaultString(image.getdescription()));
        _writer.WriteEndElement();
    }
    for (VmNetworkInterface iface : vmBase.getInterfaces()) {
        _writer.WriteStartElement(OVF_URI, "Nic");
        _writer.WriteAttributeString(OVF_URI, "id", iface.getId().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#method_after
@Override
public void BuildReference() {
    _writer.WriteStartElement("References");
    for (DiskImage image : _images) {
        _writer.WriteStartElement("File");
        _writer.WriteAttributeString(OVF_URI, "href", OvfParser.CreateImageFile(image));
        _writer.WriteAttributeString(OVF_URI, "id", image.getImageId().toString());
        _writer.WriteAttributeString(OVF_URI, "size", String.valueOf(image.getsize()));
        _writer.WriteAttributeString(OVF_URI, "description", StringUtils.defaultString(image.getdescription()));
        _writer.WriteEndElement();
    }
    for (VmNetworkInterface iface : vmBase.getInterfaces()) {
        _writer.WriteStartElement("Nic");
        _writer.WriteAttributeString(OVF_URI, "id", iface.getId().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildNetwork() {
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":NetworkSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw("List of networks");
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Network");
    _writer.WriteAttributeString(OVF_URI, "name", "Network 1");
    _writer.WriteEndElement();
    _writer.WriteEndElement();
}
#method_after
@Override
public void BuildNetwork() {
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":NetworkSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw("List of networks");
    _writer.WriteEndElement();
    _writer.WriteStartElement("Network");
    _writer.WriteAttributeString(OVF_URI, "name", "Network 1");
    _writer.WriteEndElement();
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildDisk() {
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":DiskSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw("List of Virtual Disks");
    _writer.WriteEndElement();
    for (DiskImage image : _images) {
        _writer.WriteStartElement(OVF_URI, "Disk");
        _writer.WriteAttributeString(OVF_URI, "diskId", image.getImageId().toString());
        _writer.WriteAttributeString(OVF_URI, "size", String.valueOf(BytesToGigabyte(image.getsize())));
        _writer.WriteAttributeString(OVF_URI, "actual_size", String.valueOf(BytesToGigabyte(image.getactual_size())));
        _writer.WriteAttributeString(OVF_URI, "vm_snapshot_id", (image.getvm_snapshot_id() != null) ? image.getvm_snapshot_id().getValue().toString() : "");
        if (image.getParentId().equals(Guid.Empty)) {
            _writer.WriteAttributeString(OVF_URI, "parentRef", "");
        } else {
            int i = 0;
            while (_images.get(i).getImageId().equals(image.getParentId())) i++;
            List<DiskImage> res = _images.subList(i, _images.size() - 1);
            if (res.size() > 0) {
                _writer.WriteAttributeString(OVF_URI, "parentRef", OvfParser.CreateImageFile(res.get(0)));
            } else {
                _writer.WriteAttributeString(OVF_URI, "parentRef", "");
            }
        }
        _writer.WriteAttributeString(OVF_URI, "fileRef", OvfParser.CreateImageFile(image));
        String format = "";
        switch(image.getvolume_format()) {
            case RAW:
                format = "http://www.vmware.com/specifications/vmdk.html#sparse";
                break;
            case COW:
                format = "http://www.gnome.org/~markmc/qcow-image-format.html";
                break;
            case Unassigned:
                break;
        }
        _writer.WriteAttributeString(OVF_URI, "format", format);
        _writer.WriteAttributeString(OVF_URI, "volume-format", image.getvolume_format().toString());
        _writer.WriteAttributeString(OVF_URI, "volume-type", image.getvolume_type().toString());
        _writer.WriteAttributeString(OVF_URI, "disk-interface", image.getDiskInterface().toString());
        _writer.WriteAttributeString(OVF_URI, "boot", (new Boolean(image.isBoot())).toString());
        if (image.getDiskAlias() != null) {
            _writer.WriteAttributeString(OVF_URI, "disk-alias", image.getDiskAlias());
        }
        if (image.getDiskDescription() != null) {
            _writer.WriteAttributeString(OVF_URI, "disk-description", image.getDiskDescription());
        }
        _writer.WriteAttributeString(OVF_URI, "wipe-after-delete", (new Boolean(image.isWipeAfterDelete())).toString());
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#method_after
@Override
public void BuildDisk() {
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":DiskSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw("List of Virtual Disks");
    _writer.WriteEndElement();
    for (DiskImage image : _images) {
        _writer.WriteStartElement("Disk");
        _writer.WriteAttributeString(OVF_URI, "diskId", image.getImageId().toString());
        _writer.WriteAttributeString(OVF_URI, "size", String.valueOf(BytesToGigabyte(image.getsize())));
        _writer.WriteAttributeString(OVF_URI, "actual_size", String.valueOf(BytesToGigabyte(image.getactual_size())));
        _writer.WriteAttributeString(OVF_URI, "vm_snapshot_id", (image.getvm_snapshot_id() != null) ? image.getvm_snapshot_id().getValue().toString() : "");
        if (image.getParentId().equals(Guid.Empty)) {
            _writer.WriteAttributeString(OVF_URI, "parentRef", "");
        } else {
            int i = 0;
            while (_images.get(i).getImageId().equals(image.getParentId())) i++;
            List<DiskImage> res = _images.subList(i, _images.size() - 1);
            if (res.size() > 0) {
                _writer.WriteAttributeString(OVF_URI, "parentRef", OvfParser.CreateImageFile(res.get(0)));
            } else {
                _writer.WriteAttributeString(OVF_URI, "parentRef", "");
            }
        }
        _writer.WriteAttributeString(OVF_URI, "fileRef", OvfParser.CreateImageFile(image));
        String format = "";
        switch(image.getvolume_format()) {
            case RAW:
                format = "http://www.vmware.com/specifications/vmdk.html#sparse";
                break;
            case COW:
                format = "http://www.gnome.org/~markmc/qcow-image-format.html";
                break;
            case Unassigned:
                break;
        }
        _writer.WriteAttributeString(OVF_URI, "format", format);
        _writer.WriteAttributeString(OVF_URI, "volume-format", image.getvolume_format().toString());
        _writer.WriteAttributeString(OVF_URI, "volume-type", image.getvolume_type().toString());
        _writer.WriteAttributeString(OVF_URI, "disk-interface", image.getDiskInterface().toString());
        _writer.WriteAttributeString(OVF_URI, "boot", String.valueOf(image.isBoot()));
        if (image.getDiskAlias() != null) {
            _writer.WriteAttributeString(OVF_URI, "disk-alias", image.getDiskAlias());
        }
        if (image.getDiskDescription() != null) {
            _writer.WriteAttributeString(OVF_URI, "disk-description", image.getDiskDescription());
        }
        _writer.WriteAttributeString(OVF_URI, "wipe-after-delete", (new Boolean(image.isWipeAfterDelete())).toString());
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildVirtualSystem() {
    // General Vm
    _writer.WriteStartElement(OVF_URI, "Content");
    _writer.WriteAttributeString(OVF_URI, "id", "out");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":VirtualSystem_Type");
    // General Data
    WriteGeneralData();
    // Application List
    WriteAppList();
    // Content Items
    WriteContentItems();
    // End Content tag
    _writer.WriteEndElement();
}
#method_after
@Override
public void BuildVirtualSystem() {
    // General Vm
    _writer.WriteStartElement("Content");
    _writer.WriteAttributeString(OVF_URI, "id", "out");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":VirtualSystem_Type");
    // General Data
    WriteGeneralData();
    // Application List
    WriteAppList();
    // Content Items
    WriteContentItems();
    // End Content tag
    _writer.WriteEndElement();
}
#end_block

#method_before
protected void writeOtherDevices(VmBase vmBase, XmlTextWriter write) {
    List<VmDevice> devices = vmBase.getUnmanagedDeviceList();
    // sound cards are treated as managed devices but are exported using the OTHER OVF ResourceType
    Collection<VmDevice> managedDevices = vmBase.getManagedVmDeviceMap().values();
    for (VmDevice device : managedDevices) {
        if (VmDeviceType.SOUND.getName().equals(device.getType())) {
            devices.add(device);
        }
    }
    for (VmDevice vmDevice : devices) {
        _writer.WriteStartElement(OVF_URI, "Item");
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.OTHER);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw((String.valueOf(vmDevice.getId().getDeviceId())));
        _writer.WriteEndElement();
        writeVmDeviceInfo(vmDevice);
        // item
        _writer.WriteEndElement();
    }
}
#method_after
protected void writeOtherDevices(VmBase vmBase, XmlTextWriter write) {
    List<VmDevice> devices = vmBase.getUnmanagedDeviceList();
    Collection<VmDevice> managedDevices = vmBase.getManagedVmDeviceMap().values();
    for (VmDevice device : managedDevices) {
        if (VmDeviceCommonUtils.isSpecialDevice(device.getDevice(), device.getType())) {
            devices.add(device);
        }
    }
    for (VmDevice vmDevice : devices) {
        _writer.WriteStartElement("Item");
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.OTHER);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(vmDevice.getId().getDeviceId().toString());
        _writer.WriteEndElement();
        writeVmDeviceInfo(vmDevice);
        // item
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
protected void writeMonitors(VmBase vmBase) {
    Collection<VmDevice> devices = vmBase.getManagedVmDeviceMap().values();
    int numOfMonitors = vmBase.getnum_of_monitors();
    int i = 0;
    for (VmDevice vmDevice : devices) {
        if (vmDevice.getType().equals(VmDeviceType.VIDEO.getName())) {
            _writer.WriteStartElement(OVF_URI, "Item");
            _writer.WriteStartElement(RASD_URI, "Caption");
            _writer.WriteRaw("Graphical Controller");
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "InstanceId");
            _writer.WriteRaw((String.valueOf(vmDevice.getId().getDeviceId())));
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "ResourceType");
            _writer.WriteRaw(OvfHardware.Monitor);
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
            // we should write number of monitors for each entry for backward compatibility
            _writer.WriteRaw(String.valueOf(numOfMonitors));
            _writer.WriteEndElement();
            writeVmDeviceInfo(vmDevice);
            // item
            _writer.WriteEndElement();
            if (i++ == numOfMonitors) {
                break;
            }
        }
    }
}
#method_after
protected void writeMonitors(VmBase vmBase) {
    Collection<VmDevice> devices = vmBase.getManagedVmDeviceMap().values();
    int numOfMonitors = vmBase.getnum_of_monitors();
    int i = 0;
    for (VmDevice vmDevice : devices) {
        if (vmDevice.getType().equals(VmDeviceType.VIDEO.getName())) {
            _writer.WriteStartElement("Item");
            _writer.WriteStartElement(RASD_URI, "Caption");
            _writer.WriteRaw("Graphical Controller");
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "InstanceId");
            _writer.WriteRaw(vmDevice.getId().getDeviceId().toString());
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "ResourceType");
            _writer.WriteRaw(OvfHardware.Monitor);
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
            // we should write number of monitors for each entry for backward compatibility
            _writer.WriteRaw(String.valueOf(numOfMonitors));
            _writer.WriteEndElement();
            writeVmDeviceInfo(vmDevice);
            // item
            _writer.WriteEndElement();
            if (i++ == numOfMonitors) {
                break;
            }
        }
    }
}
#end_block

#method_before
protected void writeCd(VmBase vmBase) {
    Collection<VmDevice> devices = vmBase.getManagedVmDeviceMap().values();
    for (VmDevice vmDevice : devices) {
        if (vmDevice.getType().equals(VmDeviceType.CDROM.getName())) {
            _writer.WriteStartElement(OVF_URI, "Item");
            _writer.WriteStartElement(RASD_URI, "Caption");
            _writer.WriteRaw("CDROM");
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "InstanceId");
            _writer.WriteRaw((String.valueOf(vmDevice.getId().getDeviceId())));
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "ResourceType");
            _writer.WriteRaw(OvfHardware.CD);
            _writer.WriteEndElement();
            writeVmDeviceInfo(vmDevice);
            // item
            _writer.WriteEndElement();
            // only one CD is currently supported
            break;
        }
    }
}
#method_after
protected void writeCd(VmBase vmBase) {
    Collection<VmDevice> devices = vmBase.getManagedVmDeviceMap().values();
    for (VmDevice vmDevice : devices) {
        if (vmDevice.getType().equals(VmDeviceType.CDROM.getName())) {
            _writer.WriteStartElement("Item");
            _writer.WriteStartElement(RASD_URI, "Caption");
            _writer.WriteRaw("CDROM");
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "InstanceId");
            _writer.WriteRaw(vmDevice.getId().getDeviceId().toString());
            _writer.WriteEndElement();
            _writer.WriteStartElement(RASD_URI, "ResourceType");
            _writer.WriteRaw(OvfHardware.CD);
            _writer.WriteEndElement();
            writeVmDeviceInfo(vmDevice);
            // item
            _writer.WriteEndElement();
            // only one CD is currently supported
            break;
        }
    }
}
#end_block

#method_before
private void writeVmDeviceInfo(VmDevice vmDevice) {
    _writer.WriteStartElement(OVF_URI, "Type");
    _writer.WriteRaw(String.valueOf(vmDevice.getType()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Device");
    _writer.WriteRaw(String.valueOf(vmDevice.getDevice()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Address");
    _writer.WriteRaw(vmDevice.getAddress());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "BootOrder");
    _writer.WriteRaw(String.valueOf(vmDevice.getBootOrder()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsPlugged");
    _writer.WriteRaw(String.valueOf(vmDevice.getIsPlugged()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsReadOnly");
    _writer.WriteRaw(String.valueOf(vmDevice.getIsReadOnly()));
    _writer.WriteEndElement();
}
#method_after
private void writeVmDeviceInfo(VmDevice vmDevice) {
    _writer.WriteStartElement(OvfProperties.VMD_TYPE);
    _writer.WriteRaw(String.valueOf(vmDevice.getType()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_DEVICE);
    _writer.WriteRaw(String.valueOf(vmDevice.getDevice()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_ADDRESS);
    _writer.WriteRaw(vmDevice.getAddress());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_BOOT_ORDER);
    _writer.WriteRaw(String.valueOf(vmDevice.getBootOrder()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_IS_PLUGGED);
    _writer.WriteRaw(String.valueOf(vmDevice.getIsPlugged()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_IS_READONLY);
    _writer.WriteRaw(String.valueOf(vmDevice.getIsReadOnly()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.VMD_ALIAS);
    _writer.WriteRaw(String.valueOf(vmDevice.getAlias()));
    _writer.WriteEndElement();
    if (vmDevice.getSpecParams() != null && vmDevice.getSpecParams().size() != 0) {
        _writer.WriteStartElement(OvfProperties.VMD_SPEC_PARAMS);
        _writer.WriteMap(vmDevice.getSpecParams());
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
@Override
protected void WriteGeneralData() {
    _writer.WriteStartElement(OVF_URI, "Name");
    _writer.WriteRaw(_vmTemplate.getname());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Description");
    _writer.WriteRaw(_vmTemplate.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Domain");
    _writer.WriteRaw(_vmTemplate.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(_vmTemplate.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new java.util.Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "TimeZone");
    _writer.WriteRaw(_vmTemplate.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "VmType");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getvm_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getdefault_display_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "default_boot_sequence");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getinitrd_url())) {
        _writer.WriteStartElement(OVF_URI, "initrd_url");
        _writer.WriteRaw(_vmTemplate.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getkernel_url())) {
        _writer.WriteStartElement(OVF_URI, "kernel_url");
        _writer.WriteRaw(_vmTemplate.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getkernel_params())) {
        _writer.WriteStartElement(OVF_URI, "kernel_params");
        _writer.WriteRaw(_vmTemplate.getkernel_params());
        _writer.WriteEndElement();
    }
}
#method_after
@Override
protected void WriteGeneralData() {
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getname());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(_vmTemplate.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(_vmTemplate.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(_vmTemplate.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(_vmTemplate.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getorigin() == null ? "" : String.valueOf(_vmTemplate.getorigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getvm_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getdefault_display_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(_vmTemplate.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(_vmTemplate.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vmTemplate.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(_vmTemplate.getkernel_params());
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
@Override
protected void WriteContentItems() {
    // os
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(OVF_URI, "id", _vmTemplate.getId().toString());
    _writer.WriteAttributeString(OVF_URI, "required", "false");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":OperatingSystemSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw("Guest Operating System");
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Description");
    _writer.WriteRaw(_vmTemplate.getos().name());
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // hardware
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":VirtualHardwareSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw(String.format("%1$s CPU, %2$s Memeory", _vmTemplate.getnum_of_cpus(), _vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "System");
    _writer.WriteStartElement(VSSD_URI, "VirtualSystemType");
    _writer.WriteRaw(String.format("%1$s %2$s", Config.<String>GetValue(ConfigValues.OvfVirtualSystemType), Config.<String>GetValue(ConfigValues.VdcVersion)));
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // item cpu
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s virtual cpu", _vmTemplate.getnum_of_cpus()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Number of virtual CPU");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.CPU);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "num_of_sockets");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getnum_of_sockets()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "cpu_per_socket");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getcpu_per_socket()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item memory
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s MB of memory", _vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Memory Size");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.Memory);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "AllocationUnits");
    _writer.WriteRaw("MegaBytes");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item drive
    for (DiskImage image : _images) {
        _writer.WriteStartElement(OVF_URI, "Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw(String.format("Drive %1$d", image.getInternalDriveMapping()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(image.getImageId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.DiskImage);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "HostResource");
        _writer.WriteRaw(image.getId() + "/" + image.getImageId());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Parent");
        _writer.WriteRaw(image.getParentId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Template");
        _writer.WriteRaw(image.getit_guid().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ApplicationList");
        _writer.WriteRaw(image.getappList());
        _writer.WriteEndElement();
        if (image.getstorage_ids() != null && image.getstorage_ids().size() > 0) {
            _writer.WriteStartElement(RASD_URI, "StorageId");
            _writer.WriteRaw(image.getstorage_ids().get(0).toString());
            _writer.WriteEndElement();
        }
        if (image.getstorage_pool_id() != null) {
            _writer.WriteStartElement(RASD_URI, "StoragePoolId");
            _writer.WriteRaw(image.getstorage_pool_id().getValue().toString());
            _writer.WriteEndElement();
        }
        _writer.WriteStartElement(RASD_URI, "CreationDate");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getcreation_date()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "LastModified");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlastModified()));
        _writer.WriteEndElement();
        writeManagedDeviceInfo(_vmTemplate, _writer, image.getId());
        // item
        _writer.WriteEndElement();
    }
    // item network
    for (VmNetworkInterface iface : _vmTemplate.getInterfaces()) {
        _writer.WriteStartElement(OVF_URI, "Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw("Ethernet adapter on " + iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(iface.getId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.Network);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceSubType");
        if (iface.getType() != null) {
            _writer.WriteRaw(iface.getType().toString());
        }
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Connection");
        _writer.WriteRaw(iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Name");
        _writer.WriteRaw(iface.getName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "speed");
        // version prior to 2.3 may not have speed so we get it by type
        if (iface.getSpeed() != null) {
            _writer.WriteRaw(iface.getSpeed().toString());
        } else {
            _writer.WriteRaw(Integer.toString(VmInterfaceType.forValue(iface.getType()).getSpeed()));
        }
        _writer.WriteEndElement();
        writeManagedDeviceInfo(_vmTemplate, _writer, iface.getId());
        // item
        _writer.WriteEndElement();
    }
    // item usb
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw("USB Controller");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.USB);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "UsbPolicy");
    _writer.WriteRaw(_vmTemplate.getusb_policy().toString());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // monitors
    writeMonitors(_vmTemplate);
    // CD
    writeCd(_vmTemplate);
    // ummanged devices
    writeOtherDevices(_vmTemplate, _writer);
}
#method_after
@Override
protected void WriteContentItems() {
    // os
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(OVF_URI, "id", _vmTemplate.getId().toString());
    _writer.WriteAttributeString(OVF_URI, "required", "false");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":OperatingSystemSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw("Guest Operating System");
    _writer.WriteEndElement();
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(_vmTemplate.getos().name());
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // hardware
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(XSI_URI, "type", OVF_PREFIX + ":VirtualHardwareSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw(String.format("%1$s CPU, %2$s Memeory", _vmTemplate.getnum_of_cpus(), _vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("System");
    _writer.WriteStartElement(VSSD_URI, "VirtualSystemType");
    _writer.WriteRaw(String.format("%1$s %2$s", Config.<String>GetValue(ConfigValues.OvfVirtualSystemType), Config.<String>GetValue(ConfigValues.VdcVersion)));
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // item cpu
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s virtual cpu", _vmTemplate.getnum_of_cpus()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Number of virtual CPU");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.CPU);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "num_of_sockets");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getnum_of_sockets()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "cpu_per_socket");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getcpu_per_socket()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item memory
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s MB of memory", _vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Memory Size");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.Memory);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "AllocationUnits");
    _writer.WriteRaw("MegaBytes");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getmem_size_mb()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item drive
    for (DiskImage image : _images) {
        _writer.WriteStartElement("Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw(String.format("Drive %1$d", image.getInternalDriveMapping()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(image.getImageId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.DiskImage);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "HostResource");
        _writer.WriteRaw(image.getId() + "/" + image.getImageId());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Parent");
        _writer.WriteRaw(image.getParentId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Template");
        _writer.WriteRaw(image.getit_guid().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ApplicationList");
        _writer.WriteRaw(image.getappList());
        _writer.WriteEndElement();
        if (image.getstorage_ids() != null && image.getstorage_ids().size() > 0) {
            _writer.WriteStartElement(RASD_URI, "StorageId");
            _writer.WriteRaw(image.getstorage_ids().get(0).toString());
            _writer.WriteEndElement();
        }
        if (image.getstorage_pool_id() != null) {
            _writer.WriteStartElement(RASD_URI, "StoragePoolId");
            _writer.WriteRaw(image.getstorage_pool_id().getValue().toString());
            _writer.WriteEndElement();
        }
        _writer.WriteStartElement(RASD_URI, "CreationDate");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getcreation_date()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "LastModified");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlastModified()));
        _writer.WriteEndElement();
        writeManagedDeviceInfo(_vmTemplate, _writer, image.getId());
        // item
        _writer.WriteEndElement();
    }
    // item network
    for (VmNetworkInterface iface : _vmTemplate.getInterfaces()) {
        _writer.WriteStartElement("Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw("Ethernet adapter on " + iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(iface.getId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.Network);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceSubType");
        if (iface.getType() != null) {
            _writer.WriteRaw(iface.getType().toString());
        }
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Connection");
        _writer.WriteRaw(iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Name");
        _writer.WriteRaw(iface.getName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "speed");
        // version prior to 2.3 may not have speed so we get it by type
        if (iface.getSpeed() != null) {
            _writer.WriteRaw(iface.getSpeed().toString());
        } else {
            _writer.WriteRaw(String.valueOf(VmInterfaceType.forValue(iface.getType()).getSpeed()));
        }
        _writer.WriteEndElement();
        writeManagedDeviceInfo(_vmTemplate, _writer, iface.getId());
        // item
        _writer.WriteEndElement();
    }
    // item usb
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw("USB Controller");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.USB);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "UsbPolicy");
    _writer.WriteRaw((_vmTemplate.getusb_policy()) != null ? _vmTemplate.getusb_policy().toString() : UsbPolicy.DISABLED.name());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // monitors
    writeMonitors(_vmTemplate);
    // CD
    writeCd(_vmTemplate);
    // ummanged devices
    writeOtherDevices(_vmTemplate, _writer);
}
#end_block

#method_before
@Override
protected void WriteGeneralData() {
    _writer.WriteStartElement(OVF_URI, "Name");
    _writer.WriteRaw(_vm.getStaticData().getvm_name());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "TemplateId");
    _writer.WriteRaw(_vm.getStaticData().getvmt_guid().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "TemplateName");
    _writer.WriteRaw(_vm.getvmt_name().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new java.util.Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsInitilized");
    _writer.WriteRaw((new Boolean(_vm.getStaticData().getis_initialized())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsAutoSuspend");
    _writer.WriteRaw((new Boolean(vmBase.getis_auto_suspend())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "IsStateless");
    _writer.WriteRaw((new Boolean(vmBase.getis_stateless())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Origin");
    _writer.WriteRaw((new Integer(_vm.getorigin().getValue())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "default_boot_sequence");
    _writer.WriteRaw((new Integer(_vm.getdefault_boot_sequence().getValue())).toString());
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(_vm.getinitrd_url())) {
        _writer.WriteStartElement(OVF_URI, "initrd_url");
        _writer.WriteRaw(_vm.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getkernel_url())) {
        _writer.WriteStartElement(OVF_URI, "kernel_url");
        _writer.WriteRaw(_vm.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getkernel_params())) {
        _writer.WriteStartElement(OVF_URI, "kernel_params");
        _writer.WriteRaw(_vm.getkernel_params());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getapp_list())) {
        _writer.WriteStartElement(OVF_URI, "app_list");
        _writer.WriteRaw(_vm.getapp_list());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement(OVF_URI, "VmType");
    _writer.WriteRaw((new Integer(_vm.getvm_type().getValue())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "DefaultDisplayType");
    _writer.WriteRaw((new Integer(_vm.getdefault_display_type().getValue())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "MinAllocatedMem");
    _writer.WriteRaw((new Integer(_vm.getMinAllocatedMem())).toString());
    _writer.WriteEndElement();
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a map that its keys are aliases to fields that should be OVF
    // logged.
    Map<String, String> aliasesValuesMap = handler.getAliasesValuesMap();
    for (Map.Entry<String, String> entry : aliasesValuesMap.entrySet()) {
        writeLogEvent(entry.getKey(), entry.getValue());
    }
}
#method_after
@Override
protected void WriteGeneralData() {
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vm.getStaticData().getvm_name());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vm.getStaticData().getvmt_guid().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateName");
    _writer.WriteRaw(_vm.getvmt_name().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsInitilized");
    _writer.WriteRaw(String.valueOf(_vm.getStaticData().getis_initialized()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(vmBase.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsStateless");
    _writer.WriteRaw(String.valueOf(vmBase.getis_stateless()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(String.valueOf(_vm.getorigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(_vm.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(_vm.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(_vm.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(_vm.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(_vm.getkernel_params());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(_vm.getapp_list())) {
        _writer.WriteStartElement("app_list");
        _writer.WriteRaw(_vm.getapp_list());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(_vm.getvm_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DefaultDisplayType");
    _writer.WriteRaw(String.valueOf(_vm.getdefault_display_type().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("MinAllocatedMem");
    _writer.WriteRaw(String.valueOf(_vm.getMinAllocatedMem()));
    _writer.WriteEndElement();
    OvfLogEventHandler<VmStatic> handler = new VMStaticOvfLogHandler(_vm.getStaticData());
    // Gets a map that its keys are aliases to fields that should be OVF
    // logged.
    Map<String, String> aliasesValuesMap = handler.getAliasesValuesMap();
    for (Map.Entry<String, String> entry : aliasesValuesMap.entrySet()) {
        writeLogEvent(entry.getKey(), entry.getValue());
    }
}
#end_block

#method_before
private void writeLogEvent(String name, String value) {
    StringBuilder fullNameSB = new StringBuilder(EXPORT_ONLY_PREFIX);
    fullNameSB.append(name);
    _writer.WriteStartElement(OVF_URI, fullNameSB.toString());
    _writer.WriteRaw(value);
    _writer.WriteEndElement();
}
#method_after
private void writeLogEvent(String name, String value) {
    StringBuilder fullNameSB = new StringBuilder(EXPORT_ONLY_PREFIX);
    fullNameSB.append(name);
    _writer.WriteStartElement(fullNameSB.toString());
    _writer.WriteRaw(value);
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
protected void WriteAppList() {
    if (_images.size() > 0) {
        if (StringHelper.isNullOrEmpty(_images.get(0).getappList())) {
            return;
        }
        String[] apps = _images.get(0).getappList().split("[,]", -1);
        for (String app : apps) {
            String product = app;
            String version = "";
            Match match = Regex.Match(app, "(.*) ([0-9.]+)", RegexOptions.Singleline | RegexOptions.IgnoreCase);
            if (match.Groups().size() > 1) {
                // match.Groups[1].getValue();
                product = match.Groups().get(1).getValue();
            }
            if (match.Groups().size() > 2) {
                // match.Groups[2].getValue();
                version = match.Groups().get(2).getValue();
            }
            _writer.WriteStartElement(OVF_URI, "ProductSection");
            _writer.WriteAttributeString(OVF_URI, "class", product);
            _writer.WriteStartElement(OVF_URI, "Info");
            _writer.WriteRaw(app);
            _writer.WriteEndElement();
            _writer.WriteStartElement(OVF_URI, "Product");
            _writer.WriteRaw(product);
            _writer.WriteEndElement();
            _writer.WriteStartElement(OVF_URI, "Version");
            _writer.WriteRaw(version);
            _writer.WriteEndElement();
            _writer.WriteEndElement();
        }
    }
}
#method_after
@Override
protected void WriteAppList() {
    if (_images.size() > 0) {
        if (StringHelper.isNullOrEmpty(_images.get(0).getappList())) {
            return;
        }
        String[] apps = _images.get(0).getappList().split("[,]", -1);
        for (String app : apps) {
            String product = app;
            String version = "";
            Match match = Regex.Match(app, "(.*) ([0-9.]+)", RegexOptions.Singleline | RegexOptions.IgnoreCase);
            if (match.Groups().size() > 1) {
                // match.Groups[1].getValue();
                product = match.Groups().get(1).getValue();
            }
            if (match.Groups().size() > 2) {
                // match.Groups[2].getValue();
                version = match.Groups().get(2).getValue();
            }
            _writer.WriteStartElement("ProductSection");
            _writer.WriteAttributeString(OVF_URI, "class", product);
            _writer.WriteStartElement("Info");
            _writer.WriteRaw(app);
            _writer.WriteEndElement();
            _writer.WriteStartElement("Product");
            _writer.WriteRaw(product);
            _writer.WriteEndElement();
            _writer.WriteStartElement("Version");
            _writer.WriteRaw(version);
            _writer.WriteEndElement();
            _writer.WriteEndElement();
        }
    }
}
#end_block

#method_before
@Override
protected void WriteContentItems() {
    // os
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(OVF_URI, "id", vmBase.getId().toString());
    _writer.WriteAttributeString(OVF_URI, "required", "false");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:OperatingSystemSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw("Guest Operating System");
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "Description");
    _writer.WriteRaw(vmBase.getos().name());
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // hardware
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:VirtualHardwareSection_Type");
    _writer.WriteStartElement(OVF_URI, "Info");
    _writer.WriteRaw(String.format("%1$s CPU, %2$s Memeory", _vm.getStaticData().getnum_of_cpus(), _vm.getStaticData().getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OVF_URI, "System");
    _writer.WriteStartElement(VSSD_URI, "VirtualSystemType");
    _writer.WriteRaw(String.format("%1$s %2$s", Config.<String>GetValue(ConfigValues.OvfVirtualSystemType), Config.<String>GetValue(ConfigValues.VdcVersion)));
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // item cpu
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s virtual cpu", _vm.getStaticData().getnum_of_cpus()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Number of virtual CPU");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.CPU);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "num_of_sockets");
    _writer.WriteRaw((new Integer(vmBase.getnum_of_sockets())).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "cpu_per_socket");
    _writer.WriteRaw((new Integer(vmBase.getcpu_per_socket())).toString());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item memory
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s MB of memory", vmBase.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Memory Size");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.Memory);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "AllocationUnits");
    _writer.WriteRaw("MegaBytes");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
    _writer.WriteRaw((new Integer(vmBase.getmem_size_mb())).toString());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item drive
    for (DiskImage image : _images) {
        _writer.WriteStartElement(OVF_URI, "Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw(String.format("Drive %1$d", image.getInternalDriveMapping()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(image.getImageId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.DiskImage);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "HostResource");
        _writer.WriteRaw(OvfParser.CreateImageFile(image));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Parent");
        _writer.WriteRaw(image.getParentId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Template");
        _writer.WriteRaw(image.getit_guid().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ApplicationList");
        _writer.WriteRaw(image.getappList());
        _writer.WriteEndElement();
        if (image.getstorage_ids() != null && image.getstorage_ids().size() > 0) {
            _writer.WriteStartElement(RASD_URI, "StorageId");
            _writer.WriteRaw(image.getstorage_ids().get(0).toString());
            _writer.WriteEndElement();
        }
        if (image.getstorage_pool_id() != null) {
            _writer.WriteStartElement(RASD_URI, "StoragePoolId");
            _writer.WriteRaw(image.getstorage_pool_id().getValue().toString());
            _writer.WriteEndElement();
        }
        _writer.WriteStartElement(RASD_URI, "CreationDate");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getcreation_date()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "LastModified");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlastModified()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "last_modified_date");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlast_modified_date()));
        _writer.WriteEndElement();
        writeManagedDeviceInfo(vmBase, _writer, image.getId());
        // item
        _writer.WriteEndElement();
    }
    // item network
    for (VmNetworkInterface iface : _vm.getInterfaces()) {
        _writer.WriteStartElement(OVF_URI, "Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw("Ethernet adapter on " + iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(iface.getId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.Network);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceSubType");
        if (iface.getType() != null) {
            _writer.WriteRaw(iface.getType().toString());
        }
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Connection");
        _writer.WriteRaw(iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Name");
        _writer.WriteRaw(iface.getName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "MACAddress");
        _writer.WriteRaw(iface.getMacAddress());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "speed");
        // version prior to 2.3 may not have speed so we get it by type
        if (iface.getSpeed() != null) {
            _writer.WriteRaw(iface.getSpeed().toString());
        } else {
            _writer.WriteRaw(Integer.toString(VmInterfaceType.forValue(iface.getType()).getSpeed()));
        }
        _writer.WriteEndElement();
        writeManagedDeviceInfo(vmBase, _writer, iface.getId());
        // item
        _writer.WriteEndElement();
    }
    // item usb
    _writer.WriteStartElement(OVF_URI, "Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw("USB Controller");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(((Integer) (++_instanceId)).toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.USB);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "UsbPolicy");
    _writer.WriteRaw(vmBase.getusb_policy().toString());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // monitors
    writeMonitors(vmBase);
    // CD
    writeCd(vmBase);
    // ummanged devices
    writeOtherDevices(vmBase, _writer);
    // End hardware section
    _writer.WriteEndElement();
    writeSnapshotsSection();
}
#method_after
@Override
protected void WriteContentItems() {
    // os
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(OVF_URI, "id", vmBase.getId().toString());
    _writer.WriteAttributeString(OVF_URI, "required", "false");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:OperatingSystemSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw("Guest Operating System");
    _writer.WriteEndElement();
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getos().name());
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // hardware
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:VirtualHardwareSection_Type");
    _writer.WriteStartElement("Info");
    _writer.WriteRaw(String.format("%1$s CPU, %2$s Memeory", _vm.getStaticData().getnum_of_cpus(), _vm.getStaticData().getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("System");
    _writer.WriteStartElement(VSSD_URI, "VirtualSystemType");
    _writer.WriteRaw(String.format("%1$s %2$s", Config.<String>GetValue(ConfigValues.OvfVirtualSystemType), Config.<String>GetValue(ConfigValues.VdcVersion)));
    _writer.WriteEndElement();
    _writer.WriteEndElement();
    // item cpu
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s virtual cpu", _vm.getStaticData().getnum_of_cpus()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Number of virtual CPU");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.CPU);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "num_of_sockets");
    _writer.WriteRaw(String.valueOf(vmBase.getnum_of_sockets()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "cpu_per_socket");
    _writer.WriteRaw(String.valueOf(vmBase.getcpu_per_socket()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item memory
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw(String.format("%1$s MB of memory", vmBase.getmem_size_mb()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "Description");
    _writer.WriteRaw("Memory Size");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.Memory);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "AllocationUnits");
    _writer.WriteRaw("MegaBytes");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "VirtualQuantity");
    _writer.WriteRaw(String.valueOf(vmBase.getmem_size_mb()));
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // item drive
    for (DiskImage image : _images) {
        _writer.WriteStartElement("Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw(String.format("Drive %1$d", image.getInternalDriveMapping()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(image.getImageId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.DiskImage);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "HostResource");
        _writer.WriteRaw(OvfParser.CreateImageFile(image));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Parent");
        _writer.WriteRaw(image.getParentId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Template");
        _writer.WriteRaw(image.getit_guid().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ApplicationList");
        _writer.WriteRaw(image.getappList());
        _writer.WriteEndElement();
        if (image.getstorage_ids() != null && image.getstorage_ids().size() > 0) {
            _writer.WriteStartElement(RASD_URI, "StorageId");
            _writer.WriteRaw(image.getstorage_ids().get(0).toString());
            _writer.WriteEndElement();
        }
        if (image.getstorage_pool_id() != null) {
            _writer.WriteStartElement(RASD_URI, "StoragePoolId");
            _writer.WriteRaw(image.getstorage_pool_id().getValue().toString());
            _writer.WriteEndElement();
        }
        _writer.WriteStartElement(RASD_URI, "CreationDate");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getcreation_date()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "LastModified");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlastModified()));
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "last_modified_date");
        _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(image.getlast_modified_date()));
        _writer.WriteEndElement();
        writeManagedDeviceInfo(vmBase, _writer, image.getId());
        // item
        _writer.WriteEndElement();
    }
    // item network
    for (VmNetworkInterface iface : _vm.getInterfaces()) {
        _writer.WriteStartElement("Item");
        _writer.WriteStartElement(RASD_URI, "Caption");
        _writer.WriteRaw("Ethernet adapter on " + iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "InstanceId");
        _writer.WriteRaw(iface.getId().toString());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceType");
        _writer.WriteRaw(OvfHardware.Network);
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "ResourceSubType");
        if (iface.getType() != null) {
            _writer.WriteRaw(iface.getType().toString());
        }
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Connection");
        _writer.WriteRaw(iface.getNetworkName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "Name");
        _writer.WriteRaw(iface.getName());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "MACAddress");
        _writer.WriteRaw(iface.getMacAddress());
        _writer.WriteEndElement();
        _writer.WriteStartElement(RASD_URI, "speed");
        // version prior to 2.3 may not have speed so we get it by type
        if (iface.getSpeed() != null) {
            _writer.WriteRaw(iface.getSpeed().toString());
        } else {
            _writer.WriteRaw(String.valueOf(VmInterfaceType.forValue(iface.getType()).getSpeed()));
        }
        _writer.WriteEndElement();
        writeManagedDeviceInfo(vmBase, _writer, iface.getId());
        // item
        _writer.WriteEndElement();
    }
    // item usb
    _writer.WriteStartElement("Item");
    _writer.WriteStartElement(RASD_URI, "Caption");
    _writer.WriteRaw("USB Controller");
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "InstanceId");
    _writer.WriteRaw(String.valueOf(++_instanceId));
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "ResourceType");
    _writer.WriteRaw(OvfHardware.USB);
    _writer.WriteEndElement();
    _writer.WriteStartElement(RASD_URI, "UsbPolicy");
    _writer.WriteRaw(vmBase.getusb_policy() != null ? vmBase.getusb_policy().toString() : UsbPolicy.DISABLED.name());
    _writer.WriteEndElement();
    // item
    _writer.WriteEndElement();
    // monitors
    writeMonitors(vmBase);
    // CD
    writeCd(vmBase);
    // ummanged devices
    writeOtherDevices(vmBase, _writer);
    // End hardware section
    _writer.WriteEndElement();
    writeSnapshotsSection();
}
#end_block

#method_before
private void writeSnapshotsSection() {
    List<Snapshot> snapshots = _vm.getSnapshots();
    if (snapshots == null || snapshots.isEmpty()) {
        return;
    }
    _writer.WriteStartElement(OVF_URI, "Section");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:SnapshotsSection_Type");
    for (Snapshot snapshot : snapshots) {
        _writer.WriteStartElement(OVF_URI, "Snapshot");
        _writer.WriteAttributeString(OVF_URI, "id", snapshot.getId().toString());
        _writer.writeElement(OVF_URI, "Type", snapshot.getType().name());
        _writer.writeElement(OVF_URI, "Description", snapshot.getDescription());
        _writer.writeElement(OVF_URI, "CreationDate", OvfParser.LocalDateToUtcDateString(snapshot.getCreationDate()));
        if (snapshot.getAppList() != null) {
            _writer.writeElement(OVF_URI, "ApplicationList", snapshot.getAppList());
        }
        if (snapshot.getVmConfiguration() != null) {
            _writer.writeElement(OVF_URI, "VmConfiguration", Base64.encodeBase64String(snapshot.getVmConfiguration().getBytes()));
        }
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#method_after
private void writeSnapshotsSection() {
    List<Snapshot> snapshots = _vm.getSnapshots();
    if (snapshots == null || snapshots.isEmpty()) {
        return;
    }
    _writer.WriteStartElement("Section");
    _writer.WriteAttributeString(XSI_URI, "type", "ovf:SnapshotsSection_Type");
    for (Snapshot snapshot : snapshots) {
        _writer.WriteStartElement("Snapshot");
        _writer.WriteAttributeString(OVF_URI, "id", snapshot.getId().toString());
        _writer.writeElement("Type", snapshot.getType().name());
        _writer.writeElement("Description", snapshot.getDescription());
        _writer.writeElement("CreationDate", OvfParser.LocalDateToUtcDateString(snapshot.getCreationDate()));
        if (snapshot.getAppList() != null) {
            _writer.writeElement("ApplicationList", snapshot.getAppList());
        }
        if (snapshot.getVmConfiguration() != null) {
            _writer.writeElement("VmConfiguration", Base64.encodeBase64String(snapshot.getVmConfiguration().getBytes()));
        }
        _writer.WriteEndElement();
    }
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterAddHostFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterHostRemoveFailed:
        case GlusterAddHostFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Gluster Host add
        if (getAllVds(getVdsGroupId()).size() > 0) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(getUpServer().getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // only on non vds installation mode.
        if (getVdsGroup().supportsGlusterService() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(getUpServer().getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringHelper.isNullOrEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_IS_UP);
        if (getAllVds(getVdsGroupId()).size() > 0 && getUpServer() == null) {
            returnValue = false;
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringHelper.isNullOrEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getAllVds(getVdsGroupId()).size() > 0 && getUpServer() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
            returnValue = false;
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

#method_before
@Override
public FutureTask<Map<String, Object>> poll() {
    return vdsServer.futureGetCapabilities();
}
#method_after
@Override
public FutureTask<Map<String, Object>> poll() {
    return vdsServer.futurePing();
}
#end_block

#method_before
private void glusterHostRemove() {
    // UI will implement forceAction later
    // Now assume that the force option is false
    boolean forceAction = false;
    if (isGlusterEnabled() && getVdsDAO().getAll().size() > 1 && !hasVolumeOnServer()) {
        String hostName = getVdsDAO().get(getParameters().getVdsId()).gethost_name();
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((ClusterUtils.getInstance().getUpServer(getVdsGroupId())).getId(), hostName, forceAction));
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
        }
    }
}
#method_after
private void glusterHostRemove() {
    // UI will implement forceAction later
    // Now assume that the force option is false
    boolean forceAction = false;
    if (isGlusterEnabled() && getVdsDAO().getAll().size() > 1 && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((ClusterUtils.getInstance().getUpServer(getVdsGroupId())).getId(), getVds().gethost_name(), forceAction));
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
        }
    }
}
#end_block

#method_before
@Override
public Response replace(Action action) {
    validateParameters(action, "newBrick.serverId", "newBrick.brickDir");
    Mapper<GlusterBrick, GlusterBrickEntity> mapper = getMapper(GlusterBrick.class, GlusterBrickEntity.class);
    return doAction(VdcActionType.ReplaceGlusterVolumeBrick, new GlusterVolumeReplaceBrickActionParameters(asGuid(getVolumeId()), GlusterTaskOperation.START, mapper.map(get(), null), mapper.map(action.getNewBrick(), null), action.isSetForce() ? action.isForce() : false), action);
}
#method_after
@Override
public Response replace(Action action) {
    validateParameters(action, "newBrick.serverId", "newBrick.brickDir");
    Mapper<GlusterBrick, GlusterBrickEntity> mapper = getMapper(GlusterBrick.class, GlusterBrickEntity.class);
    return doAction(VdcActionType.ReplaceGlusterVolumeBrick, new GlusterVolumeReplaceBrickActionParameters(asGuid(getVolumeId()), GlusterTaskOperation.START, mapper.map(get(), null), mapper.map(action.getBrick(), null), action.isSetForce() ? action.isForce() : false), action);
}
#end_block

#method_before
@Override
public GlusterVolume get() {
    return performGet(VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(guid));
}
#method_after
@Override
public GlusterVolume get() {
    return performGet(VdcQueryType.GetGlusterVolumeById, new GetGlusterVolumeByIdQueryParameters(guid));
}
#end_block

#method_before
@Test
public void testReplace() throws Exception {
    setupParentExpectations();
    setUpGetEntityExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.ReplaceGlusterVolumeBrick, GlusterVolumeReplaceBrickActionParameters.class, new String[] { "VolumeId", "NewBrick.ServerId", "NewBrick.BrickDirectory" }, new Object[] { volumeId, serverId, brickDir }));
    resource.setParent(bricksResourceMock);
    Action action = new Action();
    action.setNewBrick(new GlusterBrick());
    action.getNewBrick().setServerId(serverId.toString());
    action.getNewBrick().setBrickDir(brickDir);
    verifyActionResponse(resource.replace(action));
}
#method_after
@Test
public void testReplace() throws Exception {
    setupParentExpectations();
    setUpGetEntityExpectations(1);
    setUriInfo(setUpActionExpectations(VdcActionType.ReplaceGlusterVolumeBrick, GlusterVolumeReplaceBrickActionParameters.class, new String[] { "VolumeId", "NewBrick.ServerId", "NewBrick.BrickDirectory" }, new Object[] { volumeId, serverId, brickDir }));
    resource.setParent(bricksResourceMock);
    Action action = new Action();
    action.setBrick(new GlusterBrick());
    action.getBrick().setServerId(serverId.toString());
    action.getBrick().setBrickDir(brickDir);
    verifyActionResponse(resource.replace(action));
}
#end_block

#method_before
protected void prepareRoleForCommand() {
    // Note that the role is take from the parameters
    roles role = getRole();
    role.setId(Guid.NewGuid());
    role.setInheritable(false);
    for (ActionGroup group : getParameters().getActionGroups()) {
        if (group.isInheritable()) {
            role.setInheritable(true);
            break;
        }
    }
}
#method_after
protected void prepareRoleForCommand() {
    // Note that the role is take from the parameters
    roles role = getRole();
    role.setId(Guid.NewGuid());
    role.setAllowsViewingChildren(false);
    for (ActionGroup group : getParameters().getActionGroups()) {
        if (group.allowsViewingChildren()) {
            role.setAllowsViewingChildren(true);
            break;
        }
    }
}
#end_block

#method_before
/* execute related tests */
@Test
public void testExecuteCommandNoUpdate() {
    mockRoleGroups(ActionGroup.CONFIGURE_HOST_NETWORK);
    getRole().setInheritable(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, false);
}
#method_after
/* execute related tests */
@Test
public void testExecuteCommandNoUpdate() {
    mockRoleGroups(ActionGroup.CONFIGURE_HOST_NETWORK);
    getRole().setAllowsViewingChildren(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, false);
}
#end_block

#method_before
@Test
public void testExecuteCommandNoUpdateSinceRoleWasAlreadyNotInheritable() {
    getRole().setInheritable(false);
    getCommand().executeCommand();
    verifyRoleSaving(false, false);
}
#method_after
@Test
public void testExecuteCommandNoUpdateSinceRoleWasAlreadyNotInheritable() {
    getRole().setAllowsViewingChildren(false);
    getCommand().executeCommand();
    verifyRoleSaving(false, false);
}
#end_block

#method_before
@Test
public void testExecuteCommandWithUpdateAllRolesRemoved() {
    mockRoleGroups();
    getRole().setInheritable(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, true);
}
#method_after
@Test
public void testExecuteCommandWithUpdateAllRolesRemoved() {
    mockRoleGroups();
    getRole().setAllowsViewingChildren(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, true);
}
#end_block

#method_before
@Test
public void testExecuteCommandWithUpdateInheritableRolesRemoved() {
    mockRoleGroups(ActionGroup.CREATE_VM);
    getRole().setInheritable(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, true);
}
#method_after
@Test
public void testExecuteCommandWithUpdateInheritableRolesRemoved() {
    mockRoleGroups(ActionGroup.CREATE_VM);
    getRole().setAllowsViewingChildren(true);
    getCommand().executeCommand();
    verifyRoleSaving(true, true);
}
#end_block

#method_before
@Test
public void testPrepareRoleForCommandNoGroups() {
    command.prepareRoleForCommand();
    assertEquals("Wrong inheritable state for command", shouldBeInheritable, params.getRole().isInheritable());
}
#method_after
@Test
public void testPrepareRoleForCommandNoGroups() {
    command.prepareRoleForCommand();
    assertEquals("Wrong inheritable state for command", shouldBeInheritable, params.getRole().allowsViewingChildren());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getRole().setId(Guid.NewGuid());
    getRole().setInheritable(false);
    getRoleDao().save(getRole());
    getReturnValue().setActionReturnValue(getRole().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getRole().setId(Guid.NewGuid());
    getRole().setAllowsViewingChildren(false);
    getRoleDao().save(getRole());
    getReturnValue().setActionReturnValue(getRole().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // If the role is already inheritable, adding more action groups won't make it stop being inheritable
    boolean addedInheritableGroup = false;
    List<ActionGroup> groups = getParameters().getActionGroups();
    for (ActionGroup group : groups) {
        addedInheritableGroup |= group.isInheritable();
        getRoleGroupMapDAO().save(new RoleGroupMap(group, getParameters().getRoleId()));
        AppendCustomValue("ActionGroup", group.toString(), ", ");
    }
    // Only adding inheritable groups could make a role inheritable
    if (addedInheritableGroup) {
        roles role = getRole();
        // The role should be updated only if it wasn't inheritable in the first place
        if (!role.isInheritable()) {
            role.setInheritable(true);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    boolean addedGroupThatAllowsViewingChildren = false;
    List<ActionGroup> groups = getParameters().getActionGroups();
    for (ActionGroup group : groups) {
        addedGroupThatAllowsViewingChildren |= group.allowsViewingChildren();
        getRoleGroupMapDAO().save(new RoleGroupMap(group, getParameters().getRoleId()));
        AppendCustomValue("ActionGroup", group.toString(), ", ");
    }
    // Only adding groups that allow viewing children could make a role allow viewing its children
    if (addedGroupThatAllowsViewingChildren) {
        roles role = getRole();
        // The role should be updated only if it didn't allow viewing children in the first place
        if (!role.allowsViewingChildren()) {
            role.setAllowsViewingChildren(true);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    for (ActionGroup group : groupsToDetach) {
        getRoleGroupMapDAO().remove(group, getParameters().getRoleId());
        AppendCustomValue("ActionGroup", group.toString(), ", ");
    }
    // If the role wasn't inheritable in the first place, removing action groups won't change that
    roles role = getRole();
    if (role.isInheritable()) {
        boolean shouldBeInheritable = false;
        // Go over all the REMAINING action groups
        List<ActionGroup> groups = getActionGroupsByRoleId(role.getId());
        for (ActionGroup group : groups) {
            if (group.isInheritable()) {
                shouldBeInheritable = true;
                break;
            }
        }
        if (!shouldBeInheritable) {
            role.setInheritable(false);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    for (ActionGroup group : groupsToDetach) {
        getRoleGroupMapDAO().remove(group, getParameters().getRoleId());
        AppendCustomValue("ActionGroup", group.toString(), ", ");
    }
    // If the role didn't allow viewing children in the first place, removing action groups won't change that
    roles role = getRole();
    if (role.allowsViewingChildren()) {
        boolean shouldAllowViewingChildren = false;
        // Go over all the REMAINING action groups
        List<ActionGroup> groups = getActionGroupsByRoleId(role.getId());
        for (ActionGroup group : groups) {
            if (group.allowsViewingChildren()) {
                shouldAllowViewingChildren = true;
                break;
            }
        }
        if (!shouldAllowViewingChildren) {
            role.setAllowsViewingChildren(false);
            getRoleDao().update(role);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
/* execute related tests */
@Test
public void testExecuteCommandNoUpdate() {
    getRole().setInheritable(true);
    getCommand().executeCommand();
    verifyRoleSaving(false);
}
#method_after
/* execute related tests */
@Test
public void testExecuteCommandNoUpdate() {
    getRole().setAllowsViewingChildren(true);
    getCommand().executeCommand();
    verifyRoleSaving(false);
}
#end_block

#method_before
@Test
public void testExecuteCommandWithUpdate() {
    getRole().setInheritable(false);
    getCommand().executeCommand();
    verifyRoleSaving(true);
}
#method_after
@Test
public void testExecuteCommandWithUpdate() {
    getRole().setAllowsViewingChildren(false);
    getCommand().executeCommand();
    verifyRoleSaving(true);
}
#end_block

#method_before
@Test
public void testExecuteCommandNoUpdateNonInheritableRole() {
    getRole().setInheritable(false);
    getParams().setActionGroups(new ArrayList<ActionGroup>(Collections.singletonList(ActionGroup.CREATE_VM)));
    getCommand().executeCommand();
    verifyRoleSaving(false);
}
#method_after
@Test
public void testExecuteCommandNoUpdateNonInheritableRole() {
    getRole().setAllowsViewingChildren(false);
    getParams().setActionGroups(new ArrayList<ActionGroup>(Collections.singletonList(ActionGroup.CREATE_VM)));
    getCommand().executeCommand();
    verifyRoleSaving(false);
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    VdsActionParameters parameters = createParameters();
    command = spy(new RemoveVdsCommand<VdsActionParameters>(parameters));
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterVolumeDao).when(command).getGlusterVolumeDao();
    doReturn(vdsGroupDAO).when(command).getVdsGroupDAO();
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    VdsActionParameters parameters = createParameters();
    command = spy(new RemoveVdsCommand<VdsActionParameters>(parameters));
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterBrickDao).when(command).getGlusterBrickDao();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsGroup).when(vdsGroupDao).get(Mockito.any(Guid.class));
}
#end_block

#method_before
@Test
public void canDoActionSucceeds() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockVmsPinnedToHost(Collections.<String>emptyList());
    mockIsGlusterEnabled(false);
    mockHasVolumeOnServer(0);
    runAndAssertCanDoActionSuccess();
}
#method_after
@Test
public void canDoActionSucceeds() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockVmsPinnedToHost(Collections.<String>emptyList());
    mockIsGlusterEnabled(false);
    mockHasVolumeOnServer(false);
    runAndAssertCanDoActionSuccess();
}
#end_block

#method_before
@Test
public void canDoActionFailsWhenGlusterHostHasVolumes() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockVmsPinnedToHost(Collections.<String>emptyList());
    mockIsGlusterEnabled(true);
    mockHasVolumeOnServer(3);
    boolean canDoAction = command.canDoAction();
    System.out.println(command.getReturnValue().getCanDoActionMessages());
    assertFalse(canDoAction);
}
#method_after
@Test
public void canDoActionFailsWhenGlusterHostHasVolumes() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockVmsPinnedToHost(Collections.<String>emptyList());
    mockIsGlusterEnabled(true);
    mockHasVolumeOnServer(true);
    boolean canDoAction = command.canDoAction();
    System.out.println(command.getReturnValue().getCanDoActionMessages());
    assertFalse(canDoAction);
}
#end_block

#method_before
@Test
public void canDoActionFailsWhenVMsPinnedToHost() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockIsGlusterEnabled(true);
    mockHasVolumeOnServer(2);
    String vmName = "abc";
    mockVmsPinnedToHost(Arrays.asList(vmName));
    ArrayList<String> messages = runAndAssertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_PINNED_VMS);
    boolean foundMessage = false;
    for (String message : messages) {
        foundMessage |= message.contains(vmName);
    }
    assertTrue("Can't find VM name in can do action messages", foundMessage);
}
#method_after
@Test
public void canDoActionFailsWhenVMsPinnedToHost() throws Exception {
    mockVdsWithStatus(VDSStatus.Maintenance);
    mockVdsDynamic();
    mockIsGlusterEnabled(true);
    mockHasVolumeOnServer(true);
    String vmName = "abc";
    mockVmsPinnedToHost(Arrays.asList(vmName));
    ArrayList<String> messages = runAndAssertCanDoActionFailure(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_PINNED_VMS);
    boolean foundMessage = false;
    for (String message : messages) {
        foundMessage |= message.contains(vmName);
    }
    assertTrue("Can't find VM name in can do action messages", foundMessage);
}
#end_block

#method_before
private void mockIsGlusterEnabled(boolean glusterService) {
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setGlusterService(glusterService);
    when(vdsGroupDAO.get(command.getVdsGroupId())).thenReturn(vdsGroup);
}
#method_after
private void mockIsGlusterEnabled(boolean glusterService) {
    when(vdsGroup.supportsGlusterService()).thenReturn(glusterService);
}
#end_block

#method_before
private void mockHasVolumeOnServer(int volumeCount) {
    when(glusterVolumeDao.getBrickCountByServerId(command.getVdsId())).thenReturn(volumeCount);
}
#method_after
private void mockHasVolumeOnServer(boolean isBricksRequired) {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    if (isBricksRequired) {
        GlusterBrickEntity brick = new GlusterBrickEntity();
        brick.setVolumeId(new Guid());
        brick.setServerId(command.getVdsId());
        bricks.add(brick);
    }
    when(glusterBrickDao.getGlusterVolumeBricksByServerId(command.getVdsId())).thenReturn(bricks);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = CanRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    storage_pool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
            returnValue = false;
        }
    }
    if (isGlusterEnabled() && hasVolumeOnServer()) {
        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
        return false;
    }
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = CanRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    storage_pool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
            returnValue = false;
        }
    }
    if (isGlusterEnabled() && hasVolumeOnServer()) {
        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
        returnValue = false;
    }
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    return returnValue;
}
#end_block

#method_before
private void RemoveVdsFromCollection() {
    // ResourceManager.Instance.removeVds(VdsId);
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId()));
    if (!returnValue.getSucceeded()) {
        errorType = AuditLogType.USER_FAILED_REMOVE_VDS;
    }
}
#method_after
private void RemoveVdsFromCollection() {
    // ResourceManager.Instance.removeVds(VdsId);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(getVdsId()));
}
#end_block

#method_before
private boolean isGlusterEnabled() {
    VDSGroup vdsGroup = getVdsGroupDAO().get(getVdsGroupId());
    return (vdsGroup.supportsGlusterService());
}
#method_after
private boolean isGlusterEnabled() {
    return (getVdsGroup().supportsGlusterService());
}
#end_block

#method_before
private boolean hasVolumeOnServer() {
    if (getGlusterVolumeDao().getBrickCountByServerId(getVdsId()) > 0) {
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean hasVolumeOnServer() {
    if (getGlusterBrickDao().getGlusterVolumeBricksByServerId(getVdsId()).size() > 0) {
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private void glusterHostRemove() {
    // UI will implement forceAction later
    // Now assume that the force option is false
    boolean forceAction = false;
    if (getVdsDAO().getAll().size() > 1) {
        if (isGlusterEnabled() && !hasVolumeOnServer()) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((ClusterUtils.getInstance().getUpServer(getVdsGroupId())).getId(), getVdsName(), forceAction));
            setSucceeded(returnValue.getSucceeded());
            if (!returnValue.getSucceeded()) {
                errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
            }
        }
    }
}
#method_after
private void glusterHostRemove() {
    // UI will implement forceAction later
    // Now assume that the force option is false
    boolean forceAction = false;
    if (isGlusterEnabled() && getVdsDAO().getAll().size() > 1 && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters((ClusterUtils.getInstance().getUpServer(getVdsGroupId())).getId(), getVdsName(), forceAction));
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<ActionGroup> attachGroups = getParameters().getActionGroups();
    Guid roleId = getParameters().getRoleId();
    roles role = getRoleDao().get(roleId);
    List<String> canDoMessages = getReturnValue().getCanDoActionMessages();
    if (CheckIfRoleIsReadOnly(canDoMessages)) {
        canDoMessages.add(VdcBllMessages.VAR__TYPE__ROLE.toString());
        canDoMessages.add(VdcBllMessages.VAR__ACTION__ATTACH_ACTION_TO.toString());
        return false;
    }
    // Get all groups by ID and check if they already exist
    List<ActionGroup> allGroups = getActionGroupsByRoleId(roleId);
    for (ActionGroup group : attachGroups) {
        if (allGroups.contains(group)) {
            // group already exist
            canDoMessages.add(VdcBllMessages.ERROR_CANNOT_ATTACH_ACTION_GROUP_TO_ROLE_ATTACHED.toString());
            return false;
        } else if (role.getType() != RoleType.ADMIN && group.getRoleType() == RoleType.ADMIN) {
            canDoMessages.add(VdcBllMessages.CANNOT_ADD_ACTION_GROUPS_TO_ROLE_TYPE.toString());
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<ActionGroup> attachGroups = getParameters().getActionGroups();
    Guid roleId = getParameters().getRoleId();
    roles role = getRoleDao().get(roleId);
    List<String> canDoMessages = getReturnValue().getCanDoActionMessages();
    if (checkIfRoleIsReadOnly(canDoMessages)) {
        canDoMessages.add(VdcBllMessages.VAR__TYPE__ROLE.toString());
        canDoMessages.add(VdcBllMessages.VAR__ACTION__ATTACH_ACTION_TO.toString());
        return false;
    }
    // Get all groups by ID and check if they already exist
    List<ActionGroup> allGroups = getActionGroupsByRoleId(roleId);
    for (ActionGroup group : attachGroups) {
        if (allGroups.contains(group)) {
            // group already exist
            canDoMessages.add(VdcBllMessages.ERROR_CANNOT_ATTACH_ACTION_GROUP_TO_ROLE_ATTACHED.toString());
            return false;
        } else if (role.getType() != RoleType.ADMIN && group.getRoleType() == RoleType.ADMIN) {
            canDoMessages.add(VdcBllMessages.CANNOT_ADD_ACTION_GROUPS_TO_ROLE_TYPE.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    roles oldRole = getRoleDao().get(getRole().getId());
    if (oldRole == null) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_ID);
        returnValue = false;
    } else {
        if (CheckIfRoleIsReadOnly(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        } else if (!StringHelper.EqOp(getRole().getname(), oldRole.getname()) && getRoleDao().getByName(getRole().getname()) != null) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_NAME);
            returnValue = false;
        } else // changing role type isn't allowed
        if (getRole().getType() != oldRole.getType()) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_TYPE);
            returnValue = false;
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__ROLE);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    roles oldRole = getRoleDao().get(getRole().getId());
    if (oldRole == null) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_ID);
        returnValue = false;
    } else {
        if (checkIfRoleIsReadOnly(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        } else if (!StringHelper.EqOp(getRole().getname(), oldRole.getname()) && getRoleDao().getByName(getRole().getname()) != null) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_NAME);
            returnValue = false;
        } else // changing role type isn't allowed
        if (getRole().getType() != oldRole.getType()) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_UPDATE_ROLE_TYPE);
            returnValue = false;
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__ROLE);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid roleId = getParameters().getRoleId();
    roles role = getRoleDao().get(roleId);
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ATTACH_ACTION_GROUP_TO_ROLE_ATTACHED);
        return false;
    }
    List<String> canDoMessages = getReturnValue().getCanDoActionMessages();
    if (CheckIfRoleIsReadOnly(canDoMessages)) {
        canDoMessages.add(VdcBllMessages.VAR__TYPE__ROLE.toString());
        canDoMessages.add(VdcBllMessages.VAR__ACTION__DETACH_ACTION_TO.toString());
        return false;
    }
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    List<ActionGroup> allGroups = getActionGroupsByRoleId(roleId);
    // Check that target action group exists for this role
    for (ActionGroup group : groupsToDetach) {
        if (!allGroups.contains(group)) {
            canDoMessages.add(VdcBllMessages.ERROR_CANNOT_DETACH_ACTION_GROUP_TO_ROLE_NOT_ATTACHED.toString());
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid roleId = getParameters().getRoleId();
    roles role = getRoleDao().get(roleId);
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ATTACH_ACTION_GROUP_TO_ROLE_ATTACHED);
        return false;
    }
    List<String> canDoMessages = getReturnValue().getCanDoActionMessages();
    if (checkIfRoleIsReadOnly(canDoMessages)) {
        canDoMessages.add(VdcBllMessages.VAR__TYPE__ROLE.toString());
        canDoMessages.add(VdcBllMessages.VAR__ACTION__DETACH_ACTION_TO.toString());
        return false;
    }
    List<ActionGroup> groupsToDetach = getParameters().getActionGroups();
    List<ActionGroup> allGroups = getActionGroupsByRoleId(roleId);
    // Check that target action group exists for this role
    for (ActionGroup group : groupsToDetach) {
        if (!allGroups.contains(group)) {
            canDoMessages.add(VdcBllMessages.ERROR_CANNOT_DETACH_ACTION_GROUP_TO_ROLE_NOT_ATTACHED.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    roles roles = getRoleDao().get(getParameters().getRoleId());
    if (roles == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_ROLE_INVALID_ROLE_ID);
    } else {
        if (CheckIfRoleIsReadOnly(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__ROLE);
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
        } else {
            if (getPermissionDAO().getAllForRole(getParameters().getRoleId()).size() != 0) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_ROLE_ATTACHED_TO_PERMISSION);
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    roles roles = getRoleDao().get(getParameters().getRoleId());
    if (roles == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_ROLE_INVALID_ROLE_ID);
    } else {
        if (checkIfRoleIsReadOnly(getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__ROLE);
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
        } else {
            if (getPermissionDAO().getAllForRole(getParameters().getRoleId()).size() != 0) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_REMOVE_ROLE_ATTACHED_TO_PERMISSION);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
public GlusterVolumes list() {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
public GlusterVolumes list() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), "cluster = " + parent.get().getName(), GlusterVolume.class);
    return mapCollection(getBackendCollection(SearchType.GlusterVolume, constraint));
}
#end_block

#method_before
@Override
protected GlusterVolume addParents(GlusterVolume volume) {
    volume.setCluster(new Cluster());
    volume.getCluster().setId(clusterId);
    return volume;
}
#method_after
@Override
protected GlusterVolume addParents(GlusterVolume volume) {
    volume.setCluster(parent.get());
    return volume;
}
#end_block

#method_before
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "glusterBricks");
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(Guid.createGuidFromString(clusterId));
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, GetGlusterVolumeByIdQueryParameters.class), true);
}
#method_after
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, GetGlusterVolumeByIdQueryParameters.class), true);
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.DeleteGlusterVolume, new GlusterVolumeParameters(asGuid(id)));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((serverId == null) ? 0 : serverId.hashCode());
    result = prime * result + ((serverName == null) ? 0 : serverName.hashCode());
    result = prime * result + ((brickDirectory == null) ? 0 : brickDirectory.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return ((id != null && id.equals(brick.getId())) && (volumeId != null && volumeId.equals(brick.getVolumeId())) && serverId.equals(brick.getServerId()) && serverName.equals(brick.getServerName()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (getId().equals(brick.getId()) && (volumeId != null && volumeId.equals(brick.getVolumeId())) && serverId.equals(brick.getServerId()) && serverName.equals(brick.getServerName()) && brickDirectory.equals(brick.getBrickDirectory()) && status == brick.getStatus());
}
#end_block

#method_before
public Guid getId() {
    return id;
}
#method_after
public Guid getId() {
    if (id == null) {
        id = Guid.NewGuid();
    }
    return id;
}
#end_block

#method_before
@Override
public GlusterVolumeOptionEntity getById(Guid id) {
    return getCallsHandler().executeRead("GetGlusterOptionById", optionRowMapper, getCustomMapSqlParameterSource().addValue("id", id.getUuid()));
}
#method_after
@Override
public GlusterVolumeOptionEntity getById(Guid id) {
    return getCallsHandler().executeRead("GetGlusterOptionById", optionRowMapper, getCustomMapSqlParameterSource().addValue("id", id));
}
#end_block

#method_before
@Override
public List<GlusterVolumeOptionEntity> getOptionsOfVolume(Guid volumeId) {
    return getCallsHandler().executeReadList("GetOptionsByGlusterVolumeGuid", optionRowMapper, getCustomMapSqlParameterSource().addValue("volume_id", volumeId.getUuid()));
}
#method_after
@Override
public List<GlusterVolumeOptionEntity> getOptionsOfVolume(Guid volumeId) {
    return getCallsHandler().executeReadList("GetOptionsByGlusterVolumeGuid", optionRowMapper, getCustomMapSqlParameterSource().addValue("volume_id", volumeId));
}
#end_block

#method_before
private MapSqlParameterSource createVolumeOptionParams(GlusterVolumeOptionEntity option) {
    return getCustomMapSqlParameterSource().addValue("id", option.getId().getUuid()).addValue("volume_id", option.getVolumeId().getUuid()).addValue("option_key", option.getKey()).addValue("option_val", option.getValue());
}
#method_after
private MapSqlParameterSource createVolumeOptionParams(GlusterVolumeOptionEntity option) {
    return getCustomMapSqlParameterSource().addValue("id", option.getId()).addValue("volume_id", option.getVolumeId()).addValue("option_key", option.getKey()).addValue("option_val", option.getValue());
}
#end_block

#method_before
@Override
public GlusterVolumeEntity getByName(Guid clusterId, String volName) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByName", volumeRowMapper, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId.getUuid()).addValue("vol_name", volName));
    fetchRelatedEntities(volume);
    return volume;
}
#method_after
@Override
public GlusterVolumeEntity getByName(Guid clusterId, String volName) {
    GlusterVolumeEntity volume = getCallsHandler().executeRead("GetGlusterVolumeByName", volumeRowMapper, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId).addValue("vol_name", volName));
    fetchRelatedEntities(volume);
    return volume;
}
#end_block

#method_before
@Override
public List<GlusterVolumeEntity> getByClusterId(Guid clusterId) {
    List<GlusterVolumeEntity> volumes = getCallsHandler().executeReadList("GetGlusterVolumesByClusterGuid", volumeRowMapper, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId.getUuid()));
    fetchRelatedEntities(volumes);
    return volumes;
}
#method_after
@Override
public List<GlusterVolumeEntity> getByClusterId(Guid clusterId) {
    List<GlusterVolumeEntity> volumes = getCallsHandler().executeReadList("GetGlusterVolumesByClusterGuid", volumeRowMapper, getCustomMapSqlParameterSource().addValue("cluster_id", clusterId));
    fetchRelatedEntities(volumes);
    return volumes;
}
#end_block

#method_before
@Override
public void removeByName(Guid clusterId, String volName) {
    getCallsHandler().executeModification("DeleteGlusterVolumeByName", getCustomMapSqlParameterSource().addValue("cluster_id", clusterId.getUuid()).addValue("vol_name", volName));
}
#method_after
@Override
public void removeByName(Guid clusterId, String volName) {
    getCallsHandler().executeModification("DeleteGlusterVolumeByName", getCustomMapSqlParameterSource().addValue("cluster_id", clusterId).addValue("vol_name", volName));
}
#end_block

#method_before
@Override
public void updateVolumeStatusByName(Guid clusterId, String volumeName, GlusterVolumeStatus status) {
    getCallsHandler().executeModification("UpdateGlusterVolumeStatusByName", getCustomMapSqlParameterSource().addValue("cluster_id", clusterId.getUuid()).addValue("vol_name", volumeName).addValue("status", EnumUtils.nameOrNull(status)));
}
#method_after
@Override
public void updateVolumeStatusByName(Guid clusterId, String volumeName, GlusterVolumeStatus status) {
    getCallsHandler().executeModification("UpdateGlusterVolumeStatusByName", getCustomMapSqlParameterSource().addValue("cluster_id", clusterId).addValue("vol_name", volumeName).addValue("status", EnumUtils.nameOrNull(status)));
}
#end_block

#method_before
private MapSqlParameterSource createVolumeIdParams(Guid id) {
    return getCustomMapSqlParameterSource().addValue("volume_id", id.getUuid());
}
#method_after
private MapSqlParameterSource createVolumeIdParams(Guid id) {
    return getCustomMapSqlParameterSource().addValue("volume_id", id);
}
#end_block

#method_before
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId().getUuid()).addValue("cluster_id", volume.getClusterId().getUuid()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#method_after
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#end_block

#method_before
@Override
public void removeBrick(Guid brickId) {
    getCallsHandler().executeModification("DeleteGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", brickId.getUuid()));
}
#method_after
@Override
public void removeBrick(Guid brickId) {
    getCallsHandler().executeModification("DeleteGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", brickId));
}
#end_block

#method_before
@Override
public void replaceBrick(GlusterBrickEntity oldBrick, GlusterBrickEntity newBrick) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", oldBrick.getId()).addValue("new_id", newBrick.getId()).addValue("new_server_id", newBrick.getServerId().getUuid()).addValue("new_brick_dir", newBrick.getBrickDirectory()).addValue("new_status", EnumUtils.nameOrNull(newBrick.getStatus())));
}
#method_after
@Override
public void replaceBrick(GlusterBrickEntity oldBrick, GlusterBrickEntity newBrick) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrick", getCustomMapSqlParameterSource().addValue("id", oldBrick.getId()).addValue("new_id", newBrick.getId()).addValue("new_server_id", newBrick.getServerId()).addValue("new_brick_dir", newBrick.getBrickDirectory()).addValue("new_status", EnumUtils.nameOrNull(newBrick.getStatus())));
}
#end_block

#method_before
@Override
public void updateBrickStatus(Guid brickId, GlusterBrickStatus status) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrickStatus", getCustomMapSqlParameterSource().addValue("id", brickId.getUuid()).addValue("status", EnumUtils.nameOrNull(status)));
}
#method_after
@Override
public void updateBrickStatus(Guid brickId, GlusterBrickStatus status) {
    getCallsHandler().executeModification("UpdateGlusterVolumeBrickStatus", getCustomMapSqlParameterSource().addValue("id", brickId).addValue("status", EnumUtils.nameOrNull(status)));
}
#end_block

#method_before
@Override
public GlusterBrickEntity getById(Guid id) {
    return getCallsHandler().executeRead("GetGlusterBrickById", brickRowMapper, getCustomMapSqlParameterSource().addValue("id", id.getUuid()));
}
#method_after
@Override
public GlusterBrickEntity getById(Guid id) {
    return getCallsHandler().executeRead("GetGlusterBrickById", brickRowMapper, getCustomMapSqlParameterSource().addValue("id", id));
}
#end_block

#method_before
@Override
public List<GlusterBrickEntity> getBricksOfVolume(Guid volumeId) {
    return getCallsHandler().executeReadList("GetBricksByGlusterVolumeGuid", brickRowMapper, getCustomMapSqlParameterSource().addValue("volume_id", volumeId.getUuid()));
}
#method_after
@Override
public List<GlusterBrickEntity> getBricksOfVolume(Guid volumeId) {
    return getCallsHandler().executeReadList("GetBricksByGlusterVolumeGuid", brickRowMapper, getCustomMapSqlParameterSource().addValue("volume_id", volumeId));
}
#end_block

#method_before
private MapSqlParameterSource createBrickParams(GlusterBrickEntity brick) {
    return getCustomMapSqlParameterSource().addValue("id", brick.getId().getUuid()).addValue("volume_id", brick.getVolumeId().getUuid()).addValue("server_id", brick.getServerId().getUuid()).addValue("brick_dir", brick.getBrickDirectory()).addValue("status", EnumUtils.nameOrNull(brick.getStatus()));
}
#method_after
private MapSqlParameterSource createBrickParams(GlusterBrickEntity brick) {
    return getCustomMapSqlParameterSource().addValue("id", brick.getId()).addValue("volume_id", brick.getVolumeId()).addValue("server_id", brick.getServerId()).addValue("brick_dir", brick.getBrickDirectory()).addValue("status", EnumUtils.nameOrNull(brick.getStatus()));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((key == null) ? 0 : key.hashCode());
    result = prime * result + ((value == null) ? 0 : value.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + getId().hashCode();
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((key == null) ? 0 : key.hashCode());
    result = prime * result + ((value == null) ? 0 : value.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeOptionEntity)) {
        return false;
    }
    GlusterVolumeOptionEntity option = (GlusterVolumeOptionEntity) obj;
    return ((id != null && id.equals(option.getId())) && (volumeId != null && volumeId.equals(option.getVolumeId())) && key.equals(option.getKey()) && value.equals(option.getValue()));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeOptionEntity)) {
        return false;
    }
    GlusterVolumeOptionEntity option = (GlusterVolumeOptionEntity) obj;
    return (getId().equals(option.getId()) && (volumeId != null && volumeId.equals(option.getVolumeId())) && key.equals(option.getKey()) && value.equals(option.getValue()));
}
#end_block

#method_before
public Guid getId() {
    return id;
}
#method_after
public Guid getId() {
    if (id == null) {
        id = Guid.NewGuid();
    }
    return id;
}
#end_block

#method_before
public int getReplicaCount() {
    return replicaCount;
}
#method_after
public Integer getReplicaCount() {
    return replicaCount;
}
#end_block

#method_before
public void setReplicaCount(int replicaCount) {
    this.replicaCount = replicaCount;
}
#method_after
public void setReplicaCount(Integer replicaCount) {
    this.replicaCount = replicaCount;
}
#end_block

#method_before
public int getStripeCount() {
    return stripeCount;
}
#method_after
public Integer getStripeCount() {
    return stripeCount;
}
#end_block

#method_before
public void setStripeCount(int stripeCount) {
    this.stripeCount = stripeCount;
}
#method_after
public void setStripeCount(Integer stripeCount) {
    this.stripeCount = stripeCount;
}
#end_block

#method_before
@Override
public ActionResource getActionSubresource(String action, String oid) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
public ActionResource getActionSubresource(String action, String oid) {
    // TODO: To be implemented (pending backend functionality)
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response rebalance(Action action) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
public Response rebalance(Action action) {
    // TODO: To be implemented (pending backend functionality)
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response resetAllOptions() {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
public Response resetAllOptions(Action action) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
protected Response performRemove(String id) {
    // TODO: To be implemented (pending backend functionality)
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response replace(Action action) {
    // TODO: To be implemented
    throw new NotImplementedException();
}
#method_after
@Override
public Response replace(Action action) {
    // TODO: To be implemented (pending backend functionality)
    throw new NotImplementedException();
}
#end_block

#method_before
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    storage_server_connections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    storage.setNfsRetrans(cnx.getNfsRetrans());
    storage.setNfsTimeo(cnx.getNfsTimeo());
    storage.setNfsVersion(cnx.getNfsVersion());
}
#method_after
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    storage_server_connections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
    storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
    storage.setNfsVersion(cnx.getNfsVersion().intValue());
}
#end_block

#method_before
@Mapping(from = StorageDomain.class, to = storage_server_connections.class)
public static storage_server_connections map(StorageDomain model, storage_server_connections template) {
    storage_server_connections entity = template != null ? template : new storage_server_connections();
    if (model.isSetStorage() && model.getStorage().isSetType()) {
        Storage storage = model.getStorage();
        StorageType storageType = StorageType.fromValue(storage.getType());
        if (storageType != null) {
            entity.setstorage_type(map(storageType, null));
            switch(storageType) {
                case ISCSI:
                    break;
                case FCP:
                    break;
                case NFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    }
                    if (storage.getNfsRetrans() != null) {
                        entity.setNfsRetrans(storage.getNfsRetrans());
                    }
                    if (storage.getNfsTimeo() != null) {
                        entity.setNfsTimeo(storage.getNfsTimeo());
                    }
                    if (storage.getNfsVersion() != null) {
                        entity.setNfsVersion(storage.getNfsVersion());
                    }
                    break;
                case LOCALFS:
                    if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    break;
                case POSIXFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    } else if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    if (storage.isSetMountOptions()) {
                        entity.setMountOptions(storage.getMountOptions());
                    }
                    if (storage.isSetVfsType()) {
                        entity.setVfsType(storage.getVfsType());
                    }
                default:
                    break;
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = StorageDomain.class, to = storage_server_connections.class)
public static storage_server_connections map(StorageDomain model, storage_server_connections template) {
    storage_server_connections entity = template != null ? template : new storage_server_connections();
    if (model.isSetStorage() && model.getStorage().isSetType()) {
        Storage storage = model.getStorage();
        StorageType storageType = StorageType.fromValue(storage.getType());
        if (storageType != null) {
            entity.setstorage_type(map(storageType, null));
            switch(storageType) {
                case ISCSI:
                    break;
                case FCP:
                    break;
                case NFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    }
                    if (storage.getNfsRetrans() != null) {
                        entity.setNfsRetrans(storage.getNfsRetrans().shortValue());
                    }
                    if (storage.getNfsTimeo() != null) {
                        entity.setNfsTimeo(storage.getNfsTimeo().shortValue());
                    }
                    if (storage.getNfsVersion() != null) {
                        entity.setNfsVersion(storage.getNfsVersion().shortValue());
                    }
                    break;
                case LOCALFS:
                    if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    break;
                case POSIXFS:
                    if (storage.isSetAddress() && storage.isSetPath()) {
                        entity.setconnection(storage.getAddress() + ":" + storage.getPath());
                    } else if (storage.isSetPath()) {
                        entity.setconnection(storage.getPath());
                    }
                    if (storage.isSetMountOptions()) {
                        entity.setMountOptions(storage.getMountOptions());
                    }
                    if (storage.isSetVfsType()) {
                        entity.setVfsType(storage.getVfsType());
                    }
                default:
                    break;
            }
        }
    }
    return entity;
}
#end_block

#method_before
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() != 0) {
                if (cluster.supportsGlusterService()) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        // $NON-NLS-1$
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true, getGlusterModeEnum());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    model.getEnableOvirtService().setIsChangable(false);
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    model.getEnableGlusterService().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() > 0) {
                clusterModel.getEnableGlusterService().setIsChangable(false);
            } else {
                clusterModel.getEnableGlusterService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    AsyncQuery asyncQuery1 = new AsyncQuery();
    asyncQuery1.setModel(model);
    asyncQuery1.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<VM> vmList = (ArrayList<VM>) result;
            if (vmList.size() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
            } else {
                clusterModel.getEnableOvirtService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        // $NON-NLS-1$
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount());
    }
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        addGlusterVolumeBricksInDb(getParameters().getBricks(), getParameters().getReplicaCount(), getParameters().getStripeCount());
    }
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
public void setVolumeIdInBricks(List<GlusterBrickEntity> bricks) {
    for (GlusterBrickEntity brick : bricks) {
        brick.setVolumeId(getVolumeId());
    }
}
#method_after
public void setVolumeIdInBricks(List<GlusterBrickEntity> bricks) {
    if (bricks != null) {
        for (GlusterBrickEntity brick : bricks) {
            brick.setVolumeId(getVolumeId());
        }
    }
}
#end_block

#method_before
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc hotPlugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(XmlRpcStruct info) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.hotplugNic(info.getInnerMap());
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeRemoveBricksFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks());
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterVolumeRemoveBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), getGlusterVolumeName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        removeBricksFromVolumeInDb(getGlusterVolume(), getParameters().getBricks());
    } else {
        getReturnValue().getExecuteFailedMessages().add(returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    status = getBroker().glusterVolumeRemoveBricks(getParameters().getVolumeName(), getParameters().getBrickDirectories().toArray(new String[0]));
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    status = getBroker().glusterVolumeRemoveBrickForce(getParameters().getVolumeName(), getParameters().getBrickDirectories().toArray(new String[0]));
    ProceedProxyReturnValue();
}
#end_block

#method_before
@Mapping(from = GlusterBrick.class, to = GlusterBrickEntity.class)
public static GlusterBrickEntity map(GlusterBrick fromBrick, GlusterBrickEntity toBrick) {
    GlusterBrickEntity brick = (toBrick == null) ? new GlusterBrickEntity() : toBrick;
    brick.setServerId(Guid.createGuidFromString(fromBrick.getServerId()));
    brick.setBrickDirectory(fromBrick.getBrickDir());
    brick.setStatus(GlusterBrickStatus.valueOf(fromBrick.getStatus().name()));
    return brick;
}
#method_after
@Mapping(from = GlusterBrick.class, to = GlusterBrickEntity.class)
public static GlusterBrickEntity map(GlusterBrick fromBrick, GlusterBrickEntity toBrick) {
    GlusterBrickEntity brick = (toBrick == null) ? new GlusterBrickEntity() : toBrick;
    if (fromBrick.isSetServerId()) {
        brick.setServerId(Guid.createGuidFromString(fromBrick.getServerId()));
    }
    if (fromBrick.isSetBrickDir()) {
        brick.setBrickDirectory(fromBrick.getBrickDir());
    }
    return brick;
}
#end_block

#method_before
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    brick.setServerId(fromBrick.getServerId().toString());
    brick.setBrickDir(fromBrick.getBrickDirectory());
    brick.setStatus(GlusterStatus.valueOf(fromBrick.getStatus().name()));
    return brick;
}
#method_after
@Mapping(from = GlusterBrickEntity.class, to = GlusterBrick.class)
public static GlusterBrick map(GlusterBrickEntity fromBrick, GlusterBrick toBrick) {
    GlusterBrick brick = (toBrick == null) ? new GlusterBrick() : toBrick;
    if (fromBrick.getServerId() != null) {
        brick.setServerId(fromBrick.getServerId().toString());
    }
    if (fromBrick.getBrickDirectory() != null) {
        brick.setBrickDir(fromBrick.getBrickDirectory());
    }
    if (fromBrick.getStatus() != null) {
        brick.setState(fromBrick.getStatus().name());
    }
    return brick;
}
#end_block

#method_before
@Override
protected void verify(GlusterBrick model, GlusterBrick transform) {
    assertNotNull(transform);
    assertNotNull(transform.getServerId());
    assertEquals(model.getServerId(), transform.getServerId());
    assertNotNull(transform.getBrickDir());
    assertEquals(model.getBrickDir(), transform.getBrickDir());
    assertNotNull(transform.getStatus());
    assertEquals(model.getStatus(), transform.getStatus());
}
#method_after
@Override
protected void verify(GlusterBrick model, GlusterBrick transform) {
    assertNotNull(transform);
    assertNotNull(transform.getServerId());
    assertEquals(model.getServerId(), transform.getServerId());
    assertNotNull(transform.getBrickDir());
    assertEquals(model.getBrickDir(), transform.getBrickDir());
}
#end_block

#method_before
@Override
protected GlusterVolume postPopulate(GlusterVolume model) {
    // The model is pre-populated with randomly generated values.
    // This won't work for access protocols since it must be a list
    // of valid values that are present in the enum AccessProtocol
    model.setAccessProtocols("GLUSTER,NFS");
    return model;
}
#method_after
@Override
protected GlusterVolume postPopulate(GlusterVolume model) {
    // The model is pre-populated with randomly generated values.
    // This won't work for enum fields like volume type since it
    // must be a valid value from corresponding enum
    model.setVolumeType(GlusterVolumeType.DISTRIBUTE.name());
    List<String> transportTypes = model.getTransportTypes().getTransportTypes();
    transportTypes.clear();
    transportTypes.add(TransportType.TCP.name());
    List<String> accessProtocols = model.getAccessProtocols().getAccessProtocols();
    accessProtocols.clear();
    accessProtocols.add(AccessProtocol.GLUSTER.name());
    accessProtocols.add(AccessProtocol.NFS.name());
    return model;
}
#end_block

#method_before
@Override
protected void verify(GlusterVolume model, GlusterVolume transform) {
    assertNotNull(transform);
    assertNotNull(transform.getId());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getName());
    assertEquals(model.getName(), transform.getName());
    assertNotNull(transform.getVolumeType());
    assertEquals(model.getVolumeType(), transform.getVolumeType());
    assertNotNull(transform.getTransportType());
    assertEquals(model.getTransportType(), transform.getTransportType());
    assertNotNull(transform.getReplicaCount());
    assertEquals(model.getReplicaCount(), transform.getReplicaCount());
    assertNotNull(transform.getStripeCount());
    assertEquals(model.getStripeCount(), transform.getStripeCount());
    assertNotNull(transform.getStatus());
    assertEquals(model.getStatus(), transform.getStatus());
    verifyBricks(model, transform);
    verifyOptions(model, transform);
}
#method_after
@Override
protected void verify(GlusterVolume model, GlusterVolume transform) {
    assertNotNull(transform);
    assertNotNull(transform.getId());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getName());
    assertEquals(model.getName(), transform.getName());
    assertNotNull(transform.getVolumeType());
    assertEquals(model.getVolumeType(), transform.getVolumeType());
    assertNotNull(transform.getTransportTypes());
    assertArrayEquals(model.getTransportTypes().getTransportTypes().toArray(), transform.getTransportTypes().getTransportTypes().toArray());
    assertNotNull(transform.getReplicaCount());
    assertEquals(model.getReplicaCount(), transform.getReplicaCount());
    assertNotNull(transform.getStripeCount());
    assertEquals(model.getStripeCount(), transform.getStripeCount());
    verifyOptions(model, transform);
}
#end_block

#method_before
private boolean containsOption(GlusterVolume volume, GlusterOption expectedOption) {
    for (GlusterOption option : volume.getGlusterOptions().getGlusterOptions()) {
        if (option.getKey().equals(expectedOption.getKey()) && option.getValue().equals(expectedOption.getValue())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean containsOption(GlusterVolume volume, Option expectedOption) {
    for (Option option : volume.getOptions().getOptions()) {
        if (option.getName().equals(expectedOption.getName()) && option.getValue().equals(expectedOption.getValue())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void verifyOptions(GlusterVolume model, GlusterVolume transform) {
    for (GlusterOption modelOption : model.getGlusterOptions().getGlusterOptions()) {
        assertTrue(containsOption(transform, modelOption));
    }
}
#method_after
private void verifyOptions(GlusterVolume model, GlusterVolume transform) {
    for (Option modelOption : model.getOptions().getOptions()) {
        assertTrue(containsOption(transform, modelOption));
    }
}
#end_block

#method_before
@Mapping(from = GlusterVolume.class, to = GlusterVolumeEntity.class)
public static GlusterVolumeEntity map(GlusterVolume fromVolume, GlusterVolumeEntity toVolume) {
    GlusterVolumeEntity volume = toVolume != null ? toVolume : new GlusterVolumeEntity();
    volume.setId(Guid.createGuidFromString(fromVolume.getId()));
    volume.setName(fromVolume.getName());
    volume.setVolumeType(GlusterVolumeType.valueOf(fromVolume.getVolumeType().name()));
    GlusterOptions options = fromVolume.getGlusterOptions();
    for (GlusterOption option : options.getGlusterOptions()) {
        volume.setOption(option.getKey(), option.getValue());
    }
    if (fromVolume.getTransportType() == null) {
        volume.setTransportType(TransportType.ETHERNET);
    } else {
        volume.setTransportType(TransportType.valueOf(fromVolume.getTransportType().name()));
    }
    volume.setAccessProtocols(fromVolume.getAccessProtocols());
    volume.setAccessControlList(fromVolume.getAccessControlList());
    for (GlusterBrick brick : fromVolume.getGlusterBricks().getGlusterBricks()) {
        volume.addBrick(GlusterBrickMapper.map(brick, null));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() == null) {
        volume.setStatus(GlusterVolumeStatus.DOWN);
    } else {
        volume.setStatus(GlusterVolumeStatus.valueOf(fromVolume.getStatus().name()));
    }
    return volume;
}
#method_after
@Mapping(from = GlusterVolume.class, to = GlusterVolumeEntity.class)
public static GlusterVolumeEntity map(GlusterVolume fromVolume, GlusterVolumeEntity toVolume) {
    GlusterVolumeEntity volume = toVolume != null ? toVolume : new GlusterVolumeEntity();
    if (fromVolume.isSetId()) {
        volume.setId(Guid.createGuidFromString(fromVolume.getId()));
    }
    if (fromVolume.isSetName()) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.isSetVolumeType()) {
        volume.setVolumeType(GlusterVolumeType.valueOf(fromVolume.getVolumeType()));
    }
    if (fromVolume.isSetTransportTypes()) {
        for (String transportType : fromVolume.getTransportTypes().getTransportTypes()) {
            volume.addTransportType(TransportType.valueOf(transportType));
        }
    }
    if (fromVolume.isSetAccessProtocols()) {
        for (String accessProtocol : fromVolume.getAccessProtocols().getAccessProtocols()) {
            volume.addAccessProtocol(AccessProtocol.valueOf(accessProtocol));
        }
    }
    if (fromVolume.isSetAccessControlList()) {
        volume.setAccessControlList(StringUtils.join(fromVolume.getAccessControlList().getAccessControlList(), ","));
    }
    if (fromVolume.isSetReplicaCount()) {
        volume.setReplicaCount(fromVolume.getReplicaCount());
    }
    if (fromVolume.isSetStripeCount()) {
        volume.setStripeCount(fromVolume.getStripeCount());
    }
    if (fromVolume.isSetOptions()) {
        Options options = fromVolume.getOptions();
        if (options.isSetOptions()) {
            for (Option option : options.getOptions()) {
                if (option.isSetName() && option.isSetValue()) {
                    volume.setOption(option.getName(), option.getValue());
                }
            }
        }
    }
    return volume;
}
#end_block

#method_before
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    volume.setId(fromVolume.getId().toString());
    volume.setName(fromVolume.getName());
    volume.setVolumeType(org.ovirt.engine.api.model.GlusterVolumeType.valueOf(fromVolume.getVolumeType().name()));
    volume.setTransportType(org.ovirt.engine.api.model.TransportType.valueOf(fromVolume.getTransportType().name()));
    volume.setAccessProtocols(StringHelper.collectionToString(fromVolume.getAccessProtocols(), ","));
    volume.setAccessControlList(fromVolume.getAccessControlList());
    GlusterBricks glusterBricks = new GlusterBricks();
    List<GlusterBrick> bricks = glusterBricks.getGlusterBricks();
    for (GlusterBrickEntity brick : fromVolume.getBricks()) {
        bricks.add(GlusterBrickMapper.map(brick, null));
    }
    volume.setGlusterBricks(glusterBricks);
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    GlusterOptions glusterOptions = new GlusterOptions();
    List<GlusterOption> options = glusterOptions.getGlusterOptions();
    for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
        options.add(GlusterOptionMapper.map(option, null));
    }
    volume.setGlusterOptions(glusterOptions);
    volume.setStatus(GlusterStatus.valueOf(fromVolume.getStatus().name()));
    return volume;
}
#method_after
@Mapping(from = GlusterVolumeEntity.class, to = GlusterVolume.class)
public static GlusterVolume map(GlusterVolumeEntity fromVolume, GlusterVolume toVolume) {
    GlusterVolume volume = toVolume != null ? toVolume : new GlusterVolume();
    if (fromVolume.getId() != null) {
        volume.setId(fromVolume.getId().toString());
    }
    if (fromVolume.getName() != null) {
        volume.setName(fromVolume.getName());
    }
    if (fromVolume.getVolumeType() != null) {
        volume.setVolumeType(fromVolume.getVolumeType().name());
    }
    if (fromVolume.getTransportTypes() != null) {
        volume.setTransportTypes(new TransportTypes());
        volume.getTransportTypes().getTransportTypes().addAll(EnumUtils.enumCollectionToStringList(fromVolume.getTransportTypes()));
    }
    if (fromVolume.getAccessProtocols() != null) {
        volume.setAccessProtocols(new AccessProtocols());
        volume.getAccessProtocols().getAccessProtocols().addAll(EnumUtils.enumCollectionToStringList(fromVolume.getAccessProtocols()));
    }
    if (fromVolume.getAccessControlList() != null) {
        volume.getAccessControlList().getAccessControlList().addAll(Arrays.asList(fromVolume.getAccessControlList().split(",")));
    }
    volume.setReplicaCount(fromVolume.getReplicaCount());
    volume.setStripeCount(fromVolume.getStripeCount());
    if (fromVolume.getStatus() != null) {
        volume.setState(fromVolume.getStatus().name());
    }
    if (fromVolume.getOptions() != null) {
        Options glusterOptions = new Options();
        List<Option> options = glusterOptions.getOptions();
        for (GlusterVolumeOptionEntity option : fromVolume.getOptions()) {
            options.add(mapOption(option));
        }
        volume.setOptions(glusterOptions);
    }
    return volume;
}
#end_block

#method_before
private final boolean validatePermissions() {
    return true;
/*
         * // If the user requests filtered execution, his permissions are inconsequential. // If the query supports
         * filtering it should be allowed, and if not - not. if (parameters.isFiltered()) { return !queryType.isAdmin();
         * }
         *
         * // If the query was executed internally, it should be allowed in any event. if (isInternalExecution) { return
         * true; }
         *
         * // In any other event, we have admin execution, which should only be allowed according to the user's //
         * permissions. // Note that is cached per session return getUser().isAdmin();
         */
}
#method_after
private final boolean validatePermissions() {
    return true;
// Due to stability issues, this feature is temporarily disabled.
// Once these issues are solved, we will reenable it.
/*
         * // If the user requests filtered execution, his permissions are inconsequential. // If the query supports
         * filtering it should be allowed, and if not - not. if (parameters.isFiltered()) { return !queryType.isAdmin();
         * }
         *
         * // If the query was executed internally, it should be allowed in any event. if (isInternalExecution) { return
         * true; }
         *
         * // In any other event, we have admin execution, which should only be allowed according to the user's //
         * permissions. // Note that is cached per session return getUser().isAdmin();
         */
}
#end_block

#method_before
private GlusterVolumeEntity getGlusterVolume(Guid id) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(id);
    volumeEntity.setName("test-vol");
    volumeEntity.setAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.setTransportType(TransportType.ETHERNET);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getGlusterVolume(Guid id) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    HashSet<TransportType> transportType = new HashSet<TransportType>();
    HashSet<AccessProtocol> accessProtocol = new HashSet<AccessProtocol>();
    accessProtocol.add(AccessProtocol.GLUSTER);
    transportType.add(TransportType.TCP);
    volumeEntity.setId(id);
    volumeEntity.setName("test-vol");
    volumeEntity.setAccessProtocols(accessProtocol);
    volumeEntity.setTransportTypes(transportType);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    return volumeEntity;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec, String connectionAction, Map<String, String> params) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec, connectionAction, params);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(Map<String, Object> volumeData) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeData));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterVolumeSeverities();
    checkSeverities();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterVolumeSeverities();
    initDwhSeverities();
    checkSeverities();
}
#end_block

#method_before
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        default:
            return null;
    }
}
#method_after
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return PermitType.RECONNECT_TO_VM;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        case CREATE_DISK:
            return PermitType.CREATE_DISK;
        case ATTACH_DISK:
            return PermitType.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return PermitType.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return PermitType.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return PermitType.DELETE_DISK;
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    storageDomainId = Guid.NewGuid();
    setUpConfigMock();
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    storageDomainId = Guid.NewGuid();
}
#end_block

#method_before
@Test
public void testGetStorageDomainIdWithPermissions() {
    Guid storagePoolId = getQueryParameters().getStoragePoolId();
    storage_pool pool = new storage_pool();
    pool.setId(storagePoolId);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolId, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(pool);
    when(getQuery().getDbFacade().getStoragePoolDAO()).thenReturn(storagePoolDAOMock);
    storage_domains dataDomain = new storage_domains();
    dataDomain.setId(Guid.NewGuid());
    dataDomain.setstorage_domain_type(StorageDomainType.Data);
    storage_domains isoDomain = new storage_domains();
    isoDomain.setId(storageDomainId);
    isoDomain.setstorage_domain_type(StorageDomainType.ISO);
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(storageDomainDAOMock.getAllForStoragePool(storagePoolId)).thenReturn(Arrays.asList(dataDomain, isoDomain));
    when(getQuery().getDbFacade().getStorageDomainDAO()).thenReturn(storageDomainDAOMock);
    assertEquals("wrong storage domain id", storageDomainId, getQuery().getStorageDomainId());
}
#method_after
@Test
public void testGetStorageDomainIdWithPermissions() {
    mockStoragePoolDAO(new storage_pool());
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(storageDomainDAOMock.getIsoStorageDomainIdForPool(getQueryParameters().getStoragePoolId())).thenReturn(storageDomainId);
    when(getQuery().getDbFacade().getStorageDomainDAO()).thenReturn(storageDomainDAOMock);
    assertEquals("wrong storage domain id", storageDomainId, getQuery().getStorageDomainId());
}
#end_block

#method_before
@Test
public void testGetStorageDomainIdWithNoPermissions() {
    Guid storagePoolId = getQueryParameters().getStoragePoolId();
    storage_pool pool = new storage_pool();
    pool.setId(storagePoolId);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolId, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(pool);
    when(getQuery().getDbFacade().getStoragePoolDAO()).thenReturn(null);
    verifyNoMoreInteractions(getQuery().getDbFacade());
    assertNull("No storage domains should have been returned", null);
}
#method_after
@Test
public void testGetStorageDomainIdWithNoPermissions() {
    mockStoragePoolDAO(null);
    verifyNoMoreInteractions(getQuery().getDbFacade());
    assertNull("No storage domains should have been returned", getQuery().getStorageDomainId());
}
#end_block

#method_before
@Override
protected Guid getStorageDomainId() {
    // Get the storage pool, according to the user's permissions
    // The storage_pool object itself is not needed for this query, it's retrieved only for permission checking
    storage_pool pool = getDbFacade().getStoragePoolDAO().get(getParameters().getStoragePoolId(), getUserID(), getParameters().isFiltered());
    if (pool != null) {
        // Now get all the storage domains
        List<storage_domains> domains = getDbFacade().getStorageDomainDAO().getAllForStoragePool(pool.getId());
        // And find the ISO one
        for (storage_domains domain : domains) {
            if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
                return domain.getId();
            }
        }
    }
    return null;
}
#method_after
@Override
protected Guid getStorageDomainId() {
    if (doesUserHavePemissionsOnStoragePool()) {
        return getDbFacade().getStorageDomainDAO().getIsoStorageDomainIdForPool(getStoragePoolId());
    }
    return null;
}
#end_block

#method_before
@Override
public VM get() {
    VM vm = performGet(VdcQueryType.GetVmByVmId, new GetVmByVmIdParameters(guid));
    setPayload(vm);
    return vm;
}
#method_after
@Override
public VM get() {
    return performGet(VdcQueryType.GetVmByVmId, new GetVmByVmIdParameters(guid));
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    // resolve the host's ID, because it will be needed down the line
    if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
        incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
    }
    VM retVal = performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    setPayload(retVal);
    return retVal;
}
#method_after
@Override
public VM update(VM incoming) {
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    // resolve the host's ID, because it will be needed down the line
    if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
        incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
    }
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected VM populate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    parent.addInlineDetails(details, model);
    addStatistics(model, entity, uriInfo, httpHeaders);
    return model;
}
#method_after
@Override
protected VM populate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    parent.addInlineDetails(details, model);
    addStatistics(model, entity, uriInfo, httpHeaders);
    parent.setPayload(model);
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetVmPayloads()) {
        if (incoming.getVmPayloads().getVmPayload().get(0).isSetType()) {
            VmDeviceType deviceType = VmDeviceType.fromValue(incoming.getVmPayloads().getVmPayload().get(0).getType());
            if (deviceType != null) {
                org.ovirt.engine.core.common.businessentities.VmPayload vmPayload = new org.ovirt.engine.core.common.businessentities.VmPayload(org.ovirt.engine.api.restapi.types.VmMapper.map(deviceType, null), incoming.getVmPayloads().getVmPayload().get(0).getFile().getName(), incoming.getVmPayloads().getVmPayload().get(0).getFile().getContent());
                params.setVmPayload(vmPayload);
            }
        }
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        params.setVmPayload(parent.getPayload(incoming));
    }
    return params;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.sethypervisor_type(entity.gethypervisor_type());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.sethypervisor_type(entity.gethypervisor_type());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetTopology()) {
        if (vm.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
        }
        if (vm.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.Enabled : UsbPolicy.Disabled);
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu() && vm.getCpu().isSetTopology()) {
        if (vm.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
        }
        if (vm.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowReconnect()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowReconnect());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.Enabled : UsbPolicy.Disabled);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdisplay_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getdisplay_type(), null));
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getelapsed_time() != null) {
        if (entity.getelapsed_time() == 0) {
            model.setStartTime(null);
        } else {
            model.setStartTime(DateMapper.map(new BigDecimal(entity.getelapsed_time()), null));
        }
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(entity.getusb_policy() == UsbPolicy.Enabled ? true : false);
        model.setUsb(usb);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdisplay_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getdisplay_type(), null));
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowReconnect(entity.getAllowConsoleReconnect());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getelapsed_time() != null) {
        if (entity.getelapsed_time() == 0) {
            model.setStartTime(null);
        } else {
            model.setStartTime(DateMapper.map(new BigDecimal(entity.getelapsed_time()), null));
        }
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(entity.getusb_policy() == UsbPolicy.Enabled ? true : false);
        model.setUsb(usb);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.api.model.VmPayload.class, to = VmPayload.class)
public static VmPayload map(org.ovirt.engine.api.model.VmPayload entity, VmPayload template) {
    VmPayload model = template != null ? template : new VmPayload();
    model.setType(VmDeviceType.valueOf(entity.getType().toUpperCase()));
    model.setFileName(entity.getFile().getName());
    model.setContent(entity.getFile().getContent());
    return model;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    Payload model = template != null ? template : new Payload();
    if (entity.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
        if (deviceType != null) {
            model.setType(deviceType.value());
        }
    }
    PayloadFile file = new PayloadFile();
    file.setName(entity.getFileName());
    file.setContent(entity.getContent());
    model.setFile(file);
    return model;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "template.id|name", "cluster.id|name");
    Guid templateId = getTemplateId(vm);
    VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
    if (namedCluster(vm)) {
        staticVm.setvds_group_id(getClusterId(vm));
    }
    // resolve the host's ID, because it will be needed down the line
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
        vm.getPlacementPolicy().getHost().setId(getHostId(vm.getPlacementPolicy().getHost().getName()));
    }
    org.ovirt.engine.core.common.businessentities.VmPayload vmPayload = null;
    if (vm.isSetVmPayloads()) {
        if (vm.getVmPayloads().getVmPayload().get(0).isSetType()) {
            VmDeviceType deviceType = VmDeviceType.fromValue(vm.getVmPayloads().getVmPayload().get(0).getType());
            if (deviceType != null) {
                vmPayload = new org.ovirt.engine.core.common.businessentities.VmPayload(org.ovirt.engine.api.restapi.types.VmMapper.map(deviceType, null), vm.getVmPayloads().getVmPayload().get(0).getFile().getName(), vm.getVmPayloads().getVmPayload().get(0).getFile().getContent());
            }
        }
    }
    Response response = null;
    Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
    if (vm.isSetSnapshots() && vm.getSnapshots().getSnapshots() != null && !vm.getSnapshots().getSnapshots().isEmpty()) {
        // If Vm has snapshots collection - this is a clone vm from snapshot operation
        String snapshotId = getSnapshotId(vm.getSnapshots());
        org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
        getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
        // If vm passed in the call has disks attached on them,
        // merge their data with the data of the disks on the configuration
        // The parameters to AddVmFromSnapshot hold an array list of Disks
        // and not List of Disks, as this is a GWT serialization limitation,
        // and this parameter class serves GWT clients as well.
        HashMap<Guid, DiskImage> diskImagesById = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
        if (vm.isSetDisks()) {
            prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesById);
        }
        response = cloneVmFromSnapshot(vmConfiguration.getStaticData(), snapshotId, diskImagesById);
    } else if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
        response = cloneVmFromTemplate(staticVm, vm.getDisks(), templateId);
    } else if (Guid.Empty.equals(templateId)) {
        response = addVmFromScratch(staticVm, storageDomainId, vm.getDisks(), vmPayload);
    } else {
        response = addVm(staticVm, storageDomainId, vm.getDisks(), templateId, vmPayload);
    }
    return response;
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "template.id|name", "cluster.id|name");
    Guid templateId = getTemplateId(vm);
    VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
    if (namedCluster(vm)) {
        staticVm.setvds_group_id(getClusterId(vm));
    }
    // resolve the host's ID, because it will be needed down the line
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
        vm.getPlacementPolicy().getHost().setId(getHostId(vm.getPlacementPolicy().getHost().getName()));
    }
    Response response = null;
    Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
    if (vm.isSetSnapshots() && vm.getSnapshots().getSnapshots() != null && !vm.getSnapshots().getSnapshots().isEmpty()) {
        // If Vm has snapshots collection - this is a clone vm from snapshot operation
        String snapshotId = getSnapshotId(vm.getSnapshots());
        org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getVmConfiguration(snapshotId);
        getMapper(VM.class, VmStatic.class).map(vm, vmConfiguration.getStaticData());
        // If vm passed in the call has disks attached on them,
        // merge their data with the data of the disks on the configuration
        // The parameters to AddVmFromSnapshot hold an array list of Disks
        // and not List of Disks, as this is a GWT serialization limitation,
        // and this parameter class serves GWT clients as well.
        HashMap<Guid, DiskImage> diskImagesByImageId = getDiskImagesByIdMap(vmConfiguration.getDiskMap().values());
        if (vm.isSetDisks()) {
            prepareImagesForCloneFromSnapshotParams(vm.getDisks(), diskImagesByImageId);
        }
        response = cloneVmFromSnapshot(vmConfiguration.getStaticData(), snapshotId, diskImagesByImageId);
    } else if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
        response = cloneVmFromTemplate(staticVm, vm, templateId);
    } else if (Guid.Empty.equals(templateId)) {
        response = addVmFromScratch(staticVm, vm, storageDomainId);
    } else {
        response = addVm(staticVm, vm, storageDomainId, templateId);
    }
    return response;
}
#end_block

#method_before
private void prepareImagesForCloneFromSnapshotParams(Disks disks, Map<Guid, DiskImage> imagesFromConfiguration) {
    if (disks.getDisks() != null) {
        for (Disk disk : disks.getDisks()) {
            DiskImage diskImageFromConfig = imagesFromConfiguration.get(asGuid(disk.getId()));
            DiskImage diskImage = getMapper(Disk.class, DiskImage.class).map(disk, diskImageFromConfig);
            imagesFromConfiguration.put(diskImage.getImageId(), diskImage);
        }
    }
}
#method_after
private void prepareImagesForCloneFromSnapshotParams(Disks disks, Map<Guid, DiskImage> imagesFromConfiguration) {
    if (disks.getDisks() != null) {
        for (Disk disk : disks.getDisks()) {
            DiskImage diskImageFromConfig = imagesFromConfiguration.get(asGuid(disk.getImageId()));
            DiskImage diskImage = getMapper(Disk.class, DiskImage.class).map(disk, diskImageFromConfig);
            imagesFromConfiguration.put(diskImage.getImageId(), diskImage);
        }
    }
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, Disks disks, Guid templateId) {
    return performCreation(VdcActionType.AddVmFromTemplate, new AddVmFromTemplateParameters(staticVm, getDisksToClone(disks, templateId), Guid.Empty), new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    return performCreation(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
private HashMap<Guid, DiskImage> getDisksToClone(Disks disks, Guid templateId) {
    HashMap<Guid, DiskImage> disksMap = new HashMap<Guid, DiskImage>();
    if (disks != null && disks.isSetDisks() && disks.getDisks().size() > 0) {
        HashMap<Guid, DiskImage> templatesDisksMap = getTemplateDisks(templateId);
        for (Disk disk : disks.getDisks()) {
            DiskImage templateDisk = templatesDisksMap.get(Guid.createGuidFromString(disk.getId()));
            if (templateDisk != null) {
                disksMap.put(templateDisk.getImageId(), map(disk, templateDisk));
            } else {
                throw new WebApplicationException(Response.Status.NOT_FOUND);
            }
        }
    }
    return disksMap;
}
#method_after
private HashMap<Guid, DiskImage> getDisksToClone(Disks disks, Guid templateId) {
    HashMap<Guid, DiskImage> disksMap = new HashMap<Guid, DiskImage>();
    if (disks != null && disks.isSetDisks() && disks.getDisks().size() > 0) {
        HashMap<Guid, DiskImage> templatesDisksMap = getTemplateDisks(templateId);
        for (Disk disk : disks.getDisks()) {
            DiskImage templateDisk = templatesDisksMap.get(asGuid(disk.getImageId()));
            if (templateDisk != null) {
                disksMap.put(templateDisk.getImageId(), map(disk, templateDisk));
            } else {
                throw new WebApplicationException(Response.Status.NOT_FOUND);
            }
        }
    }
    return disksMap;
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, Guid storageDomainId, Disks disks, Guid templateId, org.ovirt.engine.core.common.businessentities.VmPayload vmPayload) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(vmPayload);
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(disks, templateId));
    return performCreation(VdcActionType.AddVm, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    return performCreation(VdcActionType.AddVm, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, Guid storageDomainId, Disks disks, org.ovirt.engine.core.common.businessentities.VmPayload vmPayload) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(disks), Guid.Empty);
    params.setVmPayload(vmPayload);
    params.setStorageDomainId(storageDomainId);
    return performCreation(VdcActionType.AddVmFromScratch, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    params.setStorageDomainId(storageDomainId);
    return performCreation(VdcActionType.AddVmFromScratch, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities) {
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        collection.getVMs().add(addLinks(populate(vm, entity)));
        setPayload(vm);
    }
    return collection;
}
#method_after
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities) {
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#end_block

#method_before
private void setPayload(VM vm) {
    // TODO: remove thte try catch...
    try {
        org.ovirt.engine.core.common.businessentities.VmPayload payload = getEntity(org.ovirt.engine.core.common.businessentities.VmPayload.class, VdcQueryType.GetVmPayload, new GetVmByVmIdParameters(new Guid(vm.getId())), null, false);
        if (payload != null) {
            VmPayload p = getMapper(org.ovirt.engine.core.common.businessentities.VmPayload.class, VmPayload.class).map(payload, null);
            VmPayloads payloads = new VmPayloads();
            payloads.getVmPayload().add(p);
            vm.setVmPayloads(payloads);
        }
    } catch (Exception ex) {
    }
}
#method_after
protected void setPayload(VM vm) {
    try {
        VmPayload payload = getEntity(VmPayload.class, VdcQueryType.GetVmPayload, new GetVmByVmIdParameters(new Guid(vm.getId())), null, true);
        if (payload != null) {
            Payload p = getMapper(VmPayload.class, Payload.class).map(payload, null);
            Payloads payloads = new Payloads();
            payloads.getPayload().add(p);
            vm.setPayloads(payloads);
        }
    } catch (WebApplicationException ex) {
        if (ex.getResponse().getStatus() == Response.Status.NOT_FOUND.getStatusCode()) {
        // It's legal to not receive a payload for this VM, so the exception is caught and ignored.
        // (TODO: 'getEntity()' should be refactored to make it the programmer's decision,
        // whether to throw an exception or not in case the entity is not found.) Then
        // this try-catch won't be necessary.
        } else {
            throw ex;
        }
    }
}
#end_block

#method_before
@Override
protected VM populate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    model = addInlineDetails(details, model);
    if (details.contains(Detail.STATISTICS)) {
        addInlineStatistics(model);
    }
    return model;
}
#method_after
@Override
protected VM populate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    model = addInlineDetails(details, model);
    if (details.contains(Detail.STATISTICS)) {
        addInlineStatistics(model);
    }
    setPayload(model);
    return model;
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getVmPayloads().getVmPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    return from;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowReconnect(), transform.getDisplay().isAllowReconnect());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
}
#end_block

#method_before
private static void printUsage() {
    System.out.println("Usage:");
    System.out.println("StoreUtils -[enc|dec|pvk] -store=path/to/keystore-file -pass=keystore-pass -string='string to be enc/decrypted' [-alias='cert alias']");
    System.out.println("StoreUtils -pubkey2ssh -store=path/to/keystore-file -pass=keystore-pass -alias='cert alias'");
}
#method_after
private static void printUsage() {
    System.out.println("Usage:");
    System.out.println("StoreUtils -[enc|dec] -store=path/to/keystore-file -pass=keystore-pass -string='string to be enc/decrypted' [-alias='cert alias']");
    System.out.println("StoreUtils -pubkey2ssh -store=path/to/keystore-file -pass=keystore-pass -alias='cert alias'");
}
#end_block

#method_before
private static boolean validate(CLIParse parser) {
    boolean fOK = true;
    if ((!parser.hasArg("enc")) && (!parser.hasArg("dec")) && (!parser.hasArg("pvk")) && (!parser.hasArg("pubkey2ssh"))) {
        System.out.println("What do you wish me to do? -please specify -enc, -dec, -pvk or -pubkey2ssh");
        fOK = false;
    }
    if ((parser.hasArg("enc") || parser.hasArg("dec")) && (!parser.hasArg("string"))) {
        System.out.println("Can't find a string to work with :( -please specify -string='something'.");
        fOK = false;
    }
    if ((!parser.hasArg("store")) || (!new File(parser.getArg("store")).exists())) {
        System.out.println("Can't find a keystore to work with :( -please specify -store with the correct keystore path.");
        fOK = false;
    }
    if (!parser.hasArg("pass")) {
        System.out.println("Can't find a keystore pass :( -please specify -pass with the correct keystore password.");
        fOK = false;
    }
    if (!fOK) {
        printUsage();
    }
    return fOK;
}
#method_after
private static boolean validate(CLIParse parser) {
    boolean fOK = true;
    if ((!parser.hasArg("enc")) && (!parser.hasArg("dec")) && (!parser.hasArg("pvk")) && (!parser.hasArg("pubkey2ssh"))) {
        System.out.println("What do you wish me to do? -please specify -enc, -dec or -pubkey2ssh");
        fOK = false;
    }
    if ((parser.hasArg("enc") || parser.hasArg("dec")) && (!parser.hasArg("string"))) {
        System.out.println("Can't find a string to work with :( -please specify -string='something'.");
        fOK = false;
    }
    if ((!parser.hasArg("store")) || (!new File(parser.getArg("store")).exists())) {
        System.out.println("Can't find a keystore to work with :( -please specify -store with the correct keystore path.");
        fOK = false;
    }
    if (!parser.hasArg("pass")) {
        System.out.println("Can't find a keystore pass :( -please specify -pass with the correct keystore password.");
        fOK = false;
    }
    if (!fOK) {
        printUsage();
    }
    return fOK;
}
#end_block

#method_before
public static void main(String[] args) {
    try {
        CLIParse parser = new CLIParse(args);
        if (parser.hasArg("?") || parser.hasArg("help") || args.length == 0) {
            printUsage();
            return;
        }
        if (!validate(parser)) {
            return;
        }
        String alias = "engine";
        if (parser.hasArg("alias")) {
            alias = parser.getArg("alias");
        }
        if (parser.hasArg("enc")) {
            System.out.println(EncryptionUtils.encrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias).trim().replace("\r\n", ""));
        } else if (parser.hasArg("dec")) {
            System.out.println(EncryptionUtils.decrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pvk")) {
            System.out.write(pvk(parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pubkey2ssh")) {
            System.out.println(ssh(parser.getArg("store"), parser.getArg("pass"), alias));
        }
    } catch (Exception e) {
        System.out.println("Operation failed!");
    }
}
#method_after
public static void main(String[] args) {
    try {
        CLIParse parser = new CLIParse(args);
        if (parser.hasArg("?") || parser.hasArg("help") || args.length == 0) {
            printUsage();
            return;
        }
        if (!validate(parser)) {
            return;
        }
        String alias = "engine";
        if (parser.hasArg("alias")) {
            alias = parser.getArg("alias");
        }
        if (parser.hasArg("enc")) {
            System.out.println(EncryptionUtils.encrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias).trim().replace("\r\n", ""));
        } else if (parser.hasArg("dec")) {
            System.out.println(EncryptionUtils.decrypt(parser.getArg("string"), parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pvk")) {
            System.out.write(pvk(parser.getArg("store"), parser.getArg("pass"), alias));
        } else if (parser.hasArg("pubkey2ssh")) {
            System.out.println(pubkey2ssh(parser.getArg("store"), parser.getArg("pass"), alias));
        }
    } catch (Exception e) {
        System.out.println("Operation failed!");
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getstatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
        return false;
    }
    // If we are here everything is okay:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getstatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // subjects:
    return true;
}
#end_block

#method_before
@Override
protected void Perform() {
    // a ticket):
    if (StringHelper.isNullOrEmpty(mTicket)) {
        mTicket = Ticketing.GenerateOTP();
    }
    // Update the dynamic information of the virtual machine in memory (we need it
    // to update the database later):
    // Check that the virtual machine exists:
    final VM vm = getVm();
    final IVdcUser user = getCurrentUser();
    vm.setConsoleUserName(user.getUserName());
    vm.setConsoleUserId(user.getUserId());
    // If the virtual machine has the allow reconnect then we just have to save
    // the user name and the user id to the database, regardless of what was there
    // before and without locking.
    // 
    // In any other situation we try to save the new user to the database and proceed
    // only if the previous user in the database is null. This is needed to prevent
    // races between different users trying to access the console of the same virtual
    // machine simultaneously.
    final VmDynamicDAO dao = DbFacade.getInstance().getVmDynamicDAO();
    if (vm.getAllowConsoleReconnect() || userHasReconnectPermission) {
        dao.update(vm.getDynamicData());
        sendTicket();
    } else {
        final boolean saved = dao.updateConsoleUserWithOptimisticLocking(vm.getDynamicData());
        if (saved) {
            sendTicket();
        } else {
            dontSendTicket();
        }
    }
}
#method_after
@Override
protected void Perform() {
    // a ticket):
    if (StringHelper.isNullOrEmpty(mTicket)) {
        mTicket = Ticketing.GenerateOTP();
    }
    // Update the dynamic information of the virtual machine in memory (we need it
    // to update the database later):
    final VM vm = getVm();
    final IVdcUser user = getCurrentUser();
    vm.setConsoleUserId(user.getUserId());
    // If the virtual machine has the allow reconnect flag or the user
    // needed additional permissions to connect to the console then we just
    // have to save the user id to the database, regardless of what was
    // there before and without locking.
    // 
    // Note that the fact that the user needed permissions actually means
    // that it has them, otherwise we will not be here, performing the
    // operation.
    // 
    // In any other situation we try to save the new user to the database
    // and proceed only if the previous user in the database is null. This
    // is needed to prevent races between different users trying to access
    // the console of the same virtual machine simultaneously.
    final VmDynamicDAO dao = DbFacade.getInstance().getVmDynamicDAO();
    if (vm.getAllowConsoleReconnect() || neededPermissions) {
        dao.update(vm.getDynamicData());
        sendTicket();
    } else {
        final boolean saved = dao.updateConsoleUserWithOptimisticLocking(vm.getDynamicData());
        if (saved) {
            sendTicket();
        } else {
            dontSendTicket();
        }
    }
}
#end_block

#method_before
private void dontSendTicket() {
    // Send messages to the log explaining the situation:
    final VM vm = getVm();
    final IVdcUser user = getCurrentUser();
    log.warnFormat("Failed to set console user to \"{0}\" for virtual machine \"{1}\".", user.getUserName(), vm.getvm_name());
    log.warnFormat("This probably means that two users are trying to connect to the console simultaneously.");
    log.warnFormat("The id of user \"{0}\" is \"{1}\".", user.getUserName(), user.getUserId());
    log.warnFormat("The id of virtual machine \"{0}\" is \"{1}\".", vm.getvm_name(), vm.getvm_guid());
    log.warnFormat("The ticket will not be set.");
    // Set the result messages indicating that the operation failed:
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_USE_BY_OTHER_USER);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
    // The command failed:
    setSucceeded(false);
}
#method_after
private void dontSendTicket() {
    // Send messages to the log explaining the situation:
    final VM vm = getVm();
    final IVdcUser user = getCurrentUser();
    log.warnFormat("Can't give console of virtual machine \"{0}\" to user \"{1}\", it has probably been taken by another user.", vm.getId(), user.getUserId());
    // Set the result messages indicating that the operation failed:
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_USE_BY_OTHER_USER);
    // The command failed:
    setSucceeded(false);
}
#end_block

#method_before
private void sendTicket() {
    // Send the ticket to the virtual machine:
    final boolean sent = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(getVdsId(), getVmId(), mTicket, mValidTime)).getSucceeded();
    // Return the ticket only if sending it to the virtual machine succeeded:
    if (sent) {
        setActionReturnValue(mTicket);
    }
    setSucceeded(sent);
}
#method_after
private void sendTicket() {
    // Send the ticket to the virtual machine:
    final IVdcUser user = getCurrentUser();
    final boolean sent = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(getVdsId(), getVmId(), mTicket, mValidTime, user.getUserName(), user.getUserId())).getSucceeded();
    // Return the ticket only if sending it to the virtual machine succeeded:
    if (sent) {
        setActionReturnValue(mTicket);
    }
    setSucceeded(sent);
}
#end_block

#method_before
@XmlElement(name = "CustomProperties")
public String getCustomProperties() {
    return mVmStatic.getCustomProperties();
}
#method_after
public String getCustomProperties() {
    return mVmStatic.getCustomProperties();
}
#end_block

#method_before
@XmlElement(name = "VmPauseStatus")
public VmPauseStatus getVmPauseStatus() {
    return this.mVmDynamic.getPauseStatus();
}
#method_after
public VmPauseStatus getVmPauseStatus() {
    return this.mVmDynamic.getPauseStatus();
}
#end_block

#method_before
@XmlElement(name = "vm_name")
public String getvm_name() {
    return this.mVmStatic.getvm_name();
}
#method_after
public String getvm_name() {
    return this.mVmStatic.getvm_name();
}
#end_block

#method_before
@XmlElement(name = "vm_mem_size_mb")
public int getvm_mem_size_mb() {
    return this.mVmStatic.getmem_size_mb();
}
#method_after
public int getvm_mem_size_mb() {
    return this.mVmStatic.getmem_size_mb();
}
#end_block

#method_before
@XmlElement(name = "vm_domain")
public String getvm_domain() {
    return this.mVmStatic.getdomain();
}
#method_after
public String getvm_domain() {
    return this.mVmStatic.getdomain();
}
#end_block

#method_before
@XmlElement(name = "vm_os")
public VmOsType getvm_os() {
    return this.mVmStatic.getos();
}
#method_after
public VmOsType getvm_os() {
    return this.mVmStatic.getos();
}
#end_block

#method_before
@XmlElement(name = "vm_creation_date")
public java.util.Date getvm_creation_date() {
    return this.mVmStatic.getcreation_date();
}
#method_after
public Date getvm_creation_date() {
    return this.mVmStatic.getcreation_date();
}
#end_block

#method_before
public void setvm_creation_date(java.util.Date value) {
    this.mVmStatic.setcreation_date(value);
}
#method_after
public void setvm_creation_date(Date value) {
    this.mVmStatic.setcreation_date(value);
}
#end_block

#method_before
@XmlElement(name = "vm_description")
public String getvm_description() {
    return this.mVmStatic.getdescription();
}
#method_after
public String getvm_description() {
    return this.mVmStatic.getdescription();
}
#end_block

#method_before
@XmlElement(name = "num_of_monitors")
public int getnum_of_monitors() {
    return this.mVmStatic.getnum_of_monitors();
}
#method_after
public int getnum_of_monitors() {
    return this.mVmStatic.getnum_of_monitors();
}
#end_block

#method_before
@XmlElement
public boolean getAllowConsoleReconnect() {
    return mVmStatic.getAllowConsoleReconnect();
}
#method_after
public boolean getAllowConsoleReconnect() {
    return this.mVmStatic.getAllowConsoleReconnect();
}
#end_block

#method_before
public void setAllowConsoleReconnect(boolean value) {
    mVmStatic.setAllowConsoleReconnect(value);
}
#method_after
public void setAllowConsoleReconnect(boolean value) {
    this.mVmStatic.setAllowConsoleReconnect(value);
    OnPropertyChanged(new PropertyChangedEventArgs("allowConsoleReconnect"));
}
#end_block

#method_before
@XmlElement(name = "is_initialized")
public boolean getis_initialized() {
    return this.mVmStatic.getis_initialized();
}
#method_after
public boolean getis_initialized() {
    return this.mVmStatic.getis_initialized();
}
#end_block

#method_before
@XmlElement(name = "is_auto_suspend")
public boolean getis_auto_suspend() {
    return this.mVmStatic.getis_auto_suspend();
}
#method_after
public boolean getis_auto_suspend() {
    return this.mVmStatic.getis_auto_suspend();
}
#end_block

#method_before
@XmlElement(name = "num_of_cpus")
public int getnum_of_cpus() {
    return this.mVmStatic.getnum_of_cpus();
}
#method_after
public int getnum_of_cpus() {
    return this.mVmStatic.getnum_of_cpus();
}
#end_block

#method_before
@XmlElement(name = "num_of_sockets")
public int getnum_of_sockets() {
    return this.mVmStatic.getnum_of_sockets();
}
#method_after
public int getnum_of_sockets() {
    return this.mVmStatic.getnum_of_sockets();
}
#end_block

#method_before
@XmlElement(name = "cpu_per_socket")
public int getcpu_per_socket() {
    return this.mVmStatic.getcpu_per_socket();
}
#method_after
public int getcpu_per_socket() {
    return this.mVmStatic.getcpu_per_socket();
}
#end_block

#method_before
@XmlElement(name = "usb_policy")
public UsbPolicy getusb_policy() {
    return mVmStatic.getusb_policy();
}
#method_after
public UsbPolicy getusb_policy() {
    return mVmStatic.getusb_policy();
}
#end_block

#method_before
@XmlElement(name = "auto_startup")
public boolean getauto_startup() {
    return mVmStatic.getauto_startup();
}
#method_after
public boolean getauto_startup() {
    return mVmStatic.getauto_startup();
}
#end_block

#method_before
@XmlElement(name = "dedicated_vm_for_vds")
public NGuid getdedicated_vm_for_vds() {
    return mVmStatic.getdedicated_vm_for_vds();
}
#method_after
public NGuid getdedicated_vm_for_vds() {
    return mVmStatic.getdedicated_vm_for_vds();
}
#end_block

#method_before
@XmlElement(name = "vds_group_id")
public Guid getvds_group_id() {
    return this.mVmStatic.getvds_group_id();
}
#method_after
public Guid getvds_group_id() {
    return this.mVmStatic.getvds_group_id();
}
#end_block

#method_before
@XmlElement(name = "time_zone")
public String gettime_zone() {
    return mVmStatic.gettime_zone();
}
#method_after
public String gettime_zone() {
    return mVmStatic.gettime_zone();
}
#end_block

#method_before
@XmlElement(name = "is_stateless")
public boolean getis_stateless() {
    return mVmStatic.getis_stateless();
}
#method_after
public boolean getis_stateless() {
    return mVmStatic.getis_stateless();
}
#end_block

#method_before
@XmlElement(name = "default_display_type")
public DisplayType getdefault_display_type() {
    return mVmStatic.getdefault_display_type();
}
#method_after
public DisplayType getdefault_display_type() {
    return mVmStatic.getdefault_display_type();
}
#end_block

#method_before
@XmlElement(name = "priority")
public int getpriority() {
    return mVmStatic.getpriority();
}
#method_after
public int getpriority() {
    return mVmStatic.getpriority();
}
#end_block

#method_before
@XmlElement(name = "iso_path")
public String getiso_path() {
    return mVmStatic.getiso_path();
}
#method_after
public String getiso_path() {
    return mVmStatic.getiso_path();
}
#end_block

#method_before
@XmlElement(name = "origin")
public OriginType getorigin() {
    return mVmStatic.getorigin();
}
#method_after
public OriginType getorigin() {
    return mVmStatic.getorigin();
}
#end_block

#method_before
@XmlElement(name = "initrd_url")
public String getinitrd_url() {
    return mVmStatic.getinitrd_url();
}
#method_after
public String getinitrd_url() {
    return mVmStatic.getinitrd_url();
}
#end_block

#method_before
@XmlElement(name = "kernel_url")
public String getkernel_url() {
    return mVmStatic.getkernel_url();
}
#method_after
public String getkernel_url() {
    return mVmStatic.getkernel_url();
}
#end_block

#method_before
@XmlElement(name = "kernel_params")
public String getkernel_params() {
    return mVmStatic.getkernel_params();
}
#method_after
public String getkernel_params() {
    return mVmStatic.getkernel_params();
}
#end_block

#method_before
@XmlElement(name = "status")
public VMStatus getstatus() {
    return this.mVmDynamic.getstatus();
}
#method_after
public VMStatus getstatus() {
    return this.mVmDynamic.getstatus();
}
#end_block

#method_before
@XmlElement(name = "vm_ip")
public String getvm_ip() {
    return this.mVmDynamic.getvm_ip();
}
#method_after
public String getvm_ip() {
    return this.mVmDynamic.getvm_ip();
}
#end_block

#method_before
@XmlElement(name = "vm_host")
public String getvm_host() {
    String vmHost = this.mVmDynamic.getvm_host();
    if (!StringHelper.isNullOrEmpty(this.getvm_ip())) {
        this.mVmDynamic.setvm_host(getvm_ip());
    } else {
        String vmDomain = getvm_domain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getvm_name() : getvm_name() + "." + vmDomain;
            this.mVmDynamic.setvm_host(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.mVmDynamic.setvm_host(vmHost + "." + vmDomain);
        }
    }
    return this.mVmDynamic.getvm_host();
}
#method_after
public String getvm_host() {
    String vmHost = this.mVmDynamic.getvm_host();
    if (!StringHelper.isNullOrEmpty(this.getvm_ip())) {
        this.mVmDynamic.setvm_host(getvm_ip());
    } else {
        String vmDomain = getvm_domain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getvm_name() : getvm_name() + "." + vmDomain;
            this.mVmDynamic.setvm_host(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.mVmDynamic.setvm_host(vmHost + "." + vmDomain);
        }
    }
    return this.mVmDynamic.getvm_host();
}
#end_block

#method_before
@XmlElement(name = "vm_pid")
public Integer getvm_pid() {
    return this.mVmDynamic.getvm_pid();
}
#method_after
public Integer getvm_pid() {
    return this.mVmDynamic.getvm_pid();
}
#end_block

#method_before
@XmlElement(name = "vm_last_up_time")
public java.util.Date getvm_last_up_time() {
    return this.mVmDynamic.getvm_last_up_time();
}
#method_after
public Date getvm_last_up_time() {
    return this.mVmDynamic.getvm_last_up_time();
}
#end_block

#method_before
public void setvm_last_up_time(java.util.Date value) {
    this.mVmDynamic.setvm_last_up_time(value);
}
#method_after
public void setvm_last_up_time(Date value) {
    this.mVmDynamic.setvm_last_up_time(value);
}
#end_block

#method_before
@XmlElement(name = "vm_last_boot_time")
public java.util.Date getvm_last_boot_time() {
    return this.mVmDynamic.getvm_last_boot_time();
}
#method_after
public Date getvm_last_boot_time() {
    return this.mVmDynamic.getvm_last_boot_time();
}
#end_block

#method_before
public void setvm_last_boot_time(java.util.Date value) {
    this.mVmDynamic.setvm_last_boot_time(value);
}
#method_after
public void setvm_last_boot_time(Date value) {
    this.mVmDynamic.setvm_last_boot_time(value);
}
#end_block

#method_before
@XmlElement(name = "guest_cur_user_name")
public String getguest_cur_user_name() {
    return this.mVmDynamic.getguest_cur_user_name();
}
#method_after
public String getguest_cur_user_name() {
    return this.mVmDynamic.getguest_cur_user_name();
}
#end_block

#method_before
@XmlElement(name = "guest_last_login_time")
public java.util.Date getguest_last_login_time() {
    return this.mVmDynamic.getguest_last_login_time();
}
#method_after
public Date getguest_last_login_time() {
    return this.mVmDynamic.getguest_last_login_time();
}
#end_block

#method_before
public void setguest_last_login_time(java.util.Date value) {
    this.mVmDynamic.setguest_last_login_time(value);
}
#method_after
public void setguest_last_login_time(Date value) {
    this.mVmDynamic.setguest_last_login_time(value);
}
#end_block

#method_before
@XmlElement(name = "guest_cur_user_id")
public NGuid getguest_cur_user_id() {
    return this.mVmDynamic.getguest_cur_user_id();
}
#method_after
public NGuid getguest_cur_user_id() {
    return this.mVmDynamic.getguest_cur_user_id();
}
#end_block

#method_before
@XmlElement
public NGuid getConsoleUserId() {
    return this.mVmDynamic.getConsoleUserId();
}
#method_after
public NGuid getConsoleUserId() {
    return this.mVmDynamic.getConsoleUserId();
}
#end_block

#method_before
@XmlElement(name = "guest_last_logout_time")
public java.util.Date getguest_last_logout_time() {
    return this.mVmDynamic.getguest_last_logout_time();
}
#method_after
public Date getguest_last_logout_time() {
    return this.mVmDynamic.getguest_last_logout_time();
}
#end_block

#method_before
public void setguest_last_logout_time(java.util.Date value) {
    this.mVmDynamic.setguest_last_logout_time(value);
}
#method_after
public void setguest_last_logout_time(Date value) {
    this.mVmDynamic.setguest_last_logout_time(value);
}
#end_block

#method_before
@XmlElement(name = "guest_os")
public String getguest_os() {
    return this.mVmDynamic.getguest_os();
}
#method_after
public String getguest_os() {
    return this.mVmDynamic.getguest_os();
}
#end_block

#method_before
@XmlElement(name = "run_on_vds")
public NGuid getrun_on_vds() {
    return this.mVmDynamic.getrun_on_vds();
}
#method_after
public NGuid getrun_on_vds() {
    return this.mVmDynamic.getrun_on_vds();
}
#end_block

#method_before
@XmlElement(name = "migrating_to_vds")
public NGuid getmigrating_to_vds() {
    return this.mVmDynamic.getmigrating_to_vds();
}
#method_after
public NGuid getmigrating_to_vds() {
    return this.mVmDynamic.getmigrating_to_vds();
}
#end_block

#method_before
@XmlElement(name = "app_list")
public String getapp_list() {
    return this.mVmDynamic.getapp_list();
}
#method_after
public String getapp_list() {
    return this.mVmDynamic.getapp_list();
}
#end_block

#method_before
@XmlElement(name = "display", nillable = true)
public Integer getdisplay() {
    return this.mVmDynamic.getdisplay();
}
#method_after
public Integer getdisplay() {
    return this.mVmDynamic.getdisplay();
}
#end_block

#method_before
@XmlElement(name = "acpi_enable")
public Boolean getacpi_enable() {
    return this.mVmDynamic.getacpi_enable();
}
#method_after
public Boolean getacpi_enable() {
    return this.mVmDynamic.getacpi_enable();
}
#end_block

#method_before
@XmlElement(name = "display_ip")
public String getdisplay_ip() {
    return this.mVmDynamic.getdisplay_ip();
}
#method_after
public String getdisplay_ip() {
    return this.mVmDynamic.getdisplay_ip();
}
#end_block

#method_before
@XmlElement(name = "display_type")
public DisplayType getdisplay_type() {
    return this.mVmDynamic.getdisplay_type();
}
#method_after
public DisplayType getdisplay_type() {
    return this.mVmDynamic.getdisplay_type();
}
#end_block

#method_before
@XmlElement(name = "kvm_enable")
public Boolean getkvm_enable() {
    return this.mVmDynamic.getkvm_enable();
}
#method_after
public Boolean getkvm_enable() {
    return this.mVmDynamic.getkvm_enable();
}
#end_block

#method_before
@XmlElement(name = "session")
public SessionState getsession() {
    return this.mVmDynamic.getsession();
}
#method_after
public SessionState getsession() {
    return this.mVmDynamic.getsession();
}
#end_block

#method_before
@XmlElement(name = "boot_sequence")
public BootSequence getboot_sequence() {
    return this.mVmDynamic.getboot_sequence();
}
#method_after
public BootSequence getboot_sequence() {
    return this.mVmDynamic.getboot_sequence();
}
#end_block

#method_before
@XmlElement(name = "display_secure_port", nillable = true)
public Integer getdisplay_secure_port() {
    return this.mVmDynamic.getdisplay_secure_port();
}
#method_after
public Integer getdisplay_secure_port() {
    return this.mVmDynamic.getdisplay_secure_port();
}
#end_block

#method_before
@XmlElement(name = "ExitStatus")
public VmExitStatus getExitStatus() {
    return this.mVmDynamic.getExitStatus();
}
#method_after
public VmExitStatus getExitStatus() {
    return this.mVmDynamic.getExitStatus();
}
#end_block

#method_before
@XmlElement(name = "ExitMessage")
public String getExitMessage() {
    return this.mVmDynamic.getExitMessage();
}
#method_after
public String getExitMessage() {
    return this.mVmDynamic.getExitMessage();
}
#end_block

#method_before
@XmlElement(name = "utc_diff")
public Integer getutc_diff() {
    return this.mVmDynamic.getutc_diff();
}
#method_after
public Integer getutc_diff() {
    return this.mVmDynamic.getutc_diff();
}
#end_block

#method_before
@XmlElement(name = "last_vds_run_on")
public NGuid getlast_vds_run_on() {
    return this.mVmDynamic.getlast_vds_run_on();
}
#method_after
public NGuid getlast_vds_run_on() {
    return this.mVmDynamic.getlast_vds_run_on();
}
#end_block

#method_before
@XmlElement(name = "client_ip")
public String getclient_ip() {
    return this.mVmDynamic.getclient_ip();
}
#method_after
public String getclient_ip() {
    return this.mVmDynamic.getclient_ip();
}
#end_block

#method_before
@XmlElement(name = "guest_requested_memory")
public Integer getguest_requested_memory() {
    return this.mVmDynamic.getguest_requested_memory();
}
#method_after
public Integer getguest_requested_memory() {
    return this.mVmDynamic.getguest_requested_memory();
}
#end_block

#method_before
@XmlElement(name = "cpu_user")
public Double getcpu_user() {
    return this.mVmStatistics.getcpu_user();
}
#method_after
public Double getcpu_user() {
    return this.mVmStatistics.getcpu_user();
}
#end_block

#method_before
@XmlElement(name = "cpu_sys")
public Double getcpu_sys() {
    return this.mVmStatistics.getcpu_sys();
}
#method_after
public Double getcpu_sys() {
    return this.mVmStatistics.getcpu_sys();
}
#end_block

#method_before
@XmlElement(name = "elapsed_time", nillable = true)
public Double getelapsed_time() {
    return this.mVmStatistics.getelapsed_time();
}
#method_after
public Double getelapsed_time() {
    return this.mVmStatistics.getelapsed_time();
}
#end_block

#method_before
@XmlElement(name = "RoundedElapsedTime", nillable = true)
public Double getRoundedElapsedTime() {
    return this.mVmStatistics.getRoundedElapsedTime();
}
#method_after
public Double getRoundedElapsedTime() {
    return this.mVmStatistics.getRoundedElapsedTime();
}
#end_block

#method_before
@XmlElement(name = "usage_network_percent", nillable = true)
public Integer getusage_network_percent() {
    return this.mVmStatistics.getusage_network_percent();
}
#method_after
public Integer getusage_network_percent() {
    return this.mVmStatistics.getusage_network_percent();
}
#end_block

#method_before
@XmlElement(name = "usage_mem_percent", nillable = true)
public Integer getusage_mem_percent() {
    return this.mVmStatistics.getusage_mem_percent();
}
#method_after
public Integer getusage_mem_percent() {
    return this.mVmStatistics.getusage_mem_percent();
}
#end_block

#method_before
@XmlElement(name = "usage_cpu_percent", nillable = true)
public Integer getusage_cpu_percent() {
    return this.mVmStatistics.getusage_cpu_percent();
}
#method_after
public Integer getusage_cpu_percent() {
    return this.mVmStatistics.getusage_cpu_percent();
}
#end_block

#method_before
@XmlElement(name = "vmt_guid")
public Guid getvmt_guid() {
    return this.mVmStatic.getvmt_guid();
}
#method_after
public Guid getvmt_guid() {
    return this.mVmStatic.getvmt_guid();
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "vmt_name")
public String getvmt_name() {
    return this.vmt_nameField;
}
#method_after
public String getvmt_name() {
    return this.vmt_nameField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public int getvmt_mem_size_mb() {
    return this.vmt_mem_size_mbField;
}
#method_after
public int getvmt_mem_size_mb() {
    return this.vmt_mem_size_mbField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public VmOsType getvmt_os() {
    return this.vmt_osField;
}
#method_after
public VmOsType getvmt_os() {
    return this.vmt_osField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public java.util.Date getvmt_creation_date() {
    return this.vmt_creation_dateField;
}
#method_after
public Date getvmt_creation_date() {
    return this.vmt_creation_dateField;
}
#end_block

#method_before
public void setvmt_creation_date(java.util.Date value) {
    this.vmt_creation_dateField = value;
}
#method_after
public void setvmt_creation_date(Date value) {
    this.vmt_creation_dateField = value;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public int getvmt_child_count() {
    return this.vmt_child_countField;
}
#method_after
public int getvmt_child_count() {
    return this.vmt_child_countField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public int getvmt_num_of_cpus() {
    return this.vmt_num_of_cpusField;
}
#method_after
public int getvmt_num_of_cpus() {
    return this.vmt_num_of_cpusField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public int getvmt_num_of_sockets() {
    return this.vmt_num_of_socketsField;
}
#method_after
public int getvmt_num_of_sockets() {
    return this.vmt_num_of_socketsField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public int getvmt_cpu_per_socket() {
    return this.vmt_cpu_per_socketField;
}
#method_after
public int getvmt_cpu_per_socket() {
    return this.vmt_cpu_per_socketField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public String getvmt_description() {
    return this.vmt_descriptionField;
}
#method_after
public String getvmt_description() {
    return this.vmt_descriptionField;
}
#end_block

#method_before
@XmlElement(name = "vds_group_compatibility_version")
public Version getvds_group_compatibility_version() {
    return this.vds_group_compatibility_versionField;
}
#method_after
public Version getvds_group_compatibility_version() {
    return this.vds_group_compatibility_versionField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public String getvds_group_name() {
    return this.vds_group_nameField;
}
#method_after
public String getvds_group_name() {
    return this.vds_group_nameField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public String getvds_group_description() {
    return this.vds_group_descriptionField;
}
#method_after
public String getvds_group_description() {
    return this.vds_group_descriptionField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public String getvds_group_cpu_name() {
    return this.vds_group_cpu_nameField;
}
#method_after
public String getvds_group_cpu_name() {
    return this.vds_group_cpu_nameField;
}
#end_block

#method_before
@XmlElement(name = "fail_back")
public boolean getfail_back() {
    return this.mVmStatic.getfail_back();
}
#method_after
public boolean getfail_back() {
    return this.mVmStatic.getfail_back();
}
#end_block

#method_before
@XmlElement(name = "default_boot_sequence")
public BootSequence getdefault_boot_sequence() {
    return this.mVmStatic.getdefault_boot_sequence();
}
#method_after
public BootSequence getdefault_boot_sequence() {
    return this.mVmStatic.getdefault_boot_sequence();
}
#end_block

#method_before
@XmlElement(name = "nice_level")
public int getnice_level() {
    return this.mVmStatic.getnice_level();
}
#method_after
public int getnice_level() {
    return this.mVmStatic.getnice_level();
}
#end_block

#method_before
@XmlElement(name = "MigrationSupport")
public MigrationSupport getMigrationSupport() {
    return this.mVmStatic.getMigrationSupport();
}
#method_after
public MigrationSupport getMigrationSupport() {
    return this.mVmStatic.getMigrationSupport();
}
#end_block

#method_before
@XmlElement(name = "vm_type")
public VmType getvm_type() {
    return this.mVmStatic.getvm_type();
}
#method_after
public VmType getvm_type() {
    return this.mVmStatic.getvm_type();
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "storage_pool_id")
public Guid getstorage_pool_id() {
    return storage_pool_idField;
}
#method_after
@Override
public Guid getstorage_pool_id() {
    return storage_pool_idField;
}
#end_block

#method_before
public void setstorage_pool_id(Guid value) {
    storage_pool_idField = value;
}
#method_after
@Override
public void setstorage_pool_id(Guid value) {
    storage_pool_idField = value;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "storage_pool_name")
public String getstorage_pool_name() {
    return storage_pool_nameField;
}
#method_after
public String getstorage_pool_name() {
    return storage_pool_nameField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
// to .NET attributes:
public VdsSelectionAlgorithm getselection_algorithm() {
    return selection_algorithmField;
}
#method_after
public VdsSelectionAlgorithm getselection_algorithm() {
    return selection_algorithmField;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "Interfaces")
public List<VmNetworkInterface> getInterfaces() {
    return mInterfaces;
}
#method_after
public List<VmNetworkInterface> getInterfaces() {
    return mVmStatic.getInterfaces();
}
#end_block

#method_before
public void setInterfaces(List<VmNetworkInterface> value) {
    mInterfaces = value;
}
#method_after
public void setInterfaces(List<VmNetworkInterface> value) {
    mVmStatic.setInterfaces(value);
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getImages() {
    return mImages;
}
#method_after
public ArrayList<DiskImage> getImages() {
    return mVmStatic.getImages();
}
#end_block

#method_before
public void setImages(java.util.ArrayList<DiskImage> value) {
    mImages = value;
}
#method_after
public void setImages(ArrayList<DiskImage> value) {
    mVmStatic.setImages(value);
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Events are not available in Java:
// public event PropertyChangedEventHandler PropertyChanged;
protected void OnPropertyChanged(PropertyChangedEventArgs e) {
    /* if (PropertyChanged != null) */
    {
    /* PropertyChanged(this, e); */
    }
}
#method_after
protected void OnPropertyChanged(PropertyChangedEventArgs e) {
}
#end_block

#method_before
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getguest_last_login_time() != null && (getguest_last_logout_time() == null || getguest_last_login_time().compareTo(getguest_last_logout_time()) > 0)) {
        setguest_last_logout_time(new java.util.Date());
    }
}
#method_after
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getguest_last_login_time() != null && (getguest_last_logout_time() == null || getguest_last_login_time().compareTo(getguest_last_logout_time()) > 0)) {
        setguest_last_logout_time(new Date());
    }
}
#end_block

#method_before
@XmlElement(name = "ActualDiskWithSnapshotsSize")
public double getActualDiskWithSnapshotsSize() {
    if (_actualDiskWithSnapthotsSize == 0 && getDiskMap() != null) {
        for (DiskImage disk : getDiskMap().values()) {
            _actualDiskWithSnapthotsSize += disk.getActualDiskWithSnapshotsSize();
        }
    }
    return _actualDiskWithSnapthotsSize;
}
#method_after
public double getActualDiskWithSnapshotsSize() {
    if (_actualDiskWithSnapthotsSize == 0 && getDiskMap() != null) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                _actualDiskWithSnapthotsSize += ((DiskImage) disk).getActualDiskWithSnapshotsSize();
            }
        }
    }
    return _actualDiskWithSnapthotsSize;
}
#end_block

#method_before
@XmlElement(name = "DiskSize")
public double getDiskSize() {
    if (_diskSize == 0) {
        for (DiskImage disk : getDiskMap().values()) {
            _diskSize += disk.getsize() / Double.valueOf(1024 * 1024 * 1024);
        }
    }
    return _diskSize;
}
#method_after
public double getDiskSize() {
    if (_diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                _diskSize += ((DiskImage) disk).getsize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return _diskSize;
}
#end_block

#method_before
public void setStaticData(VmStatic value) {
    mVmStatic = value;
}
#method_after
public void setStaticData(VmStatic value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic = value;
}
#end_block

#method_before
@XmlElement
public String getrun_on_vds_name() {
    return run_on_vds_nameField;
}
#method_after
public String getrun_on_vds_name() {
    return run_on_vds_nameField;
}
#end_block

#method_before
public DiskImage getDriveToImageMap(String drive) {
    DiskImage image = null;
    if (mDiskMap.containsKey(drive)) {
        image = mDiskMap.get(drive);
    }
    return image;
}
#method_after
public Disk getDriveToImageMap(String drive) {
    Disk image = null;
    if (mDiskMap.containsKey(drive)) {
        image = mDiskMap.get(drive);
    }
    return image;
}
#end_block

#method_before
public Map<String, DiskImage> getDiskMap() {
    return mDiskMap;
}
#method_after
public Map<String, Disk> getDiskMap() {
    return mDiskMap;
}
#end_block

#method_before
public void setDiskMap(Map<String, DiskImage> diskMap) {
    mDiskMap = diskMap;
}
#method_after
public void setDiskMap(Map<String, Disk> diskMap) {
    mDiskMap = diskMap;
}
#end_block

#method_before
@XmlElement(name = "MinAllocatedMem")
public int getMinAllocatedMem() {
    return mVmStatic.getMinAllocatedMem();
}
#method_after
public int getMinAllocatedMem() {
    return mVmStatic.getMinAllocatedMem();
}
#end_block

#method_before
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct acccess to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    _diskList.add(image);
}
#method_after
// This function is left only to leave the option of creating a VM without
// having all the data in the DB
// Currently it is used mainly by tests and VdcClient (for direct access to
// the VDS)
public void addDriveToImageMap(String drive, DiskImage image) {
    mDiskMap.put(drive, image);
    getDiskList().add(image);
}
#end_block

#method_before
// public string qemuAudioDrv;
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setelapsed_time(vmStatistics.getelapsed_time());
    setusage_network_percent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setcpu_sys(vmStatistics.getcpu_sys());
    setcpu_user(vmStatistics.getcpu_user());
    if ((getcpu_sys() != null) && (getcpu_user() != null)) {
        // VB & C# TO JAVA CONVERTER TODO TASK: Arithmetic operations
        // involving nullable type instances are not converted to null-value
        // logic:
        // if statement will overcome Arithmetic operations problem
        Double percent = (getcpu_sys() + getcpu_user()) / new Double(vm.getnum_of_cpus());
        setusage_cpu_percent(percent.intValue());
        if (getusage_cpu_percent() != null && getusage_cpu_percent() > 100) {
            setusage_cpu_percent(100);
        }
    }
    // -------- memory --------------
    setusage_mem_percent(vmStatistics.getusage_mem_percent());
}
#method_after
// public string qemuAudioDrv;
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setelapsed_time(vmStatistics.getelapsed_time());
    setusage_network_percent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setcpu_sys(vmStatistics.getcpu_sys());
    setcpu_user(vmStatistics.getcpu_user());
    if ((getcpu_sys() != null) && (getcpu_user() != null)) {
        Double percent = (getcpu_sys() + getcpu_user()) / new Double(vm.getnum_of_cpus());
        setusage_cpu_percent(percent.intValue());
        if (getusage_cpu_percent() != null && getusage_cpu_percent() > 100) {
            setusage_cpu_percent(100);
        }
    }
    // -------- memory --------------
    setusage_mem_percent(vmStatistics.getusage_mem_percent());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (super.equals(obj)) {
        return true;
    }
    VM eq = (VM) ((obj instanceof VM) ? obj : null);
    if (eq != null) {
        if (eq.getvm_guid().equals(this.getvm_guid())) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    if (super.equals(obj)) {
        return true;
    }
    VM eq = (VM) ((obj instanceof VM) ? obj : null);
    if (eq != null) {
        if (eq.getId().equals(this.getId())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "VmPoolName")
public String getVmPoolName() {
    return mVmPoolName;
// string returnValue = null;
// vm_pool_map map = DbFacade.Instance.GetVmPoolsMapByVmGuid(vm_guid);
// if (map != null)
// {
// vm_pools pool =
// DbFacade.Instance.GetVmPoolByVmPoolId(map.vm_pool_id.Value);
// if (pool != null)
// {
// returnValue = pool.vm_pool_name;
// }
// }
// return returnValue;
}
#method_after
public String getVmPoolName() {
    return mVmPoolName;
}
#end_block

#method_before
// VB & C# TO JAVA CONVERTER TODO TASK: Java annotations will not correspond
@XmlElement(name = "VmPoolId", nillable = true)
public NGuid getVmPoolId() {
    return mVmPoolId;
// int? returnValue = null;
// vm_pool_map map = DbFacade.Instance.GetVmPoolsMapByVmGuid(vm_guid);
// if (map != null)
// {
// vm_pools pool =
// DbFacade.Instance.GetVmPoolByVmPoolId(map.vm_pool_id.Value);
// if (pool != null)
// {
// returnValue = pool.vm_pool_id;
// }
// }
// return returnValue;
}
#method_after
public NGuid getVmPoolId() {
    return mVmPoolId;
}
#end_block

#method_before
@XmlElement(name = "TransparentHugePages")
public boolean getTransparentHugePages() {
    return this.transparentHugePages;
}
#method_after
public boolean getTransparentHugePages() {
    return this.transparentHugePages;
}
#end_block

#method_before
@Override
public Object getQueryableId() {
    return getvm_guid();
}
#method_after
@Override
public Object getQueryableId() {
    return getId();
}
#end_block

#method_before
@Override
public java.util.ArrayList<String> getChangeablePropertiesList() {
    return _vmProperties;
}
#method_after
@Override
public ArrayList<String> getChangeablePropertiesList() {
    return _vmProperties;
}
#end_block

#method_before
public java.util.ArrayList<DiskImage> getDiskList() {
    return _diskList;
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    return mVmStatic.getDiskList();
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, java.util.Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem" });
    mUpdateVmsStatic.AddFields(java.util.Arrays.asList(new Enum[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "vmPayload" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties", "images", "interfaces" }));
}
#end_block

#method_before
public static boolean VerifyAddVm(java.util.ArrayList<String> reasons, int vmsCount, Object vmTemplateId, Guid storagePoolId, Guid storageDomainId, boolean checkVmTemplateImages, boolean checkTemplateLock, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            } else if (checkVmTemplateImages) {
                returnValue = VmTemplateCommand.isVmTemplateImagesReady((Guid) vmTemplateId, storageDomainId, reasons, true, checkTemplateLock, true, true);
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(ArrayList<String> reasons, int vmsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < vmsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else if (reasons != null) {
            reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
        }
    }
    return returnValue;
}
#end_block

#method_before
public static void unlockVm(final VmDynamic vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm, vm.getstatus());
            UnLockVm(vm.getId());
            compensationContext.stateChanged();
            return null;
        }
    });
}
#method_after
public static void unlockVm(final VmDynamic vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm, vm.getstatus());
            vm.setstatus(VMStatus.Down);
            UnLockVm(vm.getId());
            compensationContext.stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
public static void UnLockVm(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    if (vm.getstatus() == VMStatus.ImageLocked) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vmId, VMStatus.Down));
    } else {
        log.errorFormat("Trying to unlock vm {0} in status {1} - not moving to down!", vm.getvm_name(), vm.getstatus());
    }
}
#method_after
public static void UnLockVm(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDAO().get(vmId);
    if (vm.getstatus() == VMStatus.ImageLocked) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vmId, VMStatus.Down));
    } else {
        log.errorFormat("Trying to unlock vm {0} in status {1} - not moving to down!", vm.getvm_name(), vm.getstatus());
    }
}
#end_block

#method_before
public static void updateDisksFromDb(VM vm) {
    List<DiskImage> imageList = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getvm_guid());
    for (DiskImage image : imageList) {
        if (image.getactive() != null && image.getactive()) {
            vm.getDiskMap().put(image.getinternal_drive_mapping(), image);
            vm.getDiskList().add(image);
        }
    }
}
#method_after
public static void updateDisksFromDb(VM vm) {
    List<Disk> imageList = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    updateDisksForVm(vm, imageList);
}
#end_block

#method_before
private static String getAppName(final String part, final String appName) {
    if (StringUtils.contains(part, appName + "64")) {
        // to its name.
        return appName + "64";
    } else {
        return appName;
    }
}
#method_after
private static String getAppName(final String part, final String appName) {
    if (StringUtils.contains(part, appName + "64")) {
        // to its name.
        return appName + "64";
    }
    return appName;
}
#end_block

#method_before
public static boolean isMemorySizeLegal(VmOsType osType, int memSizeInMB, java.util.ArrayList<String> reasons, String clsuter_version) {
    boolean result = VmValidationUtils.isMemorySizeLegal(osType, memSizeInMB, clsuter_version);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_MEMORY_SIZE.toString());
        reasons.add(String.format("$minMemorySize %s", VmValidationUtils.getMinMemorySizeInMb()));
        reasons.add(String.format("$maxMemorySize %s", VmValidationUtils.getMaxMemorySizeInMb(osType, clsuter_version)));
    }
    return result;
}
#method_after
public static boolean isMemorySizeLegal(VmOsType osType, int memSizeInMB, ArrayList<String> reasons, String clsuter_version) {
    boolean result = VmValidationUtils.isMemorySizeLegal(osType, memSizeInMB, clsuter_version);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_MEMORY_SIZE.toString());
        reasons.add(String.format("$minMemorySize %s", VmValidationUtils.getMinMemorySizeInMb()));
        reasons.add(String.format("$maxMemorySize %s", VmValidationUtils.getMaxMemorySizeInMb(osType, clsuter_version)));
    }
    return result;
}
#end_block

#method_before
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREAY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
public void RemoveAsyncRunningVm(Guid vmId) {
    _asyncRunningVms.remove(vmId);
    getEventListener().RemoveAsyncRunningCommand(vmId);
}
#method_after
public void RemoveAsyncRunningVm(Guid vmId) {
    _asyncRunningVms.remove(vmId);
    getEventListener().removeAsyncRunningCommand(vmId);
}
#end_block

#method_before
public void SuccededToRunVm(Guid vmId, Guid vdsId) {
    IVdsEventListener listener = _asyncRunningVms.get(vmId);
    if (listener != null) {
        listener.RunningSucceded(vmId);
    }
    RemoveAsyncRunningVm(vmId);
}
#method_after
public void SuccededToRunVm(Guid vmId, Guid vdsId) {
    IVdsEventListener listener = _asyncRunningVms.get(vmId);
    if (listener != null) {
        listener.runningSucceded(vmId);
    }
    RemoveAsyncRunningVm(vmId);
}
#end_block

#method_before
public void RerunFailedCommand(Guid vmId, Guid vdsId) {
    IVdsEventListener listener = _asyncRunningVms.remove(vmId);
    // remove async record from broker only
    if (listener != null) {
        listener.Rerun(vmId);
    }
}
#method_after
public void RerunFailedCommand(Guid vmId, Guid vdsId) {
    IVdsEventListener listener = _asyncRunningVms.remove(vmId);
    // remove async record from broker only
    if (listener != null) {
        listener.rerun(vmId);
    }
}
#end_block

#method_before
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#method_after
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#end_block

#method_before
public void HandleVdsFinishedInit(Guid vdsId) {
    java.util.HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().ProcessOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#method_after
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#end_block

#method_before
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getstatus();
        switch(vds.getstatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Problematic:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getstatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.UpdateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setpending_vcpus_count(0);
        vdsManager.UpdateDynamicData(vds.getDynamicData());
    }
    _vdsManagersDict.put(vds.getvds_id(), vdsManager);
    log.infoFormat("ResourceManager::AddVds - VDS {0} was added to the Resource Manager", vds.getvds_id());
}
#method_after
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getstatus();
        switch(vds.getstatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Problematic:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getstatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.UpdateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setpending_vcpus_count(0);
        vdsManager.UpdateDynamicData(vds.getDynamicData());
    }
    _vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("ResourceManager::AddVds - VDS {0} was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public void SetVmUnknown(VM vm) {
    RemoveAsyncRunningVm(vm.getvm_guid());
    InternalSetVmStatus(vm, VMStatus.Unknown);
    // log VM transition to unknown status
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVmId(vm.getvm_guid());
    AuditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    storeVm(vm);
}
#method_after
public void SetVmUnknown(VM vm) {
    RemoveAsyncRunningVm(vm.getId());
    InternalSetVmStatus(vm, VMStatus.Unknown);
    // log VM transition to unknown status
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVmId(vm.getId());
    AuditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    storeVm(vm);
}
#end_block

#method_before
public void SetVmDown(VM vm) {
    RemoveAsyncRunningVm(vm.getvm_guid());
    InternalSetVmStatus(vm, VMStatus.Down);
    storeVm(vm);
}
#method_after
public void SetVmDown(VM vm) {
    RemoveAsyncRunningVm(vm.getId());
    InternalSetVmStatus(vm, VMStatus.Down);
    storeVm(vm);
}
#end_block

#method_before
private void resetVmAttributes(VM vm) {
    vm.setusage_network_percent(0);
    vm.setelapsed_time(Double.valueOf(0));
    vm.setcpu_sys(new Double(0));
    vm.setcpu_user(new Double(0));
    vm.setusage_cpu_percent(0);
    vm.setusage_mem_percent(0);
    vm.setmigrating_to_vds(null);
    vm.setrun_on_vds_name("");
    vm.setguest_cur_user_name(null);
    vm.setguest_cur_user_id(null);
    vm.setConsoleUserName(null);
    vm.setConsoleUserId(null);
    vm.setguest_os(null);
    vm.setvm_ip(null);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(new Double(0));
        statistics.setTransmitRate(new Double(0));
        statistics.setReceiveRate(new Double(0));
        statistics.setReceiveDropRate(new Double(0));
    }
}
#method_after
private void resetVmAttributes(VM vm) {
    vm.setusage_network_percent(0);
    vm.setelapsed_time(Double.valueOf(0));
    vm.setcpu_sys(new Double(0));
    vm.setcpu_user(new Double(0));
    vm.setusage_cpu_percent(0);
    vm.setusage_mem_percent(0);
    vm.setmigrating_to_vds(null);
    vm.setrun_on_vds_name("");
    vm.setguest_cur_user_name(null);
    vm.setguest_cur_user_id(null);
    vm.setConsoleUserId(null);
    vm.setguest_os(null);
    vm.setvm_ip(null);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    for (VmNetworkInterface ifc : interfaces) {
        NetworkStatistics statistics = ifc.getStatistics();
        statistics.setTransmitDropRate(new Double(0));
        statistics.setTransmitRate(new Double(0));
        statistics.setReceiveRate(new Double(0));
        statistics.setReceiveDropRate(new Double(0));
    }
}
#end_block

#method_before
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, java.util.ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#method_after
public void UpdateVdsDomainsData(Guid vdsId, String vdsName, Guid storagePoolId, ArrayList<VDSDomainsData> vdsDomainData) {
    IrsBrokerCommand.UpdateVdsDomainsData(vdsId, vdsName, storagePoolId, vdsDomainData);
}
#end_block

#method_before
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "num_of_cpus", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params" });
}
#method_after
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "num_of_cpus", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params", "images", "interfaces", "quotaId", "quotaName" });
}
#end_block

#method_before
public static void UpdateDisksFromDb(VmTemplate vmt) {
    vmt.getDiskMap().clear();
    vmt.getDiskImageMap().clear();
    vmt.getDiskList().clear();
    List<DiskImageTemplate> diskList = DbFacade.getInstance().getDiskImageTemplateDAO().getAllByVmTemplate(vmt.getId());
    for (DiskImageTemplate dit : diskList) {
        vmt.getDiskMap().put(dit.getinternal_drive_mapping(), dit);
        // Translation from number of sectors to GB.
        vmt.setSizeGB(Double.valueOf(dit.getsize()) / Double.valueOf((1024 * 1024 * 1024)));
        DiskImage image = DbFacade.getInstance().getDiskImageDAO().getSnapshotById(dit.getId());
        if (image != null) {
            vmt.getDiskImageMap().put(dit.getinternal_drive_mapping(), image);
            vmt.getDiskList().add(image);
        }
    }
}
#method_after
public static void UpdateDisksFromDb(VmTemplate vmt) {
    vmt.getDiskMap().clear();
    vmt.getDiskImageMap().clear();
    vmt.getDiskList().clear();
    List<Disk> diskList = DbFacade.getInstance().getDiskDao().getAllForVm(vmt.getId());
    for (Disk dit : diskList) {
        DiskImage diskImage = (DiskImage) dit;
        vmt.getDiskMap().put(dit.getinternal_drive_mapping(), diskImage);
        // Translation from number of sectors to GB.
        vmt.setSizeGB(Double.valueOf(dit.getsize()) / Double.valueOf((1024 * 1024 * 1024)));
        vmt.getDiskImageMap().put(dit.getinternal_drive_mapping(), diskImage);
        vmt.getDiskList().add(diskImage);
    }
}
#end_block

#method_before
@Override
public VM get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeRead("GetVmByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public VM get(Guid id) {
    return get(id, null, false);
}
#end_block

#method_before
@Override
public VM get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeRead("GetVmByVmGuid", mapper, parameterSource);
}
#method_after
@Override
public VM get(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeRead("GetVmByVmGuid", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vm_guid", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public VM getForHibernationImage(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_id", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeRead("GetVmByHibernationImageId", mapper, parameterSource);
}
#method_after
@Override
public VM getForHibernationImage(Guid id) {
    return getCallsHandler().executeRead("GetVmByHibernationImageId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("image_id", id));
}
#end_block

#method_before
@Override
public VM getForImage(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_guid", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeRead("GetVmByImageId", mapper, parameterSource);
}
#method_after
@Override
public Map<Boolean, List<VM>> getForImage(Guid id) {
    Map<Boolean, List<VM>> result = new HashMap<Boolean, List<VM>>();
    List<VMWithPlugInfo> vms = getCallsHandler().executeReadList("GetVmsByImageId", VMWithPlugInfoRowMapper.instance, getCustomMapSqlParameterSource().addValue("image_guid", id));
    for (VMWithPlugInfo vm : vms) {
        MultiValueMapUtils.addToMap(vm.isPlugged(), vm.getVM(), result);
    }
    return result;
}
#end_block

#method_before
@Override
public VM getForImageGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("image_group_id", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeRead("GetVmByImageGroupId", mapper, parameterSource);
}
#method_after
@Override
public VM getForImageGroup(Guid id) {
    return getCallsHandler().executeRead("GetVmByImageGroupId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("image_group_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAllForUser(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    return getCallsHandler().executeReadList("GetVmsByUserId", new VMRowMapper(), parameterSource);
}
#method_after
@Override
public List<VM> getAllForUser(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByUserId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("user_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAllForUserWithGroupsAndUserRoles(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", id);
    return getCallsHandler().executeReadList("GetVmsByUserIdWithGroupsAndUserRoles", new VMRowMapper(), parameterSource);
}
#method_after
@Override
public List<VM> getAllForUserWithGroupsAndUserRoles(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByUserIdWithGroupsAndUserRoles", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("user_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAllForAdGroupByName(String name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("ad_group_names", name);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetVmsByAdGroupNames", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllForAdGroupByName(String name) {
    return getCallsHandler().executeReadList("GetVmsByAdGroupNames", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("ad_group_names", name));
}
#end_block

#method_before
@Override
public List<VM> getAllWithTemplate(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vmt_guid", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetVmsByVmtGuid", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllWithTemplate(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByVmtGuid", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vmt_guid", id));
}
#end_block

#method_before
@Override
public List<VM> getAllRunningForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetVmsRunningOnVds", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllRunningForVds(Guid id) {
    return getCallsHandler().executeReadList("GetVmsRunningOnVds", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAllForDedicatedPowerClientByVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("dedicated_vm_for_vds", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetVmsDedicatedToPowerClientByVdsId", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllForDedicatedPowerClientByVds(Guid id) {
    return getCallsHandler().executeReadList("GetVmsDedicatedToPowerClientByVdsId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("dedicated_vm_for_vds", id));
}
#end_block

#method_before
@Override
public Map<Guid, VM> getAllRunningByVds(Guid id) {
    HashMap<Guid, VM> map = new HashMap<Guid, VM>();
    List<VM> vms = getAllRunningForVds(id);
    for (VM vm : vms) {
        map.put(vm.getvm_guid(), vm);
    }
    return map;
}
#method_after
@Override
public Map<Guid, VM> getAllRunningByVds(Guid id) {
    HashMap<Guid, VM> map = new HashMap<Guid, VM>();
    for (VM vm : getAllRunningForVds(id)) {
        map.put(vm.getId(), vm);
    }
    return map;
}
#end_block

#method_before
@Override
public List<VM> getAllUsingQuery(String query) {
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, mapper);
}
#method_after
@Override
public List<VM> getAllUsingQuery(String query) {
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, VMRowMapper.instance);
}
#end_block

#method_before
@Override
public List<VM> getAllForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetVmsByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllForStorageDomain(Guid id) {
    return getCallsHandler().executeReadList("GetVmsByStorageDomainId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_domain_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAllRunningForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetRunningVmsByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAllRunningForStorageDomain(Guid id) {
    return getCallsHandler().executeReadList("GetRunningVmsByStorageDomainId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_domain_id", id));
}
#end_block

#method_before
@Override
public List<VM> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<VM> mapper = new VMRowMapper();
    return getCallsHandler().executeReadList("GetAllFromVms", mapper, parameterSource);
}
#method_after
@Override
public List<VM> getAll() {
    return getCallsHandler().executeReadList("GetAllFromVms", VMRowMapper.instance, getCustomMapSqlParameterSource());
}
#end_block

#method_before
@Override
public void save(VM vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getvm_guid()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect());
    getCallsHandler().executeModification("InsertVm", parameterSource);
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()));
}
#end_block

#method_before
@Override
public void remove(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_guid", id);
    getCallsHandler().executeModification("DeleteVm", parameterSource);
}
#method_after
@Override
public void remove(Guid id) {
    getCallsHandler().executeModification("DeleteVm", getCustomMapSqlParameterSource().addValue("vm_guid", id));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setvm_guid(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setvm_last_up_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_up_time")));
    entity.setvm_last_boot_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_boot_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setConsoleUserName(rs.getString("console_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    // entity.setnum_of_cpus(rs.getInt("num_of_cpus"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.sethypervisor_type(HypervisorType.forValue(rs.getInt("hypervisor_type")));
    entity.setoperation_mode(OperationMode.forValue(rs.getInt("operation_mode")));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
    VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(exitStatus);
    entity.setVmPauseStatus(pauseStatus);
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setvm_last_up_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_up_time")));
    entity.setvm_last_boot_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_boot_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.sethypervisor_type(HypervisorType.forValue(rs.getInt("hypervisor_type")));
    entity.setoperation_mode(OperationMode.forValue(rs.getInt("operation_mode")));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    return entity;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Load the description of the virtual machine from the database:
    final Guid vmId = getVmId();
    final VM vm = DbFacade.getInstance().getVmDAO().getById(vmId);
    // Check that the virtual machine exists:
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getstatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // the console to any user:
    if (vm.getAllowConsoleReconnect()) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
        return true;
    }
    // to the console, regardless of the previously connected user:
    if (checkUserAuthorization(ActionGroup.RECONNECT_TO_VM, MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
        return true;
    }
    // For normal users, with no special privileges, only the first user that connected to
    // the console is allowed to reconnect:
    final String currentName = getCurrentUser().getUserName();
    final NGuid currentId = getCurrentUser().getUserId();
    final String previousName = vm.getConsoleUserName();
    final NGuid previousId = vm.getConsoleUserId();
    if (previousId != null && !previousId.equals(currentId)) {
        log.warnFormat("User \"{0}\" is trying to set a ticket for virtual machine \"{1}\" but the machine is already in use by \"{2}\".", currentName, vm.getvm_name(), previousName);
        log.warnFormat("The id of user \"{0}\" is \"{1}\".", currentName, currentId);
        log.warnFormat("The id of user \"{0}\" is \"{1}\".", previousName, previousId);
        log.warnFormat("The id of virtual machine \"{0}\" is \"{1}\".", vm.getvm_name(), vmId);
        log.warnFormat("The ticket will not be set.");
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_USE_BY_OTHER_USER);
        return false;
    }
    // Try to save the new user to the database and proceed only if the previous user in
    // the database is null (this is needed to prevent races between different users trying
    // to access the console of the same virtual machine simultaneously):
    vm.setConsoleUserName(currentName);
    vm.setConsoleUserId(currentId);
    final boolean saved = DbFacade.getInstance().getVmDynamicDAO().saveFirstConsoleUser(vmId, currentId, currentName);
    if (!saved) {
        log.warnFormat("Failed to set console user to \"{0}\" for virtual machine \"{1}\".", currentName, vm.getvm_name());
        log.warnFormat("This probably means that two users are trying to connect to the console simultaneously.");
        log.warnFormat("The id of user \"{0}\" is \"{1}\".", currentName, currentId);
        log.warnFormat("The id of virtual machine \"{0}\" is \"{1}\".", vm.getvm_name(), vmId);
        log.warnFormat("The ticket will not be set.");
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_USE_BY_OTHER_USER);
        return false;
    }
    // If we are here then the connection should be granted:
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SET);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TICKET);
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getstatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // Check that the user can connect to the console:
    return canConnectToConsole();
}
#end_block

#method_before
@Override
protected void Perform() {
    // Generate the ticket if needed:
    if (StringHelper.isNullOrEmpty(mTicket)) {
        mTicket = Ticketing.GenerateOTP();
    }
    // Send the ticket to the virtual machine:
    setSucceeded(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(getVdsId(), getVmId(), mTicket, mValidTime)).getSucceeded());
    // Return the ticket:
    setActionReturnValue(mTicket);
}
#method_after
@Override
protected void Perform() {
    // a ticket):
    if (StringHelper.isNullOrEmpty(mTicket)) {
        mTicket = Ticketing.GenerateOTP();
    }
    // Update the dynamic information of the virtual machine in memory (we need it
    // to update the database later):
    // Check that the virtual machine exists:
    final VM vm = getVm();
    final IVdcUser user = getCurrentUser();
    vm.setConsoleUserId(user.getUserId());
    // If the virtual machine has the allow reconnect then we just have to save
    // the user name and the user id to the database, regardless of what was there
    // before and without locking.
    // 
    // In any other situation we try to save the new user to the database and proceed
    // only if the previous user in the database is null. This is needed to prevent
    // races between different users trying to access the console of the same virtual
    // machine simultaneously.
    final VmDynamicDAO dao = DbFacade.getInstance().getVmDynamicDAO();
    if (vm.getAllowConsoleReconnect()) {
        dao.update(vm.getDynamicData());
        sendTicket();
    } else {
        final boolean saved = dao.updateConsoleUserWithOptimisticLocking(vm.getDynamicData());
        if (saved) {
            sendTicket();
        } else {
            dontSendTicket();
        }
    }
}
#end_block

#method_before
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#method_after
@Override
public void save(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect());
    getCallsHandler().executeModification("InsertVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#method_after
@Override
public void update(VmStatic vm) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("hypervisor_type", vm.gethypervisor_type()).addValue("operation_mode", vm.getoperation_mode()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect());
    getCallsHandler().executeModification("UpdateVmStatic", parameterSource);
}
#end_block

#method_before
@Override
public VmTemplate get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vmt_guid", id);
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeRead("GetVmTemplateByVmtGuid", mapper, parameterSource);
}
#method_after
@Override
public VmTemplate get(Guid id) {
    return get(id, null, false);
}
#end_block

#method_before
@Override
public VmTemplate get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vmt_guid", id);
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeRead("GetVmTemplateByVmtGuid", mapper, parameterSource);
}
#method_after
@Override
public VmTemplate get(Guid id, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeRead("GetVmTemplateByVmtGuid", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("vmt_guid", id).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VmTemplate> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeReadList("GetAllFromVmTemplates", mapper, parameterSource);
}
#method_after
@Override
public List<VmTemplate> getAll() {
    return getCallsHandler().executeReadList("GetAllFromVmTemplates", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VmTemplate> getAllForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeReadList("GetVmTemplatesByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<VmTemplate> getAllForStorageDomain(Guid storageDomain) {
    return getAllForStorageDomain(storageDomain, null, false);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VmTemplate> getAllForStorageDomain(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("storage_domain_id", id);
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeReadList("GetVmTemplatesByStorageDomainId", mapper, parameterSource);
}
#method_after
@Override
public List<VmTemplate> getAllForStorageDomain(Guid storageDomain, Guid userID, boolean isFiltered) {
    return getCallsHandler().executeReadList("GetVmTemplatesByStorageDomainId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomain).addValue("user_id", userID).addValue("is_filtered", isFiltered));
}
#end_block

#method_before
@Override
public List<VmTemplate> getAllWithQuery(String query) {
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, mapper);
}
#method_after
@Override
public List<VmTemplate> getAllWithQuery(String query) {
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, VMTemplateRowMapper.instance);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VmTemplate> getAllForVdsGroup(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_group_id", id);
    ParameterizedRowMapper<VmTemplate> mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeReadList("GetVmTemplateByVdsGroupId", mapper, parameterSource);
}
#method_after
@Override
public List<VmTemplate> getAllForVdsGroup(Guid id) {
    return getCallsHandler().executeReadList("GetVmTemplateByVdsGroupId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_id", id));
}
#end_block

#method_before
@Override
public void save(VmTemplate template) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params());
    getCallsHandler().executeModification("InsertVmTemplate", parameterSource);
}
#method_after
@Override
public void save(VmTemplate template) {
    getCallsHandler().executeModification("InsertVmTemplate", getInsertOrUpdateParameters(template));
}
#end_block

#method_before
@Override
public void update(VmTemplate template) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("hypervisor_type", template.gethypervisor_type()).addValue("operation_mode", template.getoperation_mode()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params());
    getCallsHandler().executeModification("UpdateVmTemplate", parameterSource);
}
#method_after
@Override
public void update(VmTemplate template) {
    getCallsHandler().executeModification("UpdateVmTemplate", getInsertOrUpdateParameters(template));
}
#end_block

#method_before
@Override
public void updateStatus(Guid id, VmTemplateStatus status) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vmt_guid", id).addValue("status", status);
    getCallsHandler().executeModification("UpdateVmTemplateStatus", parameterSource);
}
#method_after
@Override
public void updateStatus(Guid id, VmTemplateStatus status) {
    getCallsHandler().executeModification("UpdateVmTemplateStatus", getCustomMapSqlParameterSource().addValue("vmt_guid", id).addValue("status", status));
}
#end_block

#method_before
@Override
public void remove(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vmt_guid", id);
    getCallsHandler().executeModification("DeleteVmTemplates", parameterSource);
}
#method_after
@Override
public void remove(Guid id) {
    getCallsHandler().executeModification("DeleteVmTemplates", getCustomMapSqlParameterSource().addValue("vmt_guid", id));
}
#end_block

#method_before
@Override
public List<VmTemplate> getTemplatesWithPermittedAction(Guid userId, ActionGroup actionGroup) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", userId).addValue("action_group_id", actionGroup.getId());
    VMTemplateRowMapper mapper = new VMTemplateRowMapper();
    return getCallsHandler().executeReadList("fn_perms_get_templates_with_permitted_action", mapper, parameterSource);
}
#method_after
@Override
public List<VmTemplate> getTemplatesWithPermittedAction(Guid userId, ActionGroup actionGroup) {
    return getCallsHandler().executeReadList("fn_perms_get_templates_with_permitted_action", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("user_id", userId).addValue("action_group_id", actionGroup.getId()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getapp_list()).addValue("guest_cur_user_id", vm.getguest_cur_user_id()).addValue("guest_cur_user_name", vm.getguest_cur_user_name()).addValue("console_user_id", vm.getConsoleUserId()).addValue("console_user_name", vm.getConsoleUserName()).addValue("guest_last_login_time", vm.getguest_last_login_time()).addValue("guest_last_logout_time", vm.getguest_last_logout_time()).addValue("guest_os", vm.getguest_os()).addValue("migrating_to_vds", vm.getmigrating_to_vds()).addValue("run_on_vds", vm.getrun_on_vds()).addValue("status", vm.getstatus()).addValue("vm_host", vm.getvm_host()).addValue("vm_ip", vm.getvm_ip()).addValue("vm_last_boot_time", vm.getvm_last_boot_time()).addValue("vm_last_up_time", vm.getvm_last_up_time()).addValue("vm_pid", vm.getvm_pid()).addValue("display", vm.getdisplay()).addValue("acpi_enable", vm.getacpi_enable()).addValue("session", vm.getsession()).addValue("display_ip", vm.getdisplay_ip()).addValue("display_type", vm.getdisplay_type()).addValue("kvm_enable", vm.getkvm_enable()).addValue("boot_sequence", vm.getboot_sequence()).addValue("display_secure_port", vm.getdisplay_secure_port()).addValue("utc_diff", vm.getutc_diff()).addValue("last_vds_run_on", vm.getlast_vds_run_on()).addValue("client_ip", vm.getclient_ip()).addValue("guest_requested_memory", vm.getguest_requested_memory()).addValue("hibernation_vol_handle", vm.gethibernation_vol_handle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getapp_list()).addValue("guest_cur_user_id", vm.getguest_cur_user_id()).addValue("guest_cur_user_name", vm.getguest_cur_user_name()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getguest_last_login_time()).addValue("guest_last_logout_time", vm.getguest_last_logout_time()).addValue("guest_os", vm.getguest_os()).addValue("migrating_to_vds", vm.getmigrating_to_vds()).addValue("run_on_vds", vm.getrun_on_vds()).addValue("status", vm.getstatus()).addValue("vm_host", vm.getvm_host()).addValue("vm_ip", vm.getvm_ip()).addValue("vm_last_boot_time", vm.getvm_last_boot_time()).addValue("vm_last_up_time", vm.getvm_last_up_time()).addValue("vm_pid", vm.getvm_pid()).addValue("display", vm.getdisplay()).addValue("acpi_enable", vm.getacpi_enable()).addValue("session", vm.getsession()).addValue("display_ip", vm.getdisplay_ip()).addValue("display_type", vm.getdisplay_type()).addValue("kvm_enable", vm.getkvm_enable()).addValue("boot_sequence", vm.getboot_sequence()).addValue("display_secure_port", vm.getdisplay_secure_port()).addValue("utc_diff", vm.getutc_diff()).addValue("last_vds_run_on", vm.getlast_vds_run_on()).addValue("client_ip", vm.getclient_ip()).addValue("guest_requested_memory", vm.getguest_requested_memory()).addValue("hibernation_vol_handle", vm.gethibernation_vol_handle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash());
}
#end_block

#method_before
@Override
protected ParameterizedRowMapper<VmDynamic> createEntityRowMapper() {
    return new ParameterizedRowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setapp_list(rs.getString("app_list"));
            entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
            entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
            entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
            entity.setConsoleUserName(rs.getString("console_user_name"));
            entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setguest_os(rs.getString("guest_os"));
            entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
            entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
            entity.setstatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setvm_host(rs.getString("vm_host"));
            entity.setvm_ip(rs.getString("vm_ip"));
            entity.setvm_last_boot_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_boot_time")));
            entity.setvm_last_up_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_up_time")));
            entity.setvm_pid((Integer) rs.getObject("vm_pid"));
            entity.setdisplay((Integer) rs.getObject("display"));
            entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
            entity.setsession(SessionState.forValue(rs.getInt("session")));
            entity.setdisplay_ip(rs.getString("display_ip"));
            entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
            entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
            entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
            entity.setutc_diff((Integer) rs.getObject("utc_diff"));
            entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
            entity.setclient_ip(rs.getString("client_ip"));
            entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
            entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            return entity;
        }
    };
}
#method_after
@Override
protected ParameterizedRowMapper<VmDynamic> createEntityRowMapper() {
    return new ParameterizedRowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setapp_list(rs.getString("app_list"));
            entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
            entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
            entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
            entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setguest_os(rs.getString("guest_os"));
            entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
            entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
            entity.setstatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setvm_host(rs.getString("vm_host"));
            entity.setvm_ip(rs.getString("vm_ip"));
            entity.setvm_last_boot_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_boot_time")));
            entity.setvm_last_up_time(DbFacadeUtils.fromDate(rs.getTimestamp("vm_last_up_time")));
            entity.setvm_pid((Integer) rs.getObject("vm_pid"));
            entity.setdisplay((Integer) rs.getObject("display"));
            entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
            entity.setsession(SessionState.forValue(rs.getInt("session")));
            entity.setdisplay_ip(rs.getString("display_ip"));
            entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
            entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
            entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
            entity.setutc_diff((Integer) rs.getObject("utc_diff"));
            entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
            entity.setclient_ip(rs.getString("client_ip"));
            entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
            entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            entity.setHash(rs.getString("hash"));
            return entity;
        }
    };
}
#end_block

#method_before
@Override
protected void Perform() {
    // Get a reference to the virtual machine:
    final VM vm = getVm();
    // Send the log on command to the virtual machine:
    final IVdcUser currentUser = getCurrentUser();
    final String domainController = currentUser != null ? currentUser.getDomainControler() : "";
    final String password = currentUser != null ? currentUser.getPassword() : "";
    setSucceeded(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmLogon, new VmLogonVDSCommandParameters(getVdsId(), vm.getvm_guid(), domainController, getUserName(), password)).getSucceeded());
    // database to reflect that the user is logged on:
    if (getSucceeded() && currentUser != null) {
        vm.setguest_cur_user_name(currentUser.getUserName());
        vm.setguest_cur_user_id(currentUser.getUserId());
        DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
    }
}
#method_after
@Override
protected void Perform() {
    // Get a reference to the virtual machine:
    final VM vm = getVm();
    // Send the log on command to the virtual machine:
    final IVdcUser currentUser = getCurrentUser();
    final String domainController = currentUser != null ? currentUser.getDomainControler() : "";
    final String password = currentUser != null ? currentUser.getPassword() : "";
    final boolean sentToVM = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmLogon, new VmLogonVDSCommandParameters(getVdsId(), vm.getId(), domainController, getUserName(), password)).getSucceeded();
    // database to reflect that the user is logged on:
    if (sentToVM && currentUser != null) {
        vm.setguest_cur_user_name(currentUser.getUserName());
        vm.setguest_cur_user_id(currentUser.getUserId());
        DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
    }
    // Done:
    setSucceeded(sentToVM);
}
#end_block

#method_before
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getvds_id() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#method_after
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getId() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#end_block

#method_before
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getvm_guid()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            status = CreateVm();
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status = null;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            if (connectLunDisks(getVdsId())) {
                status = CreateVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getvm_guid()).size() > 0) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    setActionReturnValue(VMStatus.Down);
    if (InitVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            ResumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && !getVm().getDiskList().isEmpty() && getVm().getstatus() != VMStatus.Suspended) {
                StatelessVmTreatment();
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                RunVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            // LINQ Vm.boot_sequence.toString().Contains(cd))
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence().toString().indexOf(cd) > -1) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#method_after
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence() == BootSequence.CD) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#end_block

#method_before
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getvm_guid()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getvm_guid());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getvm_guid(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, getCompensationContext());
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getvm_guid()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#method_after
private void StatelessVmTreatment() {
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#end_block

#method_before
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getvm_guid());
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getId(), new CommandContext(getExecutionContext()));
    setSucceeded(true);
}
#end_block

#method_before
protected VMStatus CreateVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Set path for initrd and kernel image.
    if (!StringHelper.isNullOrEmpty(getVm().getinitrd_url())) {
        getVm().setinitrd_url(getIsoPrefixFilePath(getVm().getinitrd_url()));
    }
    if (!StringHelper.isNullOrEmpty(getVm().getkernel_url())) {
        getVm().setkernel_url(getIsoPrefixFilePath(getVm().getkernel_url()));
    }
    return (VMStatus) Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initVdsCreateVmParams(), this).getReturnValue();
}
#method_after
protected VMStatus CreateVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Set path for initrd and kernel image.
    if (!StringHelper.isNullOrEmpty(getVm().getinitrd_url())) {
        getVm().setinitrd_url(getIsoPrefixFilePath(getVm().getinitrd_url()));
    }
    if (!StringHelper.isNullOrEmpty(getVm().getkernel_url())) {
        getVm().setkernel_url(getIsoPrefixFilePath(getVm().getkernel_url()));
    }
    VMStatus vmStatus = (VMStatus) Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initVdsCreateVmParams(), this).getReturnValue();
    // After VM was create (or not), we can remove the quota vds group memory.
    removeQuotaCommandLeftOver();
    return vmStatus;
}
#end_block

#method_before
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserName(null);
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#method_after
protected boolean InitVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        HandleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringHelper.isNullOrEmpty(getVm().getFloppyPath())) {
            DbFacade.getInstance().getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#end_block

#method_before
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getid(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.regexToolPattern).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.guestToolsSetupIsoPrefix, selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#method_after
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getId(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.getRegexToolPattern()).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getvm_guid());
        Guid storagePoolId = vm.getstorage_pool_id();
        // and no other boot devices are configured
        if (vmImages.isEmpty() && StringHelper.EqOp(boot_sequence.toString(), BootSequence.C.toString())) {
            message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString());
            retValue = false;
        } else {
            if ((findActiveISODomain(storagePoolId) == null) && boot_sequence.toString().length() > 0 && (boot_sequence.toString().charAt(0) == cd)) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getvm_guid()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else {
                    if (vmImages.size() > 0) {
                        Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                        // if VM is not HA VM
                        if (!ImagesHandler.PerformImagesChecks(vm.getvm_guid(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                            retValue = false;
                        } else // Check if iso and floppy path exists
                        if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                            retValue = false;
                        } else {
                            boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getvm_guid())).getReturnValue()).booleanValue();
                            if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                                }
                            } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                                VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                                if (vds.getstatus() != VDSStatus.Up) {
                                    retValue = false;
                                    if (message != null) {
                                        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                    }
                                }
                            }
                            boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                            if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                            }
                            // if the VM itself is stateless or run once as stateless
                            if (retValue && isStatelessVm && vm.getauto_startup()) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                            }
                            retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                            /**
                             * only if can do action ok then check with actions matrix that status is valid for this
                             * action
                             */
                            if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                                retValue = false;
                            }
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator, VmPropertiesUtils vmPropsUtils) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = vmPropsUtils.validateVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<Disk> vmDisks = getPluggedDisks(vm);
        if (boot_sequence == BootSequence.C && vmDisks.size() == 0) {
            String messageStr = !vmDisks.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmDisks.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    // if VM is not HA VM
                    if (retValue && !ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmDisks)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vm.getId())) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, java.util.ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#method_after
@SuppressWarnings("unchecked")
protected static boolean validateIsoPath(Guid storageDomainId, RunVmParams runParams, ArrayList<String> messages) {
    if (!StringHelper.isNullOrEmpty(runParams.getDiskPath())) {
        if (storageDomainId == null) {
            messages.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
            return false;
        }
        boolean retValForIso = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllIsoImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getDiskPath())) {
                        retValForIso = true;
                        break;
                    }
                }
            }
        }
        if (!retValForIso) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_ISO_IMAGE_PATH.toString());
            return false;
        }
    }
    if (!StringHelper.isNullOrEmpty(runParams.getFloppyPath())) {
        boolean retValForFloppy = false;
        VdcQueryReturnValue ret = Backend.getInstance().runInternalQuery(VdcQueryType.GetAllFloppyImagesList, new GetAllIsoImagesListParameters(storageDomainId));
        if (ret != null && ret.getReturnValue() != null && ret.getSucceeded()) {
            List<RepoFileMetaData> repoFileNameList = (List<RepoFileMetaData>) ret.getReturnValue();
            if (repoFileNameList != null) {
                for (RepoFileMetaData isoFileMetaData : (List<RepoFileMetaData>) ret.getReturnValue()) {
                    if (isoFileMetaData.getRepoFileName().equals(runParams.getFloppyPath())) {
                        retValForFloppy = true;
                        break;
                    }
                }
            }
        }
        if (!retValForFloppy) {
            messages.add(VdcBllMessages.ERROR_CANNOT_FIND_FLOPPY_IMAGE_PATH.toString());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm();
    if (!canDoAction) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return canDoAction;
}
#method_after
@Override
protected boolean canDoAction() {
    // setting the RunVmParams Internal flag according to the command Internal flag.
    // we can not use only the command Internal flag and remove this flag from RunVmParams
    // since canRunVm is static and can not call non-static method isInternalExecution
    getParameters().setIsInternal(isInternalExecution());
    boolean canDoAction = CanRunVm(getVm(), getReturnValue().getCanDoActionMessages(), getParameters(), getVdsSelector(), getSnapshotsValidator(), getVmPropertiesUtils()) && isVmInterfacesAttachedToVmNetworks();
    // check for Vm Payload
    if (canDoAction && getParameters().getVmPayload() != null) {
        canDoAction = checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath());
        if (canDoAction && !StringHelper.isNullOrEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
            canDoAction = false;
        } else {
            getVm().setVmPayload(getParameters().getVmPayload());
        }
    }
    return canDoAction;
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId()).size() > 0) {
            VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
            if (createSnapshotParameters != null) {
                createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
            }
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
            getParameters().setShouldBeLogged(false);
            getParameters().setRunAsStateless(false);
            getParameters().setIsInternal(true);
            setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
            if (!getSucceeded()) {
                // could not run the vm don't try to run the end action
                // again
                log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // the stateless-snapshot no longer exists (probably due to
        // ProcessVmPoolOnStopVm
        // treatment) -> no point in running the VM or retrying to
        // EndAction:
        {
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setIsInternal(true);
        setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
        if (getVm() != null) {
            VmHandler.updateDisksFromDb(getVm());
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * remove stateless vm image from db:
                 */
                DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(disk.getId());
            }
        } else {
            setCommandShouldBeLogged(false);
            log.warn("RunVmCommand::EndWithFailure [stateless]: Vm is null - not performing full EndAction");
        }
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#method_after
@Override
protected void EndWithFailure() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.EndWithFailure();
    }
}
#end_block

#method_before
private void SetIsVmRunningStateless() {
    List<stateless_vm_image_map> list = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    _isVmRunningStateless = (list != null && list.size() > 0);
}
#method_after
private void SetIsVmRunningStateless() {
    _isVmRunningStateless = statelessSnapshotExistsForVm();
}
#end_block

#method_before
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getid(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getid();
                break;
            }
        }
    }
    return isoGuid;
}
#method_after
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getId(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getId();
                break;
            }
        }
    }
    return isoGuid;
}
#end_block

#method_before
@Override
protected void Perform() {
    // Get a reference to the virtual machine:
    final VM vm = getVm();
    // Send the log off command to the virtual machine:
    setSucceeded(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmLogoff, new VmLogoffVDSCommandParameters(getVdsId(), vm.getvm_guid(), mForce)).getSucceeded());
    // database to reflect that the user is logged off:
    if (getSucceeded()) {
        vm.setguest_cur_user_name(null);
        vm.setguest_cur_user_id(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
    }
}
#method_after
@Override
protected void Perform() {
    // Get a reference to the virtual machine:
    final VM vm = getVm();
    // Send the log off command to the virtual machine:
    final boolean sentToVM = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmLogoff, new VmLogoffVDSCommandParameters(getVdsId(), vm.getId(), mForce)).getSucceeded();
    // database to reflect that the user is logged off:
    if (sentToVM) {
        vm.setguest_cur_user_name(null);
        vm.setguest_cur_user_id(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vm.getDynamicData());
    }
    // Done:
    setSucceeded(sentToVM);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((acpi_enable == null) ? 0 : acpi_enable.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + boot_sequence.hashCode() * prime;
    result = prime * result + ((client_ip == null) ? 0 : client_ip.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((display_ip == null) ? 0 : display_ip.hashCode());
    result = prime * result + ((display_secure_port == null) ? 0 : display_secure_port.hashCode());
    result = prime * result + display_type.hashCode() * prime;
    result = prime * result + ((guest_cur_user_id == null) ? 0 : guest_cur_user_id.hashCode());
    result = prime * result + ((guest_cur_user_name == null) ? 0 : guest_cur_user_name.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((consoleUserName == null) ? 0 : consoleUserName.hashCode());
    result = prime * result + ((guest_last_login_time == null) ? 0 : guest_last_login_time.hashCode());
    result = prime * result + ((guest_last_logout_time == null) ? 0 : guest_last_logout_time.hashCode());
    result = prime * result + ((guest_os == null) ? 0 : guest_os.hashCode());
    result = prime * result + ((guest_requested_memory == null) ? 0 : guest_requested_memory.hashCode());
    result = prime * result + ((hibernation_vol_handle == null) ? 0 : hibernation_vol_handle.hashCode());
    result = prime * result + ((kvm_enable == null) ? 0 : kvm_enable.hashCode());
    result = prime * result + ((last_vds_run_on == null) ? 0 : last_vds_run_on.hashCode());
    result = prime * result + ((mDisks == null) ? 0 : mDisks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + mExitStatus.hashCode() * prime;
    result = prime * result + (mWin2kHackEnable ? 1231 : 1237);
    result = prime * result + ((migrating_to_vds == null) ? 0 : migrating_to_vds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((run_on_vds == null) ? 0 : run_on_vds.hashCode());
    result = prime * result + session.hashCode() * prime;
    result = prime * result + status.hashCode() * prime;
    result = prime * result + ((utc_diff == null) ? 0 : utc_diff.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((vm_host == null) ? 0 : vm_host.hashCode());
    result = prime * result + ((vm_ip == null) ? 0 : vm_ip.hashCode());
    result = prime * result + ((vm_last_boot_time == null) ? 0 : vm_last_boot_time.hashCode());
    result = prime * result + ((vm_last_up_time == null) ? 0 : vm_last_up_time.hashCode());
    result = prime * result + ((vm_pid == null) ? 0 : vm_pid.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((acpi_enable == null) ? 0 : acpi_enable.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + boot_sequence.hashCode() * prime;
    result = prime * result + ((client_ip == null) ? 0 : client_ip.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((display_ip == null) ? 0 : display_ip.hashCode());
    result = prime * result + ((display_secure_port == null) ? 0 : display_secure_port.hashCode());
    result = prime * result + display_type.hashCode() * prime;
    result = prime * result + ((guest_cur_user_id == null) ? 0 : guest_cur_user_id.hashCode());
    result = prime * result + ((guest_cur_user_name == null) ? 0 : guest_cur_user_name.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guest_last_login_time == null) ? 0 : guest_last_login_time.hashCode());
    result = prime * result + ((guest_last_logout_time == null) ? 0 : guest_last_logout_time.hashCode());
    result = prime * result + ((guest_os == null) ? 0 : guest_os.hashCode());
    result = prime * result + ((guest_requested_memory == null) ? 0 : guest_requested_memory.hashCode());
    result = prime * result + ((hibernation_vol_handle == null) ? 0 : hibernation_vol_handle.hashCode());
    result = prime * result + ((kvm_enable == null) ? 0 : kvm_enable.hashCode());
    result = prime * result + ((last_vds_run_on == null) ? 0 : last_vds_run_on.hashCode());
    result = prime * result + ((mDisks == null) ? 0 : mDisks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + mExitStatus.hashCode() * prime;
    result = prime * result + (mWin2kHackEnable ? 1231 : 1237);
    result = prime * result + ((migrating_to_vds == null) ? 0 : migrating_to_vds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((run_on_vds == null) ? 0 : run_on_vds.hashCode());
    result = prime * result + session.hashCode() * prime;
    result = prime * result + status.hashCode() * prime;
    result = prime * result + ((utc_diff == null) ? 0 : utc_diff.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((vm_host == null) ? 0 : vm_host.hashCode());
    result = prime * result + ((vm_ip == null) ? 0 : vm_ip.hashCode());
    result = prime * result + ((vm_last_boot_time == null) ? 0 : vm_last_boot_time.hashCode());
    result = prime * result + ((vm_last_up_time == null) ? 0 : vm_last_up_time.hashCode());
    result = prime * result + ((vm_pid == null) ? 0 : vm_pid.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VmDynamic other = (VmDynamic) obj;
    if (acpi_enable == null) {
        if (other.acpi_enable != null)
            return false;
    } else if (!acpi_enable.equals(other.acpi_enable))
        return false;
    if (appList == null) {
        if (other.appList != null)
            return false;
    } else if (!appList.equals(other.appList))
        return false;
    if (boot_sequence != other.boot_sequence)
        return false;
    if (client_ip == null) {
        if (other.client_ip != null)
            return false;
    } else if (!client_ip.equals(other.client_ip))
        return false;
    if (display == null) {
        if (other.display != null)
            return false;
    } else if (!display.equals(other.display))
        return false;
    if (display_ip == null) {
        if (other.display_ip != null)
            return false;
    } else if (!display_ip.equals(other.display_ip))
        return false;
    if (display_secure_port == null) {
        if (other.display_secure_port != null)
            return false;
    } else if (!display_secure_port.equals(other.display_secure_port))
        return false;
    if (display_type != other.display_type)
        return false;
    if (guest_cur_user_id == null) {
        if (other.guest_cur_user_id != null)
            return false;
    } else if (!guest_cur_user_id.equals(other.guest_cur_user_id))
        return false;
    if (guest_cur_user_name == null) {
        if (other.guest_cur_user_name != null)
            return false;
    } else if (!guest_cur_user_name.equals(other.guest_cur_user_name))
        return false;
    if (consoleUserId == null) {
        if (other.consoleUserId != null)
            return false;
    } else if (!consoleUserId.equals(other.consoleUserId))
        return false;
    if (consoleUserName == null) {
        if (other.consoleUserName != null)
            return false;
    } else if (!consoleUserName.equals(other.consoleUserName))
        return false;
    if (guest_last_login_time == null) {
        if (other.guest_last_login_time != null)
            return false;
    } else if (!guest_last_login_time.equals(other.guest_last_login_time))
        return false;
    if (guest_last_logout_time == null) {
        if (other.guest_last_logout_time != null)
            return false;
    } else if (!guest_last_logout_time.equals(other.guest_last_logout_time))
        return false;
    if (guest_os == null) {
        if (other.guest_os != null)
            return false;
    } else if (!guest_os.equals(other.guest_os))
        return false;
    if (guest_requested_memory == null) {
        if (other.guest_requested_memory != null)
            return false;
    } else if (!guest_requested_memory.equals(other.guest_requested_memory))
        return false;
    if (hibernation_vol_handle == null) {
        if (other.hibernation_vol_handle != null)
            return false;
    } else if (!hibernation_vol_handle.equals(other.hibernation_vol_handle))
        return false;
    if (kvm_enable == null) {
        if (other.kvm_enable != null)
            return false;
    } else if (!kvm_enable.equals(other.kvm_enable))
        return false;
    if (last_vds_run_on == null) {
        if (other.last_vds_run_on != null)
            return false;
    } else if (!last_vds_run_on.equals(other.last_vds_run_on))
        return false;
    if (mDisks == null) {
        if (other.mDisks != null)
            return false;
    } else if (!mDisks.equals(other.mDisks))
        return false;
    if (mExitMessage == null) {
        if (other.mExitMessage != null)
            return false;
    } else if (!mExitMessage.equals(other.mExitMessage))
        return false;
    if (mExitStatus != other.mExitStatus)
        return false;
    if (mWin2kHackEnable != other.mWin2kHackEnable)
        return false;
    if (migrating_to_vds == null) {
        if (other.migrating_to_vds != null)
            return false;
    } else if (!migrating_to_vds.equals(other.migrating_to_vds))
        return false;
    if (pauseStatus != other.pauseStatus)
        return false;
    if (run_on_vds == null) {
        if (other.run_on_vds != null)
            return false;
    } else if (!run_on_vds.equals(other.run_on_vds))
        return false;
    if (session != other.session)
        return false;
    if (status != other.status)
        return false;
    if (utc_diff == null) {
        if (other.utc_diff != null)
            return false;
    } else if (!utc_diff.equals(other.utc_diff))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (vm_host == null) {
        if (other.vm_host != null)
            return false;
    } else if (!vm_host.equals(other.vm_host))
        return false;
    if (vm_ip == null) {
        if (other.vm_ip != null)
            return false;
    } else if (!vm_ip.equals(other.vm_ip))
        return false;
    if (vm_last_boot_time == null) {
        if (other.vm_last_boot_time != null)
            return false;
    } else if (!vm_last_boot_time.equals(other.vm_last_boot_time))
        return false;
    if (vm_last_up_time == null) {
        if (other.vm_last_up_time != null)
            return false;
    } else if (!vm_last_up_time.equals(other.vm_last_up_time))
        return false;
    if (vm_pid == null) {
        if (other.vm_pid != null)
            return false;
    } else if (!vm_pid.equals(other.vm_pid))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VmDynamic other = (VmDynamic) obj;
    if (acpi_enable == null) {
        if (other.acpi_enable != null)
            return false;
    } else if (!acpi_enable.equals(other.acpi_enable))
        return false;
    if (appList == null) {
        if (other.appList != null)
            return false;
    } else if (!appList.equals(other.appList))
        return false;
    if (boot_sequence != other.boot_sequence)
        return false;
    if (client_ip == null) {
        if (other.client_ip != null)
            return false;
    } else if (!client_ip.equals(other.client_ip))
        return false;
    if (display == null) {
        if (other.display != null)
            return false;
    } else if (!display.equals(other.display))
        return false;
    if (display_ip == null) {
        if (other.display_ip != null)
            return false;
    } else if (!display_ip.equals(other.display_ip))
        return false;
    if (display_secure_port == null) {
        if (other.display_secure_port != null)
            return false;
    } else if (!display_secure_port.equals(other.display_secure_port))
        return false;
    if (display_type != other.display_type)
        return false;
    if (guest_cur_user_id == null) {
        if (other.guest_cur_user_id != null)
            return false;
    } else if (!guest_cur_user_id.equals(other.guest_cur_user_id))
        return false;
    if (guest_cur_user_name == null) {
        if (other.guest_cur_user_name != null)
            return false;
    } else if (!guest_cur_user_name.equals(other.guest_cur_user_name))
        return false;
    if (consoleUserId == null) {
        if (other.consoleUserId != null)
            return false;
    } else if (!consoleUserId.equals(other.consoleUserId))
        return false;
    if (guest_last_login_time == null) {
        if (other.guest_last_login_time != null)
            return false;
    } else if (!guest_last_login_time.equals(other.guest_last_login_time))
        return false;
    if (guest_last_logout_time == null) {
        if (other.guest_last_logout_time != null)
            return false;
    } else if (!guest_last_logout_time.equals(other.guest_last_logout_time))
        return false;
    if (guest_os == null) {
        if (other.guest_os != null)
            return false;
    } else if (!guest_os.equals(other.guest_os))
        return false;
    if (guest_requested_memory == null) {
        if (other.guest_requested_memory != null)
            return false;
    } else if (!guest_requested_memory.equals(other.guest_requested_memory))
        return false;
    if (hibernation_vol_handle == null) {
        if (other.hibernation_vol_handle != null)
            return false;
    } else if (!hibernation_vol_handle.equals(other.hibernation_vol_handle))
        return false;
    if (kvm_enable == null) {
        if (other.kvm_enable != null)
            return false;
    } else if (!kvm_enable.equals(other.kvm_enable))
        return false;
    if (last_vds_run_on == null) {
        if (other.last_vds_run_on != null)
            return false;
    } else if (!last_vds_run_on.equals(other.last_vds_run_on))
        return false;
    if (mDisks == null) {
        if (other.mDisks != null)
            return false;
    } else if (!mDisks.equals(other.mDisks))
        return false;
    if (mExitMessage == null) {
        if (other.mExitMessage != null)
            return false;
    } else if (!mExitMessage.equals(other.mExitMessage))
        return false;
    if (mExitStatus != other.mExitStatus)
        return false;
    if (mWin2kHackEnable != other.mWin2kHackEnable)
        return false;
    if (migrating_to_vds == null) {
        if (other.migrating_to_vds != null)
            return false;
    } else if (!migrating_to_vds.equals(other.migrating_to_vds))
        return false;
    if (pauseStatus != other.pauseStatus)
        return false;
    if (run_on_vds == null) {
        if (other.run_on_vds != null)
            return false;
    } else if (!run_on_vds.equals(other.run_on_vds))
        return false;
    if (session != other.session)
        return false;
    if (status != other.status)
        return false;
    if (utc_diff == null) {
        if (other.utc_diff != null)
            return false;
    } else if (!utc_diff.equals(other.utc_diff))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (vm_host == null) {
        if (other.vm_host != null)
            return false;
    } else if (!vm_host.equals(other.vm_host))
        return false;
    if (vm_ip == null) {
        if (other.vm_ip != null)
            return false;
    } else if (!vm_ip.equals(other.vm_ip))
        return false;
    if (vm_last_boot_time == null) {
        if (other.vm_last_boot_time != null)
            return false;
    } else if (!vm_last_boot_time.equals(other.vm_last_boot_time))
        return false;
    if (vm_last_up_time == null) {
        if (other.vm_last_up_time != null)
            return false;
    } else if (!vm_last_up_time.equals(other.vm_last_up_time))
        return false;
    if (vm_pid == null) {
        if (other.vm_pid != null)
            return false;
    } else if (!vm_pid.equals(other.vm_pid))
        return false;
    return true;
}
#end_block

#method_before
@XmlElement(name = "ExitMessage")
public String getExitMessage() {
    return mExitMessage;
}
#method_after
public String getExitMessage() {
    return mExitMessage;
}
#end_block

#method_before
@XmlElement(name = "ExitStatus")
public VmExitStatus getExitStatus() {
    return this.mExitStatus;
}
#method_after
public VmExitStatus getExitStatus() {
    return this.mExitStatus;
}
#end_block

#method_before
@XmlElement(name = "Win2kHackEnable")
public boolean getWin2kHackEnable() {
    return mWin2kHackEnable;
}
#method_after
public boolean getWin2kHackEnable() {
    return mWin2kHackEnable;
}
#end_block

#method_before
@XmlElement
public String getapp_list() {
    return this.appList;
}
#method_after
public String getapp_list() {
    return this.appList;
}
#end_block

#method_before
@XmlElement
public NGuid getguest_cur_user_id() {
    return this.guest_cur_user_id;
}
#method_after
public NGuid getguest_cur_user_id() {
    return this.guest_cur_user_id;
}
#end_block

#method_before
@XmlElement
public String getguest_cur_user_name() {
    return this.guest_cur_user_name;
}
#method_after
public String getguest_cur_user_name() {
    return this.guest_cur_user_name;
}
#end_block

#method_before
@XmlElement
public NGuid getConsoleUserId() {
    return this.consoleUserId;
}
#method_after
public NGuid getConsoleUserId() {
    return this.consoleUserId;
}
#end_block

#method_before
@XmlElement
public String getguest_os() {
    return this.guest_os;
}
#method_after
public String getguest_os() {
    return this.guest_os;
}
#end_block

#method_before
@XmlElement(nillable = true)
public java.util.Date getguest_last_login_time() {
    return this.guest_last_login_time;
}
#method_after
public java.util.Date getguest_last_login_time() {
    return this.guest_last_login_time;
}
#end_block

#method_before
@XmlElement(nillable = true)
public java.util.Date getguest_last_logout_time() {
    return this.guest_last_logout_time;
}
#method_after
public java.util.Date getguest_last_logout_time() {
    return this.guest_last_logout_time;
}
#end_block

#method_before
@XmlElement(nillable = true)
public NGuid getmigrating_to_vds() {
    return this.migrating_to_vds;
}
#method_after
public NGuid getmigrating_to_vds() {
    return this.migrating_to_vds;
}
#end_block

#method_before
@XmlElement(nillable = true)
public NGuid getrun_on_vds() {
    return this.run_on_vds;
}
#method_after
public NGuid getrun_on_vds() {
    return this.run_on_vds;
}
#end_block

#method_before
@XmlElement
public VMStatus getstatus() {
    return this.status;
}
#method_after
public VMStatus getstatus() {
    return this.status;
}
#end_block

#method_before
@XmlElement
public Guid getId() {
    return this.id;
}
#method_after
public Guid getId() {
    return this.id;
}
#end_block

#method_before
@XmlElement
public String getvm_host() {
    return this.vm_host;
}
#method_after
public String getvm_host() {
    return this.vm_host;
}
#end_block

#method_before
@XmlElement
public String getvm_ip() {
    return this.vm_ip;
}
#method_after
public String getvm_ip() {
    return this.vm_ip;
}
#end_block

#method_before
@XmlElement(nillable = true)
public java.util.Date getvm_last_boot_time() {
    return this.vm_last_boot_time;
}
#method_after
public java.util.Date getvm_last_boot_time() {
    return this.vm_last_boot_time;
}
#end_block

#method_before
@XmlElement(nillable = true)
public java.util.Date getvm_last_up_time() {
    return this.vm_last_up_time;
}
#method_after
public java.util.Date getvm_last_up_time() {
    return this.vm_last_up_time;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Integer getvm_pid() {
    return this.vm_pid;
}
#method_after
public Integer getvm_pid() {
    return this.vm_pid;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Integer getdisplay() {
    return this.display;
}
#method_after
public Integer getdisplay() {
    return this.display;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Boolean getacpi_enable() {
    return this.acpi_enable;
}
#method_after
public Boolean getacpi_enable() {
    return this.acpi_enable;
}
#end_block

#method_before
@XmlElement
public String getdisplay_ip() {
    return this.display_ip;
}
#method_after
public String getdisplay_ip() {
    return this.display_ip;
}
#end_block

#method_before
@XmlElement
public DisplayType getdisplay_type() {
    return display_type;
}
#method_after
public DisplayType getdisplay_type() {
    return display_type;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Boolean getkvm_enable() {
    return this.kvm_enable;
}
#method_after
public Boolean getkvm_enable() {
    return this.kvm_enable;
}
#end_block

#method_before
@XmlElement
public SessionState getsession() {
    return this.session;
}
#method_after
public SessionState getsession() {
    return this.session;
}
#end_block

#method_before
@XmlElement
public BootSequence getboot_sequence() {
    return this.boot_sequence;
}
#method_after
public BootSequence getboot_sequence() {
    return this.boot_sequence;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Integer getdisplay_secure_port() {
    return this.display_secure_port;
}
#method_after
public Integer getdisplay_secure_port() {
    return this.display_secure_port;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Integer getutc_diff() {
    return this.utc_diff;
}
#method_after
public Integer getutc_diff() {
    return this.utc_diff;
}
#end_block

#method_before
@XmlElement(nillable = true)
public NGuid getlast_vds_run_on() {
    return this.last_vds_run_on;
}
#method_after
public NGuid getlast_vds_run_on() {
    return this.last_vds_run_on;
}
#end_block

#method_before
@XmlElement
public String getclient_ip() {
    return this.client_ip;
}
#method_after
public String getclient_ip() {
    return this.client_ip;
}
#end_block

#method_before
@XmlElement(nillable = true)
public Integer getguest_requested_memory() {
    return this.guest_requested_memory;
}
#method_after
public Integer getguest_requested_memory() {
    return this.guest_requested_memory;
}
#end_block

#method_before
@XmlElement
public String gethibernation_vol_handle() {
    return this.hibernation_vol_handle;
}
#method_after
public String gethibernation_vol_handle() {
    return this.hibernation_vol_handle;
}
#end_block

#method_before
@XmlElement(name = "PauseStatus")
public VmPauseStatus getPauseStatus() {
    return this.pauseStatus;
}
#method_after
public VmPauseStatus getPauseStatus() {
    return this.pauseStatus;
}
#end_block

#method_before
public VDS getUpServer(Guid clusterId) {
    List<VDS> servers = DbFacade.getInstance().getVdsDAO().getAllForVdsGroupWithStatus(clusterId, VDSStatus.Up);
    if (servers == null || servers.isEmpty()) {
        throw new VdcBLLException(VdcBllErrors.NO_UP_SERVER_FOUND);
    }
    return servers.get(GlusterCoreUtil.random(servers.size() - 1));
}
#method_after
public VDS getUpServer(Guid clusterId) {
    List<VDS> servers = getVdsDao().getAllForVdsGroupWithStatus(clusterId, VDSStatus.Up);
    if (servers == null || servers.isEmpty()) {
        throw new VdcBLLException(VdcBllErrors.NO_UP_SERVER_FOUND);
    }
    return RandomUtils.instance().pickRandom(servers);
}
#end_block

#method_before
@Before
public void mockDbFacadeAndDao() {
    MockitoAnnotations.initMocks(this);
    mockStatic(DbFacade.class);
    mockStatic(VdsDAO.class);
    when(db.getVdsDAO()).thenReturn(vdsDao);
    when(DbFacade.getInstance()).thenReturn(db);
    when(vdsDao.getAllForVdsGroupWithStatus(CLUSTER_ID, VDSStatus.Up)).thenReturn(mockGetAllVdsForwithStatus(VDSStatus.Up));
}
#method_after
@Before
public void mockDbFacadeAndDao() {
    vdsDao = mock(VdsDAO.class);
    when(vdsDao.getAllForVdsGroupWithStatus(CLUSTER_ID, VDSStatus.Up)).thenReturn(mockGetAllVdsForwithStatus(VDSStatus.Up));
    clusterUtils = spy(ClusterUtils.getInstance());
    doReturn(vdsDao).when(clusterUtils).getVdsDao();
}
#end_block

#method_before
@Test
public void testGetAllVdsWithStatus() {
    VDS vds = ClusterUtils.getInstance().getUpServer(CLUSTER_ID);
    assertNotNull(vds);
    assertEquals(vds, getVds(VDSStatus.Up));
}
#method_after
@Test
public void testGetAllVdsWithStatus() {
    VDS vds = clusterUtils.getUpServer(CLUSTER_ID);
    assertNotNull(vds);
    assertEquals(vds, getVds(VDSStatus.Up));
}
#end_block

#method_before
@Test
public void testSave() {
    // Fetch the file from cache table
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(ISO_STORAGE_DOAMIN_ID, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(listOfRepoFiles.isEmpty(), true);
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(ISO_STORAGE_DOAMIN_ID, FileTypeExtension.ISO);
    assertSame(listOfRepoFiles.isEmpty(), false);
}
#method_after
@Test
public void testSave() {
    // Fetch the file from cache table
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(listOfRepoFiles.isEmpty(), true);
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, FileTypeExtension.ISO);
    assertSame(listOfRepoFiles.isEmpty(), false);
}
#end_block

#method_before
@Test
public void testRemove() {
    // Should get one iso file
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#method_after
@Test
public void testRemove() {
    // Should get one iso file
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#end_block

#method_before
@Test
public void testRemoveByRemoveIsoDomain() {
    // Should get one iso file
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Test remove Iso
    StorageDomainDAO storageDomainDao = dbFacade.getStorageDomainDAO();
    storageDomainDao.remove(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#method_after
@Test
public void testRemoveByRemoveIsoDomain() {
    // Should get one iso file
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Test remove Iso
    StorageDomainDAO storageDomainDao = dbFacade.getStorageDomainDAO();
    storageDomainDao.remove(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#end_block

#method_before
@Test
public void testFileTypeWhenFetchAllIsoDomainInSystem() {
    // Should get one iso file
    List<RepoFileMetaData> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<FileTypeExtension> SharedStorageDomainFileType = new ArrayList<FileTypeExtension>();
    List<FileTypeExtension> EmptyStorageDomainFileType = new ArrayList<FileTypeExtension>();
    for (RepoFileMetaData fileMD : listOfAllIsoFiles) {
        Guid repoDomainId = fileMD.getRepoDomainId();
        if (repoDomainId.equals(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3)) {
            // Should have three types of files.
            SharedStorageDomainFileType.add(fileMD.getFileType());
        } else if (repoDomainId.equals(ISO_STORAGE_DOAMIN_ID)) {
            // Should have only one type (UNKNOWN)
            EmptyStorageDomainFileType.add(fileMD.getFileType());
        }
    }
    // Start the check
    // the shared storage domain, should have three types of files.
    assertEquals(SharedStorageDomainFileType.size(), 3);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.Unknown), true);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.ISO), true);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.Floppy), true);
    // The empty storage domain, should not have files, but should be fetched, since we want to refresh it.
    assertEquals(EmptyStorageDomainFileType.size(), 1);
    assertEquals(EmptyStorageDomainFileType.contains(FileTypeExtension.Unknown), true);
}
#method_after
@Test
public void testFileTypeWhenFetchAllIsoDomainInSystem() {
    // Should get one iso file
    List<RepoFileMetaData> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<FileTypeExtension> SharedStorageDomainFileType = new ArrayList<FileTypeExtension>();
    List<FileTypeExtension> EmptyStorageDomainFileType = new ArrayList<FileTypeExtension>();
    for (RepoFileMetaData fileMD : listOfAllIsoFiles) {
        Guid repoDomainId = fileMD.getRepoDomainId();
        if (repoDomainId.equals(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3)) {
            // Should have three types of files.
            SharedStorageDomainFileType.add(fileMD.getFileType());
        } else if (repoDomainId.equals(FixturesTool.STORAGE_DOAMIN_NFS_ISO)) {
            // Should have only one type (UNKNOWN)
            EmptyStorageDomainFileType.add(fileMD.getFileType());
        }
    }
    // Start the check
    // the shared storage domain, should have three types of files.
    assertEquals(SharedStorageDomainFileType.size(), 3);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.Unknown), true);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.ISO), true);
    assertEquals(SharedStorageDomainFileType.contains(FileTypeExtension.Floppy), true);
    // The empty storage domain, should not have files, but should be fetched, since we want to refresh it.
    assertEquals(EmptyStorageDomainFileType.size(), 1);
    assertEquals(EmptyStorageDomainFileType.contains(FileTypeExtension.Unknown), true);
}
#end_block

#method_before
@Test
public void testFetchAllIsoDomainOldestFile() {
    List<RepoFileMetaData> listOfIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<RepoFileMetaData> listOfFloppyFiles = repoFileMetaDataDao.getRepoListForStorageDomain(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.Floppy);
    long minLastRefreshed = new Long("9999999999999").longValue();
    for (RepoFileMetaData fileMD : listOfFloppyFiles) {
        long fileLastRefreshed = fileMD.getLastRefreshed();
        if (fileLastRefreshed < minLastRefreshed) {
            minLastRefreshed = fileLastRefreshed;
        }
    }
    // Check if fetched the oldest file when fetching all repository files.
    boolean isValid = true;
    for (RepoFileMetaData fileMetaData : listOfIsoFiles) {
        if (fileMetaData.getFileType() == FileTypeExtension.Floppy) {
            if (fileMetaData.getLastRefreshed() > minLastRefreshed) {
                isValid = false;
            }
        }
    }
    assertEquals(isValid, true);
}
#method_after
@Test
public void testFetchAllIsoDomainOldestFile() {
    List<RepoFileMetaData> listOfIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<RepoFileMetaData> listOfFloppyFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.Floppy);
    long minLastRefreshed = new Long("9999999999999").longValue();
    for (RepoFileMetaData fileMD : listOfFloppyFiles) {
        long fileLastRefreshed = fileMD.getLastRefreshed();
        if (fileLastRefreshed < minLastRefreshed) {
            minLastRefreshed = fileLastRefreshed;
        }
    }
    // Check if fetched the oldest file when fetching all repository files.
    boolean isValid = true;
    for (RepoFileMetaData fileMetaData : listOfIsoFiles) {
        if (fileMetaData.getFileType() == FileTypeExtension.Floppy) {
            if (fileMetaData.getLastRefreshed() > minLastRefreshed) {
                isValid = false;
            }
        }
    }
    assertEquals(isValid, true);
}
#end_block

#method_before
@Test
public void testInsertRepoFileAndFetchItAgain() {
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(ISO_STORAGE_DOAMIN_ID, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(true, !listOfRepoFiles.isEmpty());
    assertSame(true, listOfRepoFiles.get(0).getRepoFileName().equals(newRepoFileMap.getRepoFileName()));
    assertSame(true, listOfRepoFiles.get(0).getLastRefreshed() == newRepoFileMap.getLastRefreshed());
    assertSame(true, listOfRepoFiles.get(0).getSize() == newRepoFileMap.getSize());
    assertSame(true, listOfRepoFiles.get(0).getRepoDomainId().equals(newRepoFileMap.getRepoDomainId()));
}
#method_after
@Test
public void testInsertRepoFileAndFetchItAgain() {
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    List<RepoFileMetaData> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, FileTypeExtension.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(true, !listOfRepoFiles.isEmpty());
    assertSame(true, listOfRepoFiles.get(0).getRepoFileName().equals(newRepoFileMap.getRepoFileName()));
    assertSame(true, listOfRepoFiles.get(0).getLastRefreshed() == newRepoFileMap.getLastRefreshed());
    assertSame(true, listOfRepoFiles.get(0).getSize() == newRepoFileMap.getSize());
    assertSame(true, listOfRepoFiles.get(0).getRepoDomainId().equals(newRepoFileMap.getRepoDomainId()));
}
#end_block

#method_before
@Test
public void testUpdateRepoFileByRemoveAndInsert() {
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the file from cache table
    List<RepoFileMetaData> listOfRepoFiles = getActiveIsoDomain();
    // Get first file and update its String
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoFileMetaData repoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    String oldRepoFileName = repoFile.getRepoFileName();
    newRepoFileMap.setRepoFileName("updatedFileName" + newRepoFileMap.getRepoFileName());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(ISO_STORAGE_DOAMIN_ID, FileTypeExtension.ISO);
    // Add the new updated file into the cache table.
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the updated File.
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoFileMetaData newRepoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    // Check if not same file name as in the old file.
    assertNotSame(oldRepoFileName, newRepoFile.getRepoFileName());
}
#method_after
@Test
public void testUpdateRepoFileByRemoveAndInsert() {
    RepoFileMetaData newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the file from cache table
    List<RepoFileMetaData> listOfRepoFiles = getActiveIsoDomain();
    // Get first file and update its String
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoFileMetaData repoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    String oldRepoFileName = repoFile.getRepoFileName();
    newRepoFileMap.setRepoFileName("updatedFileName" + newRepoFileMap.getRepoFileName());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.STORAGE_DOAMIN_NFS_ISO, FileTypeExtension.ISO);
    // Add the new updated file into the cache table.
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the updated File.
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoFileMetaData newRepoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    // Check if not same file name as in the old file.
    assertNotSame(oldRepoFileName, newRepoFile.getRepoFileName());
}
#end_block

#method_before
private static RepoFileMetaData getNewIsoRepoFile() {
    RepoFileMetaData newRepoFileMap = new RepoFileMetaData();
    newRepoFileMap.setFileType(FileTypeExtension.ISO);
    newRepoFileMap.setRepoFileName("isoDomain.iso");
    newRepoFileMap.setLastRefreshed(System.currentTimeMillis());
    newRepoFileMap.setSize(0);
    newRepoFileMap.setDateCreated(null);
    newRepoFileMap.setRepoDomainId(ISO_STORAGE_DOAMIN_ID);
    return newRepoFileMap;
}
#method_after
private static RepoFileMetaData getNewIsoRepoFile() {
    RepoFileMetaData newRepoFileMap = new RepoFileMetaData();
    newRepoFileMap.setFileType(FileTypeExtension.ISO);
    newRepoFileMap.setRepoFileName("isoDomain.iso");
    newRepoFileMap.setLastRefreshed(System.currentTimeMillis());
    newRepoFileMap.setSize(0);
    newRepoFileMap.setDateCreated(null);
    newRepoFileMap.setRepoDomainId(FixturesTool.STORAGE_DOAMIN_NFS_ISO);
    return newRepoFileMap;
}
#end_block

#method_before
private List<RepoFileMetaData> getActiveIsoDomain() {
    return repoFileMetaDataDao.getRepoListForStorageDomain(SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
}
#method_after
private List<RepoFileMetaData> getActiveIsoDomain() {
    return repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, FileTypeExtension.ISO);
}
#end_block

#method_before
@Override
public void Search() {
    if (getEntity() != null) {
        setSearchString(StringFormat.format("Events: volume.name=%1$s", getEntity().getName()));
        super.Search();
    }
}
#method_after
@Override
public void Search() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        setSearchString(StringFormat.format("Events: volume.name=%1$s", getEntity().getName()));
        super.Search();
    }
}
#end_block

#method_before
@Override
protected void EntityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.EntityPropertyChanged(sender, e);
    if (e.PropertyName.equals("gluster_volume_name")) {
        getSearchCommand().Execute();
    }
}
#method_after
@Override
protected void EntityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.EntityPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("gluster_volume_name")) {
        getSearchCommand().Execute();
    }
}
#end_block

#method_before
public boolean getTaskGroupSuccess() {
    boolean childrenTasksSuccess = taskGroupSuccess;
    for (VdcActionParametersBase childParameters : getImagesParameters()) {
        childrenTasksSuccess &= childParameters.getTaskGroupSuccess();
    }
    return childrenTasksSuccess;
}
#method_after
public boolean getTaskGroupSuccess() {
    boolean childrenTasksSuccess = taskGroupSuccess;
    for (VdcActionParametersBase childParameters : getImagesParameters()) {
        childrenTasksSuccess &= childParameters.getTaskGroupSuccess();
        if (!childrenTasksSuccess) {
            break;
        }
    }
    return childrenTasksSuccess;
}
#end_block

#method_before
@Ignore
@Test
public void deleteAJob() throws SchedulerException {
    PrintJob pj = new PrintJob();
    Date startTestDate = new Date();
    System.out.println("Start Time=" + startTestDate);
    String jobId = scheduler.scheduleAFixedDelayJob(pj, "onTimer11", new Class[0], new Object[0], 1, 3, TimeUnit.MILLISECONDS);
    // String[] jobs = scheduler.getRawScheduler().getJobNames(Scheduler.DEFAULT_GROUP);
    Set<JobKey> jobKeys = scheduler.getRawScheduler().getJobKeys(jobGroupEquals(Scheduler.DEFAULT_GROUP));
    assertEquals("Number of scheduled jobs", 1, jobKeys.size());
    // delete a valid job
    scheduler.deleteJob(jobId);
    jobKeys = scheduler.getRawScheduler().getJobKeys(jobGroupEquals(Scheduler.DEFAULT_GROUP));
    assertEquals("Number of scheduled jobs", 0, jobKeys.size());
    // delete invalid job
    scheduler.deleteJob("nojob");
}
#method_after
@Ignore
@Test
public void deleteAJob() throws SchedulerException {
    PrintJob pj = new PrintJob();
    Date startTestDate = new Date();
    System.out.println("Start Time=" + startTestDate);
    String jobId = scheduler.scheduleAFixedDelayJob(pj, "onTimer11", new Class[0], new Object[0], 1, 3, TimeUnit.MILLISECONDS);
    Set<JobKey> jobKeys = scheduler.getRawScheduler().getJobKeys(jobGroupEquals(Scheduler.DEFAULT_GROUP));
    assertEquals("Number of scheduled jobs", 1, jobKeys.size());
    // delete a valid job
    scheduler.deleteJob(jobId);
    jobKeys = scheduler.getRawScheduler().getJobKeys(jobGroupEquals(Scheduler.DEFAULT_GROUP));
    assertEquals("Number of scheduled jobs", 0, jobKeys.size());
    // delete invalid job
    scheduler.deleteJob("nojob");
}
#end_block

#method_before
@Override
public void jobWasExecuted(JobExecutionContext context, JobExecutionException exception) {
    // Get the details of the job:
    JobDetail jobdetail = context.getJobDetail();
    JobDataMap data = jobdetail.getJobDataMap();
    // job and if not just exit:
    if (data.containsKey(SchedulerUtilQuartzImpl.FIXED_DELAY_ENABLED)) {
        boolean fixedDelayEnabled = data.getBoolean(SchedulerUtilQuartzImpl.FIXED_DELAY_ENABLED);
        if (!fixedDelayEnabled) {
            return;
        }
    }
    // generate the new trigger time
    long delay = data.getLongValue(SchedulerUtilQuartzImpl.FIXED_DELAY_VALUE);
    TimeUnit delayUnit = (TimeUnit) data.getWrappedMap().get(SchedulerUtilQuartzImpl.FIXED_DELAY_TIME_UNIT);
    Date runTime = SchedulerUtilQuartzImpl.getFutureDate(delay, delayUnit);
    // generate the new trigger
    Trigger oldTrigger = context.getTrigger();
    TriggerKey oldTriggerKey = oldTrigger.getKey();
    Trigger newTrigger = newTrigger().withIdentity(oldTriggerKey).startAt(runTime).build();
    // schedule the new trigger
    sched.rescheduleAJob(oldTriggerKey.getName(), oldTriggerKey.getGroup(), newTrigger);
// SchedulerUtilQuartzImpl.getInstance().rescheduleAJob(oldTriggerName,
// oldTriggerGroup, newTrigger);
}
#method_after
@Override
public void jobWasExecuted(JobExecutionContext context, JobExecutionException exception) {
    // Get the details of the job:
    JobDetail jobdetail = context.getJobDetail();
    JobDataMap data = jobdetail.getJobDataMap();
    // job and if not just exit:
    if (!data.containsKey(SchedulerUtilQuartzImpl.FIXED_DELAY_VALUE)) {
        return;
    }
    // generate the new trigger time
    long delay = data.getLongValue(SchedulerUtilQuartzImpl.FIXED_DELAY_VALUE);
    TimeUnit delayUnit = (TimeUnit) data.getWrappedMap().get(SchedulerUtilQuartzImpl.FIXED_DELAY_TIME_UNIT);
    Date runTime = SchedulerUtilQuartzImpl.getFutureDate(delay, delayUnit);
    // generate the new trigger
    Trigger oldTrigger = context.getTrigger();
    TriggerKey oldTriggerKey = oldTrigger.getKey();
    Trigger newTrigger = newTrigger().withIdentity(oldTriggerKey).startAt(runTime).build();
    // schedule the new trigger
    sched.rescheduleAJob(oldTriggerKey.getName(), oldTriggerKey.getGroup(), newTrigger);
// SchedulerUtilQuartzImpl.getInstance().rescheduleAJob(oldTriggerName,
// oldTriggerGroup, newTrigger);
}
#end_block

#method_before
@Override
public String scheduleAFixedDelayJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, long initialDelay, long taskDelay, TimeUnit timeUnit) {
    String jobName = generateUniqueNameForInstance(instance, methodName);
    JobDetail job = newJob().withIdentity(jobName, Scheduler.DEFAULT_GROUP).ofType(JobWrapper.class).build();
    JobDataMap data = job.getJobDataMap();
    data.put(RUNNABLE_INSTANCE, instance);
    data.put(RUN_METHOD_NAME, methodName);
    data.put(RUN_METHOD_PARAM_TYPE, inputTypes);
    data.put(RUN_METHOD_PARAM, inputParams);
    data.put(FIXED_DELAY_ENABLED, true);
    data.put(FIXED_DELAY_VALUE, taskDelay);
    data.put(FIXED_DELAY_TIME_UNIT, timeUnit);
    Date runTime = getFutureDate(initialDelay, timeUnit);
    String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
    Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).startAt(runTime).build();
    try {
        sched.scheduleJob(job, trigger);
    } catch (SchedulerException se) {
        log.error("failed to schedule job", se);
    }
    return jobName;
}
#method_after
@Override
public String scheduleAFixedDelayJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, long initialDelay, long taskDelay, TimeUnit timeUnit) {
    JobDetail job = createJobWithBasicMapValues(instance, methodName, inputTypes, inputParams);
    JobDataMap data = job.getJobDataMap();
    data.put(FIXED_DELAY_VALUE, taskDelay);
    data.put(FIXED_DELAY_TIME_UNIT, timeUnit);
    Trigger trigger = createSimpleTrigger(initialDelay, timeUnit, instance);
    try {
        sched.scheduleJob(job, trigger);
    } catch (SchedulerException se) {
        log.error("failed to schedule job", se);
    }
    return job.getKey().getName();
}
#end_block

#method_before
@Override
public String scheduleAOneTimeJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, long initialDelay, TimeUnit timeUnit) {
    String jobName = generateUniqueNameForInstance(instance, methodName);
    JobDetail job = newJob().withIdentity(jobName, Scheduler.DEFAULT_GROUP).ofType(JobWrapper.class).build();
    JobDataMap data = job.getJobDataMap();
    data.put(RUNNABLE_INSTANCE, instance);
    data.put(RUN_METHOD_NAME, methodName);
    data.put(RUN_METHOD_PARAM, inputParams);
    data.put(RUN_METHOD_PARAM_TYPE, inputTypes);
    Date runTime = getFutureDate(initialDelay, timeUnit);
    String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
    Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).startAt(runTime).build();
    try {
        sched.scheduleJob(job, trigger);
    } catch (SchedulerException se) {
        log.error("failed to schedule job", se);
    }
    return jobName;
}
#method_after
@Override
public String scheduleAOneTimeJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, long initialDelay, TimeUnit timeUnit) {
    JobDetail job = createJobWithBasicMapValues(instance, methodName, inputTypes, inputParams);
    Trigger trigger = createSimpleTrigger(initialDelay, timeUnit, instance);
    try {
        sched.scheduleJob(job, trigger);
    } catch (SchedulerException se) {
        log.error("failed to schedule job", se);
    }
    return job.getKey().getName();
}
#end_block

#method_before
@Override
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression) {
    String jobName = generateUniqueNameForInstance(instance, methodName);
    JobDetail job = newJob().withIdentity(jobName, Scheduler.DEFAULT_GROUP).ofType(JobWrapper.class).build();
    JobDataMap data = job.getJobDataMap();
    data.put(RUNNABLE_INSTANCE, instance);
    data.put(RUN_METHOD_NAME, methodName);
    data.put(RUN_METHOD_PARAM, inputParams);
    data.put(RUN_METHOD_PARAM_TYPE, inputTypes);
    try {
        String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
        Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).withSchedule(cronSchedule(cronExpression)).build();
        sched.scheduleJob(job, trigger);
    } catch (Exception se) {
        log.error("failed to schedule job", se);
    }
    return jobName;
}
#method_after
@Override
public String scheduleACronJob(Object instance, String methodName, Class<?>[] inputTypes, Object[] inputParams, String cronExpression) {
    JobDetail job = createJobWithBasicMapValues(instance, methodName, inputTypes, inputParams);
    try {
        String triggerName = generateUniqueNameForInstance(instance, TRIGGER_PREFIX);
        Trigger trigger = newTrigger().withIdentity(triggerName, Scheduler.DEFAULT_GROUP).withSchedule(cronSchedule(cronExpression)).build();
        sched.scheduleJob(job, trigger);
    } catch (Exception se) {
        log.error("failed to schedule job", se);
    }
    return job.getKey().getName();
}
#end_block

#method_before
private TreeItem createDiskItem(DiskImage disk) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<ListModel>(false, diskRowResources, true);
    Column<EntityModel, EntityModel> diskWithMappingColumn = new Column<EntityModel, EntityModel>(createDiskImageWithMappingComoisiteCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    TextColumn<EntityModel> paddingColumn = new TextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return "Disk" + asDisk(entity).getinternal_drive_mapping();
        }
    };
    TextColumnWithTooltip<EntityModel> virtualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSizeInGigabytes() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> actualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asDisk(entity).getActualDiskWithSnapshotsSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> snapshotsColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSnapshots().size() + "";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskWithMappingColumn, "diskWithMappingColumn", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(paddingColumn, "paddingColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "virtualSizeColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "actualSizeColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "snapshotsColumn", "31%");
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(disk);
    table.setRowData(Arrays.asList(entityModel));
    return new TreeItem(table);
}
#method_after
private TreeItem createDiskItem(DiskImage disk) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<ListModel>(false, diskRowResources, true);
    Column<EntityModel, EntityModel> diskWithMappingColumn = new Column<EntityModel, EntityModel>(createDiskImageWithMappingComoisiteCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    TextColumn<EntityModel> paddingColumn = new TextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return "Disk" + asDisk(entity).getinternal_drive_mapping();
        }
    };
    TextColumnWithTooltip<EntityModel> virtualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSizeInGigabytes() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> actualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asDisk(entity).getActualDiskWithSnapshotsSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> snapshotsColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSnapshots().size() + "";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskWithMappingColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(paddingColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(disk);
    table.setRowData(Arrays.asList(entityModel));
    return new TreeItem(table);
}
#end_block

#method_before
private VmTreeItem createVmItem(VM vm) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<ListModel>(false, vmRowResources, true);
    Column<EntityModel, EntityModel> vmImageWithNameColumn = new Column<EntityModel, EntityModel>(createVmImageWithNameCompositeCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    TextColumnWithTooltip<EntityModel> diskSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asVm(entity).getDiskList().size() + "";
        }
    };
    TextColumnWithTooltip<EntityModel> virtualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asVm(entity).getDiskSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> actualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asVm(entity).getActualDiskWithSnapshotsSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> snapshotsColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return asVm(entity).getDiskList().size() > 0 ? asVm(entity).getDiskList().get(0).getSnapshots().size() + "" : // $NON-NLS-1$ //$NON-NLS-2$
            "0";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(vmImageWithNameColumn, "vmImageWithNameColumn", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskSizeColumn, "diskSizeColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "virtualSizeColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "actualSizeColumn", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "snapshotsColumn", "31%");
    table.setSelectionModel(vmSelectionModel);
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(vm);
    table.setRowData(Arrays.asList(entityModel));
    return new VmTreeItem(table, vm);
}
#method_after
private VmTreeItem createVmItem(VM vm) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<ListModel>(false, vmRowResources, true);
    Column<EntityModel, EntityModel> vmImageWithNameColumn = new Column<EntityModel, EntityModel>(createVmImageWithNameCompositeCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    TextColumnWithTooltip<EntityModel> diskSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asVm(entity).getDiskList().size() + "";
        }
    };
    TextColumnWithTooltip<EntityModel> virtualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asVm(entity).getDiskSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> actualSizeColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return ((Double) asVm(entity).getActualDiskWithSnapshotsSize()).intValue() + "GB";
        }
    };
    TextColumnWithTooltip<EntityModel> snapshotsColumn = new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return asVm(entity).getDiskList().size() > 0 ? asVm(entity).getDiskList().get(0).getSnapshots().size() + "" : // $NON-NLS-1$ //$NON-NLS-2$
            "0";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(vmImageWithNameColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    table.setSelectionModel(vmSelectionModel);
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(vm);
    table.setRowData(Arrays.asList(entityModel));
    return new VmTreeItem(table, vm);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // add user session
    // todo : insert correct values of all arguments, separate
    HandleUserSession(_adUser);
    setActionReturnValue(getCurrentUser());
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    // Permissions for this user might been changed since last login so
    // update hiss isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // add user session
    // todo : insert correct values of all arguments, separate
    HandleUserSession(_adUser);
    setActionReturnValue(getCurrentUser());
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    // Permissions for this user might been changed since last login so
    // update his isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void testAdUserConstrcutor() {
    VdcUser user = new VdcUser(adUser);
    assertFalse("By default, a user should not be an admin", user.isAdmin());
    user.setIsAdmin(true);
    assertTrue("after being set as such, the user should be an admin", user.isAdmin());
}
#method_after
@Test
public void testAdUserConstrcutor() {
    VdcUser user = new VdcUser(adUser);
    assertFalse("By default, a user should not be an admin", user.isAdmin());
    user.setAdmin(true);
    assertTrue("after being set as such, the user should be an admin", user.isAdmin());
}
#end_block

#method_before
@Test
public void testAdUserAndFalseBooleanConstrcutor() {
    VdcUser user = new VdcUser(adUser, false);
    assertFalse("If not set, a user should not be an admin", user.isAdmin());
    user.setIsAdmin(true);
    assertTrue("after being set as such, the user should be an admin", user.isAdmin());
}
#method_after
@Test
public void testAdUserAndFalseBooleanConstrcutor() {
    VdcUser user = new VdcUser(adUser, false);
    assertFalse("If not set, a user should not be an admin", user.isAdmin());
    user.setAdmin(true);
    assertTrue("after being set as such, the user should be an admin", user.isAdmin());
}
#end_block

#method_before
@Test
public void testAdUserAndTrueBooleanConstrcutor() {
    VdcUser user = new VdcUser(adUser, true);
    assertTrue("If set, a user should not be an admin", user.isAdmin());
    user.setIsAdmin(false);
    assertFalse("after being set not to be, the user should be an admin", user.isAdmin());
}
#method_after
@Test
public void testAdUserAndTrueBooleanConstrcutor() {
    VdcUser user = new VdcUser(adUser, true);
    assertTrue("If set, a user should not be an admin", user.isAdmin());
    user.setAdmin(false);
    assertFalse("after being set not to be, the user should be an admin", user.isAdmin());
}
#end_block

#method_before
@Override
public void edit(VolumeBrickModel object) {
    table.setRowData(new ArrayList<ListModel>());
    table.edit(object.getBricks());
    Driver.driver.edit(object);
}
#method_after
@Override
public void edit(VolumeBrickModel object) {
    table.edit(object.getBricks());
    Driver.driver.edit(object);
}
#end_block

#method_before
public void addBricks() {
    if (getWindow() != null) {
        return;
    }
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(this.getReplicaCount().getEntity());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(this.getReplicaCount().getIsAvailable());
    volumeBrickModel.getStripeCount().setEntity(this.getStripeCount().getEntity());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(this.getStripeCount().getIsAvailable());
    setWindow(volumeBrickModel);
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("Ok", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
}
#method_after
public void addBricks() {
    if (getWindow() != null) {
        return;
    }
    VolumeBrickModel volumeBrickModel = new VolumeBrickModel();
    volumeBrickModel.getReplicaCount().setEntity(getReplicaCount().getEntity());
    volumeBrickModel.getReplicaCount().setIsChangable(true);
    volumeBrickModel.getReplicaCount().setIsAvailable(getReplicaCount().getIsAvailable());
    volumeBrickModel.getStripeCount().setEntity(getStripeCount().getEntity());
    volumeBrickModel.getStripeCount().setIsChangable(true);
    volumeBrickModel.getStripeCount().setIsAvailable(getStripeCount().getIsAvailable());
    setWindow(volumeBrickModel);
    volumeBrickModel.setTitle(ConstantsManager.getInstance().getConstants().addBricksVolume());
    // $NON-NLS-1$
    volumeBrickModel.setHashName("add_bricks");
    // TODO: fetch the mount points to display
    volumeBrickModel.getBricks().setItems(new ArrayList<EntityModel>());
    // $NON-NLS-1$
    UICommand command = new UICommand("Ok", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsDefault(true);
    volumeBrickModel.getCommands().add(command);
}
#end_block

#method_before
private void onAddBricks() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    if (!volumeBrickModel.validateAddBricks((GlusterVolumeType) this.getTypeList().getSelectedItem())) {
        return;
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object object : volumeBrickModel.getBricks().getSelectedItems()) {
        EntityModel entityModel = (EntityModel) object;
        brickList.add((GlusterBrickEntity) entityModel.getEntity());
    }
    ListModel brickListModel = new ListModel();
    brickListModel.setItems(brickList);
    setBricks(brickListModel);
    setWindow(null);
}
#method_after
private void onAddBricks() {
    VolumeBrickModel volumeBrickModel = (VolumeBrickModel) getWindow();
    if (!volumeBrickModel.validateAddBricks((GlusterVolumeType) getTypeList().getSelectedItem())) {
        return;
    }
    ArrayList<GlusterBrickEntity> brickList = new ArrayList<GlusterBrickEntity>();
    for (Object object : volumeBrickModel.getBricks().getSelectedItems()) {
        EntityModel entityModel = (EntityModel) object;
        brickList.add((GlusterBrickEntity) entityModel.getEntity());
    }
    ListModel brickListModel = new ListModel();
    brickListModel.setItems(brickList);
    setBricks(brickListModel);
    setWindow(null);
}
#end_block

#method_before
private void updateActionAvailability() {
    getRemoveVolumeCommand().setIsExecutionAllowed(getSelectedItem() != null);
    getStartCommand().setIsExecutionAllowed(getSelectedItem() != null);
    getStopCommand().setIsExecutionAllowed(getSelectedItem() != null);
    getRebalanceCommand().setIsExecutionAllowed(getSelectedItem() != null);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volume = (GlusterVolumeEntity) getSelectedItem();
    getRemoveVolumeCommand().setIsExecutionAllowed(getSelectedItem() != null);
    getStartCommand().setIsExecutionAllowed(volume != null && volume.getStatus() != GlusterVolumeStatus.UP);
    getStopCommand().setIsExecutionAllowed(getSelectedItem() != null);
    getRebalanceCommand().setIsExecutionAllowed(getSelectedItem() != null);
}
#end_block

#method_before
private void start() {
    if (getSelectedItem() == null) {
        return;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) getSelectedItem();
// Frontend.RunAction(VdcActionType.StartGlusterVolume, new GlusterVolumeParameters(clusterId,
// volume.getName()));
}
#method_after
private void start() {
    if (getSelectedItem() == null) {
        return;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) getSelectedItem();
    Frontend.RunAction(VdcActionType.StartGlusterVolume, new GlusterVolumeActionParameters(volume.getId(), false));
}
#end_block

#method_before
private void onCreateVolume() {
    VolumeModel model = (VolumeModel) getWindow();
    Guid clusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) model.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) model.getTypeList().getSelectedItem();
    if (type == GlusterVolumeType.STRIPE || type == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        volume.setStripeCount(Integer.parseInt((String) model.getStripeCount().getEntity()));
    } else if (type == GlusterVolumeType.REPLICATE || type == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        volume.setReplicaCount(Integer.parseInt((String) model.getReplicaCount().getEntity()));
    }
    volume.setVolumeType(type);
    if ((Boolean) model.getTcpTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.TCP);
    if ((Boolean) model.getRdmaTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.RDMA);
    volume.setBricks((List<GlusterBrickEntity>) model.getBricks().getItems());
    if ((Boolean) model.getNfs_accecssProtocol().getEntity())
        volume.enableNFS();
    else
        volume.disableNFS();
    if ((Boolean) model.getCifs_accecssProtocol().getEntity())
        volume.enableCifs();
    else
        volume.disableCifs();
    volume.setAccessControlList((String) model.getAllowAccess().getEntity());
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume);
    Frontend.RunAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    });
}
#method_after
private void onCreateVolume() {
    VolumeModel model = (VolumeModel) getWindow();
    Guid clusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setName((String) model.getName().getEntity());
    GlusterVolumeType type = (GlusterVolumeType) model.getTypeList().getSelectedItem();
    if (type == GlusterVolumeType.STRIPE || type == GlusterVolumeType.DISTRIBUTED_STRIPE) {
        volume.setStripeCount(model.getStripeCountValue());
    } else if (type == GlusterVolumeType.REPLICATE || type == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        volume.setReplicaCount(model.getReplicaCountValue());
    }
    volume.setVolumeType(type);
    if ((Boolean) model.getTcpTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.TCP);
    if ((Boolean) model.getRdmaTransportType().getEntity())
        volume.getTransportTypes().add(TransportType.RDMA);
    volume.setBricks((List<GlusterBrickEntity>) model.getBricks().getItems());
    if ((Boolean) model.getNfs_accecssProtocol().getEntity())
        volume.enableNFS();
    else
        volume.disableNFS();
    if ((Boolean) model.getCifs_accecssProtocol().getEntity())
        volume.enableCifs();
    else
        volume.disableCifs();
    volume.setAccessControlList((String) model.getAllowAccess().getEntity());
    CreateGlusterVolumeParameters parameter = new CreateGlusterVolumeParameters(volume);
    Frontend.RunAction(VdcActionType.CreateGlusterVolume, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    });
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(DbFacade.getInstance().getGlusterVolumeDao().getById(getParameters().getVolumeId()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getGlusterVolumeDao().getById(getParameters().getVolumeId()));
}
#end_block

#method_before
private void UpdateVmNetworks() {
    VmStatic dbVm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmStaticData().getId());
    // check if the cluster has changed
    if (!dbVm.getvds_group_id().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            // LINQ 29456
            // network net = networks.FirstOrDefault(n => iface.network_name
            // == n.name);
            // // if network not exists in cluster we remove the network to
            // interface connection
            // if (net == null)
            // {
            // iface.network_name = null;
            // DbFacade.Instance.updateVmInterface(iface.InterfaceDynamic);
            // }
            network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

                @Override
                public boolean eval(network n) {
                    return iface.getNetworkName().equals(n.getname());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDAO().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    VmStatic dbVm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmStaticData().getId());
    // check if the cluster has changed
    if (!dbVm.getvds_group_id().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

                @Override
                public boolean eval(network n) {
                    return iface.getNetworkName().equals(n.getname());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDAO().update(iface);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = false;
    List<ValidationError> validationErrors = null;
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        } else if (getVm().getStaticData() != null) {
            VM vm = DbFacade.getInstance().getVmDAO().getById(getVm().getStaticData().getId());
            // Checking if a desktop with same name already exists
            VmStatic vmStaticDataFromParams = getParameters().getVmStaticData();
            boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmStaticDataFromParams.getvm_name())).getReturnValue();
            if (exists && (!StringHelper.EqOp(vm.getvm_name(), vmStaticDataFromParams.getvm_name()))) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            } else if (!(validationErrors = VmPropertiesUtils.getInstance().validateVMProperties(DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticDataFromParams)).isEmpty()) {
                handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
            } else if (vmStaticDataFromParams.getauto_startup() && vmStaticDataFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
            } else if (VmHandler.isMemorySizeLegal(vmStaticDataFromParams.getos(), vmStaticDataFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
                if (StringHelper.EqOp(vmStaticDataFromParams.getvm_name(), "")) {
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_NAME_CANNOT_BE_EMPTY.toString());
                } else if (vm != null) {
                    setCustomDefinedProperties(vmStaticDataFromParams);
                    setCustomDefinedProperties(getVm().getStaticData());
                    retValue = VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), vmStaticDataFromParams, vm.getstatus());
                    if (!retValue) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
                    } else if (!getVm().getStaticData().getvds_group_id().equals(vmStaticDataFromParams.getvds_group_id())) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
                        retValue = false;
                    }
                    if (vmStaticDataFromParams.getdedicated_vm_for_vds() != null) {
                        VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vmStaticDataFromParams.getdedicated_vm_for_vds().toString()));
                        // if vds doesnt exist or not the same cluster
                        if (vds == null || !vds.getvds_group_id().equals(vmStaticDataFromParams.getvds_group_id())) {
                            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_DEFAULT_VDS_NOT_VALID);
                            retValue = false;
                        }
                    }
                    // Check if number of monitors passed is legal
                    if (!VmHandler.isNumOfMonitorsLegal(vmStaticDataFromParams.getdefault_display_type(), vmStaticDataFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
                        retValue = false;
                    }
                    if (vm.getnum_of_monitors() < vmStaticDataFromParams.getnum_of_monitors()) {
                        // LINQ 29456
                        // List<DiskImageBase> allDisks =
                        // DbFacade.Instance.GetImagesByVmGuid(VmId).Select(a
                        // =>
                        // (DiskImageBase)a).ToList();
                        // List<Interface> interfaces =
                        // DbFacade.Instance.getIterfacesByVmId(VmId);
                        // retValue =
                        // CheckPCIAndIDELimit(VmManagementParameters.VmStaticData.num_of_monitors,
                        // interfaces, allDisks);
                        List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVmId());
                        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
                        retValue = retValue && CheckPCIAndIDELimit(vmStaticDataFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages());
                    }
                    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmStaticDataFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
                        retValue = false;
                    }
                    if (retValue && vm.getVmPoolId() != null && vmStaticDataFromParams.getis_stateless()) {
                        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
                        retValue = false;
                    }
                }
            }
            if (retValue) {
                retValue = AddVmCommand.CheckCpuSockets(vmStaticDataFromParams.getnum_of_sockets(), vmStaticDataFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
            }
            // Check id dedicated host is same as VM cluster
            if (retValue) {
                retValue = isDedicatedVdsOnSameCluster(getParameters().getVmStaticData());
            }
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = false;
    List<ValidationError> validationErrors = null;
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        } else if (getVm().getStaticData() != null) {
            VM vm = DbFacade.getInstance().getVmDAO().get(getVm().getStaticData().getId());
            // Checking if a desktop with same name already exists
            VmStatic vmStaticDataFromParams = getParameters().getVmStaticData();
            boolean exists = (Boolean) Backend.getInstance().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmStaticDataFromParams.getvm_name())).getReturnValue();
            if (exists && (!StringHelper.EqOp(vm.getvm_name(), vmStaticDataFromParams.getvm_name()))) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            } else if (!(validationErrors = VmPropertiesUtils.getInstance().validateVMProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticDataFromParams)).isEmpty()) {
                handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
            } else if (vmStaticDataFromParams.getauto_startup() && vmStaticDataFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
            } else if (VmHandler.isMemorySizeLegal(vmStaticDataFromParams.getos(), vmStaticDataFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
                if (StringHelper.EqOp(vmStaticDataFromParams.getvm_name(), "")) {
                    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_NAME_CANNOT_BE_EMPTY.toString());
                } else if (vm != null) {
                    setCustomDefinedProperties(vmStaticDataFromParams);
                    setCustomDefinedProperties(getVm().getStaticData());
                    retValue = VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), vmStaticDataFromParams, vm.getstatus());
                    if (!retValue) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
                    } else if (!getVm().getStaticData().getvds_group_id().equals(vmStaticDataFromParams.getvds_group_id())) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
                        retValue = false;
                    }
                    if (vmStaticDataFromParams.getdedicated_vm_for_vds() != null) {
                        VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vmStaticDataFromParams.getdedicated_vm_for_vds().toString()));
                        // if vds doesnt exist or not the same cluster
                        if (vds == null || !vds.getvds_group_id().equals(vmStaticDataFromParams.getvds_group_id())) {
                            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_DEFAULT_VDS_NOT_VALID);
                            retValue = false;
                        }
                    }
                    // Check if number of monitors passed is legal
                    if (!VmHandler.isNumOfMonitorsLegal(vmStaticDataFromParams.getdefault_display_type(), vmStaticDataFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
                        retValue = false;
                    }
                    if (vm.getnum_of_monitors() < vmStaticDataFromParams.getnum_of_monitors()) {
                        List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVmId());
                        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
                        retValue = retValue && CheckPCIAndIDELimit(vmStaticDataFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages());
                    }
                    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmStaticDataFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
                        retValue = false;
                    }
                    if (retValue && vm.getVmPoolId() != null && vmStaticDataFromParams.getis_stateless()) {
                        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
                        retValue = false;
                    }
                }
            }
            if (retValue) {
                retValue = AddVmCommand.CheckCpuSockets(vmStaticDataFromParams.getnum_of_sockets(), vmStaticDataFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
            }
            // Check id dedicated host is same as VM cluster
            if (retValue) {
                retValue = isDedicatedVdsOnSameCluster(getParameters().getVmStaticData());
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private void setCustomDefinedProperties(VmStatic vmStaticDataFromParams) {
    VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticDataFromParams.getCustomProperties());
    vmStaticDataFromParams.setPredefinedProperties(properties.getPredefinedProperties());
    vmStaticDataFromParams.setUserDefinedProperties(properties.getUseDefinedProperties());
}
#method_after
private void setCustomDefinedProperties(VmStatic vmStaticDataFromParams) {
    VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticDataFromParams.getCustomProperties());
    vmStaticDataFromParams.setPredefinedProperties(properties.getPredefinedProperties());
    vmStaticDataFromParams.setUserDefinedProperties(properties.getUseDefinedProperties());
}
#end_block

#method_before
public static boolean CheckPCIAndIDELimit(int monitorsNumber, List<VmNetworkInterface> interfaces, List<DiskImageBase> disks, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    // LINQ 29456
    // int pciInUse = monitorsNumber + interfaces.Select(a =>
    // (a.type.HasValue &&
    // (VmInterfaceType)a.type.Value == VmInterfaceType.rtl8139_pv) ? 2 :
    // 1).Sum() +
    // disks.Where(a => a.disk_interface != DiskInterface.IDE).Count();
    int pciInUse = monitorsNumber;
    for (VmNetworkInterface a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv)
            pciInUse += 2;
        else
            pciInUse += 1;
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<DiskImageBase>() {

        @Override
        public boolean eval(DiskImageBase a) {
            return a.getdisk_interface() != DiskInterface.IDE;
        }
    }).size();
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else // DiskInterface.IDE).Count() > MAX_IDE_SLOTS)
    if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<DiskImageBase>() {

        @Override
        public boolean eval(DiskImageBase a) {
            return a.getdisk_interface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#method_after
public static <T extends Disk> boolean CheckPCIAndIDELimit(int monitorsNumber, List<VmNetworkInterface> interfaces, List<T> disks, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNetworkInterface a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv)
            pciInUse += 2;
        else
            pciInUse += 1;
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() != DiskInterface.IDE;
        }
    }).size();
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#end_block

#method_before
public static boolean UpdateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    java.util.HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new java.util.HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        java.util.ArrayList<DiskImage> AllVmImages = new java.util.ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()));
        }
        for (DiskImage disk : vm.getDiskMap().values()) {
            AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(disk.getId(), disk.getit_guid()));
        }
        if (StringHelper.isNullOrEmpty(vm.getvmt_name())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDAO().get(vm.getvmt_guid());
            vm.setvmt_name(t.getname());
        }
        String vmMeta = "";
        // OVF Uncomment next line when OVF support is added
        RefObject<String> tempRefObject = new RefObject<String>(vmMeta);
        ovfManager.ExportVm(tempRefObject, vm, AllVmImages);
        vmMeta = tempRefObject.argvalue;
        // LINQ 29456
        // vmsAndMetaDictionary.Add(vm.vm_guid, new KeyValuePair<string,
        // List<Guid>>
        // (vmMeta, vm.DiskMap.Values.Select(a =>
        // a.image_group_id.Value).ToList()));
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<DiskImage, Guid>() {

            @Override
            public Guid eval(DiskImage a) {
                return a.getimage_group_id().getValue();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public static boolean UpdateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    java.util.HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new java.util.HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        java.util.ArrayList<DiskImage> AllVmImages = new java.util.ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()));
        }
        for (Disk disk : vm.getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                DiskImage diskImage = (DiskImage) disk;
                AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
            }
        }
        if (StringHelper.isNullOrEmpty(vm.getvmt_name())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDAO().get(vm.getvmt_guid());
            vm.setvmt_name(t.getname());
        }
        String vmMeta = "";
        // OVF Uncomment next line when OVF support is added
        RefObject<String> tempRefObject = new RefObject<String>(vmMeta);
        ovfManager.ExportVm(tempRefObject, vm, AllVmImages);
        vmMeta = tempRefObject.argvalue;
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

            @Override
            public Guid eval(Disk a) {
                return a.getId();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected boolean HandleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implmented in SPM
    // LINQ 29456
    // Guid[] imagesList = Vm.hibernation_vol_handle.Split(',').Select(a =>
    // new Guid(a)).ToArray();
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        // boolean postZero = false; //LINQ
        // DbFacade.Instance.GetImagesByVmGuid(Vm.vm_guid).Exists(a =>
        // a.wipe_after_delete);
        boolean postZero = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVm().getId()), new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getwipe_after_delete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean HandleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implmented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVm().getId()), new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected List<DiskImageBase> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = LinqUtils.foreach(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVmTemplateId()), new Function<DiskImage, DiskImageBase>() {

            @Override
            public DiskImageBase eval(DiskImage diskImageTemplate) {
                return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(diskImageTemplate.getId());
            }
        });
    }
    return _vmDisks;
}
#method_after
protected List<? extends Disk> getVmDisks() {
    if (_vmDisks == null) {
        _vmDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getVmTemplateId());
    }
    return _vmDisks;
}
#end_block

#method_before
protected boolean CanAddVm(ArrayList<String> reasons, Collection<storage_domains> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.getInstance().validateVMProperties(DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (storage_domains domain : destStorages) {
                if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                } else if (!StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize(domain.getId()))) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
protected boolean CanAddVm(ArrayList<String> reasons, Collection<storage_domains> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.getInstance().validateVMProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (storage_domains domain : destStorages) {
                if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                } else if (!StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize(domain.getId()))) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getId().equals(VmTemplateHandler.BlankVmTemplateId);
}
#method_after
protected boolean shouldCheckSpaceInStorageDomains() {
    return !getImagesToCheckDestinationStorageDomains().isEmpty() && !LinqUtils.firstOrNull(getImagesToCheckDestinationStorageDomains(), new All<DiskImage>()).getImageId().equals(VmTemplateHandler.BlankVmTemplateId);
}
#end_block

#method_before
private boolean fillDestMap() {
    if (getParameters().getStorageDomainId() != null && !Guid.Empty.equals(getParameters().getStorageDomainId())) {
        Guid storageId = getParameters().getStorageDomainId();
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            diskInfoDestinationMap.put(image.getId(), makeNewImage(storageId, image));
        }
        return validateProvidedDestinations();
    }
    ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), diskInfoDestinationMap, destStorages, false);
    return true;
}
#method_after
private boolean fillDestMap() {
    if (getParameters().getStorageDomainId() != null && !Guid.Empty.equals(getParameters().getStorageDomainId())) {
        Guid storageId = getParameters().getStorageDomainId();
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            diskInfoDestinationMap.put(image.getImageId(), makeNewImage(storageId, image));
        }
        return validateProvidedDestinations();
    }
    ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), diskInfoDestinationMap, destStorages, false);
    return true;
}
#end_block

#method_before
protected boolean validateIsImagesOnDomains() {
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        if (!image.getstorage_ids().containsAll(diskInfoDestinationMap.get(image.getId()).getstorage_ids())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validateIsImagesOnDomains() {
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        if (!image.getstorage_ids().containsAll(diskInfoDestinationMap.get(image.getImageId()).getstorage_ids())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setId(image.getId());
    newImage.setvolume_format(image.getvolume_format());
    newImage.setvolume_type(image.getvolume_type());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setstorage_ids(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#method_after
private DiskImage makeNewImage(Guid storageId, DiskImage image) {
    DiskImage newImage = new DiskImage();
    newImage.setImageId(image.getImageId());
    newImage.setvolume_format(image.getvolume_format());
    newImage.setvolume_type(image.getvolume_type());
    ArrayList<Guid> storageIds = new ArrayList<Guid>();
    storageIds.add(storageId);
    newImage.setstorage_ids(storageIds);
    newImage.setQuotaId(image.getQuotaId());
    return newImage;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (CanAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                AddVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (CanAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                AddVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages, _vmInterfaces);
}
#end_block

#method_before
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getstorage_ids().get(0));
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean AddVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getImageId()).getstorage_ids().get(0));
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParemeters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getImageId()).getQuotaId());
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    permissionList = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    permissionList.addAll(QuotaHelper.getInstance().getPermissionsForDiskImagesList(diskInfoDestinationMap.values(), getStoragePool()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        addStoragePermissionByQuotaMode(permissionList, GuidUtils.getGuidValue(getStoragePoolId()), GuidUtils.getGuidValue(getStorageDomainId()));
    }
    permissionList = QuotaHelper.getInstance().addQuotaPermissionSubject(permissionList, getStoragePool(), getQuotaId());
    permissionList.addAll(QuotaHelper.getInstance().getPermissionsForDiskImagesList(diskInfoDestinationMap.values(), getStoragePool()));
    return permissionList;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid objectId = getParameters().getObjectId();
    List<permissions> perms;
    if (getParameters().getDirectOnly()) {
        perms = getPermissionDAO().getAllForEntity(objectId, getUserID(), getParameters().isFiltered());
    } else {
        perms = getPermissionDAO().getTreeForEntity(objectId, getParameters().getVdcObjectType(), getUserID(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(perms);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid objectId = getParameters().getObjectId();
    PermissionDAO dao = getDbFacade().getPermissionDAO();
    List<permissions> perms;
    if (getParameters().getDirectOnly()) {
        perms = dao.getAllForEntity(objectId, getUserID(), getParameters().isFiltered());
    } else {
        perms = dao.getTreeForEntity(objectId, getParameters().getVdcObjectType(), getUserID(), getParameters().isFiltered());
    }
    getQueryReturnValue().setReturnValue(perms);
}
#end_block

#method_before
public static void updateVmDevicesBootOrder(VmBase vmBase, List<VmDevice> devices, BootSequence bootSequence, boolean isOldCluster) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        if (isBootable(device)) {
            device.setBootOrder(0);
        }
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case CD:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
    }
}
#method_after
public static void updateVmDevicesBootOrder(VmBase vmBase, List<VmDevice> devices, BootSequence bootSequence, boolean isOldCluster) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        if (isBootable(device)) {
            // a boot order of 0 prevents it from being sent to VDSM
            device.setBootOrder(0);
        }
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case CD:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vmBase, devices, bootOrder, isOldCluster);
            break;
    }
}
#end_block

#method_before
private static boolean isBootable(VmDevice device) {
    return (device.getType().equals(VmDeviceType.DISK.getName()) || device.getType().equals(VmDeviceType.INTERFACE.getName()));
}
#method_after
private static boolean isBootable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getType()) || VmDeviceType.INTERFACE.getName().equals(device.getType()));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // sysprep handler and be done with it
    synchronized (o) {
        if (timezones == null) {
            timezones = new HashMap<String, String>();
            for (String value : SysprepHandler.timeZoneIndex.keySet()) {
                // we use:
                // key = "Afghanistan Standard Time"
                // value = "(GMT+04:30) Afghanistan Standard Time"
                String key = SysprepHandler.getTimezoneKey(value);
                timezones.put(key, value);
            }
            timezones = sortMapByValue(timezones);
        }
    }
    getQueryReturnValue().setReturnValue(timezones);
}
#method_after
@Override
protected void executeQueryCommand() {
    // sysprep handler and be done with it
    synchronized (LOCK) {
        if (timezones == null) {
            timezones = new HashMap<String, String>();
            for (String value : SysprepHandler.timeZoneIndex.keySet()) {
                // we use:
                // key = "Afghanistan Standard Time"
                // value = "(GMT+04:30) Afghanistan Standard Time"
                String key = SysprepHandler.getTimezoneKey(value);
                timezones.put(key, value);
            }
            timezones = sortMapByValue(timezones);
        }
    }
    getQueryReturnValue().setReturnValue(timezones);
}
#end_block

#method_before
private Map<String, String> sortMapByValue(Map<String, String> map) {
    List<Map.Entry<String, String>> list = new LinkedList<Map.Entry<String, String>>(map.entrySet());
    Collections.sort(list, new Comparator<Map.Entry<String, String>>() {

        private Pattern regex = Pattern.compile(SysprepHandler.TimzeZoneExtractTimePattern);

        // we get a string like "(GMT-04:30) Afghanistan Standard Time"
        // we use regex to extract the time only and replace it to number
        // in this sample we get -430
        @Override
        public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
            int a = 0, b = 0;
            Matcher match1 = regex.matcher(o1.toString());
            Matcher match2 = regex.matcher(o2.toString());
            if (match1.matches() && match1.groupCount() > 0) {
                a = Integer.parseInt(match1.group(1).substring(3).replace(":", "").replace("+", ""));
            }
            if (match2.matches() && match2.groupCount() > 0) {
                b = Integer.parseInt(match2.group(1).substring(3).replace(":", "").replace("+", ""));
            }
            return (a > b) ? 1 : 0;
        }
    });
    Map<String, String> result = new LinkedHashMap<String, String>();
    for (Iterator<Map.Entry<String, String>> it = list.iterator(); it.hasNext(); ) {
        Map.Entry<String, String> entry = it.next();
        result.put(entry.getKey(), entry.getValue());
    }
    return result;
}
#method_after
private static Map<String, String> sortMapByValue(Map<String, String> map) {
    List<Map.Entry<String, String>> list = new LinkedList<Map.Entry<String, String>>(map.entrySet());
    Collections.sort(list, TimeZoneTimeExtractComperator.instance);
    Map<String, String> result = new LinkedHashMap<String, String>();
    for (Iterator<Map.Entry<String, String>> it = list.iterator(); it.hasNext(); ) {
        Map.Entry<String, String> entry = it.next();
        result.put(entry.getKey(), entry.getValue());
    }
    return result;
}
#end_block

#method_before
@Override
public boolean IsConnectSucceeded(java.util.HashMap<String, String> returnValue, List<storage_server_connections> connections) {
    boolean result = true;
    for (Map.Entry<String, String> entry : returnValue.entrySet()) {
        if (!"0".equals(entry.getValue())) {
            String connectionField = addToAuditLogErrorMessage(entry.getKey(), entry.getValue(), connections);
            printLog(getLog(), connectionField, entry.getValue());
            result = false;
        }
    }
    return result;
}
#method_after
@Override
public boolean IsConnectSucceeded(Map<String, String> returnValue, List<storage_server_connections> connections) {
    boolean result = true;
    for (Map.Entry<String, String> entry : returnValue.entrySet()) {
        if (!"0".equals(entry.getValue())) {
            String connectionField = addToAuditLogErrorMessage(entry.getKey(), entry.getValue(), connections);
            printLog(getLog(), connectionField, entry.getValue());
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc setVmTicket(String vmId, String otp64, String sec, String connectionAction, Map<String, String> params) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.setVmTicket(vmId, otp64, sec, connectionAction, params);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(Map<String, Object> volumeData) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeData));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private void setUpDAOMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName(), getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getImageId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshots(pluggedDisk.getId()))));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getImageId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshots(unpluggedDisk.getId()))));
}
#method_after
private void setUpDAOMocks() {
    // Mock some devices
    VmDevice pluggedDevice = createVMDevice(vmID, pluggedDisk);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.DISK.getName(), VmDeviceType.DISK.getName(), getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getImageId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(pluggedDisk.getId()))));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getImageId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(NUM_DISKS_OF_EACH_KIND, createDiskSnapshot(unpluggedDisk.getId()))));
}
#end_block

#method_before
private static void assertCorrectSnapshots(DiskImage disk) {
    for (int i = 0; i < NUM_DISKS_OF_EACH_KIND; ++i) {
        assertEquals("Wrong snapshot " + i + " for disk ", disk.getId(), disk.getSnapshots().get(i).getImageId());
    }
}
#method_after
private static void assertCorrectSnapshots(DiskImage disk) {
    for (int i = 0; i < NUM_DISKS_OF_EACH_KIND; ++i) {
        assertEquals("Wrong snapshot " + i + " for disk ", disk.getId(), disk.getSnapshots().get(i).getId());
    }
}
#end_block

#method_before
private boolean checkQuotaValidationCommon(Quota quota, List<String> messages) {
    if (quota == null) {
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    }
    // Check if quota name isn't reserved.
    if (!checkQuotaNameReserved(quota, messages)) {
        return false;
    }
    // Check if quota name exists.
    if (!checkQuotaNameExisting(quota, messages)) {
        return false;
    }
    // If specific Quota for storage is specified
    if (!validateQuotaStorageLimitation(quota, messages)) {
        return false;
    }
    // If specific Quota for VDS Group is specific
    if (!validateQuotaVdsGroupLimitation(quota, messages)) {
        return false;
    }
    return true;
}
#method_after
private boolean checkQuotaValidationCommon(Quota quota, List<String> messages) {
    if (quota == null) {
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    }
    // If a user manually tries to add a quota with this reserved name, it should not be allowed.
    if (!checkQuotaNamePrefixReserved(quota, messages)) {
        return false;
    }
    // Check if quota name exists.
    if (!checkQuotaNameExisting(quota, messages)) {
        return false;
    }
    // If specific Quota for storage is specified
    if (!validateQuotaStorageLimitation(quota, messages)) {
        return false;
    }
    // If specific Quota for VDS Group is specific
    if (!validateQuotaVdsGroupLimitation(quota, messages)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testQuotaWithReservedName() throws Exception {
    List<String> messages = new ArrayList<String>();
    Quota mockQuota = mockGeneralStorageQuota();
    mockQuota.setIsDefaultQuota(false);
    mockQuota.setQuotaName("DefaultQuota-Storage pool name");
    boolean isQuotaValid = quotaHelper.checkQuotaNameReserved(mockQuota, messages);
    assertTrue(messages.contains(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NAME_RESERVED_FOR_DEFAULT.toString()));
    assertFalse(isQuotaValid);
}
#method_after
@Test
public void testQuotaWithReservedName() throws Exception {
    List<String> messages = new ArrayList<String>();
    Quota mockQuota = mockGeneralStorageQuota();
    mockQuota.setIsDefaultQuota(false);
    mockQuota.setQuotaName("DefaultQuota-Storage pool name");
    boolean isQuotaValid = quotaHelper.checkQuotaNamePrefixReserved(mockQuota, messages);
    assertTrue(messages.contains(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NAME_RESERVED_FOR_DEFAULT.toString()));
    assertFalse(isQuotaValid);
}
#end_block

#method_before
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    if (!quotaParameter.isEmptyStorageQuota()) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (!quotaParameter.isEmptyVdsGroupQuota()) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#method_after
private void setQuotaParameter() {
    Quota quotaParameter = getParameters().getQuota();
    setStoragePoolId(quotaParameter.getStoragePoolId());
    setQuotaName(quotaParameter.getQuotaName());
    quotaParameter.setIsDefaultQuota(false);
    if (!quotaParameter.isEmptyStorageQuota()) {
        for (QuotaStorage quotaStorage : quotaParameter.getQuotaStorages()) {
            quotaStorage.setQuotaId(getQuotaId());
            quotaStorage.setQuotaStorageId(Guid.NewGuid());
        }
    }
    if (!quotaParameter.isEmptyVdsGroupQuota()) {
        for (QuotaVdsGroup quotaVdsGroup : quotaParameter.getQuotaVdsGroups()) {
            quotaVdsGroup.setQuotaId(getQuotaId());
            quotaVdsGroup.setQuotaVdsGroupId(Guid.NewGuid());
        }
    }
    setQuota(quotaParameter);
}
#end_block

