207
#method_before
private boolean unplugPassthroughNics() {
    if (passthroughNicsUnplugged) {
        // no need to unplug more than once
        return true;
    }
    passthroughNicsUnplugged = true;
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getAllVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    return true;
}
#method_after
private boolean unplugPassthroughNics() {
    if (passthroughNicsUnplugged) {
        // no need to unplug more than once
        return true;
    }
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getAllVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    passthroughNicsUnplugged = true;
    return true;
}
#end_block

#method_before
public List<LUNs> getVgLUNsInfo(StorageDomainStatic storageDomain, Guid vdsId) {
    try {
        return (ArrayList<LUNs>) resourceManager.runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(vdsId, storageDomain.getStorage())).getReturnValue();
    } catch (Exception e) {
        log.info("Failed to get the domain info, ignoring");
    }
    return null;
}
#method_after
@SuppressWarnings("unchecked")
public List<LUNs> getVgLUNsInfo(StorageDomainStatic storageDomain, Guid vdsId) {
    try {
        return (List<LUNs>) resourceManager.runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(vdsId, storageDomain.getStorage())).getReturnValue();
    } catch (Exception e) {
        log.info("Failed to get the domain info, ignoring");
    }
    return null;
}
#end_block

#method_before
public void validateFreeSpace() {
    List<LUNs> allLuns = blockStorageDomainHelper.getVgLUNsInfo(getStorageDomain().getStorageStaticData(), getVdsId());
    if (allLuns == null) {
        getAuditLogDirector().log(this, AuditLogType.USER_REDUCE_DOMAIN_DEVICES_FAILED_TO_GET_DOMAIN_INFO);
        throw new EngineException(EngineError.GeneralException, "Failed to get the vg info");
    }
    Long freeExtants = allLuns.stream().filter(l -> getParameters().getDstDevices().contains(l.getLUNId())).mapToLong(l -> l.getPeCount() - l.getPeAllocatedCount()).sum();
    Long neededExtants = allLuns.stream().filter(l -> getParameters().getDevicesToReduce().contains(l.getLUNId())).mapToLong(LUNs::getPeAllocatedCount).sum();
    if (neededExtants > freeExtants) {
        getAuditLogDirector().log(this, AuditLogType.USER_REDUCE_DOMAIN_DEVICES_FAILED_NO_FREE_SPACE);
        throw new EngineException(EngineError.GeneralException, "Not enough free space on the destination devices");
    }
}
#method_after
public void validateFreeSpace() {
    List<LUNs> allLuns = blockStorageDomainHelper.getVgLUNsInfo(getStorageDomain().getStorageStaticData(), getVdsId());
    if (allLuns == null) {
        getAuditLogDirector().log(this, AuditLogType.USER_REDUCE_DOMAIN_DEVICES_FAILED_TO_GET_DOMAIN_INFO);
        throw new EngineException(EngineError.GeneralException, "Failed to get the vg info");
    }
    long freeExtents = allLuns.stream().filter(l -> getParameters().getDstDevices().contains(l.getLUNId())).mapToLong(l -> l.getPeCount() - l.getPeAllocatedCount()).sum();
    long neededExtents = allLuns.stream().filter(l -> getParameters().getDevicesToReduce().contains(l.getLUNId())).mapToLong(LUNs::getPeAllocatedCount).sum();
    if (neededExtents > freeExtents) {
        getAuditLogDirector().log(this, AuditLogType.USER_REDUCE_DOMAIN_DEVICES_FAILED_NO_FREE_SPACE);
        throw new EngineException(EngineError.GeneralException, "Not enough free space on the destination devices");
    }
}
#end_block

#method_before
@Override
public <U extends T> Instance<U> select(Class<U> aClass, Annotation... annotations) {
    return createMockInstance(aClass);
}
#method_after
@Override
@SuppressWarnings("unchecked")
public <U extends T> Instance<U> select(Class<U> aClass, Annotation... annotations) {
    return new SimpleInstanceIdGenerator<>((U) beansCache.get(aClass));
}
#end_block

#method_before
protected static String renameDiskAlias(OriginType originType, String alias) {
    Matcher matcher;
    if (originType == OriginType.VMWARE) {
        matcher = VMWARE_DISK_NAME_PATTERN.matcher(alias);
    } else {
        matcher = DISK_NAME_PATTERN.matcher(alias);
    }
    if (matcher.matches()) {
        return matcher.group(1).replace(' ', '_');
    }
    return alias;
}
#method_after
protected static String renameDiskAlias(OriginType originType, String alias) {
    Matcher matcher;
    if (originType == OriginType.VMWARE) {
        matcher = VMWARE_DISK_NAME_PATTERN.matcher(alias);
    } else {
        matcher = DISK_NAME_PATTERN.matcher(alias);
    }
    if (matcher.matches()) {
        return replaceInvalidDiskAliasChars(matcher.group(1));
    }
    return replaceInvalidDiskAliasChars(alias);
}
#end_block

#method_before
public static void init() {
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    dbFacade = SimpleDependencyInjector.getInstance().get(DbFacade.class);
    vmDeviceDao = dbFacade.getVmDeviceDao();
    vmDao = dbFacade.getVmDao();
}
#method_after
public static void init() {
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    dbFacade = SimpleDependencyInjector.getInstance().get(DbFacade.class);
    vmDeviceDao = dbFacade.getVmDeviceDao();
    vmDao = dbFacade.getVmDao();
    clusterDao = dbFacade.getClusterDao();
}
#end_block

#method_before
private static UsbControllerModel getUsbControllerModel(VmBase vmBase) {
    final VM vm = vmDao.get(vmBase.getId());
    return osRepository.getOsUsbControllerModel(vmBase.getOsId(), vm.getCompatibilityVersion());
}
#method_after
/**
 * @return usb controller model defined as defined in osinfo file for VM's OS and effective compatibility version
 */
private static UsbControllerModel getUsbControllerModel(VmBase vmBase) {
    final Version version = vmBase.getCustomCompatibilityVersion() != null ? vmBase.getCustomCompatibilityVersion() : vmBase.getClusterId() != null ? clusterDao.get(vmBase.getClusterId()).getCompatibilityVersion() : null;
    return osRepository.getOsUsbControllerModel(vmBase.getOsId(), version);
}
#end_block

#method_before
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    if (Config.<Boolean>getValue(ConfigValues.EnableHostUpdate)) {
        double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
        final int HOURS_TO_MINUTES = 60;
        long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
        registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], RandomUtils.nextInt(HOURS_TO_MINUTES) + 1, rateInMinutes, TimeUnit.MINUTES));
    }
    vmsRefresher = getRefresherFactory().create(this);
    vmsRefresher.startMonitoring();
    hostRefresher = new HostConnectionRefresher(this, resourceManager);
    hostRefresher.start();
}
#method_after
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    if (availableUpdatesRefreshRate > 0) {
        final int HOURS_TO_MINUTES = 60;
        long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
        registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], RandomUtils.nextInt(HOURS_TO_MINUTES) + 1, rateInMinutes, TimeUnit.MINUTES));
    }
    vmsRefresher = getRefresherFactory().create(this);
    vmsRefresher.startMonitoring();
    hostRefresher = new HostConnectionRefresher(this, resourceManager);
    hostRefresher.start();
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting();
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVmsToUnknown(vmsRunningOnVds);
                    logHostFailToRespond(ex);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    saveToDb = false;
                }
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting();
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVmsToUnknown(vmsRunningOnVds);
                    // we want to try to restart VMs with lease right after they switch to unknown
                    autoRestartUnknownVmsIteration = -1;
                    logHostFailToRespond(ex);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    saveToDb = false;
                }
                restartVmsWithLeaseIfNeeded(vmsRunningOnVds);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    return false;
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                if (getVfPreallocatedForNic() == null && findFreeVf() == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isNicToBePlugged) {
                if (isPassthrough()) {
                    try {
                        hostDeviceManager.acquireHostDevicesLock(getVdsId());
                        vfToUse = updateFreeVf();
                        if (vfToUse == null) {
                            return;
                        }
                        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                        vmDevice.setHostDevice(vfToUse);
                    } finally {
                        hostDeviceManager.releaseHostDevicesLock(getVdsId());
                    }
                }
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                boolean passthroughHotPlug = vfToUse != null;
                boolean passthroughHotUnplug = isPassthrough() && getParameters().getAction() == PlugAction.UNPLUG;
                if (passthroughHotUnplug) {
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                }
                if (passthroughHotPlug || passthroughHotUnplug) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    switch(getParameters().getAction()) {
        case PLUG:
            plugNic();
            break;
        case UNPLUG:
            unplugNic();
            break;
        default:
            throw new RuntimeException("Coding error: unknown enum value");
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = XmlRpcStringUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = StringMapUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = StringMapUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public ValidationResult isMacAssignableValidator() {
    Boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean illegalDuplicateMacUsage = !allowDupMacs && macPool.isMacInUse(macAddress);
    EngineMessage failMessage = EngineMessage.NETWORK_MAC_ADDRESS_IN_USE;
    return ValidationResult.failWith(failMessage, ReplacementUtils.getVariableAssignmentString(failMessage, macAddress)).when(illegalDuplicateMacUsage);
}
#method_after
public ValidationResult isMacAssignableValidator() {
    boolean allowDupMacs = macPool.isDuplicateMacAddressesAllowed();
    boolean illegalDuplicateMacUsage = !allowDupMacs && macPool.isMacInUse(macAddress);
    EngineMessage failMessage = EngineMessage.NETWORK_MAC_ADDRESS_IN_USE;
    return ValidationResult.failWith(failMessage, ReplacementUtils.getVariableAssignmentString(failMessage, macAddress)).when(illegalDuplicateMacUsage);
}
#end_block

#method_before
public void buildVmLease() {
    Map<String, Object> device = new HashMap<>();
    device.put(VdsProperties.Type, VdsProperties.VmLease);
    device.put(VdsProperties.Device, VdsProperties.VmLease);
    device.put(VdsProperties.DeviceId, Guid.newGuid());
    Map<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.VM_LEASE_SD_ID, vm.getLeaseStorageDomainId());
    specParams.put(VdsProperties.VM_LEASE_ID, vm.getId());
    device.put(VdsProperties.SpecParams, specParams);
    devices.add(device);
}
#method_after
public void buildVmLease() {
    Map<String, Object> device = new HashMap<>();
    device.put(VdsProperties.Type, VdsProperties.VmLease);
    device.put(VdsProperties.Device, VdsProperties.VmLease);
    device.put(VdsProperties.DeviceId, Guid.newGuid());
    Map<String, Object> specParams = new HashMap<>();
    specParams.put(VdsProperties.VmLeaseSdId, vm.getLeaseStorageDomainId());
    specParams.put(VdsProperties.VmLeaseId, vm.getId());
    device.put(VdsProperties.SpecParams, specParams);
    devices.add(device);
}
#end_block

#method_before
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk && vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            }
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#method_after
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#end_block

#method_before
public static VMStatus convertToVmStatus(String status) {
    switch(status) {
        case "Migration Source":
            return VMStatus.MigratingFrom;
        case "Migration Destination":
            return VMStatus.MigratingTo;
        default:
            status = status.replace(" ", "");
            try {
                return EnumUtils.valueOf(VMStatus.class, status, true);
            } catch (Exception e) {
                log.error("Illegal VM status: '{}'.", status);
                return VMStatus.Unassigned;
            }
    }
}
#method_after
public static VMStatus convertToVmStatus(String status) {
    switch(status) {
        case VdsProperties.MIGRATION_SOURCE:
            return VMStatus.MigratingFrom;
        case VdsProperties.MIGRATION_DESTINATION:
            return VMStatus.MigratingTo;
        default:
            status = status.replace(" ", "");
            try {
                return EnumUtils.valueOf(VMStatus.class, status, true);
            } catch (Exception e) {
                log.error("Illegal VM status: '{}'.", status);
                return VMStatus.Unassigned;
            }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean returnValue = true;
    Permission p = permissionDao.get(getParameters().getPermission().getId());
    if (MultiLevelAdministrationHandler.isLastSuperUserPermission(p.getRoleId())) {
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_REMOVE_LAST_SUPER_USER_ROLE.toString());
        returnValue = false;
    } else if (p.getRoleType().equals(RoleType.ADMIN) && !isSystemSuperUser()) {
        addValidationMessage(EngineMessage.PERMISSION_REMOVE_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_REMOVE_ADMIN_ROLES);
        returnValue = false;
    } else if (Objects.equals(p.getObjectId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID) && Objects.equals(p.getAdElementId(), MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID)) {
        addValidationMessage(EngineMessage.SYSTEM_PERMISSIONS_CANT_BE_REMOVED_TO_EVERYONE);
        returnValue = false;
    }
    if (!Objects.equals(p.getAdElementId(), getParameters().getTargetId()) && dbUserDao.get(getParameters().getTargetId()) != null) {
        addValidationMessage(EngineMessage.INHERITED_PERMISSION_CANT_BE_REMOVED);
        returnValue = false;
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    boolean returnValue = true;
    Permission p = permissionDao.get(getParameters().getPermission().getId());
    if (MultiLevelAdministrationHandler.isLastSuperUserPermission(p.getRoleId())) {
        getReturnValue().getValidationMessages().add(EngineMessage.ERROR_CANNOT_REMOVE_LAST_SUPER_USER_ROLE.toString());
        returnValue = false;
    } else if (p.getRoleType().equals(RoleType.ADMIN) && !isSystemSuperUser()) {
        addValidationMessage(EngineMessage.PERMISSION_REMOVE_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_REMOVE_ADMIN_ROLES);
        returnValue = false;
    } else if (Objects.equals(p.getObjectId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID) && Objects.equals(p.getAdElementId(), MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID)) {
        addValidationMessage(EngineMessage.SYSTEM_PERMISSIONS_CANT_BE_REMOVED_FROM_EVERYONE);
        returnValue = false;
    }
    if (!Objects.equals(p.getAdElementId(), getParameters().getTargetId()) && dbUserDao.get(getParameters().getTargetId()) != null) {
        addValidationMessage(EngineMessage.INHERITED_PERMISSION_CANT_BE_REMOVED);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
        try {
            plugNics(allVmPassthroughNics);
        } catch (Exception e) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NOT_PLUGGING_VM_NICS_FAILED);
            log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
            log.debug("Exception: ", e);
        }
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
        try {
            plugNics(allVmPassthroughNics);
        } catch (Exception e) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
            log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
            log.debug("Exception: ", e);
        }
    }
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    Map<String, String> props = super.getJobMessageProperties();
    props.put(STEP_DEVICE_TYPE, getParameters().getDeviceId());
    return props;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
    }
    jobProperties.put(STEP_DEVICE_TYPE, getParameters().getDeviceId());
    return jobProperties;
}
#end_block

#method_before
@Test
public void testVmMigrationSubscription() {
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|VM_migration_status|*");
    SubscriptionHolder holder = new SubscriptionHolder(subscriber, new AtomicInteger());
    EventSubscriber subscriber2 = mock(EventSubscriber.class);
    when(subscriber2.getSubscriptionId()).thenReturn("*|*|VM_status|*");
    SubscriptionHolder holder2 = new SubscriptionHolder(subscriber2, new AtomicInteger());
    SubscriptionMatcher matcher = new SubscriptionMatcher();
    matcher.add(holder);
    matcher.add(holder2);
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("10.35.18.138|virt|VM_status|d4b04c1d-c2bc-41e3-add7-bcad2ab782d4");
    JsonRpcEvent event2 = mock(JsonRpcEvent.class);
    when(event2.getMethod()).thenReturn("10.35.0.96|virt|VM_migration_status|d4b04c1d-c2bc-41e3-add7-bcad2ab782d4");
    Set<SubscriptionHolder> holders = matcher.match(event);
    assertEquals(1, holders.size());
    Set<SubscriptionHolder> holders2 = matcher.match(event2);
    assertEquals(1, holders2.size());
}
#method_after
@Test
public void testVmMigrationSubscription() {
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|VM_migration_status|*");
    SubscriptionHolder holder = new SubscriptionHolder(subscriber, new AtomicInteger());
    EventSubscriber subscriber2 = mock(EventSubscriber.class);
    when(subscriber2.getSubscriptionId()).thenReturn("10.35.0.96|*|VM_status|*");
    SubscriptionHolder holder2 = new SubscriptionHolder(subscriber2, new AtomicInteger());
    SubscriptionMatcher matcher = new SubscriptionMatcher();
    matcher.add(holder);
    matcher.add(holder2);
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("10.35.0.96|virt|VM_migration_status|d4b04c1d-c2bc-41e3-add7");
    Set<SubscriptionHolder> holders = matcher.match(event);
    assertEquals(1, holders.size());
}
#end_block

#method_before
private RemoveDeviceFromSANStorageDomainCommandParameters createRemoveParameters(String deviceId) {
    RemoveDeviceFromSANStorageDomainCommandParameters p = new RemoveDeviceFromSANStorageDomainCommandParameters(getParameters().getStorageDomainId(), deviceId);
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setVdsId(getParameters().getVdsId());
    p.setParentCommand(getActionType());
    p.setParentParameters(getParameters());
    p.setDestinationDevices(getParameters().getDstDevices());
    return p;
}
#method_after
private RemoveDeviceFromSANStorageDomainCommandParameters createRemoveParameters(String deviceId) {
    RemoveDeviceFromSANStorageDomainCommandParameters p = new RemoveDeviceFromSANStorageDomainCommandParameters(getParameters().getStorageDomainId(), deviceId);
    p.setEndProcedure(EndProcedure.PARENT_MANAGED);
    p.setVdsId(getParameters().getVdsId());
    p.setParentCommand(getActionType());
    p.setParentParameters(getParameters());
    p.setDestinationDevices(getParameters().getDstDevices());
    return p;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (CollectionUtils.isEmpty(getParameters().getDevicesToReduce())) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_PARAMETERS_INVALID);
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    if (!validateReduceDeviceSupported()) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!validateDevices()) {
        return false;
    }
    if (!checkStorageDomainStatus(StorageDomainStatus.Maintenance)) {
        return false;
    }
    if (!initializeVds()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (CollectionUtils.isEmpty(getParameters().getDevicesToReduce())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_DEVICES_PROVIDED);
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    if (!validateReduceDeviceSupported()) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!validateDevices()) {
        return false;
    }
    if (!checkStorageDomainStatus(StorageDomainStatus.Maintenance)) {
        return false;
    }
    if (!initializeVds()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean validateReduceDeviceSupported() {
    if (getStoragePool() != null && !FeatureSupported.reduceDeviceFromStorageDomain(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_DOMAIN_DEVICE_NOT_SUPPORTED);
    }
    return true;
}
#method_after
private boolean validateReduceDeviceSupported() {
    if (getStorageDomain().getStorageFormat() == StorageFormatType.V1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_FORMAT_ILLEGAL, String.format("$storageFormat %1$s", StorageFormatType.V1.toString()));
    }
    if (getStoragePool() != null && !FeatureSupported.reduceDeviceFromStorageDomain(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_REDUCE_DOMAIN_DEVICE_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private void endOperation() {
    try {
        disconnectHostFromDomain();
    } catch (Exception e) {
        log.error("Failed to disconnect the host from the domain storage servers, ignoring", e);
    }
    // TODO: currently we need to execute the endAction() of the child commands from here after we disconnected from
    // the domain, that's because the connections filter code in the StorageHelper that currently assumes that if
    // lun id is passed there's no lun disk using the device. After that will be fixed we may let the child commands
    // end by themselves and remove the device from the domain/disconnect.
    endActionOnDevices();
    setSucceeded(true);
}
#method_after
private void endOperation() {
    try {
        disconnectHostFromDomain();
    } catch (Exception e) {
        log.error("Failed to disconnect the host from the domain storage servers, ignoring", e);
    }
    // TODO: currently we need to execute the endAction() of the child commands from here after we disconnected from
    // the domain, that's because the connections filter code in the StorageHelper that currently assumes that if
    // lun id is passed there's no lun disk using the device. After that will be fixed we may let the child commands
    // end by themselves (EndProcedure = COMMAND_MANAGED) and remove the device from the domain/disconnect on that
    // phase before all the devices were reduced from the domain.
    endActionOnDevices();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    setSucceeded(initVdss() && perform());
}
#method_after
@Override
protected void executeVmCommand() {
    resourceManager.getVmManager(getVmId()).getStatistics().setMigrationProgressPercent(0);
    setSucceeded(initVdss() && perform());
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId(), getCluster().getCompatibilityVersion());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#end_block

#method_before
private MigrationPolicy findEffectiveConvergenceConfig(MigrationPolicy clusterMigrationPolicy) {
    Guid overriddenPolicyId = getVm().getMigrationPolicyId();
    if (overriddenPolicyId == null) {
        return clusterMigrationPolicy;
    }
    return convergenceConfigProvider.getMigrationPolicy(overriddenPolicyId);
}
#method_after
private MigrationPolicy findEffectiveConvergenceConfig(MigrationPolicy clusterMigrationPolicy) {
    Guid overriddenPolicyId = getVm().getMigrationPolicyId();
    if (overriddenPolicyId == null) {
        return clusterMigrationPolicy;
    }
    return convergenceConfigProvider.getMigrationPolicy(overriddenPolicyId, getCluster().getCompatibilityVersion());
}
#end_block

#method_before
public Optional<Guid> schedule(@NotNull Cluster cluster, @NotNull VM vm, @NotNull List<Guid> hostBlackList, @NotNull List<Guid> hostWhiteList, @NotNull List<Guid> destHostIdList, @NotNull List<String> messages, @NotNull VdsFreeMemoryChecker memoryChecker, @NotNull String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return null;
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent()) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Optional<Guid> schedule(@NotNull Cluster cluster, @NotNull VM vm, @NotNull List<Guid> hostBlackList, @NotNull List<Guid> hostWhiteList, @NotNull List<Guid> destHostIdList, @NotNull List<String> messages, @NotNull VdsFreeMemoryChecker memoryChecker, @NotNull String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent()) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
public boolean canMaintenanceVds(Guid vdsId, ArrayList<String> reasons) {
    boolean returnValue = true;
    // VDS vds = ResourceManager.Instance.getVds(vdsId);
    VDS vds = vdsDao.get(vdsId);
    // we can get here when vds status was set already to Maintenance
    if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down && (vds.getStatus() != VDSStatus.InstallFailed))) {
        returnValue = false;
        reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
    }
    orderListOfRunningVmsOnVds(vdsId);
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
            reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM.toString());
            return false;
        }
    }
    return returnValue;
}
#method_after
public boolean canMaintenanceVds(Guid vdsId, ArrayList<String> reasons) {
    boolean returnValue = true;
    // VDS vds = ResourceManager.Instance.getVds(vdsId);
    VDS vds = vdsDao.get(vdsId);
    // we can get here when vds status was set already to Maintenance
    if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down && (vds.getStatus() != VDSStatus.InstallFailed))) {
        returnValue = false;
        reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
    }
    orderListOfRunningVmsOnVds(vdsId);
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // Check if there are available Hosted Engine hosts for that VM
            if (!HostedEngineHelper.haveHostsAvailableforHE(vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up), Collections.singletonList(vds.getId()))) {
                reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE.toString());
                return false;
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
            reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM.toString());
            return false;
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return false;
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = findFreeVf();
                if (vfToUse == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#method_after
private boolean failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    return failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    boolean isNicToBeUnplugged = getParameters().getAction() == PlugAction.UNPLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            boolean shouldAcquireVF = isNicToBePlugged && isPassthrough();
            if (shouldAcquireVF) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                }
                vmDevice.setHostDevice(vfToUse);
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                if (isPassthrough()) {
                    if (isNicToBeUnplugged) {
                        networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                    }
                    if (isNicToBePlugged || isNicToBeUnplugged) {
                        runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                    }
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    boolean isNicToBeUnplugged = getParameters().getAction() == PlugAction.UNPLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            boolean shouldAcquireVF = isNicToBePlugged && isPassthrough();
            if (shouldAcquireVF) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                }
                networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                vmDevice.setHostDevice(vfToUse);
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                if (isPassthrough()) {
                    if (isNicToBeUnplugged) {
                        networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                    }
                    if (isNicToBePlugged || isNicToBeUnplugged) {
                        runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                    }
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        String vfToUse = updateFreeVf();
        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
        return vfToUse;
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#method_after
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        return findFreeVf();
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return false;
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = findFreeVf();
                if (vfToUse == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#method_after
private boolean failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    return failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isNicToBePlugged) {
                if (isPassthrough()) {
                    try {
                        hostDeviceManager.acquireHostDevicesLock(getVdsId());
                        vfToUse = updateFreeVf();
                        if (vfToUse == null) {
                            failValidationCannotPlugPassthroughVnicNoSuitableVf();
                            return;
                        }
                        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                        vmDevice.setHostDevice(vfToUse);
                    } finally {
                        hostDeviceManager.releaseHostDevicesLock(getVdsId());
                    }
                }
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                boolean passthroughHotPlug = vfToUse != null;
                boolean passthroughHotUnplug = isPassthrough() && getParameters().getAction() == PlugAction.UNPLUG;
                if (passthroughHotUnplug) {
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                }
                if (passthroughHotPlug || passthroughHotUnplug) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isNicToBePlugged) {
                if (isPassthrough()) {
                    try {
                        hostDeviceManager.acquireHostDevicesLock(getVdsId());
                        vfToUse = findFreeVf();
                        if (vfToUse == null) {
                            failValidationCannotPlugPassthroughVnicNoSuitableVf();
                            return;
                        }
                        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                        vmDevice.setHostDevice(vfToUse);
                    } finally {
                        hostDeviceManager.releaseHostDevicesLock(getVdsId());
                    }
                }
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                boolean passthroughHotPlug = vfToUse != null;
                boolean passthroughHotUnplug = isPassthrough() && getParameters().getAction() == PlugAction.UNPLUG;
                if (passthroughHotUnplug) {
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                }
                if (passthroughHotPlug || passthroughHotUnplug) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = XmlRpcStringUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = StringMapUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = StringMapUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneVmReturnForXmlRpc create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneVmReturn create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public HostDevListReturnForXmlRpc hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturnForXmlRpc(response);
}
#method_after
@Override
public HostDevListReturn hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturnForXmlRpc(response);
}
#method_after
@Override
public MigrateStatusReturn migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturn fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainStatsReturnForXmlRpc getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainStatsReturn getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainInfoReturnForXmlRpc getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainInfoReturn getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturn(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturn getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneVGReturnForXmlRpc getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturnForXmlRpc(response);
}
#method_after
@Override
public OneVGReturn getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturn(response);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturn getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturn(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturn getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturn(response);
}
#end_block

#method_before
@Override
public IQNListReturnForXmlRpc discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturnForXmlRpc(response);
}
#method_after
@Override
public IQNListReturn discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public SpmStatusReturnForXmlRpc spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturnForXmlRpc(response);
}
#method_after
@Override
public SpmStatusReturn spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturn(response);
}
#end_block

#method_before
@Override
public HostJobsReturnForXmlRpc getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturnForXmlRpc(response);
}
#method_after
@Override
public HostJobsReturn getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusReturnForXmlRpc getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusReturn getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusListReturnForXmlRpc getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusListReturn getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturn(response);
}
#end_block

#method_before
@Override
public TaskInfoListReturnForXmlRpc getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskInfoListReturn getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public AlignmentScanReturnForXmlRpc getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturnForXmlRpc(response);
}
#method_after
@Override
public AlignmentScanReturn getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturn(response);
}
#end_block

#method_before
@Override
public ImageSizeReturnForXmlRpc diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturnForXmlRpc(response);
}
#method_after
@Override
public ImageSizeReturn diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeOptionsInfoReturnForXmlRpc glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeOptionsInfoReturn glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public BooleanReturnForXmlRpc glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturnForXmlRpc(response, "volumeEmptyCheck");
}
#method_after
@Override
public BooleanReturn glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturn(response, "volumeEmptyCheck");
}
#end_block

#method_before
@Override
public GlusterHostsPubKeyReturnForXmlRpc glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHostsPubKeyReturn glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServersListReturnForXmlRpc glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterServersListReturn glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigList glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigList(response);
}
#end_block

#method_before
@Override
public GlusterVolumeStatusReturnForXmlRpc glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeStatusReturn glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesHealInfoReturnForXmlRpc glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumesHealInfoReturn glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeProfileInfoReturn glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterHooksListReturnForXmlRpc glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHooksListReturn glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public GlusterHookContentInfoReturnForXmlRpc glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHookContentInfoReturn glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfoReturnForXmlRpc(response);
}
#method_after
@Override
public StoragePoolInfo getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfo(response);
}
#end_block

#method_before
@Override
public GlusterTasksListReturnForXmlRpc glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTasksListReturn glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetail glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetail(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneMapReturnForXmlRpc get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturnForXmlRpc(response);
}
#method_after
@Override
public OneMapReturn get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturn(response);
}
#end_block

#method_before
@Override
public PrepareImageReturnForXmlRpc prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturnForXmlRpc(response);
}
#method_after
@Override
public PrepareImageReturn prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMNamesListReturnForXmlRpc getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturnForXmlRpc(response);
}
#method_after
@Override
public VMNamesListReturn getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotInfoReturnForXmlRpc glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotInfoReturn glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotConfigReturnForXmlRpc glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotConfigReturn glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturn glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StorageDeviceListReturnForXmlRpc glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDeviceListReturn glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDeviceReturn glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturnForXmlRpc(response);
}
#method_after
@Override
public OvfReturn getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturn registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VolumeInfoReturnForXmlRpc getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VolumeInfoReturn getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturn(response);
}
#end_block

#method_before
@Override
public QemuImageInfoReturnForXmlRpc getQemuImageInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getQemuImageInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new QemuImageInfoReturnForXmlRpc(response);
}
#method_after
@Override
public QemuImageInfoReturn getQemuImageInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getQemuImageInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new QemuImageInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

