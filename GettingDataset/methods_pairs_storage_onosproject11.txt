870
#method_before
private void pollGroups() {
    deviceService.getAvailableDevices().forEach(device -> {
        if (mastershipService.isLocalMaster(device.id())) {
            pollDeviceGroups(device.id());
        }
    });
}
#method_after
private void pollGroups() {
    deviceService.getAvailableDevices().forEach(device -> {
        if (mastershipService.isLocalMaster(device.id()) && device.is(GroupProgrammable.class)) {
            pollDeviceGroups(device.id());
        }
    });
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    ImmutableList.Builder<FlowEntry> resultBuilder = ImmutableList.builder();
    List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    for (PiTableModel tableModel : pipelineModel.tables()) {
        PiTableId piTableId = PiTableId.of(tableModel.name());
        // P4 program, to implement other capabilities, e.g. action execution in control flow.
        if (!interpreter.mapPiTableId(piTableId).isPresent()) {
            // next table
            continue;
        }
        Collection<PiTableEntry> installedEntries;
        try {
            // TODO: optimize by dumping entries and counters in parallel, from ALL tables with the same request.
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            if (!(e.getCause() instanceof StatusRuntimeException)) {
                // gRPC errors are logged in the client.
                log.error("Exception while dumping table {} of {}", piTableId, deviceId, e);
            }
            return Collections.emptyList();
        }
        Map<PiTableEntry, PiCounterCellData> counterCellMap;
        try {
            if (interpreter.mapTableCounter(piTableId).isPresent()) {
                PiCounterId piCounterId = interpreter.mapTableCounter(piTableId).get();
                Collection<PiCounterCellData> cellDatas;
                if (readAllDirectCounters) {
                    cellDatas = client.readAllCounterCells(Collections.singleton(piCounterId), pipeconf).get();
                } else {
                    Set<PiCounterCellId> cellIds = installedEntries.stream().map(entry -> PiDirectCounterCellId.of(piCounterId, entry)).collect(Collectors.toSet());
                    cellDatas = client.readCounterCells(cellIds, pipeconf).get();
                }
                counterCellMap = cellDatas.stream().collect(Collectors.toMap(c -> ((PiDirectCounterCellId) c.cellId()).tableEntry(), c -> c));
            } else {
                counterCellMap = Collections.emptyMap();
            }
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            if (!(e.getCause() instanceof StatusRuntimeException)) {
                // gRPC errors are logged in the client.
                log.error("Exception while reading counters of table {} of {}", piTableId, deviceId, e);
            }
            counterCellMap = Collections.emptyMap();
        }
        for (PiTableEntry installedEntry : installedEntries) {
            P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, piTableId, installedEntry.matchKey());
            if (!ENTRY_STORE.containsKey(entryRef)) {
                // Inconsistent entry
                inconsistentEntries.add(installedEntry);
                // next one.
                continue;
            }
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            long bytes = 0L;
            long packets = 0L;
            if (counterCellMap.containsKey(installedEntry)) {
                PiCounterCellData counterCellData = counterCellMap.get(installedEntry);
                bytes = counterCellData.bytes();
                packets = counterCellData.packets();
            }
            resultBuilder.add(new DefaultFlowEntry(frWrapper.rule(), ADDED, frWrapper.lifeInSeconds(), packets, bytes));
        }
    }
    if (inconsistentEntries.size() > 0) {
        log.warn("Found {} entries in {} that are not known by table entry service," + " removing them", inconsistentEntries.size(), deviceId);
        inconsistentEntries.forEach(entry -> log.debug(entry.toString()));
        // Async remove them.
        client.writeTableEntries(inconsistentEntries, DELETE, pipeconf);
    }
    return resultBuilder.build();
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    if (ignoreDeviceWhenGet) {
        return ENTRY_STORE.values().stream().filter(frWrapper -> frWrapper.rule().deviceId().equals(this.deviceId)).map(frWrapper -> new DefaultFlowEntry(frWrapper.rule(), ADDED, frWrapper.lifeInSeconds(), 0, 0)).collect(Collectors.toList());
    }
    ImmutableList.Builder<FlowEntry> resultBuilder = ImmutableList.builder();
    List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    for (PiTableModel tableModel : pipelineModel.tables()) {
        PiTableId piTableId = PiTableId.of(tableModel.name());
        // P4 program, to implement other capabilities, e.g. action execution in control flow.
        if (!interpreter.mapPiTableId(piTableId).isPresent()) {
            // next table
            continue;
        }
        Collection<PiTableEntry> installedEntries;
        try {
            // TODO: optimize by dumping entries and counters in parallel, from ALL tables with the same request.
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            if (!(e.getCause() instanceof StatusRuntimeException)) {
                // gRPC errors are logged in the client.
                log.error("Exception while dumping table {} of {}", piTableId, deviceId, e);
            }
            return Collections.emptyList();
        }
        Map<PiTableEntry, PiCounterCellData> counterCellMap;
        try {
            if (interpreter.mapTableCounter(piTableId).isPresent()) {
                PiCounterId piCounterId = interpreter.mapTableCounter(piTableId).get();
                Collection<PiCounterCellData> cellDatas;
                if (readAllDirectCounters) {
                    cellDatas = client.readAllCounterCells(Collections.singleton(piCounterId), pipeconf).get();
                } else {
                    Set<PiCounterCellId> cellIds = installedEntries.stream().map(entry -> PiDirectCounterCellId.of(piCounterId, entry)).collect(Collectors.toSet());
                    cellDatas = client.readCounterCells(cellIds, pipeconf).get();
                }
                counterCellMap = cellDatas.stream().collect(Collectors.toMap(c -> ((PiDirectCounterCellId) c.cellId()).tableEntry(), c -> c));
            } else {
                counterCellMap = Collections.emptyMap();
            }
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            if (!(e.getCause() instanceof StatusRuntimeException)) {
                // gRPC errors are logged in the client.
                log.error("Exception while reading counters of table {} of {}", piTableId, deviceId, e);
            }
            counterCellMap = Collections.emptyMap();
        }
        for (PiTableEntry installedEntry : installedEntries) {
            P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, piTableId, installedEntry.matchKey());
            if (!ENTRY_STORE.containsKey(entryRef)) {
                // Inconsistent entry
                inconsistentEntries.add(installedEntry);
                // next one.
                continue;
            }
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            long bytes = 0L;
            long packets = 0L;
            if (counterCellMap.containsKey(installedEntry)) {
                PiCounterCellData counterCellData = counterCellMap.get(installedEntry);
                bytes = counterCellData.bytes();
                packets = counterCellData.packets();
            }
            resultBuilder.add(new DefaultFlowEntry(frWrapper.rule(), ADDED, frWrapper.lifeInSeconds(), packets, bytes));
        }
    }
    if (inconsistentEntries.size() > 0) {
        log.warn("Found {} entries in {} that are not known by table entry service," + " removing them", inconsistentEntries.size(), deviceId);
        inconsistentEntries.forEach(entry -> log.debug(entry.toString()));
        // Async remove them.
        client.writeTableEntries(inconsistentEntries, DELETE, pipeconf);
    }
    return resultBuilder.build();
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing");
        log.warn("dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgType = dhcp6Payload.getMsgType();
    log.warn("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incommin ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
    }
    if (msgType == DHCP6.MsgType.SOLICIT.value() || msgType == DHCP6.MsgType.REQUEST.value() || msgType == DHCP6.MsgType.REBIND.value() || msgType == DHCP6.MsgType.RENEW.value() || msgType == DHCP6.MsgType.RELEASE.value() || msgType == DHCP6.MsgType.DECLINE.value() || msgType == DHCP6.MsgType.CONFIRM.value() || msgType == DHCP6.MsgType.RELAY_FORW.value()) {
        InternalPacket ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        if (ethernetClientPacket != null) {
            forwardPacket(ethernetClientPacket);
        }
    } else if (msgType == DHCP6.MsgType.RELAY_REPL.value()) {
        log.warn("calling processDhcp6PacketFromServer with RELAY_REPL", msgType);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgType);
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP6 payload can't be null");
    checkState(payload instanceof DHCP6, "Payload is not a DHCP6");
    DHCP6 dhcp6Payload = (DHCP6) payload;
    Ethernet receivedPacket = context.inPacket().parsed();
    if (!configured()) {
        log.warn("Missing DHCP6 relay server config. Abort packet processing");
        log.warn("dhcp6 payload {}", dhcp6Payload);
        return;
    }
    byte msgType = dhcp6Payload.getMsgType();
    log.warn("msgType is {}", msgType);
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (inPort == null) {
        log.warn("incommin ConnectPoint is null");
    }
    Set<Interface> receivingInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (receivingInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    if (MSG_TYPE_FROM_CLIENT.contains(msgType)) {
        InternalPacket ethernetClientPacket = processDhcp6PacketFromClient(context, receivedPacket, receivingInterfaces);
        if (ethernetClientPacket != null) {
            forwardPacket(ethernetClientPacket);
        }
    } else if (MSG_TYPE_FROM_SERVER.contains(msgType)) {
        log.warn("calling processDhcp6PacketFromServer with RELAY_REPL", msgType);
        InternalPacket ethernetPacketReply = processDhcp6PacketFromServer(context, receivedPacket, receivingInterfaces);
        if (ethernetPacketReply != null) {
            forwardPacket(ethernetPacketReply);
        }
    } else {
        log.warn("Not so fast, packet type {} not supported yet", msgType);
    }
}
#end_block

#method_before
private boolean directlyConnected(DHCP6 dhcp6Payload) {
    if (dhcp6Payload.getMsgType() != DHCP6.MsgType.RELAY_FORW.value() && dhcp6Payload.getMsgType() != DHCP6.MsgType.RELAY_REPL.value()) {
        log.warn("directlyConnected true. MsgType {}", dhcp6Payload.getMsgType());
        return true;
    }
    // Regardless of relay-forward or relay-replay, check if we see another relay message
    DHCP6 dhcp6Payload2 = dhcp6PacketFromRelayPacket(dhcp6Payload);
    if (dhcp6Payload2 != null) {
        if (dhcp6Payload.getMsgType() == DHCP6.MsgType.RELAY_FORW.value()) {
            log.warn("directlyConnected  false. 1st realy-foward, 2nd MsgType {}", dhcp6Payload2.getMsgType());
            return false;
        } else {
            // relay-reply
            if (dhcp6Payload2.getMsgType() != DHCP6.MsgType.RELAY_REPL.value()) {
                log.warn("directlyConnected  true. 2nd MsgType {}", dhcp6Payload2.getMsgType());
                // must be directly connected
                return true;
            } else {
                log.warn("directlyConnected  false. 1st relay-reply, 2nd relay-reply MsgType {}", dhcp6Payload2.getMsgType());
                // must be indirectly connected
                return false;
            }
        }
    } else {
        log.warn("directlyConnected  true. No dhcp6 payload found. Bad Packet!!");
        return true;
    }
}
#method_after
private boolean directlyConnected(DHCP6 dhcp6Payload) {
    log.debug("directlyConnected enters");
    if (dhcp6Payload.getMsgType() != DHCP6.MsgType.RELAY_FORW.value() && dhcp6Payload.getMsgType() != DHCP6.MsgType.RELAY_REPL.value()) {
        log.debug("directlyConnected true. MsgType {}", dhcp6Payload.getMsgType());
        return true;
    }
    // Regardless of relay-forward or relay-replay, check if we see another relay message
    DHCP6 dhcp6Payload2 = dhcp6PacketFromRelayPacket(dhcp6Payload);
    if (dhcp6Payload2 != null) {
        if (dhcp6Payload.getMsgType() == DHCP6.MsgType.RELAY_FORW.value()) {
            log.debug("directlyConnected  false. 1st realy-foward, 2nd MsgType {}", dhcp6Payload2.getMsgType());
            return false;
        } else {
            // relay-reply
            if (dhcp6Payload2.getMsgType() != DHCP6.MsgType.RELAY_REPL.value()) {
                log.debug("directlyConnected  true. 2nd MsgType {}", dhcp6Payload2.getMsgType());
                // must be directly connected
                return true;
            } else {
                log.debug("directlyConnected  false. 1st relay-reply, 2nd relay-reply MsgType {}", dhcp6Payload2.getMsgType());
                // must be indirectly connected
                return false;
            }
        }
    } else {
        log.warn("directlyConnected  true.");
        return true;
    }
}
#end_block

#method_before
private DHCP6 dhcp6PacketFromRelayPacket(DHCP6 dhcp6) {
    log.warn("dhcp6PacketFromRelayPacket  enters. dhcp6 {}", dhcp6);
    // extract the relay message if exist
    DHCP6 dhcp6Payload = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    if (dhcp6Payload == null) {
        // Can't find dhcp payload
        log.warn("Can't find dhcp6 payload from relay message");
    } else {
        log.warn("dhcp6 payload found from relay message {}", dhcp6Payload);
    }
    return dhcp6Payload;
}
#method_after
private DHCP6 dhcp6PacketFromRelayPacket(DHCP6 dhcp6) {
    log.debug("dhcp6PacketFromRelayPacket  enters. dhcp6 {}", dhcp6);
    // extract the relay message if exist
    DHCP6 dhcp6Payload = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    if (dhcp6Payload == null) {
        // Can't find dhcp payload
        log.debug("Can't find dhcp6 payload from relay message");
    } else {
        log.debug("dhcp6 payload found from relay message {}", dhcp6Payload);
    }
    return dhcp6Payload;
}
#end_block

#method_before
private boolean isDhcp6Reply(DHCP6 relayPacket) {
    DHCP6 dhcpPayload = dhcp6PacketFromRelayPacket(relayPacket);
    if (dhcpPayload != null) {
        if (dhcpPayload.getMsgType() == DHCP6.MsgType.REPLY.value()) {
            log.warn("isDhcp6Reply  true.");
            // must be directly connected
            return true;
        } else {
            // check if another relay option exists
            DHCP6 dhcpPayload2 = dhcp6PacketFromRelayPacket(dhcpPayload);
            if (dhcpPayload2 != null) {
                if (dhcpPayload2.getMsgType() == DHCP6.MsgType.REPLY.value()) {
                    log.warn("isDhcp6Reply  true. 2nd");
                    return true;
                } else {
                    log.warn("relay-reply for gateway is not ack. MsgType {}", dhcpPayload2.getMsgType());
                }
            }
        }
    }
    log.warn("isDhcp6Reply  false.");
    return false;
}
#method_after
private boolean isDhcp6Reply(DHCP6 relayPacket) {
    log.debug("isDhcp6Reply  entered.");
    DHCP6 leafDhcp6 = getDhcp6Leaf(relayPacket);
    if (leafDhcp6 != null) {
        if (leafDhcp6.getMsgType() == DHCP6.MsgType.REPLY.value()) {
            log.debug("isDhcp6Reply  true.");
            // must be directly connected
            return true;
        } else {
            log.debug("isDhcp6Reply false. leaf dhcp6 is not replay. MsgType {}", leafDhcp6.getMsgType());
        }
    } else {
        log.debug("isDhcp6Reply false. Expected dhcp6 within relay pkt but not found.");
    }
    log.debug("isDhcp6Reply  false.");
    return false;
}
#end_block

#method_before
private boolean isDhcp6Release(DHCP6 dhcp6Payload) {
    if (dhcp6Payload.getMsgType() == DHCP6.MsgType.RELEASE.value()) {
        log.warn("isDhcp6Release  true.");
        // must be directly connected
        return true;
    } else {
        DHCP6 dhcp6Leaf = dhcp6PacketFromRelayPacket(dhcp6Payload);
        if (dhcp6Leaf != null) {
            if (dhcp6Leaf.getMsgType() == DHCP6.MsgType.RELEASE.value()) {
                log.warn("isDhcp6Release  true. indirectlry connected");
                return true;
            } else {
                log.warn("relay-forward for gateway is not release. MsgType {}", dhcp6Leaf.getMsgType());
                return false;
            }
        } else {
            log.warn("isDhcp6Release  false. no relay-forward");
            return false;
        }
    }
}
#method_after
private boolean isDhcp6Release(DHCP6 dhcp6Payload) {
    log.debug("isDhcp6Release  entered.");
    if (dhcp6Payload.getMsgType() == DHCP6.MsgType.RELEASE.value()) {
        log.debug("isDhcp6Release  true.");
        // must be directly connected
        return true;
    } else {
        DHCP6 dhcp6Leaf = getDhcp6Leaf(dhcp6Payload);
        if (dhcp6Leaf != null) {
            if (dhcp6Leaf.getMsgType() == DHCP6.MsgType.RELEASE.value()) {
                log.debug("isDhcp6Release  true. indirectlry connected");
                return true;
            } else {
                log.debug("leaf dhcp6 is not release. MsgType {}", dhcp6Leaf.getMsgType());
                return false;
            }
        } else {
            log.debug("isDhcp6Release  false. dhcp6 is niether relay nor release.");
            return false;
        }
    }
}
#end_block

#method_before
private Ip6Address extractIpAddress(DHCP6 dhcp6) {
    Ip6Address ip = null;
    log.warn("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.warn("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.warn("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ip = iaAddressOption.get().getIp6Address();
        log.warn("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.warn("Can't find IPv6 address from DHCPv6 {}", dhcp6);
    }
    return ip;
}
#method_after
private Ip6Address extractIpAddress(DHCP6 dhcp6) {
    Ip6Address ip = null;
    log.debug("extractIpAddress  enters dhcp6 {}.", dhcp6);
    // Extract IPv6 address from IA NA ot IA TA option
    Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
    Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
    Optional<Dhcp6IaAddressOption> iaAddressOption;
    if (iaNaOption.isPresent()) {
        log.debug("Found IPv6 address from iaNaOption {}", iaNaOption);
        iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else if (iaTaOption.isPresent()) {
        log.debug("Found IPv6 address from iaTaOption {}", iaTaOption);
        iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
    } else {
        iaAddressOption = Optional.empty();
    }
    if (iaAddressOption.isPresent()) {
        ip = iaAddressOption.get().getIp6Address();
        log.debug("Found IPv6 address from iaAddressOption {}", iaAddressOption);
    } else {
        log.debug("Can't find IPv6 address from DHCPv6 {}", dhcp6);
    }
    return ip;
}
#end_block

#method_before
// build the DHCP6 solicit/request packet with gatewayip(unicast packet)
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Ethernet etherReply = (Ethernet) clientPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMac);
    if (this.dhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        if (directConnFlag) {
            return null;
        }
    }
    if (this.indirectDhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        if (!directConnFlag) {
            return null;
        }
    }
    etherReply.setDestinationMACAddress(directConnFlag ? this.dhcpConnectMac : this.indirectDhcpConnectMac);
    etherReply.setVlanID(directConnFlag ? this.dhcpConnectVlan.toShort() : this.indirectDhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(relayAgentIp.toOctets());
    ipv6Packet.setDestinationAddress(directConnFlag ? this.dhcpServerIp.toOctets() : this.indirectDhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // add host or route
    if (isDhcp6Release(dhcp6Packet)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it is connected to network directly
            ip = extractIpAddress(dhcp6Packet);
            if (ip != null) {
                VlanId vlanId = clientInterfaces.iterator().next().vlan();
                MacAddress clientMac = clientPacket.getSourceMAC();
                HostId hostId = HostId.hostId(clientMac, vlanId);
                log.warn("remove Host {} ip for directly connected.", hostId.toString());
                log.warn("client mac {} client vlan {}", bytesToHex(clientMac.toBytes()), vlanId);
                // Remove host's ip of  when dhcp release msg is received
                hostStore.removeIp(hostId, ip);
            } else {
                log.warn("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Remove from route store if it is not connected to network directly
            IpAddress nextHopIp = IpAddress.valueOf(IpAddress.Version.INET6, clientIpv6.getSourceAddress());
            DHCP6 leafDhcp = dhcp6PacketFromRelayPacket(dhcp6Packet);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.warn("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.warn("removing route of 128 address for indirectly connected.");
                log.warn("128 ip {} ,  nexthop {}", bytesToHex(ip.toOctets()), bytesToHex(nextHopIp.toOctets()));
                routeStore.removeRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.warn("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.warn("removing route of PD for indirectly connected.");
                log.warn("pd ip {} ,  nexthop {}", bytesToHex(ipPrefix.address().toOctets()), bytesToHex(nextHopIp.toOctets()));
                routeStore.removeRoute(routeForPrefix);
            }
        }
    }
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // link address: server uses the address to identify the link on which the client
    // is located.
    dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (dhcp6Packet.getMsgType() != DHCP6.MsgType.RELAY_FORW.value()) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString();
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length];
    log.warn("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} ", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length);
    for (int i = 0; i < clientSoureMacBytes.length; i++) {
        interfaceIdBytes[i] = clientSoureMacBytes[i];
    }
    for (int i = clientSoureMacBytes.length, j = 0; j < inPortStringBytes.length; i++, j++) {
        interfaceIdBytes[i] = inPortStringBytes[j];
    }
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.warn("interfaceId write srcMac {} portString {}", bytesToHex(clientSoureMacBytes), inPortString);
    dhcp6Relay.setOptions(options);
    // dhcp6Packet.setPayload(dhcp6Relay);
    // udpPacket.setPayload(dhcp6Packet);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point is not set up yet");
        return null;
    }
    return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromClient(PacketContext context, Ethernet clientPacket, Set<Interface> clientInterfaces) {
    Ip6Address relayAgentIp = getRelayAgentIPv6Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv6 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp6 header.
    IPv6 clientIpv6 = (IPv6) clientPacket.getPayload();
    UDP clientUdp = (UDP) clientIpv6.getPayload();
    DHCP6 clientDhcp6 = (DHCP6) clientUdp.getPayload();
    boolean directConnFlag = directlyConnected(clientDhcp6);
    Ethernet etherReply = (Ethernet) clientPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMac);
    if (directConnFlag && this.dhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.dhcpGatewayIp == null) ? "server IP " + this.dhcpServerIp : "gateway IP " + this.dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (!directConnFlag && this.indirectDhcpConnectMac == null) {
        log.warn("DHCP6 {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (this.indirectDhcpGatewayIp == null) ? "server IP " + this.indirectDhcpServerIp : "gateway IP " + this.indirectDhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (this.dhcpServerConnectPoint == null) {
        log.warn("DHCP6 server connection point is not set up yet");
        return null;
    }
    etherReply.setDestinationMACAddress(directConnFlag ? this.dhcpConnectMac : this.indirectDhcpConnectMac);
    etherReply.setVlanID(directConnFlag ? this.dhcpConnectVlan.toShort() : this.indirectDhcpConnectVlan.toShort());
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    byte[] peerAddress = clientIpv6.getSourceAddress();
    ipv6Packet.setSourceAddress(relayAgentIp.toOctets());
    ipv6Packet.setDestinationAddress(directConnFlag ? this.dhcpServerIp.toOctets() : this.indirectDhcpServerIp.toOctets());
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    DHCP6 dhcp6Packet = (DHCP6) udpPacket.getPayload();
    byte[] dhcp6PacketByte = dhcp6Packet.serialize();
    // notify onos and quagga to release PD
    // releasePD(dhcp6Packet);
    removeHostOrRoute(directConnFlag, dhcp6Packet, clientPacket, clientIpv6, clientInterfaces);
    DHCP6 dhcp6Relay = new DHCP6();
    dhcp6Relay.setMsgType(DHCP6.MsgType.RELAY_FORW.value());
    // is located.
    if (directConnFlag) {
        dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
        log.debug("direct connection: relayAgentIp obtained dynamically {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
    } else {
        if (this.indirectRelayAgentIpFromCfg == null) {
            dhcp6Relay.setLinkAddress(relayAgentIp.toOctets());
            log.warn("indirect connection: relayAgentIp NOT availale from config file! {}", HexString.toHexString(relayAgentIp.toOctets(), ":"));
        } else {
            dhcp6Relay.setLinkAddress(this.indirectRelayAgentIpFromCfg.toOctets());
            log.debug("indirect connection: relayAgentIp from config file is available! {}", HexString.toHexString(this.indirectRelayAgentIpFromCfg.toOctets(), ":"));
        }
    }
    // peer address:  address of the client or relay agent from which
    // the message to be relayed was received.
    dhcp6Relay.setPeerAddress(peerAddress);
    List<Dhcp6Option> options = new ArrayList<Dhcp6Option>();
    // otherwise, hop count + 1
    if (directConnFlag) {
        dhcp6Relay.setHopCount((byte) 0);
    } else {
        dhcp6Relay.setHopCount((byte) (dhcp6Packet.getHopCount() + 1));
    }
    // create relay message option
    Dhcp6Option relayMessage = new Dhcp6Option();
    relayMessage.setCode(DHCP6.OptionCode.RELAY_MSG.value());
    relayMessage.setLength((short) dhcp6PacketByte.length);
    relayMessage.setData(dhcp6PacketByte);
    options.add(relayMessage);
    // create interfaceId option
    String inPortString = "-" + context.inPacket().receivedFrom().toString();
    Dhcp6Option interfaceId = new Dhcp6Option();
    interfaceId.setCode(DHCP6.OptionCode.INTERFACE_ID.value());
    byte[] clientSoureMacBytes = clientPacket.getSourceMACAddress();
    byte[] inPortStringBytes = inPortString.getBytes();
    byte[] interfaceIdBytes = new byte[clientSoureMacBytes.length + inPortStringBytes.length];
    log.debug("Length: interfaceIdBytes  {} clientSoureMacBytes {} inPortStringBytes {} ", interfaceIdBytes.length, clientSoureMacBytes.length, inPortStringBytes.length);
    System.arraycopy(clientSoureMacBytes, 0, interfaceIdBytes, 0, clientSoureMacBytes.length);
    System.arraycopy(inPortStringBytes, 0, interfaceIdBytes, clientSoureMacBytes.length, inPortStringBytes.length);
    interfaceId.setData(interfaceIdBytes);
    interfaceId.setLength((short) interfaceIdBytes.length);
    options.add(interfaceId);
    log.debug("interfaceId write srcMac {} portString {}", HexString.toHexString(clientSoureMacBytes, ":"), inPortString);
    dhcp6Relay.setOptions(options);
    // dhcp6Packet.setPayload(dhcp6Relay);
    // udpPacket.setPayload(dhcp6Packet);
    udpPacket.setPayload(dhcp6Relay);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, this.dhcpServerConnectPoint);
}
#end_block

#method_before
// build the DHCP6 solicit/request packet with gatewayip(unicast packet)
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (!inPort.equals(this.dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server port {}", inPort, this.dhcpServerConnectPoint);
        return null;
    }
    // get dhcp6 header.
    Ethernet etherReply = (Ethernet) receivedPacket.clone();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    // get options
    List<Dhcp6Option> dhcp6Options = dhcp6Relay.getOptions();
    Iterator<Dhcp6Option> iterDhcp6Options = dhcp6Options.iterator();
    Dhcp6Option d6Option;
    Dhcp6Option interfaceIdOption = null;
    byte[] clientMacByte = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    byte[] clientConnPointByte = new byte[21];
    while (iterDhcp6Options.hasNext()) {
        d6Option = iterDhcp6Options.next();
        if (d6Option.getCode() == DHCP6.OptionCode.INTERFACE_ID.value()) {
            interfaceIdOption = d6Option;
            ByteBuffer bb = ByteBuffer.wrap(d6Option.getData(), 0, d6Option.getLength());
            bb.get(clientMacByte);
            // read separator
            bb.get();
            bb.get(clientConnPointByte);
        } else {
            log.warn("Not interested option optionCode {}", d6Option.getCode());
        }
    }
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    // String myInterface = new String(interfaceIdOption.getData());
    log.warn("interfaceId read");
    MacAddress peerMac = MacAddress.valueOf(clientMacByte);
    String clientConnectionPointStr = new String(clientConnPointByte);
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    Set<Interface> clientInterfaces = interfaceService.getInterfacesByPort(clientConnectionPoint);
    if (clientInterfaces.isEmpty()) {
        log.warn("Can not get client interface from packet, abort..");
        return null;
    }
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Set<Host> clients = hostService.getHostsByIp(Ip6Address.valueOf(dhcp6Relay.getPeerAddress()));
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", bytesToHex(dhcp6Relay.getPeerAddress()));
        log.warn("Let's look up interfaceId {}", bytesToHex(peerMac.toBytes()));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    if (isDhcp6Reply(dhcp6Relay)) {
        IpAddress ip = null;
        if (directConnFlag) {
            // Add to host store if it connect to network directly
            ip = extractIpAddress(embeddedDhcp6);
            if (ip != null) {
                Set<IpAddress> ips = Sets.newHashSet(ip);
                VlanId vlanId = clientInterfaces.iterator().next().vlan();
                HostId hostId = HostId.hostId(clientMac, vlanId);
                HostLocation hostLocation = new HostLocation(clientInterfaces.iterator().next().connectPoint(), System.currentTimeMillis());
                HostDescription desc = new DefaultHostDescription(clientMac, vlanId, hostLocation, ips);
                log.warn("adding Host for directly connected.");
                log.warn("client mac {} client vlan {} hostlocation {}", bytesToHex(clientMac.toBytes()), vlanId, hostLocation.toString());
                // Replace the ip when dhcp server give the host new ip address
                hostStore.createOrUpdateHost(DhcpRelayManager.PROVIDER_ID, hostId, desc, true);
            } else {
                log.warn("ipAddress not found. Do not add Host for directly connected.");
            }
        } else {
            // Add to route store if it does not connect to network directly
            IpAddress nextHopIp = IpAddress.valueOf(IpAddress.Version.INET6, dhcp6Relay.getPeerAddress());
            DHCP6 leafDhcp = dhcp6PacketFromRelayPacket(embeddedDhcp6);
            ip = extractIpAddress(leafDhcp);
            if (ip == null) {
                log.warn("ip is null");
            } else {
                Route routeForIP = new Route(Route.Source.STATIC, ip.toIpPrefix(), nextHopIp);
                log.warn("adding Route of 128 address for indirectly connected.");
                routeStore.updateRoute(routeForIP);
            }
            IpPrefix ipPrefix = extractPrefix(leafDhcp);
            if (ipPrefix == null) {
                log.warn("ipPrefix is null ");
            } else {
                Route routeForPrefix = new Route(Route.Source.STATIC, ipPrefix, nextHopIp);
                log.warn("adding Route of PD for indirectly connected.");
                routeStore.updateRoute(routeForPrefix);
            }
        }
    }
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#method_after
private InternalPacket processDhcp6PacketFromServer(PacketContext context, Ethernet receivedPacket, Set<Interface> recevingInterfaces) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    if (!inPort.equals(this.dhcpServerConnectPoint)) {
        log.warn("Receiving port {} is not the same as server port {}", inPort, this.dhcpServerConnectPoint);
        return null;
    }
    // get dhcp6 header.
    Ethernet etherReply = (Ethernet) receivedPacket.clone();
    IPv6 ipv6Packet = (IPv6) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv6Packet.getPayload();
    DHCP6 dhcp6Relay = (DHCP6) udpPacket.getPayload();
    Boolean directConnFlag = directlyConnected(dhcp6Relay);
    Dhcp6InterfaceIdOption interfaceIdOption = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6InterfaceIdOption).map(opt -> (Dhcp6InterfaceIdOption) opt).findFirst().orElse(null);
    if (interfaceIdOption == null) {
        log.warn("Interface Id option is not present, abort packet...");
        return null;
    }
    MacAddress peerMac = interfaceIdOption.getMacAddress();
    String clientConnectionPointStr = new String(interfaceIdOption.getInPort());
    ConnectPoint clientConnectionPoint = ConnectPoint.deviceConnectPoint(clientConnectionPointStr);
    Set<Interface> clientInterfaces = interfaceService.getInterfacesByPort(clientConnectionPoint);
    if (clientInterfaces.isEmpty()) {
        log.warn("Can not get client interface from packet, abort..");
        return null;
    }
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentMac == null) {
        log.warn("Can not get interface mac, abort packet..");
        return null;
    }
    etherReply.setSourceMACAddress(relayAgentMac);
    // find destMac
    MacAddress clientMac = null;
    Set<Host> clients = hostService.getHostsByIp(Ip6Address.valueOf(dhcp6Relay.getPeerAddress()));
    if (clients.isEmpty()) {
        log.warn("There's no host found for this address {}", HexString.toHexString(dhcp6Relay.getPeerAddress(), ":"));
        log.warn("Let's look up interfaceId {}", HexString.toHexString(peerMac.toBytes(), ":"));
        clientMac = peerMac;
    } else {
        clientMac = clients.iterator().next().mac();
        if (clientMac == null) {
            log.warn("No client mac address found, abort packet...");
            return null;
        }
        log.warn("Client mac address found from getHostByIp");
    }
    etherReply.setDestinationMACAddress(clientMac);
    // ip header
    ipv6Packet.setSourceAddress(dhcp6Relay.getLinkAddress());
    ipv6Packet.setDestinationAddress(dhcp6Relay.getPeerAddress());
    // udp header
    udpPacket.setSourcePort(UDP.DHCP_V6_SERVER_PORT);
    if (directConnFlag) {
        udpPacket.setDestinationPort(UDP.DHCP_V6_CLIENT_PORT);
    } else {
        udpPacket.setDestinationPort(UDP.DHCP_V6_SERVER_PORT);
    }
    DHCP6 embeddedDhcp6 = dhcp6Relay.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
    // add host or route
    addHostOrRoute(directConnFlag, dhcp6Relay, embeddedDhcp6, clientMac, clientInterfaces);
    udpPacket.setPayload(embeddedDhcp6);
    udpPacket.resetChecksum();
    ipv6Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv6Packet);
    return new InternalPacket(etherReply, clientConnectionPoint);
}
#end_block

#method_before
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    checkState(serverConfig.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(serverConfig.getDhcpServerIp6().isPresent(), "IP of DHCP6 server not exists");
    Ip6Address oldServerIp = this.dhcpServerIp;
    Ip6Address oldGatewayIp = this.dhcpGatewayIp;
    // stop monitoring gateway or server
    if (oldGatewayIp != null) {
        hostService.stopMonitoringIp(oldGatewayIp);
    } else if (oldServerIp != null) {
        hostService.stopMonitoringIp(oldServerIp);
    }
    this.dhcpServerConnectPoint = serverConfig.getDhcpServerConnectPoint().get();
    this.dhcpServerIp = serverConfig.getDhcpServerIp6().get();
    this.dhcpGatewayIp = serverConfig.getDhcpGatewayIp6().orElse(null);
    // reset server mac and vlan
    this.dhcpConnectMac = null;
    this.dhcpConnectVlan = null;
    log.info("DHCP6 server connect point: " + this.dhcpServerConnectPoint);
    log.info("DHCP6 server IP: " + this.dhcpServerIp);
    IpAddress ipToProbe = MoreObjects.firstNonNull(this.dhcpGatewayIp, this.dhcpServerIp);
    String hostToProbe = this.dhcpGatewayIp != null ? "gateway" : "DHCP6 server";
    if (ipToProbe == null) {
        log.warn("Server IP6 not set, can't probe it");
        return;
    }
    log.info("Probing to resolve {} IP6 {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        this.dhcpConnectVlan = host.vlan();
        this.dhcpConnectMac = host.mac();
    }
}
#method_after
@Override
public void setDefaultDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up first DHCP server config.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    if (!serverConfig.getDhcpServerConnectPoint().isPresent()) {
        log.warn("Connect point not exists");
        return;
    }
    if (!serverConfig.getDhcpServerIp6().isPresent()) {
        log.warn("IP of DHCP6 server not exists");
        return;
    }
    Ip6Address oldServerIp = this.dhcpServerIp;
    Ip6Address oldGatewayIp = this.dhcpGatewayIp;
    // stop monitoring gateway or server
    if (oldGatewayIp != null) {
        hostService.stopMonitoringIp(oldGatewayIp);
    } else if (oldServerIp != null) {
        hostService.stopMonitoringIp(oldServerIp);
    }
    this.dhcpServerConnectPoint = serverConfig.getDhcpServerConnectPoint().get();
    this.dhcpServerIp = serverConfig.getDhcpServerIp6().get();
    this.dhcpGatewayIp = serverConfig.getDhcpGatewayIp6().orElse(null);
    this.relayAgentIpFromCfg = serverConfig.getRelayAgentIp6().orElse(null);
    // reset server mac and vlan
    this.dhcpConnectMac = null;
    this.dhcpConnectVlan = null;
    log.info("DHCP6 server connect point: " + this.dhcpServerConnectPoint);
    log.info("DHCP6 server IP: " + this.dhcpServerIp);
    IpAddress ipToProbe = MoreObjects.firstNonNull(this.dhcpGatewayIp, this.dhcpServerIp);
    String hostToProbe = this.dhcpGatewayIp != null ? "gateway" : "DHCP6 server";
    if (ipToProbe == null) {
        log.warn("Server IP6 not set, can't probe it");
        return;
    }
    log.info("Probing to resolve {} IP6 {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        this.dhcpConnectVlan = host.vlan();
        this.dhcpConnectMac = host.mac();
    }
}
#end_block

#method_before
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up Second DHCP server config for indirect.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    checkState(serverConfig.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(serverConfig.getDhcpServerIp6().isPresent(), "IP of DHCP6 server not exists");
    Ip6Address oldServerIp = this.indirectDhcpServerIp;
    Ip6Address oldGatewayIp = this.indirectDhcpGatewayIp;
    // stop monitoring gateway or server
    if (oldGatewayIp != null) {
        hostService.stopMonitoringIp(oldGatewayIp);
    } else if (oldServerIp != null) {
        hostService.stopMonitoringIp(oldServerIp);
    }
    this.indirectDhcpServerConnectPoint = serverConfig.getDhcpServerConnectPoint().get();
    this.indirectDhcpServerIp = serverConfig.getDhcpServerIp6().get();
    this.indirectDhcpGatewayIp = serverConfig.getDhcpGatewayIp6().orElse(null);
    // reset server mac and vlan
    this.indirectDhcpConnectMac = null;
    this.indirectDhcpConnectVlan = null;
    log.info("DHCP6 server connect point: " + this.indirectDhcpServerConnectPoint);
    log.info("DHCP6 server IP: " + this.indirectDhcpServerIp);
    IpAddress ipToProbe = MoreObjects.firstNonNull(this.indirectDhcpGatewayIp, this.indirectDhcpServerIp);
    String hostToProbe = this.indirectDhcpGatewayIp != null ? "gateway" : "DHCP6 server";
    if (ipToProbe == null) {
        log.warn("Server IP6 not set, can't probe it");
        return;
    }
    log.info("Probing to resolve {} IP6 {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        this.indirectDhcpConnectVlan = host.vlan();
        this.indirectDhcpConnectMac = host.mac();
    }
}
#method_after
@Override
public void setIndirectDhcpServerConfigs(Collection<DhcpServerConfig> configs) {
    if (configs.size() == 0) {
        // no config to update
        return;
    }
    // TODO: currently we pick up Second DHCP server config for indirect.
    // Will use other server configs in the future for HA.
    DhcpServerConfig serverConfig = configs.iterator().next();
    checkState(serverConfig.getDhcpServerConnectPoint().isPresent(), "Connect point not exists");
    checkState(serverConfig.getDhcpServerIp6().isPresent(), "IP of DHCP6 server not exists");
    Ip6Address oldServerIp = this.indirectDhcpServerIp;
    Ip6Address oldGatewayIp = this.indirectDhcpGatewayIp;
    // stop monitoring gateway or server
    if (oldGatewayIp != null) {
        hostService.stopMonitoringIp(oldGatewayIp);
    } else if (oldServerIp != null) {
        hostService.stopMonitoringIp(oldServerIp);
    }
    this.indirectDhcpServerConnectPoint = serverConfig.getDhcpServerConnectPoint().get();
    this.indirectDhcpServerIp = serverConfig.getDhcpServerIp6().get();
    this.indirectDhcpGatewayIp = serverConfig.getDhcpGatewayIp6().orElse(null);
    this.indirectRelayAgentIpFromCfg = serverConfig.getRelayAgentIp6().orElse(null);
    // reset server mac and vlan
    this.indirectDhcpConnectMac = null;
    this.indirectDhcpConnectVlan = null;
    log.info("DHCP6 server connect point: " + this.indirectDhcpServerConnectPoint);
    log.info("DHCP6 server IP: " + this.indirectDhcpServerIp);
    IpAddress ipToProbe = MoreObjects.firstNonNull(this.indirectDhcpGatewayIp, this.indirectDhcpServerIp);
    String hostToProbe = this.indirectDhcpGatewayIp != null ? "gateway" : "DHCP6 server";
    if (ipToProbe == null) {
        log.warn("Server IP6 not set, can't probe it");
        return;
    }
    log.info("Probing to resolve {} IP6 {}", hostToProbe, ipToProbe);
    hostService.startMonitoringIp(ipToProbe);
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (!hosts.isEmpty()) {
        Host host = hosts.iterator().next();
        this.indirectDhcpConnectVlan = host.vlan();
        this.indirectDhcpConnectMac = host.mac();
    }
}
#end_block

#method_before
private void hostMoved(Host host) {
    if (this.dhcpServerConnectPoint == null && this.indirectDhcpServerConnectPoint == null) {
        return;
    }
    if (this.dhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.dhcpGatewayIp) && !host.locations().contains(this.dhcpServerConnectPoint)) {
            this.dhcpConnectMac = null;
            this.dhcpConnectVlan = null;
        }
    // return;
    }
    if (this.dhcpServerIp != null) {
        if (host.ipAddresses().contains(this.dhcpServerIp) && !host.locations().contains(this.dhcpServerConnectPoint)) {
            this.dhcpConnectMac = null;
            this.dhcpConnectVlan = null;
        }
    // return;
    }
    if (this.indirectDhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpGatewayIp) && !host.locations().contains(this.indirectDhcpServerConnectPoint)) {
            this.indirectDhcpConnectMac = null;
            this.indirectDhcpConnectVlan = null;
        }
    // return;
    }
    if (this.indirectDhcpServerIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpServerIp) && !host.locations().contains(this.indirectDhcpServerConnectPoint)) {
            this.indirectDhcpConnectMac = null;
            this.indirectDhcpConnectVlan = null;
        }
    }
}
#method_after
private void hostMoved(Host host) {
    if (this.dhcpServerConnectPoint == null && this.indirectDhcpServerConnectPoint == null) {
        return;
    }
    if (this.dhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.dhcpGatewayIp) && !host.locations().contains(this.dhcpServerConnectPoint)) {
            this.dhcpConnectMac = null;
            this.dhcpConnectVlan = null;
        }
    }
    if (this.dhcpServerIp != null) {
        if (host.ipAddresses().contains(this.dhcpServerIp) && !host.locations().contains(this.dhcpServerConnectPoint)) {
            this.dhcpConnectMac = null;
            this.dhcpConnectVlan = null;
        }
    }
    if (this.indirectDhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpGatewayIp) && !host.locations().contains(this.indirectDhcpServerConnectPoint)) {
            this.indirectDhcpConnectMac = null;
            this.indirectDhcpConnectVlan = null;
        }
    }
    if (this.indirectDhcpServerIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpServerIp) && !host.locations().contains(this.indirectDhcpServerConnectPoint)) {
            this.indirectDhcpConnectMac = null;
            this.indirectDhcpConnectVlan = null;
        }
    }
}
#end_block

#method_before
private void hostUpdated(Host host) {
    if (this.dhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.dhcpGatewayIp)) {
            this.dhcpConnectMac = host.mac();
            this.dhcpConnectVlan = host.vlan();
        }
    // return;
    }
    if (this.dhcpServerIp != null) {
        if (host.ipAddresses().contains(this.dhcpServerIp)) {
            this.dhcpConnectMac = host.mac();
            this.dhcpConnectVlan = host.vlan();
        }
    // return;
    }
    if (this.indirectDhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpGatewayIp)) {
            this.indirectDhcpConnectMac = host.mac();
            this.indirectDhcpConnectVlan = host.vlan();
        }
    // return;
    }
    if (this.indirectDhcpServerIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpServerIp)) {
            this.indirectDhcpConnectMac = host.mac();
            this.indirectDhcpConnectVlan = host.vlan();
        }
    }
}
#method_after
private void hostUpdated(Host host) {
    if (this.dhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.dhcpGatewayIp)) {
            this.dhcpConnectMac = host.mac();
            this.dhcpConnectVlan = host.vlan();
        }
    }
    if (this.dhcpServerIp != null) {
        if (host.ipAddresses().contains(this.dhcpServerIp)) {
            this.dhcpConnectMac = host.mac();
            this.dhcpConnectVlan = host.vlan();
        }
    }
    if (this.indirectDhcpGatewayIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpGatewayIp)) {
            this.indirectDhcpConnectMac = host.mac();
            this.indirectDhcpConnectVlan = host.vlan();
        }
    }
    if (this.indirectDhcpServerIp != null) {
        if (host.ipAddresses().contains(this.indirectDhcpServerIp)) {
            this.indirectDhcpConnectMac = host.mac();
            this.indirectDhcpConnectVlan = host.vlan();
        }
    }
}
#end_block

#method_before
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, length) -> {
        Dhcp6IaPrefixOption iaPrefixOption = new Dhcp6IaPrefixOption();
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, length);
        iaPrefixOption.setPayload(dhcp6Option.getPayload());
        if (dhcp6Option.getLength() < DEFAULT_LEN) {
            throw new DeserializationException("Invalid length of IA prefix option");
        }
        ByteBuffer bb = ByteBuffer.wrap(dhcp6Option.getData());
        iaPrefixOption.preferredLifetime = bb.getInt();
        iaPrefixOption.validLifetime = bb.getInt();
        iaPrefixOption.prefixLength = bb.get();
        byte[] ipv6Pref = new byte[16];
        bb.get(ipv6Pref);
        iaPrefixOption.ip6Prefix = Ip6Address.valueOf(ipv6Pref);
        // options length of IA Address option
        int optionsLen = dhcp6Option.getLength() - DEFAULT_LEN;
        if (optionsLen > 0) {
            byte[] optionsData = new byte[optionsLen];
            bb.get(optionsData);
            iaPrefixOption.options = Data.deserializer().deserialize(optionsData, 0, optionsLen);
        }
        return iaPrefixOption;
    };
}
#method_after
public static Deserializer<Dhcp6Option> deserializer() {
    return (data, offset, length) -> {
        Dhcp6IaPrefixOption iaPrefixOption = new Dhcp6IaPrefixOption();
        Dhcp6Option dhcp6Option = Dhcp6Option.deserializer().deserialize(data, offset, length);
        iaPrefixOption.setPayload(dhcp6Option.getPayload());
        if (dhcp6Option.getLength() < DEFAULT_LEN) {
            throw new DeserializationException("Invalid length of IA prefix option");
        }
        ByteBuffer bb = ByteBuffer.wrap(dhcp6Option.getData());
        iaPrefixOption.preferredLifetime = bb.getInt();
        iaPrefixOption.validLifetime = bb.getInt();
        iaPrefixOption.prefixLength = bb.get();
        byte[] ipv6Pref = new byte[Ip6Address.BYTE_LENGTH];
        bb.get(ipv6Pref);
        iaPrefixOption.ip6Prefix = Ip6Address.valueOf(ipv6Pref);
        // options length of IA Address option
        int optionsLen = dhcp6Option.getLength() - DEFAULT_LEN;
        if (optionsLen > 0) {
            byte[] optionsData = new byte[optionsLen];
            bb.get(optionsData);
            iaPrefixOption.options = Data.deserializer().deserialize(optionsData, 0, optionsLen);
        }
        return iaPrefixOption;
    };
}
#end_block

#method_before
@Override
public void run() {
    MeterProvider p = getProvider(this.deviceId);
    try {
        p.performMeterOperation(deviceId, new MeterOperation(meter, op));
    // Exception thrown
    } catch (Exception e) {
        log.warn("Exception while installing meter", e);
    }
}
#method_after
@Override
public void run() {
    MeterProvider p = getProvider(this.deviceId);
    if (p == null) {
        log.error("Unable to recover {}'s provider", deviceId);
        return;
    }
    p.performMeterOperation(deviceId, new MeterOperation(meter, op));
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet processor
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    // listen host event for dhcp server or the gateway
    requestDhcpPackets();
    modified(context);
    // disable dhcp from host location provider
    compCfgService.preSetProperty(HOST_LOCATION_PROVIDER, "useDhcp", Boolean.FALSE.toString());
    compCfgService.registerProperties(getClass());
    log.info("DHCP-RELAY Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet processor
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    // listen host event for dhcp server or the gateway
    requestDhcpPackets();
    modified(context);
    // disable dhcp from host location provider
    compCfgService.preSetProperty(HOST_LOCATION_PROVIDER, "useDhcp", Boolean.FALSE.toString());
    // Enable distribute route store
    compCfgService.preSetProperty(ROUTE_STORE_IMPL, "distributed", Boolean.TRUE.toString());
    compCfgService.registerProperties(getClass());
    log.info("DHCP-RELAY Started");
}
#end_block

#method_before
protected void updateConfig(Config config) {
    if (config == null) {
        // Ignore if config is not present
        return;
    }
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        addIgnoreVlanRules((IgnoreDhcpConfig) config);
    }
}
#method_after
protected void updateConfig(Config config) {
    if (config instanceof IndirectDhcpRelayConfig) {
        IndirectDhcpRelayConfig indirectConfig = (IndirectDhcpRelayConfig) config;
        v4Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
        v6Handler.setIndirectDhcpServerConfigs(indirectConfig.dhcpServerConfigs());
    } else if (config instanceof DefaultDhcpRelayConfig) {
        DefaultDhcpRelayConfig defaultConfig = (DefaultDhcpRelayConfig) config;
        v4Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
        v6Handler.setDefaultDhcpServerConfigs(defaultConfig.dhcpServerConfigs());
    }
    if (config instanceof IgnoreDhcpConfig) {
        addIgnoreVlanRules((IgnoreDhcpConfig) config);
    }
}
#end_block

#method_before
private void addIgnoreVlanRules(IgnoreDhcpConfig config) {
    config.ignoredVlans().forEach((deviceId, vlanId) -> {
        if (ignoredVlans.get(deviceId).contains(vlanId)) {
            // don't need to process if it already ignored
            return;
        }
        addIgnoreVlanRule(deviceId, vlanId);
    });
    ignoredVlans.forEach((deviceId, vlanId) -> {
        if (!config.ignoredVlans().get(deviceId).contains(vlanId)) {
            // not contains in new config, remove it
            removeIgnoreVlanRule(deviceId, vlanId);
        }
    });
}
#method_after
private void addIgnoreVlanRules(IgnoreDhcpConfig config) {
    config.ignoredVlans().forEach((deviceId, vlanId) -> {
        if (ignoredVlans.get(deviceId).contains(vlanId)) {
            // don't need to process if it already ignored
            return;
        }
        installIgnoreVlanRule(deviceId, vlanId);
        ignoredVlans.put(deviceId, vlanId);
    });
    Multimap<DeviceId, VlanId> removedVlans = HashMultimap.create();
    ignoredVlans.forEach((deviceId, vlanId) -> {
        if (!config.ignoredVlans().get(deviceId).contains(vlanId)) {
            // not contains in new config, remove it
            removeIgnoreVlanRule(deviceId, vlanId);
            removedVlans.put(deviceId, vlanId);
        }
    });
    removedVlans.forEach(ignoredVlans::remove);
}
#end_block

#method_before
private void removeIgnoreVlanRule(DeviceId deviceId, VlanId vlanId) {
    TrafficSelector serverSelector = DefaultTrafficSelector.builder(DHCP_SERVER_SELECTOR).matchVlanId(vlanId).build();
    TrafficSelector clientSelector = DefaultTrafficSelector.builder(DHCP_CLIENT_SELECTOR).matchVlanId(vlanId).build();
    ForwardingObjective fwd = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).withSelector(serverSelector).withPriority(IGNORE_CONTROL_PRIORITY).withTreatment(DefaultTrafficTreatment.emptyTreatment()).fromApp(appId).remove(new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.info("Ignore role for Vlan id {} from device {} removed (DHCP server)", vlanId, deviceId);
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.warn("Can't remove ignore role for Vlan id {} from device {} due to {} (DHCP server)", vlanId, deviceId, error);
        }
    });
    flowObjectiveService.apply(deviceId, fwd);
    fwd = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).withSelector(clientSelector).withPriority(IGNORE_CONTROL_PRIORITY).withTreatment(DefaultTrafficTreatment.emptyTreatment()).fromApp(appId).remove(new ObjectiveContext() {

        @Override
        public void onSuccess(Objective objective) {
            log.info("Ignore role for Vlan id {} from device {} removed (DHCP client)", vlanId, deviceId);
        }

        @Override
        public void onError(Objective objective, ObjectiveError error) {
            log.warn("Can't remove ignore role for Vlan id {} from device {} due to {} (DHCP client)", vlanId, deviceId, error);
        }
    });
    flowObjectiveService.apply(deviceId, fwd);
}
#method_after
private void removeIgnoreVlanRule(DeviceId deviceId, VlanId vlanId) {
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.emptyTreatment();
    dropTreatment.clearedDeferred();
    DHCP_SELECTORS.forEach(trafficSelector -> {
        UdpPortCriterion udpDst = (UdpPortCriterion) trafficSelector.getCriterion(Criterion.Type.UDP_DST);
        TrafficSelector selector = DefaultTrafficSelector.builder(trafficSelector).matchVlanId(vlanId).build();
        ForwardingObjective fwd = DefaultForwardingObjective.builder().withFlag(ForwardingObjective.Flag.VERSATILE).withSelector(selector).withPriority(IGNORE_CONTROL_PRIORITY).withTreatment(dropTreatment).fromApp(appId).remove(new ObjectiveContext() {

            @Override
            public void onSuccess(Objective objective) {
                log.info("Vlan id {} from device {} ignore rule removed (UDP port {})", vlanId, deviceId, udpDst.udpPort().toInt());
            }

            @Override
            public void onError(Objective objective, ObjectiveError error) {
                log.warn("Can't remove ignore rule of vlan id {} from device {} due to {}", vlanId, deviceId, error);
            }
        });
        flowObjectiveService.apply(deviceId, fwd);
    });
}
#end_block

#method_before
private void requestDhcpPackets() {
    packetService.requestPackets(DHCP_SERVER_SELECTOR, PacketPriority.CONTROL, appId);
    packetService.requestPackets(DHCP_CLIENT_SELECTOR, PacketPriority.CONTROL, appId);
}
#method_after
private void requestDhcpPackets() {
    DHCP_SELECTORS.forEach(trafficSelector -> {
        packetService.requestPackets(trafficSelector, PacketPriority.CONTROL, appId);
    });
}
#end_block

#method_before
private void cancelDhcpPackets() {
    TrafficSelector.Builder selectorServer = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpSrc(TpPort.tpPort(UDP.DHCP_SERVER_PORT));
    packetService.cancelPackets(DHCP_SERVER_SELECTOR, PacketPriority.CONTROL, appId);
    TrafficSelector.Builder selectorClient = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_UDP).matchUdpSrc(TpPort.tpPort(UDP.DHCP_CLIENT_PORT));
    packetService.cancelPackets(DHCP_CLIENT_SELECTOR, PacketPriority.CONTROL, appId);
}
#method_after
private void cancelDhcpPackets() {
    DHCP_SELECTORS.forEach(trafficSelector -> {
        packetService.cancelPackets(trafficSelector, PacketPriority.CONTROL, appId);
    });
}
#end_block

#method_before
private void requestArpPackets() {
    TrafficSelector.Builder selectorArpServer = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP);
    packetService.requestPackets(selectorArpServer.build(), PacketPriority.CONTROL, appId);
}
#method_after
private void requestArpPackets() {
    packetService.requestPackets(ARP_SELECTOR, PacketPriority.CONTROL, appId);
}
#end_block

#method_before
private void cancelArpPackets() {
    TrafficSelector.Builder selectorArpServer = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_ARP);
    packetService.cancelPackets(selectorArpServer.build(), PacketPriority.CONTROL, appId);
}
#method_after
private void cancelArpPackets() {
    packetService.cancelPackets(ARP_SELECTOR, PacketPriority.CONTROL, appId);
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    if (event.type() != NetworkConfigEvent.Type.CONFIG_ADDED && event.type() != NetworkConfigEvent.Type.CONFIG_UPDATED) {
        // Ignore unhandled event type
        return;
    }
    if (!event.configClass().equals(DefaultDhcpRelayConfig.class) && !event.configClass().equals(IndirectDhcpRelayConfig.class) && !event.configClass().equals(IgnoreDhcpConfig.class)) {
        // Ignore unhandled config type
        return;
    }
    event.config().ifPresent(config -> {
        updateConfig(config);
        log.info("Reconfigured");
    });
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    switch(event.type()) {
        case CONFIG_UPDATED:
        case CONFIG_ADDED:
            event.config().ifPresent(config -> {
                updateConfig(config);
                log.info("{} updated", config.getClass().getSimpleName());
            });
            break;
        case CONFIG_REMOVED:
            event.prevConfig().ifPresent(config -> {
                removeConfig(config);
                log.info("{} removed", config.getClass().getSimpleName());
            });
            break;
        default:
            log.warn("Unsupported event type {}", event.type());
            break;
    }
}
#end_block

#method_before
@Test
public void testIgnoreVlan() throws Exception {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(2);
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(2);
    replay(manager.flowObjectiveService);
    manager.updateConfig(config);
    verify(manager.flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficSelector serverSelector = DefaultTrafficSelector.builder(DHCP_SERVER_SELECTOR).matchVlanId(IGNORED_VLAN).build();
    TrafficSelector clientSelector = DefaultTrafficSelector.builder(DHCP_CLIENT_SELECTOR).matchVlanId(IGNORED_VLAN).build();
    ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(0);
    assertEquals(serverSelector, fwd.selector());
    assertEquals(DefaultTrafficTreatment.emptyTreatment(), fwd.treatment());
    assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
    assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
    fwd = (ForwardingObjective) objectivesFromDev1.get(1);
    assertEquals(clientSelector, fwd.selector());
    assertEquals(DefaultTrafficTreatment.emptyTreatment(), fwd.treatment());
    assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
    assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
}
#method_after
@Test
public void testIgnoreVlan() throws Exception {
    ObjectMapper om = new ObjectMapper();
    JsonNode json = om.readTree(Resources.getResource(CONFIG_FILE_PATH));
    IgnoreDhcpConfig config = new IgnoreDhcpConfig();
    json = json.path("apps").path(DHCP_RELAY_APP).path(IgnoreDhcpConfig.KEY);
    config.init(APP_ID, IgnoreDhcpConfig.KEY, json, om, null);
    Capture<Objective> capturedFromDev1 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_1_ID), capture(capturedFromDev1));
    expectLastCall().times(2);
    Capture<Objective> capturedFromDev2 = newCapture(CaptureType.ALL);
    manager.flowObjectiveService.apply(eq(DEV_2_ID), capture(capturedFromDev2));
    expectLastCall().times(2);
    replay(manager.flowObjectiveService);
    manager.updateConfig(config);
    verify(manager.flowObjectiveService);
    List<Objective> objectivesFromDev1 = capturedFromDev1.getValues();
    List<Objective> objectivesFromDev2 = capturedFromDev2.getValues();
    assertTrue(objectivesFromDev1.containsAll(objectivesFromDev2));
    assertTrue(objectivesFromDev2.containsAll(objectivesFromDev1));
    TrafficTreatment dropTreatment = DefaultTrafficTreatment.emptyTreatment();
    dropTreatment.clearedDeferred();
    for (int index = 0; index < objectivesFromDev1.size(); index++) {
        TrafficSelector selector = DefaultTrafficSelector.builder(DhcpRelayManager.DHCP_SELECTORS.get(index)).matchVlanId(IGNORED_VLAN).build();
        ForwardingObjective fwd = (ForwardingObjective) objectivesFromDev1.get(index);
        assertEquals(selector, fwd.selector());
        assertEquals(dropTreatment, fwd.treatment());
        assertEquals(IGNORE_CONTROL_PRIORITY, fwd.priority());
        assertEquals(ForwardingObjective.Flag.VERSATILE, fwd.flag());
        assertEquals(Objective.Operation.ADD, fwd.op());
    }
    assertEquals(2, manager.ignoredVlans.size());
}
#end_block

#method_before
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.debug("SendEvent called with src IP: {}, dst IP: {}", srcIp, dstIp);
    ObjectNode objectNode = getFlowTraceRequestAsJson(srcIp, dstIp);
    InputStream byteArrayInputStream = new ByteArrayInputStream(objectNode.toString().getBytes());
    Invocation.Builder builder = getClientBuilder(restUrl);
    if (builder == null) {
        log.error("Fail to get the client builder");
        return;
    }
    try {
        Response response = builder.header(AUTHORIZATION, restAuthInfo.toString()).post(Entity.entity(IOUtils.toString(byteArrayInputStream, StandardCharsets.UTF_8), MediaType.APPLICATION_JSON_TYPE));
        log.debug("Response from server: {}", response.toString());
        if (response.getStatus() != 200) {
            log.error("FlowTraceRequest failed because of {}", response.toString());
        }
    } catch (IOException e) {
        log.error("Exception occured because of {}", e.toString());
    }
}
#method_after
@Override
public void process(ObjectNode payload) {
    String srcIp = string(payload, SRC_IP);
    String dstIp = string(payload, DST_IP);
    log.debug("SendEvent called with src IP: {}, dst IP: {}", srcIp, dstIp);
    ObjectNode objectNode = getFlowTraceRequestAsJson(srcIp, dstIp);
    InputStream byteArrayInputStream = new ByteArrayInputStream(objectNode.toString().getBytes());
    Invocation.Builder builder = getClientBuilder(restUrl);
    if (builder == null) {
        log.error("Fail to get the client builder for the trace from {} to {}", srcIp, dstIp);
        return;
    }
    try {
        Response response = builder.header(AUTHORIZATION, restAuthInfo.toString()).post(Entity.entity(IOUtils.toString(byteArrayInputStream, StandardCharsets.UTF_8), MediaType.APPLICATION_JSON_TYPE));
        log.debug("Response from server: {}", response);
        if (response.getStatus() != 200) {
            log.error("FlowTraceRequest failed because of {}", response);
        }
    } catch (IOException e) {
        log.error("Exception occured because of {}", e.toString());
    }
}
#end_block

#method_before
private ObjectNode getFlowTraceRequestAsJson(String srcIp, String dstIp) {
    ObjectMapper mapper = new ObjectMapper();
    String controllerUrl = "http://" + clusterService.getLocalNode().ip().toString() + ":8181/onos/openstacknetworkingui/result";
    ObjectNode objectNode = mapper.createObjectNode();
    objectNode.put(COMMAND, FLOW_TRACE).put(REVERSE, false).put(TRANSACTION_ID, TRANSACTION_VALUE).put(APP_REST_URL, controllerUrl);
    if (srcIp.equals(dstIp)) {
        objectNode.putObject(MATCHING_FIELDS).put(SOURCE_IP, srcIp).put(DESTINATION_IP, dstIp).put(TO_GATEWAY, true).put(IP_PROTOCOL, 1);
    } else {
        objectNode.putObject(MATCHING_FIELDS).put(SOURCE_IP, srcIp).put(DESTINATION_IP, dstIp);
    }
    return objectNode;
}
#method_after
private ObjectNode getFlowTraceRequestAsJson(String srcIp, String dstIp) {
    ObjectMapper mapper = new ObjectMapper();
    String controllerUrl = HTTP + clusterService.getLocalNode().ip() + OPENSTACK_NETWORKING_UI_RESULT;
    ObjectNode objectNode = mapper.createObjectNode();
    objectNode.put(COMMAND, FLOW_TRACE).put(REVERSE, false).put(TRANSACTION_ID, TRANSACTION_VALUE).put(APP_REST_URL, controllerUrl);
    if (srcIp.equals(dstIp)) {
        objectNode.putObject(MATCHING_FIELDS).put(SOURCE_IP, srcIp).put(DESTINATION_IP, dstIp).put(TO_GATEWAY, true).put(IP_PROTOCOL, 1);
    } else {
        objectNode.putObject(MATCHING_FIELDS).put(SOURCE_IP, srcIp).put(DESTINATION_IP, dstIp);
    }
    return objectNode;
}
#end_block

#method_before
@Activate
protected void activate() {
    uiExtensionService.register(extension);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    uiExtensionService.register(extension);
    vDevices = Streams.stream(deviceService.getAvailableDevices()).filter(this::isVirtualDevice).collect(Collectors.toSet());
    vDevices.forEach(this::createLinksConnectedToTargetvDevice);
    log.info("Started");
}
#end_block

#method_before
protected int buildIpv6Selector(TrafficSelector.Builder builderToUpdate, ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
    if (ipv6Dst.isMulticast()) {
        if (ipv6Dst.prefixLength() != 128) {
            log.warn("Multicast specific forwarding objective can only be /128");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        }
        VlanId assignedVlan = readVlanFromSelector(fwd.meta());
        if (assignedVlan == null) {
            log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        }
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            builderToUpdate.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            builderToUpdate.matchVlanId(assignedVlan);
        }
        builderToUpdate.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
        log.debug("processing IPv6 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        if (ipv6Dst.prefixLength() != 0) {
            builderToUpdate.matchIPv6Dst(ipv6Dst);
        }
        builderToUpdate.matchEthType(Ethernet.TYPE_IPV6);
        log.debug("processing IPv6 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    }
    return 0;
}
#method_after
protected int buildIpv6Selector(TrafficSelector.Builder builderToUpdate, ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
    if (ipv6Dst.isMulticast()) {
        if (ipv6Dst.prefixLength() != IpAddress.INET6_BIT_LENGTH) {
            log.warn("Multicast specific forwarding objective can only be /128");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        }
        VlanId assignedVlan = readVlanFromSelector(fwd.meta());
        if (assignedVlan == null) {
            log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
            fail(fwd, ObjectiveError.BADPARAMS);
            return -1;
        }
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            builderToUpdate.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            builderToUpdate.matchVlanId(assignedVlan);
        }
        builderToUpdate.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
        log.debug("processing IPv6 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    } else {
        if (ipv6Dst.prefixLength() != 0) {
            builderToUpdate.matchIPv6Dst(ipv6Dst);
        }
        builderToUpdate.matchEthType(Ethernet.TYPE_IPV6);
        log.debug("processing IPv6 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
    }
    return 0;
}
#end_block

#method_before
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST) && (ethType.ethType().toShort() != Ethernet.TYPE_IPV6)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    boolean defaultRule = false;
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                // The entire IPV4_DST field is wildcarded intentionally
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
        if (ipv6Dst.isMulticast()) {
            if (ipv6Dst.prefixLength() != 128) {
                log.debug("Multicast specific IPv6 forwarding objective can only be /128");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.debug("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv6 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (buildIpv6Selector(filteredSelector, fwd) < 0) {
                return Collections.emptyList();
            }
            forTableId = UNICAST_ROUTING_TABLE;
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            if (!supportCopyTtl() && i instanceof L3ModificationInstruction) {
                L3ModificationInstruction l3instr = (L3ModificationInstruction) i;
                if (l3instr.subtype().equals(L3ModificationInstruction.L3SubType.TTL_IN) || l3instr.subtype().equals(L3ModificationInstruction.L3SubType.TTL_OUT)) {
                    continue;
                }
            }
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    return flowRuleCollection;
}
#method_after
@Override
protected Collection<FlowRule> processEthTypeSpecific(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    EthTypeCriterion ethType = (EthTypeCriterion) selector.getCriterion(Criterion.Type.ETH_TYPE);
    if ((ethType == null) || (ethType.ethType().toShort() != Ethernet.TYPE_IPV4) && (ethType.ethType().toShort() != Ethernet.MPLS_UNICAST) && (ethType.ethType().toShort() != Ethernet.TYPE_IPV6)) {
        log.warn("processSpecific: Unsupported forwarding objective criteria" + "ethType:{} in dev:{}", ethType, deviceId);
        fail(fwd, ObjectiveError.UNSUPPORTED);
        return Collections.emptySet();
    }
    boolean defaultRule = false;
    int forTableId = -1;
    TrafficSelector.Builder filteredSelector = DefaultTrafficSelector.builder();
    TrafficSelector.Builder complementarySelector = DefaultTrafficSelector.builder();
    if (ethType.ethType().toShort() == Ethernet.TYPE_IPV4) {
        IpPrefix ipv4Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV4_DST)).ip();
        if (ipv4Dst.isMulticast()) {
            if (ipv4Dst.prefixLength() != 32) {
                log.warn("Multicast specific forwarding objective can only be /32");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.warn("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv4 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (ipv4Dst.prefixLength() == 0) {
                // The entire IPV4_DST field is wildcarded intentionally
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4);
            } else {
                filteredSelector.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ipv4Dst);
            }
            forTableId = UNICAST_ROUTING_TABLE;
            log.debug("processing IPv4 unicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        }
    } else if (ethType.ethType().toShort() == Ethernet.TYPE_IPV6) {
        IpPrefix ipv6Dst = ((IPCriterion) selector.getCriterion(Criterion.Type.IPV6_DST)).ip();
        if (ipv6Dst.isMulticast()) {
            if (ipv6Dst.prefixLength() != IpAddress.INET6_BIT_LENGTH) {
                log.debug("Multicast specific IPv6 forwarding objective can only be /128");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            VlanId assignedVlan = readVlanFromSelector(fwd.meta());
            if (assignedVlan == null) {
                log.debug("VLAN ID required by multicast specific fwd obj is missing. Abort.");
                fail(fwd, ObjectiveError.BADPARAMS);
                return ImmutableSet.of();
            }
            filteredSelector.matchVlanId(assignedVlan);
            filteredSelector.matchEthType(Ethernet.TYPE_IPV6).matchIPv6Dst(ipv6Dst);
            forTableId = MULTICAST_ROUTING_TABLE;
            log.debug("processing IPv6 multicast specific forwarding objective {} -> next:{}" + " in dev:{}", fwd.id(), fwd.nextId(), deviceId);
        } else {
            if (buildIpv6Selector(filteredSelector, fwd) < 0) {
                return Collections.emptyList();
            }
            forTableId = UNICAST_ROUTING_TABLE;
        }
    } else {
        filteredSelector.matchEthType(Ethernet.MPLS_UNICAST).matchMplsLabel(((MplsCriterion) selector.getCriterion(Criterion.Type.MPLS_LABEL)).label());
        MplsBosCriterion bos = (MplsBosCriterion) selector.getCriterion(Criterion.Type.MPLS_BOS);
        if (bos != null) {
            filteredSelector.matchMplsBos(bos.mplsBos());
        }
        forTableId = MPLS_TABLE_1;
        log.debug("processing MPLS specific forwarding objective {} -> next:{}" + " in dev {}", fwd.id(), fwd.nextId(), deviceId);
    }
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction i : fwd.treatment().allInstructions()) {
            if (!supportCopyTtl() && i instanceof L3ModificationInstruction) {
                L3ModificationInstruction l3instr = (L3ModificationInstruction) i;
                if (l3instr.subtype().equals(L3ModificationInstruction.L3SubType.TTL_IN) || l3instr.subtype().equals(L3ModificationInstruction.L3SubType.TTL_OUT)) {
                    continue;
                }
            }
            /*
                 * NOTE: OF-DPA does not support immediate instruction in
                 * L3 unicast and MPLS table.
                 */
            tb.deferred().add(i);
        }
    }
    if (fwd.nextId() != null) {
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next != null) {
            List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
            // we only need the top level group's key to point the flow to it
            Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
            if (group == null) {
                log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
                fail(fwd, ObjectiveError.GROUPMISSING);
                return Collections.emptySet();
            }
            tb.deferred().group(group.id());
        }
    }
    tb.transition(ACL_TABLE);
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(filteredSelector.build()).withTreatment(tb.build()).forTable(forTableId);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    Collection<FlowRule> flowRuleCollection = new ArrayList<>();
    flowRuleCollection.add(ruleBuilder.build());
    if (defaultRule) {
        flowRuleCollection.add(defaultRoute(fwd, complementarySelector, forTableId, tb));
        log.debug("Default rule 0.0.0.0/0 is being installed two rules");
    }
    return flowRuleCollection;
}
#end_block

#method_before
private ForwardingObjective.Builder fwdObjBuilder(IpAddress mcastIp, VlanId assignedVlan, int nextId) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    IpPrefix mcastPrefix;
    if (mcastIp.isIp4()) {
        mcastPrefix = IpPrefix.valueOf(mcastIp, IpPrefix.MAX_INET_MASK_LENGTH);
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(mcastPrefix);
    } else {
        mcastPrefix = IpPrefix.valueOf(mcastIp, IpPrefix.MAX_INET6_MASK_LENGTH);
        sbuilder.matchEthType(Ethernet.TYPE_IPV6);
        sbuilder.matchIPv6Dst(mcastPrefix);
    }
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
    metabuilder.matchVlanId(assignedVlan);
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder();
    fwdBuilder.withSelector(sbuilder.build()).withMeta(metabuilder.build()).nextStep(nextId).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(srManager.appId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    return fwdBuilder;
}
#method_after
private ForwardingObjective.Builder fwdObjBuilder(IpAddress mcastIp, VlanId assignedVlan, int nextId) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    IpPrefix mcastPrefix = mcastIp.toIpPrefix();
    if (mcastIp.isIp4()) {
        sbuilder.matchEthType(Ethernet.TYPE_IPV4);
        sbuilder.matchIPDst(mcastPrefix);
    } else {
        sbuilder.matchEthType(Ethernet.TYPE_IPV6);
        sbuilder.matchIPv6Dst(mcastPrefix);
    }
    TrafficSelector.Builder metabuilder = DefaultTrafficSelector.builder();
    metabuilder.matchVlanId(assignedVlan);
    ForwardingObjective.Builder fwdBuilder = DefaultForwardingObjective.builder();
    fwdBuilder.withSelector(sbuilder.build()).withMeta(metabuilder.build()).nextStep(nextId).withFlag(ForwardingObjective.Flag.SPECIFIC).fromApp(srManager.appId).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
    return fwdBuilder;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_OCTET_STREAM)
@Path("{name}/download")
public Response download(@PathParam("name") String name) {
    ApplicationAdminService service = get(ApplicationAdminService.class);
    ApplicationId appId = service.getId(name);
    InputStream bits = service.getApplicationArchive(appId);
    return Response.ok(bits).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_OCTET_STREAM)
@Path("{name}/download")
public Response download(@PathParam("name") String name) {
    ApplicationAdminService service = get(ApplicationAdminService.class);
    ApplicationId appId = service.getId(name);
    InputStream bits = service.getApplicationArchive(appId);
    String fileName = appId.name() + ".oar";
    return Response.ok(bits).header("Content-Disposition", "attachment; filename=\"" + fileName + "\"").build();
}
#end_block

#method_before
public synchronized ApplicationDescription saveApplication(InputStream stream) {
    try (InputStream ais = stream) {
        byte[] cache = toByteArray(ais);
        InputStream bis = new ByteArrayInputStream(cache);
        boolean plainXml = isPlainXml(cache);
        ApplicationDescription desc = plainXml ? parsePlainAppDescription(bis) : parseZippedAppDescription(bis);
        checkState(!appFile(desc.name(), APP_XML).exists(), "Application %s already installed", desc.name());
        boolean isSelfContainedJar = false;
        if (plainXml) {
            expandPlainApplication(cache, desc);
        } else {
            bis.reset();
            isSelfContainedJar = expandZippedApplication(bis, desc);
            if (isSelfContainedJar) {
                bis.reset();
                stageSelfContainedJar(bis, desc);
            }
            bis.reset();
            saveApplication(bis, desc, isSelfContainedJar);
        }
        installArtifacts(desc);
        return desc;
    } catch (IOException e) {
        throw new ApplicationException("Unable to save application", e);
    }
}
#method_after
public synchronized ApplicationDescription saveApplication(InputStream stream) {
    try (InputStream ais = stream) {
        byte[] cache = toByteArray(ais);
        InputStream bis = new ByteArrayInputStream(cache);
        boolean plainXml = isPlainXml(cache);
        ApplicationDescription desc = plainXml ? parsePlainAppDescription(bis) : parseZippedAppDescription(bis);
        checkState(!appFile(desc.name(), APP_XML).exists(), "Application %s already installed", desc.name());
        if (plainXml) {
            expandPlainApplication(cache, desc);
        } else {
            bis.reset();
            boolean isSelfContainedJar = expandZippedApplication(bis, desc);
            if (isSelfContainedJar) {
                bis.reset();
                stageSelfContainedJar(bis, desc);
            }
            bis.reset();
            saveApplication(bis, desc, isSelfContainedJar);
        }
        installArtifacts(desc);
        return desc;
    } catch (IOException e) {
        throw new ApplicationException("Unable to save application", e);
    }
}
#end_block

#method_before
@Override
public void filter(FilteringObjective filter) {
    Instructions.OutputInstruction output;
    if (filter.meta() != null && !filter.meta().immediate().isEmpty()) {
        output = (Instructions.OutputInstruction) filter.meta().immediate().stream().filter(t -> t.type().equals(Instruction.Type.OUTPUT)).limit(1).findFirst().get();
        if (output == null || !output.port().equals(PortNumber.CONTROLLER)) {
            log.error("OLT can only filter packet to controller");
            fail(filter, ObjectiveError.UNSUPPORTED);
            return;
        }
    } else {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    if (filter.key().type() != Criterion.Type.IN_PORT) {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    EthTypeCriterion ethType = (EthTypeCriterion) filterForCriterion(filter.conditions(), Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    if (ethType.ethType().equals(EthType.EtherType.EAPOL.ethType())) {
        provisionEapol(filter, ethType, output);
    } else if (ethType.ethType().equals(EthType.EtherType.IPV4.ethType())) {
        IPProtocolCriterion ipProto = (IPProtocolCriterion) filterForCriterion(filter.conditions(), Criterion.Type.IP_PROTO);
        if (ipProto == null) {
            log.error("OLT can only filter IGMP and DHCP");
            fail(filter, ObjectiveError.UNSUPPORTED);
            return;
        }
        if (ipProto.protocol() == IPv4.PROTOCOL_IGMP) {
            provisionIgmp(filter, ethType, ipProto, output);
        } else if (ipProto.protocol() == IPv4.PROTOCOL_UDP) {
            UdpPortCriterion udpSrcPort = (UdpPortCriterion) filterForCriterion(filter.conditions(), Criterion.Type.UDP_SRC);
            UdpPortCriterion udpDstPort = (UdpPortCriterion) filterForCriterion(filter.conditions(), Criterion.Type.UDP_DST);
            if (udpSrcPort.udpPort().toInt() != 68 || udpDstPort.udpPort().toInt() != 67) {
                log.error("OLT can only filter DHCP, wrong UDP Src or Dst Port");
                fail(filter, ObjectiveError.UNSUPPORTED);
            }
            provisionDhcp(filter, ethType, ipProto, udpSrcPort, udpDstPort, output);
        } else {
            log.error("OLT can only filter IGMP and DHCP");
            fail(filter, ObjectiveError.UNSUPPORTED);
        }
    } else {
        log.error("\nOnly the following are Supported in OLT for filter ->\n" + "ETH TYPE : EAPOL and IPV4\n" + "IPV4 TYPE: IGMP and UDP (for DHCP)");
        fail(filter, ObjectiveError.UNSUPPORTED);
    }
}
#method_after
@Override
public void filter(FilteringObjective filter) {
    Instructions.OutputInstruction output;
    if (filter.meta() != null && !filter.meta().immediate().isEmpty()) {
        output = (Instructions.OutputInstruction) filter.meta().immediate().stream().filter(t -> t.type().equals(Instruction.Type.OUTPUT)).limit(1).findFirst().get();
        if (output == null || !output.port().equals(PortNumber.CONTROLLER)) {
            log.warn("OLT can only filter packet to controller");
            fail(filter, ObjectiveError.UNSUPPORTED);
            return;
        }
    } else {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    if (filter.key().type() != Criterion.Type.IN_PORT) {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    EthTypeCriterion ethType = (EthTypeCriterion) filterForCriterion(filter.conditions(), Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        fail(filter, ObjectiveError.BADPARAMS);
        return;
    }
    if (ethType.ethType().equals(EthType.EtherType.EAPOL.ethType())) {
        provisionEapol(filter, ethType, output);
    } else if (ethType.ethType().equals(EthType.EtherType.IPV4.ethType())) {
        IPProtocolCriterion ipProto = (IPProtocolCriterion) filterForCriterion(filter.conditions(), Criterion.Type.IP_PROTO);
        if (ipProto == null) {
            log.warn("OLT can only filter IGMP and DHCP");
            fail(filter, ObjectiveError.UNSUPPORTED);
            return;
        }
        if (ipProto.protocol() == IPv4.PROTOCOL_IGMP) {
            provisionIgmp(filter, ethType, ipProto, output);
        } else if (ipProto.protocol() == IPv4.PROTOCOL_UDP) {
            UdpPortCriterion udpSrcPort = (UdpPortCriterion) filterForCriterion(filter.conditions(), Criterion.Type.UDP_SRC);
            UdpPortCriterion udpDstPort = (UdpPortCriterion) filterForCriterion(filter.conditions(), Criterion.Type.UDP_DST);
            if (udpSrcPort.udpPort().toInt() != 68 || udpDstPort.udpPort().toInt() != 67) {
                log.warn("OLT can only filter DHCP, wrong UDP Src or Dst Port");
                fail(filter, ObjectiveError.UNSUPPORTED);
            }
            provisionDhcp(filter, ethType, ipProto, udpSrcPort, udpDstPort, output);
        } else {
            log.warn("OLT can only filter IGMP and DHCP");
            fail(filter, ObjectiveError.UNSUPPORTED);
        }
    } else {
        log.warn("\nOnly the following are Supported in OLT for filter ->\n" + "ETH TYPE : EAPOL and IPV4\n" + "IPV4 TYPE: IGMP and UDP (for DHCP)");
        fail(filter, ObjectiveError.UNSUPPORTED);
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    netconfDeviceMap.values().forEach(device -> {
        device.getSession().removeDeviceOutputListener(downListener);
        device.disconnect();
    });
    cfgService.unregisterProperties(getClass(), false);
    netconfDeviceListeners.clear();
    netconfDeviceMap.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    netconfDeviceMap.values().forEach(device -> {
        device.getSession().removeDeviceOutputListener(downListener);
        device.disconnect();
    });
    cfgService.unregisterProperties(getClass(), false);
    netconfDeviceListeners.clear();
    netconfDeviceMap.clear();
    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);
    log.info("Stopped");
}
#end_block

#method_before
private void startSession() throws IOException {
    final ConnectFuture connectFuture;
    connectFuture = client.connect(deviceInfo.name(), deviceInfo.ip().toString(), deviceInfo.port()).verify(connectTimeout, TimeUnit.SECONDS);
    session = connectFuture.getSession();
    // Using the device ssh key if possible
    if (deviceInfo.getKey() != null) {
        PEMParser pemParser = new PEMParser(new CharArrayReader(deviceInfo.getKey()));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        try {
            KeyPair kp = converter.getKeyPair((PEMKeyPair) pemParser.readObject());
            session.addPublicKeyIdentity(kp);
        } catch (java.io.IOException e) {
            throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check key to be a valid key", e);
        }
    } else {
        session.addPasswordIdentity(deviceInfo.password());
    }
    session.auth().verify(connectTimeout, TimeUnit.SECONDS);
    Set<ClientSession.ClientSessionEvent> event = session.waitFor(ImmutableSet.of(ClientSession.ClientSessionEvent.WAIT_AUTH, ClientSession.ClientSessionEvent.CLOSED, ClientSession.ClientSessionEvent.AUTHED), 0);
    if (!event.contains(ClientSession.ClientSessionEvent.AUTHED)) {
        log.debug("Session closed {} {}", event, session.isClosed());
        throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check the user/pwd or key");
    }
    openChannel();
}
#method_after
private void startSession() throws IOException {
    final ConnectFuture connectFuture;
    connectFuture = client.connect(deviceInfo.name(), deviceInfo.ip().toString(), deviceInfo.port()).verify(connectTimeout, TimeUnit.SECONDS);
    session = connectFuture.getSession();
    // Using the device ssh key if possible
    if (deviceInfo.getKey() != null) {
        PEMParser pemParser = new PEMParser(new CharArrayReader(deviceInfo.getKey()));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME);
        try {
            KeyPair kp = converter.getKeyPair((PEMKeyPair) pemParser.readObject());
            session.addPublicKeyIdentity(kp);
        } catch (java.io.IOException e) {
            throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check key to be a valid key", e);
        }
    } else {
        session.addPasswordIdentity(deviceInfo.password());
    }
    session.auth().verify(connectTimeout, TimeUnit.SECONDS);
    Set<ClientSession.ClientSessionEvent> event = session.waitFor(ImmutableSet.of(ClientSession.ClientSessionEvent.WAIT_AUTH, ClientSession.ClientSessionEvent.CLOSED, ClientSession.ClientSessionEvent.AUTHED), 0);
    if (!event.contains(ClientSession.ClientSessionEvent.AUTHED)) {
        log.debug("Session closed {} {}", event, session.isClosed());
        throw new NetconfException("Failed to authenticate session with device " + deviceInfo + "check the user/pwd or key");
    }
    openChannel();
}
#end_block

#method_before
YangSchemaNode fetchModuleNode(String pkg) {
    YangSchemaNode modNode;
    StringBuilder modPkg = new StringBuilder();
    // In other case we need to find the package
    // of module fetchNode from the given fetchNode's package.
    String[] strArray = pkg.split(Pattern.quote(PERIOD));
    int i = 0;
    while (i <= strArray.length - 3) {
        modPkg.append(strArray[i]).append(PERIOD);
        i++;
    }
    // If path contains input fetchNode class then in that case if we add
    // current modePkg will be the correct package for module fetchNode
    // because the next string will be rpc name in received from fetch
    // package method.
    modPkg.deleteCharAt(modPkg.lastIndexOf(PERIOD));
    YangNode node = (YangNode) reg.getForRegClassQualifiedName(modPkg.toString(), true);
    if (node != null) {
        modNode = node;
        // in this case we should update the lastIndexNode for object to
        // data fetchNode conversion. because we need to create the data fetchNode
        // with the input fetchNode's data
        node = node.getChild();
        while (node != null) {
            YangSchemaNodeType type = node.getYangSchemaNodeType();
            if (type != YANG_NON_DATA_NODE && type != YANG_AUGMENT_NODE && node.getJavaAttributeName().toLowerCase().equals(strArray[i])) {
                // last index fetchNode will be input fetchNode.
                lastIndexNode = node.getChild();
                break;
            }
            node = node.getNextSibling();
        }
        if (lastIndexNode != null && (lastIndexNode instanceof YangInput || lastIndexNode instanceof YangOutput)) {
            isInputOrOutput = true;
        }
    } else {
        modPkg.append(PERIOD);
        // In this case this package will be of module fetchNode.
        modPkg.append(strArray[i]);
        modNode = reg.getForRegClassQualifiedName(modPkg.toString(), false);
    }
    return modNode;
}
#method_after
YangSchemaNode fetchModuleNode(String pkg) {
    YangSchemaNode modNode;
    StringBuilder modPkg = new StringBuilder();
    // In other case we need to find the package
    // of module fetchNode from the given fetchNode's package.
    String[] strArray = pkg.split(Pattern.quote(PERIOD));
    int i = 0;
    while (i <= strArray.length - 3) {
        modPkg.append(strArray[i]).append(PERIOD);
        i++;
    }
    // If path contains input fetchNode class then in that case if we add
    // current modePkg will be the correct package for module fetchNode
    // because the next string will be rpc name in received from fetch
    // package method.
    modPkg.deleteCharAt(modPkg.lastIndexOf(PERIOD));
    YangNode node = (YangNode) reg.getForRegClassQualifiedName(modPkg.toString(), true);
    if (node != null) {
        modNode = node;
        // in this case we should update the lastIndexNode for object to
        // data fetchNode conversion. because we need to create the data fetchNode
        // with the input fetchNode's data
        node = node.getChild();
        while (node != null) {
            YangSchemaNodeType type = node.getYangSchemaNodeType();
            if (type != YANG_NON_DATA_NODE && type != YANG_AUGMENT_NODE && node.getJavaAttributeName().toLowerCase().equals(strArray[i])) {
                // last index fetchNode will be input fetchNode.
                lastIndexNode = node.getChild();
                break;
            }
            node = node.getNextSibling();
        }
        if (lastIndexNode instanceof YangInput || lastIndexNode instanceof YangOutput) {
            isInputOrOutput = true;
        }
    } else {
        modPkg.append(PERIOD);
        // In this case this package will be of module fetchNode.
        modPkg.append(strArray[i]);
        modNode = reg.getForRegClassQualifiedName(modPkg.toString(), false);
    }
    return modNode;
}
#end_block

#method_before
@Override
public String toString() {
    return "device: " + deviceId + ", " + "port: " + this.portNumber.toLong() + ", " + "pktRx: " + this.packetsReceived + ", " + "pktTx: " + this.packetsSent + ", " + "byteRx: " + this.bytesReceived + ", " + "byteTx: " + this.bytesSent + ", " + "pktRxErr: " + this.packetsRxErrors + ", " + "pktTxErr: " + this.packetsTxErrors + ", " + "pktRxDrp: " + this.packetsRxDropped + ", " + "pktTxDrp: " + this.packetsTxDropped;
}
#method_after
@Override
public String toString() {
    return "device: " + deviceId + ", " + "port: " + this.portNumber + ", " + "pktRx: " + this.packetsReceived + ", " + "pktTx: " + this.packetsSent + ", " + "byteRx: " + this.bytesReceived + ", " + "byteTx: " + this.bytesSent + ", " + "pktRxErr: " + this.packetsRxErrors + ", " + "pktTxErr: " + this.packetsTxErrors + ", " + "pktRxDrp: " + this.packetsRxDropped + ", " + "pktTxDrp: " + this.packetsTxDropped;
}
#end_block

#method_before
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // From p4runtime.proto:
    // For ReadRequest, the scope is defined as follows:
    // - All counter cells for all meters if counter_id = 0 (default).
    // - All counter cells for given counter_id if index = 0 (default).
    final ReadRequest.Builder requestBuilder = ReadRequest.newBuilder().setDeviceId(p4DeviceId);
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    for (PiCounterCellId cellId : cellIds) {
        int counterId;
        try {
            counterId = browser.counters().getByNameOrAlias(cellId.counterId().id()).getPreamble().getId();
        } catch (P4InfoBrowser.NotFoundException e) {
            log.warn(e.getMessage());
            continue;
        }
        requestBuilder.addEntities(Entity.newBuilder().setCounterEntry(CounterEntry.newBuilder().setCounterId(counterId).setIndex(cellId.index()).build()));
        counterIdMap.put(counterId, cellId.counterId());
    }
    final Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestBuilder.build());
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read counters: {}", e.getMessage());
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responseIterable = () -> responses;
    final ImmutableList.Builder<PiCounterCellData> piCounterEntryListBuilder = ImmutableList.builder();
    StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == COUNTER_ENTRY).map(Entity::getCounterEntry).forEach(counterEntryMsg -> {
        if (!counterIdMap.containsKey(counterEntryMsg.getCounterId())) {
            log.warn("Unrecognized counter ID '{}', skipping", counterEntryMsg.getCounterId());
            return;
        }
        PiCounterCellId cellId = PiCounterCellId.of(counterIdMap.get(counterEntryMsg.getCounterId()), counterEntryMsg.getIndex());
        piCounterEntryListBuilder.add(new PiCounterCellData(cellId, counterEntryMsg.getData().getPacketCount(), counterEntryMsg.getData().getByteCount()));
    });
    return piCounterEntryListBuilder.build();
}
#method_after
private Collection<PiCounterCellData> doReadCounterCells(Collection<PiCounterCellId> cellIds, PiPipeconf pipeconf) {
    // From p4runtime.proto:
    // For ReadRequest, the scope is defined as follows:
    // - All counter cells for all meters if counter_id = 0 (default).
    // - All counter cells for given counter_id if index = 0 (default).
    final ReadRequest.Builder requestBuilder = ReadRequest.newBuilder().setDeviceId(p4DeviceId);
    final P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    final Map<Integer, PiCounterId> counterIdMap = Maps.newHashMap();
    for (PiCounterCellId cellId : cellIds) {
        int counterId;
        try {
            counterId = browser.counters().getByNameOrAlias(cellId.counterId().id()).getPreamble().getId();
        } catch (P4InfoBrowser.NotFoundException e) {
            log.warn("Skipping counter cell {}: {}", cellId, e.getMessage());
            continue;
        }
        requestBuilder.addEntities(Entity.newBuilder().setCounterEntry(CounterEntry.newBuilder().setCounterId(counterId).setIndex(cellId.index()).build()));
        counterIdMap.put(counterId, cellId.counterId());
    }
    final Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestBuilder.build());
    } catch (StatusRuntimeException e) {
        log.warn("Unable to read counters: {}", e.getMessage());
        return Collections.emptyList();
    }
    final Iterable<ReadResponse> responseIterable = () -> responses;
    final ImmutableList.Builder<PiCounterCellData> piCounterEntryListBuilder = ImmutableList.builder();
    StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == COUNTER_ENTRY).map(Entity::getCounterEntry).forEach(counterEntryMsg -> {
        if (!counterIdMap.containsKey(counterEntryMsg.getCounterId())) {
            log.warn("Unrecognized counter ID '{}', skipping", counterEntryMsg.getCounterId());
            return;
        }
        PiCounterCellId cellId = PiCounterCellId.of(counterIdMap.get(counterEntryMsg.getCounterId()), counterEntryMsg.getIndex());
        piCounterEntryListBuilder.add(new PiCounterCellData(cellId, counterEntryMsg.getData().getPacketCount(), counterEntryMsg.getData().getByteCount()));
    });
    return piCounterEntryListBuilder.build();
}
#end_block

#method_before
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    if (!super.initBehaviour()) {
        return Collections.emptyList();
    }
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort((int) p.number().toLong()).setDeviceId(deviceId)));
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.of(INGRESS_COUNTER_ID, p));
        counterCellIds.add(PiCounterCellId.of(EGRESS_COUNTER_ID, p));
    });
    Collection<PiCounterCellData> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    counterEntryResponse.forEach(counterEntry -> {
        if (!portStatBuilders.containsKey(counterEntry.cellId().index())) {
            log.warn("Unrecognized counter index {}, skipping", counterEntry);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(counterEntry.cellId().index());
        if (counterEntry.cellId().counterId().equals(INGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsReceived(counterEntry.packets());
            statsBuilder.setBytesReceived(counterEntry.bytes());
        } else if (counterEntry.cellId().counterId().equals(EGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsSent(counterEntry.packets());
            statsBuilder.setBytesSent(counterEntry.bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterEntry);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#method_after
@Override
public Collection<PortStatistics> discoverPortStatistics() {
    if (!super.setupBehaviour()) {
        return Collections.emptyList();
    }
    Map<Long, DefaultPortStatistics.Builder> portStatBuilders = Maps.newHashMap();
    deviceService.getPorts(deviceId).forEach(p -> portStatBuilders.put(p.number().toLong(), DefaultPortStatistics.builder().setPort((int) p.number().toLong()).setDeviceId(deviceId)));
    Set<PiCounterCellId> counterCellIds = Sets.newHashSet();
    portStatBuilders.keySet().forEach(p -> {
        // Counter cell/index = port number.
        counterCellIds.add(PiCounterCellId.of(INGRESS_COUNTER_ID, p));
        counterCellIds.add(PiCounterCellId.of(EGRESS_COUNTER_ID, p));
    });
    Collection<PiCounterCellData> counterEntryResponse;
    try {
        counterEntryResponse = client.readCounterCells(counterCellIds, pipeconf).get();
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Exception while reading port counters from {}: {}", deviceId, e.toString());
        log.debug("", e);
        return Collections.emptyList();
    }
    counterEntryResponse.forEach(counterEntry -> {
        if (!portStatBuilders.containsKey(counterEntry.cellId().index())) {
            log.warn("Unrecognized counter index {}, skipping", counterEntry);
            return;
        }
        DefaultPortStatistics.Builder statsBuilder = portStatBuilders.get(counterEntry.cellId().index());
        if (counterEntry.cellId().counterId().equals(INGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsReceived(counterEntry.packets());
            statsBuilder.setBytesReceived(counterEntry.bytes());
        } else if (counterEntry.cellId().counterId().equals(EGRESS_COUNTER_ID)) {
            statsBuilder.setPacketsSent(counterEntry.packets());
            statsBuilder.setBytesSent(counterEntry.bytes());
        } else {
            log.warn("Unrecognized counter ID {}, skipping", counterEntry);
        }
    });
    return portStatBuilders.values().stream().map(DefaultPortStatistics.Builder::build).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void emit(OutboundPacket packet) {
    if (!this.initBehaviour()) {
        return;
    }
    final PiPipelineInterpreter interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    if (!device.is(PiPipelineInterpreter.class)) {
        log.warn("Device {} with pipeconf {} has no interpreter, aborting emit operation", deviceId, pipeconf.id());
        return;
    }
    try {
        Collection<PiPacketOperation> operations = interpreter.mapOutboundPacket(packet);
        operations.forEach(piPacketOperation -> {
            log.debug("Doing PiPacketOperation {}", piPacketOperation);
            client.packetOut(piPacketOperation, pipeconf);
        });
    } catch (PiPipelineInterpreter.PiInterpreterException e) {
        log.error("Interpreter of pipeconf {} was unable to translate outbound packet: {}", pipeconf.id(), e.getMessage());
    }
}
#method_after
@Override
public void emit(OutboundPacket packet) {
    if (!this.setupBehaviour()) {
        return;
    }
    final PiPipelineInterpreter interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    if (!device.is(PiPipelineInterpreter.class)) {
        log.warn("Device {} with pipeconf {} has no interpreter, aborting emit operation", deviceId, pipeconf.id());
        return;
    }
    try {
        Collection<PiPacketOperation> operations = interpreter.mapOutboundPacket(packet);
        operations.forEach(piPacketOperation -> {
            log.debug("Doing PiPacketOperation {}", piPacketOperation);
            client.packetOut(piPacketOperation, pipeconf);
        });
    } catch (PiPipelineInterpreter.PiInterpreterException e) {
        log.error("Interpreter of pipeconf {} was unable to translate outbound packet: {}", pipeconf.id(), e.getMessage());
    }
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!initBehaviour()) {
        return Collections.emptyList();
    }
    ImmutableList.Builder<FlowEntry> resultBuilder = ImmutableList.builder();
    List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    for (PiTableModel tableModel : pipelineModel.tables()) {
        PiTableId piTableId = PiTableId.of(tableModel.name());
        // P4 program, to implement other capabilities, e.g. action execution in control flow.
        if (!interpreter.mapPiTableId(piTableId).isPresent()) {
            // next table
            continue;
        }
        Collection<PiTableEntry> installedEntries;
        try {
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while dumping table {} of {}", piTableId, deviceId, e);
            return Collections.emptyList();
        }
        for (PiTableEntry installedEntry : installedEntries) {
            P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, piTableId, installedEntry.matchKey());
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            if (frWrapper == null) {
                // Inconsistent entry
                inconsistentEntries.add(installedEntry);
                // next one.
                continue;
            }
            // TODO: implement table entry counter retrieval.
            long bytes = 0L;
            long packets = 0L;
            FlowEntry entry = new DefaultFlowEntry(frWrapper.rule(), ADDED, frWrapper.lifeInSeconds(), packets, bytes);
            resultBuilder.add(entry);
        }
    }
    if (inconsistentEntries.size() > 0) {
        log.warn("Found {} entries in {} that are not known by table entry service," + " removing them", inconsistentEntries.size(), deviceId);
        inconsistentEntries.forEach(entry -> log.debug(entry.toString()));
        // Async remove them.
        client.writeTableEntries(inconsistentEntries, DELETE, pipeconf);
    }
    return resultBuilder.build();
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    ImmutableList.Builder<FlowEntry> resultBuilder = ImmutableList.builder();
    List<PiTableEntry> inconsistentEntries = Lists.newArrayList();
    for (PiTableModel tableModel : pipelineModel.tables()) {
        PiTableId piTableId = PiTableId.of(tableModel.name());
        // P4 program, to implement other capabilities, e.g. action execution in control flow.
        if (!interpreter.mapPiTableId(piTableId).isPresent()) {
            // next table
            continue;
        }
        Collection<PiTableEntry> installedEntries;
        try {
            installedEntries = client.dumpTable(piTableId, pipeconf).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception while dumping table {} of {}", piTableId, deviceId, e);
            return Collections.emptyList();
        }
        for (PiTableEntry installedEntry : installedEntries) {
            P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, piTableId, installedEntry.matchKey());
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            if (frWrapper == null) {
                // Inconsistent entry
                inconsistentEntries.add(installedEntry);
                // next one.
                continue;
            }
            // TODO: implement table entry counter retrieval.
            long bytes = 0L;
            long packets = 0L;
            FlowEntry entry = new DefaultFlowEntry(frWrapper.rule(), ADDED, frWrapper.lifeInSeconds(), packets, bytes);
            resultBuilder.add(entry);
        }
    }
    if (inconsistentEntries.size() > 0) {
        log.warn("Found {} entries in {} that are not known by table entry service," + " removing them", inconsistentEntries.size(), deviceId);
        inconsistentEntries.forEach(entry -> log.debug(entry.toString()));
        // Async remove them.
        client.writeTableEntries(inconsistentEntries, DELETE, pipeconf);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private Collection<FlowRule> processFlowRules(Collection<FlowRule> rules, Operation operation) {
    if (!initBehaviour()) {
        return Collections.emptyList();
    }
    ImmutableList.Builder<FlowRule> processedFlowRuleListBuilder = ImmutableList.builder();
    for (FlowRule rule : rules) {
        PiTableEntry piTableEntry;
        try {
            piTableEntry = piFlowRuleTranslationService.translate(rule, pipeconf);
        } catch (PiFlowRuleTranslationService.PiFlowRuleTranslationException e) {
            log.warn("Unable to translate flow rule: {} - {}", e.getMessage(), rule);
            // next rule
            continue;
        }
        PiTableId tableId = piTableEntry.table();
        P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, tableId, piTableEntry.matchKey());
        Lock lock = ENTRY_LOCKS.computeIfAbsent(entryRef, k -> new ReentrantLock());
        lock.lock();
        try {
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            WriteOperationType opType = null;
            boolean doApply = true;
            if (operation == APPLY) {
                if (frWrapper == null) {
                    // Entry is first-timer.
                    opType = INSERT;
                } else {
                    // This match key already exists in the device.
                    if (checkEntryStoreBeforeUpdate && piTableEntry.action().equals(frWrapper.piTableEntry().action())) {
                        doApply = false;
                        log.debug("Ignoring re-apply of existing entry: {}", piTableEntry);
                    }
                    if (doApply) {
                        if (deleteEntryBeforeUpdate) {
                            // Remove before re-adding the modified one.
                            try {
                                if (client.writeTableEntries(newArrayList(piTableEntry), DELETE, pipeconf).get()) {
                                    frWrapper = null;
                                } else {
                                    log.warn("Unable to DELETE table entry (before re-adding) in {}: {}", deviceId, piTableEntry);
                                }
                            } catch (InterruptedException | ExecutionException e) {
                                log.warn("Exception while deleting table entry:", operation.name(), e);
                            }
                            opType = INSERT;
                        } else {
                            opType = MODIFY;
                        }
                    }
                }
            } else {
                opType = DELETE;
            }
            if (doApply) {
                try {
                    if (client.writeTableEntries(newArrayList(piTableEntry), opType, pipeconf).get()) {
                        processedFlowRuleListBuilder.add(rule);
                        if (operation == APPLY) {
                            frWrapper = new P4RuntimeFlowRuleWrapper(rule, piTableEntry, System.currentTimeMillis());
                        } else {
                            frWrapper = null;
                        }
                    } else {
                        log.warn("Unable to {} table entry in {}: {}", opType.name(), deviceId, piTableEntry);
                    }
                } catch (InterruptedException | ExecutionException e) {
                    log.warn("Exception while performing {} table entry operation:", operation.name(), e);
                }
            } else {
                processedFlowRuleListBuilder.add(rule);
            }
            // Update entryRef binding in table entry service.
            if (frWrapper != null) {
                ENTRY_STORE.put(entryRef, frWrapper);
            } else {
                ENTRY_STORE.remove(entryRef);
            }
        } finally {
            lock.unlock();
        }
    }
    return processedFlowRuleListBuilder.build();
}
#method_after
private Collection<FlowRule> processFlowRules(Collection<FlowRule> rules, Operation operation) {
    if (!setupBehaviour()) {
        return Collections.emptyList();
    }
    ImmutableList.Builder<FlowRule> processedFlowRuleListBuilder = ImmutableList.builder();
    for (FlowRule rule : rules) {
        PiTableEntry piTableEntry;
        try {
            piTableEntry = piFlowRuleTranslationService.translate(rule, pipeconf);
        } catch (PiFlowRuleTranslationService.PiFlowRuleTranslationException e) {
            log.warn("Unable to translate flow rule: {} - {}", e.getMessage(), rule);
            // next rule
            continue;
        }
        PiTableId tableId = piTableEntry.table();
        P4RuntimeTableEntryReference entryRef = new P4RuntimeTableEntryReference(deviceId, tableId, piTableEntry.matchKey());
        Lock lock = ENTRY_LOCKS.computeIfAbsent(entryRef, k -> new ReentrantLock());
        lock.lock();
        try {
            P4RuntimeFlowRuleWrapper frWrapper = ENTRY_STORE.get(entryRef);
            WriteOperationType opType = null;
            boolean doApply = true;
            if (operation == APPLY) {
                if (frWrapper == null) {
                    // Entry is first-timer.
                    opType = INSERT;
                } else {
                    // This match key already exists in the device.
                    if (checkEntryStoreBeforeUpdate && piTableEntry.action().equals(frWrapper.piTableEntry().action())) {
                        doApply = false;
                        log.debug("Ignoring re-apply of existing entry: {}", piTableEntry);
                    }
                    if (doApply) {
                        if (deleteEntryBeforeUpdate) {
                            // Remove before re-adding the modified one.
                            try {
                                if (client.writeTableEntries(newArrayList(piTableEntry), DELETE, pipeconf).get()) {
                                    frWrapper = null;
                                } else {
                                    log.warn("Unable to DELETE table entry (before re-adding) in {}: {}", deviceId, piTableEntry);
                                }
                            } catch (InterruptedException | ExecutionException e) {
                                log.warn("Exception while deleting table entry:", operation.name(), e);
                            }
                            opType = INSERT;
                        } else {
                            opType = MODIFY;
                        }
                    }
                }
            } else {
                opType = DELETE;
            }
            if (doApply) {
                try {
                    if (client.writeTableEntries(newArrayList(piTableEntry), opType, pipeconf).get()) {
                        processedFlowRuleListBuilder.add(rule);
                        if (operation == APPLY) {
                            frWrapper = new P4RuntimeFlowRuleWrapper(rule, piTableEntry, System.currentTimeMillis());
                        } else {
                            frWrapper = null;
                        }
                    } else {
                        log.warn("Unable to {} table entry in {}: {}", opType.name(), deviceId, piTableEntry);
                    }
                } catch (InterruptedException | ExecutionException e) {
                    log.warn("Exception while performing {} table entry operation:", operation.name(), e);
                }
            } else {
                processedFlowRuleListBuilder.add(rule);
            }
            // Update entryRef binding in table entry service.
            if (frWrapper != null) {
                ENTRY_STORE.put(entryRef, frWrapper);
            } else {
                ENTRY_STORE.remove(entryRef);
            }
        } finally {
            lock.unlock();
        }
    }
    return processedFlowRuleListBuilder.build();
}
#end_block

#method_before
private boolean doConnect() {
    return super.initClient();
}
#method_after
private boolean doConnect() {
    return super.createClient();
}
#end_block

#method_before
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket) {
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    Interface serverInterface = getServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get server interface, ignore");
        return null;
    }
    Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP address for server Interface {}", serverInterface);
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, context.inPacket().receivedFrom());
        return null;
    }
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(macFacingServer);
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(ipFacingServer.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    if (directlyConnected(dhcpPacket)) {
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        CircuitId cid = new CircuitId(inPort.toString(), vlanId);
        byte[] circuitId = cid.serialize();
        DhcpOption circuitIdSubOpt = new DhcpOption();
        circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
        DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
        newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
        newRelayAgentOpt.addSubOption(circuitIdSubOpt);
        // Removes END option  first
        List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
        // push relay agent option
        options.add(newRelayAgentOpt);
        // make sure option 255(End) is the last option
        DhcpOption endOption = new DhcpOption();
        endOption.setCode(OptionCode_END.getValue());
        options.add(endOption);
        dhcpPacket.setOptions(options);
        // Sets giaddr to IP address from the Interface which facing to
        // DHCP client
        dhcpPacket.setGatewayIPAddress(clientInterfaceIp.toInt());
    }
    // FIXME for both direct and indirect case now, should be separate
    if (relayAgentIp != null) {
        dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
    }
    udpPacket.setPayload(dhcpPacket);
    // As a DHCP relay, the source port should be server port(67) instead
    // of client port(68)
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket) {
    Ip4Address clientInterfaceIp = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom()).stream().map(Interface::ipAddressesList).flatMap(Collection::stream).map(InterfaceIpAddress::ipAddress).filter(IpAddress::isIp4).map(IpAddress::getIp4Address).findFirst().orElse(null);
    if (clientInterfaceIp == null) {
        log.warn("Can't find interface IP for client interface for port {}", context.inPacket().receivedFrom());
        return null;
    }
    Interface serverInterface = getServerInterface();
    if (serverInterface == null) {
        log.warn("Can't get server interface, ignore");
        return null;
    }
    Ip4Address ipFacingServer = getFirstIpFromInterface(serverInterface);
    MacAddress macFacingServer = serverInterface.mac();
    if (ipFacingServer == null || macFacingServer == null) {
        log.warn("No IP address for server Interface {}", serverInterface);
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, context.inPacket().receivedFrom());
        return null;
    }
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(macFacingServer);
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(ipFacingServer.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    if (directlyConnected(dhcpPacket)) {
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        CircuitId cid = new CircuitId(inPort.toString(), vlanId);
        byte[] circuitId = cid.serialize();
        DhcpOption circuitIdSubOpt = new DhcpOption();
        circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
        DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
        newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
        newRelayAgentOpt.addSubOption(circuitIdSubOpt);
        // Removes END option  first
        List<DhcpOption> options = dhcpPacket.getOptions().stream().filter(opt -> opt.getCode() != OptionCode_END.getValue()).collect(Collectors.toList());
        // push relay agent option
        options.add(newRelayAgentOpt);
        // make sure option 255(End) is the last option
        DhcpOption endOption = new DhcpOption();
        endOption.setCode(OptionCode_END.getValue());
        options.add(endOption);
        dhcpPacket.setOptions(options);
        // Sets giaddr to IP address from the Interface which facing to
        // DHCP client
        dhcpPacket.setGatewayIPAddress(clientInterfaceIp.toInt());
    }
    // FIXME for both direct and indirect case now, should be separated
    if (relayAgentIp != null) {
        dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
    }
    udpPacket.setPayload(dhcpPacket);
    // As a DHCP relay, the source port should be server port(67) instead
    // of client port(68)
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
private ResolvedRoute tryResolve(Route route) {
    ResolvedRoute resolvedRoute = resolve(route);
    if (resolvedRoute == null) {
        resolvedRoute = new ResolvedRoute(route, null, null);
    }
    return resolvedRoute;
}
#method_after
private ResolvedRoute tryResolve(Route route) {
    ResolvedRoute resolvedRoute = resolve(route);
    if (resolvedRoute == null) {
        resolvedRoute = new ResolvedRoute(route, null, null, null);
    }
    return resolvedRoute;
}
#end_block

#method_before
private ResolvedRoute resolve(Route route) {
    hostService.startMonitoringIp(route.nextHop());
    Set<Host> hosts = hostService.getHostsByIp(route.nextHop());
    Optional<Host> host = hosts.stream().findFirst();
    if (host.isPresent()) {
        return new ResolvedRoute(route, host.get().mac(), host.get().vlan());
    } else {
        return null;
    }
}
#method_after
private ResolvedRoute resolve(Route route) {
    hostService.startMonitoringIp(route.nextHop());
    Set<Host> hosts = hostService.getHostsByIp(route.nextHop());
    return hosts.stream().findFirst().map(host -> new ResolvedRoute(route, host.mac(), host.vlan(), host.location())).orElse(null);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(route, nextHopMac, nextHopVlan);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(route, nextHopMac, nextHopVlan, location);
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof ResolvedRoute)) {
        return false;
    }
    ResolvedRoute that = (ResolvedRoute) other;
    return Objects.equals(this.route, that.route) && Objects.equals(this.nextHopMac, that.nextHopMac) && Objects.equals(this.nextHopVlan, that.nextHopVlan);
}
#method_after
@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (!(other instanceof ResolvedRoute)) {
        return false;
    }
    ResolvedRoute that = (ResolvedRoute) other;
    return Objects.equals(this.route, that.route) && Objects.equals(this.nextHopMac, that.nextHopMac) && Objects.equals(this.nextHopVlan, that.nextHopVlan) && Objects.equals(this.location, that.location);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("route", route).add("nextHopMac", nextHopMac).add("nextHopVlan", nextHopVlan).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("route", route).add("nextHopMac", nextHopMac).add("nextHopVlan", nextHopVlan).add("location", location).toString();
}
#end_block

#method_before
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("verification not supported for {} group", nextObjective.type());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(NextObjective.Type.HASHED).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(bucket -> nextObjBuilder.addTreatment(bucket));
        addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sycn with nextObjective passed-in
        // Nevertheless groupStore may not be in sync (see CORD-1844)- verify
        GroupKey hashGroupKey = allActiveKeys.get(0).peekFirst();
        Group hashGroup = groupService.getGroup(deviceId, hashGroupKey);
        int actualGroupSize = hashGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, hashGroupKey, removeBuckets, hashGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, hashGroupKey, addBuckets, hashGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#method_after
protected void verifyGroup(NextObjective nextObjective, NextGroup next) {
    if (nextObjective.type() != NextObjective.Type.HASHED) {
        log.warn("verification not supported for {} group", nextObjective.type());
        fail(nextObjective, ObjectiveError.UNSUPPORTED);
        return;
    }
    log.debug("Call to verify device:{} nextId:{}", deviceId, nextObjective.id());
    List<Deque<GroupKey>> allActiveKeys = appKryo.deserialize(next.data());
    List<TrafficTreatment> bucketsToCreate = Lists.newArrayList();
    List<Integer> indicesToRemove = Lists.newArrayList();
    for (TrafficTreatment bkt : nextObjective.next()) {
        PortNumber portNumber = readOutPortFromTreatment(bkt);
        int label = readLabelFromTreatment(bkt);
        if (portNumber == null) {
            log.warn("treatment {} of next objective {} has no outport.. " + "cannot remove bucket from group in dev: {}", bkt, nextObjective.id(), deviceId);
            fail(nextObjective, ObjectiveError.BADPARAMS);
            return;
        }
        List<Integer> existing = existingPortAndLabel(allActiveKeys, groupService, deviceId, portNumber, label);
        if (existing.isEmpty()) {
            // if it doesn't exist, mark this bucket for creation
            bucketsToCreate.add(bkt);
        }
        if (existing.size() > 1) {
            // if it exists but there are duplicates, mark the others for removal
            existing.remove(0);
            indicesToRemove.addAll(existing);
        }
    }
    if (!bucketsToCreate.isEmpty()) {
        log.info("creating {} buckets as part of nextId: {} verification", bucketsToCreate.size(), nextObjective.id());
        // create a nextObjective only with these buckets
        NextObjective.Builder nextObjBuilder = DefaultNextObjective.builder().withId(nextObjective.id()).withType(NextObjective.Type.HASHED).withMeta(nextObjective.meta()).fromApp(nextObjective.appId());
        bucketsToCreate.forEach(bucket -> nextObjBuilder.addTreatment(bucket));
        addBucketToHashGroup(nextObjBuilder.addToExisting(), allActiveKeys);
    }
    if (!indicesToRemove.isEmpty()) {
        log.info("removing {} buckets as part of nextId: {} verification", indicesToRemove.size(), nextObjective.id());
        List<Deque<GroupKey>> chainsToRemove = Lists.newArrayList();
        indicesToRemove.forEach(index -> chainsToRemove.add(allActiveKeys.get(index)));
        removeBucket(chainsToRemove, nextObjective);
    }
    if (bucketsToCreate.isEmpty() && indicesToRemove.isEmpty()) {
        // flowObjective store record is in-sync with nextObjective passed-in
        // Nevertheless groupStore may not be in sync due to bug in the store
        // - see CORD-1844. XXX When this bug is fixed, the rest of this verify
        // method will not be required.
        GroupKey hashGroupKey = allActiveKeys.get(0).peekFirst();
        Group hashGroup = groupService.getGroup(deviceId, hashGroupKey);
        int actualGroupSize = hashGroup.buckets().buckets().size();
        int objGroupSize = nextObjective.next().size();
        if (actualGroupSize != objGroupSize) {
            log.warn("Mismatch detected in device:{}, nextId:{}, nextObjective-size" + ":{} group-size:{} .. correcting", deviceId, nextObjective.id(), objGroupSize, actualGroupSize);
        }
        if (actualGroupSize > objGroupSize) {
            List<GroupBucket> bucketsToRemove = Lists.newArrayList();
            // check every bucket in the actual group
            for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                // the group pointed to
                GroupId gidToCheck = g.groupId();
                boolean matches = false;
                for (Deque<GroupKey> validChain : allActiveKeys) {
                    if (validChain.size() < 2) {
                        continue;
                    }
                    GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                    Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                    if (pointedGroup != null && gidToCheck.equals(pointedGroup.id())) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Removing bucket pointing to groupId:{}", gidToCheck);
                    bucketsToRemove.add(bucket);
                }
            }
            // remove buckets for which there was no record in the obj store
            if (bucketsToRemove.isEmpty()) {
                log.warn("Mismatch detected but could not determine which" + "buckets to remove");
            } else {
                GroupBuckets removeBuckets = new GroupBuckets(bucketsToRemove);
                groupService.removeBucketsFromGroup(deviceId, hashGroupKey, removeBuckets, hashGroupKey, nextObjective.appId());
            }
        } else if (actualGroupSize < objGroupSize) {
            // should also add buckets not in group-store but in obj-store
            List<GroupBucket> bucketsToAdd = Lists.newArrayList();
            // check every bucket in the obj
            for (Deque<GroupKey> validChain : allActiveKeys) {
                if (validChain.size() < 2) {
                    continue;
                }
                GroupKey pointedGroupKey = validChain.stream().collect(Collectors.toList()).get(1);
                Group pointedGroup = groupService.getGroup(deviceId, pointedGroupKey);
                if (pointedGroup == null) {
                    // group should exist, otherwise cannot be added as bucket
                    continue;
                }
                boolean matches = false;
                for (GroupBucket bucket : hashGroup.buckets().buckets()) {
                    GroupInstruction g = (GroupInstruction) bucket.treatment().allInstructions().iterator().next();
                    // the group pointed to
                    GroupId gidToCheck = g.groupId();
                    if (pointedGroup.id().equals(gidToCheck)) {
                        matches = true;
                        break;
                    }
                }
                if (!matches) {
                    log.warn("Adding bucket pointing to groupId:{}", pointedGroup);
                    TrafficTreatment t = DefaultTrafficTreatment.builder().group(pointedGroup.id()).build();
                    bucketsToAdd.add(DefaultGroupBucket.createSelectGroupBucket(t));
                }
            }
            if (bucketsToAdd.isEmpty()) {
                log.warn("Mismatch detected but could not determine which " + "buckets to add");
            } else {
                GroupBuckets addBuckets = new GroupBuckets(bucketsToAdd);
                groupService.addBucketsToGroup(deviceId, hashGroupKey, addBuckets, hashGroupKey, nextObjective.appId());
            }
        }
    }
    pass(nextObjective);
}
#end_block

#method_before
static PiTableEntry translateFlowRule(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiFlowRuleTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    final PiPipelineInterpreter interpreter;
    if (device != null) {
        interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    } else {
        // The case of device == null should be admitted only during unit testing.
        // In any other case, the interpreter should be constructed using the device.as() method to make sure that
        // behaviour's handler/data attributes are correctly populated.
        log.warn("translateFlowRule() called with device == null, is this a unit test?");
        try {
            interpreter = (PiPipelineInterpreter) pipeconf.implementation(PiPipelineInterpreter.class).orElse(null).newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(format("Unable to instantiate interpreter of pipeconf %s", pipeconf.id()));
        }
    }
    PiTableId piTableId;
    switch(rule.table().type()) {
        case PIPELINE_INDEPENDENT:
            piTableId = (PiTableId) rule.table();
            break;
        case INDEX:
            IndexTableId indexId = (IndexTableId) rule.table();
            if (interpreter == null) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing interpreter", indexId.id()));
            } else if (!interpreter.mapFlowRuleTableId(indexId.id()).isPresent()) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing ID in interpreter", indexId.id()));
            } else {
                piTableId = interpreter.mapFlowRuleTableId(indexId.id()).get();
            }
            break;
        default:
            throw new PiFlowRuleTranslationException(format("Unrecognized table ID type %s", rule.table().type().name()));
    }
    PiTableModel table = pipelineModel.table(piTableId.toString()).orElseThrow(() -> new PiFlowRuleTranslationException(format("Not such a table in pipeline model: %s", piTableId)));
    /* Translate selector */
    Collection<PiFieldMatch> fieldMatches = buildFieldMatches(interpreter, rule.selector(), table);
    /* Translate treatment */
    PiAction piAction = buildAction(rule.treatment(), interpreter, piTableId);
    piAction = typeCheckAction(piAction, table);
    PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    // In the P4 world 0 is the highest priority, in ONOS the lowest one.
    // FIXME: move priority conversion to the driver, where different constraints might apply
    // e.g. less bits for encoding priority in TCAM-based implementations.
    int newPriority;
    if (rule.priority() > MAX_PI_PRIORITY) {
        log.warn("Flow rule priority too big, setting translated priority to max value {}: {}", MAX_PI_PRIORITY, rule);
        newPriority = 0;
    } else {
        newPriority = MAX_PI_PRIORITY - rule.priority();
    }
    tableEntryBuilder.forTable(piTableId).withPriority(newPriority).withMatchKey(PiMatchKey.builder().addFieldMatches(fieldMatches).build()).withAction(piAction);
    if (!rule.isPermanent()) {
        if (table.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", table.name());
        }
    }
    return tableEntryBuilder.build();
}
#method_after
static PiTableEntry translateFlowRule(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiFlowRuleTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    final PiPipelineInterpreter interpreter;
    if (device != null) {
        interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    } else {
        // The case of device == null should be admitted only during unit testing.
        // In any other case, the interpreter should be constructed using the device.as() method to make sure that
        // behaviour's handler/data attributes are correctly populated.
        // FIXME: modify test class PiFlowRuleTranslatorTest to avoid passing null device
        // I.e. we need to create a device object that supports is/as method for obtaining the interpreter.
        log.warn("translateFlowRule() called with device == null, is this a unit test?");
        try {
            interpreter = (PiPipelineInterpreter) pipeconf.implementation(PiPipelineInterpreter.class).orElse(null).newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(format("Unable to instantiate interpreter of pipeconf %s", pipeconf.id()));
        }
    }
    PiTableId piTableId;
    switch(rule.table().type()) {
        case PIPELINE_INDEPENDENT:
            piTableId = (PiTableId) rule.table();
            break;
        case INDEX:
            IndexTableId indexId = (IndexTableId) rule.table();
            if (interpreter == null) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing interpreter", indexId.id()));
            } else if (!interpreter.mapFlowRuleTableId(indexId.id()).isPresent()) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing ID in interpreter", indexId.id()));
            } else {
                piTableId = interpreter.mapFlowRuleTableId(indexId.id()).get();
            }
            break;
        default:
            throw new PiFlowRuleTranslationException(format("Unrecognized table ID type %s", rule.table().type().name()));
    }
    PiTableModel table = pipelineModel.table(piTableId.toString()).orElseThrow(() -> new PiFlowRuleTranslationException(format("Not such a table in pipeline model: %s", piTableId)));
    /* Translate selector */
    Collection<PiFieldMatch> fieldMatches = buildFieldMatches(interpreter, rule.selector(), table);
    /* Translate treatment */
    PiAction piAction = buildAction(rule.treatment(), interpreter, piTableId);
    piAction = typeCheckAction(piAction, table);
    PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    // In the P4 world 0 is the highest priority, in ONOS the lowest one.
    // FIXME: move priority conversion to the driver, where different constraints might apply
    // e.g. less bits for encoding priority in TCAM-based implementations.
    int newPriority;
    if (rule.priority() > MAX_PI_PRIORITY) {
        log.warn("Flow rule priority too big, setting translated priority to max value {}: {}", MAX_PI_PRIORITY, rule);
        newPriority = 0;
    } else {
        newPriority = MAX_PI_PRIORITY - rule.priority();
    }
    tableEntryBuilder.forTable(piTableId).withPriority(newPriority).withMatchKey(PiMatchKey.builder().addFieldMatches(fieldMatches).build()).withAction(piAction);
    if (!rule.isPermanent()) {
        if (table.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", table.name());
        }
    }
    return tableEntryBuilder.build();
}
#end_block

#method_before
public Set<HostLocation> locations() {
    Set<HostLocation> locations = null;
    if (object.has(LOCATIONS)) {
        Set<HostLocation> objectLocations = new HashSet<>();
        ArrayNode locationNodes = (ArrayNode) object.path(LOCATIONS);
        locationNodes.forEach(n -> {
            ConnectPoint cp = ConnectPoint.deviceConnectPoint((n.asText()));
            objectLocations.add(new HostLocation(cp, 0));
        });
        if (objectLocations.isEmpty()) {
            throw new IllegalArgumentException("Host should have at least one location");
        } else {
            locations = objectLocations;
        }
    }
    return locations;
}
#method_after
public Set<HostLocation> locations() {
    if (!object.has(LOCATIONS)) {
        // no locations are specified
        return null;
    }
    ImmutableSet.Builder<HostLocation> locationsSetBuilder = ImmutableSet.<HostLocation>builder();
    ArrayNode locationNodes = (ArrayNode) object.path(LOCATIONS);
    locationNodes.forEach(n -> {
        ConnectPoint cp = ConnectPoint.deviceConnectPoint((n.asText()));
        locationsSetBuilder.add(new HostLocation(cp, 0));
    });
    Set<HostLocation> locations = locationsSetBuilder.build();
    if (locations.isEmpty()) {
        throw new IllegalArgumentException("Host should have at least one location");
    }
    return locations;
}
#end_block

#method_before
public static ApplicationIdProtoOuterClass.ApplicationIdProto translate(ApplicationId applicationId) {
    return ApplicationIdProtoOuterClass.ApplicationIdProto.newBuilder().setId(applicationId.id()).setName(applicationId.name()).build();
}
#method_after
public static ApplicationId translate(ApplicationIdProto applicationId) {
    return new DefaultApplicationId(applicationId.getId(), applicationId.getName());
}
#end_block

#method_before
public static ApplicationIdProtoOuterClass.ApplicationIdProto translate(ApplicationId applicationId) {
    return ApplicationIdProtoOuterClass.ApplicationIdProto.newBuilder().setId(applicationId.id()).setName(applicationId.name()).build();
}
#method_after
public static ApplicationIdProto translate(ApplicationId applicationId) {
    if (applicationId != null) {
        return ApplicationIdProto.newBuilder().setId(applicationId.id()).setName(applicationId.name()).build();
    }
    return getDefaultInstance();
}
#end_block

#method_before
public static ApplicationEnumsProto.ApplicationRoleProto translate(ApplicationRole role) {
    switch(role) {
        case USER:
            return ApplicationEnumsProto.ApplicationRoleProto.USER;
        case ADMIN:
            return ApplicationEnumsProto.ApplicationRoleProto.ADMIN;
        case UNSPECIFIED:
            return ApplicationEnumsProto.ApplicationRoleProto.UNSPECIFIED;
        default:
            log.warn("Unexpected application role: {}", role);
            return ApplicationEnumsProto.ApplicationRoleProto.UNSPECIFIED;
    }
}
#method_after
public static ApplicationRoleProto translate(ApplicationRole role) {
    switch(role) {
        case USER:
            return ApplicationRoleProto.USER;
        case ADMIN:
            return ApplicationRoleProto.ADMIN;
        case UNSPECIFIED:
            return ApplicationRoleProto.UNSPECIFIED;
        default:
            log.warn("Unexpected application role: {}", role);
            return ApplicationRoleProto.UNSPECIFIED;
    }
}
#end_block

#method_before
public static ApplicationState translate(ApplicationEnumsProto.ApplicationStateProto stateProto) {
    switch(stateProto) {
        case ACTIVE:
            return ApplicationState.ACTIVE;
        case INSTALLED:
            return ApplicationState.INSTALLED;
        default:
            log.warn("Unexpected application state proto: {}", stateProto);
            return ApplicationState.INSTALLED;
    }
}
#method_after
public static Optional<Object> translate(ApplicationRoleProto roleProto) {
    switch(roleProto) {
        case USER:
            return Optional.of(ApplicationRole.USER);
        case ADMIN:
            return Optional.of(ApplicationRole.ADMIN);
        case UNSPECIFIED:
            return Optional.of(ApplicationRole.UNSPECIFIED);
        default:
            log.warn("Unexpected application role proto: {}", roleProto);
            return Optional.empty();
    }
}
#end_block

#method_before
public static ApplicationEnumsProto.ApplicationStateProto translate(ApplicationState state) {
    switch(state) {
        case ACTIVE:
            return ApplicationEnumsProto.ApplicationStateProto.ACTIVE;
        case INSTALLED:
            return ApplicationEnumsProto.ApplicationStateProto.INSTALLED;
        default:
            log.warn("Unexpected application state: {}", state);
            return ApplicationEnumsProto.ApplicationStateProto.INSTALLED;
    }
}
#method_after
public static ApplicationStateProto translate(ApplicationState state) {
    switch(state) {
        case ACTIVE:
            return ApplicationStateProto.ACTIVE;
        case INSTALLED:
            return ApplicationStateProto.INSTALLED;
        default:
            log.warn("Unexpected application state: {}", state);
            return ApplicationStateProto.INSTALLED;
    }
}
#end_block

#method_before
public static ApplicationProtoOuterClass.ApplicationProto translate(Application application) {
    return ApplicationProtoOuterClass.ApplicationProto.newBuilder().setAppId(ApplicationIdProtoTranslator.translate(application.id())).setCategory(application.category()).setDescription(application.description()).setOrigin(application.origin()).setReadme(application.readme()).setTitle(application.title()).setUrl(application.url()).setVersion(application.version().toString()).setRole(ApplicationEnumsProtoTranslator.translate(application.role())).build();
}
#method_after
public static Application translate(ApplicationProto app) {
    Set<Permission> permissions = Sets.newHashSet();
    app.getPermissionsList().forEach(p -> permissions.add(PermissionProtoTranslator.translate(p)));
    return new DefaultApplication(ApplicationIdProtoTranslator.translate(app.getAppId()), VersionProtoTranslator.translate(app.getVersion()), app.getTitle(), app.getDescription(), app.getOrigin(), app.getCategory(), app.getUrl(), app.getReadme(), app.toByteArray(), (ApplicationRole) ApplicationEnumsProtoTranslator.translate(app.getRole()).get(), permissions, Optional.empty(), app.getFeaturesList(), app.getRequiredAppsList());
}
#end_block

#method_before
public static ApplicationProtoOuterClass.ApplicationProto translate(Application application) {
    return ApplicationProtoOuterClass.ApplicationProto.newBuilder().setAppId(ApplicationIdProtoTranslator.translate(application.id())).setCategory(application.category()).setDescription(application.description()).setOrigin(application.origin()).setReadme(application.readme()).setTitle(application.title()).setUrl(application.url()).setVersion(application.version().toString()).setRole(ApplicationEnumsProtoTranslator.translate(application.role())).build();
}
#method_after
public static ApplicationProto translate(Application application) {
    if (application != null) {
        return ApplicationProto.newBuilder().setAppId(ApplicationIdProtoTranslator.translate(application.id())).setCategory(application.category()).setDescription(application.description()).setOrigin(application.origin()).setReadme(application.readme()).setTitle(application.title()).setUrl(application.url()).setVersion(VersionProtoTranslator.translate(application.version())).setRole(ApplicationEnumsProtoTranslator.translate(application.role())).build();
    }
    return getDefaultInstance();
}
#end_block

#method_before
public static PermissionProtoOuterClass.PermissionProto translate(Permission permission) {
    return PermissionProtoOuterClass.PermissionProto.newBuilder().setActions(permission.getActions()).setClassname(permission.getClassName()).setName(permission.getName()).build();
}
#method_after
public static PermissionProto translate(Permission permission) {
    if (permission != null) {
        return PermissionProto.newBuilder().setActions(permission.getActions()).setClassname(permission.getClassName()).setName(permission.getName()).build();
    }
    return getDefaultInstance();
}
#end_block

#method_before
public static PermissionProtoOuterClass.PermissionProto translate(Permission permission) {
    return PermissionProtoOuterClass.PermissionProto.newBuilder().setActions(permission.getActions()).setClassname(permission.getClassName()).setName(permission.getName()).build();
}
#method_after
public static Permission translate(PermissionProto permission) {
    return new Permission(permission.getClassname(), permission.getName(), permission.getActions());
}
#end_block

#method_before
public static LinkProtoOuterClass.LinkProto translate(Link link) {
    return LinkProtoOuterClass.LinkProto.newBuilder().setState(translate(link.state())).setSrc(translate(link.src())).setDst(translate(link.dst())).setType(translate(link.type())).build();
}
#method_after
public static MastershipRole translate(MastershipRoleProto role) {
    switch(role) {
        case NONE:
            return MastershipRole.NONE;
        case MASTER:
            return MastershipRole.MASTER;
        case STANDBY:
            return MastershipRole.STANDBY;
        case UNRECOGNIZED:
            log.warn("Unrecognized MastershipRole gRPC message: {}", role);
            return MastershipRole.NONE;
        default:
            return MastershipRole.NONE;
    }
}
#end_block

#method_before
public static DeviceEnums.MastershipRole translate(MastershipRole newRole) {
    switch(newRole) {
        case MASTER:
            return DeviceEnums.MastershipRole.MASTER;
        case STANDBY:
            return DeviceEnums.MastershipRole.STANDBY;
        case NONE:
        default:
            return DeviceEnums.MastershipRole.NONE;
    }
}
#method_after
public static MastershipRoleProto translate(MastershipRole newRole) {
    switch(newRole) {
        case MASTER:
            return MastershipRoleProto.MASTER;
        case STANDBY:
            return MastershipRoleProto.STANDBY;
        case NONE:
        default:
            return MastershipRoleProto.NONE;
    }
}
#end_block

#method_before
public static DeviceDescriptionProto.DeviceDescription translate(DeviceDescription deviceDescription) {
    return DeviceDescriptionProto.DeviceDescription.newBuilder().setDeviceUri(deviceDescription.deviceUri().toString()).setType(translate(deviceDescription.type())).setManufacturer(deviceDescription.manufacturer()).setHwVersion(deviceDescription.hwVersion()).setSwVersion(deviceDescription.swVersion()).setSerialNumber(deviceDescription.serialNumber()).setChassisId(deviceDescription.chassisId().toString()).setIsDefaultAvailable(deviceDescription.isDefaultAvailable()).putAllAnnotations(asMap(deviceDescription.annotations())).build();
}
#method_after
public static DeviceDescriptionProto translate(DeviceDescription deviceDescription) {
    return DeviceDescriptionProto.newBuilder().setDeviceUri(deviceDescription.deviceUri().toString()).setType(translate(deviceDescription.type())).setManufacturer(deviceDescription.manufacturer()).setHwVersion(deviceDescription.hwVersion()).setSwVersion(deviceDescription.swVersion()).setSerialNumber(deviceDescription.serialNumber()).setChassisId(deviceDescription.chassisId().toString()).setIsDefaultAvailable(deviceDescription.isDefaultAvailable()).putAllAnnotations(asMap(deviceDescription.annotations())).build();
}
#end_block

#method_before
public static DeviceType translate(Device.Type type) {
    switch(type) {
        case BALANCER:
            return DeviceType.BALANCER;
        case CONTROLLER:
            return DeviceType.CONTROLLER;
        case FIBER_SWITCH:
            return DeviceType.FIBER_SWITCH;
        case FIREWALL:
            return DeviceType.FIREWALL;
        case IDS:
            return DeviceType.IDS;
        case IPS:
            return DeviceType.IPS;
        case MICROWAVE:
            return DeviceType.MICROWAVE;
        case OTHER:
            return DeviceType.OTHER;
        case OTN:
            return DeviceType.OTN;
        case ROADM:
            return DeviceType.ROADM;
        case ROADM_OTN:
            return DeviceType.ROADM_OTN;
        case ROUTER:
            return DeviceType.ROUTER;
        case SWITCH:
            return DeviceType.SWITCH;
        case VIRTUAL:
            return DeviceType.VIRTUAL;
        default:
            log.warn("Unexpected Device.Type: {}", type);
            return DeviceType.OTHER;
    }
}
#method_after
public static DeviceTypeProto translate(Device.Type type) {
    switch(type) {
        case BALANCER:
            return DeviceTypeProto.BALANCER;
        case CONTROLLER:
            return DeviceTypeProto.CONTROLLER;
        case FIBER_SWITCH:
            return DeviceTypeProto.FIBER_SWITCH;
        case FIREWALL:
            return DeviceTypeProto.FIREWALL;
        case IDS:
            return DeviceTypeProto.IDS;
        case IPS:
            return DeviceTypeProto.IPS;
        case MICROWAVE:
            return DeviceTypeProto.MICROWAVE;
        case OTHER:
            return DeviceTypeProto.OTHER;
        case OTN:
            return DeviceTypeProto.OTN;
        case ROADM:
            return DeviceTypeProto.ROADM;
        case ROADM_OTN:
            return DeviceTypeProto.ROADM_OTN;
        case ROUTER:
            return DeviceTypeProto.ROUTER;
        case SWITCH:
            return DeviceTypeProto.SWITCH;
        case VIRTUAL:
            return DeviceTypeProto.VIRTUAL_DEVICE;
        default:
            log.warn("Unexpected Device.Type: {}", type);
            return DeviceTypeProto.OTHER;
    }
}
#end_block

#method_before
public static PortDescriptionProto.PortDescription translate(PortDescription portDescription) {
    return PortDescriptionProto.PortDescription.newBuilder().setPortNumber(portDescription.portNumber().toString()).setIsEnabled(portDescription.isEnabled()).setType(translate(portDescription.type())).setPortSpeed(portDescription.portSpeed()).putAllAnnotations(asMap(portDescription.annotations())).build();
}
#method_after
public static PortDescriptionProto translate(PortDescription portDescription) {
    return PortDescriptionProto.newBuilder().setPortNumber(portDescription.portNumber().toString()).setIsEnabled(portDescription.isEnabled()).setType(translate(portDescription.type())).setPortSpeed(portDescription.portSpeed()).putAllAnnotations(asMap(portDescription.annotations())).build();
}
#end_block

#method_before
public static PortType translate(Port.Type type) {
    switch(type) {
        case COPPER:
            return PortType.COPPER;
        case FIBER:
            return PortType.FIBER;
        case OCH:
            return PortType.OCH;
        case ODUCLT:
            return PortType.ODUCLT;
        case OMS:
            return PortType.OMS;
        case PACKET:
            return PortType.PACKET;
        case VIRTUAL:
            return PortType.VIRTUAL;
        default:
            log.warn("Unexpected Port.Type: {}", type);
            return PortType.COPPER;
    }
}
#method_after
public static PortTypeProto translate(Port.Type type) {
    switch(type) {
        case COPPER:
            return PortTypeProto.COPPER;
        case FIBER:
            return PortTypeProto.FIBER;
        case OCH:
            return PortTypeProto.OCH;
        case ODUCLT:
            return PortTypeProto.ODUCLT;
        case OMS:
            return PortTypeProto.OMS;
        case PACKET:
            return PortTypeProto.PACKET;
        case VIRTUAL:
            return PortTypeProto.VIRTUAL_PORT;
        default:
            log.warn("Unexpected Port.Type: {}", type);
            return PortTypeProto.COPPER;
    }
}
#end_block

#method_before
public static PortStatisticsProto.PortStatistics translate(PortStatistics portStatistics) {
    // TODO implement adding missing fields
    return PortStatisticsProto.PortStatistics.newBuilder().setPort(portStatistics.port()).setPacketsReceived(portStatistics.packetsReceived()).setPacketsSent(portStatistics.packetsSent()).build();
}
#method_after
public static PortStatisticsProto translate(PortStatistics portStatistics) {
    // TODO implement adding missing fields
    return PortStatisticsProto.newBuilder().setPort(portStatistics.port()).setPacketsReceived(portStatistics.packetsReceived()).setPacketsSent(portStatistics.packetsSent()).build();
}
#end_block

#method_before
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, "pollFrequency", DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
    }
    if (scheduledTasks != null) {
        // cancel all previous tasks
        scheduledTasks.forEach(task -> task.cancel(false));
        // resubmit task with new timeout.
        Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class);
        deviceSubjects.forEach(deviceId -> {
            if (!deviceId.uri().getScheme().equals(URI_SCHEME)) {
                // not under my scheme, skipping
                log.debug("{} is not my scheme, skipping", deviceId);
                return;
            }
            scheduledTasks.add(schedulePolling(deviceId));
        });
    }
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context != null) {
        Dictionary<?, ?> properties = context.getProperties();
        pollFrequency = Tools.getIntegerProperty(properties, "pollFrequency", DEFAULT_POLL_FREQUENCY_SECONDS);
        log.info("Configured. Poll frequency is configured to {} seconds", pollFrequency);
    }
    if (!scheduledTasks.isEmpty()) {
        // cancel all previous tasks
        scheduledTasks.values().forEach(task -> task.cancel(false));
        // resubmit task with new timeout.
        Set<DeviceId> deviceSubjects = cfgService.getSubjects(DeviceId.class, GeneralProviderDeviceConfig.class);
        deviceSubjects.forEach(deviceId -> {
            if (!compareScheme(deviceId)) {
                // not under my scheme, skipping
                log.debug("{} is not my scheme, skipping", deviceId);
                return;
            }
            scheduledTasks.put(deviceId, schedulePolling(deviceId, true));
        });
    }
}
#end_block

#method_before
private void disconnectDevice(DeviceId deviceId) {
    log.info("Disconnecting for device {}", deviceId);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker != null) {
        CompletableFuture<Boolean> disconnect = handshaker.disconnect();
        disconnect.thenAcceptAsync(result -> {
            if (result) {
                log.info("Disconnected device {}", deviceId);
                providerService.deviceDisconnected(deviceId);
            } else {
                log.warn("Device {} was unable to disconnect", deviceId);
            }
        });
    } else {
        // gracefully ignoring.
        log.info("No DeviceHandshaker for device {}", deviceId);
    }
}
#method_after
private void disconnectDevice(DeviceId deviceId) {
    log.info("Disconnecting for device {}", deviceId);
    DeviceHandshaker handshaker = getHandshaker(deviceId);
    if (handshaker != null) {
        CompletableFuture<Boolean> disconnect = handshaker.disconnect();
        disconnect.thenAcceptAsync(result -> {
            if (result) {
                log.info("Disconnected device {}", deviceId);
                providerService.deviceDisconnected(deviceId);
            } else {
                log.warn("Device {} was unable to disconnect", deviceId);
            }
        });
    } else {
        // gracefully ignoring.
        log.info("No DeviceHandshaker for device {}", deviceId);
    }
    ScheduledFuture<?> pollingStatisticsTask = scheduledTasks.get(deviceId);
    if (pollingStatisticsTask != null) {
        pollingStatisticsTask.cancel(true);
    }
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    DeviceId deviceId = (DeviceId) event.subject();
    // Assuming that the deviceId comes with uri 'device:'
    if (!deviceId.uri().getScheme().equals(URI_SCHEME)) {
        // not under my scheme, skipping
        log.debug("{} is not my scheme, skipping", deviceId);
        return;
    }
    if (deviceService.getDevice(deviceId) != null || deviceService.isAvailable(deviceId)) {
        log.info("Device {} is already connected to ONOS and is available", deviceId);
        return;
    }
    // FIXME to be removed when netcfg will issue device events in a bundle or
    // ensure all configuration needed is present
    Lock lock = ENTRY_LOCKS.computeIfAbsent(deviceId, key -> new ReentrantLock());
    lock.lock();
    try {
        if (event.configClass().equals(GeneralProviderDeviceConfig.class)) {
            // If we want to connect a p4runtime device with no pipeline
            if (event.config().isPresent() && Collections.disjoint(ImmutableSet.copyOf(event.config().get().node().fieldNames()), PIPELINE_CONFIGURABLE_PROTOCOLS)) {
                pipelineConfigured.add(deviceId);
            }
            deviceConfigured.add(deviceId);
        } else if (event.configClass().equals(BasicDeviceConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(DRIVER)) {
                // TODO add check for pipeline and add it to the pipeline list if no
                // p4runtime is present.
                driverConfigured.add(deviceId);
            }
        } else if (event.configClass().equals(PiPipeconfConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(PiPipeconfConfig.PIPIPECONFID)) {
                pipelineConfigured.add(deviceId);
            }
        }
        // in the pipelineConfigured
        if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId) && pipelineConfigured.contains(deviceId)) {
            checkAndSubmitDeviceTask(deviceId);
        } else {
            if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for pipeline configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for device configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && deviceConfigured.contains(deviceId)) {
                log.debug("Waiting for driver configuration for device {}", deviceId);
            } else if (driverConfigured.contains(deviceId)) {
                log.debug("Only driver configuration for device {}", deviceId);
            } else if (deviceConfigured.contains(deviceId)) {
                log.debug("Only device configuration for device {}", deviceId);
            }
        }
    } finally {
        lock.unlock();
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    DeviceId deviceId = (DeviceId) event.subject();
    // Assuming that the deviceId comes with uri 'device:'
    if (!compareScheme(deviceId)) {
        // not under my scheme, skipping
        log.debug("{} is not my scheme, skipping", deviceId);
        return;
    }
    if (deviceService.getDevice(deviceId) != null || deviceService.isAvailable(deviceId)) {
        log.info("Device {} is already connected to ONOS and is available", deviceId);
        return;
    }
    // FIXME to be removed when netcfg will issue device events in a bundle or
    // ensure all configuration needed is present
    Lock lock = ENTRY_LOCKS.computeIfAbsent(deviceId, key -> new ReentrantLock());
    lock.lock();
    try {
        if (event.configClass().equals(GeneralProviderDeviceConfig.class)) {
            // If we want to connect a p4runtime device with no pipeline
            if (event.config().isPresent() && Collections.disjoint(ImmutableSet.copyOf(event.config().get().node().fieldNames()), PIPELINE_CONFIGURABLE_PROTOCOLS)) {
                pipelineConfigured.add(deviceId);
            }
            deviceConfigured.add(deviceId);
        } else if (event.configClass().equals(BasicDeviceConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(DRIVER)) {
                // TODO add check for pipeline and add it to the pipeline list if no
                // p4runtime is present.
                driverConfigured.add(deviceId);
            }
        } else if (event.configClass().equals(PiPipeconfConfig.class)) {
            if (event.config().isPresent() && event.config().get().node().has(PiPipeconfConfig.PIPIPECONFID)) {
                pipelineConfigured.add(deviceId);
            }
        }
        // in the pipelineConfigured
        if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId) && pipelineConfigured.contains(deviceId)) {
            checkAndSubmitDeviceTask(deviceId);
        } else {
            if (deviceConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for pipeline configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && driverConfigured.contains(deviceId)) {
                log.debug("Waiting for device configuration for device {}", deviceId);
            } else if (pipelineConfigured.contains(deviceId) && deviceConfigured.contains(deviceId)) {
                log.debug("Waiting for driver configuration for device {}", deviceId);
            } else if (driverConfigured.contains(deviceId)) {
                log.debug("Only driver configuration for device {}", deviceId);
            } else if (deviceConfigured.contains(deviceId)) {
                log.debug("Only device configuration for device {}", deviceId);
            }
        }
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
private ScheduledFuture<?> schedulePolling(DeviceId deviceId) {
    return portStatsExecutor.scheduleAtFixedRate(exceptionSafe(() -> updatePortStatistics(deviceId)), 0, pollFrequency, TimeUnit.SECONDS);
}
#method_after
private ScheduledFuture<?> schedulePolling(DeviceId deviceId, boolean randomize) {
    int delay = 0;
    if (randomize) {
        delay = new Random().nextInt(10);
    }
    return portStatsExecutor.scheduleAtFixedRate(exceptionSafe(() -> updatePortStatistics(deviceId)), delay, pollFrequency, TimeUnit.SECONDS);
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    Type type = event.type();
    if (type.equals((Type.DEVICE_ADDED))) {
        // be available we check and base it on the streaming API (e.g. gNMI)
        if (deviceService.getDevice(event.subject().id()).is(PortStatisticsDiscovery.class)) {
            scheduledTasks.add(schedulePolling(event.subject().id()));
            updatePortStatistics(event.subject().id());
        }
    } else if (type.equals(Type.DEVICE_REMOVED)) {
        connectionExecutor.submit(exceptionSafe(() -> disconnectDevice(event.subject().id())));
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    Type type = event.type();
    if (type.equals((Type.DEVICE_ADDED))) {
        // be available we check and base it on the streaming API (e.g. gNMI)
        if (deviceService.getDevice(event.subject().id()).is(PortStatisticsDiscovery.class)) {
            scheduledTasks.put(event.subject().id(), schedulePolling(event.subject().id(), false));
            updatePortStatistics(event.subject().id());
        }
    } else if (type.equals(Type.DEVICE_REMOVED)) {
        connectionExecutor.submit(exceptionSafe(() -> disconnectDevice(event.subject().id())));
    }
}
#end_block

#method_before
private void addToStore(ResourceData resData) {
    if (resData != null && resData.dataNodes() != null) {
        List<DataNode> dataNodes = resData.dataNodes();
        for (DataNode node : dataNodes) {
            configService.createNodeRecursive(resData.resourceId(), node);
        }
    }
}
#method_after
private void addToStore(ResourceData resData) {
    if (resData != null && resData.dataNodes() != null) {
        List<DataNode> dataNodes = resData.dataNodes();
        for (DataNode node : dataNodes) {
            configService.createNode(resData.resourceId(), node);
        }
    }
}
#end_block

#method_before
private void deleteFromStore(ResourceData resData) {
    if (resData != null) {
        configService.deleteNodeRecursive(resData.resourceId());
    }
}
#method_after
private void deleteFromStore(ResourceData resData) {
    if (resData != null) {
        configService.deleteNode(resData.resourceId());
    }
}
#end_block

#method_before
@Override
public void processItems(List<DynamicConfigEvent> events) {
    for (DynamicConfigEvent event : events) {
        checkNotNull(event, EVENT_NULL);
        Filter filter = new Filter();
        DataNode node;
        try {
            node = configService.readNode(event.subject(), filter);
        } catch (FailedException e) {
            node = null;
        }
        switch(event.type()) {
            case NODE_ADDED:
                processCreateFromStore(event.subject(), node);
                break;
            case NODE_DELETED:
                processDeleteFromStore(node);
                break;
            default:
                log.warn(UNKNOWN_EVENT, event.type());
                break;
        }
    }
}
#method_after
@Override
public void processItems(List<DynamicConfigEvent> events) {
    for (DynamicConfigEvent event : events) {
        checkNotNull(event, EVENT_NULL);
        Filter filter = Filter.builder().build();
        DataNode node;
        try {
            node = configService.readNode(event.subject(), filter);
        } catch (FailedException e) {
            node = null;
        }
        switch(event.type()) {
            case NODE_ADDED:
                processCreateFromStore(event.subject(), node);
                break;
            case NODE_DELETED:
                processDeleteFromStore(node);
                break;
            default:
                log.warn(UNKNOWN_EVENT, event.type());
                break;
        }
    }
}
#end_block

#method_before
public ModelObjectData processCreateInstance(DriverService driverSvc, ModelObjectData modelData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.createInstance(modelData);
}
#method_after
public ModelObjectData processCreateInstance(DriverService driverSvc, ModelObjectData modelData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.createInstance(modelData);
}
#end_block

#method_before
public ModelObjectData processCreateInterface(DriverService driverSvc, ModelObjectData modData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.bindInterface(modData);
}
#method_after
public ModelObjectData processCreateInterface(DriverService driverSvc, ModelObjectData modData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.bindInterface(modData);
}
#end_block

#method_before
public ModelObjectData processCreateBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.createBgpInfo(bgpInfo, driverInfo);
}
#method_after
public ModelObjectData processCreateBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.createBgpInfo(bgpInfo, driverInfo);
}
#end_block

#method_before
public ModelObjectData processCreateTnlDev(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.createTnlDev(tnlInfo);
}
#method_after
public ModelObjectData processCreateTnlDev(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.createTnlDev(tnlInfo);
}
#end_block

#method_before
public ModelObjectData processCreateTnlPol(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.createTnlPol(tnlInfo);
}
#method_after
public ModelObjectData processCreateTnlPol(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.createTnlPol(tnlInfo);
}
#end_block

#method_before
public ModelObjectData processCreateTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.createTnl(tnlInfo);
}
#method_after
public ModelObjectData processCreateTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.createTnl(tnlInfo);
}
#end_block

#method_before
public ModelObjectData processBindTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.bindTnl(tnlInfo);
}
#method_after
public ModelObjectData processBindTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.bindTnl(tnlInfo);
}
#end_block

#method_before
public ModelObjectData processDeleteInstance(DriverService driverSvc, ModelObjectData modData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.deleteInstance(modData);
}
#method_after
public ModelObjectData processDeleteInstance(DriverService driverSvc, ModelObjectData modData) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.deleteInstance(modData);
}
#end_block

#method_before
public ModelObjectData processDeleteBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.deleteBgpInfo(bgpInfo, driverInfo);
}
#method_after
public ModelObjectData processDeleteBgpInfo(DriverService driverSvc, BgpInfo bgpInfo, BgpDriverInfo driverInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.deleteBgpInfo(bgpInfo, driverInfo);
}
#end_block

#method_before
public ModelObjectData processDeleteTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return (ModelObjectData) config.deleteTnl(tnlInfo);
}
#method_after
public ModelObjectData processDeleteTnl(DriverService driverSvc, TunnelInfo tnlInfo) {
    L3VpnConfig config = getL3VpnConfig(driverSvc);
    return config.deleteTnl(tnlInfo);
}
#end_block

#method_before
private void addToStore(ResourceData resData) {
    if (resData != null && resData.dataNodes() != null) {
        List<DataNode> dataNodes = resData.dataNodes();
        for (DataNode node : dataNodes) {
            configSvc.createNodeRecursive(resData.resourceId(), node);
        }
    }
}
#method_after
private void addToStore(ResourceData resData) {
    if (resData != null && resData.dataNodes() != null) {
        List<DataNode> dataNodes = resData.dataNodes();
        for (DataNode node : dataNodes) {
            configSvc.createNode(resData.resourceId(), node);
        }
    }
}
#end_block

#method_before
private void deleteFromStore(ModelObjectData mod) {
    ResourceData resData = modelCon.createDataNode(mod);
    if (resData != null) {
        configSvc.deleteNodeRecursive(resData.resourceId());
    }
}
#method_after
private void deleteFromStore(ModelObjectData mod) {
    ResourceData resData = modelCon.createDataNode(mod);
    if (resData != null) {
        configSvc.deleteNode(resData.resourceId());
    }
}
#end_block

#method_before
static Object getDeleteVpnIns(ModelObjectData modObj) {
    ModelIdLevel modIdLvl = DEVICE;
    String id = getIdFromModId(modObj.identifier(), true);
    Object obj = getObjFromModData(modObj);
    if (obj == null) {
        throw new IllegalArgumentException(OBJECT_NULL);
    }
    if (id == null) {
        modIdLvl = ROOT;
        id = getDevIdFromRootObj(obj);
        obj = getObjFromRootObj(obj);
    } else if (id.equals(CONS_DEVICES)) {
        modIdLvl = DEVICES;
        id = ((Device) obj).deviceid();
        obj = ((Device) obj).networkInstances();
    }
    List<NetworkInstance> ins = ((NetworkInstances) obj).networkInstance();
    Iterator<NetworkInstance> it = ins.iterator();
    NetworkInstance instance;
    if (it.hasNext()) {
        instance = it.next();
    } else {
        throw new IllegalArgumentException(INS_NULL);
    }
    return getDelModObjData(modIdLvl, id, instance.name());
}
#method_after
static ModelObjectData getDeleteVpnIns(ModelObjectData modObj) {
    ModelIdLevel modIdLvl = DEVICE;
    String id = getIdFromModId(modObj.identifier(), true);
    Object obj = getObjFromModData(modObj);
    if (obj == null) {
        throw new IllegalArgumentException(OBJECT_NULL);
    }
    if (id == null) {
        modIdLvl = ROOT;
        id = getDevIdFromRootObj(obj);
        obj = getObjFromRootObj(obj);
    } else if (id.equals(CONS_DEVICES)) {
        modIdLvl = DEVICES;
        id = ((Device) obj).deviceid();
        obj = ((Device) obj).networkInstances();
    }
    List<NetworkInstance> ins = ((NetworkInstances) obj).networkInstance();
    Iterator<NetworkInstance> it = ins.iterator();
    NetworkInstance instance;
    if (it.hasNext()) {
        instance = it.next();
    } else {
        throw new IllegalArgumentException(INS_NULL);
    }
    return getDelModObjData(modIdLvl, id, instance.name());
}
#end_block

#method_before
@Override
public Object createInstance(Object objectData) {
    if (modelRegistry == null) {
        init();
    }
    return getCreateVpnIns((ModelObjectData) objectData, isDevicesPresent());
}
#method_after
@Override
public ModelObjectData createInstance(ModelObjectData objectData) {
    if (modelRegistry == null) {
        init();
    }
    return getCreateVpnIns(objectData, isDevicesPresent());
}
#end_block

#method_before
@Override
public Object bindInterface(Object objectData) {
    return getCreateInt((ModelObjectData) objectData);
}
#method_after
@Override
public ModelObjectData bindInterface(ModelObjectData objectData) {
    return getCreateInt(objectData);
}
#end_block

#method_before
@Override
public Object createBgpInfo(Object bgpInfo, Object bgpConfig) {
    return getCreateBgp((BgpInfo) bgpInfo, (BgpDriverInfo) bgpConfig);
}
#method_after
@Override
public ModelObjectData createBgpInfo(BgpInfo bgpInfo, BgpDriverInfo bgpConfig) {
    return getCreateBgp(bgpInfo, bgpConfig);
}
#end_block

#method_before
@Override
public Object createTnlDev(Object tnlInfo) {
    return getCreateTnlDev((TunnelInfo) tnlInfo);
}
#method_after
@Override
public ModelObjectData createTnlDev(TunnelInfo tnlInfo) {
    return getCreateTnlDev(tnlInfo);
}
#end_block

#method_before
@Override
public Object createTnlPol(Object tnlInfo) {
    return getCreateTnlPol((TunnelInfo) tnlInfo);
}
#method_after
@Override
public ModelObjectData createTnlPol(TunnelInfo tnlInfo) {
    return getCreateTnlPol(tnlInfo);
}
#end_block

#method_before
@Override
public Object createTnl(Object tnlInfo) {
    return getCreateTnl((TunnelInfo) tnlInfo);
}
#method_after
@Override
public ModelObjectData createTnl(TunnelInfo tnlInfo) {
    return getCreateTnl(tnlInfo);
}
#end_block

#method_before
@Override
public Object bindTnl(Object tnlInfo) {
    return getBindTnl((TunnelInfo) tnlInfo);
}
#method_after
@Override
public ModelObjectData bindTnl(TunnelInfo tnlInfo) {
    return getBindTnl(tnlInfo);
}
#end_block

#method_before
@Override
public Object deleteInstance(Object objectData) {
    return getDeleteVpnIns((ModelObjectData) objectData);
}
#method_after
@Override
public ModelObjectData deleteInstance(ModelObjectData objectData) {
    return getDeleteVpnIns(objectData);
}
#end_block

#method_before
@Override
public Object unbindInterface(Object objectData) {
    // TODO:To be committed.
    return null;
}
#method_after
@Override
public ModelObjectData unbindInterface(ModelObjectData objectData) {
    // TODO:To be committed.
    return null;
}
#end_block

#method_before
@Override
public Object deleteTnl(Object tnlInfo) {
    return getDeleteTnl((TunnelInfo) tnlInfo);
}
#method_after
@Override
public ModelObjectData deleteTnl(TunnelInfo tnlInfo) {
    return getDeleteTnl(tnlInfo);
}
#end_block

#method_before
@Override
public Object deleteBgpInfo(Object bgpInfo, Object bgpConfig) {
    return getDeleteBgp((BgpInfo) bgpInfo, (BgpDriverInfo) bgpConfig);
}
#method_after
@Override
public ModelObjectData deleteBgpInfo(BgpInfo bgpInfo, BgpDriverInfo bgpConfig) {
    return getDeleteBgp(bgpInfo, bgpConfig);
}
#end_block

#method_before
private List<PortDescription> getPorts() {
    /*
         * Relationship between ptp-index and port number shown in Ciena Wave Server
         * CLI:
         *      ptp-index = 4 * port_number (without decimal) + decimal
         *      e.g
         *          if port_number is 5 then ptp-index = 5 * 4 + 0 = 20
         *          if port_number is 5.1 then ptp-index = 5 * 4 + 1 = 21
         *
         * Relationship between channelId and in/out port:
         *      in_port = channelId * 2
         *      out_port = channelId * 2 -1
         */
    List<PortDescription> ports = Lists.newArrayList();
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    DeviceId deviceId = handler().data().deviceId();
    HierarchicalConfiguration config = XmlConfigParser.loadXml(controller.get(deviceId, PORT_REQUEST, XML));
    List<HierarchicalConfiguration> portsConfig = parseWaveServerCienaPorts(config);
    portsConfig.forEach(sub -> {
        String portId = sub.getString(PORT_ID);
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
        String channelId = sub.getString(CHANNEL_ID);
        // any port that has channel will have in/out ports
        if (channelId != null) {
            // TX/OUT port
            annotations.set(AnnotationKeys.CHANNEL_ID, sub.getString(CHANNEL_ID));
            annotations.set(AnnotationKeys.PORT_NAME, portId + " TX");
            ports.add(parseWaveServerCienaOchPorts(sub.getLong(PORT_OUT), sub, annotations.build()));
            // RX/IN port
            annotations.set(AnnotationKeys.PORT_NAME, portId + " RX");
            annotations.set(AnnotationKeys.CHANNEL_ID, sub.getString(CHANNEL_ID));
            ports.add(parseWaveServerCienaOchPorts(sub.getLong(PORT_IN), sub, annotations.build()));
        } else if (!portId.equals("5") && !portId.equals("49")) {
            DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, portId);
            // FIXME change when all optical types have two way information methods, see jira tickets
            ports.add(oduCltPortDescription(PortNumber.portNumber(sub.getLong(PORT_ID)), sub.getString(ADMIN_STATE).equals(ENABLED), CltSignalType.CLT_100GBE, annotations.build()));
        }
    });
    return ImmutableList.copyOf(ports);
}
#method_after
private List<PortDescription> getPorts() {
    /*
         * Relationship between ptp-index and port number shown in Ciena Wave Server
         * CLI:
         *      ptp-index = 4 * port_number (without decimal) + decimal
         *      e.g
         *          if port_number is 5 then ptp-index = 5 * 4 + 0 = 20
         *          if port_number is 5.1 then ptp-index = 5 * 4 + 1 = 21
         *
         * Relationship between channelId and in/out port:
         *      in_port = channelId * 2
         *      out_port = channelId * 2 -1
         */
    List<PortDescription> ports = Lists.newArrayList();
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    DeviceId deviceId = handler().data().deviceId();
    HierarchicalConfiguration config = XmlConfigParser.loadXml(controller.get(deviceId, PORT_REQUEST, XML));
    List<HierarchicalConfiguration> portsConfig = parseWaveServerCienaPorts(config);
    portsConfig.forEach(sub -> {
        String portId = sub.getString(PORT_ID);
        DefaultAnnotations.Builder annotations = DefaultAnnotations.builder();
        if (LINESIDE_PORT_ID.contains(portId)) {
            // TX/OUT port
            annotations.set(AnnotationKeys.CHANNEL_ID, sub.getString(CHANNEL_ID));
            annotations.set(AnnotationKeys.PORT_NAME, portId + " TX");
            ports.add(parseWaveServerCienaOchPorts(sub.getLong(PORT_OUT), sub, annotations.build()));
            // RX/IN port
            annotations.set(AnnotationKeys.PORT_NAME, portId + " RX");
            annotations.set(AnnotationKeys.CHANNEL_ID, sub.getString(CHANNEL_ID));
            ports.add(parseWaveServerCienaOchPorts(sub.getLong(PORT_IN), sub, annotations.build()));
        } else if (!portId.equals("5") && !portId.equals("49")) {
            DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, portId);
            // FIXME change when all optical types have two way information methods, see jira tickets
            ports.add(oduCltPortDescription(PortNumber.portNumber(sub.getLong(PORT_ID)), sub.getString(ADMIN_STATE).equals(ENABLED), CltSignalType.CLT_100GBE, annotations.build()));
        }
    });
    return ImmutableList.copyOf(ports);
}
#end_block

#method_before
private final String generateUri(PortNumber number) {
    return String.format("ws-ptps/ptps/%s/state", number);
}
#method_after
private final String generateUri(long number) {
    return String.format("ws-ptps/ptps/%d/state", number);
}
#end_block

#method_before
private final boolean put(PortNumber number, String state) {
    String uri = generateUri(number);
    String request = generateRequest(state);
    DeviceId deviceId = handler().data().deviceId();
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    InputStream payload = new ByteArrayInputStream(request.getBytes(StandardCharsets.UTF_8));
    int response = controller.put(deviceId, uri, payload, MediaType.valueOf(APP_JSON));
    log.debug("response: {}", response);
    // expecting 204 as successful response
    return response == 204;
}
#method_after
private final boolean put(long number, String state) {
    String uri = generateUri(number);
    String request = generateRequest(state);
    DeviceId deviceId = handler().data().deviceId();
    RestSBController controller = checkNotNull(handler().get(RestSBController.class));
    InputStream payload = new ByteArrayInputStream(request.getBytes(StandardCharsets.UTF_8));
    int response = controller.put(deviceId, uri, payload, MediaType.valueOf(APP_JSON));
    log.debug("response: {}", response);
    // expecting 204/NO_CONTENT_RESPONSE as successful response
    return response == Status.NO_CONTENT.getStatusCode();
}
#end_block

#method_before
private PortNumber getLineSidePort(PortNumber number) {
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Port port = deviceService.getPort(deviceId, number);
    String channelId = port.annotations().value(AnnotationKeys.CHANNEL_ID);
    // any port that has channel will have TX and RX
    if (channelId != null) {
        String portName = port.annotations().value(AnnotationKeys.PORT_NAME);
        // last three characters of portName will always be " TX" or " RX"
        portName = portName.substring(0, portName.length() - 3);
        log.debug("port number {} is mapped to {} lineside port", number, portName);
        number = PortNumber.portNumber(portName);
    }
    return number;
}
#method_after
private Long getLineSidePort(PortNumber number) {
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Port port = deviceService.getPort(deviceId, number);
    if (port != null) {
        String channelId = port.annotations().value(AnnotationKeys.CHANNEL_ID);
        // any port that has channel is lineSidePort and will have TX and RX
        if (channelId != null) {
            String portName = port.annotations().value(AnnotationKeys.PORT_NAME);
            // last three characters of portName will always be " TX" or " RX"
            portName = portName.substring(0, portName.length() - 3);
            log.debug("port number {} is mapped to {} lineside port", number, portName);
            return new Long(portName);
        }
    }
    // not a line-side port
    return null;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> disable(PortNumber number) {
    log.debug("disabling port {}", number);
    number = getLineSidePort(number);
    put(number, DISABLE);
    CompletableFuture<Boolean> result = CompletableFuture.completedFuture(put(number, DISABLE));
    return result;
}
#method_after
@Override
public CompletableFuture<Boolean> disable(PortNumber number) {
    log.debug("disabling port {}", number);
    Long lineSidePort = getLineSidePort(number);
    long devicePortNum;
    if (lineSidePort != null) {
        devicePortNum = lineSidePort.longValue();
    } else {
        devicePortNum = number.toLong();
    }
    CompletableFuture<Boolean> result = CompletableFuture.completedFuture(put(devicePortNum, DISABLE));
    return result;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> enable(PortNumber number) {
    log.debug("enabling port {}", number);
    number = getLineSidePort(number);
    CompletableFuture<Boolean> result = CompletableFuture.completedFuture(put(number, ENABLE));
    return result;
}
#method_after
@Override
public CompletableFuture<Boolean> enable(PortNumber number) {
    log.debug("enabling port {}", number);
    Long lineSidePort = getLineSidePort(number);
    long devicePortNum;
    if (lineSidePort != null) {
        devicePortNum = lineSidePort.longValue();
    } else {
        devicePortNum = number.toLong();
    }
    CompletableFuture<Boolean> result = CompletableFuture.completedFuture(put(devicePortNum, ENABLE));
    return result;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    return null;
}
#method_after
@Override
public CompletableFuture<Boolean> isEnabled(PortNumber number) {
    return Tools.exceptionalFuture(new UnsupportedOperationException("isEnabled is not supported"));
}
#end_block

#method_before
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    if (deviceService.getDevice(deviceId).is(PortAdmin.class)) {
        Device device = deviceService.getDevice(deviceId);
        PortAdmin portAdmin = device.as(PortAdmin.class);
        CompletableFuture<Boolean> modified;
        if (enable) {
            modified = portAdmin.enable(portNumber);
        } else {
            modified = portAdmin.disable(portNumber);
        }
        modified.thenAcceptAsync(result -> {
            if (!result) {
                log.warn("Device {} port {} state can't be changed to {}", deviceId, portNumber, enable);
            }
        });
    } else {
        log.warn("Device {} does not support PortAdmin behavior", deviceId);
    }
}
#method_after
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    Device device = deviceService.getDevice(deviceId);
    if (device != null) {
        if (device.is(PortAdmin.class)) {
            PortAdmin portAdmin = device.as(PortAdmin.class);
            CompletableFuture<Boolean> modified;
            if (enable) {
                modified = portAdmin.enable(portNumber);
            } else {
                modified = portAdmin.disable(portNumber);
            }
            modified.thenAcceptAsync(result -> {
                if (!result) {
                    log.warn("Device {} port {} state can't be changed to {}", deviceId, portNumber, enable);
                }
            });
        } else {
            log.warn("Device {} does not support PortAdmin behavior", deviceId);
        }
    } else {
        log.warn("unable to get the device {}, port {} state can't be changed to {}", deviceId, portNumber, enable);
    }
}
#end_block

#method_before
private void invalidatePipeliner(DeviceId id) {
    log.info("Invalidating cached pipeline behaviour for {}", id);
    DriverHandler handler = driverHandlers.remove(id);
    Pipeliner pipeliner = pipeliners.remove(id);
    if (handler != null || pipeliner != null) {
        getAndInitDevicePipeliner(id);
    }
}
#method_after
private void invalidatePipeliner(DeviceId id) {
    log.info("Invalidating cached pipeline behaviour for {}", id);
    driverHandlers.remove(id);
    pipeliners.remove(id);
    if (deviceService.isAvailable(id)) {
        getAndInitDevicePipeliner(id);
    }
}
#end_block

#method_before
@Override
public void event(DriverEvent event) {
    // First accrue the list of all devices whose driver was affected
    String driverName = event.subject().name();
    ImmutableSet.Builder<DeviceId> toInvalidate = ImmutableSet.builder();
    driverHandlers.entrySet().stream().filter(e -> driverName.equals(e.getValue().driver().name())).forEach(e -> toInvalidate.add(e.getKey()));
    // And then invalidate their cached pipeliners handlers
    toInvalidate.build().forEach(FlowObjectiveManager.this::invalidatePipeliner);
}
#method_after
@Override
public void event(DriverEvent event) {
    String driverName = event.subject().name();
    driverHandlers.entrySet().stream().filter(e -> driverName.equals(e.getValue().driver().name())).map(Map.Entry::getKey).distinct().forEach(FlowObjectiveManager.this::invalidatePipeliner);
}
#end_block

#method_before
private void pushToAllDevices(PacketRequest request) {
    log.debug("Pushing packet request {} to all devices", request);
    for (Device device : deviceService.getDevices()) {
        // TODO properly test capability via driver, defining behaviour
        if (SUPPORTED.contains(device.id().uri().getScheme())) {
            pushRule(device, request);
        }
    }
}
#method_after
private void pushToAllDevices(PacketRequest request) {
    log.debug("Pushing packet request {} to all devices", request);
    for (Device device : deviceService.getDevices()) {
        Driver driver = driverService.getDriver(device.id());
        if (driver != null && Boolean.parseBoolean(driver.getProperty(SUPPORT_PACKET_REQUEST_PROPERTY))) {
            pushRule(device, request);
        }
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    eventHandlingExecutor.execute(() -> {
        try {
            Device device = event.subject();
            switch(event.type()) {
                case DEVICE_ADDED:
                case DEVICE_AVAILABILITY_CHANGED:
                    if (deviceService.isAvailable(event.subject().id())) {
                        pushRulesToDevice(device);
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#method_after
@Override
public void event(DeviceEvent event) {
    eventHandlingExecutor.execute(() -> {
        try {
            Device device = event.subject();
            Driver driver = driverService.getDriver(device.id());
            if (driver == null) {
                return;
            }
            if (!Boolean.parseBoolean(driver.getProperty(SUPPORT_PACKET_REQUEST_PROPERTY))) {
                return;
            }
            if (!deviceService.isAvailable(event.subject().id())) {
                return;
            }
            switch(event.type()) {
                case DEVICE_ADDED:
                case DEVICE_AVAILABILITY_CHANGED:
                    pushRulesToDevice(device);
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            log.warn("Failed to process {}", event, e);
        }
    });
}
#end_block

#method_before
@Override
public PiAction mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException {
    if (treatment.allInstructions().size() == 0) {
        // No instructions means drop for us.
        return actionWithName(DROP);
    } else if (treatment.allInstructions().size() > 1) {
        // Otherwise, we understand treatments with only 1 instruction.
        throw new PiInterpreterException("Treatment has multiple instructions");
    }
    Instruction instruction = treatment.allInstructions().get(0);
    switch(instruction.type()) {
        case OUTPUT:
            OutputInstruction outInstruction = (OutputInstruction) instruction;
            PortNumber port = outInstruction.port();
            if (!port.isLogical()) {
                PiAction.builder().withId(PiActionId.of(SET_EGRESS_PORT)).withParameter(new PiActionParam(PiActionParamId.of(PORT), ImmutableByteSequence.copyFrom(port.toLong()))).build();
            } else if (port.equals(CONTROLLER)) {
                return actionWithName(SEND_TO_CPU);
            } else {
                throw new PiInterpreterException("Egress on logical port not supported: " + port);
            }
        case NOACTION:
            return actionWithName(DROP);
        default:
            throw new PiInterpreterException("Instruction type not supported: " + instruction.type().name());
    }
}
#method_after
@Override
public PiAction mapTreatment(TrafficTreatment treatment, PiTableId piTableId) throws PiInterpreterException {
    if (treatment.allInstructions().size() == 0) {
        // No instructions means drop for us.
        return actionWithName(DROP);
    } else if (treatment.allInstructions().size() > 1) {
        // Otherwise, we understand treatments with only 1 instruction.
        throw new PiPipelineInterpreter.PiInterpreterException("Treatment has multiple instructions");
    }
    Instruction instruction = treatment.allInstructions().get(0);
    switch(instruction.type()) {
        case OUTPUT:
            Instructions.OutputInstruction outInstruction = (Instructions.OutputInstruction) instruction;
            PortNumber port = outInstruction.port();
            if (!port.isLogical()) {
                PiAction.builder().withId(PiActionId.of(SET_EGRESS_PORT)).withParameter(new PiActionParam(PiActionParamId.of(PORT), ImmutableByteSequence.copyFrom(port.toLong()))).build();
            } else if (port.equals(CONTROLLER)) {
                return actionWithName(SEND_TO_CPU);
            } else {
                throw new PiInterpreterException("Egress on logical port not supported: " + port);
            }
        case NOACTION:
            return actionWithName(DROP);
        default:
            throw new PiInterpreterException("Instruction type not supported: " + instruction.type().name());
    }
}
#end_block

#method_before
@Override
public Optional<PiHeaderFieldId> mapCriterionType(Criterion.Type type) {
    return null;
}
#method_after
@Override
public Optional<PiHeaderFieldId> mapCriterionType(Criterion.Type type) {
    return Optional.ofNullable(CRITERION_MAP.get(type));
}
#end_block

#method_before
@Override
public Optional<Criterion.Type> mapPiHeaderFieldId(PiHeaderFieldId headerFieldId) {
    return null;
}
#method_after
@Override
public Optional<Criterion.Type> mapPiHeaderFieldId(PiHeaderFieldId headerFieldId) {
    return Optional.ofNullable(CRITERION_MAP.inverse().get(headerFieldId));
}
#end_block

#method_before
@Override
public Optional<PiTableId> mapFlowRuleTableId(int flowRuleTableId) {
    return null;
}
#method_after
@Override
public Optional<PiTableId> mapFlowRuleTableId(int flowRuleTableId) {
    return Optional.ofNullable(TABLE_MAP.get(flowRuleTableId));
}
#end_block

#method_before
@Override
public Collection<PiPacketOperation> mapOutboundPacket(OutboundPacket packet) throws PiInterpreterException {
    return null;
}
#method_after
@Override
public Collection<PiPacketOperation> mapOutboundPacket(OutboundPacket packet) throws PiInterpreterException {
    TrafficTreatment treatment = packet.treatment();
    // ecmp.p4 supports only OUTPUT instructions.
    List<Instructions.OutputInstruction> outInstructions = treatment.allInstructions().stream().filter(i -> i.type().equals(OUTPUT)).map(i -> (Instructions.OutputInstruction) i).collect(toList());
    if (treatment.allInstructions().size() != outInstructions.size()) {
        // There are other instructions that are not of type OUTPUT
        throw new PiInterpreterException("Treatment not supported: " + treatment);
    }
    ImmutableList.Builder<PiPacketOperation> builder = ImmutableList.builder();
    for (Instructions.OutputInstruction outInst : outInstructions) {
        if (outInst.port().isLogical() && !outInst.port().equals(FLOOD)) {
            throw new PiInterpreterException("Logical port not supported: " + outInst.port());
        } else if (outInst.port().equals(FLOOD)) {
            // create a packet operation to send the packet out of that specific port
            for (Port port : handler().get(DeviceService.class).getPorts(packet.sendThrough())) {
                builder.add(createPiPacketOperation(packet.data(), port.number().toLong()));
            }
        } else {
            builder.add(createPiPacketOperation(packet.data(), outInst.port().toLong()));
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
public InboundPacket mapInboundPacket(DeviceId deviceId, PiPacketOperation packetInOperation) throws PiInterpreterException {
    return null;
}
#method_after
@Override
public InboundPacket mapInboundPacket(DeviceId deviceId, PiPacketOperation packetInOperation) throws PiInterpreterException {
    // We are assuming that the packet is ethernet type
    Ethernet ethPkt = new Ethernet();
    ethPkt.deserialize(packetInOperation.data().asArray(), 0, packetInOperation.data().size());
    // Returns the ingress port packet metadata
    Optional<PiPacketMetadata> packetMetadata = packetInOperation.metadatas().stream().filter(metadata -> metadata.id().name().equals(INGRESS_PORT)).findFirst();
    if (packetMetadata.isPresent()) {
        // Obtaining the ingress port as an immutable byte sequence
        ImmutableByteSequence portByteSequence = packetMetadata.get().value();
        // Converting immutableByteSequence to short
        short s = portByteSequence.asReadOnlyBuffer().getShort();
        ConnectPoint receivedFrom = new ConnectPoint(deviceId, PortNumber.portNumber(s));
        // FIXME should be optimizable with .asReadOnlyBytebuffer
        ByteBuffer rawData = ByteBuffer.wrap(packetInOperation.data().asArray());
        return new DefaultInboundPacket(receivedFrom, ethPkt, rawData);
    } else {
        throw new PiInterpreterException("Can't get packet metadata for" + INGRESS_PORT);
    }
}
#end_block

#method_before
@Override
public List<FlowRule> generateLeafRules(DeviceId leaf, Host srcHost, Collection<Host> dstHosts, Collection<DeviceId> availableSpines, Topology topo) throws FlowRuleGeneratorException {
    // Get ports which connect this leaf switch to hosts.
    Set<PortNumber> hostPorts = deviceService.getPorts(leaf).stream().filter(port -> !isFabricPort(port, topo)).map(Port::number).collect(Collectors.toSet());
    // Get ports which connect this leaf to the given available spines.
    TopologyGraph graph = topologyService.getGraph(topo);
    Set<PortNumber> fabricPorts = graph.getEdgesFrom(new DefaultTopologyVertex(leaf)).stream().filter(e -> availableSpines.contains(e.dst().deviceId())).map(e -> e.link().src().port()).collect(Collectors.toSet());
    if (hostPorts.size() != 1 || fabricPorts.size() == 0) {
        log.error("Leaf switch has invalid port configuration: hostPorts={}, fabricPorts={}", hostPorts.size(), fabricPorts.size());
        throw new FlowRuleGeneratorException();
    }
    PortNumber hostPort = hostPorts.iterator().next();
    List<FlowRule> rules = Lists.newArrayList();
    TrafficTreatment treatment;
    if (fabricPorts.size() > 1) {
        // Do ECMP.
        Pair<ExtensionTreatment, List<FlowRule>> result = provisionEcmpTreatment(leaf, fabricPorts);
        rules.addAll(result.getRight());
        ExtensionTreatment extTreatment = result.getLeft();
        treatment = DefaultTrafficTreatment.builder().extension(extTreatment, leaf).build();
    } else {
        // Output on port.
        PortNumber outPort = fabricPorts.iterator().next();
        treatment = DefaultTrafficTreatment.builder().setOutput(outPort).build();
    }
    // From srHost to dstHosts.
    for (Host dstHost : dstHosts) {
        FlowRule rule = flowRuleBuilder(leaf, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchInPort(hostPort).matchEthType(IPV4.ethType().toShort()).matchEthSrc(srcHost.mac()).matchEthDst(dstHost.mac()).build()).withTreatment(treatment).build();
        rules.add(rule);
    }
    // From fabric ports to this leaf host.
    for (PortNumber port : fabricPorts) {
        FlowRule rule = flowRuleBuilder(leaf, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchInPort(port).matchEthType(IPV4.ethType().toShort()).matchEthDst(srcHost.mac()).build()).withTreatment(DefaultTrafficTreatment.builder().setOutput(hostPort).build()).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
@Override
public List<FlowRule> generateLeafRules(DeviceId leaf, Host srcHost, Collection<Host> dstHosts, Collection<DeviceId> availableSpines, Topology topo) throws FlowRuleGeneratorException {
    // Get ports which connect this leaf switch to hosts.
    Set<PortNumber> hostPorts = deviceService.getPorts(leaf).stream().filter(port -> !isFabricPort(port, topo)).map(Port::number).collect(Collectors.toSet());
    // Get ports which connect this leaf to the given available spines.
    TopologyGraph graph = topologyService.getGraph(topo);
    Set<PortNumber> fabricPorts = graph.getEdgesFrom(new DefaultTopologyVertex(leaf)).stream().filter(e -> availableSpines.contains(e.dst().deviceId())).map(e -> e.link().src().port()).collect(Collectors.toSet());
    if (hostPorts.size() != 1 || fabricPorts.size() == 0) {
        log.error("Leaf switch has invalid port configuration: hostPorts={}, fabricPorts={}", hostPorts.size(), fabricPorts.size());
        throw new FlowRuleGeneratorException();
    }
    PortNumber hostPort = hostPorts.iterator().next();
    List<FlowRule> rules = Lists.newArrayList();
    TrafficTreatment treatment;
    if (fabricPorts.size() > 1) {
        // Do ECMP.
        Pair<PiTableAction, List<FlowRule>> result = provisionEcmpPiTableAction(leaf, fabricPorts);
        rules.addAll(result.getRight());
        treatment = DefaultTrafficTreatment.builder().piTableAction(result.getLeft()).build();
    } else {
        // Output on port.
        PortNumber outPort = fabricPorts.iterator().next();
        treatment = DefaultTrafficTreatment.builder().setOutput(outPort).build();
    }
    // From srHost to dstHosts.
    for (Host dstHost : dstHosts) {
        FlowRule rule = flowRuleBuilder(leaf, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchInPort(hostPort).matchEthType(IPV4.ethType().toShort()).matchEthSrc(srcHost.mac()).matchEthDst(dstHost.mac()).build()).withTreatment(treatment).build();
        rules.add(rule);
    }
    // From fabric ports to this leaf host.
    for (PortNumber port : fabricPorts) {
        FlowRule rule = flowRuleBuilder(leaf, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchInPort(port).matchEthType(IPV4.ethType().toShort()).matchEthDst(srcHost.mac()).build()).withTreatment(DefaultTrafficTreatment.builder().setOutput(hostPort).build()).build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
@Override
public List<FlowRule> generateSpineRules(DeviceId deviceId, Collection<Host> dstHosts, Topology topo) throws FlowRuleGeneratorException {
    List<FlowRule> rules = Lists.newArrayList();
    // for each host
    for (Host dstHost : dstHosts) {
        Set<Path> paths = topologyService.getPaths(topo, deviceId, dstHost.location().deviceId());
        if (paths.size() == 0) {
            log.warn("Can't find any path between spine {} and host {}", deviceId, dstHost);
            throw new FlowRuleGeneratorException();
        }
        TrafficTreatment treatment;
        if (paths.size() == 1) {
            // Only one path, do output on port.
            PortNumber port = paths.iterator().next().src().port();
            treatment = DefaultTrafficTreatment.builder().setOutput(port).build();
        } else {
            // Multiple paths, do ECMP.
            Set<PortNumber> portNumbers = paths.stream().map(p -> p.src().port()).collect(toSet());
            Pair<ExtensionTreatment, List<FlowRule>> result = provisionEcmpTreatment(deviceId, portNumbers);
            rules.addAll(result.getRight());
            treatment = DefaultTrafficTreatment.builder().extension(result.getLeft(), deviceId).build();
        }
        FlowRule rule = flowRuleBuilder(deviceId, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchEthType(IPV4.ethType().toShort()).matchEthDst(dstHost.mac()).build()).withTreatment(treatment).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
@Override
public List<FlowRule> generateSpineRules(DeviceId deviceId, Collection<Host> dstHosts, Topology topo) throws FlowRuleGeneratorException {
    List<FlowRule> rules = Lists.newArrayList();
    // for each host
    for (Host dstHost : dstHosts) {
        Set<Path> paths = topologyService.getPaths(topo, deviceId, dstHost.location().deviceId());
        if (paths.size() == 0) {
            log.warn("Can't find any path between spine {} and host {}", deviceId, dstHost);
            throw new FlowRuleGeneratorException();
        }
        TrafficTreatment treatment;
        if (paths.size() == 1) {
            // Only one path, do output on port.
            PortNumber port = paths.iterator().next().src().port();
            treatment = DefaultTrafficTreatment.builder().setOutput(port).build();
        } else {
            // Multiple paths, do ECMP.
            Set<PortNumber> portNumbers = paths.stream().map(p -> p.src().port()).collect(toSet());
            Pair<PiTableAction, List<FlowRule>> result = provisionEcmpPiTableAction(deviceId, portNumbers);
            rules.addAll(result.getRight());
            treatment = DefaultTrafficTreatment.builder().piTableAction(result.getLeft()).build();
        }
        FlowRule rule = flowRuleBuilder(deviceId, EcmpInterpreter.TABLE0).withSelector(DefaultTrafficSelector.builder().matchEthType(IPV4.ethType().toShort()).matchEthDst(dstHost.mac()).build()).withTreatment(treatment).build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
private void init() {
    // Reset any previous state
    synchronized (this) {
        flowRuleGenerated = Boolean.FALSE;
        leafSwitches = Sets.newHashSet();
        spineSwitches = Sets.newHashSet();
        deviceFlowRules = Maps.newConcurrentMap();
        ruleFlags = Maps.newConcurrentMap();
        contextFlags = Maps.newConcurrentMap();
    }
    // Start flow rules generator...
    spawnTask(() -> generateFlowRules(topologyService.currentTopology(), Sets.newHashSet(hostService.getHosts())));
}
#method_after
private void init() {
    // Reset any previous state
    synchronized (this) {
        flowRuleGenerated = Boolean.FALSE;
        leafSwitches = Sets.newHashSet();
        spineSwitches = Sets.newHashSet();
        deviceFlowRules = Maps.newConcurrentMap();
        ruleFlags = Maps.newConcurrentMap();
        pipeconfFlags = Maps.newConcurrentMap();
    }
    // Start flow rules generator...
    spawnTask(() -> generateFlowRules(topologyService.currentTopology(), Sets.newHashSet(hostService.getHosts())));
}
#end_block

#method_before
public void deployDevice(Device device) {
    DeviceId deviceId = device.id();
    // Synchronize executions over the same device.
    Lock lock = deviceLocks.computeIfAbsent(deviceId, k -> new ReentrantLock());
    lock.lock();
    try {
        // Set context if not already done.
        if (!contextFlags.getOrDefault(deviceId, false)) {
            log.info("Setting context to {} for {}...", configurationName, deviceId);
            piPipeconfService.bindToDevice(pipeconf.id(), deviceId);
            contextFlags.put(device.id(), true);
        }
        // Initialize device.
        if (!initDevice(deviceId)) {
            log.warn("Failed to initialize device {}", deviceId);
        }
        // Install rules.
        if (!ruleFlags.getOrDefault(deviceId, false)) {
            List<FlowRule> rules = deviceFlowRules.getOrDefault(deviceId, Collections.emptyList());
            if (rules.size() > 0) {
                log.info("Installing rules for {}...", deviceId);
                installFlowRules(rules);
                ruleFlags.put(deviceId, true);
            }
        }
    } finally {
        lock.unlock();
    }
}
#method_after
public void deployDevice(Device device) {
    DeviceId deviceId = device.id();
    // Synchronize executions over the same device.
    Lock lock = deviceLocks.computeIfAbsent(deviceId, k -> new ReentrantLock());
    lock.lock();
    try {
        // Set pipeconfflag if not already done.
        if (!pipeconfFlags.getOrDefault(deviceId, false)) {
            if (pipeconf.id().equals(piPipeconfService.ofDevice(deviceId))) {
                pipeconfFlags.put(device.id(), true);
            } else {
                log.warn("No pipeconf can be associated to the device {}.", deviceId);
            }
        }
        // Initialize device.
        if (!initDevice(deviceId)) {
            log.warn("Failed to initialize device {}", deviceId);
        }
        // Install rules.
        if (!ruleFlags.getOrDefault(deviceId, false)) {
            List<FlowRule> rules = deviceFlowRules.getOrDefault(deviceId, Collections.emptyList());
            if (rules.size() > 0) {
                log.info("Installing rules for {}...", deviceId);
                installFlowRules(rules);
                ruleFlags.put(deviceId, true);
            }
        }
    } finally {
        lock.unlock();
    }
}
#end_block

#method_before
private Highlights getBandwidth(Set<Link> links, DeviceId devId) {
    LpLinkMap linkMap = new LpLinkMap();
    if (links != null) {
        log.debug("Processing {} links", links.size());
        links.forEach(linkMap::add);
    } else {
        log.debug("No egress links found for device {}", devId);
    }
    Highlights highlights = new Highlights();
    for (LpLink dlink : linkMap.biLinks()) {
        DiscreteResourceId parent = Resources.discrete(devId, PortNumber.portNumber((int) links.iterator().next().src().port().toLong())).id();
        ContinuousResource continuousResource = (ContinuousResource) resourceQueryService.getAvailableResources(parent, Bandwidth.class).iterator().next();
        double availBandwidth = continuousResource.value();
        dlink.makeImportant().setLabel(Double.toString(availBandwidth) + " bytes/s");
        highlights.add(dlink.highlight(null));
    }
    return highlights;
}
#method_after
private Highlights getBandwidth(Set<Link> links, DeviceId devId) {
    LpLinkMap linkMap = new LpLinkMap();
    if (links != null) {
        log.debug("Processing {} links", links.size());
        links.forEach(linkMap::add);
    } else {
        log.debug("No egress links found for device {}", devId);
    }
    Highlights highlights = new Highlights();
    PortNumber portnum = PortNumber.portNumber((int) links.iterator().next().src().port().toLong());
    for (LpLink dlink : linkMap.biLinks()) {
        DiscreteResourceId parent = Resources.discrete(devId, portnum).id();
        ContinuousResource continuousResource = (ContinuousResource) resourceQueryService.getAvailableResources(parent, Bandwidth.class).iterator().next();
        double availBandwidth = continuousResource.value();
        dlink.makeImportant().setLabel(Double.toString(availBandwidth) + " bytes/s");
        highlights.add(dlink.highlight(null));
    }
    return highlights;
}
#end_block

#method_before
private String getSpeedString(Long speed) {
    if (speed > 1_000_000_000)
        return Long.toString(speed / 1_000_000_000) + "Gb/s";
    else if (speed > 1_000_000)
        return Long.toString(speed / 1_000_000) + "Mb/s";
    else if (speed > 1_000)
        return Long.toString(speed / 1_000) + "kb/s";
    else
        return Long.toString(speed) + "bytes/s";
}
#method_after
private String getSpeedString(Long speed) {
    if (speed > 1_000_000_000) {
        return Long.toString(speed / 1_000_000_000) + "Gb/s";
    } else if (speed > 1_000_000) {
        return Long.toString(speed / 1_000_000) + "Mb/s";
    } else if (speed > 1_000) {
        return Long.toString(speed / 1_000) + "kb/s";
    } else {
        return Long.toString(speed) + "bytes/s";
    }
}
#end_block

#method_before
private String getBytesString(Long bytes) {
    final long tb = (long) 1_000_000_000_000.0;
    if (bytes > tb)
        return Long.toString(bytes / tb) + "Tb";
    else if (bytes > 1_000_000_000)
        return Long.toString(bytes / 1_000_000_000) + "Gb";
    else if (bytes > 1_000_000)
        return Long.toString(bytes / 1_000_000) + "Mb";
    else if (bytes > 1_000)
        return Long.toString(bytes / 1_000) + "kb";
    else
        return Long.toString(bytes) + "bytes";
}
#method_after
private String getBytesString(Long bytes) {
    final long tb = (long) 1_000_000_000_000.0;
    if (bytes > tb) {
        return Long.toString(bytes / tb) + "Tb";
    } else if (bytes > 1_000_000_000) {
        return Long.toString(bytes / 1_000_000_000) + "Gb";
    } else if (bytes > 1_000_000) {
        return Long.toString(bytes / 1_000_000) + "Mb";
    } else if (bytes > 1_000) {
        return Long.toString(bytes / 1_000) + "kb";
    } else {
        return Long.toString(bytes) + "bytes";
    }
}
#end_block

#method_before
@Override
public void modifySummary(PropertyPanel pp) {
    pp.title(MY_TITLE).typeId(GlyphConstants.CROWN).removeProps(TOPOLOGY_SSCS, INTENTS, TUNNELS, FLOWS, VERSION).addProp(VERSION, MY_VERSION);
}
#method_after
@Override
public void modifySummary(PropertyPanel pp) {
    pp.title(MY_TITLE).glyphId(GlyphConstants.CROWN).removeProps(TOPOLOGY_SSCS, INTENTS, TUNNELS, FLOWS, VERSION).addProp(VERSION, MY_VERSION);
}
#end_block

#method_before
@Test
public void testTranslate() throws Exception {
    DeviceId deviceId = DeviceId.NONE;
    ApplicationId appId = new DefaultApplicationId(1, "test");
    int tableId = 0;
    MacAddress ethDstMac = MacAddress.valueOf(random.nextLong());
    MacAddress ethSrcMac = MacAddress.valueOf(random.nextLong());
    short ethType = (short) (0x0000FFFF & random.nextInt());
    short outPort = (short) random.nextInt(65);
    short inPort = (short) random.nextInt(65);
    int timeout = random.nextInt(100);
    int priority = random.nextInt(100);
    TrafficSelector matchInPort1 = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(inPort)).matchEthDst(ethDstMac).matchEthSrc(ethSrcMac).matchEthType(ethType).build();
    TrafficTreatment outPort2 = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(outPort)).build();
    FlowRule rule1 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    FlowRule rule2 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    PiTableEntry entry1 = PiFlowRuleTranslator.translateFlowRule(rule1, pipeconf, null);
    PiTableEntry entry2 = PiFlowRuleTranslator.translateFlowRule(rule1, pipeconf, null);
    // check equality, i.e. same rules must produce same entries
    new EqualsTester().addEqualityGroup(rule1, rule2).addEqualityGroup(entry1, entry2).testEquals();
    int numMatchParams = pipeconf.pipelineModel().table(TABLE0).get().matchFields().size();
    // parse values stored in entry1
    PiTernaryFieldMatch inPortParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(IN_PORT_ID).get();
    PiTernaryFieldMatch ethDstParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_DST_ID).get();
    PiTernaryFieldMatch ethSrcParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_SRC_ID).get();
    PiTernaryFieldMatch ethTypeParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_TYPE_ID).get();
    Optional<Double> expectedTimeout = pipeconf.pipelineModel().table(TABLE0).get().supportsAging() ? Optional.of((double) rule1.timeout()) : Optional.empty();
    // check that the number of parameters in the entry is the same as the number of table keys
    assertThat("Incorrect number of match parameters", entry1.matchKey().fieldMatches().size(), is(equalTo(numMatchParams)));
    // check that values stored in entry are the same used for the flow rule
    assertThat("Incorrect inPort match param value", inPortParam.value().asReadOnlyBuffer().getShort(), is(equalTo(inPort)));
    assertThat("Incorrect inPort match param mask", inPortParam.mask().asReadOnlyBuffer().getShort(), is(equalTo(IN_PORT_MASK)));
    assertThat("Incorrect ethDestMac match param value", ethDstParam.value().asArray(), is(equalTo(ethDstMac.toBytes())));
    assertThat("Incorrect ethDestMac match param mask", ethDstParam.mask().asArray(), is(equalTo(MacAddress.BROADCAST.toBytes())));
    assertThat("Incorrect ethSrcMac match param value", ethSrcParam.value().asArray(), is(equalTo(ethSrcMac.toBytes())));
    assertThat("Incorrect ethSrcMac match param mask", ethSrcParam.mask().asArray(), is(equalTo(MacAddress.BROADCAST.toBytes())));
    assertThat("Incorrect ethType match param value", ethTypeParam.value().asReadOnlyBuffer().getShort(), is(equalTo(ethType)));
    assertThat("Incorrect ethType match param mask", ethTypeParam.mask().asReadOnlyBuffer().getShort(), is(equalTo(ETH_TYPE_MASK)));
    assertThat("Incorrect priority value", entry1.priority().get(), is(equalTo(MAX_PRIORITY - rule1.priority())));
    assertThat("Incorrect timeout value", entry1.timeout(), is(equalTo(expectedTimeout)));
}
#method_after
@Test
public void testTranslate() throws Exception {
    DeviceId deviceId = DeviceId.NONE;
    ApplicationId appId = new DefaultApplicationId(1, "test");
    int tableId = 0;
    MacAddress ethDstMac = MacAddress.valueOf(random.nextLong());
    MacAddress ethSrcMac = MacAddress.valueOf(random.nextLong());
    short ethType = (short) (0x0000FFFF & random.nextInt());
    short outPort = (short) random.nextInt(65);
    short inPort = (short) random.nextInt(65);
    int timeout = random.nextInt(100);
    int priority = random.nextInt(100);
    TrafficSelector matchInPort1 = DefaultTrafficSelector.builder().matchInPort(PortNumber.portNumber(inPort)).matchEthDst(ethDstMac).matchEthSrc(ethSrcMac).matchEthType(ethType).build();
    TrafficTreatment outPort2 = DefaultTrafficTreatment.builder().setOutput(PortNumber.portNumber(outPort)).build();
    FlowRule rule1 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    FlowRule rule2 = DefaultFlowRule.builder().forDevice(deviceId).forTable(tableId).fromApp(appId).withSelector(matchInPort1).withTreatment(outPort2).makeTemporary(timeout).withPriority(priority).build();
    PiTableEntry entry1 = PiFlowRuleTranslator.translateFlowRule(rule1, pipeconf, null);
    PiTableEntry entry2 = PiFlowRuleTranslator.translateFlowRule(rule1, pipeconf, null);
    // check equality, i.e. same rules must produce same entries
    new EqualsTester().addEqualityGroup(rule1, rule2).addEqualityGroup(entry1, entry2).testEquals();
    int numMatchParams = pipeconf.pipelineModel().table(TABLE0).get().matchFields().size();
    // parse values stored in entry1
    PiTernaryFieldMatch inPortParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(IN_PORT_ID).get();
    PiTernaryFieldMatch ethDstParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_DST_ID).get();
    PiTernaryFieldMatch ethSrcParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_SRC_ID).get();
    PiTernaryFieldMatch ethTypeParam = (PiTernaryFieldMatch) entry1.matchKey().fieldMatch(ETH_TYPE_ID).get();
    Optional<Double> expectedTimeout = pipeconf.pipelineModel().table(TABLE0).get().supportsAging() ? Optional.of((double) rule1.timeout()) : Optional.empty();
    // check that the number of parameters in the entry is the same as the number of table keys
    assertThat("Incorrect number of match parameters", entry1.matchKey().fieldMatches().size(), is(equalTo(numMatchParams)));
    // check that values stored in entry are the same used for the flow rule
    assertThat("Incorrect inPort match param value", inPortParam.value().asReadOnlyBuffer().getShort(), is(equalTo(inPort)));
    assertThat("Incorrect inPort match param mask", inPortParam.mask().asReadOnlyBuffer().getShort(), is(equalTo(IN_PORT_MASK)));
    assertThat("Incorrect ethDestMac match param value", ethDstParam.value().asArray(), is(equalTo(ethDstMac.toBytes())));
    assertThat("Incorrect ethDestMac match param mask", ethDstParam.mask().asArray(), is(equalTo(MacAddress.BROADCAST.toBytes())));
    assertThat("Incorrect ethSrcMac match param value", ethSrcParam.value().asArray(), is(equalTo(ethSrcMac.toBytes())));
    assertThat("Incorrect ethSrcMac match param mask", ethSrcParam.mask().asArray(), is(equalTo(MacAddress.BROADCAST.toBytes())));
    assertThat("Incorrect ethType match param value", ethTypeParam.value().asReadOnlyBuffer().getShort(), is(equalTo(ethType)));
    assertThat("Incorrect ethType match param mask", ethTypeParam.mask().asReadOnlyBuffer().getShort(), is(equalTo(ETH_TYPE_MASK)));
    assertThat("Incorrect priority value", entry1.priority().get(), is(equalTo(MAX_PI_PRIORITY - rule1.priority())));
    assertThat("Incorrect timeout value", entry1.timeout(), is(equalTo(expectedTimeout)));
}
#end_block

#method_before
static PiTableEntry translateFlowRule(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiFlowRuleTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    // FIXME: get interpreter via driver once implemented.
    // final PiPipelineInterpreter interpreter = device.is(PiPipelineInterpreter.class)
    // ? device.as(PiPipelineInterpreter.class) : null;
    final PiPipelineInterpreter interpreter;
    try {
        interpreter = (PiPipelineInterpreter) pipeconf.implementation(PiPipelineInterpreter.class).orElse(null).newInstance();
    } catch (InstantiationException | IllegalAccessException e) {
        throw new PiFlowRuleTranslationException(format("Unable to instantiate interpreter of pipeconf %s", pipeconf.id()));
    }
    PiTableId piTableId;
    switch(rule.table().type()) {
        case PIPELINE_INDEPENDENT:
            piTableId = (PiTableId) rule.table();
            break;
        case INDEX:
            IndexTableId indexId = (IndexTableId) rule.table();
            if (interpreter == null) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing interpreter", indexId.id()));
            } else if (!interpreter.mapFlowRuleTableId(indexId.id()).isPresent()) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing ID in interpreter", indexId.id()));
            } else {
                piTableId = interpreter.mapFlowRuleTableId(indexId.id()).get();
            }
            break;
        default:
            throw new PiFlowRuleTranslationException(format("Unrecognized table ID type %s", rule.table().type().name()));
    }
    PiTableModel table = pipelineModel.table(piTableId.toString()).orElseThrow(() -> new PiFlowRuleTranslationException(format("Not such a table in pipeline model: %s", piTableId)));
    /* Translate selector */
    Collection<PiFieldMatch> fieldMatches = buildFieldMatches(interpreter, rule.selector(), table);
    /* Translate treatment */
    PiAction piAction = buildAction(rule.treatment(), interpreter, piTableId);
    piAction = typeCheckAction(piAction, table);
    PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    // In the P4 world 0 is the highest priority, in ONOS the lowest one.
    // FIXME: move priority conversion to the driver, where different constraints might apply
    // e.g. less bits for encoding priority in TCAM-based implementations.
    int newPriority;
    if (rule.priority() > MAX_PRIORITY) {
        log.warn("Flow rule priority too big, setting translated priority to max value {}: {}", MAX_PRIORITY, rule);
        newPriority = 0;
    } else {
        newPriority = MAX_PRIORITY - rule.priority();
    }
    tableEntryBuilder.forTable(piTableId).withPriority(newPriority).withMatchKey(PiMatchKey.builder().addFieldMatches(fieldMatches).build()).withAction(piAction);
    if (!rule.isPermanent()) {
        if (table.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", table.name());
        }
    }
    return tableEntryBuilder.build();
}
#method_after
static PiTableEntry translateFlowRule(FlowRule rule, PiPipeconf pipeconf, Device device) throws PiFlowRuleTranslationException {
    PiPipelineModel pipelineModel = pipeconf.pipelineModel();
    // Retrieve interpreter, if any.
    // FIXME: get interpreter via driver once implemented.
    // final PiPipelineInterpreter interpreter = device.is(PiPipelineInterpreter.class)
    // ? device.as(PiPipelineInterpreter.class) : null;
    final PiPipelineInterpreter interpreter;
    try {
        interpreter = (PiPipelineInterpreter) pipeconf.implementation(PiPipelineInterpreter.class).orElse(null).newInstance();
    } catch (InstantiationException | IllegalAccessException e) {
        throw new PiFlowRuleTranslationException(format("Unable to instantiate interpreter of pipeconf %s", pipeconf.id()));
    }
    PiTableId piTableId;
    switch(rule.table().type()) {
        case PIPELINE_INDEPENDENT:
            piTableId = (PiTableId) rule.table();
            break;
        case INDEX:
            IndexTableId indexId = (IndexTableId) rule.table();
            if (interpreter == null) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing interpreter", indexId.id()));
            } else if (!interpreter.mapFlowRuleTableId(indexId.id()).isPresent()) {
                throw new PiFlowRuleTranslationException(format("Unable to map table ID '%d' from index to PI: missing ID in interpreter", indexId.id()));
            } else {
                piTableId = interpreter.mapFlowRuleTableId(indexId.id()).get();
            }
            break;
        default:
            throw new PiFlowRuleTranslationException(format("Unrecognized table ID type %s", rule.table().type().name()));
    }
    PiTableModel table = pipelineModel.table(piTableId.toString()).orElseThrow(() -> new PiFlowRuleTranslationException(format("Not such a table in pipeline model: %s", piTableId)));
    /* Translate selector */
    Collection<PiFieldMatch> fieldMatches = buildFieldMatches(interpreter, rule.selector(), table);
    /* Translate treatment */
    PiAction piAction = buildAction(rule.treatment(), interpreter, piTableId);
    piAction = typeCheckAction(piAction, table);
    PiTableEntry.Builder tableEntryBuilder = PiTableEntry.builder();
    // In the P4 world 0 is the highest priority, in ONOS the lowest one.
    // FIXME: move priority conversion to the driver, where different constraints might apply
    // e.g. less bits for encoding priority in TCAM-based implementations.
    int newPriority;
    if (rule.priority() > MAX_PI_PRIORITY) {
        log.warn("Flow rule priority too big, setting translated priority to max value {}: {}", MAX_PI_PRIORITY, rule);
        newPriority = 0;
    } else {
        newPriority = MAX_PI_PRIORITY - rule.priority();
    }
    tableEntryBuilder.forTable(piTableId).withPriority(newPriority).withMatchKey(PiMatchKey.builder().addFieldMatches(fieldMatches).build()).withAction(piAction);
    if (!rule.isPermanent()) {
        if (table.supportsAging()) {
            tableEntryBuilder.withTimeout((double) rule.timeout());
        } else {
            log.warn("Flow rule is temporary, but table '{}' doesn't support " + "aging, translating to permanent.", table.name());
        }
    }
    return tableEntryBuilder.build();
}
#end_block

#method_before
private void doNext(StreamMessageResponse message) {
    try {
        log.info("Received message on stream channel from {}: {}", deviceId, message.getUpdateCase());
        switch(message.getUpdateCase()) {
            case PACKET:
                // Packet-in
                doPacketIn(message.getPacket());
                return;
            case ARBITRATION:
                doArbitrationUpdateFromDevice(message.getArbitration());
                return;
            default:
                log.warn("Unrecognized stream message from {}: {}", deviceId, message.getUpdateCase());
        }
    } catch (Throwable ex) {
        log.error("Exception while processing stream channel message from {}", deviceId, ex);
    }
}
#method_after
private void doNext(StreamMessageResponse message) {
    try {
        log.debug("Received message on stream channel from {}: {}", deviceId, message.getUpdateCase());
        switch(message.getUpdateCase()) {
            case PACKET:
                // Packet-in
                doPacketIn(message.getPacket());
                return;
            case ARBITRATION:
                doArbitrationUpdateFromDevice(message.getArbitration());
                return;
            default:
                log.warn("Unrecognized stream message from {}: {}", deviceId, message.getUpdateCase());
        }
    } catch (Throwable ex) {
        log.error("Exception while processing stream channel message from {}", deviceId, ex);
    }
}
#end_block

#method_before
private static TableEntry encodePiTableEntry(PiTableEntry piTableEntry, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableEntry.Builder tableEntryMsgBuilder = TableEntry.newBuilder();
    // FIXME this thorws some kind of NPE
    P4InfoOuterClass.Table tableInfo = browser.tables().getByName(piTableEntry.table().id());
    // Table id.
    tableEntryMsgBuilder.setTableId(tableInfo.getPreamble().getId());
    // Priority.
    // FIXME: check on P4Runtime if/what is the defaulr priority.
    int priority = piTableEntry.priority().orElse(0);
    tableEntryMsgBuilder.setPriority(priority);
    // Controller metadata (cookie)
    tableEntryMsgBuilder.setControllerMetadata(piTableEntry.cookie());
    // Timeout.
    if (piTableEntry.timeout().isPresent()) {
        log.warn("Found PI table entry with timeout set, not supported in P4Runtime: {}", piTableEntry);
    }
    // Table action.
    tableEntryMsgBuilder.setAction(encodePiTableAction(piTableEntry.action(), browser));
    // Field matches.
    for (PiFieldMatch piFieldMatch : piTableEntry.matchKey().fieldMatches()) {
        tableEntryMsgBuilder.addMatch(encodePiFieldMatch(piFieldMatch, tableInfo, browser));
    }
    return tableEntryMsgBuilder.build();
}
#method_after
private static TableEntry encodePiTableEntry(PiTableEntry piTableEntry, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    TableEntry.Builder tableEntryMsgBuilder = TableEntry.newBuilder();
    // FIXME this thorws some kind of NPE
    P4InfoOuterClass.Table tableInfo = browser.tables().getByName(piTableEntry.table().id());
    // Table id.
    tableEntryMsgBuilder.setTableId(tableInfo.getPreamble().getId());
    // Priority.
    // FIXME: check on P4Runtime if/what is the default priority.
    int priority = piTableEntry.priority().orElse(0);
    tableEntryMsgBuilder.setPriority(priority);
    // Controller metadata (cookie)
    tableEntryMsgBuilder.setControllerMetadata(piTableEntry.cookie());
    // Timeout.
    if (piTableEntry.timeout().isPresent()) {
        log.warn("Found PI table entry with timeout set, not supported in P4Runtime: {}", piTableEntry);
    }
    // Table action.
    tableEntryMsgBuilder.setAction(encodePiTableAction(piTableEntry.action(), browser));
    // Field matches.
    for (PiFieldMatch piFieldMatch : piTableEntry.matchKey().fieldMatches()) {
        tableEntryMsgBuilder.addMatch(encodePiFieldMatch(piFieldMatch, tableInfo, browser));
    }
    return tableEntryMsgBuilder.build();
}
#end_block

#method_before
public static String getIdentityRefName(YangType<?> yangType) {
    YangIdentityRef ir = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
    YangIdentity identity = ir.getReferredIdentity();
    String name = identity.getName();
    if (identity instanceof ConflictResolveNode && identity.isNameConflict()) {
        name = name + UtilConstants.IDENTITY;
    }
    return name;
}
#method_after
static String getIdentityRefName(YangType<?> yangType) {
    YangIdentityRef ir = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
    YangIdentity identity = ir.getReferredIdentity();
    String name = identity.getName();
    if (identity.isNameConflict()) {
        name = name + UtilConstants.IDENTITY;
    }
    return name;
}
#end_block

#method_before
@Test
public void processtest() throws IOException, ParserException, MojoExecutionException {
    YangIoUtils.deleteDirectory(DIR);
    String searchDir = "src/test/resources/identityTypedefSameName";
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(searchDir)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir(DIR);
    utilManager.translateToJava(yangPluginConfig);
    YangPluginConfig.compileCode(COMP);
// YangIoUtils.deleteDirectory(DIR);
}
#method_after
@Test
public void processtest() throws IOException, ParserException, MojoExecutionException {
    YangIoUtils.deleteDirectory(DIR);
    String searchDir = "src/test/resources/identityTypedefSameName";
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(searchDir)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir(DIR);
    utilManager.translateToJava(yangPluginConfig);
    YangPluginConfig.compileCode(COMP);
    YangIoUtils.deleteDirectory(DIR);
}
#end_block

#method_before
public static String getFromStringMethodForIdentity(String name, String schemaName, List<YangIdentity> idList) {
    StringBuilder builder = new StringBuilder(NEW_LINE);
    builder.append(getJavaDoc(FROM_METHOD, name, false, null));
    String caps = getCapitalCase(name);
    String returnVal = caps + PERIOD + CLASS;
    String cond = getTwoParaEqualsString(FROM_STRING_PARAM_NAME, getQuotedString(schemaName));
    builder.append(methodSignature(FROM_STRING_METHOD_NAME, null, PUBLIC + SPACE + STATIC, FROM_STRING_PARAM_NAME, CLASS_STRING, STRING_DATA_TYPE, CLASS_TYPE)).append(getIfConditionBegin(EIGHT_SPACE_INDENTATION, cond)).append(getReturnString(returnVal, TWELVE_SPACE_INDENTATION)).append(signatureClose());
    if (idList != null) {
        for (YangIdentity id : idList) {
            cond = getTwoParaEqualsString(FROM_STRING_PARAM_NAME, getQuotedString(id.getName()));
            name = getCamelCase(id.getName(), null);
            caps = getCapitalCase(name);
            returnVal = caps + PERIOD + CLASS;
            builder.append(getElseIfConditionBegin(EIGHT_SPACE_INDENTATION, cond)).append(getReturnString(returnVal, TWELVE_SPACE_INDENTATION)).append(signatureClose());
        }
    }
    builder.append(methodClose(EIGHT_SPACE)).append(getExceptionThrowString(EIGHT_SPACE_INDENTATION)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#method_after
public static String getFromStringMethodForIdentity(String name, String schemaName, List<YangIdentity> idList) {
    StringBuilder builder = new StringBuilder(NEW_LINE);
    builder.append(getJavaDoc(FROM_METHOD, name, false, null));
    String caps = getCapitalCase(name);
    String returnVal = caps + PERIOD + CLASS;
    String cond = getTwoParaEqualsString(FROM_STRING_PARAM_NAME, getQuotedString(schemaName));
    builder.append(methodSignature(FROM_STRING_METHOD_NAME, null, PUBLIC + SPACE + STATIC, FROM_STRING_PARAM_NAME, CLASS_STRING, STRING_DATA_TYPE, CLASS_TYPE)).append(getIfConditionBegin(EIGHT_SPACE_INDENTATION, cond)).append(getReturnString(returnVal, TWELVE_SPACE_INDENTATION)).append(signatureClose());
    if (idList != null) {
        for (YangIdentity id : idList) {
            cond = getTwoParaEqualsString(FROM_STRING_PARAM_NAME, getQuotedString(id.getName()));
            if (id.isNameConflict()) {
                name = getCamelCase(id.getName() + IDENTITY, null);
            } else {
                name = getCamelCase(id.getName(), null);
            }
            caps = getCapitalCase(name);
            returnVal = caps + PERIOD + CLASS;
            builder.append(getElseIfConditionBegin(EIGHT_SPACE_INDENTATION, cond)).append(getReturnString(returnVal, TWELVE_SPACE_INDENTATION)).append(signatureClose());
        }
    }
    builder.append(methodClose(EIGHT_SPACE)).append(getExceptionThrowString(EIGHT_SPACE_INDENTATION)).append(methodClose(FOUR_SPACE));
    return builder.toString();
}
#end_block

#method_before
@Override
public String getSuffix() {
    return UtilConstants.IDENTITY;
}
#method_after
@Override
public String getSuffix() {
    return IDENTITY;
}
#end_block

#method_before
@Override
public Optional<VirtualIntentProcessPhase> execute() {
    try {
        List<Intent> compiled = processor.compile(networkId, data.intent(), stored.map(IntentData::installables).orElse(null));
        return Optional.of(new VirtualIntentInstalling(networkId, processor, IntentData.compiled(data, compiled), stored));
    } catch (IntentException e) {
        log.warn("Unable to compile intent {} due to:", data.intent(), e);
        if (stored.filter(x -> !x.installables().isEmpty()).isPresent()) {
            // removing orphaned flows and deallocating resources
            return Optional.of(new VirtualIntentWithdrawing(networkId, processor, new IntentData(data, stored.get().installables())));
        } else {
            return Optional.of(new VirtualIntentFailed(data));
        }
    }
}
#method_after
@Override
public Optional<VirtualIntentProcessPhase> execute() {
    try {
        List<Intent> compiled = processor.compile(networkId, data.intent(), // TODO consider passing an optional here in the future
        stored.map(IntentData::installables).orElse(null));
        return Optional.of(new VirtualIntentInstalling(networkId, processor, IntentData.compiled(data, compiled), stored));
    } catch (IntentException e) {
        log.warn("Unable to compile intent {} due to:", data.intent(), e);
        if (stored.filter(x -> !x.installables().isEmpty()).isPresent()) {
            // removing orphaned flows and deallocating resources
            return Optional.of(new VirtualIntentWithdrawing(networkId, processor, new IntentData(data, stored.get().installables())));
        } else {
            return Optional.of(new VirtualIntentFailed(data));
        }
    }
}
#end_block

#method_before
private void finish(IntentInstallationContext intentInstallationContext) {
    Set<IntentOperationContext> errCtxs = intentInstallationContext.errorContexts();
    Optional<IntentData> toUninstall = intentInstallationContext.toUninstall();
    Optional<IntentData> toInstall = intentInstallationContext.toInstall();
    // Intent install success
    if (errCtxs == null || errCtxs.isEmpty()) {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}", installData.key());
            installData = new IntentData(installData, installData.installables());
            installData.setState(INSTALLED);
            intentStore.write(networId, installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData = new IntentData(uninstallData, Collections.emptyList());
            log.debug("Completed withdrawing: {}", uninstallData.key());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    log.warn("{} was requested to withdraw during installation?", uninstallData.intent());
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            intentStore.write(networId, uninstallData);
        }
    } else {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            installData.setState(CORRUPT);
            installData.incrementErrorCount();
            intentStore.write(networId, installData);
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData.setState(CORRUPT);
            uninstallData.incrementErrorCount();
            intentStore.write(networId, uninstallData);
        }
    }
}
#method_after
private void finish(IntentInstallationContext intentInstallationContext) {
    Set<IntentOperationContext> errCtxs = intentInstallationContext.errorContexts();
    Optional<IntentData> toUninstall = intentInstallationContext.toUninstall();
    Optional<IntentData> toInstall = intentInstallationContext.toInstall();
    // Intent install success
    if (errCtxs == null || errCtxs.isEmpty()) {
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            log.debug("Completed installing: {}", installData.key());
            installData = new IntentData(installData, installData.installables());
            installData.setState(INSTALLED);
            intentStore.write(networkId, installData);
        } else if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData = new IntentData(uninstallData, Collections.emptyList());
            log.debug("Completed withdrawing: {}", uninstallData.key());
            switch(uninstallData.request()) {
                case INSTALL_REQ:
                    log.warn("{} was requested to withdraw during installation?", uninstallData.intent());
                    uninstallData.setState(FAILED);
                    break;
                case WITHDRAW_REQ:
                default:
                    // TODO "default" case should not happen
                    uninstallData.setState(WITHDRAWN);
                    break;
            }
            // Intent has been withdrawn; we can clear the installables
            intentStore.write(networkId, uninstallData);
        }
    } else {
        // if toInstall was cause of error, then recompile (manage/increment counter, when exceeded -> CORRUPT)
        if (toInstall.isPresent()) {
            IntentData installData = toInstall.get();
            installData.setState(CORRUPT);
            installData.incrementErrorCount();
            intentStore.write(networkId, installData);
        }
        // if toUninstall was cause of error, then CORRUPT (another job will clean this up)
        if (toUninstall.isPresent()) {
            IntentData uninstallData = toUninstall.get();
            uninstallData.setState(CORRUPT);
            uninstallData.incrementErrorCount();
            intentStore.write(networkId, uninstallData);
        }
    }
}
#end_block

#method_before
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.type())) {
        return new Ofdpa3SetMplsType();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.type())) {
        return new Ofdpa3SetOvid();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.type())) {
        return new Ofdpa3SetMplsL2Port();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.type())) {
        return new Ofdpa3SetQosIndex();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.type())) {
        return new Ofdpa3PushL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.type())) {
        return new Ofdpa3PushCw();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.type())) {
        return new Ofdpa3PopL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.type())) {
        return new Ofdpa3PopCw();
    }
    throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
}
#method_after
@Override
public ExtensionTreatment getExtensionInstruction(ExtensionTreatmentType type) {
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.type())) {
        return new Ofdpa3SetMplsType();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.type())) {
        return new Ofdpa3SetOvid();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.type())) {
        return new Ofdpa3SetMplsL2Port();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.type())) {
        return new Ofdpa3SetQosIndex();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.type())) {
        return new Ofdpa3PushL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.type())) {
        return new Ofdpa3PushCw();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.type())) {
        return new Ofdpa3PopL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.type())) {
        return new Ofdpa3PopCw();
    }
    throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE + type.toString());
}
#end_block

#method_before
@Override
public ObjectNode encode(ExtensionTreatment extensionTreatment, CodecContext context) {
    checkNotNull(extensionTreatment, "Extension treatment cannot be null");
    ExtensionTreatmentType type = extensionTreatment.type();
    ObjectNode root = context.mapper().createObjectNode();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.type())) {
        Ofdpa3SetMplsType setMplsType = (Ofdpa3SetMplsType) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.name());
        root.setAll(context.codec(Ofdpa3SetMplsType.class).encode(setMplsType, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.type())) {
        Ofdpa3SetOvid setOvid = (Ofdpa3SetOvid) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.name());
        root.setAll(context.codec(Ofdpa3SetOvid.class).encode(setOvid, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.type())) {
        Ofdpa3SetMplsL2Port setMplsL2Port = (Ofdpa3SetMplsL2Port) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.name());
        root.setAll(context.codec(Ofdpa3SetMplsL2Port.class).encode(setMplsL2Port, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.type())) {
        Ofdpa3SetQosIndex setQosIndex = (Ofdpa3SetQosIndex) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.name());
        root.setAll(context.codec(Ofdpa3SetQosIndex.class).encode(setQosIndex, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.name());
    }
    return root;
}
#method_after
@Override
public ObjectNode encode(ExtensionTreatment extensionTreatment, CodecContext context) {
    checkNotNull(extensionTreatment, MISSING_TREATMENT_MESSAGE);
    ExtensionTreatmentType type = extensionTreatment.type();
    ObjectNode root = context.mapper().createObjectNode();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.type())) {
        Ofdpa3SetMplsType setMplsType = (Ofdpa3SetMplsType) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.name());
        root.setAll(context.codec(Ofdpa3SetMplsType.class).encode(setMplsType, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.type())) {
        Ofdpa3SetOvid setOvid = (Ofdpa3SetOvid) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.name());
        root.setAll(context.codec(Ofdpa3SetOvid.class).encode(setOvid, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.type())) {
        Ofdpa3SetMplsL2Port setMplsL2Port = (Ofdpa3SetMplsL2Port) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.name());
        root.setAll(context.codec(Ofdpa3SetMplsL2Port.class).encode(setMplsL2Port, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.type())) {
        Ofdpa3SetQosIndex setQosIndex = (Ofdpa3SetQosIndex) extensionTreatment;
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.name());
        root.setAll(context.codec(Ofdpa3SetQosIndex.class).encode(setQosIndex, context));
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.name());
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.type())) {
        root.put(TYPE, ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.name());
    }
    return root;
}
#end_block

#method_before
@Override
public ExtensionTreatment decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.name())) {
        return context.codec(Ofdpa3SetMplsType.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.name())) {
        return context.codec(Ofdpa3SetOvid.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.name())) {
        return context.codec(Ofdpa3SetMplsL2Port.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.name())) {
        return context.codec(Ofdpa3SetQosIndex.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.name())) {
        return new Ofdpa3PushL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.name())) {
        return new Ofdpa3PushCw();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.name())) {
        return new Ofdpa3PopL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.name())) {
        return new Ofdpa3PopCw();
    } else {
        throw new UnsupportedOperationException("Driver does not support extension type " + type.toString());
    }
}
#method_after
@Override
public ExtensionTreatment decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_TYPE.name())) {
        return context.codec(Ofdpa3SetMplsType.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_OVID.name())) {
        return context.codec(Ofdpa3SetOvid.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_MPLS_L2_PORT.name())) {
        return context.codec(Ofdpa3SetMplsL2Port.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_SET_QOS_INDEX.name())) {
        return context.codec(Ofdpa3SetQosIndex.class).decode(json, context);
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_L2_HEADER.name())) {
        return new Ofdpa3PushL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_PUSH_CW.name())) {
        return new Ofdpa3PushCw();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_L2_HEADER.name())) {
        return new Ofdpa3PopL2Header();
    } else if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.OFDPA_POP_CW.name())) {
        return new Ofdpa3PopCw();
    } else {
        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE + type.toString());
    }
}
#end_block

#method_before
@Override
public ObjectNode encode(ExtensionSelector extensionSelector, CodecContext context) {
    // TODO
    return null;
}
#method_after
@Override
public ObjectNode encode(ExtensionSelector extensionSelector, CodecContext context) {
    // TODO
    log.warn("The encode method of Ofdpa3ExtensionSelectorInterpreter hasn't been implemented");
    return null;
}
#end_block

#method_before
@Override
public ExtensionSelector decode(ObjectNode json, CodecContext context) {
    // TODO
    return null;
}
#method_after
@Override
public ExtensionSelector decode(ObjectNode json, CodecContext context) {
    // TODO
    log.warn("The decode method of Ofdpa3ExtensionSelectorInterpreter hasn't been implemented");
    return null;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("relatedflows/{appId}/{key}")
public Response getIntentFlowsById(@PathParam("appId") String appId, @PathParam("key") String key) {
    ApplicationId applicationId = get(CoreService.class).getAppId(appId);
    nullIsNotFound(applicationId, APP_ID_NOT_FOUND);
    IntentService intentService = get(IntentService.class);
    FlowRuleService flowService = get(FlowRuleService.class);
    Intent intent = intentService.getIntent(Key.of(key, applicationId));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = intentService.getIntent(Key.of(numericalKey, applicationId));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    ObjectNode root = mapper().createObjectNode();
    root.put(APP_ID, appId);
    root.put(ID, key);
    IntentFilter intentFilter = new IntentFilter(intentService, flowService);
    List<Intent> installables = intentService.getInstallableIntents(intent.key());
    if (intent instanceof HostToHostIntent) {
        root.put(INTENT_TYPE, HOST_TO_HOST_INTENT);
    } else if (intent instanceof PointToPointIntent) {
        root.put(INTENT_TYPE, POINT_TO_POINT_INTENT);
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        root.put(INTENT_TYPE, SINGLE_TO_MULTI_POINT_INTENT);
    } else {
        root.put(INTENT_TYPE, INTENT);
    }
    ArrayNode pathsNode = root.putArray(INTENT_PATHS);
    for (List<FlowEntry> flowEntries : intentFilter.readIntentFlows(installables)) {
        ArrayNode flowNode = pathsNode.addArray();
        for (FlowEntry entry : flowEntries) {
            flowNode.add(codec(FlowEntry.class).encode(entry, this));
        }
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("relatedflows/{appId}/{key}")
public Response getIntentFlowsById(@PathParam("appId") String appId, @PathParam("key") String key) {
    ApplicationId applicationId = get(CoreService.class).getAppId(appId);
    nullIsNotFound(applicationId, APP_ID_NOT_FOUND);
    IntentService intentService = get(IntentService.class);
    FlowRuleService flowService = get(FlowRuleService.class);
    Intent intent = intentService.getIntent(Key.of(key, applicationId));
    if (intent == null) {
        long numericalKey = Long.decode(key);
        intent = intentService.getIntent(Key.of(numericalKey, applicationId));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    ObjectNode root = mapper().createObjectNode();
    root.put(APP_ID, appId);
    root.put(ID, key);
    IntentFilter intentFilter = new IntentFilter(intentService, flowService);
    List<Intent> installables = intentService.getInstallableIntents(intent.key());
    if (intent instanceof HostToHostIntent) {
        root.put(INTENT_TYPE, HOST_TO_HOST_INTENT);
    } else if (intent instanceof PointToPointIntent) {
        root.put(INTENT_TYPE, POINT_TO_POINT_INTENT);
    } else if (intent instanceof SinglePointToMultiPointIntent) {
        root.put(INTENT_TYPE, SINGLE_TO_MULTI_POINT_INTENT);
    } else if (intent instanceof MultiPointToSinglePointIntent) {
        root.put(INTENT_TYPE, MULTI_TO_SINGLE_POINT_INTENT);
    } else {
        root.put(INTENT_TYPE, INTENT);
    }
    ArrayNode pathsNode = root.putArray(INTENT_PATHS);
    for (List<FlowEntry> flowEntries : intentFilter.readIntentFlows(installables)) {
        ArrayNode flowNode = pathsNode.addArray();
        for (FlowEntry entry : flowEntries) {
            flowNode.add(codec(FlowEntry.class).encode(entry, this));
        }
    }
    return ok(root).build();
}
#end_block

#method_before
@Override
public ObjectNode encode(MultiPointToSinglePointIntent intent, CodecContext context) {
    checkNotNull(intent, "Multi Point to Single Point intent cannot be null");
    final JsonCodec<ConnectivityIntent> connectivityIntentCodec = context.codec(ConnectivityIntent.class);
    final ObjectNode result = connectivityIntentCodec.encode(intent, context);
    final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
    final ObjectNode egress = connectPointCodec.encode(intent.egressPoint(), context);
    final ObjectNode result2 = context.mapper().createObjectNode();
    final ArrayNode jsonconnectPoints = result2.putArray(CP_POINTS);
    if (intent.ingressPoints() != null) {
        for (final ConnectPoint cp : intent.ingressPoints()) {
            if (cp.toString().equals(egress.toString())) {
                continue;
            } else {
                jsonconnectPoints.add(connectPointCodec.encode(cp, context));
            }
        }
        result.set(INGRESS_POINT, jsonconnectPoints);
    }
    result.set(EGRESS_POINT, egress);
    return result;
}
#method_after
@Override
public ObjectNode encode(MultiPointToSinglePointIntent intent, CodecContext context) {
    checkNotNull(intent, "Multi Point to Single Point intent cannot be null");
    final JsonCodec<ConnectivityIntent> connectivityIntentCodec = context.codec(ConnectivityIntent.class);
    final ObjectNode result = connectivityIntentCodec.encode(intent, context);
    final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
    final ObjectNode egress = connectPointCodec.encode(intent.egressPoint(), context);
    // Check ingress are not null and not contain egress
    ObjectNode objectCP = context.mapper().createObjectNode();
    ArrayNode jsonconnectPoints = objectCP.putArray(CP_POINTS);
    if (intent.ingressPoints() != null) {
        for (final ConnectPoint cp : intent.ingressPoints()) {
            jsonconnectPoints.add(connectPointCodec.encode(cp, context));
        }
        result.set(INGRESS_POINT, jsonconnectPoints);
    }
    result.set(EGRESS_POINT, egress);
    return result;
}
#end_block

#method_before
public void processInterFileLinking(Set<YangNode> yangNodeSet) throws LinkerException {
    List<YangNode> yangNodeSortedList = new LinkedList<>();
    yangNodeSortedList.addAll(yangNodeSet);
    sort(yangNodeSortedList);
    for (YangNode yangNode : yangNodeSortedList) {
        try {
            YangReferenceResolver resolver = ((YangReferenceResolver) yangNode);
            resolver.resolveInterFileLinking(YANG_IF_FEATURE);
            resolver.resolveInterFileLinking(YANG_USES);
            resolver.resolveInterFileLinking(YANG_AUGMENT);
            resolver.resolveInterFileLinking(YANG_USES_AUGMENT);
            resolver.resolveInterFileLinking(YANG_DERIVED_DATA_TYPE);
            resolver.resolveInterFileLinking(YANG_BASE);
            resolver.resolveInterFileLinking(YANG_IDENTITYREF);
            resolver.resolveInterFileLinking(YANG_LEAFREF);
            resolver.resolveInterFileLinking(YANG_COMPILER_ANNOTATION);
            resolver.resolveInterFileLinking(YANG_DEVIATION);
        } catch (DataModelException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " in " + yangNode.getFileName() + " at " + "line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getLocalizedMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        } catch (LinkerException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " in " + yangNode.getFileName() + " at " + "line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getLocalizedMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        }
    }
}
#method_after
public void processInterFileLinking(Set<YangNode> yangNodeSet) throws LinkerException {
    List<YangNode> yangNodeSortedList = new LinkedList<>();
    yangNodeSortedList.addAll(yangNodeSet);
    sort(yangNodeSortedList);
    for (YangNode yangNode : yangNodeSortedList) {
        try {
            YangReferenceResolver resolver = ((YangReferenceResolver) yangNode);
            resolver.resolveInterFileLinking(YANG_IF_FEATURE);
            resolver.resolveInterFileLinking(YANG_USES);
            resolver.resolveInterFileLinking(YANG_USES_AUGMENT);
            resolver.resolveInterFileLinking(YANG_AUGMENT);
            resolver.resolveInterFileLinking(YANG_DERIVED_DATA_TYPE);
            resolver.resolveInterFileLinking(YANG_BASE);
            resolver.resolveInterFileLinking(YANG_IDENTITYREF);
            resolver.resolveInterFileLinking(YANG_LEAFREF);
            resolver.resolveInterFileLinking(YANG_COMPILER_ANNOTATION);
            resolver.resolveInterFileLinking(YANG_DEVIATION);
        } catch (DataModelException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " in " + yangNode.getFileName() + " at " + "line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getLocalizedMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        } catch (LinkerException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " in " + yangNode.getFileName() + " at " + "line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getLocalizedMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        }
    }
}
#end_block

#method_before
private static List<YangAtomicPath> validateDesSchemaNode(String val, String prefix, ParserRuleContext ctx, YangConstructType type) {
    List<YangAtomicPath> pathList = new LinkedList<>();
    String[] path = val.split(SLASH_FOR_STRING);
    for (String uniVal : path) {
        YangAtomicPath atomicPath = new YangAtomicPath();
        YangNodeIdentifier id = getValidNodeIdentifier(uniVal, type, ctx);
        atomicPath.setNodeIdentifier(id);
        pathList.add(atomicPath);
        if (id.getPrefix() != null && !id.getPrefix().equals(prefix)) {
            ParserException exc = new ParserException(E_LEAF_REF);
            exc.setLine(ctx.getStart().getLine());
            exc.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw exc;
        }
    }
    return pathList;
}
#method_after
private static List<YangAtomicPath> validateDesSchemaNode(String val, String prefix, ParserRuleContext ctx, YangConstructType type) {
    if (val.startsWith(SLASH_FOR_STRING)) {
        ParserException exc = new ParserException(E_DES_FORMAT);
        exc.setLine(ctx.getStart().getLine());
        exc.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw exc;
    }
    List<YangAtomicPath> pathList = new LinkedList<>();
    String[] path = val.split(SLASH_FOR_STRING);
    for (String uniVal : path) {
        YangAtomicPath atomicPath = new YangAtomicPath();
        YangNodeIdentifier id = getValidNodeIdentifier(uniVal, type, ctx);
        atomicPath.setNodeIdentifier(id);
        pathList.add(atomicPath);
        if (id.getPrefix() != null && !id.getPrefix().equals(prefix)) {
            ParserException exc = new ParserException(E_DES_NODE);
            exc.setLine(ctx.getStart().getLine());
            exc.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw exc;
        }
    }
    return pathList;
}
#end_block

#method_before
public static void translate(YangNode rootNode, YangPluginConfig yangPlugin, boolean codeGen) throws TranslatorException, IOException {
    YangNode codeGenNode = rootNode;
    TraversalType curTraversal = ROOT;
    while (codeGenNode != null) {
        if (curTraversal != PARENT) {
            if (!(codeGenNode instanceof JavaCodeGenerator)) {
                throw new TranslatorException("Unsupported node to generate code " + codeGenNode.getName() + " in " + codeGenNode.getLineNumber() + " at " + codeGenNode.getCharPosition() + " in " + codeGenNode.getFileName());
            }
            try {
                if (!(codeGenNode instanceof YangUses) || !((YangUses) codeGenNode).isCloned()) {
                    if (codeGen) {
                        generateCodeEntry(codeGenNode, yangPlugin, rootNode);
                    } else {
                        // this will update java file info for the target
                        // node.
                        updateJavaInfo(codeGenNode, yangPlugin);
                        if (codeGenNode instanceof YangNotification) {
                            // to know in generated code what was the enum
                            // name generated for current notification
                            String enumName = getEnumJavaAttribute(codeGenNode.getName().toUpperCase());
                            ((RpcNotificationContainer) codeGenNode.getParent()).addToNotificationEnumMap(enumName, codeGenNode);
                        }
                    }
                    if (!(codeGenNode instanceof YangUses)) {
                        codeGenNode.setNameSpaceAndAddToParentSchemaMap();
                        if (codeGenNode instanceof YangLeavesHolder || codeGenNode instanceof SchemaDataNode) {
                            codeGenNode.setParentContext();
                        }
                    }
                } else {
                    if (((YangUses) codeGenNode).isCloned()) {
                        setUsesAugNsAddToParent((YangUses) codeGenNode);
                    }
                    // handle uses ,its java info is not required.
                    if (codeGenNode.getNextSibling() != null) {
                        curTraversal = SIBLING;
                        codeGenNode = codeGenNode.getNextSibling();
                    } else {
                        curTraversal = PARENT;
                        codeGenNode = codeGenNode.getParent();
                    }
                    continue;
                }
            } catch (InvalidNodeForTranslatorException e) {
                if (codeGenNode.getNextSibling() != null) {
                    curTraversal = SIBLING;
                    codeGenNode = codeGenNode.getNextSibling();
                } else {
                    curTraversal = PARENT;
                    codeGenNode = codeGenNode.getParent();
                }
                continue;
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                throw new TranslatorException(e.getMessage());
            }
        }
        if (curTraversal != PARENT && codeGenNode.getChild() != null) {
            curTraversal = CHILD;
            codeGenNode = codeGenNode.getChild();
        } else if (codeGenNode.getNextSibling() != null) {
            try {
                if (codeGen) {
                    generateCodeExit(codeGenNode, yangPlugin, rootNode);
                }
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = SIBLING;
            codeGenNode = codeGenNode.getNextSibling();
        } else {
            try {
                if (codeGen) {
                    generateCodeExit(codeGenNode, yangPlugin, rootNode);
                }
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = PARENT;
            codeGenNode = codeGenNode.getParent();
        }
    }
}
#method_after
public static void translate(YangNode rootNode, YangPluginConfig yangPlugin, boolean codeGen) throws TranslatorException, IOException {
    YangNode codeGenNode = rootNode;
    TraversalType curTraversal = ROOT;
    while (codeGenNode != null) {
        if (curTraversal != PARENT) {
            if (!(codeGenNode instanceof JavaCodeGenerator)) {
                throw new TranslatorException("Unsupported node to generate code " + codeGenNode.getName() + " in " + codeGenNode.getLineNumber() + " at " + codeGenNode.getCharPosition() + " in " + codeGenNode.getFileName());
            }
            try {
                if (!(codeGenNode instanceof YangUses) || !((YangUses) codeGenNode).isCloned()) {
                    if (codeGen) {
                        generateCodeEntry(codeGenNode, yangPlugin, rootNode);
                    } else {
                        // this will update java file info for the target
                        // node.
                        updateJavaInfo(codeGenNode, yangPlugin);
                        if (codeGenNode instanceof YangNotification) {
                            // to know in generated code what was the enum
                            // name generated for current notification
                            String enumName = getEnumJavaAttribute(codeGenNode.getName().toUpperCase());
                            ((RpcNotificationContainer) codeGenNode.getParent()).addToNotificationEnumMap(enumName, codeGenNode);
                        }
                    }
                    if (!(codeGenNode instanceof YangUses)) {
                        codeGenNode.setNameSpaceAndAddToParentSchemaMap();
                        if (codeGenNode instanceof YangLeavesHolder || codeGenNode instanceof SchemaDataNode) {
                            codeGenNode.setParentContext();
                        }
                    }
                } else {
                    if (((YangUses) codeGenNode).isCloned()) {
                        setUsesAugNsAddToParent((YangUses) codeGenNode);
                    }
                    // handle uses ,its java info is not required.
                    if (codeGenNode.getNextSibling() != null) {
                        curTraversal = SIBLING;
                        codeGenNode = codeGenNode.getNextSibling();
                    } else {
                        curTraversal = PARENT;
                        codeGenNode = codeGenNode.getParent();
                    }
                    continue;
                }
            } catch (InvalidNodeForTranslatorException e) {
                if (codeGenNode.getNextSibling() != null) {
                    curTraversal = SIBLING;
                    codeGenNode = codeGenNode.getNextSibling();
                } else {
                    curTraversal = PARENT;
                    codeGenNode = codeGenNode.getParent();
                }
                continue;
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                throw new TranslatorException(e.getMessage());
            }
        }
        if (curTraversal != PARENT && codeGenNode.getChild() != null) {
            curTraversal = CHILD;
            codeGenNode = codeGenNode.getChild();
        } else if (codeGenNode.getNextSibling() != null) {
            try {
                if (codeGen) {
                    generateCodeExit(codeGenNode, yangPlugin, rootNode);
                }
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                Throwables.propagateIfInstanceOf(e, TranslatorException.class);
                throw new TranslatorException(e);
            }
            curTraversal = SIBLING;
            codeGenNode = codeGenNode.getNextSibling();
        } else {
            try {
                if (codeGen) {
                    generateCodeExit(codeGenNode, yangPlugin, rootNode);
                }
            } catch (Exception e) {
                e.printStackTrace();
                close(codeGenNode, yangPlugin, rootNode);
                Throwables.propagateIfInstanceOf(e, TranslatorException.class);
                throw new TranslatorException(e);
            }
            curTraversal = PARENT;
            codeGenNode = codeGenNode.getParent();
        }
    }
}
#end_block

#method_before
public ParameterValuesBuilder intValue(final List<IntValue> value) {
    this.intValue = value;
    return this;
}
#method_after
public ParameterValuesBuilder intValue(List<IntValue> value) {
    this.intValue = value;
    return this;
}
#end_block

#method_before
public ParameterValuesBuilder rangeValue(final RangeValue value) {
    this.rangeValue = value;
    return this;
}
#method_after
public ParameterValuesBuilder rangeValue(RangeValue value) {
    this.rangeValue = value;
    return this;
}
#end_block

#method_before
public ParameterValuesBuilder stringValue(final List<StringValue> value) {
    this.stringValue = value;
    return this;
}
#method_after
public ParameterValuesBuilder stringValue(List<StringValue> value) {
    this.stringValue = value;
    return this;
}
#end_block

#method_before
public ParameterValuesBuilder addAugmentation(Class<? extends ParameterValues> augmentationType, ParameterValues augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    if (!(this.augmentation instanceof HashMap)) {
        this.augmentation = new HashMap<>();
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#method_after
public ParameterValuesBuilder addAugmentation(Class<? extends ParameterValues> augmentationType, ParameterValues augmentation) {
    if (augmentation == null) {
        return removeAugmentation(augmentationType);
    }
    this.augmentation.put(augmentationType, augmentation);
    return this;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ParameterValues other = (ParameterValues) obj;
    if (!Objects.equals(intValue, other.getIntValue())) {
        return false;
    }
    if (!Objects.equals(rangeValue, other.getRangeValue())) {
        return false;
    }
    if (!Objects.equals(stringValue, other.getStringValue())) {
        return false;
    }
    // Simple case: we are comparing against self
    ParameterValuesImpl otherImpl = (ParameterValuesImpl) obj;
    if (!Objects.equals(augmentation, otherImpl.augmentation)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    ParameterValues other = (ParameterValues) obj;
    ParameterValuesImpl otherImpl = (ParameterValuesImpl) obj;
    return Objects.equals(intValue, other.getIntValues()) && Objects.equals(rangeValue, other.getRangeValues()) && Objects.equals(stringValue, other.getStringValues()) && Objects.equals(augmentation, otherImpl.augmentation);
}
#end_block

#method_before
public PropertyDefinitionBuilder isReadOnly(PropertyDefinition.IsReadOnly readOnly) {
    isReadOnly = readOnly;
    return this;
}
#method_after
public PropertyDefinitionBuilder isReadOnly(PropertyDefinition.Access readOnly) {
    isReadOnly = readOnly;
    return this;
}
#end_block

#method_before
@Override
public IsReadOnly getIsReadOnly() {
    return isReadOnly;
}
#method_after
@Override
public Access getIsReadOnly() {
    return isReadOnly;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PropertyDefinition other = (PropertyDefinition) obj;
    if (!Objects.equals(isReadOnly, other.getIsReadOnly())) {
        return false;
    }
    if (!Objects.equals(isRequired, other.getIsRequired())) {
        return false;
    }
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(propertyName, other.getPropertyName())) {
        return false;
    }
    if (!Objects.equals(propertyValueType, other.getPropertyValueType())) {
        return false;
    }
    PropertyDefinitionImpl otherImpl = (PropertyDefinitionImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PropertyDefinitionImpl o = (PropertyDefinitionImpl) obj;
    return Objects.equals(isReadOnly, o.isReadOnly) && Objects.equals(isRequired, o.isRequired) && Objects.equals(key, o.key) && Objects.equals(propertyName, o.propertyName) && Objects.equals(propertyValueType, o.propertyValueType) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("propertyName", propertyName).add("propertyValueType", propertyValueType).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("isReadOnly", isReadOnly).add("isRequired", isRequired).add("key", key).add("propertyName", propertyName).add("propertyValueType", propertyValueType).add("augmentation", augmentation).toString();
}
#end_block

#method_before
public NodeDefinitionBuilder propertyDefinition(List<PropertyDefinition> definition) {
    propertyDefinition = definition;
    return this;
}
#method_after
public NodeDefinitionBuilder propertyDefinition(List<PropertyDefinition> definition) {
    propDefs = definition;
    return this;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(key, nodeType, propertyDefinition, augmentation);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(key, nodeType, propertyDefinitions, augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeDefinition other = (NodeDefinition) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(nodeType, other.getNodeType())) {
        return false;
    }
    if (!Objects.equals(propertyDefinition, other.getPropertyDefinition())) {
        return false;
    }
    NodeDefinitionImpl otherImpl = (NodeDefinitionImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    NodeDefinition other = (NodeDefinition) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(nodeType, other.getNodeType())) {
        return false;
    }
    if (!Objects.equals(propertyDefinitions, other.getPropertyDefinitions())) {
        return false;
    }
    NodeDefinitionImpl otherImpl = (NodeDefinitionImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("nodeType", nodeType).add("propertyDefinition", propertyDefinition).add("augmentation", augmentation).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("key", key).add("nodeType", nodeType).add("propertyDefinition", propertyDefinitions).add("augmentation", augmentation).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValueKey other = (IntValueKey) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    return Objects.equals(order, other.order);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValueKey o = (IntValueKey) obj;
    return value == o.value && order == o.order;
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("order", order).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("value", value).add("order", order).toString();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Property other = (Property) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(propertyName, other.getPropertyName())) {
        return false;
    }
    if (!Objects.equals(propertyValues, other.getPropertyValues())) {
        return false;
    }
    PropertyImpl otherImpl = (PropertyImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PropertyImpl o = (PropertyImpl) obj;
    return Objects.equals(key, o.key) && Objects.equals(propertyName, o.propertyName) && Objects.equals(propertyValues, o.propertyValues) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValue other = (IntValue) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    if (!Objects.equals(value, other.getValue())) {
        return false;
    }
    IntValueImpl otherImpl = (IntValueImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    IntValueImpl o = (IntValueImpl) obj;
    return Objects.equals(key, o.key) && Objects.equals(order, o.order) && Objects.equals(value, o.value) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    RangeValue other = (RangeValue) obj;
    if (!Objects.equals(max, other.getMax())) {
        return false;
    }
    if (!Objects.equals(min, other.getMin())) {
        return false;
    }
    RangeValueImpl otherImpl = (RangeValueImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    RangeValueImpl o = (RangeValueImpl) obj;
    return Objects.equals(max, o.max) && Objects.equals(min, o.min) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    SubNode other = (SubNode) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(nodeId, other.getNodeId())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    SubNodeImpl otherImpl = (SubNodeImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    SubNodeImpl o = (SubNodeImpl) obj;
    return Objects.equals(key, o.key) && Objects.equals(nodeId, o.nodeId) && Objects.equals(order, o.order) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PropertyValues other = (PropertyValues) obj;
    if (!Objects.equals(intValue, other.getIntValue())) {
        return false;
    }
    if (!Objects.equals(rangeValue, other.getRangeValue())) {
        return false;
    }
    if (!Objects.equals(stringValue, other.getStringValue())) {
        return false;
    }
    PropertyValuesImpl otherImpl = (PropertyValuesImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    PropertyValuesImpl o = (PropertyValuesImpl) obj;
    return Objects.equals(intValue, o.intValue) && Objects.equals(rangeValue, o.rangeValue) && Objects.equals(stringValue, o.stringValue) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValue other = (StringValue) obj;
    if (!Objects.equals(key, other.getKey())) {
        return false;
    }
    if (!Objects.equals(order, other.getOrder())) {
        return false;
    }
    if (!Objects.equals(value, other.getValue())) {
        return false;
    }
    StringValueImpl otherImpl = (StringValueImpl) obj;
    return Objects.equals(augmentation, otherImpl.augmentation);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValueImpl o = (StringValueImpl) obj;
    return Objects.equals(key, o.key) && Objects.equals(order, o.order) && Objects.equals(value, o.value) && Objects.equals(augmentation, o.augmentation);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValueKey other = (StringValueKey) obj;
    if (!Objects.equals(value, other.value)) {
        return false;
    }
    return Objects.equals(order, other.order);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StringValueKey o = (StringValueKey) obj;
    return Objects.equals(value, o.value) && Objects.equals(order, o.order);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("order", order).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("value", value).add("order", order).toString();
}
#end_block

#method_before
private void addToPendingAudit(GroupDescription groupDesc) {
    GroupId groupId = dummyGroupId;
    Integer groupIdVal = groupDesc.givenGroupId();
    if (groupIdVal != null) {
        groupId = new GroupId(groupIdVal);
    }
    addToPendingKeyTable(new DefaultGroup(groupId, groupDesc));
}
#method_after
private void addToPendingAudit(GroupDescription groupDesc) {
    Integer groupIdVal = groupDesc.givenGroupId();
    GroupId groupId = (groupIdVal != null) ? new GroupId(groupIdVal) : dummyGroupId;
    addToPendingKeyTable(new DefaultGroup(groupId, groupDesc));
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    instancePortService.addListener(instancePortListener);
    securityGroupService.addListener(securityGroupListener);
    openstackService.addListener(portListener);
    nodeService.addListener(osNodeListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    localNodeId = clusterService.getLocalNode().id();
    instancePortService.addListener(instancePortListener);
    securityGroupService.addListener(securityGroupListener);
    osNetService.addListener(portListener);
    configService.registerProperties(getClass());
    osNodeService.addListener(osNodeListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    instancePortService.removeListener(instancePortListener);
    securityGroupService.removeListener(securityGroupListener);
    openstackService.removeListener(portListener);
    nodeService.removeListener(osNodeListener);
    eventExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    instancePortService.removeListener(instancePortListener);
    securityGroupService.removeListener(securityGroupListener);
    osNetService.removeListener(portListener);
    configService.unregisterProperties(getClass(), false);
    osNodeService.removeListener(osNodeListener);
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void initializeConnTrackTable(DeviceId deviceId) {
    // table=1,ip,ct_state=-trk, actions=ct(table:2)
    long ctState = RulePopulatorUtil.computeCtStateFlag(false, false, false);
    long ctMask = RulePopulatorUtil.computeCtMaskFlag(true, false, false);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, (short) GOTO_CONNTRACK_TABLE, ACTION_NONE, PRIORITY_CT_HOOK_RULE, true);
    // table=2,ip,nw_dst=10.10.0.2,ct_state=+trk+est,action=goto_table:3
    ctState = RulePopulatorUtil.computeCtStateFlag(true, false, true);
    ctMask = RulePopulatorUtil.computeCtMaskFlag(true, false, true);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, CT_NO_RECIRC, GOTO_JUMP_TABLE, PRIORITY_CT_RULE, true);
    // table=2,ip,nw_dst=10.10.0.2,ct_state=+trk+new,action=drop
    ctState = RulePopulatorUtil.computeCtStateFlag(true, true, false);
    ctMask = RulePopulatorUtil.computeCtMaskFlag(true, true, false);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, CT_NO_RECIRC, ACTION_DROP, PRIORITY_CT_DROP_RULE, true);
}
#method_after
private void initializeConnTrackTable(DeviceId deviceId, boolean install) {
    // table=1,ip,ct_state=-trk, actions=ct(table:2)
    long ctState = RulePopulatorUtil.computeCtStateFlag(false, false, false);
    long ctMask = RulePopulatorUtil.computeCtMaskFlag(true, false, false);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, (short) GOTO_CONNTRACK_TABLE, ACTION_NONE, PRIORITY_CT_HOOK_RULE, install);
    // table=2,ip,nw_dst=10.10.0.2,ct_state=+trk+est,action=goto_table:3
    ctState = RulePopulatorUtil.computeCtStateFlag(true, false, true);
    ctMask = RulePopulatorUtil.computeCtMaskFlag(true, false, true);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, CT_NO_RECIRC, GOTO_JUMP_TABLE, PRIORITY_CT_RULE, install);
    // table=2,ip,nw_dst=10.10.0.2,ct_state=+trk+new,action=drop
    ctState = RulePopulatorUtil.computeCtStateFlag(true, true, false);
    ctMask = RulePopulatorUtil.computeCtMaskFlag(true, true, false);
    setConnTrackRule(deviceId, ctState, ctMask, CT_NO_COMMIT, CT_NO_RECIRC, ACTION_DROP, PRIORITY_CT_DROP_RULE, install);
}
#end_block

#method_before
private void setSecurityGroupRules(InstancePort instPort, Port port, boolean install) {
    port.getSecurityGroups().forEach(sgId -> {
        log.debug("security group rule ID : " + sgId.toString());
        SecurityGroup sg = securityGroupService.securityGroup(sgId);
        if (sg == null) {
            log.error("Security Group Not Found : {}", sgId);
            return;
        }
        sg.getRules().forEach(sgRule -> updateSecurityGroupRule(instPort, port, sgRule, install));
    });
}
#method_after
private void setSecurityGroupRules(InstancePort instPort, Port port, boolean install) {
    port.getSecurityGroups().forEach(sgId -> {
        SecurityGroup sg = securityGroupService.securityGroup(sgId);
        if (sg == null) {
            log.error("Security Group Not Found : {}", sgId);
            return;
        }
        sg.getRules().forEach(sgRule -> updateSecurityGroupRule(instPort, port, sgRule, install));
        final String action = install ? "Installed " : "Removed ";
        log.debug(action + "security group rule ID : " + sgId);
    });
}
#end_block

#method_before
private void populateSecurityGroupRule(SecurityGroupRule sgRule, InstancePort instPort, IpPrefix remoteIp, boolean install) {
    ForwardingObjective.Builder foBuilder = buildFlowObjective(sgRule, Ip4Address.valueOf(instPort.ipAddress().toInetAddress()), remoteIp);
    if (foBuilder == null) {
        return;
    }
    if (install) {
        flowObjectiveService.forward(instPort.deviceId(), foBuilder.add());
    } else {
        flowObjectiveService.forward(instPort.deviceId(), foBuilder.remove());
    }
}
#method_after
private void populateSecurityGroupRule(SecurityGroupRule sgRule, InstancePort instPort, IpPrefix remoteIp, boolean install) {
    Set<TrafficSelector> selectors = buildSelectors(sgRule, Ip4Address.valueOf(instPort.ipAddress().toInetAddress()), remoteIp);
    if (selectors == null || selectors.isEmpty()) {
        return;
    }
    selectors.forEach(selector -> {
        osFlowRuleService.setRule(appId, instPort.deviceId(), selector, DefaultTrafficTreatment.builder().transition(JUMP_TABLE).build(), PRIORITY_ACL_RULE, ACL_TABLE, install);
    });
}
#end_block

#method_before
private void setConnTrackRule(DeviceId deviceId, long ctState, long ctMask, int commit, short recircTable, int action, int priority, boolean install) {
    ExtensionSelector esCtSate = RulePopulatorUtil.buildCtExtensionSelector(driverService, deviceId, ctState, ctMask);
    TrafficSelector selector = DefaultTrafficSelector.builder().extension(esCtSate, deviceId).matchEthType(Ethernet.TYPE_IPV4).build();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (commit == CT_COMMIT || recircTable > 0) {
        RulePopulatorUtil.NiriraConnTrackTreatmentBuilder natTreatmentBuilder = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId);
        natTreatmentBuilder.natAction(false);
        if (commit == CT_COMMIT) {
            natTreatmentBuilder.commit(true);
        } else {
            natTreatmentBuilder.commit(false);
        }
        if (recircTable > 0) {
            natTreatmentBuilder.table(recircTable);
        }
        tb.extension(natTreatmentBuilder.build(), deviceId);
    } else if (action == ACTION_DROP) {
        tb.drop();
    }
    if (action != ACTION_NONE) {
        tb.transition(action);
    }
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, tb.build(), ForwardingObjective.Flag.SPECIFIC, priority, install);
}
#method_after
private void setConnTrackRule(DeviceId deviceId, long ctState, long ctMask, int commit, short recircTable, int action, int priority, boolean install) {
    ExtensionSelector esCtSate = RulePopulatorUtil.buildCtExtensionSelector(driverService, deviceId, ctState, ctMask);
    TrafficSelector selector = DefaultTrafficSelector.builder().extension(esCtSate, deviceId).matchEthType(Ethernet.TYPE_IPV4).build();
    TrafficTreatment.Builder tb = DefaultTrafficTreatment.builder();
    if (commit == CT_COMMIT || recircTable > 0) {
        RulePopulatorUtil.NiriraConnTrackTreatmentBuilder natTreatmentBuilder = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId);
        natTreatmentBuilder.natAction(false);
        if (commit == CT_COMMIT) {
            natTreatmentBuilder.commit(true);
        } else {
            natTreatmentBuilder.commit(false);
        }
        if (recircTable > 0) {
            natTreatmentBuilder.table(recircTable);
        }
        tb.extension(natTreatmentBuilder.build(), deviceId);
    } else if (action == ACTION_DROP) {
        tb.drop();
    }
    if (action != ACTION_NONE) {
        tb.transition(action);
    }
    int tableType = ERROR_TABLE;
    if (priority == PRIORITY_CT_RULE || priority == PRIORITY_CT_DROP_RULE) {
        tableType = CT_TABLE;
    } else if (priority == PRIORITY_CT_HOOK_RULE) {
        tableType = ACL_TABLE;
    } else {
        log.error("Cannot an appropriate table for the conn track rule.");
    }
    osFlowRuleService.setRule(appId, deviceId, selector, tb.build(), priority, tableType, install);
}
#end_block

#method_before
private Set<InstancePort> getRemoteInstPorts(String tenantId, String sgId) {
    Set<InstancePort> remoteInstPorts;
    remoteInstPorts = openstackService.ports().stream().filter(port -> port.getTenantId().equals(tenantId)).filter(port -> port.getSecurityGroups().contains(sgId)).map(port -> instancePortService.instancePort(port.getId())).filter(instPort -> instPort != null && instPort.ipAddress() != null).collect(Collectors.toSet());
    return Collections.unmodifiableSet(remoteInstPorts);
}
#method_after
private Set<InstancePort> getRemoteInstPorts(String tenantId, String sgId) {
    Set<InstancePort> remoteInstPorts;
    remoteInstPorts = osNetService.ports().stream().filter(port -> port.getTenantId().equals(tenantId)).filter(port -> port.getSecurityGroups().contains(sgId)).map(port -> instancePortService.instancePort(port.getId())).filter(instPort -> instPort != null && instPort.ipAddress() != null).collect(Collectors.toSet());
    return Collections.unmodifiableSet(remoteInstPorts);
}
#end_block

#method_before
private void buildMatchs(TrafficSelector.Builder sBuilder, SecurityGroupRule sgRule, Ip4Address vmIp, IpPrefix remoteIp) {
    buildMatchEthType(sBuilder, sgRule.getEtherType());
    buildMatchDirection(sBuilder, sgRule.getDirection(), vmIp);
    buildMatchProto(sBuilder, sgRule.getProtocol());
    buildMatchPort(sBuilder, sgRule.getProtocol(), sgRule.getDirection(), sgRule.getPortRangeMax() == null ? 0 : sgRule.getPortRangeMax(), sgRule.getPortRangeMin() == null ? 0 : sgRule.getPortRangeMin());
    buildMatchRemoteIp(sBuilder, remoteIp, sgRule.getDirection());
    if (sgRule.getRemoteGroupId() != null && sgRule.getRemoteGroupId().isEmpty()) {
        buildMatchRemoteIp(sBuilder, remoteIp, sgRule.getDirection());
    }
}
#method_after
private void buildMatchs(TrafficSelector.Builder sBuilder, SecurityGroupRule sgRule, Ip4Address vmIp, IpPrefix remoteIp) {
    buildMatchEthType(sBuilder, sgRule.getEtherType());
    buildMatchDirection(sBuilder, sgRule.getDirection(), vmIp);
    buildMatchProto(sBuilder, sgRule.getProtocol());
    buildMatchPort(sBuilder, sgRule.getProtocol(), sgRule.getDirection(), sgRule.getPortRangeMin() == null ? 0 : sgRule.getPortRangeMin(), sgRule.getPortRangeMax() == null ? 0 : sgRule.getPortRangeMax());
    buildMatchRemoteIp(sBuilder, remoteIp, sgRule.getDirection());
    if (sgRule.getRemoteGroupId() != null && sgRule.getRemoteGroupId().isEmpty()) {
        buildMatchRemoteIp(sBuilder, remoteIp, sgRule.getDirection());
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    return mastershipService.isLocalMaster(instPort.deviceId());
}
#method_after
@Override
public boolean isRelevant(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    if (!useSecurityGroup) {
        return false;
    }
    return mastershipService.isLocalMaster(instPort.deviceId());
}
#end_block

#method_before
@Override
public void event(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    switch(event.type()) {
        case OPENSTACK_INSTANCE_PORT_UPDATED:
        case OPENSTACK_INSTANCE_PORT_DETECTED:
            eventExecutor.execute(() -> {
                log.info("Instance port detected MAC:{} IP:{}", instPort.macAddress(), instPort.ipAddress());
                instPortDetected(event.subject(), openstackService.port(event.subject().portId()));
            });
            break;
        case OPENSTACK_INSTANCE_PORT_VANISHED:
            eventExecutor.execute(() -> {
                log.info("Instance port vanished MAC:{} IP:{}", instPort.macAddress(), instPort.ipAddress());
                instPortRemoved(event.subject(), openstackService.port(event.subject().portId()));
            });
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(InstancePortEvent event) {
    InstancePort instPort = event.subject();
    switch(event.type()) {
        case OPENSTACK_INSTANCE_PORT_UPDATED:
        case OPENSTACK_INSTANCE_PORT_DETECTED:
            log.debug("Instance port detected MAC:{} IP:{}", instPort.macAddress(), instPort.ipAddress());
            eventExecutor.execute(() -> {
                setSecurityGroupRules(instPort, osNetService.port(event.subject().portId()), true);
            });
            break;
        case OPENSTACK_INSTANCE_PORT_VANISHED:
            log.debug("Instance port vanished MAC:{} IP:{}", instPort.macAddress(), instPort.ipAddress());
            eventExecutor.execute(() -> {
                setSecurityGroupRules(instPort, osNetService.port(event.subject().portId()), false);
            });
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(OpenstackNetworkEvent event) {
    Port osPort = event.port();
    if (osPort == null) {
        return false;
    }
    return !Strings.isNullOrEmpty(osPort.getId());
}
#method_after
@Override
public boolean isRelevant(OpenstackNetworkEvent event) {
    if (event.port() == null || !Strings.isNullOrEmpty(event.port().getId())) {
        return false;
    }
    if (event.securityGroupId() == null || securityGroupService.securityGroup(event.securityGroupId()) == null) {
        return false;
    }
    if (instancePortService.instancePort(event.port().getId()) == null) {
        return false;
    }
    if (!useSecurityGroup) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void event(OpenstackNetworkEvent event) {
    switch(event.type()) {
        case OPENSTACK_SECURITY_GROUP_ADDED_TO_PORT:
            securityGroupAddedToPort(event.securityGroupRuleIds(), event.port());
            break;
        case OPENSTACK_SECURITY_GROUP_REMOVED_FROM_PORT:
            securityGroupRemovedFromPort(event.securityGroupRuleIds(), event.port());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNetworkEvent event) {
    Port osPort = event.port();
    InstancePort instPort = instancePortService.instancePort(osPort.getId());
    SecurityGroup osSg = securityGroupService.securityGroup(event.securityGroupId());
    switch(event.type()) {
        case OPENSTACK_PORT_SECURITY_GROUP_ADDED:
            eventExecutor.execute(() -> {
                osSg.getRules().forEach(sgRule -> {
                    updateSecurityGroupRule(instPort, osPort, sgRule, true);
                });
                log.info("Added security group {} to port {}", event.securityGroupId(), event.port().getId());
            });
            break;
        case OPENSTACK_PORT_SECURITY_GROUP_REMOVED:
            eventExecutor.execute(() -> {
                osSg.getRules().forEach(sgRule -> {
                    updateSecurityGroupRule(instPort, osPort, sgRule, false);
                });
                log.info("Removed security group {} from port {}", event.securityGroupId(), event.port().getId());
            });
            break;
        default:
            // do nothing for the other events
            break;
    }
}
#end_block

#method_before
@Override
public void event(OpenstackSecurityGroupEvent event) {
    switch(event.type()) {
        case OPENSTACK_SECURITY_GROUP_CREATED:
        case OPENSTACK_SECURITY_GROUP_REMOVED:
            break;
        case OPENSTACK_SECURITY_GROUP_RULE_CREATED:
            SecurityGroupRule securityGroupRuleToAdd = event.securityGroupRule();
            eventExecutor.execute(() -> {
                log.info("Security group rule detected: ID {}", securityGroupRuleToAdd.getId());
                securityGroupRuleAdded(securityGroupRuleToAdd);
            });
            break;
        case OPENSTACK_SECURITY_GROUP_RULE_REMOVED:
            SecurityGroupRule securityGroupRuleToRemove = event.securityGroupRule();
            eventExecutor.execute(() -> {
                log.info("security gorup rule removed: ID {}", securityGroupRuleToRemove.getId());
                securityGroupRuleRemoved(securityGroupRuleToRemove);
            });
            break;
        default:
    }
}
#method_after
@Override
public void event(OpenstackSecurityGroupEvent event) {
    switch(event.type()) {
        case OPENSTACK_SECURITY_GROUP_RULE_CREATED:
            SecurityGroupRule securityGroupRuleToAdd = event.securityGroupRule();
            eventExecutor.execute(() -> {
                securityGroupRuleAdded(securityGroupRuleToAdd);
                log.info("Applied new security group rule {} to ports", securityGroupRuleToAdd.getId());
            });
            break;
        case OPENSTACK_SECURITY_GROUP_RULE_REMOVED:
            SecurityGroupRule securityGroupRuleToRemove = event.securityGroupRule();
            eventExecutor.execute(() -> {
                securityGroupRuleRemoved(securityGroupRuleToRemove);
                log.info("Removed security group rule {} from ports", securityGroupRuleToRemove.getId());
            });
            break;
        case OPENSTACK_SECURITY_GROUP_CREATED:
        case OPENSTACK_SECURITY_GROUP_REMOVED:
        default:
            // do nothing
            break;
    }
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
            if (isRelevant(event)) {
                eventExecutor.execute(() -> {
                    try {
                        initializeConnTrackTable(osNode.intBridge());
                        log.warn("SG table initialization : {} is done", osNode.ovsdbId());
                    } catch (IllegalArgumentException e) {
                        log.error("ACL table initialization error : {}", e.getMessage());
                    }
                });
            }
            break;
        case INIT:
        case DEVICE_CREATED:
        case INCOMPLETE:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
            eventExecutor.execute(() -> {
                try {
                    if (useSecurityGroup) {
                        initializeConnTrackTable(osNode.intgBridge(), true);
                        log.warn("SG table initialization : {} is done", osNode.intgBridge());
                    }
                } catch (IllegalArgumentException e) {
                    log.error("ACL table initialization error : {}", e.getMessage());
                }
            });
            break;
        case OPENSTACK_NODE_CREATED:
        case OPENSTACK_NODE_REMOVED:
        case OPENSTACK_NODE_UPDATED:
        case OPENSTACK_NODE_INCOMPLETE:
        default:
            break;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    instancePortService.addListener(instancePortListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(OPENSTACK_NETWORKING_APP_ID);
    instancePortService.addListener(instancePortListener);
    osNetworkService.addListener(osNetworkListener);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    instancePortService.removeListener(instancePortListener);
    eventExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    instancePortService.removeListener(instancePortListener);
    osNetworkService.removeListener(osNetworkListener);
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void setNetworkRules(InstancePort instPort, boolean install) {
    setTunnelTagFlowRules(instPort, install);
    setForwardingRules(instPort, install);
}
#method_after
private void setNetworkRules(InstancePort instPort, boolean install) {
    switch(osNetworkService.network(instPort.networkId()).getNetworkType()) {
        case VXLAN:
            setTunnelTagFlowRules(instPort, install);
            setForwardingRules(instPort, install);
            break;
        case VLAN:
            setVlanTagFlowRules(instPort, install);
            setForwardingRulesForVlan(instPort, install);
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, instPort.deviceId(), selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_SWITCHING_RULE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> !osNode.intBridge().equals(instPort.deviceId())).forEach(osNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, osNode.intBridge(), osNodeService.dataIp(instPort.deviceId()).get().getIp4Address()), osNode.intBridge()).setOutput(osNodeService.tunnelPort(osNode.intBridge()).get()).build();
        RulePopulatorUtil.setRule(flowObjectiveService, appId, osNode.intBridge(), selector, treatmentToRemote, ForwardingObjective.Flag.SPECIFIC, PRIORITY_SWITCHING_RULE, install);
    });
}
#method_after
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    OpenstackNode localNode = osNodeService.node(instPort.deviceId());
    if (localNode == null) {
        final String error = String.format("Cannot find openstack node for %s", instPort.deviceId());
        throw new IllegalStateException(error);
    }
    osNodeService.completeNodes(COMPUTE).stream().filter(remoteNode -> !remoteNode.intgBridge().equals(localNode.intgBridge())).forEach(remoteNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, remoteNode.intgBridge(), localNode.dataIp().getIp4Address()), remoteNode.intgBridge()).setOutput(remoteNode.tunnelPortNum()).build();
        osFlowRuleService.setRule(appId, remoteNode.intgBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#end_block

#method_before
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    // XXX All egress traffic needs to go through connection tracking module, which might hurt its performance.
    ExtensionTreatment ctTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, instPort.deviceId()).commit(true).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).extension(ctTreatment, instPort.deviceId()).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, instPort.deviceId(), selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_TUNNEL_TAG_RULE, install);
}
#method_after
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    // XXX All egress traffic needs to go through connection tracking module, which might hurt its performance.
    ExtensionTreatment ctTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, instPort.deviceId()).commit(true).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).transition(ACL_TABLE).extension(ctTreatment, instPort.deviceId()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
@Override
public ObjectNode encode(Intent intent, CodecContext context) {
    checkNotNull(intent, "Intent cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put(TYPE, intent.getClass().getSimpleName()).put(ID, intent.id().toString()).put(APP_ID, UrlEscapers.urlPathSegmentEscaper().escape(intent.appId().name()));
    if (intent.resourceGroup() != null) {
        result.put(RESOURCE_GROUP, intent.resourceGroup().toString());
    }
    final ArrayNode jsonResources = result.putArray(RESOURCES);
    for (final NetworkResource resource : intent.resources()) {
        jsonResources.add(resource.toString());
    }
    IntentService service = context.getService(IntentService.class);
    IntentState state = service.getIntentState(intent.key());
    if (state != null) {
        result.put(STATE, state.toString());
    }
    return result;
}
#method_after
@Override
public ObjectNode encode(Intent intent, CodecContext context) {
    checkNotNull(intent, "Intent cannot be null");
    final ObjectNode result = context.mapper().createObjectNode().put(TYPE, intent.getClass().getSimpleName()).put(ID, intent.id().toString()).put(APP_ID, UrlEscapers.urlPathSegmentEscaper().escape(intent.appId().name()));
    if (intent.resourceGroup() != null) {
        result.put(RESOURCE_GROUP, intent.resourceGroup().toString());
    }
    final ArrayNode jsonResources = result.putArray(RESOURCES);
    intent.resources().forEach(resource -> {
        if (resource instanceof Link) {
            jsonResources.add(context.codec(Link.class).encode((Link) resource, context));
        } else {
            jsonResources.add(resource.toString());
        }
    });
    IntentService service = context.getService(IntentService.class);
    IntentState state = service.getIntentState(intent.key());
    if (state != null) {
        result.put(STATE, state.toString());
    }
    return result;
}
#end_block

#method_before
@Activate
public void activate() {
    codecs.clear();
    registerCodec(Application.class, new ApplicationCodec());
    registerCodec(ApplicationId.class, new ApplicationIdCodec());
    registerCodec(ControllerNode.class, new ControllerNodeCodec());
    registerCodec(Annotations.class, new AnnotationsCodec());
    registerCodec(Device.class, new DeviceCodec());
    registerCodec(Port.class, new PortCodec());
    registerCodec(ConnectPoint.class, new ConnectPointCodec());
    registerCodec(Link.class, new LinkCodec());
    registerCodec(Host.class, new HostCodec());
    registerCodec(HostLocation.class, new HostLocationCodec());
    registerCodec(HostToHostIntent.class, new HostToHostIntentCodec());
    registerCodec(PointToPointIntent.class, new PointToPointIntentCodec());
    registerCodec(SinglePointToMultiPointIntent.class, new SinglePointToMultiPointIntentCodec());
    registerCodec(MultiPointToSinglePointIntent.class, new MultiPointToSinglePointIntentCodec());
    registerCodec(Intent.class, new IntentCodec());
    registerCodec(ConnectivityIntent.class, new ConnectivityIntentCodec());
    registerCodec(FlowEntry.class, new FlowEntryCodec());
    registerCodec(FlowRule.class, new FlowRuleCodec());
    registerCodec(TrafficTreatment.class, new TrafficTreatmentCodec());
    registerCodec(TrafficSelector.class, new TrafficSelectorCodec());
    registerCodec(Instruction.class, new InstructionCodec());
    registerCodec(Criterion.class, new CriterionCodec());
    registerCodec(Ethernet.class, new EthernetCodec());
    registerCodec(Constraint.class, new ConstraintCodec());
    registerCodec(Topology.class, new TopologyCodec());
    registerCodec(TopologyCluster.class, new TopologyClusterCodec());
    registerCodec(Path.class, new PathCodec());
    registerCodec(DisjointPath.class, new DisjointPathCodec());
    registerCodec(Group.class, new GroupCodec());
    registerCodec(Driver.class, new DriverCodec());
    registerCodec(GroupBucket.class, new GroupBucketCodec());
    registerCodec(Load.class, new LoadCodec());
    registerCodec(MeterRequest.class, new MeterRequestCodec());
    registerCodec(Meter.class, new MeterCodec());
    registerCodec(Band.class, new MeterBandCodec());
    registerCodec(TableStatisticsEntry.class, new TableStatisticsEntryCodec());
    registerCodec(PortStatistics.class, new PortStatisticsCodec());
    registerCodec(Metric.class, new MetricCodec());
    registerCodec(FilteringObjective.class, new FilteringObjectiveCodec());
    registerCodec(ForwardingObjective.class, new ForwardingObjectiveCodec());
    registerCodec(NextObjective.class, new NextObjectiveCodec());
    registerCodec(McastRoute.class, new McastRouteCodec());
    registerCodec(DeviceKey.class, new DeviceKeyCodec());
    registerCodec(Region.class, new RegionCodec());
    registerCodec(TenantId.class, new TenantIdCodec());
    registerCodec(VirtualNetwork.class, new VirtualNetworkCodec());
    registerCodec(VirtualDevice.class, new VirtualDeviceCodec());
    registerCodec(VirtualPort.class, new VirtualPortCodec());
    registerCodec(VirtualLink.class, new VirtualLinkCodec());
    registerCodec(VirtualHost.class, new VirtualHostCodec());
    registerCodec(MastershipTerm.class, new MastershipTermCodec());
    registerCodec(MastershipRole.class, new MastershipRoleCodec());
    registerCodec(RoleInfo.class, new RoleInfoCodec());
    registerCodec(DpiStatistics.class, new DpiStatisticsCodec());
    registerCodec(DpiStatInfo.class, new DpiStatInfoCodec());
    registerCodec(TrafficStatInfo.class, new TrafficStatInfoCodec());
    registerCodec(ProtocolStatInfo.class, new ProtocolStatInfoCodec());
    registerCodec(FlowStatInfo.class, new FlowStatInfoCodec());
    registerCodec(FilteredConnectPoint.class, new FilteredConnectPointCodec());
    registerCodec(TransportEndpointDescription.class, new TransportEndpointDescriptionCodec());
    registerCodec(PacketRequest.class, new PacketRequestCodec());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    codecs.clear();
    registerCodec(Application.class, new ApplicationCodec());
    registerCodec(ApplicationId.class, new ApplicationIdCodec());
    registerCodec(ControllerNode.class, new ControllerNodeCodec());
    registerCodec(Annotations.class, new AnnotationsCodec());
    registerCodec(Device.class, new DeviceCodec());
    registerCodec(Port.class, new PortCodec());
    registerCodec(ConnectPoint.class, new ConnectPointCodec());
    registerCodec(Link.class, new LinkCodec());
    registerCodec(Host.class, new HostCodec());
    registerCodec(HostLocation.class, new HostLocationCodec());
    registerCodec(HostToHostIntent.class, new HostToHostIntentCodec());
    registerCodec(IntentMiniSummary.class, new IntentMiniSummaryCodec());
    registerCodec(PointToPointIntent.class, new PointToPointIntentCodec());
    registerCodec(SinglePointToMultiPointIntent.class, new SinglePointToMultiPointIntentCodec());
    registerCodec(MultiPointToSinglePointIntent.class, new MultiPointToSinglePointIntentCodec());
    registerCodec(Intent.class, new IntentCodec());
    registerCodec(ConnectivityIntent.class, new ConnectivityIntentCodec());
    registerCodec(FlowEntry.class, new FlowEntryCodec());
    registerCodec(FlowRule.class, new FlowRuleCodec());
    registerCodec(TrafficTreatment.class, new TrafficTreatmentCodec());
    registerCodec(TrafficSelector.class, new TrafficSelectorCodec());
    registerCodec(Instruction.class, new InstructionCodec());
    registerCodec(Criterion.class, new CriterionCodec());
    registerCodec(Ethernet.class, new EthernetCodec());
    registerCodec(Constraint.class, new ConstraintCodec());
    registerCodec(Topology.class, new TopologyCodec());
    registerCodec(TopologyCluster.class, new TopologyClusterCodec());
    registerCodec(Path.class, new PathCodec());
    registerCodec(DisjointPath.class, new DisjointPathCodec());
    registerCodec(Group.class, new GroupCodec());
    registerCodec(Driver.class, new DriverCodec());
    registerCodec(GroupBucket.class, new GroupBucketCodec());
    registerCodec(Load.class, new LoadCodec());
    registerCodec(MeterRequest.class, new MeterRequestCodec());
    registerCodec(Meter.class, new MeterCodec());
    registerCodec(Band.class, new MeterBandCodec());
    registerCodec(TableStatisticsEntry.class, new TableStatisticsEntryCodec());
    registerCodec(PortStatistics.class, new PortStatisticsCodec());
    registerCodec(Metric.class, new MetricCodec());
    registerCodec(FilteringObjective.class, new FilteringObjectiveCodec());
    registerCodec(ForwardingObjective.class, new ForwardingObjectiveCodec());
    registerCodec(NextObjective.class, new NextObjectiveCodec());
    registerCodec(McastRoute.class, new McastRouteCodec());
    registerCodec(DeviceKey.class, new DeviceKeyCodec());
    registerCodec(Region.class, new RegionCodec());
    registerCodec(TenantId.class, new TenantIdCodec());
    registerCodec(VirtualNetwork.class, new VirtualNetworkCodec());
    registerCodec(VirtualDevice.class, new VirtualDeviceCodec());
    registerCodec(VirtualPort.class, new VirtualPortCodec());
    registerCodec(VirtualLink.class, new VirtualLinkCodec());
    registerCodec(VirtualHost.class, new VirtualHostCodec());
    registerCodec(MastershipTerm.class, new MastershipTermCodec());
    registerCodec(MastershipRole.class, new MastershipRoleCodec());
    registerCodec(RoleInfo.class, new RoleInfoCodec());
    registerCodec(DpiStatistics.class, new DpiStatisticsCodec());
    registerCodec(DpiStatInfo.class, new DpiStatInfoCodec());
    registerCodec(TrafficStatInfo.class, new TrafficStatInfoCodec());
    registerCodec(ProtocolStatInfo.class, new ProtocolStatInfoCodec());
    registerCodec(FlowStatInfo.class, new FlowStatInfoCodec());
    registerCodec(FilteredConnectPoint.class, new FilteredConnectPointCodec());
    registerCodec(TransportEndpointDescription.class, new TransportEndpointDescriptionCodec());
    registerCodec(PacketRequest.class, new PacketRequestCodec());
    log.info("Started");
}
#end_block

#method_before
@Override
public ObjectNode encode(MultiPointToSinglePointIntent intent, CodecContext context) {
    checkNotNull(intent, "Multi Point to Single Point intent cannot be null");
    final JsonCodec<ConnectivityIntent> connectivityIntentCodec = context.codec(ConnectivityIntent.class);
    final ObjectNode result = connectivityIntentCodec.encode(intent, context);
    final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
    final ObjectNode egress = connectPointCodec.encode(intent.egressPoint(), context);
    final ObjectNode result2 = context.mapper().createObjectNode();
    final ArrayNode jsonconnectPoints = result2.putArray(CP_POINTS);
    if (intent.ingressPoints() != null) {
        for (final ConnectPoint cp : intent.ingressPoints()) {
            jsonconnectPoints.add(connectPointCodec.encode(cp, context));
        }
        result.set(INGRESS_POINT, jsonconnectPoints);
    }
    result.set(EGRESS_POINT, egress);
    return result;
}
#method_after
@Override
public ObjectNode encode(MultiPointToSinglePointIntent intent, CodecContext context) {
    checkNotNull(intent, "Multi Point to Single Point intent cannot be null");
    final JsonCodec<ConnectivityIntent> connectivityIntentCodec = context.codec(ConnectivityIntent.class);
    final ObjectNode result = connectivityIntentCodec.encode(intent, context);
    final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
    final ObjectNode egress = connectPointCodec.encode(intent.egressPoint(), context);
    final ObjectNode objectCP = context.mapper().createObjectNode();
    final ArrayNode jsonconnectPoints = objectCP.putArray(CP_POINTS);
    if (intent.ingressPoints() != null) {
        for (final ConnectPoint cp : intent.ingressPoints()) {
            jsonconnectPoints.add(connectPointCodec.encode(cp, context));
        }
        result.set(INGRESS_POINT, jsonconnectPoints);
    }
    result.set(EGRESS_POINT, egress);
    return result;
}
#end_block

#method_before
@Override
public MultiPointToSinglePointIntent decode(ObjectNode json, CodecContext context) {
    MultiPointToSinglePointIntent.Builder builder = MultiPointToSinglePointIntent.builder();
    IntentCodec.intentAttributes(json, context, builder);
    ConnectivityIntentCodec.intentAttributes(json, context, builder);
    ObjectNode egressJson = nullIsIllegal(get(json, EGRESS_POINT), EGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    ConnectPoint egress = context.codec(ConnectPoint.class).decode(egressJson, context);
    builder.egressPoint(egress);
    ObjectNode ingressJson = nullIsIllegal(get(json, INGRESS_POINT), INGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    if (ingressJson != null) {
        final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
        JsonNode connectPointsJson = get(json, INGRESS_POINT).get(CP_POINTS);
        Set<ConnectPoint> ingressCp = new HashSet<ConnectPoint>();
        if (connectPointsJson != null) {
            for (int i = 0; i < connectPointsJson.size(); i++) {
                ingressCp.add(connectPointCodec.decode(get(connectPointsJson, i), context));
            }
            builder.ingressPoints(ingressCp);
        }
    }
    return builder.build();
}
#method_after
@Override
public MultiPointToSinglePointIntent decode(ObjectNode json, CodecContext context) {
    MultiPointToSinglePointIntent.Builder builder = MultiPointToSinglePointIntent.builder();
    IntentCodec.intentAttributes(json, context, builder);
    ConnectivityIntentCodec.intentAttributes(json, context, builder);
    ObjectNode egressJson = nullIsIllegal(get(json, EGRESS_POINT), EGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    ConnectPoint egress = context.codec(ConnectPoint.class).decode(egressJson, context);
    builder.egressPoint(egress);
    ObjectNode ingressJson = nullIsIllegal(get(json, INGRESS_POINT), INGRESS_POINT + IntentCodec.MISSING_MEMBER_MESSAGE);
    if (ingressJson != null) {
        final JsonCodec<ConnectPoint> connectPointCodec = context.codec(ConnectPoint.class);
        JsonNode connectPointsJson = get(json, INGRESS_POINT).get(CP_POINTS);
        Set<ConnectPoint> ingressCp = new HashSet<ConnectPoint>();
        if (connectPointsJson != null) {
            for (JsonNode cP : connectPointsJson) {
                ingressCp.add(connectPointCodec.decode((ObjectNode) cP, context));
            }
            builder.ingressPoints(ingressCp);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
public NextObjective add() {
    treatments = listBuilder.build();
    op = Operation.ADD;
    checkNotNull(appId, "Must supply an application id");
    checkNotNull(id, "id cannot be null");
    checkNotNull(type, "The type cannot be null");
    checkArgument(!treatments.isEmpty(), "Must have at least one treatment");
    return new DefaultNextObjective(this);
}
#method_after
@Override
public NextObjective add() {
    return add(null);
}
#end_block

#method_before
@Override
public NextObjective remove() {
    treatments = listBuilder.build();
    op = Operation.REMOVE;
    checkNotNull(appId, "Must supply an application id");
    checkNotNull(id, "id cannot be null");
    checkNotNull(type, "The type cannot be null");
    return new DefaultNextObjective(this);
}
#method_after
@Override
public NextObjective remove() {
    return remove(null);
}
#end_block

#method_before
@Override
public NextObjective addToExisting() {
    treatments = listBuilder.build();
    op = Operation.ADD_TO_EXISTING;
    checkNotNull(appId, "Must supply an application id");
    checkNotNull(id, "id cannot be null");
    checkNotNull(type, "The type cannot be null");
    checkArgument(!treatments.isEmpty(), "Must have at least one treatment");
    return new DefaultNextObjective(this);
}
#method_after
@Override
public NextObjective addToExisting() {
    return addToExisting(null);
}
#end_block

#method_before
@Override
public NextObjective removeFromExisting() {
    treatments = listBuilder.build();
    op = Operation.REMOVE_FROM_EXISTING;
    checkNotNull(appId, "Must supply an application id");
    checkNotNull(id, "id cannot be null");
    checkNotNull(type, "The type cannot be null");
    return new DefaultNextObjective(this);
}
#method_after
@Override
public NextObjective removeFromExisting() {
    return removeFromExisting(null);
}
#end_block

#method_before
@Override
public NextObjective verify() {
    treatments = listBuilder.build();
    op = Operation.VERIFY;
    checkNotNull(appId, "Must supply an application id");
    checkNotNull(id, "id cannot be null");
    checkNotNull(type, "The type cannot be null");
    return new DefaultNextObjective(this);
}
#method_after
@Override
public NextObjective verify() {
    return verify(null);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.incubator.store.routing.impl.RouteStoreImpl", "distributed", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_NAME);
    log.debug("Creating EC map nsnextobjectivestore");
    EventuallyConsistentMapBuilder<DestinationSetNextObjectiveStoreKey, NextNeighbors> nsNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    dsNextObjStore = nsNextObjMapBuilder.withName("nsnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.trace("Current size {}", dsNextObjStore.size());
    log.debug("Creating EC map vlannextobjectivestore");
    EventuallyConsistentMapBuilder<VlanNextObjectiveStoreKey, Integer> vlanNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    vlanNextObjStore = vlanNextObjMapBuilder.withName("vlannextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    log.debug("Creating EC map subnetnextobjectivestore");
    EventuallyConsistentMapBuilder<PortNextObjectiveStoreKey, Integer> portNextObjMapBuilder = storageService.eventuallyConsistentMapBuilder();
    portNextObjStore = portNextObjMapBuilder.withName("portnextobjectivestore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Tunnel> tunnelMapBuilder = storageService.eventuallyConsistentMapBuilder();
    tunnelStore = tunnelMapBuilder.withName("tunnelstore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    EventuallyConsistentMapBuilder<String, Policy> policyMapBuilder = storageService.eventuallyConsistentMapBuilder();
    policyStore = policyMapBuilder.withName("policystore").withSerializer(createSerializer()).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    compCfgService.preSetProperty("org.onosproject.net.group.impl.GroupManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.net.flow.impl.FlowRuleManager", "purgeOnDisconnection", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.neighbour.impl.NeighbourResolutionManager", "requestInterceptsEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.dhcprelay.DhcpRelayManager", "arpEnabled", "false");
    compCfgService.preSetProperty("org.onosproject.net.host.impl.HostManager", "greedyLearningIpv6", "true");
    compCfgService.preSetProperty("org.onosproject.routing.cpr.ControlPlaneRedirectManager", "forceUnprovision", "true");
    compCfgService.preSetProperty("org.onosproject.routeservice.store.RouteStoreImpl", "distributed", "true");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "multihomingEnabled", "true");
    processor = new InternalPacketProcessor();
    linkListener = new InternalLinkListener();
    deviceListener = new InternalDeviceListener();
    appCfgHandler = new AppConfigHandler(this);
    xConnectHandler = new XConnectHandler(this);
    mcastHandler = new McastHandler(this);
    hostHandler = new HostHandler(this);
    routeHandler = new RouteHandler(this);
    neighbourHandler = new SegmentRoutingNeighbourDispatcher(this);
    l2TunnelHandler = new L2TunnelHandler(this);
    cfgService.addListener(cfgListener);
    cfgService.registerConfigFactory(deviceConfigFactory);
    cfgService.registerConfigFactory(appConfigFactory);
    cfgService.registerConfigFactory(xConnectConfigFactory);
    cfgService.registerConfigFactory(mcastConfigFactory);
    cfgService.registerConfigFactory(pwaasConfigFactory);
    hostService.addListener(hostListener);
    packetService.addProcessor(processor, PacketProcessor.director(2));
    linkService.addListener(linkListener);
    deviceService.addListener(deviceListener);
    multicastRouteService.addListener(mcastListener);
    routeService.addListener(routeListener);
    cfgListener.configureNetwork();
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    // Do not proceed without mastership
    DeviceId deviceId = event.subject().location().deviceId();
    if (!mastershipService.isLocalMaster(deviceId)) {
        return;
    }
    switch(event.type()) {
        case HOST_ADDED:
            hostHandler.processHostAddedEvent(event);
            break;
        case HOST_MOVED:
            hostHandler.processHostMovedEvent(event);
            break;
        case HOST_REMOVED:
            hostHandler.processHostRemovedEvent(event);
            break;
        case HOST_UPDATED:
            hostHandler.processHostUpdatedEvent(event);
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#method_after
@Override
public void event(HostEvent event) {
    switch(event.type()) {
        case HOST_ADDED:
            hostHandler.processHostAddedEvent(event);
            break;
        case HOST_MOVED:
            hostHandler.processHostMovedEvent(event);
            break;
        case HOST_REMOVED:
            hostHandler.processHostRemovedEvent(event);
            break;
        case HOST_UPDATED:
            hostHandler.processHostUpdatedEvent(event);
            break;
        default:
            log.warn("Unsupported host event type: {}", event.type());
            break;
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Flow Objectives
// ////////////////////////////////////
@Override
public void filter(FilteringObjective filteringObjective) {
    if (filteringObjective.type() == FilteringObjective.Type.PERMIT) {
        processFilter(filteringObjective, filteringObjective.op() == Objective.Operation.ADD, filteringObjective.appId());
    } else {
        // Note that packets that don't match the PERMIT filter are
        // automatically denied. The DENY filter is used to deny packets
        // that are otherwise permitted by the PERMIT filter.
        // Use ACL table flow rules here for DENY filtering objectives
        log.debug("filter objective other than PERMIT currently not supported");
        fail(filteringObjective, ObjectiveError.UNSUPPORTED);
    }
}
#method_after
// ////////////////////////////////////
// Flow Objectives
// ////////////////////////////////////
@Override
public void filter(FilteringObjective filteringObjective) {
    if (filteringObjective.type() == FilteringObjective.Type.PERMIT) {
        processFilter(filteringObjective, filteringObjective.op() == Objective.Operation.ADD, filteringObjective.appId());
    } else {
        // Note that packets that don't match the PERMIT filter are
        // automatically denied. The DENY filter is used to deny packets
        // that are otherwise permitted by the PERMIT filter.
        // Use ACL table flow rules here for DENY filtering objectives
        log.warn("filter objective other than PERMIT currently not supported");
        fail(filteringObjective, ObjectiveError.UNSUPPORTED);
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vidCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filt, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.debug("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    }
    if (portCriterion == null) {
        log.debug("No IN_PORT defined in filtering objective from app: {}", applicationId);
    } else {
        log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vidCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filt, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.info("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        preSelector = DefaultTrafficSelector.builder();
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
            selector.extension(ofdpaMatchVlanVid, deviceId);
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
            OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(VlanId.NONE);
            treatment.setVlanId(assignedVlan);
            preSelector.matchVlanId(assignedVlan);
        }
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (requireVlanExtensions()) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null && PortNumber.ALL.equals(portCriterion.port())) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        preSelector = DefaultTrafficSelector.builder();
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
            selector.extension(ofdpaMatchVlanVid, deviceId);
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
            OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(VlanId.NONE);
            treatment.setVlanId(assignedVlan);
            preSelector.matchVlanId(assignedVlan);
        }
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (requireVlanExtensions()) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (PortNumber.ALL.equals(portCriterion.port())) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
    } else {
        log.warn("Filtering Objective missing Port Criterion . " + "VLAN Table cannot be programmed for {}", deviceId);
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && PortNumber.ANY.equals(portCriterion.port())) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null && PortNumber.ALL.equals(portCriterion.port())) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    List<FlowRule> rules = new ArrayList<>();
    for (PortNumber pnum : portnums) {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (requireVlanExtensions()) {
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (requireVlanExtensions()) {
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        /*
             * TMAC rules for IPv6 packets
             */
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (requireVlanExtensions()) {
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && PortNumber.ANY.equals(portCriterion.port())) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion != null && vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    List<FlowRule> rules = new ArrayList<>();
    OfdpaMatchVlanVid ofdpaMatchVlanVid = null;
    if (vidCriterion != null && requireVlanExtensions()) {
        ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (PortNumber.ALL.equals(portCriterion.port())) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
        for (PortNumber pnum : portnums) {
            rules.add(buildTmacRuleForIpv4(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
            rules.add(buildTmacRuleForMpls(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
            rules.add(buildTmacRuleForIpv6(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
        }
    } else {
        rules.add(buildTmacRuleForIpv4(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
        rules.add(buildTmacRuleForMpls(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
        rules.add(buildTmacRuleForIpv6(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
    }
    return rules;
}
#end_block

#method_before
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective:{} in dev:{}", fwd.id(), deviceId);
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            if (requireVlanExtensions()) {
                OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
                sbuilder.extension(ofdpaMatchVlanVid, deviceId);
            } else {
                sbuilder.matchVlanId(vlanId);
            }
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o.port() == PortNumber.CONTROLLER) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
protected Collection<FlowRule> processVersatile(ForwardingObjective fwd) {
    log.debug("Processing versatile forwarding objective:{} in dev:{}", fwd.id(), deviceId);
    EthTypeCriterion ethType = (EthTypeCriterion) fwd.selector().getCriterion(Criterion.Type.ETH_TYPE);
    if (ethType == null) {
        log.error("Versatile forwarding objective:{} must include ethType", fwd.id());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    if (fwd.nextId() == null && fwd.treatment() == null) {
        log.error("Forwarding objective {} from {} must contain " + "nextId or Treatment", fwd.selector(), fwd.appId());
        fail(fwd, ObjectiveError.BADPARAMS);
        return Collections.emptySet();
    }
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    fwd.selector().criteria().forEach(criterion -> {
        if (criterion instanceof VlanIdCriterion) {
            VlanId vlanId = ((VlanIdCriterion) criterion).vlanId();
            // match untagged packets this way in the ACL table.
            if (vlanId.equals(VlanId.NONE)) {
                return;
            }
            if (requireVlanExtensions()) {
                OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vlanId);
                sbuilder.extension(ofdpaMatchVlanVid, deviceId);
            } else {
                sbuilder.matchVlanId(vlanId);
            }
        } else if (criterion instanceof Icmpv6TypeCriterion || criterion instanceof Icmpv6CodeCriterion) {
            /*
                 * We silenty discard these criterions, our current
                 * OFDPA platform does not support these matches on
                 * the ACL table.
                 */
            log.warn("ICMPv6 Type and ICMPv6 Code are not supported");
        } else {
            sbuilder.add(criterion);
        }
    });
    // XXX driver does not currently do type checking as per Tables 65-67 in
    // OFDPA 2.0 spec. The only allowed treatment is a punt to the controller.
    TrafficTreatment.Builder ttBuilder = DefaultTrafficTreatment.builder();
    if (fwd.treatment() != null) {
        for (Instruction ins : fwd.treatment().allInstructions()) {
            if (ins instanceof OutputInstruction) {
                OutputInstruction o = (OutputInstruction) ins;
                if (o != null && PortNumber.CONTROLLER.equals(o.port())) {
                    ttBuilder.add(o);
                } else {
                    log.warn("Only allowed treatments in versatile forwarding " + "objectives are punts to the controller");
                }
            } else {
                log.warn("Cannot process instruction in versatile fwd {}", ins);
            }
        }
        if (fwd.treatment().clearedDeferred()) {
            ttBuilder.wipeDeferred();
        }
    }
    if (fwd.nextId() != null) {
        // overide case
        NextGroup next = getGroupForNextObjective(fwd.nextId());
        if (next == null) {
            fail(fwd, ObjectiveError.BADPARAMS);
            return Collections.emptySet();
        }
        List<Deque<GroupKey>> gkeys = appKryo.deserialize(next.data());
        // we only need the top level group's key to point the flow to it
        Group group = groupService.getGroup(deviceId, gkeys.get(0).peekFirst());
        if (group == null) {
            log.warn("Group with key:{} for next-id:{} not found in dev:{}", gkeys.get(0).peekFirst(), fwd.nextId(), deviceId);
            fail(fwd, ObjectiveError.GROUPMISSING);
            return Collections.emptySet();
        }
        ttBuilder.deferred().group(group.id());
    }
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().fromApp(fwd.appId()).withPriority(fwd.priority()).forDevice(deviceId).withSelector(sbuilder.build()).withTreatment(ttBuilder.build()).makePermanent().forTable(ACL_TABLE);
    return Collections.singletonList(ruleBuilder.build());
}
#end_block

#method_before
@Activate
public void activate() {
    store.setDelegate(delegate);
    eventDispatcher.addSink(VirtualNetworkEvent.class, listenerRegistry);
    intentService.addListener(intentListener);
    appId = coreService.registerApplication(VIRTUAL_NETWORK_APP_ID_STRING);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    eventDispatcher.addSink(VirtualNetworkEvent.class, listenerRegistry);
    eventDispatcher.addSink(VirtualEvent.class, VirtualListenerRegistryManager.getInstance());
    store.setDelegate(delegate);
    appId = coreService.registerApplication(VIRTUAL_NETWORK_APP_ID_STRING);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    eventDispatcher.removeSink(VirtualNetworkEvent.class);
    intentService.removeListener(intentListener);
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    eventDispatcher.removeSink(VirtualNetworkEvent.class);
    eventDispatcher.removeSink(VirtualEvent.class);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public <T> T get(NetworkId networkId, Class<T> serviceClass) {
    checkNotNull(networkId, NETWORK_NULL);
    ServiceKey serviceKey = networkServiceKey(networkId, serviceClass);
    VnetService service = lookup(serviceKey);
    if (service == null) {
        service = create(serviceKey);
    }
    return (T) service;
}
#method_after
@Override
@SuppressWarnings("unchecked")
public <T> T get(NetworkId networkId, Class<T> serviceClass) {
    checkNotNull(networkId, NETWORK_NULL);
    ServiceKey serviceKey = networkServiceKey(networkId, serviceClass);
    VnetService service = lookup(serviceKey);
    if (service == null) {
        service = create(serviceKey);
    }
    return (T) service;
}
#end_block

#method_before
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(HostService.class)) {
        service = new VirtualNetworkHostManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PathService.class)) {
        service = new VirtualNetworkPathManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowRuleService.class)) {
        service = new VirtualNetworkFlowRuleManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PacketService.class)) {
        service = new VirtualNetworkPacketManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(MeterService.class)) {
        service = new VirtualNetworkMeterManager(this, network.id());
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#method_after
private VnetService create(ServiceKey serviceKey) {
    VirtualNetwork network = getVirtualNetwork(serviceKey.networkId());
    checkNotNull(network, NETWORK_NULL);
    VnetService service;
    if (serviceKey.serviceClass.equals(DeviceService.class)) {
        service = new VirtualNetworkDeviceManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(LinkService.class)) {
        service = new VirtualNetworkLinkManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(TopologyService.class)) {
        service = new VirtualNetworkTopologyManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(IntentService.class)) {
        service = new VirtualNetworkIntentManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(HostService.class)) {
        service = new VirtualNetworkHostManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PathService.class)) {
        service = new VirtualNetworkPathManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowRuleService.class)) {
        service = new VirtualNetworkFlowRuleManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(PacketService.class)) {
        service = new VirtualNetworkPacketManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(GroupService.class)) {
        service = new VirtualNetworkGroupManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(MeterService.class)) {
        service = new VirtualNetworkMeterManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(FlowObjectiveService.class)) {
        service = new VirtualNetworkFlowObjectiveManager(this, network.id());
    } else if (serviceKey.serviceClass.equals(MastershipService.class) || serviceKey.serviceClass.equals(MastershipAdminService.class) || serviceKey.serviceClass.equals(MastershipTermService.class)) {
        service = new VirtualNetworkMastershipManager(this, network.id());
    } else {
        return null;
    }
    networkServices.put(serviceKey, service);
    return service;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    CoreService coreService = new TestCoreService();
    TestStorageService storageService = new TestStorageService();
    TestUtils.setField(virtualNetworkManagerStore, "coreService", coreService);
    TestUtils.setField(virtualNetworkManagerStore, "storageService", storageService);
    virtualNetworkManagerStore.activate();
    meterStore = new SimpleVirtualMeterStore();
    providerRegistryService = new VirtualProviderManager();
    providerRegistryService.registerProvider(provider);
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    manager.intentService = intentService;
    TestUtils.setField(manager, "coreService", coreService);
    eventDeliveryService = new TestEventDispatcher();
    NetTestTools.injectEventDispatcher(manager, eventDeliveryService);
    eventDeliveryService.addSink(VirtualEvent.class, listenerRegistryManager);
    appId = new TestApplicationId("MeterManagerTest");
    testDirectory = new TestServiceDirectory().add(VirtualNetworkStore.class, virtualNetworkManagerStore).add(CoreService.class, coreService).add(VirtualProviderRegistryService.class, providerRegistryService).add(EventDeliveryService.class, eventDeliveryService).add(StorageService.class, storageService).add(VirtualNetworkMeterStore.class, meterStore);
    TestUtils.setField(manager, "serviceDirectory", testDirectory);
    manager.activate();
    vnet1 = setupVirtualNetworkTopology(manager, TID1);
    vnet2 = setupVirtualNetworkTopology(manager, TID2);
    meterManager1 = new VirtualNetworkMeterManager(manager, vnet1.id());
    meterManager2 = new VirtualNetworkMeterManager(manager, vnet2.id());
    providerService1 = (VirtualMeterProviderService) providerRegistryService.getProviderService(vnet1.id(), VirtualMeterProvider.class);
    providerService2 = (VirtualMeterProviderService) providerRegistryService.getProviderService(vnet2.id(), VirtualMeterProvider.class);
    assertTrue("provider should be registered", providerRegistryService.getProviders().contains(provider.id()));
    setupMeterTestVariables();
}
#method_after
@Before
public void setUp() throws Exception {
    virtualNetworkManagerStore = new DistributedVirtualNetworkStore();
    CoreService coreService = new TestCoreService();
    TestStorageService storageService = new TestStorageService();
    TestUtils.setField(virtualNetworkManagerStore, "coreService", coreService);
    TestUtils.setField(virtualNetworkManagerStore, "storageService", storageService);
    virtualNetworkManagerStore.activate();
    meterStore = new SimpleVirtualMeterStore();
    providerRegistryService = new VirtualProviderManager();
    providerRegistryService.registerProvider(provider);
    manager = new VirtualNetworkManager();
    manager.store = virtualNetworkManagerStore;
    TestUtils.setField(manager, "coreService", coreService);
    eventDeliveryService = new TestEventDispatcher();
    NetTestTools.injectEventDispatcher(manager, eventDeliveryService);
    // eventDeliveryService.addSink(VirtualEvent.class, listenerRegistryManager);
    appId = new TestApplicationId("MeterManagerTest");
    testDirectory = new TestServiceDirectory().add(VirtualNetworkStore.class, virtualNetworkManagerStore).add(CoreService.class, coreService).add(VirtualProviderRegistryService.class, providerRegistryService).add(EventDeliveryService.class, eventDeliveryService).add(StorageService.class, storageService).add(VirtualNetworkMeterStore.class, meterStore);
    TestUtils.setField(manager, "serviceDirectory", testDirectory);
    manager.activate();
    vnet1 = setupVirtualNetworkTopology(manager, TID1);
    vnet2 = setupVirtualNetworkTopology(manager, TID2);
    meterManager1 = new VirtualNetworkMeterManager(manager, vnet1.id());
    meterManager2 = new VirtualNetworkMeterManager(manager, vnet2.id());
    providerService1 = (VirtualMeterProviderService) providerRegistryService.getProviderService(vnet1.id(), VirtualMeterProvider.class);
    providerService2 = (VirtualMeterProviderService) providerRegistryService.getProviderService(vnet2.id(), VirtualMeterProvider.class);
    assertTrue("provider should be registered", providerRegistryService.getProviders().contains(provider.id()));
    setupMeterTestVariables();
}
#end_block

#method_before
@After
public void tearDown() {
    providerRegistryService.unregisterProvider(provider);
    assertFalse("provider should not be registered", providerRegistryService.getProviders().contains(provider.id()));
    manager.deactivate();
    NetTestTools.injectEventDispatcher(manager, null);
}
#method_after
@After
public void tearDown() {
    providerRegistryService.unregisterProvider(provider);
    assertFalse("provider should not be registered", providerRegistryService.getProviders().contains(provider.id()));
    manager.deactivate();
    NetTestTools.injectEventDispatcher(manager, null);
    virtualNetworkManagerStore.deactivate();
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> storeMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFeaturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> storeMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFuturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        meters.put(key, data);
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFeaturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.success());
        }
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> deleteMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFuturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    // that it has been removed from the dataplane.
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.success());
        }
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Override
public CompletableFuture<MeterStoreResult> updateMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFeaturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.fail(MeterFailReason.INVALID_METER));
        }
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#method_after
@Override
public CompletableFuture<MeterStoreResult> updateMeter(NetworkId networkId, Meter meter) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFuturesByNetwork(networkId);
    CompletableFuture<MeterStoreResult> future = new CompletableFuture<>();
    MeterKey key = MeterKey.key(meter.deviceId(), meter.id());
    futures.put(key, future);
    MeterData data = new MeterData(meter, null, local);
    try {
        if (meters.computeIfPresent(key, (k, v) -> data) == null) {
            future.complete(MeterStoreResult.fail(MeterFailReason.INVALID_METER));
        }
    } catch (StorageException e) {
        future.completeExceptionally(e);
    }
    return future;
}
#end_block

#method_before
@Override
public void deleteMeterNow(NetworkId networkId, Meter m) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFeaturesByNetwork(networkId);
    MeterKey key = MeterKey.key(m.deviceId(), m.id());
    futures.remove(key);
    meters.remove(key);
}
#method_after
@Override
public void deleteMeterNow(NetworkId networkId, Meter m) {
    ConcurrentMap<MeterKey, MeterData> meters = getMetersByNetwork(networkId);
    ConcurrentMap<MeterKey, CompletableFuture<MeterStoreResult>> futures = getFuturesByNetwork(networkId);
    MeterKey key = MeterKey.key(m.deviceId(), m.id());
    futures.remove(key);
    meters.remove(key);
}
#end_block

#method_before
@Override
public void processStatsRequest(Channel channel, OFMessage msg) {
    if (msg.getType() != OFType.STATS_REQUEST) {
        log.warn("Ignoring message of type {}.", msg.getType());
        return;
    }
    OFStatsRequest ofStatsRequest = (OFStatsRequest) msg;
    OFStatsReply ofStatsReply = null;
    switch(ofStatsRequest.getStatsType()) {
        case PORT_DESC:
            List<OFPortDesc> portDescs = new ArrayList<>();
            Set<Port> ports = ofSwitchService.ports(networkId, deviceId);
            ports.forEach(port -> {
                OFPortDesc ofPortDesc = portDesc(port);
                portDescs.add(ofPortDesc);
            });
            ofStatsReply = FACTORY.buildPortDescStatsReply().setXid(msg.getXid()).setEntries(portDescs).build();
            break;
        case PORT:
            OFPortStatsRequest portStatsRequest = (OFPortStatsRequest) msg;
            OFPort ofPort = portStatsRequest.getPortNo();
            List<OFPortStatsEntry> portStatsEntries = new ArrayList<>();
            List<PortStatistics> portStatistics = ofSwitchService.portStats(networkId, deviceId);
            if (ofPort.equals(OFPort.ANY)) {
                portStatistics.forEach(portStatistic -> {
                    OFPortStatsEntry ofPortStatsEntry = portStatsEntry(portStatistic);
                    portStatsEntries.add(ofPortStatsEntry);
                });
            }
            ofStatsReply = FACTORY.buildPortStatsReply().setEntries(portStatsEntries).setXid(msg.getXid()).build();
            break;
        case METER_FEATURES:
            OFMeterFeatures ofMeterFeatures = FACTORY.buildMeterFeatures().build();
            ofStatsReply = FACTORY.buildMeterFeaturesStatsReply().setXid(msg.getXid()).setFeatures(ofMeterFeatures).build();
            break;
        case DESC:
            ofStatsReply = FACTORY.buildDescStatsReply().setXid(msg.getXid()).build();
            break;
        default:
            log.debug("Functionality not yet supported for type {} statsType{} msg {}", msg.getType(), ofStatsRequest.getStatsType(), msg);
            break;
    }
    if (ofStatsReply != null) {
        log.trace("request {}; reply {}", msg, ofStatsReply);
        channel.writeAndFlush(Collections.singletonList(ofStatsReply));
    }
}
#method_after
@Override
public void processStatsRequest(Channel channel, OFMessage msg) {
    if (msg.getType() != OFType.STATS_REQUEST) {
        log.warn("Ignoring message of type {}.", msg.getType());
        return;
    }
    OFStatsRequest ofStatsRequest = (OFStatsRequest) msg;
    OFStatsReply ofStatsReply = null;
    switch(ofStatsRequest.getStatsType()) {
        case PORT_DESC:
            List<OFPortDesc> portDescs = new ArrayList<>();
            Set<Port> ports = ofSwitchService.ports(networkId, deviceId);
            ports.forEach(port -> {
                OFPortDesc ofPortDesc = portDesc(port);
                portDescs.add(ofPortDesc);
            });
            ofStatsReply = FACTORY.buildPortDescStatsReply().setXid(msg.getXid()).setEntries(portDescs).build();
            break;
        case PORT:
            OFPortStatsRequest portStatsRequest = (OFPortStatsRequest) msg;
            OFPort ofPort = portStatsRequest.getPortNo();
            List<OFPortStatsEntry> portStatsEntries = new ArrayList<>();
            List<PortStatistics> portStatistics = ofSwitchService.getPortStatistics(networkId, deviceId);
            if (ofPort.equals(OFPort.ANY)) {
                portStatistics.forEach(portStatistic -> {
                    OFPortStatsEntry ofPortStatsEntry = portStatsEntry(portStatistic);
                    portStatsEntries.add(ofPortStatsEntry);
                });
            }
            ofStatsReply = FACTORY.buildPortStatsReply().setEntries(portStatsEntries).setXid(msg.getXid()).build();
            break;
        case METER_FEATURES:
            OFMeterFeatures ofMeterFeatures = FACTORY.buildMeterFeatures().build();
            ofStatsReply = FACTORY.buildMeterFeaturesStatsReply().setXid(msg.getXid()).setFeatures(ofMeterFeatures).build();
            break;
        case DESC:
            ofStatsReply = FACTORY.buildDescStatsReply().setXid(msg.getXid()).build();
            break;
        default:
            log.debug("Functionality not yet supported for type {} statsType{} msg {}", msg.getType(), ofStatsRequest.getStatsType(), msg);
            break;
    }
    if (ofStatsReply != null) {
        log.trace("request {}; reply {}", msg, ofStatsReply);
        channel.writeAndFlush(Collections.singletonList(ofStatsReply));
    }
}
#end_block

#method_before
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.serviceDirectory = context.directory();
    this.flowRuleService = serviceDirectory.get(FlowRuleService.class);
}
#method_after
@Override
public void init(DeviceId deviceId, PipelinerContext context) {
    this.deviceId = deviceId;
    this.serviceDirectory = context.directory();
    this.flowRuleService = serviceDirectory.get(FlowRuleService.class);
    this.deviceService = serviceDirectory.get(DeviceService.class);
}
#end_block

#method_before
@Override
public void filter(FilteringObjective filterObjective) {
// Do nothing
}
#method_after
@Override
public void filter(FilteringObjective filterObjective) {
    // Do nothing
    log.info("No action is needed here");
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective forwardObjective) {
    Collection<FlowRule> rules;
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    ForwardingObjective newFwd = forwardObjective;
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.warn("Using 'clear actions' instruction which is not supported by Juniper QFX5100 Switch");
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    rules = processForward(newFwd);
    switch(forwardObjective.op()) {
        case ADD:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::add);
            break;
        case REMOVE:
            rules.stream().filter(Objects::nonNull).forEach(flowOpsBuilder::remove);
            break;
        default:
            fail(forwardObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding rtype {}");
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(forwardObjective);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(forwardObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
@Override
public void forward(ForwardingObjective forwardObjective) {
    FlowRule rule;
    FlowRuleOperations.Builder flowOpsBuilder = FlowRuleOperations.builder();
    ForwardingObjective newFwd = forwardObjective;
    Device device = deviceService.getDevice(deviceId);
    if (forwardObjective.treatment() != null && forwardObjective.treatment().clearedDeferred()) {
        log.warn("Using 'clear actions' instruction which is not supported by {} " + " {} " + "{} Switch ", device.id(), device.manufacturer(), device.hwVersion());
        newFwd = forwardingObjectiveWithoutCleardDef(forwardObjective).orElse(forwardObjective);
    }
    rule = processForward(newFwd);
    switch(forwardObjective.op()) {
        case ADD:
            flowOpsBuilder.add(rule);
            break;
        case REMOVE:
            flowOpsBuilder.remove(rule);
            break;
        default:
            fail(forwardObjective, ObjectiveError.UNKNOWN);
            log.warn("Unknown forwarding type {}", forwardObjective.op());
    }
    flowRuleService.apply(flowOpsBuilder.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(forwardObjective);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(forwardObjective, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
private Optional<ForwardingObjective> forwardingObjectiveWithoutCleardDef(ForwardingObjective forwardingObjective) {
    TrafficTreatment treatment = trafficTreatmentWithoutCleardDeffered(forwardingObjective.treatment());
    DefaultForwardingObjective.Builder foBuilder = (DefaultForwardingObjective.Builder) forwardingObjective.copy();
    foBuilder.withTreatment(treatment);
    if (forwardingObjective.op() == ADD) {
        return Optional.of(foBuilder.add(forwardingObjective.context().orElse(null)));
    } else if (forwardingObjective.op() == REMOVE) {
        return Optional.of(foBuilder.remove(forwardingObjective.context().orElse(null)));
    } else {
        log.warn("Driver Not support other operations for forwarding objective");
        return Optional.empty();
    }
}
#method_after
private Optional<ForwardingObjective> forwardingObjectiveWithoutCleardDef(ForwardingObjective forwardingObjective) {
    TrafficTreatment treatment = trafficTreatmentWithoutCleardDeffered(forwardingObjective.treatment());
    DefaultForwardingObjective.Builder foBuilder = (DefaultForwardingObjective.Builder) forwardingObjective.copy();
    foBuilder.withTreatment(treatment);
    switch(forwardingObjective.op()) {
        case ADD:
            return Optional.of(foBuilder.add(forwardingObjective.context().orElse(null)));
        case REMOVE:
            return Optional.of(foBuilder.remove(forwardingObjective.context().orElse(null)));
        default:
            log.warn("Driver Not support other operations for forwarding objective");
            return Optional.empty();
    }
}
#end_block

#method_before
private TrafficTreatment trafficTreatmentWithoutCleardDeffered(TrafficTreatment treatment) {
    return DefaultTrafficTreatment.builder(treatment).removeWipeDeferred().build();
}
#method_after
private TrafficTreatment trafficTreatmentWithoutCleardDeffered(TrafficTreatment treatment) {
    return DefaultTrafficTreatment.builder(treatment).notWipeDeferred().build();
}
#end_block

#method_before
private Collection<FlowRule> processForward(ForwardingObjective fwd) {
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).withPriority(fwd.priority()).fromApp(fwd.appId()).forTable(DEFAULT_TABLE);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return Collections.singletonList(ruleBuilder.build());
}
#method_after
private FlowRule processForward(ForwardingObjective fwd) {
    FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(fwd.selector()).withTreatment(fwd.treatment()).withPriority(fwd.priority()).fromApp(fwd.appId()).forTable(DEFAULT_TABLE);
    if (fwd.permanent()) {
        ruleBuilder.makePermanent();
    } else {
        ruleBuilder.makeTemporary(fwd.timeout());
    }
    return ruleBuilder.build();
}
#end_block

#method_before
@Override
public void next(NextObjective nextObjective) {
// Do nothing
}
#method_after
@Override
public void next(NextObjective nextObjective) {
    // Do nothing
    log.info("no action is needed here");
}
#end_block

#method_before
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    return null;
}
#method_after
@Override
public List<String> getNextMappings(NextGroup nextGroup) {
    return ImmutableList.of();
}
#end_block

#method_before
private void startConnection() throws NetconfException {
    try {
        startClient();
    } catch (IOException e) {
        throw new NetconfException("Failed to establish SSH with device " + deviceInfo, e);
    }
}
#method_after
private void startConnection() throws NetconfException {
    connectTimeout = deviceInfo.getConnectTimeoutSec().orElse(NetconfControllerImpl.netconfConnectTimeout);
    replyTimeout = deviceInfo.getReplyTimeoutSec().orElse(NetconfControllerImpl.netconfReplyTimeout);
    idleTimeout = deviceInfo.getIdleTimeoutSec().orElse(NetconfControllerImpl.netconfIdleTimeout);
    log.info("Connecting to {} with timeouts C:{}, R:{}, I:{}", deviceInfo, connectTimeout, replyTimeout, idleTimeout);
    try {
        startClient();
    } catch (IOException e) {
        throw new NetconfException("Failed to establish SSH with device " + deviceInfo, e);
    }
}
#end_block

#method_before
@Override
public String requestSync(String request) throws NetconfException {
    if (!request.contains(ENDPATTERN)) {
        request = request + NEW_LINE + ENDPATTERN;
    }
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String requestSync(String request) throws NetconfException {
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    return sendRequest(request, false);
}
#method_after
private String sendRequest(String request) throws NetconfException {
    request = formatNetconfMessage(request);
    return sendRequest(request, false);
}
#end_block

#method_before
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = deviceInfo.getReplyTimeoutSec().isPresent() ? deviceInfo.getReplyTimeoutSec().get().intValue() : NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        log.debug("Sending request to NETCONF with timeout {} for {}", replyTimeout, deviceInfo.name());
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        // Why here???
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request + " after " + replyTimeout + " sec.", e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        try {
            session.close();
            // Closes the socket which should interrupt NetconfStreamThread
            channel.close();
            client.close();
        } catch (IOException ioe) {
            log.warn("Error closing session {} on {}", sessionID, deviceInfo, ioe);
        }
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        // move to cleanUp()?
        errorReplies.clear();
        cleanUp();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatXmlHeader(request);
    request = formatRequestMessageId(request, messageId);
    CompletableFuture<String> futureReply = request(request, messageId);
    String rp;
    try {
        log.debug("Sending request to NETCONF with timeout {} for {}", replyTimeout, deviceInfo.name());
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        // Why here???
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request + " after " + replyTimeout + " sec.", e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        try {
            session.close();
            // Closes the socket which should interrupt NetconfStreamThread
            channel.close();
            client.close();
        } catch (IOException ioe) {
            log.warn("Error closing session {} on {}", sessionID, deviceInfo, ioe);
        }
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        // move to cleanUp()?
        errorReplies.clear();
        cleanUp();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    return request;
}
#method_after
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    request = updateRequestLenght(request);
    return request;
}
#end_block

#method_before
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        request = XML_HEADER + "\n" + request;
    }
    return request;
}
#method_after
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        if (request.startsWith(LF + HASH)) {
            request = request.split("<")[0] + XML_HEADER + request.substring(request.split("<")[0].length());
        } else {
            request = XML_HEADER + "\n" + request;
        }
    }
    return request;
}
#end_block

#method_before
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration + ENDPATTERN;
    return checkReply(sendRequest(newConfiguration));
}
#method_after
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    if (!newConfiguration.endsWith(ENDPATTERN)) {
        newConfiguration = newConfiguration + ENDPATTERN;
    }
    return checkReply(sendRequest(newConfiguration));
}
#end_block

#method_before
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            String[] info = deviceId.toString().split(":");
            if (info.length == 3) {
                ip = info[1];
                port = Integer.parseInt(info[2]);
            } else {
                ip = Arrays.asList(info).stream().filter(el -> !el.equals(info[0]) && !el.equals(info[info.length - 1])).reduce((t, u) -> t + ":" + u).get();
                log.debug("ip v6 {}", ip);
                port = Integer.parseInt(info[info.length - 1]);
            }
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            NetconfDeviceInfo deviceInfo = null;
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(ip), port);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, sshkey);
            } else {
                log.error("Unknown device key for device {}", deviceId);
            }
            String sshClientLib = deviceKey.annotations().value(AnnotationKeys.CLIENTLIB);
            if (sshClientLib != null && !sshClientLib.isEmpty()) {
                deviceInfo.setClientLib(Optional.of(NetconfSshClientLib.getEnum(sshClientLib)));
            } else {
                deviceInfo.setClientLib(Optional.empty());
            }
            String connectToStr = deviceKey.annotations().value(AnnotationKeys.CONNECT_TIMEOUT);
            if (connectToStr != null && !connectToStr.isEmpty()) {
                deviceInfo.setConnectTimeoutSec(Optional.of(Integer.valueOf(connectToStr)));
            } else {
                deviceInfo.setConnectTimeoutSec(Optional.empty());
            }
            String replyToStr = deviceKey.annotations().value(AnnotationKeys.REPLY_TIMEOUT);
            if (replyToStr != null && !replyToStr.isEmpty()) {
                deviceInfo.setReplyTimeoutSec(Optional.of(Integer.valueOf(replyToStr)));
            } else {
                deviceInfo.setReplyTimeoutSec(Optional.empty());
            }
            String idleToStr = deviceKey.annotations().value(AnnotationKeys.IDLE_TIMEOUT);
            if (idleToStr != null && !idleToStr.isEmpty()) {
                deviceInfo.setIdleTimeoutSec(Optional.of(Integer.valueOf(idleToStr)));
            } else {
                deviceInfo.setIdleTimeoutSec(Optional.empty());
            }
            NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
            netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
            return netconfDevicedevice;
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
}
#method_after
@Override
public NetconfDevice connectDevice(DeviceId deviceId) throws NetconfException {
    NetconfDeviceConfig netCfg = netCfgService.getConfig(deviceId, NetconfDeviceConfig.class);
    NetconfDeviceInfo deviceInfo = null;
    if (netconfDeviceMap.containsKey(deviceId)) {
        log.debug("Device {} is already present", deviceId);
        return netconfDeviceMap.get(deviceId);
    } else if (netCfg != null) {
        log.debug("Device {} is present in NetworkConfig", deviceId);
        deviceInfo = new NetconfDeviceInfo(netCfg);
    } else {
        log.debug("Creating NETCONF device {}", deviceId);
        Device device = deviceService.getDevice(deviceId);
        String ip;
        int port;
        if (device != null) {
            ip = device.annotations().value("ipaddress");
            port = Integer.parseInt(device.annotations().value("port"));
        } else {
            String[] info = deviceId.toString().split(":");
            if (info.length == 3) {
                ip = info[1];
                port = Integer.parseInt(info[2]);
            } else {
                ip = Arrays.asList(info).stream().filter(el -> !el.equals(info[0]) && !el.equals(info[info.length - 1])).reduce((t, u) -> t + ":" + u).get();
                log.debug("ip v6 {}", ip);
                port = Integer.parseInt(info[info.length - 1]);
            }
        }
        try {
            DeviceKey deviceKey = deviceKeyService.getDeviceKey(DeviceKeyId.deviceKeyId(deviceId.toString()));
            if (deviceKey.type() == DeviceKey.Type.USERNAME_PASSWORD) {
                UsernamePassword usernamepasswd = deviceKey.asUsernamePassword();
                deviceInfo = new NetconfDeviceInfo(usernamepasswd.username(), usernamepasswd.password(), IpAddress.valueOf(ip), port);
            } else if (deviceKey.type() == DeviceKey.Type.SSL_KEY) {
                String username = deviceKey.annotations().value(AnnotationKeys.USERNAME);
                String password = deviceKey.annotations().value(AnnotationKeys.PASSWORD);
                String sshkey = deviceKey.annotations().value(AnnotationKeys.SSHKEY);
                deviceInfo = new NetconfDeviceInfo(username, password, IpAddress.valueOf(ip), port, sshkey);
            } else {
                log.error("Unknown device key for device {}", deviceId);
            }
        } catch (NullPointerException e) {
            throw new NetconfException("No Device Key for device " + deviceId, e);
        }
    }
    NetconfDevice netconfDevicedevice = createDevice(deviceInfo);
    netconfDevicedevice.getSession().addDeviceOutputListener(downListener);
    return netconfDevicedevice;
}
#end_block

#method_before
@Override
public NetconfDevice createNetconfDevice(NetconfDeviceInfo netconfDeviceInfo) throws NetconfException {
    if (NetconfSshClientLib.ETHZ_SSH2.equals(netconfDeviceInfo.clientLib()) || NetconfSshClientLib.ETHZ_SSH2.equals(sshLibrary)) {
        log.info("Creating NETCONF session to {} with {}", netconfDeviceInfo.name(), NetconfSshClientLib.ETHZ_SSH2);
        return new DefaultNetconfDevice(netconfDeviceInfo, new NetconfSessionImpl.SshNetconfSessionFactory());
    }
    log.info("Creating NETCONF session to {} with {}", netconfDeviceInfo.getDeviceId(), NetconfSshClientLib.APACHE_MINA);
    return new DefaultNetconfDevice(netconfDeviceInfo);
}
#method_after
@Override
public NetconfDevice createNetconfDevice(NetconfDeviceInfo netconfDeviceInfo) throws NetconfException {
    if (NetconfSshClientLib.ETHZ_SSH2.equals(netconfDeviceInfo.sshClientLib()) || NetconfSshClientLib.ETHZ_SSH2.equals(sshLibrary)) {
        log.info("Creating NETCONF session to {} with {}", netconfDeviceInfo.name(), NetconfSshClientLib.ETHZ_SSH2);
        return new DefaultNetconfDevice(netconfDeviceInfo, new NetconfSessionImpl.SshNetconfSessionFactory());
    }
    log.info("Creating NETCONF session to {} with {}", netconfDeviceInfo.getDeviceId(), NetconfSshClientLib.APACHE_MINA);
    return new DefaultNetconfDevice(netconfDeviceInfo);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ctrl = new NetconfControllerImpl();
    ctrl.deviceFactory = new TestNetconfDeviceFactory();
    ctrl.cfgService = cfgService;
    ctrl.deviceService = deviceService;
    ctrl.deviceKeyService = deviceKeyService;
    // Creating mock devices
    deviceInfo1 = new NetconfDeviceInfo("device1", "001", IpAddress.valueOf(DEVICE_1_IP), DEVICE_1_PORT);
    deviceInfo2 = new NetconfDeviceInfo("device2", "002", IpAddress.valueOf(DEVICE_2_IP), DEVICE_2_PORT);
    deviceInfo2.setClientLib(Optional.of(NetconfSshClientLib.ETHZ_SSH2));
    badDeviceInfo3 = new NetconfDeviceInfo("device3", "003", IpAddress.valueOf(BAD_DEVICE_IP), BAD_DEVICE_PORT);
    deviceInfoIpV6 = new NetconfDeviceInfo("deviceIpv6", "004", IpAddress.valueOf(DEVICE_IPV6), IPV6_DEVICE_PORT);
    device1 = new TestNetconfDevice(deviceInfo1);
    deviceId1 = deviceInfo1.getDeviceId();
    device2 = new TestNetconfDevice(deviceInfo2);
    deviceId2 = deviceInfo2.getDeviceId();
    // Adding to the map for testing get device calls.
    Field field1 = ctrl.getClass().getDeclaredField("netconfDeviceMap");
    field1.setAccessible(true);
    reflectedDeviceMap = (Map<DeviceId, NetconfDevice>) field1.get(ctrl);
    reflectedDeviceMap.put(deviceId1, device1);
    reflectedDeviceMap.put(deviceId2, device2);
    // Creating mock events for testing NetconfDeviceOutputEventListener
    Field field2 = ctrl.getClass().getDeclaredField("downListener");
    field2.setAccessible(true);
    reflectedDownListener = (NetconfDeviceOutputEventListener) field2.get(ctrl);
    eventForDeviceInfo1 = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, null, Optional.of(1), deviceInfo1);
    eventForDeviceInfo2 = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(2), deviceInfo2);
}
#method_after
@Before
public void setUp() throws Exception {
    ctrl = new NetconfControllerImpl();
    ctrl.deviceFactory = new TestNetconfDeviceFactory();
    ctrl.cfgService = cfgService;
    ctrl.deviceService = deviceService;
    ctrl.deviceKeyService = deviceKeyService;
    ctrl.netCfgService = netCfgService;
    // Creating mock devices
    deviceInfo1 = new NetconfDeviceInfo("device1", "001", IpAddress.valueOf(DEVICE_1_IP), DEVICE_1_PORT);
    deviceInfo2 = new NetconfDeviceInfo("device2", "002", IpAddress.valueOf(DEVICE_2_IP), DEVICE_2_PORT);
    deviceInfo2.setSshClientLib(Optional.of(NetconfSshClientLib.ETHZ_SSH2));
    badDeviceInfo3 = new NetconfDeviceInfo("device3", "003", IpAddress.valueOf(BAD_DEVICE_IP), BAD_DEVICE_PORT);
    deviceInfoIpV6 = new NetconfDeviceInfo("deviceIpv6", "004", IpAddress.valueOf(DEVICE_IPV6), IPV6_DEVICE_PORT);
    deviceConfig10Id = DeviceId.deviceId("netconf:" + DEVICE_10_IP + ":" + DEVICE_10_PORT);
    // Create a JSON entry just like Network Config accepts
    ObjectMapper mapper = new ObjectMapper();
    String jsonMessage = "{\n" + "  \"ip\":\"" + DEVICE_10_IP + "\",\n" + "  \"port\":" + DEVICE_10_PORT + ",\n" + "  \"username\":\"" + DEVICE_10_USERNAME + "\",\n" + "  \"password\":\"" + DEVICE_10_PASSWORD + "\",\n" + "  \"" + NetconfDeviceConfig.CONNECT_TIMEOUT + "\":" + DEVICE_10_CONNECT_TIMEOUT + ",\n" + "  \"" + NetconfDeviceConfig.REPLY_TIMEOUT + "\":" + DEVICE_10_REPLY_TIMEOUT + ",\n" + "  \"" + NetconfDeviceConfig.IDLE_TIMEOUT + "\":" + DEVICE_10_IDLE_TIMEOUT + ",\n" + "  \"" + NetconfDeviceConfig.SSHCLIENT + "\":\"" + NetconfSshClientLib.ETHZ_SSH2.toString() + "\"\n" + "}";
    InputStream jsonStream = new ByteArrayInputStream(jsonMessage.getBytes());
    JsonNode jsonNode = mapper.readTree(jsonStream);
    jsonStream.close();
    ConfigApplyDelegate delegate = new MockDelegate();
    deviceConfig10 = new NetconfDeviceConfig();
    deviceConfig10.init(deviceConfig10Id, "netconf", jsonNode, mapper, delegate);
    device1 = new TestNetconfDevice(deviceInfo1);
    deviceId1 = deviceInfo1.getDeviceId();
    device2 = new TestNetconfDevice(deviceInfo2);
    deviceId2 = deviceInfo2.getDeviceId();
    // Adding to the map for testing get device calls.
    Field field1 = ctrl.getClass().getDeclaredField("netconfDeviceMap");
    field1.setAccessible(true);
    reflectedDeviceMap = (Map<DeviceId, NetconfDevice>) field1.get(ctrl);
    reflectedDeviceMap.put(deviceId1, device1);
    reflectedDeviceMap.put(deviceId2, device2);
    // Creating mock events for testing NetconfDeviceOutputEventListener
    Field field2 = ctrl.getClass().getDeclaredField("downListener");
    field2.setAccessible(true);
    reflectedDownListener = (NetconfDeviceOutputEventListener) field2.get(ctrl);
    eventForDeviceInfo1 = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, null, Optional.of(1), deviceInfo1);
    eventForDeviceInfo2 = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(2), deviceInfo2);
}
#end_block

#method_before
public Optional<Integer> connectTimeout() {
    int connectTimeout = get(CONNECT_TIMEOUT, 0);
    return (connectTimeout == 0) ? Optional.empty() : Optional.of(connectTimeout);
}
#method_after
public OptionalInt connectTimeout() {
    int connectTimeout = get(CONNECT_TIMEOUT, 0);
    return (connectTimeout == 0) ? OptionalInt.empty() : OptionalInt.of(connectTimeout);
}
#end_block

#method_before
public Optional<Integer> replyTimeout() {
    int replyTimeout = get(REPLY_TIMEOUT, 0);
    return (replyTimeout == 0) ? Optional.empty() : Optional.of(replyTimeout);
}
#method_after
public OptionalInt replyTimeout() {
    int replyTimeout = get(REPLY_TIMEOUT, 0);
    return (replyTimeout == 0) ? OptionalInt.empty() : OptionalInt.of(replyTimeout);
}
#end_block

#method_before
public Optional<Integer> idleTimeout() {
    int idleTimeout = get(IDLE_TIMEOUT, 0);
    return (idleTimeout == 0) ? Optional.empty() : Optional.of(idleTimeout);
}
#method_after
public OptionalInt idleTimeout() {
    int idleTimeout = get(IDLE_TIMEOUT, 0);
    return (idleTimeout == 0) ? OptionalInt.empty() : OptionalInt.of(idleTimeout);
}
#end_block

#method_before
public void setConnectTimeoutSec(Optional<Integer> connectTimeoutSec) {
    this.connectTimeoutSec = connectTimeoutSec;
}
#method_after
public void setConnectTimeoutSec(OptionalInt connectTimeoutSec) {
    this.connectTimeoutSec = connectTimeoutSec;
}
#end_block

#method_before
public void setReplyTimeoutSec(Optional<Integer> replyTimeoutSec) {
    this.replyTimeoutSec = replyTimeoutSec;
}
#method_after
public void setReplyTimeoutSec(OptionalInt replyTimeoutSec) {
    this.replyTimeoutSec = replyTimeoutSec;
}
#end_block

#method_before
public void setIdleTimeoutSec(Optional<Integer> idleTimeoutSec) {
    this.idleTimeoutSec = idleTimeoutSec;
}
#method_after
public void setIdleTimeoutSec(OptionalInt idleTimeoutSec) {
    this.idleTimeoutSec = idleTimeoutSec;
}
#end_block

#method_before
public Optional<Integer> getConnectTimeoutSec() {
    return connectTimeoutSec;
}
#method_after
public OptionalInt getConnectTimeoutSec() {
    return connectTimeoutSec;
}
#end_block

#method_before
public Optional<Integer> getReplyTimeoutSec() {
    return replyTimeoutSec;
}
#method_after
public OptionalInt getReplyTimeoutSec() {
    return replyTimeoutSec;
}
#end_block

#method_before
public Optional<Integer> getIdleTimeoutSec() {
    return idleTimeoutSec;
}
#method_after
public OptionalInt getIdleTimeoutSec() {
    return idleTimeoutSec;
}
#end_block

#method_before
private void startConnection() throws NetconfException {
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device " + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKeyFile() != null && deviceInfo.getKeyFile().canRead()) {
                log.debug("Authenticating with key file to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKeyFile(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#method_after
private void startConnection() throws NetconfException {
    connectTimeout = deviceInfo.getConnectTimeoutSec().orElse(NetconfControllerImpl.netconfConnectTimeout);
    replyTimeout = deviceInfo.getReplyTimeoutSec().orElse(NetconfControllerImpl.netconfReplyTimeout);
    log.debug("Connecting to {} with timeouts C:{}, R:{}. I:connect-timeout", deviceInfo, connectTimeout, replyTimeout);
    if (!connectionActive) {
        netconfConnection = new Connection(deviceInfo.ip().toString(), deviceInfo.port());
        try {
            netconfConnection.connect(null, 1000 * connectTimeout, 1000 * connectTimeout);
        } catch (IOException e) {
            throw new NetconfException("Cannot open a connection with device " + deviceInfo, e);
        }
        boolean isAuthenticated;
        try {
            if (deviceInfo.getKeyFile() != null && deviceInfo.getKeyFile().canRead()) {
                log.debug("Authenticating with key file to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKeyFile(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else if (deviceInfo.getKey() != null) {
                log.debug("Authenticating with key to device {} with username {}", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPublicKey(deviceInfo.name(), deviceInfo.getKey(), deviceInfo.password().equals("") ? null : deviceInfo.password());
            } else {
                log.debug("Authenticating to device {} with username {} with password", deviceInfo.getDeviceId(), deviceInfo.name());
                isAuthenticated = netconfConnection.authenticateWithPassword(deviceInfo.name(), deviceInfo.password());
            }
        } catch (IOException e) {
            log.error("Authentication connection to device {} failed", deviceInfo.getDeviceId(), e);
            throw new NetconfException("Authentication connection to device " + deviceInfo.getDeviceId() + " failed", e);
        }
        connectionActive = true;
        Preconditions.checkArgument(isAuthenticated, "Authentication to device %s with username " + "%s failed", deviceInfo.getDeviceId(), deviceInfo.name());
        startSshSession();
    }
}
#end_block

#method_before
@Override
public String requestSync(String request) throws NetconfException {
    if (!request.contains(ENDPATTERN)) {
        request = request + NEW_LINE + ENDPATTERN;
    }
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String requestSync(String request) throws NetconfException {
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    return sendRequest(request, false);
}
#method_after
private String sendRequest(String request) throws NetconfException {
    request = validateNetconfMessage(request);
    return sendRequest(request, false);
}
#end_block

#method_before
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    String rp;
    try {
        log.debug("Sending request to NETCONF with timeout {} for {}", replyTimeout, deviceInfo.name());
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request + " after " + replyTimeout + " sec.", e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        // Closes the socket which should interrupt NetconfStreamThread
        netconfConnection.close();
        sshSession.close();
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        replies.clear();
        errorReplies.clear();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatXmlHeader(request);
    request = formatRequestMessageId(request, messageId);
    CompletableFuture<String> futureReply = request(request, messageId);
    String rp;
    try {
        log.debug("Sending request to NETCONF with timeout {} for {}", replyTimeout, deviceInfo.name());
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request + " after " + replyTimeout + " sec.", e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        // Closes the socket which should interrupt NetconfStreamThread
        netconfConnection.close();
        sshSession.close();
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        replies.clear();
        errorReplies.clear();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    return request;
}
#method_after
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    request = updateRequestLength(request);
    return request;
}
#end_block

#method_before
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        request = XML_HEADER + "\n" + request;
    }
    return request;
}
#method_after
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        if (request.startsWith(LF + HASH)) {
            request = request.split("<")[0] + XML_HEADER + request.substring(request.split("<")[0].length());
        } else {
            request = XML_HEADER + "\n" + request;
        }
    }
    return request;
}
#end_block

#method_before
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration + ENDPATTERN;
    return checkReply(sendRequest(newConfiguration));
}
#method_after
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    if (!newConfiguration.endsWith(ENDPATTERN)) {
        newConfiguration = newConfiguration + ENDPATTERN;
    }
    return checkReply(sendRequest(newConfiguration));
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    SimpleGeneratorHostKeyProvider provider = new SimpleGeneratorHostKeyProvider();
    provider.setFile(new File(TEST_SERFILE));
    sshServerNetconf.setKeyPairProvider(provider);
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfController netconfCtl = new NetconfControllerImpl();
    NetconfDeviceInfo deviceInfo1 = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo1);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
    NetconfDeviceInfo deviceInfo2 = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    deviceInfo2.setConnectTimeoutSec(Optional.of(11));
    deviceInfo2.setReplyTimeoutSec(Optional.of(10));
    deviceInfo2.setIdleTimeoutSec(Optional.of(12));
    session2 = new NetconfSessionMinaImpl(deviceInfo2);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    SimpleGeneratorHostKeyProvider provider = new SimpleGeneratorHostKeyProvider();
    provider.setFile(new File(TEST_SERFILE));
    sshServerNetconf.setKeyPairProvider(provider);
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfController netconfCtl = new NetconfControllerImpl();
    NetconfDeviceInfo deviceInfo1 = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo1, ImmutableList.of("urn:ietf:params:netconf:base:1.0"));
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES.toArray()));
    NetconfDeviceInfo deviceInfo2 = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    deviceInfo2.setConnectTimeoutSec(OptionalInt.of(11));
    deviceInfo2.setReplyTimeoutSec(OptionalInt.of(10));
    deviceInfo2.setIdleTimeoutSec(OptionalInt.of(12));
    session2 = new NetconfSessionMinaImpl(deviceInfo2, ImmutableList.of("urn:ietf:params:netconf:base:1.0"));
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES.toArray()));
    session3 = new NetconfSessionImpl(deviceInfo1);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session3.getSessionId());
    assertTrue("Incorrect sessionId", !session3.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session3.getSessionId().equalsIgnoreCase("0"));
    assertThat(session3.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1.toArray()));
    session4 = new NetconfSessionImpl(deviceInfo1);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session4.getSessionId());
    assertTrue("Incorrect sessionId", !session4.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session4.getSessionId().equalsIgnoreCase("0"));
    assertThat(session4.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1.toArray()));
}
#end_block

#method_before
@AfterClass
public static void tearDown() throws Exception {
    if (session1 != null) {
        session1.close();
    }
    if (session2 != null) {
        session2.close();
    }
    sshServerNetconf.stop();
}
#method_after
@AfterClass
public static void tearDown() throws Exception {
    if (session1 != null) {
        session1.close();
    }
    if (session2 != null) {
        session2.close();
    }
    if (session3 != null) {
        session3.close();
    }
    if (session4 != null) {
        session4.close();
    }
    sshServerNetconf.stop();
}
#end_block

#method_before
@Test
public void testEditConfigRequestWithOnlyNewConfiguration() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(EDIT_CONFIG_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#method_after
@Test
public void testEditConfigRequestWithOnlyNewConfiguration() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(NetconfSessionMinaImplTest.EDIT_CONFIG_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#end_block

#method_before
@Test
public void testGetConfigRequest() {
    log.info("Starting get-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get-config running command failed. ", GET_REPLY_PATTERN.matcher(session1.getConfig(RUNNING, SAMPLE_REQUEST)).matches());
        assertTrue("NETCONF get-config candidate command failed. ", GET_REPLY_PATTERN.matcher(session1.getConfig(CANDIDATE, SAMPLE_REQUEST)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get-config test failed: " + e.getMessage());
    }
    log.info("Finishing get-config async");
}
#method_after
@Test
public void testGetConfigRequest() {
    log.info("Starting get-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get-config running command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.getConfig(RUNNING, SAMPLE_REQUEST)).matches());
        assertTrue("NETCONF get-config candidate command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.getConfig(CANDIDATE, SAMPLE_REQUEST)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get-config test failed: " + e.getMessage());
    }
    log.info("Finishing get-config async");
}
#end_block

#method_before
@Test
public void testGetRequest() {
    log.info("Starting get async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get running command failed. ", GET_REPLY_PATTERN.matcher(session1.get(SAMPLE_REQUEST, null)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get test failed: " + e.getMessage());
    }
    log.info("Finishing get async");
}
#method_after
@Test
public void testGetRequest() {
    log.info("Starting get async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get running command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.get(SAMPLE_REQUEST, null)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get test failed: " + e.getMessage());
    }
    log.info("Finishing get async");
}
#end_block

#method_before
public static String getTestHelloReply(Collection<String> capabilities, Optional<Long> sessionId) {
    StringBuffer sb = new StringBuffer();
    sb.append("<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">");
    sb.append("<capabilities>");
    capabilities.forEach(capability -> {
        sb.append("<capability>").append(capability).append("</capability>");
    });
    sb.append("</capabilities>");
    if (sessionId.isPresent()) {
        sb.append("<session-id>");
        sb.append(sessionId.get().toString());
        sb.append("</session-id>");
    }
    sb.append("</hello>");
    return sb.toString();
}
#method_after
public static String getTestHelloReply(Optional<Long> sessionId, boolean useChunkedFraming) {
    if (useChunkedFraming) {
        return getTestHelloReply(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1, sessionId);
    } else {
        return getTestHelloReply(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES, sessionId);
    }
}
#end_block

#method_before
public static String parseCopyrightHeader() throws IOException {
    return COPYRIGHTS_FIRST_LINE + COPYRIGHTS_REMAIN;
}
#method_after
public static String parseCopyrightHeader() throws IOException {
    return COPYRIGHT_HEADER;
}
#end_block

#method_before
@Test
public void testNotNullValues() throws Throwable {
    final byte[] rawFooValue = Tools.getBytesUtf8("Hello foo!");
    final byte[] rawBarValue = Tools.getBytesUtf8("Hello bar!");
    AsyncConsistentMap<String, byte[]> map = DistributedPrimitives.newNotNullMap(newPrimitive("testNullValues"));
    map.get("foo").thenAccept(v -> assertNull(v)).join();
    map.put("foo", null).thenAccept(v -> assertNull(v)).join();
    map.put("foo", rawFooValue).thenAccept(v -> assertNull(v)).join();
    map.get("foo").thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawFooValue));
    }).join();
    map.put("foo", null).thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawFooValue));
    }).join();
    map.get("foo").thenAccept(v -> assertNull(v)).join();
    map.replace("foo", rawFooValue, null).thenAccept(replaced -> assertFalse(replaced)).join();
    map.replace("foo", null, rawBarValue).thenAccept(replaced -> assertTrue(replaced)).join();
    map.get("foo").thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawBarValue));
    }).join();
    map.replace("foo", rawBarValue, null).thenAccept(replaced -> assertTrue(replaced)).join();
    map.get("foo").thenAccept(v -> assertNull(v)).join();
}
#method_after
@Test
public void testNotNullValues() throws Throwable {
    final byte[] rawFooValue = Tools.getBytesUtf8("Hello foo!");
    final byte[] rawBarValue = Tools.getBytesUtf8("Hello bar!");
    AsyncConsistentMap<String, byte[]> map = DistributedPrimitives.newNotNullMap(newPrimitive("testNotNullValues"));
    map.get("foo").thenAccept(v -> assertNull(v)).join();
    map.put("foo", null).thenAccept(v -> assertNull(v)).join();
    map.put("foo", rawFooValue).thenAccept(v -> assertNull(v)).join();
    map.get("foo").thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawFooValue));
    }).join();
    map.put("foo", null).thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawFooValue));
    }).join();
    map.get("foo").thenAccept(v -> assertNull(v)).join();
    map.replace("foo", rawFooValue, null).thenAccept(replaced -> assertFalse(replaced)).join();
    map.replace("foo", null, rawBarValue).thenAccept(replaced -> assertTrue(replaced)).join();
    map.get("foo").thenAccept(v -> {
        assertNotNull(v);
        assertTrue(Arrays.equals(v.value(), rawBarValue));
    }).join();
    map.replace("foo", rawBarValue, null).thenAccept(replaced -> assertTrue(replaced)).join();
    map.get("foo").thenAccept(v -> assertNull(v)).join();
}
#end_block

#method_before
@Override
public CompletableFuture<String> sendMessage(String request, int messageId) {
    log.debug("Sending message {} to device {}", request, netconfDeviceInfo);
    CompletableFuture<String> cf = new CompletableFuture<>();
    replies.put(messageId, cf);
    synchronized (outputStream) {
        outputStream.print(request);
        outputStream.flush();
    }
    return cf;
}
#method_after
@Override
public CompletableFuture<String> sendMessage(String request, int messageId) {
    log.debug("Sending message {} to device {}", request, netconfDeviceInfo);
    CompletableFuture<String> cf = new CompletableFuture<>();
    replies.put(messageId, cf);
    synchronized (outputStream) {
        try {
            outputStream.write(request);
            outputStream.flush();
        } catch (IOException e) {
            log.error("Writing to {} failed", netconfDeviceInfo, e);
            cf.completeExceptionally(e);
        }
    }
    return cf;
}
#end_block

#method_before
@Override
public void run() {
    BufferedReader bufferReader = new BufferedReader(new InputStreamReader(in));
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
                log.debug("Netconf device {} ERROR cInt == -1 socketClosed = true", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN || state == NetconfMessageState.END_CHUNKED_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (state == NetconfMessageState.END_CHUNKED_PATTERN) {
                    deviceReply = deviceReply.replaceAll("\n#\\d+\n", "");
                    deviceReply = deviceReply.replaceAll("\n##\n", "");
                }
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    log.debug("Netconf device {} socketClosed = true DEVICE_UNREGISTERED {}", netconfDeviceInfo, deviceReply);
                    NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_UNREGISTERED, null, null, Optional.of(-1), netconfDeviceInfo);
                    netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    this.interrupt();
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    if (deviceReply.contains(RPC_REPLY) || deviceReply.contains(RPC_ERROR) || deviceReply.contains(HELLO)) {
                        log.debug("Netconf device {} sessionDelegate.notify() DEVICE_REPLY {} {}", netconfDeviceInfo, getMsgId(deviceReply), deviceReply);
                        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_REPLY, null, deviceReply, getMsgId(deviceReply), netconfDeviceInfo);
                        sessionDelegate.notify(event);
                        netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                    } else if (deviceReply.contains(NOTIFICATION_LABEL)) {
                        log.debug("Netconf device {} DEVICE_NOTIFICATION {} {} {}", netconfDeviceInfo, enableNotifications, getMsgId(deviceReply), deviceReply);
                        if (enableNotifications) {
                            log.debug("dispatching to {} listeners", netconfDeviceEventListeners.size());
                            final String finalDeviceReply = deviceReply;
                            netconfDeviceEventListeners.forEach(listener -> listener.event(new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION, null, finalDeviceReply, getMsgId(finalDeviceReply), netconfDeviceInfo)));
                        }
                    } else {
                        log.debug("Error on reply from device {} {}", netconfDeviceInfo, deviceReply);
                    }
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#method_after
@Override
public void run() {
    BufferedReader bufferReader = null;
    while (bufferReader == null) {
        try {
            bufferReader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
    try {
        boolean socketClosed = false;
        StringBuilder deviceReplyBuilder = new StringBuilder();
        while (!socketClosed) {
            int cInt = bufferReader.read();
            if (cInt == -1) {
                log.debug("Netconf device {}  sent error char in session," + " will need to be reopend", netconfDeviceInfo);
                NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, null, Optional.of(-1), netconfDeviceInfo);
                netconfDeviceEventListeners.forEach(listener -> listener.event(event));
                socketClosed = true;
                log.debug("Netconf device {} ERROR cInt == -1 socketClosed = true", netconfDeviceInfo);
            }
            char c = (char) cInt;
            state = state.evaluateChar(c);
            deviceReplyBuilder.append(c);
            if (state == NetconfMessageState.END_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (deviceReply.equals(END_PATTERN)) {
                    socketClosed = true;
                    close(deviceReply);
                } else {
                    deviceReply = deviceReply.replace(END_PATTERN, "");
                    dealWithReply(deviceReply);
                    deviceReplyBuilder.setLength(0);
                }
            } else if (state == NetconfMessageState.END_CHUNKED_PATTERN) {
                String deviceReply = deviceReplyBuilder.toString();
                if (!validateChunkedFraming(deviceReply)) {
                    log.debug("Netconf device {} send badly framed message {}", netconfDeviceInfo, deviceReply);
                    socketClosed = true;
                    close(deviceReply);
                } else {
                    deviceReply = deviceReply.replaceAll(MSGLEN_REGEX_PATTERN, "");
                    deviceReply = deviceReply.replaceAll(CHUNKED_END_REGEX_PATTERN, "");
                    dealWithReply(deviceReply);
                    deviceReplyBuilder.setLength(0);
                }
            }
        }
    } catch (IOException e) {
        log.warn("Error in reading from the session for device {} ", netconfDeviceInfo, e);
        throw new RuntimeException(new NetconfException("Error in reading from the session for device {}" + netconfDeviceInfo, e));
    // TODO should we send a socket closed message to listeners ?
    }
}
#end_block

#method_before
protected static Optional<Integer> getMsgId(String reply) {
    Matcher matcher = MSGID_PATTERN.matcher(reply);
    if (matcher.find()) {
        Integer messageId = Integer.parseInt(matcher.group(1));
        Preconditions.checkNotNull(messageId, "Error in retrieving the message id");
        return Optional.of(messageId);
    }
    if (reply.contains(HELLO)) {
        return Optional.of(0);
    }
    return Optional.empty();
}
#method_after
protected static Optional<Integer> getMsgId(String reply) {
    Matcher matcher = MSGID_PATTERN.matcher(reply);
    if (matcher.find()) {
        try {
            return Optional.of(Integer.valueOf(matcher.group(1)));
        } catch (NumberFormatException e) {
            log.warn("Failed to parse message-id from {}", matcher.group(), e);
        }
    }
    if (reply.contains(HELLO)) {
        return Optional.of(-1);
    }
    return Optional.empty();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    List<NamedFactory<UserAuth>> userAuthFactories = new ArrayList<>();
    userAuthFactories.add(new UserAuthPassword.Factory());
    sshServerNetconf.setUserAuthFactories(userAuthFactories);
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    sshServerNetconf.setKeyPairProvider(new SimpleGeneratorHostKeyProvider(TEST_SERFILE));
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
    session2 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(DEFAULT_CAPABILITIES.toArray()));
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    sshServerNetconf = SshServer.setUpDefaultServer();
    sshServerNetconf.setPasswordAuthenticator(new PasswordAuthenticator() {

        @Override
        public boolean authenticate(String username, String password, ServerSession session) {
            return TEST_USERNAME.equals(username) && TEST_PASSWORD.equals(password);
        }
    });
    sshServerNetconf.setPort(PORT_NUMBER);
    SimpleGeneratorHostKeyProvider provider = new SimpleGeneratorHostKeyProvider();
    provider.setFile(new File(TEST_SERFILE));
    sshServerNetconf.setKeyPairProvider(provider);
    sshServerNetconf.setSubsystemFactories(Arrays.<NamedFactory<Command>>asList(new NetconfSshdTestSubsystem.Factory()));
    sshServerNetconf.open();
    log.info("SSH Server opened on port {}", PORT_NUMBER);
    NetconfDeviceInfo deviceInfo = new NetconfDeviceInfo(TEST_USERNAME, TEST_PASSWORD, Ip4Address.valueOf(TEST_HOSTNAME), PORT_NUMBER);
    session1 = new NetconfSessionImpl(deviceInfo, ImmutableList.of("urn:ietf:params:netconf:base:1.0"));
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session1.getSessionId());
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session1.getSessionId().equalsIgnoreCase("0"));
    assertThat(session1.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES.toArray()));
    session2 = new NetconfSessionImpl(deviceInfo, ImmutableList.of("urn:ietf:params:netconf:base:1.0"));
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session2.getSessionId());
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session2.getSessionId().equalsIgnoreCase("0"));
    assertThat(session2.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES.toArray()));
    session3 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session3.getSessionId());
    assertTrue("Incorrect sessionId", !session3.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session3.getSessionId().equalsIgnoreCase("0"));
    assertThat(session3.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1.toArray()));
    session4 = new NetconfSessionImpl(deviceInfo);
    log.info("Started NETCONF Session {} with test SSHD server in Unit Test", session4.getSessionId());
    assertTrue("Incorrect sessionId", !session4.getSessionId().equalsIgnoreCase("-1"));
    assertTrue("Incorrect sessionId", !session4.getSessionId().equalsIgnoreCase("0"));
    assertThat(session4.getDeviceCapabilitiesSet(), containsInAnyOrder(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1.toArray()));
}
#end_block

#method_before
@AfterClass
public static void tearDown() throws Exception {
    if (session1 != null) {
        session1.close();
    }
    if (session2 != null) {
        session2.close();
    }
    sshServerNetconf.stop();
}
#method_after
@AfterClass
public static void tearDown() throws Exception {
    if (session1 != null) {
        session1.close();
    }
    if (session2 != null) {
        session2.close();
    }
    if (session3 != null) {
        session3.close();
    }
    if (session4 != null) {
        session4.close();
    }
    sshServerNetconf.stop();
}
#end_block

#method_before
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(TargetConfig.RUNNING.toString(), null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#method_after
@Test
public void testEditConfigRequest() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(DatastoreId.RUNNING, null, SAMPLE_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#end_block

#method_before
@Test
public void testEditConfigRequestWithOnlyNewConfiguration() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(EDIT_CONFIG_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#method_after
@Test
public void testEditConfigRequestWithOnlyNewConfiguration() {
    log.info("Starting edit-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF edit-config command failed", session1.editConfig(NetconfSessionMinaImplTest.EDIT_CONFIG_REQUEST));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing edit-config async");
}
#end_block

#method_before
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(TargetConfig.RUNNING));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#method_after
@Test
public void testDeleteConfigRequestWithRunningTargetConfiguration() {
    log.info("Starting delete-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertFalse("NETCONF delete-config command failed", session1.deleteConfig(DatastoreId.RUNNING));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF delete-config test failed: " + e.getMessage());
    }
    log.info("Finishing delete-config async");
}
#end_block

#method_before
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(TargetConfig.RUNNING.toString(), "candidate"));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF edit-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#method_after
@Test
public void testCopyConfigRequest() {
    log.info("Starting copy-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF copy-config command failed", session1.copyConfig(DatastoreId.RUNNING, DatastoreId.CANDIDATE));
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF copy-config test failed: " + e.getMessage());
    }
    log.info("Finishing copy-config async");
}
#end_block

#method_before
@Test
public void testGetConfigRequest() {
    log.info("Starting get-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get-config running command failed. ", GET_REPLY_PATTERN.matcher(session1.getConfig(RUNNING, SAMPLE_REQUEST)).matches());
        assertTrue("NETCONF get-config candidate command failed. ", GET_REPLY_PATTERN.matcher(session1.getConfig(CANDIDATE, SAMPLE_REQUEST)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get-config test failed: " + e.getMessage());
    }
    log.info("Finishing get-config async");
}
#method_after
@Test
public void testGetConfigRequest() {
    log.info("Starting get-config async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get-config running command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.getConfig(RUNNING, SAMPLE_REQUEST)).matches());
        assertTrue("NETCONF get-config candidate command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.getConfig(CANDIDATE, SAMPLE_REQUEST)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get-config test failed: " + e.getMessage());
    }
    log.info("Finishing get-config async");
}
#end_block

#method_before
@Test
public void testGetRequest() {
    log.info("Starting get async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get running command failed. ", GET_REPLY_PATTERN.matcher(session1.get(SAMPLE_REQUEST, null)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get test failed: " + e.getMessage());
    }
    log.info("Finishing get async");
}
#method_after
@Test
public void testGetRequest() {
    log.info("Starting get async");
    assertNotNull("Incorrect sessionId", session1.getSessionId());
    try {
        assertTrue("NETCONF get running command failed. ", NetconfSessionMinaImplTest.GET_REPLY_PATTERN.matcher(session1.get(SAMPLE_REQUEST, null)).matches());
    } catch (NetconfException e) {
        e.printStackTrace();
        fail("NETCONF get test failed: " + e.getMessage());
    }
    log.info("Finishing get async");
}
#end_block

#method_before
public static String getTestHelloReply(Collection<String> capabilities, Optional<Long> sessionId) {
    StringBuffer sb = new StringBuffer();
    sb.append("<hello xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">");
    sb.append("<capabilities>");
    capabilities.forEach(capability -> {
        sb.append("<capability>").append(capability).append("</capability>");
    });
    sb.append("</capabilities>");
    if (sessionId.isPresent()) {
        sb.append("<session-id>");
        sb.append(sessionId.get().toString());
        sb.append("</session-id>");
    }
    sb.append("</hello>");
    return sb.toString();
}
#method_after
public static String getTestHelloReply(Optional<Long> sessionId, boolean useChunkedFraming) {
    if (useChunkedFraming) {
        return getTestHelloReply(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES_1_1, sessionId);
    } else {
        return getTestHelloReply(NetconfSessionMinaImplTest.DEFAULT_CAPABILITIES, sessionId);
    }
}
#end_block

#method_before
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString());
    Matcher capabilityMatcher = CAPABILITY_REGEX_PATTERN.matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        deviceCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = SESSION_ID_REGEX_PATTERN.matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    } else {
        throw new NetconfException("Missing SessionID in server hello " + "reponse.");
    }
}
#method_after
private void sendHello() throws NetconfException {
    serverHelloResponseOld = sendRequest(createHelloString(), true);
    Matcher capabilityMatcher = CAPABILITY_REGEX_PATTERN.matcher(serverHelloResponseOld);
    while (capabilityMatcher.find()) {
        deviceCapabilities.add(capabilityMatcher.group(1));
    }
    sessionID = String.valueOf(-1);
    Matcher sessionIDMatcher = SESSION_ID_REGEX_PATTERN.matcher(serverHelloResponseOld);
    if (sessionIDMatcher.find()) {
        sessionID = sessionIDMatcher.group(1);
    } else {
        throw new NetconfException("Missing SessionID in server hello " + "reponse.");
    }
}
#end_block

#method_before
@Override
public void checkAndReestablish() throws NetconfException {
    if (sshSession.getState() != Channel.STATE_OPEN) {
        try {
            log.debug("Trying to reopen the Sesion with {}", deviceInfo.getDeviceId());
            startSshSession();
        } catch (IOException | IllegalStateException e) {
            log.debug("Trying to reopen the Connection with {}", deviceInfo.getDeviceId());
            try {
                connectionActive = false;
                replies.clear();
                messageIdInteger.set(0);
                startConnection();
                if (subscriptionConnected) {
                    log.debug("Restarting subscription with {}", deviceInfo.getDeviceId());
                    subscriptionConnected = false;
                    startSubscription(notificationFilterSchema);
                }
            } catch (IOException e2) {
                log.error("No connection {} for device {}", netconfConnection, e.getMessage());
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#method_after
@Override
public void checkAndReestablish() throws NetconfException {
    if (sshSession.getState() != Channel.STATE_OPEN) {
        try {
            log.debug("Trying to reopen the Sesion with {}", deviceInfo.getDeviceId());
            startSshSession();
        } catch (IOException | IllegalStateException e) {
            log.debug("Trying to reopen the Connection with {}", deviceInfo.getDeviceId());
            try {
                connectionActive = false;
                replies.clear();
                startConnection();
                if (subscriptionConnected) {
                    log.debug("Restarting subscription with {}", deviceInfo.getDeviceId());
                    subscriptionConnected = false;
                    startSubscription(notificationFilterSchema);
                }
            } catch (IOException e2) {
                log.error("No connection {} for device {}", netconfConnection, e.getMessage());
                throw new NetconfException("Cannot re-open the connection with device" + deviceInfo, e);
            }
        }
    }
}
#end_block

#method_before
@Override
public String requestSync(String request) throws NetconfException {
    if (!request.contains(ENDPATTERN) && !request.contains("##")) {
        request = request + NEW_LINE + ENDPATTERN;
    }
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String requestSync(String request) throws NetconfException {
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request) throws NetconfException {
    request = validateNetconfMessage(request);
    return sendRequest(request, false);
}
#end_block

#method_before
private String sendRequest(String request) throws NetconfException {
    checkAndReestablish();
    final int messageId = messageIdInteger.getAndIncrement();
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException | TimeoutException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatXmlHeader(request);
    request = formatRequestMessageId(request, messageId);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request, e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        // Closes the socket which should interrupt NetconfStreamThread
        netconfConnection.close();
        sshSession.close();
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        replies.clear();
        errorReplies.clear();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    return request;
}
#method_after
private String formatRequestMessageId(String request, int messageId) {
    if (request.contains(MESSAGE_ID_STRING)) {
        // FIXME if application provides his own counting of messages this fails that count
        request = request.replaceFirst(MESSAGE_ID_STRING + EQUAL + NUMBER_BETWEEN_QUOTES_MATCHER, MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"");
    } else if (!request.contains(MESSAGE_ID_STRING) && !request.contains(HELLO)) {
        // FIXME find out a better way to enforce the presence of message-id
        request = request.replaceFirst(END_OF_RPC_OPEN_TAG, "\" " + MESSAGE_ID_STRING + EQUAL + "\"" + messageId + "\"" + ">");
    }
    request = updateRequestLength(request);
    return request;
}
#end_block

#method_before
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        request = XML_HEADER + "\n" + request;
    }
    return request;
}
#method_after
private String formatXmlHeader(String request) {
    if (!request.contains(XML_HEADER)) {
        // FIXME if application provieds his own XML header of different type there is a clash
        if (request.startsWith(LF + HASH)) {
            request = request.split("<")[0] + XML_HEADER + request.substring(request.split("<")[0].length());
        } else {
            request = XML_HEADER + "\n" + request;
        }
    }
    return request;
}
#end_block

#method_before
@Override
public String getConfig(TargetConfig netconfTargetConfig, String configurationSchema) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc ");
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append("xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<get-config>\n");
    rpc.append("<source>\n");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</source>");
    if (configurationSchema != null) {
        rpc.append("<filter type=\"subtree\">\n");
        rpc.append(configurationSchema).append("\n");
        rpc.append("</filter>\n");
    }
    rpc.append("</get-config>\n");
    rpc.append("</rpc>\n");
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    return checkReply(reply) ? reply : "ERROR " + reply;
}
#method_after
@Override
public String getConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    return getConfig(netconfTargetConfig, null);
}
#end_block

#method_before
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration + ENDPATTERN;
    return checkReply(sendRequest(newConfiguration));
}
#method_after
@Override
public boolean editConfig(String newConfiguration) throws NetconfException {
    if (!newConfiguration.endsWith(ENDPATTERN)) {
        newConfiguration = newConfiguration + ENDPATTERN;
    }
    return checkReply(sendRequest(newConfiguration));
}
#end_block

#method_before
@Override
public boolean editConfig(TargetConfig netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#method_after
@Override
public boolean editConfig(DatastoreId netconfTargetConfig, String mode, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(EDIT_CONFIG_OPEN).append("\n");
    rpc.append(TARGET_OPEN);
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append(TARGET_CLOSE).append("\n");
    if (mode != null) {
        rpc.append(DEFAULT_OPERATION_OPEN);
        rpc.append(mode);
        rpc.append(DEFAULT_OPERATION_CLOSE).append("\n");
    }
    rpc.append(CONFIG_OPEN).append("\n");
    rpc.append(newConfiguration);
    rpc.append(CONFIG_CLOSE).append("\n");
    rpc.append(EDIT_CONFIG_CLOSE).append("\n");
    rpc.append(RPC_CLOSE);
    rpc.append(ENDPATTERN);
    log.debug(rpc.toString());
    String reply = sendRequest(rpc.toString());
    return checkReply(reply);
}
#end_block

#method_before
@Override
public boolean copyConfig(TargetConfig netconfTargetConfig, String newConfiguration) throws NetconfException {
    newConfiguration = newConfiguration.trim();
    if (!newConfiguration.startsWith("<config>")) {
        newConfiguration = "<config>" + newConfiguration + "</config>";
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append("<copy-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("<source>");
    rpc.append(newConfiguration);
    rpc.append("</source>");
    rpc.append("</copy-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean copyConfig(DatastoreId destination, DatastoreId source) throws NetconfException {
    return bareCopyConfig(destination.asXml(), source.asXml());
}
#end_block

#method_before
@Override
public boolean copyConfig(String netconfTargetConfig, String newConfiguration) throws NetconfException {
    return copyConfig(TargetConfig.toTargetConfig(netconfTargetConfig), newConfiguration);
}
#method_after
@Override
public boolean copyConfig(String netconfTargetConfig, String newConfiguration) throws NetconfException {
    return bareCopyConfig(normalizeCopyConfigParam(netconfTargetConfig), normalizeCopyConfigParam(newConfiguration));
}
#end_block

#method_before
@Override
public boolean deleteConfig(TargetConfig netconfTargetConfig) throws NetconfException {
    if (netconfTargetConfig.equals(TargetConfig.RUNNING)) {
        log.warn("Target configuration for delete operation can't be \"running\"", netconfTargetConfig);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean deleteConfig(DatastoreId netconfTargetConfig) throws NetconfException {
    if (netconfTargetConfig.equals(DatastoreId.RUNNING)) {
        log.warn("Target configuration for delete operation can't be \"running\"", netconfTargetConfig);
        return false;
    }
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<delete-config>");
    rpc.append("<target>");
    rpc.append("<").append(netconfTargetConfig).append("/>");
    rpc.append("</target>");
    rpc.append("</delete-config>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#end_block

#method_before
@Override
public boolean lock() throws NetconfException {
    return lock("running");
}
#method_after
@Override
public boolean lock(DatastoreId configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<lock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType.id());
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</lock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String lockReply = sendRequest(rpc.toString());
    return checkReply(lockReply);
}
#end_block

#method_before
@Override
public boolean unlock() throws NetconfException {
    return unlock("running");
}
#method_after
@Override
public boolean unlock(DatastoreId configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<unlock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType.id());
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</unlock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String unlockReply = sendRequest(rpc.toString());
    return checkReply(unlockReply);
}
#end_block

#method_before
@Override
public void event(NetconfDeviceOutputEvent event) {
    primaryListeners.forEach(lsnr -> {
        if (lsnr.isRelevant(event)) {
            lsnr.event(event);
        }
    });
}
#method_after
@Override
public void event(NetconfDeviceOutputEvent event) {
    publishEvent(event);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    serializer = Serializer.using(KryoNamespaces.API);
    asyncConsistentMap = new AsyncConsistMapMock<>();
    name = "Default Name";
    map = new HashMap<>();
    collection = new ArrayList<>();
    set = new HashSet<>();
    defaultAsyncDistributedSet = new DefaultAsyncDistributedSet<>(asyncConsistentMap, name, MAGENT);
}
#method_after
@Before
public void setUp() throws Exception {
    serializer = Serializer.using(KryoNamespaces.API);
    asyncConsistentMap = new AsyncConsistentMapMock<>();
    name = "Default Name";
    map = new HashMap<>();
    collection = new ArrayList<>();
    set = new HashSet<>();
    defaultAsyncDistributedSet = new DefaultAsyncDistributedSet<>(asyncConsistentMap, name, MAGENT);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    serializer = Serializer.using(KryoNamespaces.API);
    map = new HashMap<>();
    baseMap = new AsyncConsistMapMock<>();
    transcodingMap = DistributedPrimitives.newTranscodingMap(baseMap, Function.identity(), Function.identity(), serializer::encode, serializer::decode);
}
#method_after
@Before
public void setUp() throws Exception {
    serializer = Serializer.using(KryoNamespaces.API);
    map = new HashMap<>();
    baseMap = new AsyncConsistentMapMock<>();
    transcodingMap = DistributedPrimitives.newTranscodingMap(baseMap, Function.identity(), Function.identity(), serializer::encode, serializer::decode);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    asyncMap = new AsyncConsistMapMock<>();
    serializer = Serializer.using(KryoNamespaces.BASIC);
    meteringAgent = new MeteringAgent(NAME, "*", false);
    defaultAsyncAtomicValue = new DefaultAsyncAtomicValue(MAPNAME, serializer, asyncMap, meteringAgent);
}
#method_after
@Before
public void setUp() throws Exception {
    asyncMap = new AsyncConsistentMapMock<>();
    serializer = Serializer.using(KryoNamespaces.BASIC);
    meteringAgent = new MeteringAgent(NAME, "*", false);
    defaultAsyncAtomicValue = new DefaultAsyncAtomicValue(MAPNAME, serializer, asyncMap, meteringAgent);
}
#end_block

#method_before
private void pushFlowMetricsInternal(DeviceId deviceId, Iterable<FlowEntry> flowEntries, boolean useMissingFlow) {
    Map<FlowEntry, FlowEntry> storedRules = Maps.newHashMap();
    store.getFlowEntries(deviceId).forEach(f -> storedRules.put(f, f));
    for (FlowEntry rule : flowEntries) {
        try {
            FlowEntry storedRule = storedRules.remove(rule);
            if (storedRule != null) {
                if (storedRule.exactMatch(rule)) {
                    // we both have the rule, let's update some info then.
                    flowAdded(rule);
                } else {
                    // the two rules are not an exact match - remove the
                    // switch's rule and install our rule
                    extraneousFlow(rule);
                    flowMissing(storedRule);
                }
            } else {
                // the device has a rule the store does not have
                if (!allowExtraneousRules) {
                    extraneousFlow(rule);
                }
            }
        } catch (Exception e) {
            log.warn("Can't process added or extra rule {} for device {}:", rule, deviceId, e);
        }
    }
    // DO NOT reinstall
    if (useMissingFlow) {
        for (FlowEntry rule : storedRules.keySet()) {
            try {
                // there are rules in the store that aren't on the switch
                log.debug("Adding rule in store, but not on switch {}", rule);
                flowMissing(rule);
            } catch (Exception e) {
                log.warn("Can't add missing flow rule:", e);
            }
        }
    }
}
#method_after
private void pushFlowMetricsInternal(DeviceId deviceId, Iterable<FlowEntry> flowEntries, boolean useMissingFlow) {
    Map<FlowEntry, FlowEntry> storedRules = Maps.newHashMap();
    store.getFlowEntries(deviceId).forEach(f -> storedRules.put(f, f));
    for (FlowEntry rule : flowEntries) {
        try {
            FlowEntry storedRule = storedRules.remove(rule);
            if (storedRule != null) {
                if (storedRule.exactMatch(rule)) {
                    // we both have the rule, let's update some info then.
                    flowAdded(rule);
                } else {
                    // the two rules are not an exact match - remove the
                    // switch's rule and install our rule
                    extraneousFlow(rule);
                    flowMissing(storedRule);
                }
            } else {
                // the device has a rule the store does not have
                if (!allowExtraneousRules) {
                    extraneousFlow(rule);
                }
            }
        } catch (Exception e) {
            log.warn("Can't process added or extra rule {} for device {}:{}", rule, deviceId, e);
        }
    }
    // DO NOT reinstall
    if (useMissingFlow) {
        for (FlowEntry rule : storedRules.keySet()) {
            try {
                // there are rules in the store that aren't on the switch
                log.debug("Adding rule in store, but not on switch {}", rule);
                flowMissing(rule);
            } catch (Exception e) {
                log.warn("Can't add missing flow rule:", e);
            }
        }
    }
}
#end_block

#method_before
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    } else {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    if (portCriterion == null) {
        log.warn("No IN_PORT defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.BADPARAMS);
        return;
    }
    log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vidCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filt, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.warn("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#method_after
// ////////////////////////////////////
// Flow handling
// ////////////////////////////////////
protected void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // This driver only processes filtering criteria defined with switch
    // ports as the key
    PortCriterion portCriterion = null;
    EthCriterion ethCriterion = null;
    VlanIdCriterion vidCriterion = null;
    if (!filt.key().equals(Criteria.dummy()) && filt.key().type() == Criterion.Type.IN_PORT) {
        portCriterion = (PortCriterion) filt.key();
    }
    if (portCriterion == null) {
        log.debug("No IN_PORT defined in filtering objective from app: {}", applicationId);
    } else {
        log.debug("Received filtering objective for dev/port: {}/{}", deviceId, portCriterion.port());
    }
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        switch(criterion.type()) {
            case ETH_DST:
            case ETH_DST_MASKED:
                ethCriterion = (EthCriterion) criterion;
                break;
            case VLAN_VID:
                vidCriterion = (VlanIdCriterion) criterion;
                break;
            default:
                log.warn("Unsupported filter {}", criterion);
                fail(filt, ObjectiveError.UNSUPPORTED);
                return;
        }
    }
    VlanId assignedVlan = null;
    if (vidCriterion != null) {
        // Use the VLAN in metadata whenever a metadata is provided
        if (filt.meta() != null) {
            assignedVlan = readVlanFromTreatment(filt.meta());
        // Use the VLAN in criterion if metadata is not present and the traffic is tagged
        } else if (!vidCriterion.vlanId().equals(VlanId.NONE)) {
            assignedVlan = vidCriterion.vlanId();
        }
        if (assignedVlan == null) {
            log.error("Driver fails to extract VLAN information. " + "Not proccessing VLAN filters on device {}.", deviceId);
            log.debug("VLAN ID in criterion={}, metadata={}", readVlanFromTreatment(filt.meta()), vidCriterion.vlanId());
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null || ethCriterion.mac().equals(NONE)) {
        // NOTE: it is possible that a filtering objective only has vidCriterion
        log.warn("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(portCriterion, ethCriterion, vidCriterion, assignedVlan, applicationId)) {
            log.trace("{} MAC filtering rules in TMAC table: {} for dev: {}", (install) ? "adding" : "removing", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vidCriterion == null) {
        // NOTE: it is possible that a filtering objective only has ethCriterion
        log.info("filtering objective missing VLAN, cannot program VLAN Table");
    } else {
        /*
             * NOTE: Separate vlan filtering rules and assignment rules
             * into different stage in order to guarantee that filtering rules
             * always go first, as required by ofdpa.
             */
        List<FlowRule> allRules = processVlanIdFilter(portCriterion, vidCriterion, assignedVlan, applicationId);
        List<FlowRule> filteringRules = new ArrayList<>();
        List<FlowRule> assignmentRules = new ArrayList<>();
        allRules.forEach(flowRule -> {
            VlanId vlanId;
            if (requireVlanExtensions()) {
                ExtensionCriterion extCriterion = (ExtensionCriterion) flowRule.selector().getCriterion(Criterion.Type.EXTENSION);
                vlanId = ((OfdpaMatchVlanVid) extCriterion.extensionSelector()).vlanId();
            } else {
                VlanIdCriterion vlanIdCriterion = (VlanIdCriterion) flowRule.selector().getCriterion(Criterion.Type.VLAN_VID);
                vlanId = vlanIdCriterion.vlanId();
            }
            if (!vlanId.equals(VlanId.NONE)) {
                filteringRules.add(flowRule);
            } else {
                assignmentRules.add(flowRule);
            }
        });
        for (FlowRule filteringRule : filteringRules) {
            log.trace("{} VLAN filtering rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", filteringRule, deviceId);
            ops = install ? ops.add(filteringRule) : ops.remove(filteringRule);
        }
        ops.newStage();
        for (FlowRule assignmentRule : assignmentRules) {
            log.trace("{} VLAN assignment rule in VLAN table: {} for dev: {}", (install) ? "adding" : "removing", assignmentRule, deviceId);
            ops = install ? ops.add(assignmentRule) : ops.remove(assignmentRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            log.debug("Applied {} filtering rules in device {}", ops.stages().get(0).size(), deviceId);
            pass(filt);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            log.info("Failed to apply all filtering rules in dev {}", deviceId);
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
        }
    }));
}
#end_block

#method_before
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && PortNumber.ANY.equals(portCriterion.port())) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion != null && vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (PortNumber.ALL.equals(portCriterion.port())) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
    } else {
        log.warn("Filtering Objective missing Port Criterion ." + " TMAC Table cannot be programmed for {}", deviceId);
    }
    List<FlowRule> rules = new ArrayList<>();
    for (PortNumber pnum : portnums) {
        OfdpaMatchVlanVid ofdpaMatchVlanVid = null;
        if (vidCriterion != null) {
            ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
        }
        // for unicast IP packets
        TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (vidCriterion != null) {
            if (requireVlanExtensions()) {
                selector.extension(ofdpaMatchVlanVid, deviceId);
            } else {
                selector.matchVlanId(vidCriterion.vlanId());
            }
        }
        selector.matchEthType(Ethernet.TYPE_IPV4);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        // for MPLS packets
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (vidCriterion != null) {
            if (requireVlanExtensions()) {
                selector.extension(ofdpaMatchVlanVid, deviceId);
            } else {
                selector.matchVlanId(vidCriterion.vlanId());
            }
        }
        selector.matchEthType(Ethernet.MPLS_UNICAST);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(MPLS_TABLE_0);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
        /*
             * TMAC rules for IPv6 packets
             */
        selector = DefaultTrafficSelector.builder();
        treatment = DefaultTrafficTreatment.builder();
        if (matchInPortTmacTable()) {
            selector.matchInPort(pnum);
        }
        if (vidCriterion != null) {
            if (requireVlanExtensions()) {
                selector.extension(ofdpaMatchVlanVid, deviceId);
            } else {
                selector.matchVlanId(vidCriterion.vlanId());
            }
        }
        selector.matchEthType(Ethernet.TYPE_IPV6);
        selector.matchEthDst(ethCriterion.mac());
        treatment.transition(UNICAST_ROUTING_TABLE);
        rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(TMAC_TABLE).build();
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processEthDstFilter(PortCriterion portCriterion, EthCriterion ethCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    // Consider PortNumber.ANY as wildcard. Match ETH_DST only
    if (portCriterion != null && PortNumber.ANY.equals(portCriterion.port())) {
        return processEthDstOnlyFilter(ethCriterion, applicationId);
    }
    // Multicast MAC
    if (ethCriterion.mask() != null) {
        return processMcastEthDstFilter(ethCriterion, applicationId);
    }
    // handling untagged packets via assigned VLAN
    if (vidCriterion != null && vidCriterion.vlanId() == VlanId.NONE) {
        vidCriterion = (VlanIdCriterion) Criteria.matchVlanId(assignedVlan);
    }
    List<FlowRule> rules = new ArrayList<>();
    OfdpaMatchVlanVid ofdpaMatchVlanVid = null;
    if (vidCriterion != null && requireVlanExtensions()) {
        ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null) {
        if (PortNumber.ALL.equals(portCriterion.port())) {
            for (Port port : deviceService.getPorts(deviceId)) {
                if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                    portnums.add(port.number());
                }
            }
        } else {
            portnums.add(portCriterion.port());
        }
        for (PortNumber pnum : portnums) {
            rules.add(buildTmacRuleForIpv4(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
            rules.add(buildTmacRuleForMpls(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
            rules.add(buildTmacRuleForIpv6(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, pnum));
        }
    } else {
        rules.add(buildTmacRuleForIpv4(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
        rules.add(buildTmacRuleForMpls(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
        rules.add(buildTmacRuleForIpv6(ethCriterion, vidCriterion, ofdpaMatchVlanVid, applicationId, null));
    }
    return rules;
}
#end_block

#method_before
public static String parseResId(ResourceId path) {
    StringBuilder bldr = new StringBuilder();
    bldr.append(ROOT);
    if (path == null) {
        return bldr.toString();
    }
    List<NodeKey> nodeKeyList = path.nodeKeys();
    for (NodeKey key : nodeKeyList) {
        bldr.append(EL_SEP);
        if (key instanceof LeafListKey) {
            parseLeafList((LeafListKey) key, bldr);
        } else if (key instanceof ListKey) {
            parseKeyList((ListKey) key, bldr);
        } else {
            parseNodeKey(key, bldr);
        }
    }
    return bldr.toString();
}
#method_after
public static String parseResId(ResourceId path) {
    StringBuilder bldr = new StringBuilder();
    bldr.append(ROOT);
    if (path == null) {
        return bldr.toString();
    }
    List<NodeKey> nodeKeyList = new LinkedList<>();
    Iterator<NodeKey> itr = path.nodeKeys().iterator();
    while (itr.hasNext()) {
        nodeKeyList.add(itr.next());
    }
    if (nodeKeyList.get(0).schemaId().name().compareTo("/") == 0) {
        nodeKeyList.remove(0);
    }
    for (NodeKey key : nodeKeyList) {
        bldr.append(EL_SEP);
        if (key instanceof LeafListKey) {
            parseLeafList((LeafListKey) key, bldr);
        } else if (key instanceof ListKey) {
            parseKeyList((ListKey) key, bldr);
        } else {
            parseNodeKey(key, bldr);
        }
    }
    return bldr.toString();
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    log.info("getting device description");
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.SWITCH, device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), device.chassisId());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    log.debug("getting device description");
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        return new DefaultDeviceDescription(deviceId.uri(), Device.Type.OTN, "Ciena", "WaveServer", "Unknown", "Unknown", new ChassisId());
    } else {
        return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTN, device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), device.chassisId());
    }
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, DHCP6 dhcp6Payload) {
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket dhcp6Payload) {
}
#end_block

#method_before
@Override
public Optional<Ip6Address> getDhcpServerIp() {
    return null;
}
#method_after
@Override
public Optional<IpAddress> getDhcpServerIp() {
    return null;
}
#end_block

#method_before
@Override
public Optional<Ip6Address> getDhcpGatewayIp() {
    return null;
}
#method_after
@Override
public Optional<IpAddress> getDhcpGatewayIp() {
    return null;
}
#end_block

#method_before
@Override
public void setDhcpGatewayIp(Ip6Address dhcpGatewayIp) {
}
#method_after
@Override
public void setDhcpGatewayIp(IpAddress dhcpGatewayIp) {
}
#end_block

#method_before
@Override
public void setDhcpServerIp(Ip6Address dhcpServerIp) {
}
#method_after
@Override
public void setDhcpServerIp(IpAddress dhcpServerIp) {
}
#end_block

#method_before
private void updateConfig() {
    DhcpRelayConfig cfg = cfgService.getConfig(appId, DhcpRelayConfig.class);
    if (cfg == null) {
        log.warn("Dhcp Server info not available");
        return;
    }
    Optional<Ip4Address> oldDhcpServerIp = v4Handler.getDhcpServerIp();
    Optional<Ip4Address> oldDhcpGatewayIp = v4Handler.getDhcpGatewayIp();
    v4Handler.setDhcpServerConnectPoint(cfg.getDhcpServerConnectPoint());
    v4Handler.setDhcpServerIp(cfg.getDhcpServerIp());
    v4Handler.setDhcpGatewayIp(cfg.getDhcpGatewayIp());
    v4Handler.setDhcpConnectMac(null);
    v4Handler.setDhcpConnectVlan(null);
    log.info("DHCP server connect point: " + cfg.getDhcpServerConnectPoint());
    log.info("DHCP server ipaddress " + cfg.getDhcpServerIp());
    IpAddress ipToProbe = v4Handler.getDhcpGatewayIp().isPresent() ? cfg.getDhcpGatewayIp() : cfg.getDhcpServerIp();
    String hostToProbe = v4Handler.getDhcpGatewayIp().isPresent() ? "gateway" : "DHCP server";
    // TODO: DHCPv6 server config
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (hosts.isEmpty()) {
        log.info("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        oldDhcpGatewayIp.ifPresent(hostService::stopMonitoringIp);
        oldDhcpServerIp.ifPresent(hostService::stopMonitoringIp);
        hostService.startMonitoringIp(ipToProbe);
    } else {
        // Probe target is known; There should be only 1 host with this ip
        hostUpdated(hosts.iterator().next());
    }
}
#method_after
private void updateConfig() {
    DhcpRelayConfig cfg = cfgService.getConfig(appId, DhcpRelayConfig.class);
    if (cfg == null) {
        log.warn("Dhcp Server info not available");
        return;
    }
    Optional<IpAddress> oldDhcpServerIp = v4Handler.getDhcpServerIp();
    Optional<IpAddress> oldDhcpGatewayIp = v4Handler.getDhcpGatewayIp();
    v4Handler.setDhcpServerConnectPoint(cfg.getDhcpServerConnectPoint());
    v4Handler.setDhcpServerIp(cfg.getDhcpServerIp());
    v4Handler.setDhcpGatewayIp(cfg.getDhcpGatewayIp());
    v4Handler.setDhcpConnectMac(null);
    v4Handler.setDhcpConnectVlan(null);
    log.info("DHCP server connect point: " + cfg.getDhcpServerConnectPoint());
    log.info("DHCP server ipaddress " + cfg.getDhcpServerIp());
    IpAddress ipToProbe = v4Handler.getDhcpGatewayIp().isPresent() ? cfg.getDhcpGatewayIp() : cfg.getDhcpServerIp();
    String hostToProbe = v4Handler.getDhcpGatewayIp().isPresent() ? "gateway" : "DHCP server";
    // TODO: DHCPv6 server config
    Set<Host> hosts = hostService.getHostsByIp(ipToProbe);
    if (hosts.isEmpty()) {
        log.info("Probing to resolve {} IP {}", hostToProbe, ipToProbe);
        oldDhcpGatewayIp.ifPresent(hostService::stopMonitoringIp);
        oldDhcpServerIp.ifPresent(hostService::stopMonitoringIp);
        hostService.startMonitoringIp(ipToProbe);
    } else {
        // Probe target is known; There should be only 1 host with this ip
        hostUpdated(hosts.iterator().next());
    }
}
#end_block

#method_before
@Override
public void setDhcpServerIp(Ip4Address dhcpServerIp) {
    this.dhcpServerIp = dhcpServerIp;
}
#method_after
@Override
public void setDhcpServerIp(IpAddress dhcpServerIp) {
    checkNotNull(dhcpServerIp, "DHCP server IP can't be null");
    checkState(dhcpServerIp.isIp4(), "Invalid server IP for DHCPv4 relay handler");
    this.dhcpServerIp = dhcpServerIp.getIp4Address();
}
#end_block

#method_before
@Override
public void setDhcpServerConnectPoint(ConnectPoint dhcpServerConnectPoint) {
    this.dhcpServerConnectPoint = dhcpServerConnectPoint;
}
#method_after
@Override
public void setDhcpServerConnectPoint(ConnectPoint dhcpServerConnectPoint) {
    checkNotNull(dhcpServerConnectPoint, "Server connect point can't null");
    this.dhcpServerConnectPoint = dhcpServerConnectPoint;
}
#end_block

#method_before
@Override
public void setDhcpGatewayIp(Ip4Address dhcpGatewayIp) {
    this.dhcpGatewayIp = dhcpGatewayIp;
}
#method_after
@Override
public void setDhcpGatewayIp(IpAddress dhcpGatewayIp) {
    if (dhcpGatewayIp != null) {
        checkState(dhcpGatewayIp.isIp4(), "Invalid gateway IP for DHCPv4 relay handler");
        this.dhcpGatewayIp = dhcpGatewayIp.getIp4Address();
    } else {
        // removes gateway config
        this.dhcpGatewayIp = null;
    }
}
#end_block

#method_before
@Override
public Optional<Ip4Address> getDhcpServerIp() {
    return Optional.ofNullable(dhcpServerIp);
}
#method_after
@Override
public Optional<IpAddress> getDhcpServerIp() {
    return Optional.ofNullable(dhcpServerIp);
}
#end_block

#method_before
@Override
public Optional<Ip4Address> getDhcpGatewayIp() {
    return Optional.ofNullable(dhcpGatewayIp);
}
#method_after
@Override
public Optional<IpAddress> getDhcpGatewayIp() {
    return Optional.ofNullable(dhcpGatewayIp);
}
#end_block

#method_before
@Override
public void processDhcpPacket(PacketContext context, DHCP dhcpPayload) {
    if (!configured()) {
        log.warn("Missing DHCP relay server config. Abort packet processing");
        return;
    }
    ConnectPoint inPort = context.inPacket().receivedFrom();
    Set<Interface> clientServerInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (clientServerInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCP.MsgType incomingPacketType = dhcpPayload.getOptions().stream().filter(dhcpOption -> dhcpOption.getCode() == OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> DHCP.MsgType.getType(data[0])).findFirst().orElse(null);
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // add the gatewayip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketDiscover = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketDiscover != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketDiscover);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(packet);
            if (ethernetPacketOffer != null) {
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload);
                handleDhcpOffer(ethernetPacketOffer, dhcpPayload);
            }
            break;
        case DHCPREQUEST:
            // add the gateway ip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketRequest = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketRequest != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketRequest);
            }
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(packet);
            if (ethernetPacketAck != null) {
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload);
                handleDhcpAck(ethernetPacketAck, dhcpPayload);
            }
            break;
        case DHCPRELEASE:
            // TODO: release the ip address from client
            break;
        default:
            break;
    }
}
#method_after
@Override
public void processDhcpPacket(PacketContext context, BasePacket payload) {
    checkNotNull(payload, "DHCP payload can't be null");
    checkState(payload instanceof DHCP, "Payload is not a DHCP");
    DHCP dhcpPayload = (DHCP) payload;
    if (!configured()) {
        log.warn("Missing DHCP relay server config. Abort packet processing");
        return;
    }
    ConnectPoint inPort = context.inPacket().receivedFrom();
    Set<Interface> clientServerInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (clientServerInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCP.MsgType incomingPacketType = dhcpPayload.getOptions().stream().filter(dhcpOption -> dhcpOption.getCode() == OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> DHCP.MsgType.getType(data[0])).findFirst().orElse(null);
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // add the gatewayip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketDiscover = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketDiscover != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketDiscover);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(packet);
            if (ethernetPacketOffer != null) {
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload);
                handleDhcpOffer(ethernetPacketOffer, dhcpPayload);
            }
            break;
        case DHCPREQUEST:
            // add the gateway ip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketRequest = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketRequest != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketRequest);
            }
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(packet);
            if (ethernetPacketAck != null) {
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload);
                handleDhcpAck(ethernetPacketAck, dhcpPayload);
            }
            break;
        case DHCPRELEASE:
            // TODO: release the ip address from client
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    if (eth == null) {
        return;
    }
    MacAddress srcMac = eth.getSourceMAC();
    if (srcMac.isBroadcast() || srcMac.isMulticast()) {
        return;
    }
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this arrived on control port, bail out.
    if (heardOn.port().isLogical()) {
        return;
    }
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        createOrUpdateHost(hid, srcMac, vlan, hloc, ip);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        DHCP dhcp = findDhcp(eth).orElse(null);
        if (dhcp != null) {
            if (useDhcp) {
                // learn host (server or client) MAC address
                createOrUpdateHost(hid, srcMac, vlan, hloc, null);
                // DHCP ACK: additionally update IP of DHCP client
                if (dhcp.getPacketType().equals(DHCP.MsgType.DHCPACK)) {
                    MacAddress hostMac = MacAddress.valueOf(dhcp.getClientHardwareAddress());
                    VlanId hostVlan = VlanId.vlanId(eth.getVlanID());
                    HostId hostId = HostId.hostId(hostMac, hostVlan);
                    updateHostIp(hostId, IpAddress.valueOf(dhcp.getYourIPAddress()));
                }
            }
        } else {
            // learn host MAC address
            createOrUpdateHost(hid, srcMac, vlan, hloc, null);
        }
    // 
    // NeighborAdvertisement and NeighborSolicitation: possible
    // new hosts, update both location and IP.
    // 
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6 = (IPv6) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET6, ipv6.getSourceAddress());
        // skip extension headers
        IPacket pkt = ipv6;
        while (pkt.getPayload() != null && pkt.getPayload() instanceof IExtensionHeader) {
            pkt = pkt.getPayload();
        }
        pkt = pkt.getPayload();
        // DHCPv6 protocol
        DHCP6 dhcp6 = findDhcp6(pkt).orElse(null);
        if (dhcp6 != null) {
            if (useDhcp6) {
                createOrUpdateHost(hid, srcMac, vlan, hloc, null);
                // decap the relay message if exist
                while (dhcp6 != null && DHCP6.RELAY_MSG_TYPES.contains(dhcp6.getMsgType())) {
                    dhcp6 = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6RelayOption).map(BasePacket::getPayload).map(pld -> (DHCP6) pld).findFirst().orElse(null);
                }
                if (dhcp6 == null) {
                    // Can't fin dhcp payload
                    log.warn("Can't find dhcp payload from relay message");
                    return;
                }
                if (dhcp6.getMsgType() != DHCP6.MsgType.REPLY.value()) {
                    // Update IP address only when we received REPLY message
                    return;
                }
                Optional<Dhcp6ClientIdOption> clientIdOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6ClientIdOption).map(opt -> (Dhcp6ClientIdOption) opt).findFirst();
                if (!clientIdOption.isPresent()) {
                    // invalid DHCPv6 option
                    log.warn("Can't find client ID from DHCPv6 {}", dhcp6);
                    return;
                }
                byte[] linkLayerAddr = clientIdOption.get().getDuid().getLinkLayerAddress();
                if (linkLayerAddr == null || linkLayerAddr.length != 6) {
                    // No any mac address found
                    log.warn("Can't find client mac from option {}", clientIdOption);
                    return;
                }
                MacAddress clientMac = MacAddress.valueOf(linkLayerAddr);
                // Extract IPv6 address from IA NA ot IA TA option
                Optional<Dhcp6IaNaOption> iaNaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaNaOption).map(opt -> (Dhcp6IaNaOption) opt).findFirst();
                Optional<Dhcp6IaTaOption> iaTaOption = dhcp6.getOptions().stream().filter(opt -> opt instanceof Dhcp6IaTaOption).map(opt -> (Dhcp6IaTaOption) opt).findFirst();
                Optional<Dhcp6IaAddressOption> iaAddressOption;
                if (iaNaOption.isPresent()) {
                    iaAddressOption = iaNaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
                } else if (iaTaOption.isPresent()) {
                    iaAddressOption = iaTaOption.get().getOptions().stream().filter(opt -> opt instanceof Dhcp6IaAddressOption).map(opt -> (Dhcp6IaAddressOption) opt).findFirst();
                } else {
                    iaAddressOption = Optional.empty();
                }
                if (iaAddressOption.isPresent()) {
                    ip = iaAddressOption.get().getIp6Address();
                    HostId hostId = HostId.hostId(clientMac, VlanId.vlanId(eth.getVlanID()));
                    updateHostIp(hostId, ip);
                } else {
                    log.warn("Can't find IPv6 address from DHCPv6 {}", dhcp6);
                }
                return;
            }
        }
        if (pkt != null && pkt instanceof ICMP6) {
            // Neighbor Discovery Protocol
            pkt = pkt.getPayload();
            // RouterSolicitation, RouterAdvertisement
            if (pkt != null && (pkt instanceof RouterAdvertisement || pkt instanceof RouterSolicitation)) {
                return;
            }
            if (pkt != null && (pkt instanceof NeighborSolicitation || pkt instanceof NeighborAdvertisement)) {
                // Duplicate Address Detection
                if (ip.isZero()) {
                    return;
                }
                // NeighborSolicitation, NeighborAdvertisement
                createOrUpdateHost(hid, srcMac, vlan, hloc, ip);
                return;
            }
        }
        // multicast
        if (eth.isMulticast()) {
            return;
        }
        // normal IPv6 packets
        createOrUpdateHost(hid, srcMac, vlan, hloc, null);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    if (eth == null) {
        return;
    }
    MacAddress srcMac = eth.getSourceMAC();
    if (srcMac.isBroadcast() || srcMac.isMulticast()) {
        return;
    }
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this arrived on control port, bail out.
    if (heardOn.port().isLogical()) {
        return;
    }
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        createOrUpdateHost(hid, srcMac, vlan, hloc, ip);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        DHCP dhcp = findDhcp(eth).orElse(null);
        if (dhcp != null) {
            if (useDhcp) {
                // learn host (server or client) MAC address
                createOrUpdateHost(hid, srcMac, vlan, hloc, null);
                // DHCP ACK: additionally update IP of DHCP client
                if (dhcp.getPacketType().equals(DHCP.MsgType.DHCPACK)) {
                    MacAddress hostMac = MacAddress.valueOf(dhcp.getClientHardwareAddress());
                    VlanId hostVlan = VlanId.vlanId(eth.getVlanID());
                    HostId hostId = HostId.hostId(hostMac, hostVlan);
                    updateHostIp(hostId, IpAddress.valueOf(dhcp.getYourIPAddress()));
                }
            }
        } else {
            // learn host MAC address
            createOrUpdateHost(hid, srcMac, vlan, hloc, null);
        }
    // 
    // NeighborAdvertisement and NeighborSolicitation: possible
    // new hosts, update both location and IP.
    // 
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IPv6 ipv6 = (IPv6) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET6, ipv6.getSourceAddress());
        // skip extension headers
        IPacket pkt = ipv6;
        while (pkt.getPayload() != null && pkt.getPayload() instanceof IExtensionHeader) {
            pkt = pkt.getPayload();
        }
        pkt = pkt.getPayload();
        // DHCPv6 protocol
        DHCP6 dhcp6 = findDhcp6(pkt).orElse(null);
        if (dhcp6 != null && useDhcp6) {
            createOrUpdateHost(hid, srcMac, vlan, hloc, null);
            handleDhcp6(dhcp6, vlan);
            return;
        }
        if (pkt != null && pkt instanceof ICMP6) {
            // Neighbor Discovery Protocol
            pkt = pkt.getPayload();
            // RouterSolicitation, RouterAdvertisement
            if (pkt != null && (pkt instanceof RouterAdvertisement || pkt instanceof RouterSolicitation)) {
                return;
            }
            if (pkt != null && (pkt instanceof NeighborSolicitation || pkt instanceof NeighborAdvertisement)) {
                // Duplicate Address Detection
                if (ip.isZero()) {
                    return;
                }
                // NeighborSolicitation, NeighborAdvertisement
                createOrUpdateHost(hid, srcMac, vlan, hloc, ip);
                return;
            }
        }
        // multicast
        if (eth.isMulticast()) {
            return;
        }
        // normal IPv6 packets
        createOrUpdateHost(hid, srcMac, vlan, hloc, null);
    }
}
#end_block

#method_before
protected void populateSubnet(Set<ConnectPoint> cpts, Set<IpPrefix> subnets) {
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceed with routing rules for added routes");
            return;
        }
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        log.info("Starting to populate routing rules for added routes");
        // Take snapshots of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        Set<ArrayList<DeviceId>> routeChanges = new HashSet<>();
        boolean handleRouting = false;
        if (cpts.size() == 2) {
            // ensure connect points are edge-pairs
            Iterator<ConnectPoint> iter = cpts.iterator();
            DeviceId dev1 = iter.next().deviceId();
            DeviceId pairDev = getPairDev(dev1);
            if (iter.next().deviceId().equals(pairDev)) {
                edgePairs.add(new EdgePair(dev1, pairDev));
            } else {
                log.warn("Connectpoints {} for subnets {} not on " + "pair-devices.. aborting populateSubnet", cpts, subnets);
                populationStatus = Status.ABORTED;
                return;
            }
            for (ConnectPoint cp : cpts) {
                EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(cp.deviceId(), srManager);
                updatedEcmpSpgMap.put(cp.deviceId(), ecmpSpgUpdated);
                DeviceId retId = shouldHandleRouting(cp.deviceId());
                if (retId == null) {
                    continue;
                }
                handleRouting = true;
            }
        } else {
            // single connect point
            DeviceId dstSw = cpts.iterator().next().deviceId();
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(dstSw, srManager);
            updatedEcmpSpgMap.put(dstSw, ecmpSpgUpdated);
            if (srManager.mastershipService.isLocalMaster(dstSw)) {
                handleRouting = true;
            }
        }
        if (!handleRouting) {
            log.debug("This instance is not handling ecmp routing to the " + "connectPoint(s) {}", cpts);
            populationStatus = Status.ABORTED;
            return;
        }
        // 2. if target is one of the connectpoints
        for (ConnectPoint cp : cpts) {
            DeviceId dstSw = cp.deviceId();
            for (Device targetSw : srManager.deviceService.getDevices()) {
                boolean isEdge = false;
                try {
                    isEdge = config.isEdgeDevice(targetSw.id());
                } catch (DeviceConfigNotFoundException e) {
                    log.warn(e.getMessage() + "aborting populateSubnet");
                    populationStatus = Status.ABORTED;
                    return;
                }
                if (dstSw.equals(targetSw.id()) || !isEdge || (cpts.size() == 2 && targetSw.id().equals(getPairDev(dstSw)))) {
                    continue;
                }
                routeChanges.add(Lists.newArrayList(targetSw.id(), dstSw));
            }
        }
        if (!redoRouting(routeChanges, edgePairs, subnets)) {
            log.debug("populateSubnet: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules for subnet.");
            return;
        }
        log.debug("populateSubnet: populationStatus is SUCCEEDED");
        populationStatus = Status.SUCCEEDED;
        log.info("Completed subnet population. Total # of rules pushed : {}", rulePopulator.getCounter());
        return;
    } finally {
        statusLock.unlock();
    }
}
#method_after
/**
 * Populate rules from all other edge devices to the connect-point(s)
 * specified for the given subnets.
 *
 * @param cpts connect point(s) of the subnets being added
 * @param subnets subnets being added
 */
protected void populateSubnet(Set<ConnectPoint> cpts, Set<IpPrefix> subnets) {
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceed with routing rules for added routes");
            return;
        }
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        log.info("Starting to populate routing rules for added routes");
        // Take snapshots of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        Set<ArrayList<DeviceId>> routeChanges = new HashSet<>();
        boolean handleRouting = false;
        if (cpts.size() == 2) {
            // ensure connect points are edge-pairs
            Iterator<ConnectPoint> iter = cpts.iterator();
            DeviceId dev1 = iter.next().deviceId();
            DeviceId pairDev = getPairDev(dev1);
            if (iter.next().deviceId().equals(pairDev)) {
                edgePairs.add(new EdgePair(dev1, pairDev));
            } else {
                log.warn("Connectpoints {} for subnets {} not on " + "pair-devices.. aborting populateSubnet", cpts, subnets);
                populationStatus = Status.ABORTED;
                return;
            }
            for (ConnectPoint cp : cpts) {
                EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(cp.deviceId(), srManager);
                updatedEcmpSpgMap.put(cp.deviceId(), ecmpSpgUpdated);
                DeviceId retId = shouldHandleRouting(cp.deviceId());
                if (retId == null) {
                    continue;
                }
                handleRouting = true;
            }
        } else {
            // single connect point
            DeviceId dstSw = cpts.iterator().next().deviceId();
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(dstSw, srManager);
            updatedEcmpSpgMap.put(dstSw, ecmpSpgUpdated);
            if (srManager.mastershipService.isLocalMaster(dstSw)) {
                handleRouting = true;
            }
        }
        if (!handleRouting) {
            log.debug("This instance is not handling ecmp routing to the " + "connectPoint(s) {}", cpts);
            populationStatus = Status.ABORTED;
            return;
        }
        // 2. if target is one of the connectpoints
        for (ConnectPoint cp : cpts) {
            DeviceId dstSw = cp.deviceId();
            for (Device targetSw : srManager.deviceService.getDevices()) {
                boolean isEdge = false;
                try {
                    isEdge = config.isEdgeDevice(targetSw.id());
                } catch (DeviceConfigNotFoundException e) {
                    log.warn(e.getMessage() + "aborting populateSubnet");
                    populationStatus = Status.ABORTED;
                    return;
                }
                if (dstSw.equals(targetSw.id()) || !isEdge || (cpts.size() == 2 && targetSw.id().equals(getPairDev(dstSw)))) {
                    continue;
                }
                routeChanges.add(Lists.newArrayList(targetSw.id(), dstSw));
            }
        }
        if (!redoRouting(routeChanges, edgePairs, subnets)) {
            log.debug("populateSubnet: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules for subnet.");
            return;
        }
        log.debug("populateSubnet: populationStatus is SUCCEEDED");
        populationStatus = Status.SUCCEEDED;
        log.info("Completed subnet population. Total # of rules pushed : {}", rulePopulator.getCounter());
        return;
    } finally {
        statusLock.unlock();
    }
}
#end_block

#method_before
public void populateRoutingRulesForLinkStatusChange(Link linkDown, Link linkUp, DeviceId switchDown) {
    if ((linkDown != null && (linkUp != null || switchDown != null)) || (linkUp != null && (linkDown != null || switchDown != null)) || (switchDown != null && (linkUp != null || linkDown != null))) {
        log.warn("Only one event can be handled for link status change .. aborting");
        return;
    }
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceeed with routingRules for Link Status change");
            return;
        }
        // Take snapshots of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
            DeviceId pairDev = getPairDev(sw.id());
            if (pairDev != null) {
                // pairDev may not be available yet, but we still need to add
                ecmpSpgUpdated = new EcmpShortestPathGraph(pairDev, srManager);
                updatedEcmpSpgMap.put(pairDev, ecmpSpgUpdated);
                edgePairs.add(new EdgePair(sw.id(), pairDev));
            }
        }
        log.info("Starting to populate routing rules from link status change");
        Set<ArrayList<DeviceId>> routeChanges;
        log.debug("populateRoutingRulesForLinkStatusChange: " + "populationStatus is STARTED");
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        // try optimized re-routing
        if (linkDown == null) {
            // either a linkUp or a switchDown - compute all route changes by
            // comparing all routes of existing ECMP SPG to new ECMP SPG
            routeChanges = computeRouteChange();
            if (routeChanges != null) {
                // deal with linkUp of a seen-before link
                if (linkUp != null && srManager.isSeenLink(linkUp)) {
                    if (!srManager.isBidirectional(linkUp)) {
                        log.warn("Not a bidirectional link yet .. not " + "processing link {}", linkUp);
                        srManager.updateSeenLink(linkUp, true);
                        populationStatus = Status.ABORTED;
                        return;
                    }
                    // link previously seen before
                    // do hash-bucket changes instead of a re-route
                    processHashGroupChange(routeChanges, false, null);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
                // deal with switchDown
                if (switchDown != null) {
                    processHashGroupChange(routeChanges, true, switchDown);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
            // for a linkUp of a never-seen-before link
            // let it fall through to a reroute of the routeChanges
            }
            // it is safe to update the store for the linkUp
            if (linkUp != null) {
                srManager.updateSeenLink(linkUp, true);
            }
        } else {
            // link has gone down
            // Compare existing ECMP SPG only with the link that went down
            routeChanges = computeDamagedRoutes(linkDown);
            if (routeChanges != null) {
                processHashGroupChange(routeChanges, true, null);
                // clear out routesChanges so a re-route is not attempted
                routeChanges = ImmutableSet.of();
            }
        }
        // do full re-routing if optimized routing returns null routeChanges
        if (routeChanges == null) {
            log.info("Optimized routing failed... opting for full reroute");
            populationStatus = Status.ABORTED;
            statusLock.unlock();
            populateAllRoutingRules();
            return;
        }
        if (routeChanges.isEmpty()) {
            log.info("No re-route attempted for the link status change");
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            return;
        }
        // reroute of routeChanges
        if (redoRouting(routeChanges, edgePairs, null)) {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            log.info("Completed repopulation of rules for link-status change." + " # of rules populated : {}", rulePopulator.getCounter());
            return;
        } else {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules for link status change.");
            return;
        }
    } finally {
        statusLock.unlock();
    }
}
#method_after
/**
 * Populates the routing rules or makes hash group changes according to the
 * route-path changes due to link failure, switch failure or link up. This
 * method should only be called for one of these three possible event-types.
 * Note that when a switch goes away, all of its links fail as well,
 * but this is handled as a single switch removal event.
 *
 * @param linkDown the single failed link, or null for other conditions
 *                  such as link-up or a removed switch
 * @param linkUp the single link up, or null for other conditions such as
 *                  link-down or a removed switch
 * @param switchDown the removed switch, or null for other conditions such as
 *                  link-down or link-up
 */
public void populateRoutingRulesForLinkStatusChange(Link linkDown, Link linkUp, DeviceId switchDown) {
    if ((linkDown != null && (linkUp != null || switchDown != null)) || (linkUp != null && (linkDown != null || switchDown != null)) || (switchDown != null && (linkUp != null || linkDown != null))) {
        log.warn("Only one event can be handled for link status change .. aborting");
        return;
    }
    statusLock.lock();
    try {
        if (populationStatus == Status.STARTED) {
            log.warn("Previous rule population is not finished. Cannot" + " proceeed with routingRules for Link Status change");
            return;
        }
        // Take snapshots of the topology
        updatedEcmpSpgMap = new HashMap<>();
        Set<EdgePair> edgePairs = new HashSet<>();
        for (Device sw : srManager.deviceService.getDevices()) {
            EcmpShortestPathGraph ecmpSpgUpdated = new EcmpShortestPathGraph(sw.id(), srManager);
            updatedEcmpSpgMap.put(sw.id(), ecmpSpgUpdated);
            DeviceId pairDev = getPairDev(sw.id());
            if (pairDev != null) {
                // pairDev may not be available yet, but we still need to add
                ecmpSpgUpdated = new EcmpShortestPathGraph(pairDev, srManager);
                updatedEcmpSpgMap.put(pairDev, ecmpSpgUpdated);
                edgePairs.add(new EdgePair(sw.id(), pairDev));
            }
        }
        log.info("Starting to populate routing rules from link status change");
        Set<ArrayList<DeviceId>> routeChanges;
        log.debug("populateRoutingRulesForLinkStatusChange: " + "populationStatus is STARTED");
        populationStatus = Status.STARTED;
        rulePopulator.resetCounter();
        // try optimized re-routing
        if (linkDown == null) {
            // either a linkUp or a switchDown - compute all route changes by
            // comparing all routes of existing ECMP SPG to new ECMP SPG
            routeChanges = computeRouteChange();
            if (routeChanges != null) {
                // deal with linkUp of a seen-before link
                if (linkUp != null && srManager.isSeenLink(linkUp)) {
                    if (!srManager.isBidirectional(linkUp)) {
                        log.warn("Not a bidirectional link yet .. not " + "processing link {}", linkUp);
                        srManager.updateSeenLink(linkUp, true);
                        populationStatus = Status.ABORTED;
                        return;
                    }
                    // link previously seen before
                    // do hash-bucket changes instead of a re-route
                    processHashGroupChange(routeChanges, false, null);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
                // deal with switchDown
                if (switchDown != null) {
                    processHashGroupChange(routeChanges, true, switchDown);
                    // clear out routesChanges so a re-route is not attempted
                    routeChanges = ImmutableSet.of();
                }
            // for a linkUp of a never-seen-before link
            // let it fall through to a reroute of the routeChanges
            }
            // it is safe to update the store for the linkUp
            if (linkUp != null) {
                srManager.updateSeenLink(linkUp, true);
            }
        } else {
            // link has gone down
            // Compare existing ECMP SPG only with the link that went down
            routeChanges = computeDamagedRoutes(linkDown);
            if (routeChanges != null) {
                processHashGroupChange(routeChanges, true, null);
                // clear out routesChanges so a re-route is not attempted
                routeChanges = ImmutableSet.of();
            }
        }
        // do full re-routing if optimized routing returns null routeChanges
        if (routeChanges == null) {
            log.info("Optimized routing failed... opting for full reroute");
            populationStatus = Status.ABORTED;
            statusLock.unlock();
            populateAllRoutingRules();
            return;
        }
        if (routeChanges.isEmpty()) {
            log.info("No re-route attempted for the link status change");
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            return;
        }
        // reroute of routeChanges
        if (redoRouting(routeChanges, edgePairs, null)) {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is SUCCEEDED");
            populationStatus = Status.SUCCEEDED;
            log.info("Completed repopulation of rules for link-status change." + " # of rules populated : {}", rulePopulator.getCounter());
            return;
        } else {
            log.debug("populateRoutingRulesForLinkStatusChange: populationStatus is ABORTED");
            populationStatus = Status.ABORTED;
            log.warn("Failed to repopulate the rules for link status change.");
            return;
        }
    } finally {
        statusLock.unlock();
    }
}
#end_block

#method_before
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean dest1IsEdge;
    Ip4Address dest1RouterIpv4, dest2RouterIpv4 = null;
    Ip6Address dest1RouterIpv6, dest2RouterIpv6 = null;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        dest1IsEdge = config.isEdgeDevice(destSw1);
        dest1RouterIpv4 = config.getRouterIpv4(destSw1);
        dest1RouterIpv6 = config.getRouterIpv6(destSw1);
        if (destSw2 != null) {
            dest2RouterIpv4 = config.getRouterIpv4(destSw2);
            dest2RouterIpv6 = config.getRouterIpv6(destSw2);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && dest1IsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? Sets.newHashSet(subnets) : Sets.newHashSet(config.getSubnets(destSw1));
        // XXX -  Rethink this
        /*subnets.add(dest1RouterIpv4.toIpPrefix());
            if (dest1RouterIpv6 != null) {
                subnets.add(dest1RouterIpv6.toIpPrefix());
            }
            if (destSw2 != null && dest2RouterIpv4 != null) {
                subnets.add(dest2RouterIpv4.toIpPrefix());
                if (dest2RouterIpv6 != null) {
                    subnets.add(dest2RouterIpv6.toIpPrefix());
                }
            }*/
        log.debug(". populateEcmpRoutingRulePartial in device {} towards {} {} " + "for subnets {}", targetSw, destSw1, (destSw2 != null) ? ("& " + destSw2) : "", subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw1, destSw2, nextHops);
        if (!result) {
            return false;
        }
    /* XXX rethink this
            IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} "
                    + "for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                           destSw, nextHops);
            if (!result) {
                return false;
            }
            // If present we deal with IPv6 loopback.
            if (destRouterIpv6 != null) {
                routerIpPrefix = destRouterIpv6.toIpPrefix();
                log.debug("* populateEcmpRoutingRulePartial in device {} towards {}"
                        + " for v6 router IP {}", targetSw, destSw, routerIpPrefix);
                result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                               destSw, nextHops);
                if (!result) {
                    return false;
                }
            }*/
    }
    if (!targetIsEdge && dest1IsEdge) {
        // MPLS rules in all non-edge target devices. These rules are for
        // individual destinations, even if the dsts are part of edge-pairs.
        log.debug(". populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw1);
        result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv4);
        if (!result) {
            return false;
        }
        if (dest1RouterIpv6 != null) {
            result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv6);
            if (!result) {
                return false;
            }
        }
    }
    // avoid loopback IP rules in edge-devices to non-edge-devices
    return true;
}
#method_after
/**
 * Populate ECMP rules for subnets from target to destination via nexthops.
 *
 * @param targetSw Device ID of target switch in which rules will be programmed
 * @param destSw1 Device ID of final destination switch to which the rules will forward
 * @param destSw2 Device ID of paired destination switch to which the rules will forward
 *                A null deviceId indicates packets should only be sent to destSw1
 * @param nextHops Map indication a list of next hops per destSw
 * @param subnets Subnets to be populated. If empty, populate all configured subnets.
 * @return true if it succeeds in populating rules
 */
private boolean populateEcmpRoutingRulePartial(DeviceId targetSw, DeviceId destSw1, DeviceId destSw2, Map<DeviceId, Set<DeviceId>> nextHops, Set<IpPrefix> subnets) {
    boolean result;
    // If both target switch and dest switch are edge routers, then set IP
    // rule for both subnet and router IP.
    boolean targetIsEdge;
    boolean dest1IsEdge;
    Ip4Address dest1RouterIpv4, dest2RouterIpv4 = null;
    Ip6Address dest1RouterIpv6, dest2RouterIpv6 = null;
    try {
        targetIsEdge = config.isEdgeDevice(targetSw);
        dest1IsEdge = config.isEdgeDevice(destSw1);
        dest1RouterIpv4 = config.getRouterIpv4(destSw1);
        dest1RouterIpv6 = config.getRouterIpv6(destSw1);
        if (destSw2 != null) {
            dest2RouterIpv4 = config.getRouterIpv4(destSw2);
            dest2RouterIpv6 = config.getRouterIpv6(destSw2);
        }
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateEcmpRoutingRulePartial.");
        return false;
    }
    if (targetIsEdge && dest1IsEdge) {
        subnets = (subnets != null && !subnets.isEmpty()) ? Sets.newHashSet(subnets) : Sets.newHashSet(config.getSubnets(destSw1));
        // XXX -  Rethink this
        /*subnets.add(dest1RouterIpv4.toIpPrefix());
            if (dest1RouterIpv6 != null) {
                subnets.add(dest1RouterIpv6.toIpPrefix());
            }
            if (destSw2 != null && dest2RouterIpv4 != null) {
                subnets.add(dest2RouterIpv4.toIpPrefix());
                if (dest2RouterIpv6 != null) {
                    subnets.add(dest2RouterIpv6.toIpPrefix());
                }
            }*/
        log.debug(". populateEcmpRoutingRulePartial in device {} towards {} {} " + "for subnets {}", targetSw, destSw1, (destSw2 != null) ? ("& " + destSw2) : "", subnets);
        result = rulePopulator.populateIpRuleForSubnet(targetSw, subnets, destSw1, destSw2, nextHops);
        if (!result) {
            return false;
        }
    /* XXX rethink this
            IpPrefix routerIpPrefix = destRouterIpv4.toIpPrefix();
            log.debug("* populateEcmpRoutingRulePartial in device {} towards {} "
                    + "for router IP {}", targetSw, destSw, routerIpPrefix);
            result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                           destSw, nextHops);
            if (!result) {
                return false;
            }
            // If present we deal with IPv6 loopback.
            if (destRouterIpv6 != null) {
                routerIpPrefix = destRouterIpv6.toIpPrefix();
                log.debug("* populateEcmpRoutingRulePartial in device {} towards {}"
                        + " for v6 router IP {}", targetSw, destSw, routerIpPrefix);
                result = rulePopulator.populateIpRuleForRouter(targetSw, routerIpPrefix,
                                                               destSw, nextHops);
                if (!result) {
                    return false;
                }
            }*/
    }
    if (!targetIsEdge && dest1IsEdge) {
        // MPLS rules in all non-edge target devices. These rules are for
        // individual destinations, even if the dsts are part of edge-pairs.
        log.debug(". populateEcmpRoutingRulePartial in device{} towards {} for " + "all MPLS rules", targetSw, destSw1);
        result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv4);
        if (!result) {
            return false;
        }
        if (dest1RouterIpv6 != null) {
            result = rulePopulator.populateMplsRule(targetSw, destSw1, nextHops.get(destSw1), dest1RouterIpv6);
            if (!result) {
                return false;
            }
        }
    }
    // avoid loopback IP rules in edge-devices to non-edge-devices
    return true;
}
#end_block

#method_before
private void handlePortRequest(InternalPortUpDownEvent event) {
    changePortState(event.deviceId(), event.portNumber(), event.isEnable());
}
#method_after
private void handlePortRequest(InternalPortUpDownEvent event) {
    DeviceId deviceId = event.deviceId();
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceId, PORT_NUMBER_NULL);
    checkState(mastershipService.isLocalMaster(deviceId), EVENT_NON_MASTER);
    changePortStateAtMaster(event.deviceId(), event.portNumber(), event.isEnable());
}
#end_block

#method_before
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceId, PORT_NUMBER_NULL);
    NodeId masterId = mastershipService.getMasterFor(deviceId);
    if (!masterId.equals(localNodeId)) {
        // Send the request to the master node for the device
        log.warn("Device {} is managed by {}, forwarding the request to the MASTER", deviceId, masterId);
        communicationService.unicast(new InternalPortUpDownEvent(deviceId, portNumber, enable), PORT_UPDOWN_SUBJECT, SERIALIZER::encode, masterId).whenComplete((r, error) -> {
            if (error != null) {
                log.warn("Failed to send packet-updown-req to {}", masterId, error);
            }
        });
    } else {
        DeviceProvider provider = getProvider(deviceId);
        if (provider != null) {
            log.warn("Port {} on device {} being administratively brought {}", portNumber, deviceId, (enable) ? "UP" : "DOWN");
            provider.changePortState(deviceId, portNumber, enable);
        } else {
            log.warn("Provider not found for {}", deviceId);
        }
    }
}
#method_after
@Override
public void changePortState(DeviceId deviceId, PortNumber portNumber, boolean enable) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceId, PORT_NUMBER_NULL);
    NodeId masterId = mastershipService.getMasterFor(deviceId);
    if (!masterId.equals(localNodeId)) {
        // Send the request to the master node for the device
        log.info("Device {} is managed by {}, forwarding the request to the MASTER", deviceId, masterId);
        communicationService.unicast(new InternalPortUpDownEvent(deviceId, portNumber, enable), PORT_UPDOWN_SUBJECT, SERIALIZER::encode, masterId).whenComplete((r, error) -> {
            if (error != null) {
                log.warn("Failed to send packet-updown-req to {}", masterId, error);
            }
        });
    } else {
        changePortStateAtMaster(deviceId, portNumber, enable);
    }
}
#end_block

#method_before
@Test
public void testMethods() {
    final PiPacketMetadata piPacketMetadata = PiPacketMetadata.builder().withId(PiPacketMetadataId.of("egress_port")).withValue(copyFrom(0x10)).build();
    assertThat(piPacketMetadata, is(notNullValue()));
    assertThat(piPacketMetadata.id(), is(PiPacketMetadataId.of("egress_port")));
    assertThat(piPacketMetadata.value(), is(copyFrom(0x10)));
}
#method_after
@Test
public void testMethods() {
    assertThat(piPacketMetadata1, is(notNullValue()));
    assertThat(piPacketMetadata1.id(), is(PiPacketMetadataId.of(EGRESS_PORT)));
    assertThat(piPacketMetadata1.value(), is(copyFrom(0x10)));
}
#end_block

#method_before
@Test
public void testMethods() {
    final PiActionGroupId piActionGroupId = PiActionGroupId.of(10);
    assertThat(piActionGroupId, is(notNullValue()));
    assertThat(piActionGroupId.type(), is(PiTableAction.Type.ACTION_GROUP_ID));
}
#method_after
@Test
public void testMethods() {
    assertThat(piActionGroupId1, is(notNullValue()));
    assertThat(piActionGroupId1.type(), is(PiTableAction.Type.ACTION_GROUP_ID));
    assertThat(piActionGroupId1.id(), is(10));
}
#end_block

#method_before
@Test
public void testMethods() {
    final String name = "egress_port";
    final PiPacketMetadataId piPacketMetadataId = PiPacketMetadataId.of(name);
    assertThat(piPacketMetadataId, is(notNullValue()));
    assertThat(piPacketMetadataId.name(), is(name));
}
#method_after
@Test
public void testMethods() {
    assertThat(piPacketMetadataId1, is(notNullValue()));
    assertThat(piPacketMetadataId1.name(), is(EGRESS_PORT));
}
#end_block

#method_before
@Test
public void testMethods() {
    final PiPacketOperation piPacketOperation = PiPacketOperation.builder().withData(ImmutableByteSequence.ofOnes(512)).withType(PACKET_OUT).withMetadata(PiPacketMetadata.builder().withId(PiPacketMetadataId.of("egress_port")).withValue(copyFrom((short) 10)).build()).build();
    assertThat(piPacketOperation, is(notNullValue()));
    assertThat(piPacketOperation.type(), is(PACKET_OUT));
    assertThat(piPacketOperation.data(), is(ImmutableByteSequence.ofOnes(512)));
    assertThat("Incorrect metadatas value", CollectionUtils.isEqualCollection(piPacketOperation.metadatas(), ImmutableList.of(PiPacketMetadata.builder().withId(PiPacketMetadataId.of("egress_port")).withValue(copyFrom((short) 10)).build())));
}
#method_after
@Test
public void testMethods() {
    final PiPacketOperation piPacketOperation = PiPacketOperation.builder().withData(ImmutableByteSequence.ofOnes(512)).withType(PACKET_OUT).withMetadata(PiPacketMetadata.builder().withId(PiPacketMetadataId.of(EGRESS_PORT)).withValue(copyFrom((short) 10)).build()).build();
    assertThat(piPacketOperation, is(notNullValue()));
    assertThat(piPacketOperation.type(), is(PACKET_OUT));
    assertThat(piPacketOperation.data(), is(ImmutableByteSequence.ofOnes(512)));
    assertThat("Incorrect metadatas value", CollectionUtils.isEqualCollection(piPacketOperation.metadatas(), ImmutableList.of(PiPacketMetadata.builder().withId(PiPacketMetadataId.of(EGRESS_PORT)).withValue(copyFrom((short) 10)).build())));
}
#end_block

#method_before
@Test
public void testMethods() {
    final PiActionGroupMemberId piActionGroupMemberId = PiActionGroupMemberId.of(10);
    assertThat(piActionGroupMemberId, is(notNullValue()));
    assertThat(piActionGroupMemberId.type(), is(PiTableAction.Type.GROUP_MEMBER_ID));
}
#method_after
@Test
public void testMethods() {
    assertThat(piActionGroupMemberId1, is(notNullValue()));
    assertThat(piActionGroupMemberId1.type(), is(PiTableAction.Type.GROUP_MEMBER_ID));
    assertThat(piActionGroupMemberId1.id(), is(10));
}
#end_block

#method_before
public Builder append(List<NodeKey> nodeKeys) throws CloneNotSupportedException {
    processCurKey();
    curKeyBuilder = null;
    nodeKeyList.addAll(nodeKeys);
    return this;
}
#method_after
public Builder append(List<NodeKey> nodeKeys) {
    processCurKey();
    curKeyBuilder = null;
    nodeKeyList.addAll(nodeKeys);
    return this;
}
#end_block

#method_before
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "useOvsNat");
    if (flag == null) {
        log.info("useOvsNat is not configured, " + "using current value of {}", useOvsNat);
    } else {
        useOvsNat = flag;
        log.info("Configured. useOvsNat is {}", useOvsNat ? "enabled" : "disabled");
    }
    resetSnatRules();
}
#method_after
@Modified
protected void modified(ComponentContext context) {
    Dictionary<?, ?> properties = context.getProperties();
    Boolean flag;
    flag = Tools.isPropertyEnabled(properties, "useStatefulSnat");
    if (flag == null) {
        log.info("useStatefulSnat is not configured, " + "using current value of {}", useStatefulSnat);
    } else {
        useStatefulSnat = flag;
        log.info("Configured. useStatefulSnat is {}", useStatefulSnat ? "enabled" : "disabled");
    }
    resetSnatRules();
}
#end_block

#method_before
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway == null) {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(iface, false);
        });
    } else {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(iface, exGateway.isEnableSnat());
        });
    }
}
#method_after
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway == null) {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, false);
        });
    } else {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, exGateway.isEnableSnat());
        });
    }
}
#end_block

#method_before
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void setSourceNat(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setRulesToGateway(osNode.intBridge(), osNet.getProviderSegID(), IpPrefix.valueOf(osSubnet.getCidr()), osNet.getNetworkType(), install);
    });
    if (useOvsNat) {
        setOvsSnatRules(routerIface, install);
    } else {
        setControllerSnatRules(routerIface, install);
    }
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#method_after
private void setSourceNat(Router osRouter, RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setRulesToGateway(cNode, osNet.getProviderSegID(), IpPrefix.valueOf(osSubnet.getCidr()), osNet.getNetworkType(), install);
    });
    if (useStatefulSnat) {
        setStatefulSnatRules(routerIface, install);
    } else {
        setReactiveSnatRules(routerIface, install);
    }
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#end_block

#method_before
private IpAddress getGatewayIpAddress() {
    Optional<Router> extRouter = osRouterService.routers().stream().filter(router -> osNetworkService.network(router.getExternalGatewayInfo().getNetworkId()) != null).findFirst();
    if (!extRouter.isPresent()) {
        return null;
    }
    // We assume that there is only one subnet in external network.
    Subnet externalGwSubnet = osNetworkService.subnets(extRouter.get().getExternalGatewayInfo().getNetworkId()).stream().findFirst().get();
    return IpAddress.valueOf(externalGwSubnet.getGateway());
}
#method_after
private IpAddress getGatewayIpAddress(Router osRouter) {
    String extNetId = osNetworkService.network(osRouter.getExternalGatewayInfo().getNetworkId()).getId();
    Optional<Subnet> extSubnet = osNetworkService.subnets().stream().filter(subnet -> subnet.getNetworkId().equals(extNetId)).findAny();
    if (!extSubnet.isPresent()) {
        log.error("Cannot find externel subnet for the router");
        return null;
    }
    return IpAddress.valueOf(extSubnet.get().getGateway());
}
#end_block

#method_before
private void resetSnatRules() {
    if (useOvsNat) {
        osRouterService.routerInterfaces().forEach(routerIface -> {
            setControllerSnatRules(routerIface, false);
            setOvsSnatRules(routerIface, true);
        });
    } else {
        osRouterService.routerInterfaces().forEach(routerIface -> {
            setOvsSnatRules(routerIface, false);
            setControllerSnatRules(routerIface, true);
        });
    }
}
#method_after
private void resetSnatRules() {
    if (useStatefulSnat) {
        osRouterService.routerInterfaces().forEach(routerIface -> {
            setReactiveSnatRules(routerIface, false);
            setStatefulSnatRules(routerIface, true);
        });
    } else {
        osRouterService.routerInterfaces().forEach(routerIface -> {
            setStatefulSnatRules(routerIface, false);
            setReactiveSnatRules(routerIface, true);
        });
    }
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.dataIp().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VXLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> osNode.vlanPort().isPresent()).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge(), NetworkMode.VLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, cNode.gatewayGroupId(NetworkMode.VXLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, cNode.gatewayGroupId(NetworkMode.VLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Network updatedNetwork = osNetworkService.network(updatedSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    String updatedSegmendId = getSegmentId(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setInternalRouterRules(osNode.intBridge(), updatedSegmendId, updatedSegmendId, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(osNode.intBridge(), updatedSegmendId, getSegmentId(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), updatedNetwork.getNetworkType(), install);
            setInternalRouterRules(osNode.intBridge(), getSegmentId(subnet), updatedSegmendId, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#method_after
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Network updatedNetwork = osNetworkService.network(updatedSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    String updatedSegmendId = getSegmentId(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, updatedSegmendId, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, getSegmentId(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), updatedNetwork.getNetworkType(), install);
            setInternalRouterRules(cNode.intgBridge(), getSegmentId(subnet), updatedSegmendId, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#end_block

#method_before
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_ICMP_RULE, install);
}
#method_after
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.getIp4Address().toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).build();
            RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#method_after
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
private void setRulesToGateway(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, sBuilder.build(), treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_EXTERNAL_ROUTING_RULE, install);
}
#method_after
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesForSnatIngressRule(DeviceId deviceId, Long vni, IpPrefix destVmIp, DeviceId dstDeviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(destVmIp).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(vni).extension(buildExtension(deviceService, deviceId, osNodeService.dataIp(dstDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get()).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_EXTERNAL_ROUTING_RULE, install);
}
#method_after
private void setRulesForSnatIngressRule(DeviceId deviceId, Long vni, IpPrefix destVmIp, DeviceId dstDeviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(destVmIp).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(vni).extension(buildExtension(deviceService, deviceId, osNodeService.node(dstDeviceId).dataIp().getIp4Address()), deviceId).setOutput(osNodeService.node(deviceId).tunnelPortNum()).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setRulesToGatewayWithDstIp(DeviceId deviceId, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_SWITCHING_RULE, install);
}
#method_after
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setOvsNatIngressRule(DeviceId deviceId, IpPrefix cidr, MacAddress dstMac, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(cidr).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(false).natAction(true).table((short) 0).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).extension(natTreatment, deviceId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_OVS_SNAT_RULE, install);
}
#method_after
private void setOvsNatIngressRule(DeviceId deviceId, IpPrefix cidr, MacAddress dstMac, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(cidr).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(false).natAction(true).table((short) 0).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).extension(natTreatment, deviceId).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_STATEFUL_SNAT_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setOvsNatEgressRule(DeviceId deviceId, PortNumber output, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchEthDst(DEFAULT_GATEWAY_MAC).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(true).natAction(true).natIp(getGatewayIpAddress()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(natTreatment, deviceId).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC).setEthSrc(DEFAULT_GATEWAY_MAC).setOutput(output).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_OVS_SNAT_RULE, install);
}
#method_after
private void setOvsNatEgressRule(DeviceId deviceId, IpAddress natAddress, long vni, PortNumber output, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchEthDst(DEFAULT_GATEWAY_MAC).matchTunnelId(vni).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(true).natAction(true).natIp(natAddress).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(natTreatment, deviceId).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC).setEthSrc(DEFAULT_GATEWAY_MAC).setOutput(output).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_STATEFUL_SNAT_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(MacAddress.valueOf(vlanPortMac(deviceId)));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC);
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.setOutput(PortNumber.CONTROLLER);
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, sBuilder.build(), tBuilder.build(), ForwardingObjective.Flag.VERSATILE, PRIORITY_EXTERNAL_ROUTING_RULE, install);
    // Sends ICMP response to controller for SNATing ingress traffic
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIcmpType(ICMP.TYPE_ECHO_REPLY).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_INTERNAL_ROUTING_RULE, install);
}
#method_after
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(osNodeService.node(deviceId).vlanPortMac());
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC);
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.setOutput(PortNumber.CONTROLLER);
    osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, GW_COMMON_TABLE, install);
    // Sends ICMP response to controller for SNATing ingress traffic
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIcmpType(ICMP.TYPE_ECHO_REPLY).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
        case INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("Reconfigure routers for {}", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
        case OPENSTACK_NODE_INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("Reconfigure routers for {}", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case OPENSTACK_NODE_CREATED:
        case OPENSTACK_NODE_UPDATED:
        case OPENSTACK_NODE_REMOVED:
        default:
            break;
    }
}
#end_block

#method_before
private void instPortDetected(InstancePort instPort) {
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setRulesForSnatIngressRule(gwDeviceId, Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), true));
}
#method_after
private void instPortDetected(InstancePort instPort) {
    osNodeService.completeNodes(GATEWAY).forEach(gwNode -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), true));
}
#end_block

#method_before
private void instPortRemoved(InstancePort instPort) {
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setRulesForSnatIngressRule(gwDeviceId, Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), false));
}
#method_after
private void instPortRemoved(InstancePort instPort) {
    osNodeService.completeNodes(GATEWAY).forEach(gwNode -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), false));
}
#end_block

#method_before
private void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, "controller", c.getRow().uuid()));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#method_after
private void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, BRIDGE_CONTROLLER, c.getRow().uuid()));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, BRIDGE_CONTROLLER, bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#end_block

#method_before
@Override
public Set<OvsdbPort> getPorts() {
    Set<OvsdbPort> ovsdbPorts = new HashSet<>();
    OvsdbTableStore tableStore = getTableStore(DATABASENAME);
    if (tableStore == null) {
        return null;
    }
    OvsdbRowStore rowStore = tableStore.getRows(INTERFACE);
    if (rowStore == null) {
        return null;
    }
    ConcurrentMap<String, Row> rows = rowStore.getRowStore();
    for (String uuid : rows.keySet()) {
        Row row = getRow(DATABASENAME, INTERFACE, uuid);
        OvsdbPort ovsdbPort = getOvsdbPort(row);
        if (ovsdbPort != null) {
            ovsdbPorts.add(ovsdbPort);
        }
    }
    return ovsdbPorts;
}
#method_after
@Override
public List<OvsdbPortName> getPorts(List<String> portNames, DeviceId deviceId) {
    Uuid bridgeUuid = getBridgeUuid(deviceId);
    if (bridgeUuid == null) {
        log.error("Can't find the bridge for the deviceId {}", deviceId);
        return Collections.emptyList();
    }
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    Row bridgeRow = getRow(DATABASENAME, BRIDGE, bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    if (bridge == null) {
        return Collections.emptyList();
    }
    OvsdbSet setPorts = (OvsdbSet) bridge.getPortsColumn().data();
    Set<Uuid> portSet = setPorts.set();
    if (portSet.isEmpty()) {
        return Collections.emptyList();
    }
    Map<Uuid, Port> portMap = portSet.stream().collect(Collectors.toMap(java.util.function.Function.identity(), port -> (Port) TableGenerator.getTable(dbSchema, getRow(DATABASENAME, PORT, port.value()), OvsdbTable.PORT)));
    List<OvsdbPortName> portList = portMap.entrySet().stream().filter(port -> Objects.nonNull(port.getValue()) && portNames.contains(port.getValue().getName()) && Objects.nonNull(getInterfacebyPort(port.getKey().value(), port.getValue().getName()))).map(port -> new OvsdbPortName(port.getValue().getName())).collect(Collectors.toList());
    return Collections.unmodifiableList(portList);
}
#end_block

#method_before
@Override
public boolean getPortError(List<String> portNames, DeviceId bridgeId) {
    boolean error = false;
    Uuid bridgeUuid = getBridgeUuid(bridgeId);
    DatabaseSchema dbSchema = schema.get(OvsdbConstant.DATABASENAME);
    for (String portName : portNames) {
        String portUuid = getPortUuid(portName, bridgeUuid.value());
        String intUuid = getInterfaceUuid(portUuid, portName);
        Row intfRow = getRow(OvsdbConstant.DATABASENAME, OvsdbConstant.INTERFACE, intUuid);
        Interface intf = (Interface) TableGenerator.getTable(dbSchema, intfRow, OvsdbTable.INTERFACE);
        if (intf == null) {
            continue;
        }
        OvsdbSet ofPortSet = (OvsdbSet) intf.getOpenFlowPortColumn().data();
        Set<Integer> ofPorts = ofPortSet.set();
        long ofport = 0;
        if ((ofPorts != null) && (ofPorts.size() != 0)) {
            Iterator<Integer> it = ofPorts.iterator();
            ofport = Long.parseLong(it.next().toString());
            log.info("Port - Name " + portName + " ovsdb ofport value = " + ofport);
        }
        try {
            if (ofport == -1) {
                // as per ovsdb "-1" indicates that the port has error
                OvsdbSet setErrors = (OvsdbSet) intf.getErrorColumn().data();
                Set<String> errors = setErrors.set();
                if ((errors != null) && (errors.size() != 0)) {
                    Iterator<String> it = errors.iterator();
                    log.info("Port - Name " + portName + " ovsdb Error value = " + it.next().toString());
                }
                return true;
            }
        } catch (Exception e) {
            // some ovsdb devices db schema doesn't have error column( PICA8 )
            e.printStackTrace();
            return true;
        }
    }
    return error;
}
#method_after
@Override
public boolean getPortError(List<OvsdbPortName> portNames, DeviceId bridgeId) {
    Uuid bridgeUuid = getBridgeUuid(bridgeId);
    List<Interface> interfaceList = portNames.stream().collect(Collectors.toMap(java.util.function.Function.identity(), port -> (Interface) getInterfacebyPort(getPortUuid(port.value(), bridgeUuid.value()), port.value()))).entrySet().stream().filter(intf -> Objects.nonNull(intf.getValue()) && ((OvsdbSet) intf.getValue().getOpenFlowPortColumn().data()).set().stream().findAny().orElse(OFPORT_ERROR_COMPARISON).equals(OFPORT_ERROR)).map(intf -> intf.getValue()).collect(Collectors.toList());
    interfaceList.forEach(intf -> new Consumer<Interface>() {

        @Override
        public void accept(Interface intf) {
            try {
                Set<String> setErrors = ((OvsdbSet) intf.getErrorColumn().data()).set();
                log.info("Port has errors. ofport value - {}, Interface - {} has error - {} ", intf.getOpenFlowPortColumn().data(), intf.getName(), setErrors.stream().findFirst().get());
            } catch (ColumnSchemaNotFoundException | VersionMismatchException e) {
                log.debug("Port has errors. ofport value - {}, Interface - {} has error - {} ", intf.getOpenFlowPortColumn().data(), intf.getName(), e);
            }
        }
    }.accept(intf));
    return !interfaceList.isEmpty();
}
#end_block

#method_before
private void handleEchoRequest(DeviceId srcDevice, MacAddress srcMac, IPv4 ipPacket, ICMP icmp) {
    InstancePort instPort = instancePortService.instancePort(srcMac);
    if (instPort == null) {
        log.trace(ERR_REQ + "unknown source host(MAC:{})", srcMac);
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(ipPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(instPort, srcIp);
    if (srcSubnet == null) {
        log.trace(ERR_REQ + "unknown source subnet(IP:{})", srcIp);
        return;
    }
    if (Strings.isNullOrEmpty(srcSubnet.getGateway())) {
        log.trace(ERR_REQ + "source subnet(ID:{}, CIDR:{}) has no gateway", srcSubnet.getId(), srcSubnet.getCidr());
        return;
    }
    if (isForSubnetGateway(IpAddress.valueOf(ipPacket.getDestinationAddress()), srcSubnet)) {
        // this is a request for the subnet gateway
        processRequestForGateway(ipPacket, instPort);
    } else {
        // this is a request for the external network
        IpAddress externalIp = getExternalIp(srcSubnet);
        if (externalIp == null) {
            return;
        }
        log.debug("1");
        sendRequestForExternal(ipPacket, srcDevice, externalIp);
        log.debug("2");
        String icmpInfoKey = String.valueOf(getIcmpId(icmp)).concat(String.valueOf(externalIp.getIp4Address().toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
        icmpInfoMap.putIfAbsent(icmpInfoKey, instPort);
    }
}
#method_after
private void handleEchoRequest(DeviceId srcDevice, MacAddress srcMac, IPv4 ipPacket, ICMP icmp) {
    InstancePort instPort = instancePortService.instancePort(srcMac);
    if (instPort == null) {
        log.trace(ERR_REQ + "unknown source host(MAC:{})", srcMac);
        return;
    }
    IpAddress srcIp = IpAddress.valueOf(ipPacket.getSourceAddress());
    Subnet srcSubnet = getSourceSubnet(instPort, srcIp);
    if (srcSubnet == null) {
        log.trace(ERR_REQ + "unknown source subnet(IP:{})", srcIp);
        return;
    }
    if (Strings.isNullOrEmpty(srcSubnet.getGateway())) {
        log.trace(ERR_REQ + "source subnet(ID:{}, CIDR:{}) has no gateway", srcSubnet.getId(), srcSubnet.getCidr());
        return;
    }
    if (isForSubnetGateway(IpAddress.valueOf(ipPacket.getDestinationAddress()), srcSubnet)) {
        // this is a request for the subnet gateway
        processRequestForGateway(ipPacket, instPort);
    } else {
        // this is a request for the external network
        IpAddress externalIp = getExternalIp(srcSubnet);
        if (externalIp == null) {
            return;
        }
        sendRequestForExternal(ipPacket, srcDevice, externalIp);
        String icmpInfoKey = String.valueOf(getIcmpId(icmp)).concat(String.valueOf(externalIp.getIp4Address().toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
        icmpInfoMap.putIfAbsent(icmpInfoKey, instPort);
    }
}
#end_block

#method_before
private void sendRequestForExternal(IPv4 ipPacket, DeviceId srcDevice, IpAddress srcNatIp) {
    ICMP icmpReq = (ICMP) ipPacket.getPayload();
    icmpReq.resetChecksum();
    ipPacket.setSourceAddress(srcNatIp.getIp4Address().toInt()).resetChecksum();
    ipPacket.setPayload(icmpReq);
    Ethernet icmpRequestEth = new Ethernet();
    icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(DEFAULT_GATEWAY_MAC).setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC).setPayload(ipPacket);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNodeService.externalPort(srcDevice).get()).build();
    OutboundPacket packet = new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#method_after
private void sendRequestForExternal(IPv4 ipPacket, DeviceId srcDevice, IpAddress srcNatIp) {
    ICMP icmpReq = (ICMP) ipPacket.getPayload();
    icmpReq.resetChecksum();
    ipPacket.setSourceAddress(srcNatIp.getIp4Address().toInt()).resetChecksum();
    ipPacket.setPayload(icmpReq);
    Ethernet icmpRequestEth = new Ethernet();
    icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(DEFAULT_GATEWAY_MAC).setDestinationMACAddress(DEFAULT_EXTERNAL_ROUTER_MAC).setPayload(ipPacket);
    OpenstackNode osNode = osNodeService.node(srcDevice);
    if (osNode == null) {
        final String error = String.format("Cannot find openstack node for %s", srcDevice);
        throw new IllegalStateException(error);
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(osNode.patchPortNum()).build();
    OutboundPacket packet = new DefaultOutboundPacket(srcDevice, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!osNodeService.gatewayDeviceIds().contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null || ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    if (iPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
        eventExecutor.execute(() -> processIcmpPacket(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    Set<DeviceId> gateways = osNodeService.completeNodes(GATEWAY).stream().map(OpenstackNode::intgBridge).collect(Collectors.toSet());
    if (context.isHandled()) {
        return;
    } else if (!gateways.contains(context.inPacket().receivedFrom().deviceId())) {
        // return if the packet is not from gateway nodes
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet == null || ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        return;
    }
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    if (iPacket.getProtocol() == IPv4.PROTOCOL_ICMP) {
        eventExecutor.execute(() -> processIcmpPacket(context, ethernet));
    }
}
#end_block

#method_before
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway == null) {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(iface, false);
        });
    } else {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(iface, exGateway.isEnableSnat());
        });
    }
}
#method_after
private void routerUpdated(Router osRouter) {
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway == null) {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, false);
        });
    } else {
        osRouterService.routerInterfaces(osRouter.getId()).forEach(iface -> {
            setSourceNat(osRouter, iface, exGateway.isEnableSnat());
        });
    }
}
#end_block

#method_before
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceAdded(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, true);
    setGatewayIcmp(osSubnet, true);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, true);
    }
    log.info("Connected subnet({}) to {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#method_after
private void routerIfaceRemoved(Router osRouter, RouterInterface osRouterIface) {
    Subnet osSubnet = osNetworkService.subnet(osRouterIface.getSubnetId());
    if (osSubnet == null) {
        final String error = String.format(ERR_SET_FLOWS + "subnet %s does not exist", osRouterIface.getId(), osRouterIface.getSubnetId());
        throw new IllegalStateException(error);
    }
    setInternalRoutes(osRouter, osSubnet, false);
    setGatewayIcmp(osSubnet, false);
    ExternalGateway exGateway = osRouter.getExternalGatewayInfo();
    if (exGateway != null && exGateway.isEnableSnat()) {
        setSourceNat(osRouter, osRouterIface, false);
    }
    log.info("Disconnected subnet({}) from {}", osSubnet.getCidr(), osRouter.getName());
}
#end_block

#method_before
private void setSourceNat(RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setRulesToGateway(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge()), Long.valueOf(osNet.getProviderSegID()), IpPrefix.valueOf(osSubnet.getCidr()), install);
    });
    String netId = osNetworkService.subnet(routerIface.getSubnetId()).getNetworkId();
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> {
        instancePortService.instancePorts(netId).stream().forEach(port -> setRulesForSnatIngressRule(gwDeviceId, Long.parseLong(osNet.getProviderSegID()), IpPrefix.valueOf(port.ipAddress(), 32), port.deviceId(), install));
        setOvsNatIngressRule(gwDeviceId, IpPrefix.valueOf("172.27.0.0/24"), Constants.DEFAULT_EXTERNAL_ROUTER_MAC, install);
        setOvsNatEgressRule(gwDeviceId, osNodeService.externalPort(gwDeviceId).get(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#method_after
private void setSourceNat(Router osRouter, RouterInterface routerIface, boolean install) {
    Subnet osSubnet = osNetworkService.subnet(routerIface.getSubnetId());
    Network osNet = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setRulesToGateway(cNode, osNet.getProviderSegID(), IpPrefix.valueOf(osSubnet.getCidr()), osNet.getNetworkType(), install);
    });
    IpAddress natAddress = getGatewayIpAddress(osRouter);
    if (natAddress == null) {
        return;
    }
    String netId = osNetworkService.subnet(routerIface.getSubnetId()).getNetworkId();
    osNodeService.completeNodes(OpenstackNode.NodeType.GATEWAY).forEach(gwNode -> {
        instancePortService.instancePorts(netId).stream().forEach(port -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNet.getProviderSegID()), IpPrefix.valueOf(port.ipAddress(), 32), port.deviceId(), install));
        setOvsNatIngressRule(gwNode.intgBridge(), IpPrefix.valueOf(natAddress, 32), Constants.DEFAULT_EXTERNAL_ROUTER_MAC, install);
        setOvsNatEgressRule(gwNode.intgBridge(), natAddress, Long.parseLong(osNet.getProviderSegID()), gwNode.patchPortNum(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.info(updateStr + "external access for subnet({})", osSubnet.getCidr());
}
#end_block

#method_before
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> setRulesToGatewayWithDstIp(osNode.intBridge(), osNodeService.gatewayGroupId(osNode.intBridge()), Long.valueOf(network.getProviderSegID()), IpAddress.valueOf(osSubnet.getGateway()), install));
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setGatewayIcmpRule(gatewayIp, gwDeviceId, install));
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#method_after
private void setGatewayIcmp(Subnet osSubnet, boolean install) {
    if (Strings.isNullOrEmpty(osSubnet.getGateway())) {
        // do nothing if no gateway is set
        return;
    }
    // take ICMP request to a subnet gateway through gateway node group
    Network network = osNetworkService.network(osSubnet.getNetworkId());
    switch(network.getNetworkType()) {
        case VXLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.dataIp() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, cNode.gatewayGroupId(NetworkMode.VXLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VXLAN, install));
            break;
        case VLAN:
            osNodeService.completeNodes(COMPUTE).stream().filter(cNode -> cNode.vlanPortNum() != null).forEach(cNode -> setRulesToGatewayWithDstIp(cNode, cNode.gatewayGroupId(NetworkMode.VLAN), network.getProviderSegID(), IpAddress.valueOf(osSubnet.getGateway()), NetworkMode.VLAN, install));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", network.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    IpAddress gatewayIp = IpAddress.valueOf(osSubnet.getGateway());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        setGatewayIcmpRule(gatewayIp, gNode.intgBridge(), install);
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    log.debug(updateStr + "ICMP to {}", osSubnet.getGateway());
}
#end_block

#method_before
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    Long updatedVni = getVni(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).forEach(osNode -> {
        setInternalRouterRules(osNode.intBridge(), updatedVni, updatedVni, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(osNode.intBridge(), updatedVni, getVni(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), install);
            setInternalRouterRules(osNode.intBridge(), getVni(subnet), updatedVni, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#method_after
private void setInternalRoutes(Router osRouter, Subnet updatedSubnet, boolean install) {
    Network updatedNetwork = osNetworkService.network(updatedSubnet.getNetworkId());
    Set<Subnet> routableSubnets = routableSubnets(osRouter, updatedSubnet.getId());
    String updatedSegmendId = getSegmentId(updatedSubnet);
    // installs rule from/to my subnet intentionally to fix ICMP failure
    // to my subnet gateway if no external gateway added to the router
    osNodeService.completeNodes(COMPUTE).forEach(cNode -> {
        setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, updatedSegmendId, IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        routableSubnets.forEach(subnet -> {
            setInternalRouterRules(cNode.intgBridge(), updatedSegmendId, getSegmentId(subnet), IpPrefix.valueOf(updatedSubnet.getCidr()), IpPrefix.valueOf(subnet.getCidr()), updatedNetwork.getNetworkType(), install);
            setInternalRouterRules(cNode.intgBridge(), getSegmentId(subnet), updatedSegmendId, IpPrefix.valueOf(subnet.getCidr()), IpPrefix.valueOf(updatedSubnet.getCidr()), updatedNetwork.getNetworkType(), install);
        });
    });
    final String updateStr = install ? MSG_ENABLED : MSG_DISABLED;
    routableSubnets.forEach(subnet -> log.debug(updateStr + "route between subnet:{} and subnet:{}", subnet.getCidr(), updatedSubnet.getCidr()));
}
#end_block

#method_before
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_ICMP_RULE, install);
}
#method_after
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.getIp4Address().toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setInternalRouterRules(DeviceId deviceId, Long srcVni, Long dstVni, IpPrefix srcSubnet, IpPrefix dstSubnet, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(srcVni).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(dstVni).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
    selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(dstVni).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
    treatment = DefaultTrafficTreatment.builder().setTunnelId(dstVni).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_INTERNAL_ROUTING_RULE, install);
}
#method_after
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
private void setRulesToGateway(DeviceId deviceId, GroupId groupId, Long vni, IpPrefix srcSubnet, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_EXTERNAL_ROUTING_RULE, install);
}
#method_after
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesForSnatIngressRule(DeviceId deviceId, Long vni, IpPrefix destVmIp, DeviceId dstDeviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(destVmIp).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(vni).extension(buildExtension(deviceService, deviceId, osNodeService.dataIp(dstDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get()).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_EXTERNAL_ROUTING_RULE, install);
}
#method_after
private void setRulesForSnatIngressRule(DeviceId deviceId, Long vni, IpPrefix destVmIp, DeviceId dstDeviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(destVmIp).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(vni).extension(buildExtension(deviceService, deviceId, osNodeService.node(dstDeviceId).dataIp().getIp4Address()), deviceId).setOutput(osNodeService.node(deviceId).tunnelPortNum()).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setRulesToGatewayWithDstIp(DeviceId deviceId, GroupId groupId, Long vni, IpAddress dstIp, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchIPDst(dstIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.SPECIFIC, PRIORITY_SWITCHING_RULE, install);
}
#method_after
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setOvsNatIngressRule(DeviceId deviceId, IpPrefix cidr, MacAddress dstMac, boolean install) {
    ExtensionSelector esCtSate = RulePopulatorUtil.buildCtExtensionSelector(driverService, deviceId);
    TrafficSelector selector = DefaultTrafficSelector.builder().extension(esCtSate, deviceId).matchEthType(Ethernet.TYPE_IPV4).matchIPDst(cidr).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(false).zone(1).table((short) 0).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).extension(natTreatment, deviceId).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_OVS_SNAT_RULE, install);
}
#method_after
private void setOvsNatIngressRule(DeviceId deviceId, IpPrefix cidr, MacAddress dstMac, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(cidr).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(false).natAction(true).table((short) 0).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(dstMac).extension(natTreatment, deviceId).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_OVS_SNAT_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setOvsNatEgressRule(DeviceId deviceId, PortNumber output, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchEthDst(DEFAULT_GATEWAY_MAC).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(true).zone(1).natIp(osNodeService.natAddress(deviceId).get()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(natTreatment, deviceId).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC).setEthSrc(DEFAULT_GATEWAY_MAC).setOutput(output).build();
    RulePopulatorUtil.setRule(flowObjectiveService, appId, deviceId, selector, treatment, ForwardingObjective.Flag.VERSATILE, PRIORITY_OVS_SNAT_RULE, install);
}
#method_after
private void setOvsNatEgressRule(DeviceId deviceId, IpAddress natAddress, long vni, PortNumber output, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchEthDst(DEFAULT_GATEWAY_MAC).matchTunnelId(vni).build();
    ExtensionTreatment natTreatment = RulePopulatorUtil.niciraConnTrackTreatmentBuilder(driverService, deviceId).commit(true).natAction(true).natIp(natAddress).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(natTreatment, deviceId).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC).setEthSrc(DEFAULT_GATEWAY_MAC).setOutput(output).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_OVS_SNAT_RULE, GW_COMMON_TABLE, install);
}
#end_block

#method_before
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case COMPLETE:
        case INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("COMPLETE node {} detected", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case INIT:
        case DEVICE_CREATED:
        default:
            break;
    }
}
#method_after
@Override
public void event(OpenstackNodeEvent event) {
    OpenstackNode osNode = event.subject();
    switch(event.type()) {
        case OPENSTACK_NODE_COMPLETE:
        case OPENSTACK_NODE_INCOMPLETE:
            eventExecutor.execute(() -> {
                log.info("Reconfigure routers for {}", osNode.hostname());
                reconfigureRouters();
            });
            break;
        case OPENSTACK_NODE_CREATED:
        case OPENSTACK_NODE_UPDATED:
        case OPENSTACK_NODE_REMOVED:
        default:
            break;
    }
}
#end_block

#method_before
private void instPortDetected(InstancePort instPort) {
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setRulesForSnatIngressRule(gwDeviceId, Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), true));
}
#method_after
private void instPortDetected(InstancePort instPort) {
    osNodeService.completeNodes(GATEWAY).forEach(gwNode -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), true));
}
#end_block

#method_before
private void instPortRemoved(InstancePort instPort) {
    osNodeService.gatewayDeviceIds().forEach(gwDeviceId -> setRulesForSnatIngressRule(gwDeviceId, Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), false));
}
#method_after
private void instPortRemoved(InstancePort instPort) {
    osNodeService.completeNodes(GATEWAY).forEach(gwNode -> setRulesForSnatIngressRule(gwNode.intgBridge(), Long.parseLong(osNetworkService.network(instPort.networkId()).getProviderSegID()), IpPrefix.valueOf(instPort.ipAddress(), 32), instPort.deviceId(), false));
}
#end_block

#method_before
public static ExtensionSelector buildCtExtensionSelector(DriverService driverService, DeviceId deviceId, boolean isTracking) {
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver esr = handler.behaviour(ExtensionSelectorResolver.class);
    ExtensionSelector extensionSelector = esr.getExtensionSelector(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_CONNTRACK_STATE.type());
    try {
        extensionSelector.setPropertyValue(CT_STATE, (long) 0);
        extensionSelector.setPropertyValue(CT_STATE_MASK, isTracking ? (long) 0 : (long) 0x20);
    } catch (Exception e) {
        log.error("Failed to set nicira match CT state");
        return null;
    }
    return extensionSelector;
}
#method_after
public static ExtensionSelector buildCtExtensionSelector(DriverService driverService, DeviceId deviceId, long ctState, long ctSateMask) {
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver esr = handler.behaviour(ExtensionSelectorResolver.class);
    ExtensionSelector extensionSelector = esr.getExtensionSelector(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_CONNTRACK_STATE.type());
    try {
        extensionSelector.setPropertyValue(CT_STATE, ctState);
        extensionSelector.setPropertyValue(CT_STATE_MASK, ctSateMask);
    } catch (Exception e) {
        log.error("Failed to set nicira match CT state");
        return null;
    }
    return extensionSelector;
}
#end_block

#method_before
public ExtensionTreatment build() {
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionTreatmentResolver etr = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment natTreatment = etr.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NAT.type());
    try {
        if (natAddress != null) {
            natTreatment.setPropertyValue(CT_FLAGS, 1);
            natTreatment.setPropertyValue(CT_PRESENT_FLAGS, buildPresentFlag(false, true));
            natTreatment.setPropertyValue(CT_IPADDRESS_MIN, natAddress);
            natTreatment.setPropertyValue(CT_IPADDRESS_MAX, natAddress);
        } else {
            natTreatment.setPropertyValue(CT_FLAGS, 0);
            natTreatment.setPropertyValue(CT_PRESENT_FLAGS, 0);
        }
    } catch (Exception e) {
        log.error("Failed to set NAT due to error : {}", e.getMessage());
        return null;
    }
    ExtensionTreatment ctTreatment = etr.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT.type());
    try {
        List<ExtensionTreatment> nat = new ArrayList<>();
        nat.add(natTreatment);
        ctTreatment.setPropertyValue(CT_FLAGS, commit ? 1 : 0);
        ctTreatment.setPropertyValue(CT_ZONE, zone);
        ctTreatment.setPropertyValue(CT_TABLE, table > -1 ? table : 0xff);
        ctTreatment.setPropertyValue("nestedActions", nat);
    } catch (Exception e) {
        log.error("Failed to set CT due to error : {}", e.getMessage());
        return null;
    }
    return ctTreatment;
}
#method_after
public ExtensionTreatment build() {
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionTreatmentResolver etr = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment natTreatment = etr.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NAT.type());
    try {
        if (natAddress != null) {
            natTreatment.setPropertyValue(CT_FLAGS, 1);
            natTreatment.setPropertyValue(CT_PRESENT_FLAGS, buildPresentFlag(false, true));
            natTreatment.setPropertyValue(CT_IPADDRESS_MIN, natAddress);
            natTreatment.setPropertyValue(CT_IPADDRESS_MAX, natAddress);
        } else {
            natTreatment.setPropertyValue(CT_FLAGS, 0);
            natTreatment.setPropertyValue(CT_PRESENT_FLAGS, 0);
        }
    } catch (Exception e) {
        log.error("Failed to set NAT due to error : {}", e.getMessage());
        return null;
    }
    ExtensionTreatment ctTreatment = etr.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_CT.type());
    try {
        List<ExtensionTreatment> nat = new ArrayList<>();
        if (natAction) {
            nat.add(natTreatment);
        }
        ctTreatment.setPropertyValue(CT_FLAGS, commit ? 1 : 0);
        ctTreatment.setPropertyValue(CT_ZONE, zone);
        ctTreatment.setPropertyValue(CT_TABLE, table > -1 ? table : 0xff);
        ctTreatment.setPropertyValue("nestedActions", nat);
    } catch (Exception e) {
        log.error("Failed to set CT due to error : {}", e.getMessage());
        return null;
    }
    return ctTreatment;
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(true, DateTime.now()));
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        store.updatePorts(provider().id(), deviceId, portConfig.getPortsDescription());
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    deviceLocalStatus.put(deviceId, new LocalStatus(true, DateTime.now()));
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (portConfig != null) {
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(provider().id(), deviceId).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        List<PortDescription> portDescriptions = complete.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
        store.updatePorts(provider().id(), deviceId, portDescriptions);
    }
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
@Override
public void updatePorts(DeviceId deviceId, List<PortDescription> portDescriptions) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(portDescriptions, PORT_DESC_LIST_NULL);
    checkValidity();
    if (!mastershipService.isLocalMaster(deviceId)) {
        // Never been a master for this device
        // any update will be ignored.
        log.trace("Ignoring {} port updates on standby node. {}", deviceId, portDescriptions);
        return;
    }
    portDescriptions = portDescriptions.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
    List<DeviceEvent> events = store.updatePorts(this.provider().id(), deviceId, portDescriptions);
    if (events != null) {
        for (DeviceEvent event : events) {
            post(event);
        }
    }
}
#method_after
@Override
public void updatePorts(DeviceId deviceId, List<PortDescription> portDescriptions) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(portDescriptions, PORT_DESC_LIST_NULL);
    checkValidity();
    if (!mastershipService.isLocalMaster(deviceId)) {
        // Never been a master for this device
        // any update will be ignored.
        log.trace("Ignoring {} port updates on standby node. {}", deviceId, portDescriptions);
        return;
    }
    PortDescriptionsConfig portConfig = networkConfigService.getConfig(deviceId, PortDescriptionsConfig.class);
    if (portConfig != null) {
        // updating the ports if configration exists
        portDescriptions.addAll(portConfig.portDescriptions());
    }
    portDescriptions = portDescriptions.stream().map(e -> applyAllPortOps(deviceId, e)).collect(Collectors.toList());
    List<DeviceEvent> events = store.updatePorts(this.provider().id(), deviceId, portDescriptions);
    if (events != null) {
        for (DeviceEvent event : events) {
            post(event);
        }
    }
}
#end_block

#method_before
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    return (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED) && (event.configClass().equals(BasicDeviceConfig.class) || portOpsIndex.containsKey(event.configClass()) || event.configClass().equals(PortDescriptionConfig.class));
}
#method_after
@Override
public boolean isRelevant(NetworkConfigEvent event) {
    return (event.type() == NetworkConfigEvent.Type.CONFIG_ADDED || event.type() == NetworkConfigEvent.Type.CONFIG_UPDATED) && (event.configClass().equals(BasicDeviceConfig.class) || portOpsIndex.containsKey(event.configClass()) || event.configClass().equals(PortDescriptionsConfig.class));
}
#end_block

#method_before
@Override
public void event(NetworkConfigEvent event) {
    DeviceEvent de = null;
    DeviceId did = (DeviceId) event.subject();
    DeviceProvider dp = getProvider(did);
    if (event.configClass().equals(BasicDeviceConfig.class)) {
        log.debug("Detected device network config event {}", event.type());
        BasicDeviceConfig cfg = networkConfigService.getConfig(did, BasicDeviceConfig.class);
        if (!isAllowed(cfg)) {
            kickOutBadDevice(did);
        } else {
            Device dev = getDevice(did);
            DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
            desc = BasicDeviceOperator.combine(cfg, desc);
            if (desc != null && dp != null) {
                de = store.createOrUpdateDevice(dp.id(), did, desc);
            }
        }
    }
    if (event.configClass().equals(PortDescriptionConfig.class) && getDevice(did) != null) {
        PortDescriptionConfig portConfig = networkConfigService.getConfig(did, PortDescriptionConfig.class);
        if (portConfig != null && dp != null) {
            // updating the ports if configration exists
            List<PortDescription> complete = portConfig.getPortsDescription();
            complete.addAll(store.getPortDescriptions(dp.id(), did).collect(Collectors.toList()));
            store.updatePorts(dp.id(), did, complete);
        }
    }
    if (portOpsIndex.containsKey(event.configClass())) {
        ConnectPoint cpt = (ConnectPoint) event.subject();
        // Note: assuming PortOperator can modify existing port,
        // but cannot add new port purely from Config.
        de = Optional.ofNullable(dp).map(provider -> store.getPortDescription(provider.id(), did, cpt.port())).map(desc -> applyAllPortOps(cpt, desc)).map(desc -> store.updatePortStatus(dp.id(), did, desc)).orElse(null);
    }
    if (de != null) {
        post(de);
    }
}
#method_after
@Override
public void event(NetworkConfigEvent event) {
    DeviceEvent de = null;
    DeviceId did = (DeviceId) event.subject();
    DeviceProvider dp = getProvider(did);
    if (event.configClass().equals(BasicDeviceConfig.class)) {
        log.debug("Detected device network config event {}", event.type());
        BasicDeviceConfig cfg = networkConfigService.getConfig(did, BasicDeviceConfig.class);
        if (!isAllowed(cfg)) {
            kickOutBadDevice(did);
        } else {
            Device dev = getDevice(did);
            DeviceDescription desc = (dev == null) ? null : BasicDeviceOperator.descriptionOf(dev);
            desc = BasicDeviceOperator.combine(cfg, desc);
            if (desc != null && dp != null) {
                de = store.createOrUpdateDevice(dp.id(), did, desc);
            }
        }
    }
    if (event.configClass().equals(PortDescriptionsConfig.class) && event.config().isPresent() && getDevice(did) != null && dp != null) {
        PortDescriptionsConfig portConfig = (PortDescriptionsConfig) event.config().get();
        // updating the ports if configration exists
        List<PortDescription> complete = store.getPortDescriptions(dp.id(), did).collect(Collectors.toList());
        complete.addAll(portConfig.portDescriptions());
        store.updatePorts(dp.id(), did, complete);
    }
    if (portOpsIndex.containsKey(event.configClass())) {
        ConnectPoint cpt = (ConnectPoint) event.subject();
        // Note: assuming PortOperator can modify existing port,
        // but cannot add new port purely from Config.
        de = Optional.ofNullable(dp).map(provider -> store.getPortDescription(provider.id(), did, cpt.port())).map(desc -> applyAllPortOps(cpt, desc)).map(desc -> store.updatePortStatus(dp.id(), did, desc)).orElse(null);
    }
    if (de != null) {
        post(de);
    }
}
#end_block

#method_before
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Field matches.
    PiMatchKey.Builder piMatchKeyBuilder = PiMatchKey.builder();
    for (FieldMatch fieldMatchMsg : tableEntryMsg.getMatchList()) {
        piMatchKeyBuilder.addFieldMatch(decodeFieldMatchMsg(fieldMatchMsg, tableInfo, browser));
    }
    piTableEntryBuilder.withMatchKey(piMatchKeyBuilder.build());
    return piTableEntryBuilder.build();
}
#method_after
private static PiTableEntry decodeTableEntryMsg(TableEntry tableEntryMsg, P4InfoBrowser browser) throws P4InfoBrowser.NotFoundException, EncodeException {
    PiTableEntry.Builder piTableEntryBuilder = PiTableEntry.builder();
    P4InfoOuterClass.Table tableInfo = browser.tables().getById(tableEntryMsg.getTableId());
    // Table id.
    piTableEntryBuilder.forTable(PiTableId.of(tableInfo.getPreamble().getName()));
    // Priority.
    piTableEntryBuilder.withPriority(tableEntryMsg.getPriority());
    // Controller metadata (cookie)
    piTableEntryBuilder.withCookie(tableEntryMsg.getControllerMetadata());
    // Table action.
    piTableEntryBuilder.withAction(decodeTableActionMsg(tableEntryMsg.getAction(), browser));
    // Timeout.
    // FIXME: how to decode table entry messages with timeout, given that the timeout value is lost after encoding?
    // Match key for field matches.
    PiMatchKey.Builder piMatchKeyBuilder = PiMatchKey.builder();
    for (FieldMatch fieldMatchMsg : tableEntryMsg.getMatchList()) {
        piMatchKeyBuilder.addFieldMatch(decodeFieldMatchMsg(fieldMatchMsg, tableInfo, browser));
    }
    piTableEntryBuilder.withMatchKey(piMatchKeyBuilder.build());
    return piTableEntryBuilder.build();
}
#end_block

#method_before
private String ip4State(DhcpRecord record) {
    return ipState(record.ip4Address().map(Object::toString).orElse(NA), record.ip4Status().map(Object::toString).orElse(NA), record.directlyConnected(), record.nextHop().orElse(null), record.vlanId());
}
#method_after
private String ip4State(DhcpRecord record) {
    String nextHopIp = findNextHopIp(IpAddress::isIp4, record.nextHop().orElse(null), record.vlanId());
    return ipState(record.ip4Address().map(Object::toString).orElse(NA), record.ip4Status().map(Object::toString).orElse(NA), record.directlyConnected(), nextHopIp);
}
#end_block

#method_before
private String ip6State(DhcpRecord record) {
    return ipState(record.ip6Address().map(Object::toString).orElse(NA), record.ip6Status().map(Object::toString).orElse(NA), record.directlyConnected(), record.nextHop().orElse(null), record.vlanId());
}
#method_after
private String ip6State(DhcpRecord record) {
    String nextHopIp = findNextHopIp(IpAddress::isIp6, record.nextHop().orElse(null), record.vlanId());
    return ipState(record.ip6Address().map(Object::toString).orElse(NA), record.ip6Status().map(Object::toString).orElse(NA), record.directlyConnected(), nextHopIp);
}
#end_block

#method_before
private String ipState(String ipAddress, String status, boolean directlyConnected, MacAddress nextHopAddress, VlanId vlanId) {
    if (directlyConnected) {
        return String.format(STATUS_FMT, ipAddress, status);
    } else {
        String nextHopAddr = findNextHopIp(nextHopAddress, vlanId).map(Object::toString).orElse(NA);
        return String.format(STATUS_FMT_NH, ipAddress, nextHopAddr, status);
    }
}
#method_after
private String ipState(String ipAddress, String status, boolean directlyConnected, String nextHopIp) {
    if (directlyConnected) {
        return String.format(STATUS_FMT, ipAddress, status);
    } else {
        return String.format(STATUS_FMT_NH, ipAddress, nextHopIp, status);
    }
}
#end_block

#method_before
private Optional<IpAddress> findNextHopIp(MacAddress macAddress, VlanId vlanId) {
    if (macAddress == null || vlanId == null) {
        return Optional.empty();
    }
    Host host = HOST_SERVICE.getHost(HostId.hostId(macAddress, vlanId));
    return host.ipAddresses().stream().findFirst();
}
#method_after
private String findNextHopIp(Predicate<IpAddress> ipFilter, MacAddress nextHopMac, VlanId vlanId) {
    if (ipFilter == null || nextHopMac == null || vlanId == null) {
        return NA;
    }
    Host host = HOST_SERVICE.getHost(HostId.hostId(nextHopMac, vlanId));
    if (host == null) {
        return NA;
    }
    return host.ipAddresses().stream().filter(ipFilter).filter(ip -> !ip.isLinkLocal()).map(Object::toString).findFirst().orElse(NA);
}
#end_block

#method_before
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new PortDataRequest(), new PortDataFilterRequestHandler());
}
#method_after
@Override
protected Collection<RequestHandler> createRequestHandlers() {
    return ImmutableSet.of(new PortDataRequest());
}
#end_block

#method_before
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    String uri = string(payload, "devId");
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceId deviceId = DeviceId.deviceId(uri);
        DeviceService ds = get(DeviceService.class);
        List<PortStatistics> stats = delta ? ds.getPortDeltaStatistics(deviceId) : ds.getPortStatistics(deviceId);
        for (PortStatistics stat : stats) {
            if (nz && stat.isZero())
                continue;
            populateRow(tm.addRow(), stat);
        }
    }
}
#method_after
@Override
protected void populateTable(TableModel tm, ObjectNode payload) {
    String uri = string(payload, "devId");
    boolean nz = bool(payload, NZ);
    boolean delta = bool(payload, DELTA);
    if (!Strings.isNullOrEmpty(uri)) {
        DeviceId deviceId = DeviceId.deviceId(uri);
        DeviceService ds = get(DeviceService.class);
        List<PortStatistics> stats = delta ? ds.getPortDeltaStatistics(deviceId) : ds.getPortStatistics(deviceId);
        for (PortStatistics stat : stats) {
            if (nz && stat.isZero()) {
                continue;
            }
            populateRow(tm.addRow(), stat);
        }
    }
}
#end_block

#method_before
private boolean init() {
    DeviceId deviceId = handler().data().deviceId();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    if (!controller.hasClient(deviceId)) {
        log.warn("Unable to find client for {}, aborting the sending packet", deviceId);
        return false;
    }
    client = controller.getClient(deviceId);
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (piPipeconfService.ofDevice(deviceId).isPresent() && piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    } else {
        log.warn("Unable to get the pipeconf of the {}", deviceId);
        return false;
    }
    DeviceService deviceService = handler().get(DeviceService.class);
    Device device = deviceService.getDevice(deviceId);
    interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    if (interpreter == null) {
        log.warn("Device {} unable to instantiate interpreter of pipeconf {}", deviceId, pipeconf.id());
        return false;
    }
    return true;
}
#method_after
private boolean init() {
    deviceId = handler().data().deviceId();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    if (!controller.hasClient(deviceId)) {
        log.warn("Unable to find client for {}, aborting flow rule operation", deviceId);
        return false;
    }
    client = controller.getClient(deviceId);
    piFlowRuleTranslationService = handler().get(PiFlowRuleTranslationService.class);
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    if (piPipeconfService.ofDevice(deviceId).isPresent() && piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    } else {
        log.warn("Unable to get the pipeconf of {}", deviceId);
        return false;
    }
    DeviceService deviceService = handler().get(DeviceService.class);
    Device device = deviceService.getDevice(deviceId);
    interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    if (device.is(PiPipelineInterpreter.class)) {
        log.warn("Device {} unable to instantiate interpreter of pipeconf {}", deviceId, pipeconf.id());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!init()) {
        return Collections.emptyList();
    }
    Collection<FlowEntry> flowEntries = new ArrayList<>();
    Collection<PiTableId> piTableIds = new ArrayList<>();
    piTableIds.stream().forEach(i -> {
        CompletableFuture<Collection<PiTableEntry>> result;
        result = client.dumpTable(i, pipeconf);
        result.handle((piTableEntries, e) -> {
            piTableEntries.stream().forEach(p -> flowEntries.add(mapPitableEntry(p)));
            return e;
        });
    });
    return Collections.unmodifiableCollection(flowEntries);
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    if (!init()) {
        return Collections.emptyList();
    }
    // TD DO: retrieve statistics.
    long packets = 0;
    long bytes = 0;
    Collection<FlowEntry> flowEntries = INSTALLED_FLOWENTRIES.get(deviceId).stream().map(wrapper -> new DefaultFlowEntry(wrapper.rule(), FlowEntry.FlowEntryState.ADDED, wrapper.lifeInSeconds(), packets, bytes)).collect(Collectors.toList());
    return Collections.unmodifiableCollection(flowEntries);
}
#end_block

#method_before
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    return processFlowRules(rules, WriteOperationType.INSERT);
}
#method_after
@Override
public Collection<FlowRule> applyFlowRules(Collection<FlowRule> rules) {
    Collection<FlowRule> insertFlowRules = rules.stream().filter(r -> INSTALLED_FLOWENTRIES.get(deviceId) == null || INSTALLED_FLOWENTRIES.get(deviceId).stream().noneMatch(x -> x.rule().id() == r.id())).collect(Collectors.toList());
    Collection<FlowRule> updateFlowRules = rules.stream().filter(r -> INSTALLED_FLOWENTRIES.get(deviceId) != null && INSTALLED_FLOWENTRIES.get(deviceId).stream().anyMatch(x -> x.rule().id() == r.id())).collect(Collectors.toList());
    Collection<FlowRule> flowRules = processFlowRules(insertFlowRules, WriteOperationType.INSERT);
    flowRules.addAll(processFlowRules(updateFlowRules, WriteOperationType.MODIFY));
    return flowRules;
}
#end_block

#method_before
private Collection<FlowRule> processFlowRules(Collection<FlowRule> rules, WriteOperationType opType) {
    if (!init()) {
        return Collections.emptyList();
    }
    Collection<PiTableEntry> piTableEntries = rules.stream().map(r -> {
        PiTableAction piTableAction;
        try {
            piTableAction = interpreter.mapTreatment(r.treatment(), pipeconf);
        } catch (PiPipelineInterpreter.PiInterpreterException e) {
            return null;
        }
        PiTableEntry piTableEntry = PiTableEntry.builder().forTable(interpreter.mapFlowRuleTableId(r.tableId()).get()).withPriority(r.priority()).withTimeout(r.timeout()).withAction(piTableAction).build();
        return piTableEntry;
    }).collect(Collectors.toList());
    client.writeTableEntries(piTableEntries, opType, pipeconf);
    return rules;
}
#method_after
private Collection<FlowRule> processFlowRules(Collection<FlowRule> rules, WriteOperationType opType) {
    if (!init()) {
        return Collections.emptyList();
    }
    Collection<PiTableEntry> piTableEntries = rules.stream().map(r -> {
        PiTableEntry piTableEntry = null;
        try {
            piTableEntry = piFlowRuleTranslationService.translate(r, pipeconf);
        } catch (PiFlowRuleTranslationService.PiFlowRuleTranslationException e) {
            log.error("Flow rule {} can not translte to PiTableEntry {}", r.toString(), e.getMessage());
        }
        return piTableEntry;
    }).collect(Collectors.toList());
    Collection<FlowRule> installedEntries = Collections.emptyList();
    client.writeTableEntries(piTableEntries, opType, pipeconf).whenComplete((r, e) -> {
        if (r) {
            Collection<Bmv2FlowRuleWrapper> bmv2FlowRuleWrappers = rules.stream().map(rule -> new Bmv2FlowRuleWrapper(rule, System.currentTimeMillis())).collect(Collectors.toList());
            if (opType == WriteOperationType.INSERT) {
                INSTALLED_FLOWENTRIES.put(deviceId, bmv2FlowRuleWrappers);
            } else if (opType == WriteOperationType.MODIFY) {
                rules.stream().forEach(rule -> INSTALLED_FLOWENTRIES.get(deviceId).removeIf(x -> x.rule().id() == rule.id()));
                INSTALLED_FLOWENTRIES.put(deviceId, bmv2FlowRuleWrappers);
            } else if (opType == WriteOperationType.DELETE) {
                INSTALLED_FLOWENTRIES.get(deviceId).removeAll(bmv2FlowRuleWrappers);
            }
            installedEntries.addAll(rules);
        }
    });
    return installedEntries;
}
#end_block

#method_before
@Test
public void checkRpcContext() {
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    rIdBlr = addToResourceId(rIdBlr, "hello-world", NS, value);
    provider.processSchemaRegistry();
    DefaultSchemaContextProvider scp = new DefaultSchemaContextProvider(provider.registry());
    RpcContext context = scp.getRpcContext(rIdBlr.build());
    assertEquals(context.rpcName(), "helloWorld");
    assertEquals(context.serviceIntf().toString(), "interface org.onosproject" + ".yang.gen.v1.hello.rev20150105.HelloService");
}
#method_after
@Test
public void checkRpcContext() {
    setUp();
    ResourceId.Builder rIdBlr = initializeResourceId(context);
    rIdBlr = addToResourceId(rIdBlr, "hello-world", NS, value);
    DefaultSchemaContextProvider scp = new DefaultSchemaContextProvider(reg);
    RpcContext context = scp.getRpcContext(rIdBlr.build());
    assertEquals(context.rpcName(), "helloWorld");
    assertEquals(context.serviceIntf().toString(), "interface org.onosproject" + ".yang.gen.v1.hello.rev20150105.HelloService");
}
#end_block

#method_before
@Override
public RpcContext getRpcContext(ResourceId id) {
    SchemaId schemaId = id.nodeKeys().get(1).schemaId();
    // check for namespace
    String rpcname;
    String namespace = schemaId.namespace();
    SchemaContext childContext = reg.getChildContext(schemaId);
    YangSchemaNode childNode = (YangSchemaNode) childContext;
    rpcname = childNode.getJavaAttributeName();
    YangSchemaNode moduleNode = reg.getForNameSpace(namespace, false);
    String pkg = moduleNode.getJavaPackage();
    String moduleClassName = moduleNode.getJavaClassNameOrBuiltInType();
    String moduleQlName = pkg + "." + getCapitalCase(moduleClassName);
    Class<?> moduleClass = reg.getRegisteredClass(moduleNode);
    ClassLoader classLoader = moduleClass.getClassLoader();
    Class<?> rpcServiceIntf;
    try {
        rpcServiceIntf = classLoader.loadClass(moduleQlName + "Service");
    } catch (ClassNotFoundException e) {
        throw new ModelConvertorException(e);
    }
    return new RpcContext(rpcname, (Class<? extends RpcService>) rpcServiceIntf);
}
#method_after
@Override
public RpcContext getRpcContext(ResourceId id) {
    SchemaId schemaId = id.nodeKeys().get(1).schemaId();
    String rpcname;
    SchemaContext childContext = reg.getChildContext(schemaId);
    if (childContext == null) {
        throw new IllegalArgumentException("Module is not registered or " + "RPC name doesn't " + "exist in module.");
    }
    YangSchemaNode childNode = (YangSchemaNode) childContext;
    rpcname = childNode.getJavaAttributeName();
    YangSchemaNode moduleNode = (YangSchemaNode) childNode.getNameSpace();
    String pkg = moduleNode.getJavaPackage();
    String moduleClassName = moduleNode.getJavaClassNameOrBuiltInType();
    String moduleQlName = pkg + PERIOD + getCapitalCase(moduleClassName);
    Class<?> moduleClass = reg.getRegisteredClass(moduleNode);
    ClassLoader classLoader = moduleClass.getClassLoader();
    Class rpcServiceIntf = null;
    try {
        rpcServiceIntf = classLoader.loadClass(moduleQlName + SERVICE);
    } catch (ClassNotFoundException e) {
        log.error("Not able to load service interface class");
    }
    return new RpcContext(rpcname, rpcServiceIntf);
}
#end_block

#method_before
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    addResolvedAugmentedDataNodeImports(curNode);
    JavaQualifiedTypeInfoTranslator typeInfo = new JavaQualifiedTypeInfoTranslator();
    typeInfo.setClassInfo(RPC_SERVICE);
    typeInfo.setPkgInfo(MODEL_OBJECT_PKG);
    typeInfo.setForInterface(true);
    ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    boolean rpcInput = false;
    boolean rpcOutput = false;
    YangNode subNode = curNode.getChild();
    while (subNode != null) {
        if (subNode.getNodeType() == YangNodeType.RPC_NODE) {
            YangNode childNode1 = subNode.getChild();
            while (childNode1 != null) {
                if (childNode1.getNodeType() == YangNodeType.INPUT_NODE) {
                    rpcInput = true;
                } else {
                    rpcOutput = true;
                }
                childNode1 = childNode1.getNextSibling();
            }
        }
        subNode = subNode.getNextSibling();
        if (rpcInput & rpcOutput) {
            break;
        }
    }
    if (rpcInput) {
        JavaQualifiedTypeInfoTranslator typeInfo1 = new JavaQualifiedTypeInfoTranslator();
        typeInfo1.setClassInfo("RpcInput");
        typeInfo1.setPkgInfo(MODEL_OBJECT_PKG);
        typeInfo1.setForInterface(true);
        ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo1, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    }
    if (rpcOutput) {
        JavaQualifiedTypeInfoTranslator typeInfo2 = new JavaQualifiedTypeInfoTranslator();
        typeInfo2.setClassInfo("RpcOutput");
        typeInfo2.setPkgInfo(MODEL_OBJECT_PKG);
        typeInfo2.setForInterface(true);
        ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo2, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    }
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().getImports(true);
    createPackage(curNode);
    /*boolean notification = false;
        if (curNode instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) curNode).getNotificationNodes()
                    .isEmpty()) {
                notification = true;
            }
        } else if (curNode instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) curNode).getNotificationNodes()
                    .isEmpty()) {
                notification = true;
            }
        }

        if (notification) {
            addListenersImport(curNode, imports, ADD);
        } */
    serviceJavaFileHandle = getJavaFileHandle(getJavaClassName(SERVICE));
    generateServiceInterfaceFile(serviceJavaFileHandle, curNode, imports);
    // Close all the file handles.
    freeTemporaryResources(false);
}
#method_after
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    addResolvedAugmentedDataNodeImports(curNode);
    JavaQualifiedTypeInfoTranslator typeInfo = new JavaQualifiedTypeInfoTranslator();
    typeInfo.setClassInfo(RPC_SERVICE);
    typeInfo.setPkgInfo(MODEL_OBJECT_PKG);
    typeInfo.setForInterface(true);
    ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    boolean rpcInput = false;
    boolean rpcOutput = false;
    YangNode subNode = curNode.getChild();
    while (subNode != null) {
        if (subNode.getNodeType() == YangNodeType.RPC_NODE) {
            YangNode childNode1 = subNode.getChild();
            while (childNode1 != null) {
                if (childNode1.getNodeType() == YangNodeType.INPUT_NODE) {
                    rpcInput = true;
                } else {
                    rpcOutput = true;
                }
                childNode1 = childNode1.getNextSibling();
            }
        }
        subNode = subNode.getNextSibling();
        if (rpcInput & rpcOutput) {
            break;
        }
    }
    JavaQualifiedTypeInfoTranslator typeInfo1 = new JavaQualifiedTypeInfoTranslator();
    typeInfo1.setClassInfo(RPC_INPUT);
    typeInfo1.setPkgInfo(MODEL_OBJECT_PKG);
    typeInfo1.setForInterface(true);
    ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo1, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    JavaQualifiedTypeInfoTranslator typeInfo2 = new JavaQualifiedTypeInfoTranslator();
    typeInfo2.setClassInfo(RPC_OUTPUT);
    typeInfo2.setPkgInfo(MODEL_OBJECT_PKG);
    typeInfo2.setForInterface(true);
    ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().addImportInfo(typeInfo2, getJavaClassName(SERVICE), getJavaFileInfo().getPackage());
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().getImports(true);
    createPackage(curNode);
    /*boolean notification = false;
        if (curNode instanceof YangJavaModuleTranslator) {
            if (!((YangJavaModuleTranslator) curNode).getNotificationNodes()
                    .isEmpty()) {
                notification = true;
            }
        } else if (curNode instanceof YangJavaSubModuleTranslator) {
            if (!((YangJavaSubModuleTranslator) curNode).getNotificationNodes()
                    .isEmpty()) {
                notification = true;
            }
        }

        if (notification) {
            addListenersImport(curNode, imports, ADD);
        } */
    serviceJavaFileHandle = getJavaFileHandle(getJavaClassName(SERVICE));
    generateServiceInterfaceFile(serviceJavaFileHandle, curNode, imports);
    // Close all the file handles.
    freeTemporaryResources(false);
}
#end_block

#method_before
private void addRpcString(JavaAttributeInfo inAttr, JavaAttributeInfo outAttr, String rpcName) throws IOException {
    String rpcInput = null;
    String rpcOutput = VOID;
    String rpcIn = EMPTY_STRING;
    if (inAttr != null) {
        rpcInput = RPC_INPUT;
    }
    if (outAttr != null) {
        rpcOutput = RPC_OUTPUT;
    }
    if (rpcInput != null) {
        rpcIn = RPC_INPUT_VAR_NAME;
    }
    appendToFile(rpcInterfaceTempFileHandle, generateJavaDocForRpc(rpcName, rpcIn, rpcOutput) + getRpcServiceMethod(rpcName, rpcInput, rpcOutput));
}
#method_after
private void addRpcString(JavaAttributeInfo inAttr, JavaAttributeInfo outAttr, String rpcName) throws IOException {
    String rpcInput = RPC_INPUT;
    String rpcOutput = RPC_OUTPUT;
    String rpcIn = RPC_INPUT_VAR_NAME;
    appendToFile(rpcInterfaceTempFileHandle, generateJavaDocForRpc(rpcName, rpcIn, rpcOutput) + getRpcServiceMethod(rpcName, rpcInput, rpcOutput));
}
#end_block

#method_before
private DeviceEvent markOfflineInternal(DeviceId deviceId, Timestamp timestamp) {
    Map<ProviderId, DeviceDescriptions> providerDescs = getOrCreateDeviceDescriptionsMap(deviceId);
    // locking device
    synchronized (providerDescs) {
        // accept off-line if given timestamp is newer than
        // the latest Timestamp from Primary provider
        DeviceDescriptions primDescs = getPrimaryDescriptions(providerDescs);
        if (primDescs == null) {
            return null;
        }
        Timestamp lastTimestamp = primDescs.getLatestTimestamp();
        if ((lastTimestamp != null) && (timestamp.compareTo(lastTimestamp) <= 0)) {
            // outdated event ignore
            return null;
        }
        offline.put(deviceId, timestamp);
        Device device = devices.get(deviceId);
        if (device == null) {
            return null;
        }
        boolean removed = availableDevices.remove(deviceId);
        if (removed) {
            return new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, device, null);
        }
        return null;
    }
}
#method_after
private DeviceEvent markOfflineInternal(DeviceId deviceId, Timestamp timestamp) {
    Map<ProviderId, DeviceDescriptions> providerDescs = getOrCreateDeviceDescriptionsMap(deviceId);
    // locking device
    synchronized (providerDescs) {
        // accept off-line if given timestamp is newer than
        // the latest Timestamp from Primary provider
        DeviceDescriptions primDescs = getPrimaryDescriptions(providerDescs);
        if (primDescs == null) {
            return null;
        }
        Timestamp lastTimestamp = primDescs.getLatestTimestamp();
        if (lastTimestamp == null) {
            lastTimestamp = deviceClockService.getTimestamp(deviceId);
        }
        if (timestamp.compareTo(lastTimestamp) <= 0) {
            // outdated event ignore
            return null;
        }
        offline.put(deviceId, timestamp);
        Device device = devices.get(deviceId);
        if (device == null) {
            return null;
        }
        boolean removed = availableDevices.remove(deviceId);
        if (removed) {
            return new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, device, null);
        }
        return null;
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    providerService = providerRegistry.register(this);
    coreService.registerApplication(APP_NAME);
    controller.addListener(packetListener);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    providerService = providerRegistry.register(this);
    controller.addListener(packetListener);
    log.info("Started");
}
#end_block

#method_before
@Override
public void emit(OutboundPacket packet) {
    if (packet != null) {
        DeviceId deviceId = packet.sendThrough();
        Device device = deviceService.getDevice(deviceId);
        if (device.is(PacketProgrammable.class)) {
            PacketProgrammable packetProgrammable = device.as(PacketProgrammable.class);
            packetProgrammable.emit(packet);
        } else {
            log.info("No PacketProgrammable behavior for device {}", deviceId);
        }
    }
}
#method_after
@Override
public void emit(OutboundPacket packet) {
    if (packet != null) {
        DeviceId deviceId = packet.sendThrough();
        Device device = deviceService.getDevice(deviceId);
        if (device.is(PacketProgrammable.class)) {
            PacketProgrammable packetProgrammable = device.as(PacketProgrammable.class);
            packetProgrammable.emit(packet);
        } else {
            log.warn("No PacketProgrammable behavior for device {}", deviceId);
        }
    }
}
#end_block

#method_before
@Override
public void send() {
    if (this.block()) {
        log.info("Unable to send, packet context not blocked");
        return;
    }
    DeviceId deviceId = outPacket().sendThrough();
    ByteBuffer rawData = outPacket().data();
    TrafficTreatment treatment;
    if (outPacket().treatment() == null) {
        treatment = (treatmentBuilder() == null) ? emptyTreatment() : treatmentBuilder().build();
    } else {
        treatment = outPacket().treatment();
    }
    // P4Runtime doesn't support FLOOD for packet-outs.
    // Workaround here is to perform multiple emits, one for each device port != packet inPort.
    Optional<Instructions.OutputInstruction> floodInst = treatment.allInstructions().stream().filter(i -> i.type().equals(OUTPUT)).map(i -> (Instructions.OutputInstruction) i).filter(i -> i.port().equals(FLOOD)).findAny();
    if (floodInst.isPresent() && treatment.allInstructions().size() == 1) {
        // Only one instruction and is FLOOD. Do the trick.
        PortNumber inPort = inPacket().receivedFrom().port();
        deviceService.getPorts(outPacket().sendThrough()).stream().map(Port::number).filter(port -> !port.equals(inPort)).map(outPort -> DefaultTrafficTreatment.builder().setOutput(outPort).build()).map(outTreatment -> new DefaultOutboundPacket(deviceId, outTreatment, rawData)).forEach(P4RuntimePacketProvider.this::emit);
    } else {
        // Not FLOOD treatment, what to do is up to driver.
        emit(new DefaultOutboundPacket(deviceId, treatment, rawData));
    }
}
#method_after
@Override
public void send() {
    if (this.block()) {
        log.info("Unable to send, packet context is blocked");
        return;
    }
    DeviceId deviceId = outPacket().sendThrough();
    ByteBuffer rawData = outPacket().data();
    TrafficTreatment treatment;
    if (outPacket().treatment() == null) {
        treatment = (treatmentBuilder() == null) ? emptyTreatment() : treatmentBuilder().build();
    } else {
        treatment = outPacket().treatment();
    }
    emit(new DefaultOutboundPacket(deviceId, treatment, rawData));
}
#end_block

#method_before
@Override
public void event(P4RuntimeEvent event) {
/**
 * TODO: handle packet-in event.
 */
}
#method_after
@Override
public void event(P4RuntimeEvent event) {
/**
 * TODO: handle packet-in event.
 * The inputport need parse from metadata() of packet_in event,
 * but support for parsing metadata() is not ready yet.
 */
}
#end_block

#method_before
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    } catch (TimeoutException toe) {
        log.warn("Closing session {} for {} because timeout reached waiting " + "for reply", sessionID, deviceInfo);
        // Closes the socket which should interrupt NetconfStreamThread
        netconfConnection.close();
        sshSession.close();
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed because reply not received", Optional.of(-1), deviceInfo);
        primaryListeners.forEach(listener -> listener.event(event));
        replies.clear();
        errorReplies.clear();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " Timeout waiting for reply for request " + request, toe);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request, e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        // Closes the socket which should interrupt NetconfStreamThread
        netconfConnection.close();
        sshSession.close();
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        replies.clear();
        errorReplies.clear();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
@Override
public void event(NetconfDeviceOutputEvent event) {
    primaryListeners.forEach(lsnr -> {
        if (lsnr.isRelevant(event)) {
            lsnr.event(event);
        }
    });
}
#method_after
@Override
public void event(NetconfDeviceOutputEvent event) {
    publishEvent(event);
}
#end_block

#method_before
private void startClient() throws IOException {
    client = SshClient.setUpDefaultClient();
    client.start();
    client.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());
    startSession();
}
#method_after
private void startClient() throws IOException {
    client = SshClient.setUpDefaultClient();
    int replyTimeoutSec = NetconfControllerImpl.netconfIdleTimeout;
    client.getProperties().putIfAbsent(FactoryManager.IDLE_TIMEOUT, TimeUnit.SECONDS.toMillis(replyTimeoutSec));
    client.getProperties().putIfAbsent(FactoryManager.NIO2_READ_TIMEOUT, TimeUnit.SECONDS.toMillis(replyTimeoutSec + 15L));
    client.start();
    client.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());
    startSession();
}
#end_block

#method_before
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        replies.remove(messageId);
    } catch (InterruptedException | ExecutionException e) {
        throw new NetconfException("No matching reply for request " + request, e);
    } catch (TimeoutException toe) {
        log.warn("Closing session {} for {} because timeout reached waiting " + "for reply", sessionID, deviceInfo);
        try {
            session.close();
            // Closes the socket which should interrupt NetconfStreamThread
            channel.close();
            client.close();
        } catch (IOException ioe) {
            log.warn("Error closing session {} on {}", sessionID, deviceInfo, ioe);
        }
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed because reply not received", Optional.of(-1), deviceInfo);
        primaryListeners.forEach(listener -> listener.event(event));
        replies.clear();
        errorReplies.clear();
        cleanUp();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " Timeout waiting for reply for request " + request, toe);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#method_after
private String sendRequest(String request, boolean isHello) throws NetconfException {
    checkAndReestablish();
    int messageId = -1;
    if (!isHello) {
        messageId = messageIdInteger.getAndIncrement();
    }
    request = formatRequestMessageId(request, messageId);
    request = formatXmlHeader(request);
    CompletableFuture<String> futureReply = request(request, messageId);
    int replyTimeout = NetconfControllerImpl.netconfReplyTimeout;
    String rp;
    try {
        rp = futureReply.get(replyTimeout, TimeUnit.SECONDS);
        // Why here???
        replies.remove(messageId);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new NetconfException("Interrupted waiting for reply for request" + request, e);
    } catch (TimeoutException e) {
        throw new NetconfException("Timed out waiting for reply for request " + request, e);
    } catch (ExecutionException e) {
        log.warn("Closing session {} for {} due to unexpected Error", sessionID, deviceInfo, e);
        try {
            session.close();
            // Closes the socket which should interrupt NetconfStreamThread
            channel.close();
            client.close();
        } catch (IOException ioe) {
            log.warn("Error closing session {} on {}", sessionID, deviceInfo, ioe);
        }
        NetconfDeviceOutputEvent event = new NetconfDeviceOutputEvent(NetconfDeviceOutputEvent.Type.SESSION_CLOSED, null, "Closed due to unexpected error " + e.getCause(), Optional.of(-1), deviceInfo);
        publishEvent(event);
        // move to cleanUp()?
        errorReplies.clear();
        cleanUp();
        throw new NetconfException("Closing session " + sessionID + " for " + deviceInfo + " for request " + request, e);
    }
    log.debug("Result {} from request {} to device {}", rp, request, deviceInfo);
    return rp.trim();
}
#end_block

#method_before
@Override
public void event(NetconfDeviceOutputEvent event) {
    primaryListeners.forEach(lsnr -> {
        if (lsnr.isRelevant(event)) {
            lsnr.event(event);
        }
    });
}
#method_after
@Override
public void event(NetconfDeviceOutputEvent event) {
    publishEvent(event);
}
#end_block

#method_before
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    log.debug("messageID {}, waiting replies messageIDs {}", messageId, replies.keySet());
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#method_after
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    log.debug("messageID {}, waiting replies messageIDs {}", messageId, replies.keySet());
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = // remove(..)?
    replies.get(messageId.get());
    if (completedReply != null) {
        completedReply.complete(event.getMessagePayload());
    }
}
#end_block

#method_before
@Test
public void processSingleJarLinking() throws IOException, MojoExecutionException {
    deleteDirectory(TARGET);
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(YANG_FILES_DIR)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    int size1 = utilManager.getYangFileInfoSet().size();
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.processYangModel(TARGET_RESOURCE_PATH);
    provideTestJarFile();
    utilManager.setYangFileInfoSet(removeFileInfoFromSet(utilManager.getYangFileInfoSet()));
    for (String file : getListOfTestJar(TARGET)) {
        addInterJarRootNodes(file);
    }
    utilManager.resolveDependenciesUsingLinker();
    int size2 = utilManager.getYangFileInfoSet().size();
    assertThat(true, is(size1 != size2));
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    deleteDirectory(TARGET);
    deleteTestSerFile();
}
#method_after
@Test
public void processSingleJarLinking() throws IOException, MojoExecutionException {
    deleteDirectory(TARGET);
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(YANG_FILES_DIR)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    utilManager.parseYangFileInfoSet();
    // at this point port-pair will be in current context.
    testPortPairFileForInterJar(true);
    // process jar operations. we need to add only one node in serialized
    // file which will be  added to a jar file. this jar file will be
    // used while resolving dependant schema nodes.
    // pass 1 because only 1 jar need to be created.
    processJarOperation(1);
    // at this point port-pair will be in jar context.
    testPortPairFileForInterJar(false);
    utilManager.resolveDependenciesUsingLinker();
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    deleteDirectory(TARGET);
    deleteTestSerFile();
}
#end_block

#method_before
@Test
public void processMultipleJarLinking() throws IOException, MojoExecutionException {
    deleteDirectory(TARGET);
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(YANG_FILES_DIR)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    int size1 = utilManager.getYangFileInfoSet().size();
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.processYangModel(TARGET_RESOURCE_PATH);
    provideTestJarFile();
    utilManager.setYangFileInfoSet(removeFileInfoFromSet(utilManager.getYangFileInfoSet()));
    for (String file : getListOfTestJar(TARGET)) {
        addInterJarRootNodes(file);
    }
    utilManager.resolveDependenciesUsingLinker();
    // adding process yang model for serialization
    int size2 = utilManager.getYangFileInfoSet().size();
    assertThat(true, is(size1 != size2));
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    /*
         * grouping flow-classifier {
         *      container flow-classifier {
         *           leaf id {
         *                type flow-classifier-id;
         *           }
         *
         *           leaf tenant-id {
         *                type port-pair:tenant-id;
         *           }
         *           .
         *           .
         *           .
         *
         */
    Iterator<YangFileInfo> yangFileInfoIterator = utilManager.getYangFileInfoSet().iterator();
    YangFileInfo yangFileInfo = yangFileInfoIterator.next();
    while (yangFileInfoIterator.hasNext()) {
        if (yangFileInfo.getRootNode().getName().equals("flow-classifier")) {
            break;
        }
        yangFileInfo = yangFileInfoIterator.next();
    }
    YangNode node = yangFileInfo.getRootNode();
    node = node.getChild();
    while (node != null) {
        if (node instanceof YangGrouping) {
            break;
        }
        node = node.getNextSibling();
    }
    node = node.getChild();
    ListIterator<YangLeaf> leafIterator = ((YangContainer) node).getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("id"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("flow-classifier-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tenant-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(true, is(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef().getName().equals("tenant-id")));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir(TARGET);
    utilManager.translateToJava(yangPluginConfig);
    testIfFlowClassifierFilesExists();
    testIfPortPairFileDoesNotExist();
    deleteDirectory(TARGET);
    deleteTestSerFile();
}
#method_after
@Test
public void processMultipleJarLinking() throws IOException, MojoExecutionException {
    deleteDirectory(TARGET);
    Set<Path> paths = new HashSet<>();
    for (String file : getYangFiles(YANG_FILES_DIR)) {
        paths.add(Paths.get(file));
    }
    utilManager.createYangFileInfoSet(paths);
    utilManager.parseYangFileInfoSet();
    // at this point port-pair will be in current context.
    testPortPairFileForInterJar(true);
    // process jar operations. we need to add only one node in serialized
    // file which will be  added to a jar file. this jar file will be
    // used while resolving dependant schema nodes.
    // pass 2 because 2 jar need to be created.
    processJarOperation(2);
    // at this point port-pair will be in current context.
    testPortPairFileForInterJar(false);
    utilManager.resolveDependenciesUsingLinker();
    // adding process yang model for serialization
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    assertThat(true, is(parseFileInfoSet(utilManager.getYangFileInfoSet().iterator())));
    /*
         * grouping flow-classifier {
         *      container flow-classifier {
         *           leaf id {
         *                type flow-classifier-id;
         *           }
         *
         *           leaf tenant-id {
         *                type port-pair:tenant-id;
         *           }
         *           .
         *           .
         *           .
         *
         */
    Iterator<YangFileInfo> yangFileInfoIterator = utilManager.getYangFileInfoSet().iterator();
    YangFileInfo yangFileInfo = yangFileInfoIterator.next();
    while (yangFileInfoIterator.hasNext()) {
        if (yangFileInfo.getRootNode().getName().equals("flow-classifier")) {
            break;
        }
        yangFileInfo = yangFileInfoIterator.next();
    }
    YangNode node = yangFileInfo.getRootNode();
    node = node.getChild();
    while (node != null) {
        if (node instanceof YangGrouping) {
            break;
        }
        node = node.getNextSibling();
    }
    node = node.getChild();
    ListIterator<YangLeaf> leafIterator = ((YangContainer) node).getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("id"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("flow-classifier-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tenant-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(DERIVED));
    assertThat(true, is(((YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo()).getReferredTypeDef().getName().equals("tenant-id")));
    assertThat(leafInfo.getDataType().getResolvableStatus(), is(RESOLVED));
    YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) leafInfo.getDataType().getDataTypeExtendedInfo();
    // Check for the effective built-in type.
    assertThat(derivedInfo.getEffectiveBuiltInType(), is(STRING));
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir(TARGET);
    utilManager.translateToJava(yangPluginConfig);
    testIfFlowClassifierFilesExists(false);
    testIfPortPairFileDoesNotExist();
    deleteDirectory(TARGET);
    deleteTestSerFile();
}
#end_block

#method_before
private void testIfFlowClassifierFilesExists() {
    File folder = new File(System.getProperty("user.dir") + SLASH + FLOW_CLASSIFIER_FOLDER);
    File file = new File(System.getProperty("user.dir") + SLASH + FLOW_CLASSIFIER_MANAGER);
    assertThat(true, is(folder.exists()));
    assertThat(false, is(file.exists()));
}
#method_after
private void testIfFlowClassifierFilesExists(boolean val) {
    File folder = new File(System.getProperty("user.dir") + SLASH + FLOW_CLASSIFIER_FOLDER);
    File file = new File(System.getProperty("user.dir") + SLASH + FLOW_CLASSIFIER_MANAGER);
    assertThat(val, is(folder.exists()));
    assertThat(false, is(file.exists()));
}
#end_block

#method_before
private void testIfPortPairFileDoesNotExist() {
    File folder = new File(System.getProperty("user.dir") + SLASH + PORT_PAIR_FOLDER);
    assertThat(true, is(folder.exists()));
}
#method_after
private void testIfPortPairFileDoesNotExist() {
    File folder = new File(System.getProperty("user.dir") + SLASH + PORT_PAIR_FOLDER);
    assertThat(false, is(folder.exists()));
}
#end_block

#method_before
private Set<YangFileInfo> removeFileInfoFromSet(Set<YangFileInfo> fileInfoSet) {
    String portPairFile = System.getProperty("user.dir") + SLASH + YANG_FILES_DIR + "portpair.yang";
    for (YangFileInfo fileInfo : fileInfoSet) {
        if (fileInfo.getYangFileName().equals(portPairFile)) {
            fileInfoSet.remove(fileInfo);
            return fileInfoSet;
        }
    }
    return fileInfoSet;
}
#method_after
private Set<YangFileInfo> removeFileInfoFromSet(Set<YangFileInfo> fileInfoSet, String name) {
    String portPairFile = System.getProperty("user.dir") + SLASH + YANG_FILES_DIR + name + ".yang";
    for (YangFileInfo fileInfo : fileInfoSet) {
        if (fileInfo.getYangFileName().equals(portPairFile)) {
            fileInfoSet.remove(fileInfo);
            return fileInfoSet;
        }
    }
    return fileInfoSet;
}
#end_block

#method_before
private void provideTestJarFile() throws IOException {
    String serFileDirPath = TARGET + DEFAULT_JAR_RES_PATH;
    File dir = new File(serFileDirPath);
    if (dir.exists()) {
        dir.delete();
    }
    dir.mkdirs();
    utilManager.processSerialization(System.getProperty("user.dir") + SLASH + serFileDirPath + YANG_META_DATA, id);
    createTestJar();
}
#method_after
private void provideTestJarFile(String name) throws IOException {
    String serFileDirPath = TARGET + TEMP + SLASH + YANG_RESOURCES + SLASH;
    File dir = new File(serFileDirPath);
    if (dir.exists()) {
        dir.delete();
    }
    dir.mkdirs();
    utilManager.processSerialization(System.getProperty("user.dir") + SLASH + serFileDirPath, id);
    createTestJar(name);
}
#end_block

#method_before
private void addInterJarRootNodes(String jarFile) throws IOException {
    try {
        List<YangNode> interJarResolvedNodes = new ArrayList<>();
        SerializedInfo info = parseJarFile(jarFile, TARGET);
        id = info.getModelId();
        interJarResolvedNodes.addAll(info.getYangNodes());
        for (YangNode node : interJarResolvedNodes) {
            YangFileInfo dependentFileInfo = new YangFileInfo();
            node.setToTranslate(false);
            dependentFileInfo.setRootNode(node);
            dependentFileInfo.setForTranslator(false);
            dependentFileInfo.setYangFileName(node.getName());
            utilManager.getYangFileInfoSet().add(dependentFileInfo);
        }
    } catch (IOException e) {
        throw new IOException("failed to resolve in interjar scenario.");
    }
}
#method_after
private List<YangNode> addInterJarRootNodes(String jarFile) throws IOException {
    List<YangNode> interJarResolvedNodes = new ArrayList<>();
    try {
        YangModel model = parseJarFile(jarFile, TARGET);
        id = model.getYangModelId();
        interJarResolvedNodes.addAll(getYangNodes(model));
        for (YangNode node : interJarResolvedNodes) {
            YangFileInfo dependentFileInfo = new YangFileInfo();
            node.setToTranslate(false);
            dependentFileInfo.setRootNode(node);
            dependentFileInfo.setForTranslator(false);
            dependentFileInfo.setYangFileName(node.getName());
            utilManager.getYangFileInfoSet().add(dependentFileInfo);
        }
    } catch (IOException e) {
        throw new IOException("failed to resolve in interjar scenario.");
    }
    return interJarResolvedNodes;
}
#end_block

#method_before
private void createTestJar() {
    File file = new File(TARGET + TARGET_RESOURCE_PATH);
    File[] files = file.listFiles();
    String[] source = new String[files.length];
    for (int i = 0; i < files.length; i++) {
        source[i] = files[i].toString();
    }
    byte[] buf = new byte[1024];
    try {
        String target = TARGET + JAR_FILE_NAME;
        JarOutputStream out = new JarOutputStream(new FileOutputStream(target));
        for (String element : source) {
            FileInputStream in = new FileInputStream(element);
            out.putNextEntry(new JarEntry(element));
            int len;
            while ((len = in.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            out.closeEntry();
            in.close();
        }
        out.close();
    } catch (IOException e) {
    }
}
#method_after
private void createTestJar(String name) {
    File file = new File(TARGET_RESOURCE_PATH);
    File[] files = file.listFiles();
    String[] source = new String[files.length];
    for (int i = 0; i < files.length; i++) {
        source[i] = files[i].toString();
    }
    byte[] buf = new byte[1024];
    try {
        String target = TARGET + name + JAR_FILE_NAME;
        JarOutputStream out = new JarOutputStream(new FileOutputStream(target));
        for (String element : source) {
            FileInputStream in = new FileInputStream(element);
            out.putNextEntry(new JarEntry(element));
            int len;
            while ((len = in.read(buf)) > 0) {
                out.write(buf, 0, len);
            }
            out.closeEntry();
            in.close();
        }
        out.close();
    } catch (IOException e) {
    }
}
#end_block

#method_before
public static YangModel getYangModel(Class<?> modClass) {
    BundleContext context = getBundle(modClass).getBundleContext();
    if (context != null) {
        Bundle bundle = context.getBundle();
        List<YangNode> curNodes = new ArrayList<>();
        String jarPath;
        String metaPath;
        jarPath = getJarPathFromBundleLocation(bundle.getLocation(), context.getProperty(USER_DIRECTORY));
        metaPath = jarPath + SLASH + YANG_RESOURCES + SLASH + YANG_META_DATA;
        SerializedInfo info = processJarParsingOperations(jarPath);
        if (info != null) {
            curNodes.addAll(info.getYangNodes());
            // process model creations.
            if (curNodes != null && !curNodes.isEmpty()) {
                return processYangModel(metaPath, curNodes, info.getModelId());
            }
        }
    }
    return null;
}
#method_after
public static YangModel getYangModel(Class<?> modClass) {
    BundleContext context = getBundle(modClass).getBundleContext();
    if (context != null) {
        Bundle bundle = context.getBundle();
        List<YangNode> curNodes = new ArrayList<>();
        String jarPath;
        String metaPath;
        jarPath = getJarPathFromBundleLocation(bundle.getLocation(), context.getProperty(USER_DIRECTORY));
        metaPath = jarPath + SLASH + YANG_RESOURCES + SLASH + YANG_META_DATA;
        YangModel model = processJarParsingOperations(jarPath);
        if (model != null) {
            curNodes.addAll(getYangNodes(model));
            // process model creations.
            if (!curNodes.isEmpty()) {
                try {
                    return processYangModel(metaPath, curNodes, model.getYangModelId(), false);
                } catch (IOException e) {
                    log.error(" failed to create process YANG model " + e.getMessage(), e);
                }
            }
        }
    }
    return null;
}
#end_block

#method_before
private static SerializedInfo processJarParsingOperations(String path) {
    // Deserialize data model and get the YANG node set.
    String jar = path + JAR;
    try {
        File file = new File(jar);
        if (file.exists()) {
            return parseJarFile(path + JAR, path);
        }
    } catch (IOException e) {
        log.error(" failed to parse the jar file in path {} : {} ", path, e.getMessage());
    }
    return null;
}
#method_after
private static YangModel processJarParsingOperations(String path) {
    // Deserialize data model and get the YANG node set.
    String jar = path + JAR;
    try {
        File file = new File(jar);
        if (file.exists()) {
            return parseJarFile(path + JAR, path);
        }
    } catch (IOException e) {
        log.error(" failed to parse the jar file in path {} : {} ", path, e.getMessage());
    }
    return null;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(yangFiles, dependentSchemas, codeGenDir, metaDataPath);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(yangFiles, dependentSchemas, codeGenDir, metaDataPath, modelId);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    DefaultYangCompilationParam that = (DefaultYangCompilationParam) obj;
    return yangFiles.size() == that.yangFiles.size() && dependentSchemas.size() == that.dependentSchemas.size() && yangFiles.containsAll(that.yangFiles) && dependentSchemas.containsAll(that.dependentSchemas) && Objects.equals(codeGenDir, that.codeGenDir) && Objects.equals(metaDataPath, that.metaDataPath);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    DefaultYangCompilationParam that = (DefaultYangCompilationParam) obj;
    return yangFiles.size() == that.yangFiles.size() && dependentSchemas.size() == that.dependentSchemas.size() && yangFiles.containsAll(that.yangFiles) && dependentSchemas.containsAll(that.dependentSchemas) && Objects.equals(codeGenDir, that.codeGenDir) && Objects.equals(metaDataPath, that.metaDataPath) && Objects.equals(modelId, that.modelId);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(getClass()).add("yangFilePath", yangFiles).add("dependentSchemas", dependentSchemas).add("codeGenDir", codeGenDir).add("metaDataPath", metaDataPath).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(getClass()).add("yangFilePath", yangFiles).add("dependentSchemas", dependentSchemas).add("codeGenDir", codeGenDir).add("metaDataPath", metaDataPath).add("modelId", modelId).toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(moduleMap);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(moduleMap, modelId);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    DefaultYangModel that = (DefaultYangModel) obj;
    if (moduleMap.size() == that.moduleMap.size()) {
        for (Map.Entry<YangModuleId, YangModule> entry : moduleMap.entrySet()) {
            if (!that.moduleMap.containsKey(entry.getKey()) || !that.moduleMap.containsValue(entry.getValue())) {
                return false;
            }
        }
    } else {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null) {
        return false;
    }
    DefaultYangModel that = (DefaultYangModel) obj;
    if (moduleMap.size() == that.moduleMap.size()) {
        for (Map.Entry<YangModuleId, YangModule> entry : moduleMap.entrySet()) {
            if (!that.moduleMap.containsKey(entry.getKey()) || !that.moduleMap.containsValue(entry.getValue())) {
                return false;
            }
        }
    } else {
        return false;
    }
    return Objects.equals(modelId, that.modelId);
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(getClass()).add("model", moduleMap).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(getClass()).add("model", moduleMap).add("modelId", modelId).toString();
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        param.setCodeGenDir(Paths.get(codeGenDir));
        param.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            param.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            param.addYangFile(Paths.get(file));
        }
        if (modelId != null) {
            param.setModelId(modelId);
        } else {
            param.setModelId(project.getArtifactId());
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(param);
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    String metaDataGenDir;
    String outputDir;
    try {
        validateMavenVersion();
        /*
             * For deleting the generated code in previous build.
             */
        outputDir = getDirectory(baseDir, outputDirectory);
        deleteDirectory(outputDir + SLASH + TEMP);
        deleteDirectory(outputDir + SLASH + YANG_RESOURCES);
        String searchDir = getDirectory(baseDir, yangFilesDir);
        // Get the code gen directory.
        codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        // Get the meta data gen directory.
        metaDataGenDir = outputDir + SLASH + DEFAULT_JAR_RES_PATH;
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Need to get dependent schema paths to give inter jar dependencies.
        List<Path> depSchemas = resolveInterJarDependencies(project, localRepository, remoteRepository, outputDir);
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        bldr.setCodeGenDir(Paths.get(codeGenDir));
        bldr.setMetadataGenDir(Paths.get(metaDataGenDir));
        for (Path path : depSchemas) {
            bldr.addDependentSchema(path);
        }
        for (String file : getYangFiles(searchDir)) {
            bldr.addYangFile(Paths.get(file));
        }
        if (modelId != null) {
            bldr.setModelId(modelId);
        } else {
            bldr.setModelId(project.getArtifactId());
        }
        // Compile yang files and generate java code.
        output = compiler.compileYangFiles(bldr.build());
        addToCompilationRoot(codeGenDir, project, context);
        addToProjectResource(outputDir + SLASH + TEMP + SLASH, project);
    } catch (YangCompilerException e) {
        String fileName = EMPTY_STRING;
        if (e.getYangFile() != null) {
            fileName = e.getYangFile().toString();
        }
        try {
            deleteDirectory(codeGenDir + getPackageDirPathFromJavaJPackage(DEFAULT_BASE_PKG));
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        getLog().info(e.getCause());
        throw new MojoExecutionException("Exception occurred due to " + e.getLocalizedMessage() + IN + fileName + " YANG file.");
    } catch (IOException e) {
        throw new MojoExecutionException("Failed to process files");
    }
}
#end_block

#method_before
@Test
public void testForGetSchemaNode() throws IOException {
    provider.processSchemaRegistry();
    List<YangNode> nodes = new ArrayList<>();
    DefaultYangModelRegistry registry = provider.registry();
    YangModel model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("animal", "2016-06-24");
    YangModule module = registry.getYangModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    // Unregister service
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(yangNode == null));
    module = registry.getYangModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model == null));
    modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#method_after
@Test
public void testForGetSchemaNode() throws IOException {
    List<YangNode> nodes = new ArrayList<>();
    DefaultYangModelRegistry registry = setUp();
    YangModel model = registry.getModel(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("animal", "2016-06-24");
    YangModule module = registry.getModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    // Unregister service
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(yangNode == null));
    module = registry.getModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModel(MODEL_ID);
    assertThat(true, is(model == null));
    modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#end_block

#method_before
@Test
public void testForGetSchemaNodeWhenNoRevision() throws IOException {
    provider.processSchemaRegistry();
    DefaultYangModelRegistry registry = provider.registry();
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("Logistics-manager", "2016-05-24");
    YangModule module = registry.getYangModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_5);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    module = registry.getYangModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model == null));
    modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#method_after
@Test
public void testForGetSchemaNodeWhenNoRevision() throws IOException {
    DefaultYangModelRegistry registry = setUp();
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModel(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("Logistics-manager", "2016-05-24");
    YangModule module = registry.getModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_5);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    module = registry.getModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModel(MODEL_ID);
    assertThat(true, is(model == null));
    modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#end_block

#method_before
@Override
public void registerModel(ModelRegistrationParam param) throws IllegalArgumentException {
    YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
    Set<YangNode> curNodes = getNodes(model);
    String name;
    Class<?> service;
    AppModuleInfo info;
    // adding class info if added by application.
    for (YangModuleId id : model.getYangModulesId()) {
        info = param.getAppModuleInfo(id);
        if (info != null) {
            service = info.getModuleClass();
            name = service.getName();
            if (!registerClassStore.containsKey(name)) {
                registerClassStore.put(name, service);
            }
        }
    }
    if (modelIdStore.get(model.getModelId()) != null) {
        throw new IllegalArgumentException("model with given modelId already exist");
    } else {
        modelIdStore.put(model.getModelId(), param.getYangModel());
    }
    // Register all the YANG nodes.
    registerModule(curNodes);
    // update child context
    updateChildContext(curNodes);
}
#method_after
@Override
public void registerModel(ModelRegistrationParam param) throws IllegalArgumentException {
    YangModel model = checkNotNull(param.getYangModel(), E_NULL);
    Set<YangNode> curNodes = getNodes(model);
    // adding class info if added by application.
    updateRegClassStore(param);
    if (modelIdStore.containsKey(model.getYangModelId())) {
        throw new IllegalArgumentException(E_MEXIST);
    } else {
        modelIdStore.put(model.getYangModelId(), param.getYangModel());
    }
    // Register all the YANG nodes.
    registerModule(curNodes);
    // update child context
    updateChildContext(curNodes);
}
#end_block

#method_before
@Override
public void unregisterModel(ModelRegistrationParam param) {
    synchronized (DefaultYangModelRegistry.class) {
        YangModel model = checkNotNull(param.getYangModel(), "Model must not be null");
        modelIdStore.remove(model.getModelId());
        // Unregister all yang files
        Set<YangNode> curNodes = getNodes(model);
        for (YangNode node : curNodes) {
            processUnReg(getInterfaceClassName(node));
        }
    }
}
#method_after
@Override
public void unregisterModel(ModelRegistrationParam param) {
    synchronized (DefaultYangModelRegistry.class) {
        YangModel model = checkNotNull(param.getYangModel(), E_NULL);
        modelIdStore.remove(model.getYangModelId());
        // Unregister all yang files
        Set<YangNode> curNodes = getNodes(model);
        for (YangNode node : curNodes) {
            processUnReg(getInterfaceClassName(node));
        }
    }
}
#end_block

#method_before
@Override
public YangCompiledOutput compileYangFiles(YangCompilationParam param) throws IOException, YangCompilerException {
    synchronized (YangCompilerManager.class) {
        YangPluginConfig config = new YangPluginConfig();
        config.setCodeGenDir(param.getCodeGenDir().toString() + SLASH);
        config.resourceGenDir(param.getMetadataGenDir().toString() + SLASH);
        processYangFiles(createYangFileInfoSet(param.getYangFiles()), dependentSchema(param.getDependentSchemas()), config, param.getModelId());
        return new DefaultYangCompiledOutput(processYangModel(config.resourceGenDir()), genJavaPath);
    }
}
#method_after
@Override
public YangCompiledOutput compileYangFiles(YangCompilationParam param) throws IOException, YangCompilerException {
    synchronized (YangCompilerManager.class) {
        processYangFiles(param);
        return new DefaultYangCompiledOutput(model, genJavaPath);
    }
}
#end_block

#method_before
public YangModel processYangModel(String path) {
    YangModel.Builder b = DefaultYangModel.builder();
    YangModuleId id;
    for (YangNode node : yangNodeSet) {
        id = processModuleId(node);
        YangModule module = new DefaultYangModule(id, get(node.getFileName()), get(path));
        b.addModule(id, module);
    }
    return b.build();
}
#method_after
public static YangModel processYangModel(String path, List<YangNode> list, String modelId, boolean fromUt) throws IOException {
    YangModel.Builder b = DefaultYangModel.builder();
    YangModuleId id;
    for (YangNode node : list) {
        id = processModuleId(node);
        String serFile = path + id.moduleName() + id.revision() + ".ser";
        if (!fromUt) {
            serializeModuleMetaData(serFile, node);
        }
        YangModule module = new YangModuleExtendedInfo(id, new File(node.getFileName()), new File(serFile));
        ((YangModuleExtendedInfo) module).setSchema(node);
        b.addModule(id, module);
    }
    return b.addModelId(modelId).build();
}
#end_block

#method_before
private YangModuleId processModuleId(YangNode module) {
    String rev = getDateInStringFormat(module);
    return new DefaultYangModuleId(module.getName(), rev);
}
#method_after
public static YangModuleId processModuleId(YangNode module) {
    String rev = getDateInStringFormat(module);
    return new DefaultYangModuleId(module.getName(), rev);
}
#end_block

#method_before
private void processYangFiles(Set<YangFileInfo> yangFiles, Set<YangNode> dependentSchema, YangPluginConfig config, String id) throws IOException {
    synchronized (YangCompilerManager.class) {
        try {
            yangFileInfoSet = yangFiles;
            // Check if there are any file to translate, if not return.
            if (yangFileInfoSet.isEmpty()) {
                // No files to translate
                return;
            }
            // Create resource directory.
            createDirectories(config.resourceGenDir());
            // Resolve inter jar dependency.
            addSchemaToFileSet(dependentSchema);
            // Carry out the parsing for all the YANG files.
            parseYangFileInfoSet();
            // Serialize data model.
            processSerialization(config.resourceGenDir(), id);
            // Resolve dependencies using linker.
            resolveDependenciesUsingLinker();
            // Perform translation to JAVA.
            translateToJava(config);
            // add to generated java code map
            processGeneratedCode(config.getCodeGenDir());
            // add YANG files to JAR
            processCopyYangFile(config.resourceGenDir());
        } catch (IOException | ParserException e) {
            // TODO: provide unified framework for exceptions
            YangCompilerException exception = new YangCompilerException(e.getMessage(), e);
            exception.setYangFile(get(curYangFileInfo.getYangFileName()));
            if (curYangFileInfo != null && curYangFileInfo.getRootNode() != null) {
                try {
                    translatorErrorHandler(curYangFileInfo.getRootNode(), config);
                } catch (IOException ex) {
                    e.printStackTrace();
                    throw ex;
                }
            }
            throw exception;
        }
    }
}
#method_after
private void processYangFiles(YangCompilationParam param) throws IOException {
    YangPluginConfig config = new YangPluginConfig();
    synchronized (YangCompilerManager.class) {
        try {
            String codeGenDir = param.getCodeGenDir() + SLASH;
            String resourceGenDir = param.getMetadataGenDir() + SLASH;
            config.setCodeGenDir(codeGenDir);
            config.resourceGenDir(resourceGenDir);
            yangFileInfoSet = createYangFileInfoSet(param.getYangFiles());
            // Check if there are any file to translate, if not return.
            if (yangFileInfoSet.isEmpty()) {
                // No files to translate
                return;
            }
            // Create resource directory.
            createDirectories(resourceGenDir);
            // Resolve inter jar dependency.
            addSchemaToFileSet(dependentSchema(param.getDependentSchemas()));
            // Carry out the parsing for all the YANG files.
            parseYangFileInfoSet();
            createYangNodeSet();
            // Serialize data model.
            processSerialization(resourceGenDir, param.getModelId());
            // Resolve dependencies using linker.
            resolveDependenciesUsingLinker();
            // Perform translation to JAVA.
            translateToJava(config);
            // add to generated java code map
            processGeneratedCode(codeGenDir);
            // add YANG files to JAR
            processCopyYangFile(resourceGenDir);
        } catch (IOException | ParserException e) {
            // TODO: provide unified framework for exceptions
            YangCompilerException exception = new YangCompilerException(e.getMessage(), e);
            exception.setYangFile(get(curYangFileInfo.getYangFileName()));
            if (curYangFileInfo != null && curYangFileInfo.getRootNode() != null) {
                try {
                    translatorErrorHandler(curYangFileInfo.getRootNode(), config);
                } catch (IOException ex) {
                    e.printStackTrace();
                    throw ex;
                }
            }
            throw exception;
        }
    }
}
#end_block

#method_before
private Set<YangNode> dependentSchema(Set<Path> dependentSchemaPath) {
    Set<YangNode> depNodes = new LinkedHashSet<>();
    for (Path path : dependentSchemaPath) {
        try {
            SerializedInfo info = deSerializeDataModel(path.toString());
            depNodes.addAll(info.getYangNodes());
        } catch (IOException e) {
            throw new YangCompilerException("Failed to fetch dependent schema from given " + "path :" + path.toString());
        }
    }
    return depNodes;
}
#method_after
private Set<YangNode> dependentSchema(Set<Path> dependentSchemaPath) {
    Set<YangNode> depNodes = new LinkedHashSet<>();
    for (Path path : dependentSchemaPath) {
        try {
            depNodes.addAll(getYangNodes(deSerializeDataModel(path.toString())));
        } catch (IOException e) {
            throw new YangCompilerException("Failed to fetch dependent schema from given " + "path :" + path.toString());
        }
    }
    return depNodes;
}
#end_block

#method_before
public void resolveDependenciesUsingLinker() {
    createYangNodeSet();
    try {
        yangLinker.resolveDependencies(yangNodeSet);
    } catch (LinkerException e) {
        printLog(e.getFileName(), e.getLineNumber(), e.getCharPositionInLine(), e.getMessage(), e.getLocalizedMessage());
        throw new YangCompilerException(e.getMessage());
    }
}
#method_after
public void resolveDependenciesUsingLinker() {
    try {
        yangLinker.resolveDependencies(yangNodeSet);
    } catch (LinkerException e) {
        printLog(e.getFileName(), e.getLineNumber(), e.getCharPositionInLine(), e.getMessage(), e.getLocalizedMessage());
        throw new YangCompilerException(e.getMessage());
    }
}
#end_block

#method_before
public void processSerialization(String path, String id) throws IOException {
    SerializedInfo info = new SerializedInfo(id);
    Set<YangNode> nodes = info.getYangNodes();
    for (YangFileInfo fileInfo : yangFileInfoSet) {
        nodes.add(fileInfo.getRootNode());
    }
    String serFileName = path + YANG_META_DATA;
    FileOutputStream fileOutputStream = new FileOutputStream(serFileName);
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
    objectOutputStream.writeObject(info);
    objectOutputStream.close();
    fileOutputStream.close();
}
#method_after
public void processSerialization(String path, String id) throws IOException {
    List<YangNode> nodelist = new ArrayList<>();
    nodelist.addAll(yangNodeSet);
    model = processYangModel(path, nodelist, id, false);
    String serFileName = path + YANG_META_DATA;
    FileOutputStream fileOutputStream = new FileOutputStream(serFileName);
    ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
    objectOutputStream.writeObject(model);
    objectOutputStream.close();
    fileOutputStream.close();
}
#end_block

#method_before
@Test
public void testForGetSchemaNode() throws IOException {
    provider.processSchemaRegistry();
    List<YangNode> nodes = new ArrayList<>();
    DefaultYangModelRegistry registry = provider.registry();
    YangModel model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    YangModule module = registry.getYangModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    Class<?> cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_3.equals(cls.getName())));
    // Unregister service
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(yangNode == null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_3);
    assertThat(true, is(yangNode == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls == null));
    module = registry.getYangModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model == null));
    modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#method_after
@Test
public void testForGetSchemaNode() throws IOException {
    List<YangNode> nodes = new ArrayList<>();
    DefaultYangModelRegistry registry = setUp();
    YangModel model = registry.getModel(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    YangModule module = registry.getModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_3);
    assertThat(true, is(SCHEMA_NAME_3.equals(yangNode.getName())));
    // Unregister service
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_3);
    assertThat(true, is(yangNode == null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_3);
    assertThat(true, is(yangNode == null));
    module = registry.getModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModel(MODEL_ID);
    assertThat(true, is(model == null));
    modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#end_block

#method_before
@Test
public void testForGetSchemaNodeWhenNoRevision() throws IOException {
    provider.processSchemaRegistry();
    DefaultYangModelRegistry registry = provider.registry();
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    YangModule module = registry.getYangModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    Class<?> cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_REV_15.equals(cls.getName())));
    // unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(yangNode == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_NO_REV.equals(cls.getName())));
    // unregister SERVICE_NAME_NO_REV.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    assertThat(true, is(((YangNode) yangNode).getRevision() != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(yangNode == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls == null));
    module = registry.getYangModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model == null));
    modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#method_after
@Test
public void testForGetSchemaNodeWhenNoRevision() throws IOException {
    DefaultYangModelRegistry registry = setUp();
    YangNode node = null;
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModel(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    // TODO: fix this for yang model test
    YangModule module = registry.getModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // unregister SERVICE_NAME_NO_REV.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    assertThat(true, is(((YangNode) yangNode).getRevision() != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(yangNode == null));
    module = registry.getModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModel(MODEL_ID);
    assertThat(true, is(model == null));
    modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#end_block

#method_before
@Test
public void testForGetSchemaNodeWhenMultiRevision() throws IOException {
    provider.processSchemaRegistry();
    DefaultYangModelRegistry registry = provider.registry();
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    YangModule module = registry.getYangModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    Class<?> cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_REV_15.equals(cls.getName())));
    // Unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls != null));
    // ---------------------------------------------------------------//
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_16);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_16);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_REV_16.equals(cls.getName())));
    // Unregister SERVICE_NAME_REV_16.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_16);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls != null));
    // ---------------------------------------------------------------//
    // Service with different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_17);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_17);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_REV_17.equals(cls.getName())));
    // Unregister SERVICE_NAME_REV_17.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_17);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls != null));
    // ---------------------------------------------------------------//
    // Service no revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_NO_REV.equals(cls.getName())));
    // Unregister SERVICE_NAME_NO_REV.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    assertThat(true, is(((YangNode) yangNode).getRevision() != null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls != null));
    // ---------------------------------------------------------------//
    // Service with different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_14);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_14);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(INTERFACE_NAME_REV_14.equals(cls.getName())));
    // Unregister SERVICE_NAME_REV_14.
    nodes.add((YangNode) yangNode);
    provider.unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode == null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_14);
    assertThat(true, is(yangNode == null));
    cls = registry.getRegisteredClass(yangNode);
    assertThat(true, is(cls == null));
    module = registry.getYangModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModelsForId(MODEL_ID);
    assertThat(true, is(model == null));
    modules = registry.getYangModules(MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#method_after
@Test
public void testForGetSchemaNodeWhenMultiRevision() throws IOException {
    DefaultYangModelRegistry registry = setUp();
    List<YangNode> nodes = new ArrayList<>();
    YangModel model = registry.getModel(MODEL_ID);
    assertThat(true, is(model != null));
    Set<YangModule> modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() != 0));
    assertThat(true, is(modules != null));
    YangModuleId moduleId = new DefaultYangModuleId("ietf-network4", "2017-12-08");
    YangModule module = registry.getModule(moduleId);
    assertThat(true, is(moduleId.equals(module.getYangModuleId())));
    // Service with rev.
    YangSchemaNode yangNode = registry.getForSchemaName(SCHEMA_NAME_4_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // Unregister SERVICE_NAME_REV_15.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_15);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    // Here the yangNode should be the node which does not have revision.
    // asset should pass with false.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_16);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_16);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // Unregister SERVICE_NAME_REV_16.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_16);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    // Service with different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_17);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_17);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // Unregister SERVICE_NAME_REV_17.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_17);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(((YangNode) yangNode).getRevision() == null));
    // ---------------------------------------------------------------//
    // Service no revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // Unregister SERVICE_NAME_NO_REV.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForRegClassName(INTERFACE_NAME_NO_REV);
    assertThat(true, is(yangNode == null));
    // Here the yangNode should be the node which have different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode != null));
    assertThat(true, is(((YangNode) yangNode).getRevision() != null));
    // ---------------------------------------------------------------//
    // Service with different revision.
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4_14);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_14);
    assertThat(true, is(SCHEMA_NAME_4.equals(yangNode.getName())));
    // Unregister SERVICE_NAME_REV_14.
    nodes.add((YangNode) yangNode);
    unRegister(nodes);
    yangNode = registry.getForSchemaName(SCHEMA_NAME_4);
    assertThat(true, is(yangNode == null));
    yangNode = registry.getForRegClassName(INTERFACE_NAME_REV_14);
    assertThat(true, is(yangNode == null));
    module = registry.getModule(moduleId);
    assertThat(true, is(module == null));
    Set<YangModel> models = registry.getModels();
    assertThat(true, is(models.size() == 0));
    model = registry.getModel(MODEL_ID);
    assertThat(true, is(model == null));
    modules = getYangModules(model, MODEL_ID);
    assertThat(true, is(modules.size() == 0));
}
#end_block

#method_before
@Test
public void testGetNodeWrtNamespace() {
    provider.processSchemaRegistry();
    DefaultYangModelRegistry registry = provider.registry();
    YangSchemaNode yangNode = registry.getForNameSpace(NAMESPACE, false);
    assertThat(true, is(CHECK.equals(yangNode.getName())));
    YangRevision rev = ((YangNode) yangNode).getRevision();
    assertThat(true, is(rev != null));
    String date = getDateInStringFormat((YangNode) yangNode);
    assertThat(true, is(DATE_NAMESPACE.equals(date)));
}
#method_after
@Test
public void testGetNodeWrtNamespace() {
    DefaultYangModelRegistry registry = setUp();
    YangSchemaNode yangNode = registry.getForNameSpace(NAMESPACE, false);
    assertThat(true, is(CHECK.equals(yangNode.getName())));
    YangRevision rev = ((YangNode) yangNode).getRevision();
    assertThat(true, is(rev != null));
    String date = getDateInStringFormat((YangNode) yangNode);
    assertThat(true, is(DATE_NAMESPACE.equals(date)));
}
#end_block

#method_before
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Create compiler param.
        YangCompilationParam param = new DefaultYangCompilationParam();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    param.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path");
            }
        }
        param.setCodeGenDir(Paths.get(outputDirectory));
        param.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            param.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        param.setModelId(modelId);
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(param);
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#method_after
public void execute() throws YangParsingException {
    synchronized (YangGenerator.class) {
        // Yang compiler service.
        YangCompilerService compiler = new YangCompilerManager();
        // Create compiler param.
        DefaultYangCompilationParam.Builder bldr = DefaultYangCompilationParam.builder();
        // Need to get dependent schema paths to give inter jar dependencies.
        for (String jar : depJar) {
            try {
                File path = parseDepSchemaPath(jar, outputDirectory);
                if (path != null) {
                    bldr.addDependentSchema(Paths.get(path.getAbsolutePath()));
                }
            } catch (IOException e) {
                throw new YangCompilerException("Failed to parse dependent schema path");
            }
        }
        bldr.setCodeGenDir(Paths.get(outputDirectory));
        bldr.setMetadataGenDir(Paths.get(outputDirectory + SLASH + YANG_RESOURCES + SLASH));
        for (File file : models) {
            bldr.addYangFile(Paths.get(file.getAbsolutePath()));
        }
        bldr.setModelId(modelId);
        // Compile yang files and generate java code.
        try {
            output = compiler.compileYangFiles(bldr.build());
        } catch (IOException e) {
            throw new YangParsingException(e);
        }
    }
}
#end_block

#method_before
@Test
public void testUdpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(16));
    TpPort value2 = TpPort.tpPort(random.nextInt(16));
    TpPort mask = TpPort.tpPort(random.nextInt(16));
    int bitWidth = 16;
    UdpPortCriterion criterion = (UdpPortCriterion) Criteria.matchUdpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    UdpPortCriterion maskedCriterion = (UdpPortCriterion) Criteria.matchUdpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.udpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.udpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#method_after
@Test
public void testUdpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(65536));
    TpPort value2 = TpPort.tpPort(random.nextInt(65536));
    TpPort mask = TpPort.tpPort(random.nextInt(65536));
    int bitWidth = 16;
    UdpPortCriterion criterion = (UdpPortCriterion) Criteria.matchUdpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    UdpPortCriterion maskedCriterion = (UdpPortCriterion) Criteria.matchUdpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.udpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.udpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#end_block

#method_before
@Test
public void testIPDscpCriterion() throws Exception {
    byte[] ipDscp = new byte[6];
    random.nextBytes(ipDscp);
    IPDscpCriterion criterion = (IPDscpCriterion) Criteria.matchIPDscp(ipDscp[0]);
    int bitWidth = 16;
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.ipDscp()));
}
#method_after
@Test
public void testIPDscpCriterion() throws Exception {
    byte[] ipDscp = new byte[1];
    random.nextBytes(ipDscp);
    IPDscpCriterion criterion = (IPDscpCriterion) Criteria.matchIPDscp(ipDscp[0]);
    int bitWidth = 6;
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.ipDscp()));
}
#end_block

#method_before
@Test
public void testIPProtocolCriterion() throws Exception {
    short proto = (short) random.nextInt(255);
    int bitWidth = 16;
    IPProtocolCriterion criterion = (IPProtocolCriterion) Criteria.matchIPProtocol(proto);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.protocol()));
}
#method_after
@Test
public void testIPProtocolCriterion() throws Exception {
    short proto = (short) random.nextInt(256);
    int bitWidth = 16;
    IPProtocolCriterion criterion = (IPProtocolCriterion) Criteria.matchIPProtocol(proto);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.protocol()));
}
#end_block

#method_before
@Test
public void testIcmpCodeCriterion() throws Exception {
    short icmpCode = (short) random.nextInt(255);
    int bitWidth = 16;
    IcmpCodeCriterion criterion = (IcmpCodeCriterion) Criteria.matchIcmpCode(icmpCode);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpCode()));
}
#method_after
@Test
public void testIcmpCodeCriterion() throws Exception {
    short icmpCode = (short) random.nextInt(256);
    int bitWidth = 16;
    IcmpCodeCriterion criterion = (IcmpCodeCriterion) Criteria.matchIcmpCode(icmpCode);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpCode()));
}
#end_block

#method_before
@Test
public void testIcmpTypeCriterion() throws Exception {
    short icmpType = (short) random.nextInt(255);
    int bitWidth = 16;
    IcmpTypeCriterion criterion = (IcmpTypeCriterion) Criteria.matchIcmpType(icmpType);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpType()));
}
#method_after
@Test
public void testIcmpTypeCriterion() throws Exception {
    short icmpType = (short) random.nextInt(256);
    int bitWidth = 16;
    IcmpTypeCriterion criterion = (IcmpTypeCriterion) Criteria.matchIcmpType(icmpType);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpType()));
}
#end_block

#method_before
@Test
public void testIcmpv6CodeCriterion() throws Exception {
    short icmpv6Code = (short) random.nextInt(255);
    int bitWidth = 16;
    Icmpv6CodeCriterion criterion = (Icmpv6CodeCriterion) Criteria.matchIcmpv6Code(icmpv6Code);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpv6Code()));
}
#method_after
@Test
public void testIcmpv6CodeCriterion() throws Exception {
    short icmpv6Code = (short) random.nextInt(256);
    int bitWidth = 16;
    Icmpv6CodeCriterion criterion = (Icmpv6CodeCriterion) Criteria.matchIcmpv6Code(icmpv6Code);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpv6Code()));
}
#end_block

#method_before
@Test
public void testIcmpv6TypeCriterion() throws Exception {
    short icmpv6Type = (short) random.nextInt(255);
    int bitWidth = 16;
    Icmpv6TypeCriterion criterion = (Icmpv6TypeCriterion) Criteria.matchIcmpv6Type(icmpv6Type);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpv6Type()));
}
#method_after
@Test
public void testIcmpv6TypeCriterion() throws Exception {
    short icmpv6Type = (short) random.nextInt(256);
    int bitWidth = 16;
    Icmpv6TypeCriterion criterion = (Icmpv6TypeCriterion) Criteria.matchIcmpv6Type(icmpv6Type);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is(criterion.icmpv6Type()));
}
#end_block

#method_before
public void testMplsBosCriterion() throws Exception {
    boolean mplsBos = random.nextBoolean();
    int bitWidth = 16;
    MplsBosCriterion criterion = (MplsBosCriterion) Criteria.matchMplsBos(mplsBos);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().hasArray(), is(criterion.mplsBos()));
}
#method_after
@Test
public void testMplsBosCriterion() throws Exception {
    boolean mplsBos = random.nextBoolean();
    int bitWidth = 32;
    int bMplsBos = 0;
    MplsBosCriterion criterion = (MplsBosCriterion) Criteria.matchMplsBos(mplsBos);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    bMplsBos = (criterion.mplsBos()) ? 1 : 0;
    assertThat(exactMatch.value().asReadOnlyBuffer().getInt(), is(bMplsBos));
}
#end_block

#method_before
@Test
public void testMplsCriterion() throws Exception {
    MplsLabel mplsLabel = MplsLabel.mplsLabel(random.nextInt(255));
    int bitWidth = 32;
    MplsCriterion criterion = (MplsCriterion) Criteria.matchMplsLabel(mplsLabel);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getInt(), is(criterion.label().toInt()));
}
#method_after
@Test
public void testMplsCriterion() throws Exception {
    MplsLabel mplsLabel = MplsLabel.mplsLabel(random.nextInt(2 ^ 20));
    int bitWidth = 32;
    MplsCriterion criterion = (MplsCriterion) Criteria.matchMplsLabel(mplsLabel);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getInt(), is(criterion.label().toInt()));
}
#end_block

#method_before
@Test
public void testMplsTcCriterion() throws Exception {
    byte[] mplsTc = new byte[3];
    random.nextBytes(mplsTc);
    int bitWidth = 16;
    MplsTcCriterion criterion = (MplsTcCriterion) Criteria.matchMplsTc(mplsTc[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.tc()));
}
#method_after
@Test
public void testMplsTcCriterion() throws Exception {
    byte[] mplsTc = new byte[1];
    random.nextBytes(mplsTc);
    int bitWidth = 16;
    MplsTcCriterion criterion = (MplsTcCriterion) Criteria.matchMplsTc(mplsTc[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.tc()));
}
#end_block

#method_before
@Test
public void testSctpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(16));
    TpPort value2 = TpPort.tpPort(random.nextInt(16));
    TpPort mask = TpPort.tpPort(random.nextInt(16));
    int bitWidth = 16;
    SctpPortCriterion criterion = (SctpPortCriterion) Criteria.matchSctpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    SctpPortCriterion maskedCriterion = (SctpPortCriterion) Criteria.matchSctpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.sctpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.sctpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#method_after
@Test
public void testSctpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(2 ^ 16));
    TpPort value2 = TpPort.tpPort(random.nextInt(2 ^ 16));
    TpPort mask = TpPort.tpPort(random.nextInt(2 ^ 16));
    int bitWidth = 16;
    SctpPortCriterion criterion = (SctpPortCriterion) Criteria.matchSctpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    SctpPortCriterion maskedCriterion = (SctpPortCriterion) Criteria.matchSctpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.sctpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.sctpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#end_block

#method_before
@Test
public void testTcpFlagsCriterion() throws Exception {
    int pbbIsid = random.nextInt(255);
    int bitWidth = 16;
    TcpFlagsCriterion criterion = (TcpFlagsCriterion) Criteria.matchTcpFlags(pbbIsid);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.flags()));
}
#method_after
@Test
public void testTcpFlagsCriterion() throws Exception {
    int pbbIsid = random.nextInt(2 ^ 12);
    int bitWidth = 12;
    TcpFlagsCriterion criterion = (TcpFlagsCriterion) Criteria.matchTcpFlags(pbbIsid);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.flags()));
}
#end_block

#method_before
@Test
public void testTcpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(16));
    TpPort value2 = TpPort.tpPort(random.nextInt(16));
    TpPort mask = TpPort.tpPort(random.nextInt(16));
    int bitWidth = 16;
    TcpPortCriterion criterion = (TcpPortCriterion) Criteria.matchTcpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    TcpPortCriterion maskedCriterion = (TcpPortCriterion) Criteria.matchTcpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.tcpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.tcpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#method_after
@Test
public void testTcpPortCriterion() throws Exception {
    TpPort value1 = TpPort.tpPort(random.nextInt(2 ^ 16));
    TpPort value2 = TpPort.tpPort(random.nextInt(2 ^ 16));
    TpPort mask = TpPort.tpPort(random.nextInt(2 ^ 16));
    int bitWidth = 16;
    TcpPortCriterion criterion = (TcpPortCriterion) Criteria.matchTcpDst(value1);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    TcpPortCriterion maskedCriterion = (TcpPortCriterion) Criteria.matchTcpDstMasked(value2, mask);
    PiTernaryFieldMatch ternaryMatch = (PiTernaryFieldMatch) translateCriterion(maskedCriterion, fieldId, TERNARY, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getShort(), is((short) criterion.tcpPort().toInt()));
    assertThat(ternaryMatch.value().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.tcpPort().toInt()));
    assertThat(ternaryMatch.mask().asReadOnlyBuffer().getShort(), is((short) maskedCriterion.mask().toInt()));
}
#end_block

#method_before
@Test
public void testVlanPcpCriterion() throws Exception {
    byte[] vlanPcp = new byte[3];
    random.nextBytes(vlanPcp);
    int bitWidth = 16;
    VlanPcpCriterion criterion = (VlanPcpCriterion) Criteria.matchVlanPcp(vlanPcp[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.priority()));
}
#method_after
@Test
public void testVlanPcpCriterion() throws Exception {
    byte[] vlanPcp = new byte[1];
    random.nextBytes(vlanPcp);
    int bitWidth = 3;
    VlanPcpCriterion criterion = (VlanPcpCriterion) Criteria.matchVlanPcp(vlanPcp[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.priority()));
}
#end_block

#method_before
@Test
public void testArpHaCriterionn() throws Exception {
    MacAddress mac = MacAddress.valueOf(random.nextLong());
    int bitWidth = mac.toBytes().length * 8;
    ArpHaCriterion criterion = (ArpHaCriterion) Criteria.matchArpTha(mac);
    PiLpmFieldMatch lpmMatch = (PiLpmFieldMatch) translateCriterion(criterion, fieldId, LPM, bitWidth);
    assertThat(lpmMatch.value().asArray(), is(criterion.mac().toBytes()));
    assertThat(lpmMatch.prefixLength(), is(criterion.mac().length()));
}
#method_after
@Test
public void testArpHaCriterionn() throws Exception {
    MacAddress mac = MacAddress.valueOf(random.nextLong());
    int bitWidth = mac.toBytes().length * 8;
    ArpHaCriterion criterion = (ArpHaCriterion) Criteria.matchArpTha(mac);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asArray(), is(criterion.mac().toBytes()));
}
#end_block

#method_before
@Test
public void testArpPaCriterion() throws Exception {
    Ip4Address ip = Ip4Address.valueOf(random.nextInt());
    int bitWidth = ip.toOctets().length * 8;
    ArpPaCriterion criterion = (ArpPaCriterion) Criteria.matchArpTpa(ip);
    PiLpmFieldMatch lpmMatch = (PiLpmFieldMatch) translateCriterion(criterion, fieldId, LPM, bitWidth);
    assertThat(lpmMatch.value().asReadOnlyBuffer().getInt(), is(criterion.ip().toInt()));
    assertThat(lpmMatch.prefixLength(), is(criterion.ip().toIpPrefix().prefixLength()));
}
#method_after
@Test
public void testArpPaCriterion() throws Exception {
    Ip4Address ip = Ip4Address.valueOf(random.nextInt());
    int bitWidth = ip.toOctets().length * 8;
    ArpPaCriterion criterion = (ArpPaCriterion) Criteria.matchArpTpa(ip);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().getInt(), is(criterion.ip().toInt()));
}
#end_block

#method_before
@Test
public void testIPEcnCriterion() throws Exception {
    byte[] ipEcn = new byte[3];
    random.nextBytes(ipEcn);
    int bitWidth = 16;
    IPEcnCriterion criterion = (IPEcnCriterion) Criteria.matchIPEcn(ipEcn[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.ipEcn()));
}
#method_after
@Test
public void testIPEcnCriterion() throws Exception {
    byte[] ipEcn = new byte[1];
    random.nextBytes(ipEcn);
    int bitWidth = 2;
    IPEcnCriterion criterion = (IPEcnCriterion) Criteria.matchIPEcn(ipEcn[0]);
    PiExactFieldMatch exactMatch = (PiExactFieldMatch) translateCriterion(criterion, fieldId, EXACT, bitWidth);
    assertThat(exactMatch.value().asReadOnlyBuffer().get(), is(criterion.ipEcn()));
}
#end_block

#method_before
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    MplsBosCriterion c = (MplsBosCriterion) criterion;
    initAsExactMatch(copyFrom(c.mplsBos() ? 0 : 1), bitWidth);
}
#method_after
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    MplsBosCriterion c = (MplsBosCriterion) criterion;
    initAsExactMatch(copyFrom(c.mplsBos() ? 1 : 0), bitWidth);
}
#end_block

#method_before
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    ArpHaCriterion c = (ArpHaCriterion) criterion;
    initAsLpm(copyFrom(c.mac().toLong()), c.mac().length(), bitWidth);
}
#method_after
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    ArpHaCriterion c = (ArpHaCriterion) criterion;
    initAsExactMatch(copyFrom(c.mac().toLong()), bitWidth);
}
#end_block

#method_before
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    ArpPaCriterion c = (ArpPaCriterion) criterion;
    initAsLpm(copyFrom(c.ip().toInt()), c.ip().toIpPrefix().prefixLength(), bitWidth);
}
#method_after
@Override
public void init(Criterion criterion, int bitWidth) throws ByteSequenceTrimException {
    ArpPaCriterion c = (ArpPaCriterion) criterion;
    initAsExactMatch(copyFrom(c.ip().toInt()), bitWidth);
}
#end_block

#method_before
@Override
protected void execute() {
    DhcpRelayConfig cfg = CFG_SERVICE.getConfig(APP_ID, DhcpRelayConfig.class);
    if (cfg == null) {
        print(MISSING_SERVER_CFG);
        return;
    }
    // DHCP server information
    ConnectPoint connectPoint = cfg.getDhcpServerConnectPoint();
    Ip4Address gatewayAddress = cfg.getDhcpGatewayIp();
    Ip4Address serverIp = cfg.getDhcpServerIp();
    if (gatewayAddress != null) {
        print(DHCP_SERVER_GW, connectPoint, serverIp, gatewayAddress);
    } else {
        print(DHCP_SERVER, connectPoint, serverIp);
    }
    // DHCP records
    Collection<DhcpRecord> records = DHCP_RELAY_SERVICE.getDhcpRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    print(HEADER);
    records.forEach(record -> {
        DateFormat df = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        String lastSeen = df.format(new Date(record.lastSeen()));
        if (record.directlyConnected()) {
            print(BASIC_HOST_D, record.macAddress(), record.vlanId(), record.locations(), lastSeen);
        } else {
            print(BASIC_HOST, record.macAddress(), record.vlanId(), record.locations(), lastSeen);
        }
        if (record.ip4Status().isPresent()) {
            print(IP4_INFO, record.ip4Address().orElse(null), record.ip4Gateway().orElse(null), record.ip4Status().orElse(null));
        } else {
            print(NO_IP4);
        }
        if (record.ip6Status().isPresent()) {
            print(IP6_INFO, record.ip6Address().orElse(null), record.ip6Gateway().orElse(null), record.ip6Status().orElse(null));
        } else {
            print(NO_IP6);
        }
    });
}
#method_after
@Override
protected void execute() {
    DhcpRelayConfig cfg = CFG_SERVICE.getConfig(APP_ID, DhcpRelayConfig.class);
    if (cfg == null) {
        print(MISSING_SERVER_CFG);
        return;
    }
    // DHCP server information
    ConnectPoint connectPoint = cfg.getDhcpServerConnectPoint();
    Ip4Address gatewayAddress = cfg.getDhcpGatewayIp();
    Ip4Address serverIp = cfg.getDhcpServerIp();
    if (gatewayAddress != null) {
        print(DHCP_SERVER_GW, connectPoint, serverIp, gatewayAddress);
    } else {
        print(DHCP_SERVER, connectPoint, serverIp);
    }
    // DHCP records
    Collection<DhcpRecord> records = DHCP_RELAY_SERVICE.getDhcpRecords();
    if (records.isEmpty()) {
        print(NO_RECORDS);
        return;
    }
    print(HEADER);
    records.forEach(record -> {
        DateFormat df = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS");
        String lastSeen = df.format(new Date(record.lastSeen()));
        if (record.directlyConnected()) {
            print(BASIC_HOST_D, record.macAddress(), record.vlanId(), record.locations(), lastSeen);
        } else {
            print(BASIC_HOST, record.macAddress(), record.vlanId(), record.locations(), lastSeen);
        }
        if (record.ip4Status().isPresent()) {
            if (record.directlyConnected()) {
                print(IP4_INFO_D, record.ip4Address().orElse(null), record.ip4Status().orElse(null));
            } else {
                IpAddress gatewayIp = record.nextHop().flatMap(mac -> findGatewayIp(mac, record.vlanId())).orElse(null);
                print(IP4_INFO, record.ip4Address().orElse(null), gatewayIp, record.ip4Status().orElse(null));
            }
        } else {
            print(NO_IP4);
        }
        if (record.ip6Status().isPresent()) {
            if (record.directlyConnected()) {
                print(IP6_INFO_D, record.ip6Address().orElse(null), record.ip6Status().orElse(null));
            } else {
                IpAddress gatewayIp = record.nextHop().flatMap(mac -> findGatewayIp(mac, record.vlanId())).orElse(null);
                print(IP6_INFO, record.ip6Address().orElse(null), gatewayIp, record.ip6Status().orElse(null));
            }
        } else {
            print(NO_IP6);
        }
    });
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet services.
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    hostService.addListener(hostListener);
    requestDhcpPackets();
    modified(context);
    // disable dhcp from host location provider
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "requestDhcp", "false");
    compCfgService.preSetProperty("org.onosproject.provider.host.impl.HostLocationProvider", "useDhcp", "false");
    storeDelegate = new InternalStoreDelegate();
    dhcpRelayStore.setDelegate(storeDelegate);
    log.info("DHCP-RELAY Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet services.
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    hostService.addListener(hostListener);
    requestDhcpPackets();
    modified(context);
    // disable dhcp from host location provider
    compCfgService.preSetProperty(HOST_LOCATION_PROVIDER, "useDhcp", Boolean.FALSE.toString());
    compCfgService.registerProperties(getClass());
    log.info("DHCP-RELAY Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    factories.forEach(cfgService::unregisterConfigFactory);
    packetService.removeProcessor(dhcpRelayPacketProcessor);
    hostService.removeListener(hostListener);
    cancelDhcpPackets();
    cancelArpPackets();
    if (dhcpGatewayIp != null) {
        hostService.stopMonitoringIp(dhcpGatewayIp);
    } else {
        hostService.stopMonitoringIp(dhcpServerIp);
    }
    dhcpRelayStore.unsetDelegate(storeDelegate);
    log.info("DHCP-RELAY Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    factories.forEach(cfgService::unregisterConfigFactory);
    packetService.removeProcessor(dhcpRelayPacketProcessor);
    hostService.removeListener(hostListener);
    cancelDhcpPackets();
    cancelArpPackets();
    if (dhcpGatewayIp != null) {
        hostService.stopMonitoringIp(dhcpGatewayIp);
    } else {
        hostService.stopMonitoringIp(dhcpServerIp);
    }
    compCfgService.unregisterProperties(getClass(), true);
    log.info("DHCP-RELAY Stopped");
}
#end_block

#method_before
private void hostUpdated(Host host) {
    if (dhcpGatewayIp != null) {
        if (host.ipAddresses().contains(dhcpGatewayIp)) {
            dhcpConnectMac = host.mac();
            dhcpConnectVlan = host.vlan();
            log.info("DHCP gateway {} resolved to Mac/Vlan:{}/{}", dhcpGatewayIp, dhcpConnectMac, dhcpConnectVlan);
        }
        return;
    }
    if (host.ipAddresses().contains(dhcpServerIp)) {
        dhcpConnectMac = host.mac();
        dhcpConnectVlan = host.vlan();
        log.info("DHCP server {} resolved to Mac/Vlan:{}/{}", dhcpServerIp, dhcpConnectMac, dhcpConnectVlan);
    }
}
#method_after
private void hostUpdated(Host host) {
    if (dhcpGatewayIp != null && host.ipAddresses().contains(dhcpGatewayIp)) {
        dhcpConnectMac = host.mac();
        dhcpConnectVlan = host.vlan();
        log.info("DHCP gateway {} resolved to Mac/Vlan:{}/{}", dhcpGatewayIp, dhcpConnectMac, dhcpConnectVlan);
    } else if (host.ipAddresses().contains(dhcpServerIp)) {
        dhcpConnectMac = host.mac();
        dhcpConnectVlan = host.vlan();
        log.info("DHCP server {} resolved to Mac/Vlan:{}/{}", dhcpServerIp, dhcpConnectMac, dhcpConnectVlan);
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (!configured()) {
        log.warn("Missing DHCP relay server config. Abort packet processing");
        return;
    }
    // process the packet and get the payload
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    if (packet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            if (udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT || udpPacket.getSourcePort() == UDP.DHCP_SERVER_PORT) {
                // This packet is dhcp.
                DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
                processDhcpPacket(context, dhcpPayload);
            }
        }
    } else if (packet.getEtherType() == Ethernet.TYPE_ARP && arpEnabled) {
        ARP arpPacket = (ARP) packet.getPayload();
        Set<Interface> serverInterfaces = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom());
        // ignore the packets if dhcp server interface is not configured on onos.
        if (serverInterfaces.isEmpty()) {
            log.warn("server virtual interface not configured");
            return;
        }
        if ((arpPacket.getOpCode() == ARP.OP_REQUEST) && checkArpRequestFrmDhcpServ(serverInterfaces, arpPacket)) {
            processArpPacket(context, packet);
        }
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (!configured()) {
        log.warn("Missing DHCP relay server config. Abort packet processing");
        return;
    }
    // process the packet and get the payload
    Ethernet packet = context.inPacket().parsed();
    if (packet == null) {
        return;
    }
    findDhcp(packet).ifPresent(dhcpPayload -> {
        processDhcpPacket(context, dhcpPayload);
    });
    findDhcp6(packet).ifPresent(dhcp6Payload -> {
        // TODO: handle DHCPv6 packet
        log.warn("DHCPv6 unsupported.");
    });
    if (packet.getEtherType() == Ethernet.TYPE_ARP && arpEnabled) {
        ARP arpPacket = (ARP) packet.getPayload();
        VlanId vlanId = VlanId.vlanId(packet.getVlanID());
        Set<Interface> interfaces = interfaceService.getInterfacesByPort(context.inPacket().receivedFrom());
        // ignore the packets if dhcp server interface is not configured on onos.
        if (interfaces.isEmpty()) {
            log.warn("server virtual interface not configured");
            return;
        }
        if ((arpPacket.getOpCode() != ARP.OP_REQUEST)) {
            // handle request only
            return;
        }
        MacAddress interfaceMac = interfaces.stream().filter(iface -> iface.vlan().equals(vlanId)).map(Interface::mac).filter(mac -> !mac.equals(MacAddress.NONE)).findFirst().orElse(null);
        if (interfaceMac == null) {
            // can't find interface mac address
            return;
        }
        processArpPacket(context, packet, interfaceMac);
    }
}
#end_block

#method_before
private void processArpPacket(PacketContext context, Ethernet packet) {
    ARP arpPacket = (ARP) packet.getPayload();
    ARP arpReply = (ARP) arpPacket.clone();
    arpReply.setOpCode(ARP.OP_REPLY);
    arpReply.setTargetProtocolAddress(arpPacket.getSenderProtocolAddress());
    arpReply.setTargetHardwareAddress(arpPacket.getSenderHardwareAddress());
    arpReply.setSenderProtocolAddress(arpPacket.getTargetProtocolAddress());
    arpReply.setSenderHardwareAddress(myMAC.toBytes());
    // Ethernet Frame.
    Ethernet ethReply = new Ethernet();
    ethReply.setSourceMACAddress(myMAC);
    ethReply.setDestinationMACAddress(packet.getSourceMAC());
    ethReply.setEtherType(Ethernet.TYPE_ARP);
    ethReply.setVlanID(packet.getVlanID());
    ethReply.setPayload(arpReply);
    forwardPacket(ethReply);
}
#method_after
private void processArpPacket(PacketContext context, Ethernet packet, MacAddress replyMac) {
    ARP arpPacket = (ARP) packet.getPayload();
    ARP arpReply = (ARP) arpPacket.clone();
    arpReply.setOpCode(ARP.OP_REPLY);
    arpReply.setTargetProtocolAddress(arpPacket.getSenderProtocolAddress());
    arpReply.setTargetHardwareAddress(arpPacket.getSenderHardwareAddress());
    arpReply.setSenderProtocolAddress(arpPacket.getTargetProtocolAddress());
    arpReply.setSenderHardwareAddress(replyMac.toBytes());
    // Ethernet Frame.
    Ethernet ethReply = new Ethernet();
    ethReply.setSourceMACAddress(replyMac.toBytes());
    ethReply.setDestinationMACAddress(packet.getSourceMAC());
    ethReply.setEtherType(Ethernet.TYPE_ARP);
    ethReply.setVlanID(packet.getVlanID());
    ethReply.setPayload(arpReply);
    ConnectPoint targetPort = context.inPacket().receivedFrom();
    TrafficTreatment t = DefaultTrafficTreatment.builder().setOutput(targetPort.port()).build();
    OutboundPacket o = new DefaultOutboundPacket(targetPort.deviceId(), t, ByteBuffer.wrap(ethReply.serialize()));
    if (log.isTraceEnabled()) {
        log.trace("Relaying ARP packet {} to {}", packet, targetPort);
    }
    packetService.emit(o);
}
#end_block

#method_before
private void processDhcpPacket(PacketContext context, DHCP dhcpPayload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    Set<Interface> clientServerInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (clientServerInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCPPacketType incomingPacketType = null;
    for (DHCPOption option : dhcpPayload.getOptions()) {
        if (option.getCode() == OptionCode_MessageType.getValue()) {
            byte[] data = option.getData();
            incomingPacketType = DHCPPacketType.getType(data[0]);
        }
    }
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // add the gatewayip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketDiscover = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketDiscover != null) {
                forwardPacket(ethernetPacketDiscover);
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(packet);
            if (ethernetPacketOffer != null) {
                sendReply(ethernetPacketOffer, dhcpPayload);
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload, incomingPacketType);
            }
            break;
        case DHCPREQUEST:
            // add the gatewayip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketRequest = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketRequest != null) {
                forwardPacket(ethernetPacketRequest);
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
            }
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(packet);
            if (ethernetPacketAck != null) {
                sendReply(ethernetPacketAck, dhcpPayload);
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload, incomingPacketType);
            }
            break;
        case DHCPRELEASE:
            removeHostRecord(inPort, packet, dhcpPayload);
            break;
        default:
            break;
    }
}
#method_after
private void processDhcpPacket(PacketContext context, DHCP dhcpPayload) {
    ConnectPoint inPort = context.inPacket().receivedFrom();
    Set<Interface> clientServerInterfaces = interfaceService.getInterfacesByPort(inPort);
    // ignore the packets if dhcp client interface is not configured on onos.
    if (clientServerInterfaces.isEmpty()) {
        log.warn("Virtual interface is not configured on {}", inPort);
        return;
    }
    checkNotNull(dhcpPayload, "Can't find DHCP payload");
    Ethernet packet = context.inPacket().parsed();
    DHCP.MsgType incomingPacketType = dhcpPayload.getOptions().stream().filter(dhcpOption -> dhcpOption.getCode() == OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> DHCP.MsgType.getType(data[0])).findFirst().orElse(null);
    checkNotNull(incomingPacketType, "Can't get message type from DHCP payload {}", dhcpPayload);
    switch(incomingPacketType) {
        case DHCPDISCOVER:
            // add the gatewayip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketDiscover = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketDiscover != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketDiscover);
            }
            break;
        case DHCPOFFER:
            // reply to dhcp client.
            Ethernet ethernetPacketOffer = processDhcpPacketFromServer(packet);
            if (ethernetPacketOffer != null) {
                writeResponseDhcpRecord(ethernetPacketOffer, dhcpPayload);
                handleDhcpOffer(ethernetPacketOffer, dhcpPayload);
            }
            break;
        case DHCPREQUEST:
            // add the gateway ip as virtual interface ip for server to understand
            // the lease to be assigned and forward the packet to dhcp server.
            Ethernet ethernetPacketRequest = processDhcpPacketFromClient(context, packet, clientServerInterfaces);
            if (ethernetPacketRequest != null) {
                writeRequestDhcpRecord(inPort, packet, dhcpPayload);
                handleDhcpDiscoverAndRequest(ethernetPacketRequest);
            }
            break;
        case DHCPACK:
            // reply to dhcp client.
            Ethernet ethernetPacketAck = processDhcpPacketFromServer(packet);
            if (ethernetPacketAck != null) {
                writeResponseDhcpRecord(ethernetPacketAck, dhcpPayload);
                handleDhcpAck(ethernetPacketAck, dhcpPayload);
            }
            break;
        case DHCPRELEASE:
            // TODO: release the ip address from client
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void writeRequestDhcpRecord(ConnectPoint location, Ethernet ethernet, DHCP dhcpPayload) {
    VlanId vlanId = VlanId.vlanId(ethernet.getVlanID());
    MacAddress macAddress = ethernet.getSourceMAC();
    DhcpRecord record = new DhcpRecord(location, macAddress, vlanId, null, new WallClockTimestamp(), dhcpPayload);
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(macAddress, vlanId), record);
}
#method_after
private void writeRequestDhcpRecord(ConnectPoint location, Ethernet ethernet, DHCP dhcpPayload) {
    VlanId vlanId = VlanId.vlanId(ethernet.getVlanID());
    MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
    HostId hostId = HostId.hostId(macAddress, vlanId);
    DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
    if (record == null) {
        record = new DhcpRecord(HostId.hostId(macAddress, vlanId));
    } else {
        record = record.clone();
    }
    record.addLocation(new HostLocation(location, System.currentTimeMillis()));
    record.ip4Status(dhcpPayload.getPacketType());
    record.setDirectlyConnected(directlyConnected(dhcpPayload));
    if (!directlyConnected(dhcpPayload)) {
        // Update gateway mac address if the host is not directly connected
        record.nextHop(ethernet.getSourceMAC());
    }
    record.updateLastSeen();
    dhcpRelayStore.updateDhcpRecord(HostId.hostId(macAddress, vlanId), record);
}
#end_block

#method_before
private void writeResponseDhcpRecord(Ethernet ethernet, DHCP dhcpPayload, DHCPPacketType incomingPacketType) {
    Optional<Interface> outInterface = getOutputInterface(ethernet, dhcpPayload);
    outInterface.ifPresent(outIface -> {
        ConnectPoint location = outIface.connectPoint();
        VlanId vlanId = outIface.vlan();
        MacAddress macAddress = ethernet.getDestinationMAC();
        IpAddress ipAddress = null;
        if (incomingPacketType == DHCPPacketType.DHCPACK) {
            ipAddress = IpAddress.valueOf(dhcpPayload.getYourIPAddress());
        }
        DhcpRecord record = new DhcpRecord(location, macAddress, vlanId, ipAddress, new WallClockTimestamp(), dhcpPayload);
        dhcpRelayStore.updateDhcpRecord(HostId.hostId(macAddress, vlanId), record);
    });
}
#method_after
private void writeResponseDhcpRecord(Ethernet ethernet, DHCP dhcpPayload) {
    Optional<Interface> outInterface = getOutputInterface(ethernet, dhcpPayload);
    outInterface.ifPresent(outIface -> {
        ConnectPoint location = outIface.connectPoint();
        VlanId vlanId = outIface.vlan();
        MacAddress macAddress = MacAddress.valueOf(dhcpPayload.getClientHardwareAddress());
        HostId hostId = HostId.hostId(macAddress, vlanId);
        DhcpRecord record = dhcpRelayStore.getDhcpRecord(hostId).orElse(null);
        if (record == null) {
            record = new DhcpRecord(HostId.hostId(macAddress, vlanId));
        } else {
            record = record.clone();
        }
        record.addLocation(new HostLocation(location, System.currentTimeMillis()));
        if (dhcpPayload.getPacketType() == DHCP.MsgType.DHCPACK) {
            record.ip4Address(Ip4Address.valueOf(dhcpPayload.getYourIPAddress()));
        }
        record.ip4Status(dhcpPayload.getPacketType());
        record.setDirectlyConnected(directlyConnected(dhcpPayload));
        record.updateLastSeen();
        dhcpRelayStore.updateDhcpRecord(HostId.hostId(macAddress, vlanId), record);
    });
}
#end_block

#method_before
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    Ip4Address relayAgentIp = getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMac);
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(relayAgentIp.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
    // If there is no relay agent option(option 82), add one to DHCP payload
    boolean containsRelayAgentOption = dhcpPacket.getOptions().stream().map(DHCPOption::getCode).anyMatch(code -> code == OptionCode_CircuitID.getValue());
    if (!containsRelayAgentOption) {
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        byte[] circuitId = DHCPOption.generateCircuitId(inPort.toString(), vlanId);
        if (circuitId != null) {
            DHCPOption circuitIdSubOpt = new DHCPOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue());
            circuitIdSubOpt.setData(circuitId);
            circuitIdSubOpt.setLength((byte) circuitId.length);
            DHCPOption newRelayAgentOpt = new DHCPOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // push new circuit id to last
            List<DHCPOption> options = dhcpPacket.getOptions();
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            options.sort((opt1, opt2) -> opt2.getCode() - opt1.getCode());
            dhcpPacket.setOptions(options);
        } else {
            log.warn("Can't generate circuit id for port {}, vlan {}", inPort, vlanId);
        }
    }
    udpPacket.setPayload(dhcpPacket);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFromClient(PacketContext context, Ethernet ethernetPacket, Set<Interface> clientInterfaces) {
    Ip4Address relayAgentIp = getRelayAgentIPv4Address(clientInterfaces);
    MacAddress relayAgentMac = clientInterfaces.iterator().next().mac();
    if (relayAgentIp == null || relayAgentMac == null) {
        log.warn("Missing DHCP relay agent interface Ipv4 addr config for " + "packet from client on port: {}. Aborting packet processing", clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    if (dhcpConnectMac == null) {
        log.warn("DHCP {} not yet resolved .. Aborting DHCP " + "packet processing from client on port: {}", (dhcpGatewayIp == null) ? "server IP " + dhcpServerIp : "gateway IP " + dhcpGatewayIp, clientInterfaces.iterator().next().connectPoint());
        return null;
    }
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    etherReply.setSourceMACAddress(relayAgentMac);
    etherReply.setDestinationMACAddress(dhcpConnectMac);
    etherReply.setVlanID(dhcpConnectVlan.toShort());
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    ipv4Packet.setSourceAddress(relayAgentIp.toInt());
    ipv4Packet.setDestinationAddress(dhcpServerIp.toInt());
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    // If there is no relay agent option(option 82), add one to DHCP payload
    boolean containsRelayAgentOption = dhcpPacket.getOptions().stream().map(DhcpOption::getCode).anyMatch(code -> code == OptionCode_CircuitID.getValue());
    if (!containsRelayAgentOption) {
        ConnectPoint inPort = context.inPacket().receivedFrom();
        VlanId vlanId = VlanId.vlanId(ethernetPacket.getVlanID());
        // add connected in port and vlan
        CircuitId cid = new CircuitId(inPort.toString(), vlanId);
        byte[] circuitId = cid.serialize();
        if (circuitId != null) {
            DhcpOption circuitIdSubOpt = new DhcpOption();
            circuitIdSubOpt.setCode(CIRCUIT_ID.getValue()).setLength((byte) circuitId.length).setData(circuitId);
            DhcpRelayAgentOption newRelayAgentOpt = new DhcpRelayAgentOption();
            newRelayAgentOpt.setCode(OptionCode_CircuitID.getValue());
            newRelayAgentOpt.addSubOption(circuitIdSubOpt);
            // push new circuit id to last
            List<DhcpOption> options = dhcpPacket.getOptions();
            options.add(newRelayAgentOpt);
            // make sure option 255(End) is the last option
            options.sort((opt1, opt2) -> opt2.getCode() - opt1.getCode());
            dhcpPacket.setOptions(options);
            dhcpPacket.setGatewayIPAddress(relayAgentIp.toInt());
        } else {
            log.warn("Can't generate circuit id for port {}, vlan {}", inPort, vlanId);
        }
    } else {
    // TODO: if it contains a relay agent information, sets gateway ip
    // according to the information it provided
    }
    udpPacket.setPayload(dhcpPacket);
    udpPacket.setSourcePort(UDP.DHCP_CLIENT_PORT);
    udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
private Ethernet processDhcpPacketFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    MacAddress dstMac = valueOf(dhcpPayload.getClientHardwareAddress());
    Set<Host> hosts = hostService.getHostsByMac(dstMac);
    Interface outInterface = getOutputInterface(ethernetPacket, dhcpPayload).orElse(null);
    if (hosts == null || hosts.isEmpty()) {
        log.warn("Cannot determine host for DHCP client: {}. Aborting " + "relay for dhcp packet from server {}", dhcpPayload.getClientHardwareAddress(), ethernetPacket);
        return null;
    }
    if (outInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    HostId hostId = HostId.hostId(dstMac, outInterface.vlan());
    Host host = hostService.getHost(hostId);
    if (host == null) {
        log.warn("Can't find host with host id {} ", hostId);
        return null;
    }
    etherReply.setDestinationMACAddress(dstMac);
    etherReply.setVlanID(host.vlan().toShort());
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address relayAgentIP = getRelayAgentIPv4Address(interfaceService.getInterfacesByPort(host.location()));
    if (relayAgentIP == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}. " + "Aborting relay for dhcp packet from server {}", host, ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#method_after
private Ethernet processDhcpPacketFromServer(Ethernet ethernetPacket) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPayload = (DHCP) udpPacket.getPayload();
    // determine the vlanId of the client host - note that this vlan id
    // could be different from the vlan in the packet from the server
    Interface outInterface = getOutputInterface(ethernetPacket, dhcpPayload).orElse(null);
    if (outInterface == null) {
        log.warn("Cannot find the interface for the DHCP {}", dhcpPayload);
        return null;
    }
    etherReply.setVlanID(outInterface.vlan().toShort());
    // we leave the srcMac from the original packet
    // figure out the relay agent IP corresponding to the original request
    Ip4Address relayAgentIP = getRelayAgentIPv4Address(interfaceService.getInterfacesByPort(outInterface.connectPoint()));
    if (relayAgentIP == null) {
        log.warn("Cannot determine relay agent interface Ipv4 addr for host {}/{}. " + "Aborting relay for dhcp packet from server {}", etherReply.getDestinationMAC(), outInterface.vlan(), ethernetPacket);
        return null;
    }
    // SRC_IP: relay agent IP
    // DST_IP: offered IP
    ipv4Packet.setSourceAddress(relayAgentIP.toInt());
    ipv4Packet.setDestinationAddress(dhcpPayload.getYourIPAddress());
    udpPacket.setSourcePort(UDP.DHCP_SERVER_PORT);
    if (directlyConnected(dhcpPayload)) {
        udpPacket.setDestinationPort(UDP.DHCP_CLIENT_PORT);
    } else {
        // forward to another dhcp relay
        udpPacket.setDestinationPort(UDP.DHCP_SERVER_PORT);
    }
    udpPacket.setPayload(dhcpPayload);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
public Timestamp lastSeen() {
    return lastSeen;
}
#method_after
public long lastSeen() {
    return lastSeen;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(location, macAddress, vlanId, ipAddress, lastSeen, status);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(locations, macAddress, vlanId, ip4Address, ip4Status, nextHop, ip6Address, ip6Status, lastSeen);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DhcpRecord)) {
        return false;
    }
    DhcpRecord that = (DhcpRecord) obj;
    return Objects.equals(location, that.location) && Objects.equals(macAddress, that.macAddress) && Objects.equals(vlanId, that.vlanId) && Objects.equals(ipAddress, that.ipAddress) && Objects.equals(lastSeen, that.lastSeen) && Objects.equals(status, that.status);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DhcpRecord)) {
        return false;
    }
    DhcpRecord that = (DhcpRecord) obj;
    return Objects.equals(locations, that.locations) && Objects.equals(macAddress, that.macAddress) && Objects.equals(vlanId, that.vlanId) && Objects.equals(ip4Address, that.ip4Address) && Objects.equals(ip4Status, that.ip4Status) && Objects.equals(nextHop, that.nextHop) && Objects.equals(ip6Address, that.ip6Address) && Objects.equals(ip6Status, that.ip6Status) && Objects.equals(lastSeen, that.lastSeen) && Objects.equals(directlyConnected, that.directlyConnected);
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("location", location).add("macAddress", macAddress).add("vlanId", vlanId).add("ipAddress", ipAddress).add("lastSeen", lastSeen).add("status", status).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("locations", locations).add("macAddress", macAddress).add("vlanId", vlanId).add("ip4Address", ip4Address).add("ip4State", ip4Status).add("nextHop", nextHop).add("ip6Address", ip6Address).add("ip6State", ip6Status).add("lastSeen", lastSeen).add("directlyConnected", directlyConnected).toString();
}
#end_block

#method_before
@Test
public void testPutAndRemoveRecord() {
    DHCP dhcp = new DHCP();
    dhcp.setOpCode(DHCP.OPCODE_REQUEST);
    // dhcp request, no IP
    DhcpRecord record = new DhcpRecord(CP, MAC, VLAN_ID, null, new WallClockTimestamp(), dhcp);
    CompletableFuture<DhcpRelayStoreEvent> recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    store.updateDhcpRecord(HOST_ID, record);
    DhcpRelayStoreEvent event = recordComplete.join();
    assertEquals(record, event.subject());
    assertEquals(DhcpRelayStoreEvent.Type.UPDATED, event.type());
    DhcpRecord recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNotNull(recordInStore);
    assertEquals(record, recordInStore);
    Collection<DhcpRecord> recordsInStore = store.getAllDhcpRecords();
    assertEquals(1, recordsInStore.size());
    assertEquals(record, recordsInStore.iterator().next());
    // dhcp request, with IP
    record = new DhcpRecord(CP, MAC, VLAN_ID, IP, new WallClockTimestamp(), dhcp);
    recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    store.updateDhcpRecord(HOST_ID, record);
    event = recordComplete.join();
    assertEquals(record, event.subject());
    assertEquals(DhcpRelayStoreEvent.Type.UPDATED, event.type());
    recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNotNull(recordInStore);
    assertEquals(record, recordInStore);
    recordsInStore = store.getAllDhcpRecords();
    assertEquals(1, recordsInStore.size());
    assertEquals(record, recordsInStore.iterator().next());
    // removes record
    recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    DhcpRecord removedRecord = store.removeDhcpRecord(HOST_ID).orElse(null);
    assertEquals(record, removedRecord);
    event = recordComplete.join();
    assertEquals(null, event.subject());
    assertEquals(DhcpRelayStoreEvent.Type.REMOVED, event.type());
    recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNull(recordInStore);
    recordsInStore = store.getAllDhcpRecords();
    assertEquals(0, recordsInStore.size());
}
#method_after
@Test
public void testPutAndRemoveRecord() {
    // dhcp request, no IP
    HostId hostId = HostId.hostId(MAC, VLAN_ID);
    DhcpRecord record = new DhcpRecord(hostId);
    record.addLocation(new HostLocation(CP, System.currentTimeMillis()));
    record.setDirectlyConnected(true);
    record.nextHop(GW_MAC);
    record.ip4Status(DHCPREQUEST);
    CompletableFuture<DhcpRelayStoreEvent> recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    store.updateDhcpRecord(HOST_ID, record);
    DhcpRelayStoreEvent event = recordComplete.join();
    assertEquals(record, event.subject());
    assertEquals(DhcpRelayStoreEvent.Type.UPDATED, event.type());
    DhcpRecord recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNotNull(recordInStore);
    assertEquals(record, recordInStore);
    Collection<DhcpRecord> recordsInStore = store.getDhcpRecords();
    assertEquals(1, recordsInStore.size());
    assertEquals(record, recordsInStore.iterator().next());
    // dhcp request, with IP
    record = new DhcpRecord(hostId);
    record.addLocation(new HostLocation(CP, System.currentTimeMillis()));
    record.setDirectlyConnected(true);
    record.ip4Address(IP);
    record.nextHop(GW_MAC);
    record.ip4Status(DHCPREQUEST);
    recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    store.updateDhcpRecord(HOST_ID, record);
    event = recordComplete.join();
    DhcpRecord subject = event.subject();
    assertEquals(record.locations(), subject.locations());
    assertEquals(record.vlanId(), subject.vlanId());
    assertEquals(record.macAddress(), subject.macAddress());
    assertEquals(record.ip4Address(), subject.ip4Address());
    assertEquals(record.nextHop(), subject.nextHop());
    assertEquals(record.ip4Status(), subject.ip4Status());
    assertEquals(record.ip6Address(), subject.ip6Address());
    assertEquals(record.ip6Status(), subject.ip6Status());
    assertEquals(record.directlyConnected(), subject.directlyConnected());
    assertEquals(DhcpRelayStoreEvent.Type.UPDATED, event.type());
    recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNotNull(recordInStore);
    assertEquals(record.locations(), recordInStore.locations());
    assertEquals(record.vlanId(), recordInStore.vlanId());
    assertEquals(record.macAddress(), recordInStore.macAddress());
    assertEquals(record.ip4Address(), recordInStore.ip4Address());
    assertEquals(record.nextHop(), recordInStore.nextHop());
    assertEquals(record.ip4Status(), recordInStore.ip4Status());
    assertEquals(record.ip6Address(), recordInStore.ip6Address());
    assertEquals(record.ip6Status(), recordInStore.ip6Status());
    assertEquals(record.directlyConnected(), recordInStore.directlyConnected());
    recordsInStore = store.getDhcpRecords();
    assertEquals(1, recordsInStore.size());
    // removes record
    recordComplete = new CompletableFuture<>();
    store.setDelegate(recordComplete::complete);
    DhcpRecord removedRecord = store.removeDhcpRecord(HOST_ID).orElse(null);
    assertEquals(record.locations(), removedRecord.locations());
    assertEquals(record.vlanId(), removedRecord.vlanId());
    assertEquals(record.macAddress(), removedRecord.macAddress());
    assertEquals(record.ip4Address(), removedRecord.ip4Address());
    assertEquals(record.nextHop(), removedRecord.nextHop());
    assertEquals(record.ip4Status(), removedRecord.ip4Status());
    assertEquals(record.ip6Address(), removedRecord.ip6Address());
    assertEquals(record.ip6Status(), removedRecord.ip6Status());
    assertEquals(record.directlyConnected(), removedRecord.directlyConnected());
    event = recordComplete.join();
    assertEquals(null, event.subject());
    assertEquals(DhcpRelayStoreEvent.Type.REMOVED, event.type());
    recordInStore = store.getDhcpRecord(HOST_ID).orElse(null);
    assertNull(recordInStore);
    recordsInStore = store.getDhcpRecords();
    assertEquals(0, recordsInStore.size());
}
#end_block

#method_before
@Activate
protected void activated() {
    dhcpRecords = storageService.<HostId, DhcpRecord>eventuallyConsistentMapBuilder().withName("DHCP-Relay-Records").withTimestampProvider((hostId, record) -> record.lastSeen()).withSerializer(APP_KRYO).build();
    listener = new InternalMapListener();
    dhcpRecords.addListener(listener);
}
#method_after
@Activate
protected void activated() {
    dhcpRecords = storageService.<HostId, DhcpRecord>eventuallyConsistentMapBuilder().withName("DHCP-Relay-Records").withTimestampProvider((hostId, record) -> new WallClockTimestamp(record.lastSeen())).withSerializer(APP_KRYO).build();
    listener = new InternalMapListener();
    dhcpRecords.addListener(listener);
}
#end_block

#method_before
@Override
public void setDelegate(StoreDelegate<DhcpRelayStoreEvent> delegate) {
    this.delegate = delegate;
}
#method_after
@Override
public void setDelegate(StoreDelegate<DhcpRelayStoreEvent> delegate) {
    checkNotNull("Delegate can't be null", delegate);
    this.delegate = delegate;
}
#end_block

#method_before
@Override
public Optional<DhcpRecord> getDhcpRecord(HostId hostId) {
    return Optional.ofNullable(dhcpRecords.get(hostId));
}
#method_after
@Override
public Optional<DhcpRecord> getDhcpRecord(HostId hostId) {
    checkNotNull(hostId, "Host id can't be null");
    return Optional.ofNullable(dhcpRecords.get(hostId));
}
#end_block

#method_before
@Override
public Optional<DhcpRecord> removeDhcpRecord(HostId hostId) {
    return Optional.ofNullable(dhcpRecords.remove(hostId));
}
#method_after
@Override
public Optional<DhcpRecord> removeDhcpRecord(HostId hostId) {
    checkNotNull(hostId, "Host id can't be null");
    return Optional.ofNullable(dhcpRecords.remove(hostId));
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "CREATE"));
    readNodeConfiguration(input).forEach(osNode -> {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            osNodeAdminService.createNode(osNode);
        } else if (!existing.equals(osNode)) {
            osNodeAdminService.updateNode(osNode);
        }
    });
    UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path(NODES).path("NODE_ID");
    return created(locationBuilder.build()).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response createNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "CREATE"));
    readNodeConfiguration(input).forEach(osNode -> {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            osNodeAdminService.createNode(osNode);
        }
    });
    UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path(NODES).path("NODE_ID");
    return created(locationBuilder.build()).build();
}
#end_block

#method_before
@PUT
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updateNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "CREATE"));
    readNodeConfiguration(input).forEach(osNode -> {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            osNodeAdminService.createNode(osNode);
        } else if (!existing.equals(osNode)) {
            osNodeAdminService.updateNode(osNode);
        }
    });
    UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path(NODES).path("NODE_ID");
    return created(locationBuilder.build()).build();
}
#method_after
@PUT
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response updateNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "UPDATE"));
    Set<OpenstackNode> nodes = readNodeConfiguration(input);
    for (OpenstackNode osNode : nodes) {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            log.warn("There is no node configuration to update : {}", osNode.hostname());
            return Response.notModified().build();
        } else if (!existing.equals(osNode)) {
            osNodeAdminService.updateNode(osNode);
        }
    }
    return Response.ok().build();
}
#end_block

#method_before
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "CREATE"));
    readNodeConfiguration(input).forEach(osNode -> {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            log.warn("There is no node of {}", osNode.hostname());
        } else {
            osNodeAdminService.removeNode(osNode.hostname());
        }
    });
    UriBuilder locationBuilder = uriInfo.getBaseUriBuilder().path(NODES).path("NODE_ID");
    return created(locationBuilder.build()).build();
}
#method_after
@DELETE
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public Response deleteNodes(InputStream input) {
    log.trace(String.format(MESSAGE_NODE, "DELETE"));
    Set<OpenstackNode> nodes = readNodeConfiguration(input);
    for (OpenstackNode osNode : nodes) {
        OpenstackNode existing = osNodeService.node(osNode.hostname());
        if (existing == null) {
            log.warn("There is no node configuration to delete : {}", osNode.hostname());
            return Response.notModified().build();
        } else {
            osNodeAdminService.removeNode(osNode.hostname());
        }
    }
    return Response.ok().build();
}
#end_block

#method_before
private void parseP4Info(P4Info p4info) {
    p4info.getTablesList().forEach(entity -> {
        tables.addWithPreamble(entity.getPreamble(), entity);
        // Index match fields.
        int tableId = entity.getPreamble().getId();
        String tableName = entity.getPreamble().getName();
        EntityBrowser<MatchField> matchFieldBrowser = new EntityBrowser<>(format("match field for table '%s'", tableName));
        entity.getMatchFieldsList().forEach(m -> matchFieldBrowser.add(m.getName(), m.getId(), m));
        matchFields.put(tableId, matchFieldBrowser);
    });
    p4info.getActionsList().forEach(entity -> {
        actions.addWithPreamble(entity.getPreamble(), entity);
        // Index action params.
        int actionId = entity.getPreamble().getId();
        String actionName = entity.getPreamble().getName();
        EntityBrowser<Action.Param> paramBrowser = new EntityBrowser<>(format("param for action '%s'", actionName));
        entity.getParamsList().forEach(p -> paramBrowser.add(p.getName(), p.getId(), p));
        actionParams.put(actionId, paramBrowser);
    });
    p4info.getActionProfilesList().forEach(entity -> actionProfiles.addWithPreamble(entity.getPreamble(), entity));
    p4info.getCountersList().forEach(entity -> counters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectCountersList().forEach(entity -> directCounters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getMetersList().forEach(entity -> meters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectMetersList().forEach(entity -> directMeters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getControllerPacketMetadataList().forEach(entity -> {
        ctrlPktMetadatas.addWithPreamble(entity.getPreamble(), entity);
        // Index control packet metadata metadata.
        int ctrlPktMetadataId = entity.getPreamble().getId();
        String ctrlPktMetadataName = entity.getPreamble().getName();
        EntityBrowser<ControllerPacketMetadata.Metadata> metadataBrowser = new EntityBrowser<>(format("metadata for pkt '%s'", ctrlPktMetadataName));
        entity.getMetadataList().forEach(m -> metadataBrowser.add(m.getName(), m.getId(), m));
        ctrlPktMetadatasMetadata.put(ctrlPktMetadataId, metadataBrowser);
    });
}
#method_after
private void parseP4Info(P4Info p4info) {
    p4info.getTablesList().forEach(entity -> {
        tables.addWithPreamble(entity.getPreamble(), entity);
        // Index match fields.
        int tableId = entity.getPreamble().getId();
        String tableName = entity.getPreamble().getName();
        EntityBrowser<MatchField> matchFieldBrowser = new EntityBrowser<>(format("match field for table '%s'", tableName));
        entity.getMatchFieldsList().forEach(m -> {
            String alias = extractMatchFieldSimpleName(m.getName());
            matchFieldBrowser.add(m.getName(), alias, m.getId(), m);
        });
        matchFields.put(tableId, matchFieldBrowser);
    });
    p4info.getActionsList().forEach(entity -> {
        actions.addWithPreamble(entity.getPreamble(), entity);
        // Index action params.
        int actionId = entity.getPreamble().getId();
        String actionName = entity.getPreamble().getName();
        EntityBrowser<Action.Param> paramBrowser = new EntityBrowser<>(format("param for action '%s'", actionName));
        entity.getParamsList().forEach(p -> paramBrowser.add(p.getName(), null, p.getId(), p));
        actionParams.put(actionId, paramBrowser);
    });
    p4info.getActionProfilesList().forEach(entity -> actionProfiles.addWithPreamble(entity.getPreamble(), entity));
    p4info.getCountersList().forEach(entity -> counters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectCountersList().forEach(entity -> directCounters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getMetersList().forEach(entity -> meters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectMetersList().forEach(entity -> directMeters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getControllerPacketMetadataList().forEach(entity -> {
        ctrlPktMetadatas.addWithPreamble(entity.getPreamble(), entity);
        // Index control packet metadata metadata.
        int ctrlPktMetadataId = entity.getPreamble().getId();
        String ctrlPktMetadataName = entity.getPreamble().getName();
        EntityBrowser<ControllerPacketMetadata.Metadata> metadataBrowser = new EntityBrowser<>(format("metadata field for controller packet metadata '%s'", ctrlPktMetadataName));
        entity.getMetadataList().forEach(m -> metadataBrowser.add(m.getName(), null, m.getId(), m));
        ctrlPktMetadatasMetadata.put(ctrlPktMetadataId, metadataBrowser);
    });
}
#end_block

#method_before
EntityBrowser<ControllerPacketMetadata.Metadata> packetMetadatas(int controllerPacketMetadata) throws NotFoundException {
    // Throws exception if action id is not found.
    ctrlPktMetadatas.getById(controllerPacketMetadata);
    return ctrlPktMetadatasMetadata.get(controllerPacketMetadata);
}
#method_after
EntityBrowser<ControllerPacketMetadata.Metadata> packetMetadatas(int controllerPacketMetadataId) throws NotFoundException {
    // Throws exception if controller packet metadata id is not found.
    ctrlPktMetadatas.getById(controllerPacketMetadataId);
    return ctrlPktMetadatasMetadata.get(controllerPacketMetadataId);
}
#end_block

#method_before
void add(String name, int id, T entity) {
    names.put(name, entity);
    ids.put(id, entity);
}
#method_after
void add(String name, String alias, int id, T entity) {
    checkNotNull(name);
    checkArgument(!name.isEmpty(), "Name cannot be empty");
    checkNotNull(entity);
    names.put(name, entity);
    ids.put(id, entity);
    if (alias != null && !alias.isEmpty()) {
        aliases.put(alias, entity);
    }
}
#end_block

#method_before
void addWithPreamble(Preamble preamble, T entity) {
    names.put(preamble.getName(), entity);
    aliases.put(preamble.getName(), entity);
    ids.put(preamble.getId(), entity);
}
#method_after
void addWithPreamble(Preamble preamble, T entity) {
    checkNotNull(preamble);
    add(preamble.getName(), preamble.getAlias(), preamble.getId(), entity);
}
#end_block

#method_before
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ExtensionType targetConfigExtType) {
    log.info("Setting pipeline config for {} to {} using {}...", deviceId, pipeconf.id(), targetConfigExtType);
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    if (!pipeconf.extension(targetConfigExtType).isPresent()) {
        log.warn("Missing extension {} in pipeconf {}", targetConfigExtType, pipeconf.id());
        return false;
    }
    InputStream targetConfig = pipeconf.extension(targetConfigExtType).get();
    P4Config.P4DeviceConfig deviceIdConfig;
    try {
        deviceIdConfig = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.readFrom(targetConfig)).build();
    } catch (IOException ex) {
        log.warn("Unable to load target-specific config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setAction(VERIFY_AND_COMMIT).addConfigs(ForwardingPipelineConfig.newBuilder().setDeviceId(p4DeviceId).setP4Info(p4Info).setP4DeviceConfig(deviceIdConfig.toByteString()).build()).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        log.warn("Unable to set pipeline config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
    return true;
}
#method_after
private boolean doSetPipelineConfig(PiPipeconf pipeconf, ExtensionType targetConfigExtType) {
    log.info("Setting pipeline config for {} to {} using {}...", deviceId, pipeconf.id(), targetConfigExtType);
    P4Info p4Info = PipeconfHelper.getP4Info(pipeconf);
    if (p4Info == null) {
        // Problem logged by PipeconfHelper.
        return false;
    }
    if (!pipeconf.extension(targetConfigExtType).isPresent()) {
        log.warn("Missing extension {} in pipeconf {}", targetConfigExtType, pipeconf.id());
        return false;
    }
    InputStream targetConfig = pipeconf.extension(targetConfigExtType).get();
    P4Config.P4DeviceConfig p4DeviceConfigMsg;
    try {
        p4DeviceConfigMsg = P4Config.P4DeviceConfig.newBuilder().setExtras(P4Config.P4DeviceConfig.Extras.getDefaultInstance()).setReassign(true).setDeviceData(ByteString.readFrom(targetConfig)).build();
    } catch (IOException ex) {
        log.warn("Unable to load target-specific config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
    SetForwardingPipelineConfigRequest request = SetForwardingPipelineConfigRequest.newBuilder().setAction(VERIFY_AND_COMMIT).addConfigs(ForwardingPipelineConfig.newBuilder().setDeviceId(p4DeviceId).setP4Info(p4Info).setP4DeviceConfig(p4DeviceConfigMsg.toByteString()).build()).build();
    try {
        this.blockingStub.setForwardingPipelineConfig(request);
    } catch (StatusRuntimeException ex) {
        log.warn("Unable to set pipeline config for {}: {}", deviceId, ex.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.info("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.info("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    // Dummy future result.
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#method_after
private Collection<PiTableEntry> doDumpTable(PiTableId piTableId, PiPipeconf pipeconf) {
    log.info("Dumping table {} from {} (pipeconf {})...", piTableId, deviceId, pipeconf.id());
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    int tableId;
    try {
        tableId = browser.tables().getByName(piTableId.id()).getPreamble().getId();
    } catch (P4InfoBrowser.NotFoundException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    ReadRequest requestMsg = ReadRequest.newBuilder().setDeviceId(p4DeviceId).addEntities(Entity.newBuilder().setTableEntry(TableEntry.newBuilder().setTableId(tableId).build()).build()).build();
    Iterator<ReadResponse> responses;
    try {
        responses = blockingStub.read(requestMsg);
    } catch (StatusRuntimeException e) {
        log.warn("Unable to dump table: {}", e.getMessage());
        return Collections.emptyList();
    }
    Iterable<ReadResponse> responseIterable = () -> responses;
    List<TableEntry> tableEntryMsgs = StreamSupport.stream(responseIterable.spliterator(), false).map(ReadResponse::getEntitiesList).flatMap(List::stream).filter(entity -> entity.getEntityCase() == TABLE_ENTRY).map(Entity::getTableEntry).collect(Collectors.toList());
    log.info("Retrieved {} entries from table {} on {}...", tableEntryMsgs.size(), piTableId, deviceId);
    return TableEntryEncoder.decode(tableEntryMsgs, pipeconf);
}
#end_block

#method_before
private boolean doPacketOut(PiPacketOperation packet, PiPipeconf pipeconf) {
    P4InfoBrowser browser = PipeconfHelper.getP4InfoBrowser(pipeconf);
    try {
        // Get the packet out packet metadata
        P4InfoOuterClass.ControllerPacketMetadata controllerPacketMetadata = browser.controllerPacketMetadatas().getByName("packet_out");
        PacketOut.Builder packetOutBuilder = PacketOut.newBuilder();
        // Sdd all it's metadata to the packet out
        packetOutBuilder.addAllMetadata(packet.metadatas().stream().map(metadata -> {
            try {
                // get each metadata id
                int metadataId = browser.packetMetadatas(controllerPacketMetadata.getPreamble().getId()).getByName(metadata.id().name()).getId();
                // Add the metadata id and it's data the packet out
                return PacketMetadata.newBuilder().setMetadataId(metadataId).setValue(ByteString.copyFrom(metadata.value().asReadOnlyBuffer())).build();
            } catch (P4InfoBrowser.NotFoundException e) {
                log.error("Cant find metadata with name {} in p4Info file.", metadata.id().name());
                return null;
            }
        }).filter(Objects::nonNull).collect(Collectors.toList()));
        // Set the packet out payload
        packetOutBuilder.setPayload(ByteString.copyFrom(packet.data().asReadOnlyBuffer()));
        PacketOut packetOut = packetOutBuilder.build();
        // Build the request
        StreamMessageRequest packetOutRequest = StreamMessageRequest.newBuilder().setPacket(packetOut).build();
        // Send the request
        streamRequestObserver.onNext(packetOutRequest);
    } catch (P4InfoBrowser.NotFoundException e) {
        log.error("Cant find metadata with name \"packet_out\" in p4Info file.");
        return false;
    }
    return true;
}
#method_after
private boolean doPacketOut(PiPacketOperation packet, PiPipeconf pipeconf) {
    try {
        // encode the PiPacketOperation into a PacketOut
        PacketOut packetOut = PacketIOCodec.encodePacketOut(packet, pipeconf);
        // Build the request
        StreamMessageRequest packetOutRequest = StreamMessageRequest.newBuilder().setPacket(packetOut).build();
        // Send the request
        streamRequestObserver.onNext(packetOutRequest);
    } catch (P4InfoBrowser.NotFoundException e) {
        log.error("Cant find expected metadata in p4Info file. {}", e.getMessage());
        log.debug("Exception", e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void onNext(StreamMessageResponse message) {
    P4RuntimeEvent event;
    if (message.getPacket().isInitialized()) {
        // Packet-in
        PacketIn packetIn = message.getPacket();
        ImmutableByteSequence data = copyFrom(packetIn.getPayload().asReadOnlyByteBuffer());
        ImmutableList.Builder<ImmutableByteSequence> metadataBuilder = ImmutableList.builder();
        packetIn.getMetadataList().stream().map(m -> m.getValue().asReadOnlyByteBuffer()).map(ImmutableByteSequence::copyFrom).forEach(metadataBuilder::add);
        event = new DefaultPacketInEvent(deviceId, data, metadataBuilder.build());
    } else if (message.getArbitration().isInitialized()) {
        // Arbitration.
        throw new UnsupportedOperationException("Arbitration not implemented.");
    } else {
        log.warn("Unrecognized stream message from {}: {}", deviceId, message);
        return;
    }
    controller.postEvent(event);
}
#method_after
@Override
public void onNext(StreamMessageResponse message) {
    executorService.submit(() -> doNext(message));
}
#end_block

#method_before
public Builder ochSignal(OchSignal ochSignal) {
    this.ochSignal = ochSignal;
    return this;
}
#method_after
public Builder ochSignal(OchSignal ochSignal) {
    this.ochSignal = Optional.ofNullable(ochSignal);
    return this;
}
#end_block

#method_before
public OchSignal ochSignal() {
    return ochSignal;
}
#method_after
public Optional<OchSignal> ochSignal() {
    return ochSignal;
}
#end_block

#method_before
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    ConnectPoint ingress = createConnectPoint(ingressString);
    ConnectPoint egress = createConnectPoint(egressString);
    if (ingress == null || egress == null) {
        print("Invalid endpoint(s); could not create optical intent");
        return;
    }
    DeviceService deviceService = opticalView(get(DeviceService.class));
    Port srcPort = deviceService.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = deviceService.getPort(egress.deviceId(), egress.port());
    Intent intent;
    if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
        Device srcDevice = deviceService.getDevice(ingress.deviceId());
        Device dstDevice = deviceService.getDevice(egress.deviceId());
        // continue only if both OduClt port's Devices are of the same type
        if (!(srcDevice.type().equals(dstDevice.type()))) {
            print("Devices without same deviceType: SRC=%s and DST=%s", srcDevice.type(), dstDevice.type());
            return;
        }
        CltSignalType signalType = ((OduCltPort) srcPort).signalType();
        if (Device.Type.ROADM.equals(srcDevice.type()) || Device.Type.ROADM_OTN.equals(srcDevice.type())) {
            intent = OpticalCircuitIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else if (Device.Type.OTN.equals(srcDevice.type())) {
            intent = OpticalOduIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else {
            print("Wrong Device Type for connect points %s and %s", ingress, egress);
            return;
        }
    } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
        OchSignal ochSignal = createOchSignal(channel);
        OduSignalType signalType = ((OchPort) srcPort).signalType();
        intent = OpticalConnectivityIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).ochSignal(ochSignal).build();
    } else {
        print("Unable to create optical intent between connect points %s and %s", ingress, egress);
        return;
    }
    service.submit(intent);
    print("Optical intent submitted:\n%s", intent.toString());
}
#method_after
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    ConnectPoint ingress = createConnectPoint(ingressString);
    ConnectPoint egress = createConnectPoint(egressString);
    if (ingress == null || egress == null) {
        print("Invalid endpoint(s); could not create optical intent");
        return;
    }
    DeviceService deviceService = opticalView(get(DeviceService.class));
    Port srcPort = deviceService.getPort(ingress.deviceId(), ingress.port());
    Port dstPort = deviceService.getPort(egress.deviceId(), egress.port());
    Intent intent;
    if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
        Device srcDevice = deviceService.getDevice(ingress.deviceId());
        Device dstDevice = deviceService.getDevice(egress.deviceId());
        // continue only if both OduClt port's Devices are of the same type
        if (!(srcDevice.type().equals(dstDevice.type()))) {
            print("Devices without same deviceType: SRC=%s and DST=%s", srcDevice.type(), dstDevice.type());
            return;
        }
        CltSignalType signalType = ((OduCltPort) srcPort).signalType();
        if (Device.Type.ROADM.equals(srcDevice.type()) || Device.Type.ROADM_OTN.equals(srcDevice.type())) {
            intent = OpticalCircuitIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else if (Device.Type.OTN.equals(srcDevice.type())) {
            intent = OpticalOduIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).build();
        } else {
            print("Wrong Device Type for connect points %s and %s", ingress, egress);
            return;
        }
    } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
        OduSignalType signalType = ((OchPort) srcPort).signalType();
        intent = OpticalConnectivityIntent.builder().appId(appId()).key(key()).src(ingress).dst(egress).signalType(signalType).bidirectional(bidirectional).ochSignal(createOchSignal(channel)).build();
    } else {
        print("Unable to create optical intent between connect points %s and %s", ingress, egress);
        return;
    }
    service.submit(intent);
    print("Optical intent submitted:\n%s", intent.toString());
}
#end_block

#method_before
private List<OchSignal> findFirstAvailableLambda(OpticalConnectivityIntent intent, Path path) {
    if (intent.ochSignal() != null) {
        return Collections.singletonList(intent.ochSignal());
    }
    Set<OchSignal> lambdas = findCommonLambdas(path);
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    return findFirstLambda(lambdas, slotCount());
}
#method_after
private List<OchSignal> findFirstAvailableLambda(OpticalConnectivityIntent intent, Path path) {
    if (intent.ochSignal().isPresent()) {
        return Collections.singletonList(intent.ochSignal().get());
    }
    Set<OchSignal> lambdas = findCommonLambdas(path);
    if (lambdas.isEmpty()) {
        return Collections.emptyList();
    }
    return findFirstLambda(lambdas, slotCount());
}
#end_block

#method_before
@Test
public void mockTopology() {
    host = new DefaultHost(PID, HID, MAC_ADDRESS, VID, LOC, IPSET);
    uiHost = new UiHost(topo, host);
    deviceLink = new UiDeviceLink(topo, DX1_DY2);
    edgeLink = DefaultEdgeLink.createEdgeLink(CP, true);
    linkId = UiLinkId.uiLinkId(edgeLink);
    uiEdgeLink = new UiEdgeLink(topo, linkId);
    mem1 = clusterMember("id1", 001);
    region1 = region();
    dev1 = device();
    Set<DeviceId> deviceIds = new HashSet<>();
    Set<HostId> hostIds = new HashSet<>();
    topo.add(uiHost);
    topo.add(mem1);
    topo.add(region1);
    topo.add(dev1);
    topo.add(deviceLink);
    topo.add(uiEdgeLink);
    assertTrue(topo.allRegions().contains(region1));
    assertTrue(topo.allClusterMembers().contains(mem1));
    assertTrue(topo.findClusterMember(NodeId.nodeId("id1")).equals(mem1));
    assertTrue(topo.findRegion(R1).equals(region1));
    assertTrue(topo.findDevice(DID).equals(dev1));
    assertTrue(topo.findHost(HID).equals(uiHost));
    assertTrue(topo.findDeviceLink(DX1_DY2).equals(deviceLink));
    deviceIds.add(DID);
    assertTrue(topo.deviceSet(deviceIds).contains(dev1));
    hostIds.add(HID);
    assertTrue(topo.hostSet(hostIds).contains(uiHost));
    topo.clear();
    assertThat(topo.allClusterMembers(), is(empty()));
    assertThat(topo.allDeviceLinks(), is(empty()));
    assertThat(topo.allDevices(), is(empty()));
    assertThat(topo.allHosts(), is(empty()));
    assertThat(topo.allRegions(), is(empty()));
}
#method_after
@Test
public void mockTopology() {
    host = new DefaultHost(PID, HID, MAC_ADDRESS, VID, LOC, IPSET);
    uiHost = new UiHost(topo, host);
    deviceLink = new UiDeviceLink(topo, DX1_DY2);
    edgeLink = DefaultEdgeLink.createEdgeLink(CP, true);
    linkId = UiLinkId.uiLinkId(edgeLink);
    uiEdgeLink = new UiEdgeLink(topo, linkId);
    mem1 = clusterMember(MID, 001);
    region1 = region();
    dev1 = device();
    Set<DeviceId> deviceIds = new HashSet<>();
    Set<HostId> hostIds = new HashSet<>();
    topo.add(uiHost);
    topo.add(mem1);
    topo.add(region1);
    topo.add(dev1);
    topo.add(deviceLink);
    topo.add(uiEdgeLink);
    assertTrue(topo.allRegions().contains(region1));
    assertTrue(topo.allClusterMembers().contains(mem1));
    assertTrue(topo.findClusterMember(NodeId.nodeId("id1")).equals(mem1));
    assertTrue(topo.findRegion(R1).equals(region1));
    assertTrue(topo.findDevice(DID).equals(dev1));
    assertTrue(topo.findHost(HID).equals(uiHost));
    assertTrue(topo.findDeviceLink(DX1_DY2).equals(deviceLink));
    deviceIds.add(DID);
    assertTrue(topo.deviceSet(deviceIds).contains(dev1));
    hostIds.add(HID);
    assertTrue(topo.hostSet(hostIds).contains(uiHost));
    topo.clear();
    assertThat(topo.allClusterMembers(), is(empty()));
    assertThat(topo.allDeviceLinks(), is(empty()));
    assertThat(topo.allDevices(), is(empty()));
    assertThat(topo.allHosts(), is(empty()));
    assertThat(topo.allRegions(), is(empty()));
}
#end_block

#method_before
public Class<T> serviceIntf() {
    return serviceIntf;
}
#method_after
public Class<? extends RpcService> serviceIntf() {
    return serviceIntf;
}
#end_block

#method_before
@Override
public void emit(OutboundPacket packet) {
    TrafficTreatment treatment = packet.treatment();
    // BMv2 supports only OUTPUT instructions.
    List<Instructions.OutputInstruction> outInstructions = treatment.allInstructions().stream().filter(i -> i.type().equals(OUTPUT)).map(i -> (Instructions.OutputInstruction) i).collect(toList());
    if (treatment.allInstructions().size() != outInstructions.size()) {
        // There are other instructions that are not of type OUTPUT
        log.warn("Dropping emit request, treatment nor supported: {}", treatment);
        return;
    }
    outInstructions.forEach(outInst -> {
        if (outInst.port().isLogical()) {
            log.warn("Dropping emit request, logical port not supported: {}", outInst.port());
        } else {
            try {
                int portNumber = toIntExact(outInst.port().toLong());
                send(portNumber, packet);
            } catch (ArithmeticException e) {
                log.error("Dropping emit request, port number too big: {}", outInst.port().toLong());
            }
        }
    });
}
#method_after
@Override
public void emit(OutboundPacket packet) {
    DeviceId deviceId = handler().data().deviceId();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    if (!controller.hasClient(deviceId)) {
        log.warn("Unable to find client for {}, aborting the sending packet", deviceId);
        return;
    }
    P4RuntimeClient client = controller.getClient(deviceId);
    PiPipeconfService piPipeconfService = handler().get(PiPipeconfService.class);
    final PiPipeconf pipeconf;
    if (piPipeconfService.ofDevice(deviceId).isPresent() && piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).isPresent()) {
        pipeconf = piPipeconfService.getPipeconf(piPipeconfService.ofDevice(deviceId).get()).get();
    } else {
        log.warn("Unable to get the pipeconf of the {}", deviceId);
        return;
    }
    DeviceService deviceService = handler().get(DeviceService.class);
    Device device = deviceService.getDevice(deviceId);
    final PiPipelineInterpreter interpreter = device.is(PiPipelineInterpreter.class) ? device.as(PiPipelineInterpreter.class) : null;
    if (interpreter == null) {
        log.warn("Device {} unable to instantiate interpreter of pipeconf {}", deviceId, pipeconf.id());
        return;
    }
    try {
        PiPacketOperation piPacketOperation = PiPacketOperation.builder().withType(PACKET_OUT).withData(ImmutableByteSequence.copyFrom(packet.data())).withMetadatas(interpreter.mapOutboundPacket(packet, pipeconf)).build();
        client.packetOut(piPacketOperation, pipeconf);
    } catch (PiPipelineInterpreter.PiInterpreterException e) {
        log.error("Interpreter of pipeconf {} was unable to translate outbound packet: {}", pipeconf.id(), e.getMessage());
    }
}
#end_block

#method_before
@Test
public void testExactMatchPiMethod() {
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesExactBytes = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesExactShort = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesExactInt = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesExactLong = Maps.newHashMap();
    Criterion matchPiBytes = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactBytes1).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesExactBytes.put(piEthHeaderFieldId, new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactBytes1)));
    assertThat(piCriterionBytes.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesExactBytes.values()))));
    assertThat(piCriterionBytes.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiShort = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactShort1).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesExactShort.put(piEthHeaderFieldId, new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactShort1)));
    assertThat(piCriterionShort.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesExactShort.values()))));
    assertThat(piCriterionShort.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiInt = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactInt1).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesExactInt.put(piEthHeaderFieldId, new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactInt1)));
    assertThat(piCriterionInt.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesExactInt.values()))));
    assertThat(piCriterionInt.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiLong = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactLong1).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesExactLong.put(piEthHeaderFieldId, new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactLong1)));
    assertThat(piCriterionLong.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesExactLong.values()))));
    assertThat(piCriterionLong.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
}
#method_after
@Test
public void testExactMatchPiMethod() {
    Criterion matchPiBytes = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactBytes1).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchBytes = new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactBytes1));
    assertThat(piCriterionBytes.fieldMatches().iterator().next(), is(expectedMatchBytes));
    Criterion matchPiShort = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactShort1).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchShort = new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactShort1));
    assertThat(piCriterionShort.fieldMatches().iterator().next(), is(expectedMatchShort));
    Criterion matchPiInt = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactInt1).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchInt = new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactInt1));
    assertThat(piCriterionInt.fieldMatches().iterator().next(), is(expectedMatchInt));
    Criterion matchPiLong = PiCriterion.builder().matchExact(piEthHeaderFieldId, matchExactLong1).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchLong = new PiExactFieldMatch(piEthHeaderFieldId, copyFrom(matchExactLong1));
    assertThat(piCriterionLong.fieldMatches().iterator().next(), is(expectedMatchLong));
}
#end_block

#method_before
@Test
public void testLpmMatchPiMethod() {
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesLpmBytes = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesLpmShort = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesLpmInt = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesLpmLong = Maps.newHashMap();
    Criterion matchPiBytes = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmBytes1, mask).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesLpmBytes.put(piIpv4HeaderFieldId, new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmBytes1), mask));
    assertThat(piCriterionBytes.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesLpmBytes.values()))));
    assertThat(piCriterionBytes.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiShort = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmShort1, mask).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesLpmShort.put(piIpv4HeaderFieldId, new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmShort1), mask));
    assertThat(piCriterionShort.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesLpmShort.values()))));
    assertThat(piCriterionShort.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiInt = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmInt1, mask).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesLpmInt.put(piIpv4HeaderFieldId, new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmInt1), mask));
    assertThat(piCriterionInt.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesLpmInt.values()))));
    assertThat(piCriterionInt.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiLong = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmLong1, mask).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesLpmLong.put(piIpv4HeaderFieldId, new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmLong1), mask));
    assertThat(piCriterionLong.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesLpmLong.values()))));
    assertThat(piCriterionLong.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
}
#method_after
@Test
public void testLpmMatchPiMethod() {
    Criterion matchPiBytes = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmBytes1, mask).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchBytes = new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmBytes1), mask);
    assertThat(piCriterionBytes.fieldMatches().iterator().next(), is(expectedMatchBytes));
    Criterion matchPiShort = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmShort1, mask).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchShort = new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmShort1), mask);
    assertThat(piCriterionShort.fieldMatches().iterator().next(), is(expectedMatchShort));
    Criterion matchPiInt = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmInt1, mask).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchInt = new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmInt1), mask);
    assertThat(piCriterionInt.fieldMatches().iterator().next(), is(expectedMatchInt));
    Criterion matchPiLong = PiCriterion.builder().matchLpm(piIpv4HeaderFieldId, matchLpmLong1, mask).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchLong = new PiLpmFieldMatch(piIpv4HeaderFieldId, copyFrom(matchLpmLong1), mask);
    assertThat(piCriterionLong.fieldMatches().iterator().next(), is(expectedMatchLong));
}
#end_block

#method_before
@Test
public void testTernaryMatchPiMethod() {
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesTernaryBytes = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesTernaryShort = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesTernaryInt = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesTernaryLong = Maps.newHashMap();
    Criterion matchPiBytes = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryBytes1, matchTernaryMaskBytes).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesTernaryBytes.put(piIpv4HeaderFieldId, new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryBytes1), copyFrom(matchTernaryMaskBytes)));
    assertThat(piCriterionBytes.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesTernaryBytes.values()))));
    assertThat(piCriterionBytes.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiShort = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryShort1, matchTernaryMaskShort).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesTernaryShort.put(piIpv4HeaderFieldId, new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryShort1), copyFrom(matchTernaryMaskShort)));
    assertThat(piCriterionShort.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesTernaryShort.values()))));
    assertThat(piCriterionShort.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiInt = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryInt1, matchTernaryMaskInt).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesTernaryInt.put(piIpv4HeaderFieldId, new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryInt1), copyFrom(matchTernaryMaskInt)));
    assertThat(piCriterionInt.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesTernaryInt.values()))));
    assertThat(piCriterionInt.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiLong = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryLong1, matchTernaryMaskLong).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesTernaryLong.put(piIpv4HeaderFieldId, new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryLong1), copyFrom(matchTernaryMaskLong)));
    assertThat(piCriterionLong.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesTernaryLong.values()))));
    assertThat(piCriterionLong.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
}
#method_after
@Test
public void testTernaryMatchPiMethod() {
    Criterion matchPiBytes = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryBytes1, matchTernaryMaskBytes).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchBytes = new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryBytes1), copyFrom(matchTernaryMaskBytes));
    assertThat(piCriterionBytes.fieldMatches().iterator().next(), is(expectedMatchBytes));
    Criterion matchPiShort = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryShort1, matchTernaryMaskShort).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchShort = new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryShort1), copyFrom(matchTernaryMaskShort));
    assertThat(piCriterionShort.fieldMatches().iterator().next(), is(expectedMatchShort));
    Criterion matchPiInt = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryInt1, matchTernaryMaskInt).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchInt = new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryInt1), copyFrom(matchTernaryMaskInt));
    assertThat(piCriterionInt.fieldMatches().iterator().next(), is(expectedMatchInt));
    Criterion matchPiLong = PiCriterion.builder().matchTernary(piIpv4HeaderFieldId, matchTernaryLong1, matchTernaryMaskLong).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchLong = new PiTernaryFieldMatch(piIpv4HeaderFieldId, copyFrom(matchTernaryLong1), copyFrom(matchTernaryMaskLong));
    assertThat(piCriterionLong.fieldMatches().iterator().next(), is(expectedMatchLong));
}
#end_block

#method_before
@Test
public void testValidMatchPiMethod() {
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesValid = Maps.newHashMap();
    Criterion matchPiBytes = PiCriterion.builder().matchValid(piIpv4HeaderFieldId, true).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesValid.put(piIpv4HeaderFieldId, new PiValidFieldMatch(piIpv4HeaderFieldId, true));
    assertThat(piCriterionBytes.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesValid.values()))));
    assertThat(piCriterionBytes.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
}
#method_after
@Test
public void testValidMatchPiMethod() {
    Criterion matchPiBytes = PiCriterion.builder().matchValid(piIpv4HeaderFieldId, true).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatch = new PiValidFieldMatch(piIpv4HeaderFieldId, true);
    assertThat(piCriterionBytes.fieldMatches().iterator().next(), is(expectedMatch));
}
#end_block

#method_before
@Test
public void testRangeMatchPiMethod() {
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesRangeBytes = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesRangeShort = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesRangeInt = Maps.newHashMap();
    Map<PiHeaderFieldId, PiFieldMatch> fieldMatchesRangeLong = Maps.newHashMap();
    Criterion matchPiBytes = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeBytes1, matchRangeHighBytes).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesRangeBytes.put(piIpv4HeaderFieldId, new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeBytes1), copyFrom(matchRangeHighBytes)));
    assertThat(piCriterionBytes.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesRangeBytes.values()))));
    assertThat(piCriterionBytes.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiShort = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeShort1, matchRangeHighShort).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesRangeShort.put(piIpv4HeaderFieldId, new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeShort1), copyFrom(matchRangeHighShort)));
    assertThat(piCriterionShort.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesRangeShort.values()))));
    assertThat(piCriterionShort.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiInt = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeInt1, matchRangeHighInt).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesRangeInt.put(piIpv4HeaderFieldId, new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeInt1), copyFrom(matchRangeHighInt)));
    assertThat(piCriterionInt.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesRangeInt.values()))));
    assertThat(piCriterionInt.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
    Criterion matchPiLong = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeLong1, matchRangeHighLong).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    fieldMatchesRangeLong.put(piIpv4HeaderFieldId, new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeLong1), copyFrom(matchRangeHighLong)));
    assertThat(piCriterionLong.fieldMatches(), is(equalTo(ImmutableSet.copyOf(fieldMatchesRangeLong.values()))));
    assertThat(piCriterionLong.type(), is(equalTo(Criterion.Type.PROTOCOL_INDEPENDENT)));
}
#method_after
@Test
public void testRangeMatchPiMethod() {
    Criterion matchPiBytes = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeBytes1, matchRangeHighBytes).build();
    PiCriterion piCriterionBytes = checkAndConvert(matchPiBytes, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchBytes = new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeBytes1), copyFrom(matchRangeHighBytes));
    assertThat(piCriterionBytes.fieldMatches().iterator().next(), is(expectedMatchBytes));
    Criterion matchPiShort = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeShort1, matchRangeHighShort).build();
    PiCriterion piCriterionShort = checkAndConvert(matchPiShort, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchShort = new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeShort1), copyFrom(matchRangeHighShort));
    assertThat(piCriterionShort.fieldMatches().iterator().next(), is(expectedMatchShort));
    Criterion matchPiInt = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeInt1, matchRangeHighInt).build();
    PiCriterion piCriterionInt = checkAndConvert(matchPiInt, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchInt = new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeInt1), copyFrom(matchRangeHighInt));
    assertThat(piCriterionInt.fieldMatches().iterator().next(), is(expectedMatchInt));
    Criterion matchPiLong = PiCriterion.builder().matchRange(piIpv4HeaderFieldId, matchRangeLong1, matchRangeHighLong).build();
    PiCriterion piCriterionLong = checkAndConvert(matchPiLong, Criterion.Type.PROTOCOL_INDEPENDENT, PiCriterion.class);
    PiFieldMatch expectedMatchLong = new PiRangeFieldMatch(piIpv4HeaderFieldId, copyFrom(matchRangeLong1), copyFrom(matchRangeHighLong));
    assertThat(piCriterionLong.fieldMatches().iterator().next(), is(expectedMatchLong));
}
#end_block

#method_before
// TODO after RPC abstractions are merged; else will lead to build failure
/*public void registerHandler(RpcHandler handler, RpcCommand command) {
        handlerRegistry.put(command, handler);
    }

    public void unRegisterHandler(RpcHandler handler, RpcCommand command) {
        Versioned<RpcHandler> ret = handlerRegistry.get(command);
        if ((ret == null) || (ret.value() == null)) {
            throw new FailedException("No registered handler found, cannot unregister");
        }
        handlerRegistry.remove(command);
    }*/
public Future<RpcOutput> invokeRpc(ResourceId id, RpcInput input) {
    // TODO after RPC abstractions are merged; else will lead to build failure
    throw new FailedException("Not yet implemented");
}
#method_after
// TODO after RPC abstractions are merged; else will lead to build failure
/*public void registerHandler(RpcHandler handler, RpcCommand command) {
        handlerRegistry.put(command, handler);
    }

    public void unRegisterHandler(RpcHandler handler, RpcCommand command) {
        Versioned<RpcHandler> ret = handlerRegistry.get(command);
        if ((ret == null) || (ret.value() == null)) {
            throw new FailedException("No registered handler found, cannot unregister");
        }
        handlerRegistry.remove(command);
    }*/
public CompletableFuture<RpcOutput> invokeRpc(ResourceId id, RpcInput input) {
    // TODO after RPC abstractions are merged; else will lead to build failure
    throw new FailedException("Not yet implemented");
}
#end_block

#method_before
@Override
public DeviceDescription discoverDeviceDetails() {
    log.info("Adding description for EA1000 device");
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    IetfSystemNetconfService ietfSystemService = (IetfSystemNetconfService) checkNotNull(handler().get(IetfSystemNetconfService.class));
    try {
        IetfSystem system = ietfSystemService.getIetfSystemInit(session);
        if (system != null && system.systemState() != null) {
            swVersion = system.systemState().platform().osRelease();
            AugmentedSysPlatform augmentedSysPlatform = (AugmentedSysPlatform) system.systemState().platform().augmentation(DefaultAugmentedSysPlatform.class);
            serialNumber = augmentedSysPlatform.deviceIdentification().serialNumber();
            DateAndTime deviceDateAndTime = system.systemState().clock().currentDatetime();
            OffsetDateTime odt = OffsetDateTime.parse(deviceDateAndTime.string(), DateTimeFormatter.ISO_OFFSET_DATE_TIME);
            if (odt.getYear() < OffsetDateTime.now(ZoneId.of("UTC")).getYear()) {
                OffsetDateTime nowUtc = OffsetDateTime.now(ZoneId.of("UTC"));
                log.warn("Date on device is in the past: {}. Setting it to {}", odt.toString(), nowUtc);
                ietfSystemService.setCurrentDatetime(nowUtc, session);
            }
        }
        if (system != null && system.system() != null) {
            AugmentedSysSystem augmentedSystem = (AugmentedSysSystem) system.system().augmentation(DefaultAugmentedSysSystem.class);
            longitudeStr = augmentedSystem.longitude().toPlainString();
            latitudeStr = augmentedSystem.latitude().toPlainString();
        }
    } catch (NetconfException e) {
        log.error("Unable to retrieve init data from device: " + handler().data().deviceId().toString() + " Error: " + e.getMessage());
        e.printStackTrace();
    }
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder();
    if (longitudeStr != null && latitudeStr != null) {
        annotationsBuilder.set(AnnotationKeys.LONGITUDE, longitudeStr).set(AnnotationKeys.LATITUDE, latitudeStr).build();
    } else {
        log.warn("Longitude and latitude could not be retrieved from device " + deviceId);
    }
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTHER, "Microsemi", "EA1000", swVersion, serialNumber, new ChassisId(), annotationsBuilder.build());
}
#method_after
@Override
public DeviceDescription discoverDeviceDetails() {
    log.info("Adding description for EA1000 device");
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfDevice ncDevice = controller.getDevicesMap().get(handler().data().deviceId());
    if (ncDevice == null) {
        log.error("Internal ONOS Error. Device has been marked as reachable, " + "but deviceID {} is not in Devices Map. Continuing with empty description", handler().data().deviceId());
        return null;
    }
    NetconfSession session = ncDevice.getSession();
    IetfSystemNetconfService ietfSystemService = (IetfSystemNetconfService) checkNotNull(handler().get(IetfSystemNetconfService.class));
    try {
        IetfSystem system = ietfSystemService.getIetfSystemInit(session);
        if (system != null && system.systemState() != null) {
            swVersion = system.systemState().platform().osRelease();
            AugmentedSysPlatform augmentedSysPlatform = (AugmentedSysPlatform) system.systemState().platform().augmentation(DefaultAugmentedSysPlatform.class);
            serialNumber = augmentedSysPlatform.deviceIdentification().serialNumber();
            DateAndTime deviceDateAndTime = system.systemState().clock().currentDatetime();
            OffsetDateTime odt = OffsetDateTime.parse(deviceDateAndTime.string(), DateTimeFormatter.ISO_OFFSET_DATE_TIME);
            if (odt.getYear() < OffsetDateTime.now(ZoneId.of("UTC")).getYear()) {
                OffsetDateTime nowUtc = OffsetDateTime.now(ZoneId.of("UTC"));
                log.warn("Date on device is in the past: {}. Setting it to {}", odt.toString(), nowUtc);
                ietfSystemService.setCurrentDatetime(nowUtc, session);
            }
        }
        if (system != null && system.system() != null) {
            AugmentedSysSystem augmentedSystem = (AugmentedSysSystem) system.system().augmentation(DefaultAugmentedSysSystem.class);
            longitudeStr = augmentedSystem.longitude().toPlainString();
            latitudeStr = augmentedSystem.latitude().toPlainString();
        }
    } catch (NetconfException e) {
        log.error("Unable to retrieve init data from device: " + handler().data().deviceId().toString() + " Error: " + e.getMessage());
        e.printStackTrace();
    }
    DeviceService deviceService = checkNotNull(handler().get(DeviceService.class));
    DeviceId deviceId = handler().data().deviceId();
    Device device = deviceService.getDevice(deviceId);
    DefaultAnnotations.Builder annotationsBuilder = DefaultAnnotations.builder();
    if (longitudeStr != null && latitudeStr != null) {
        annotationsBuilder.set(AnnotationKeys.LONGITUDE, longitudeStr).set(AnnotationKeys.LATITUDE, latitudeStr).build();
    } else {
        log.warn("Longitude and latitude could not be retrieved from device " + deviceId);
    }
    return new DefaultDeviceDescription(device.id().uri(), Device.Type.OTHER, "Microsemi", "EA1000", swVersion, serialNumber, new ChassisId(), annotationsBuilder.build());
}
#end_block

#method_before
protected static final String removeRpcReplyData(String rpcReplyXml) {
    rpcReplyXml = REGEX_XML_HEADER.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA_NS.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA_CLOSE.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_CLOSE.matcher(rpcReplyXml).replaceFirst("");
    return rpcReplyXml;
}
#method_after
protected static final String removeRpcReplyData(String rpcReplyXml) {
    rpcReplyXml = REGEX_XML_HEADER.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA_NS.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA_CLOSE.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_DATA_EMPTY.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = REGEX_RPC_REPLY_CLOSE.matcher(rpcReplyXml).replaceFirst("");
    rpcReplyXml = rpcReplyXml.replace("\t", "");
    return rpcReplyXml;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(MSEA_SA_FILTERING);
    log.info("MseaSaFilteringManager Started");
}
#method_after
@Activate
public void activate() {
    super.activate();
    appId = coreService.registerApplication(MSEA_SA_FILTERING);
    log.info("MseaSaFilteringManager Started");
}
#end_block

#method_before
@Override
public boolean deleteMseaSaFilteringRange(MseaSaFilteringOpParam mseaSaFiltering, NetconfSession session, DatastoreId ncDs) throws NetconfException {
    ModelObjectData moQuery = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaSaFiltering.sourceIpaddressFiltering()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    for (SourceAddressRange sar : mseaSaFiltering.sourceIpaddressFiltering().interfaceEth0().sourceAddressRange()) {
        String sarRangeIdStr = String.valueOf(sar.rangeId());
        ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema("source-ipaddress-filtering", MSEA_SA_FILTERING_NS).addBranchPointSchema("interface-eth0", MSEA_SA_FILTERING_NS).addBranchPointSchema("source-address-range", MSEA_SA_FILTERING_NS).addKeyLeaf("range-id", MSEA_SA_FILTERING_NS, sarRangeIdStr);
        AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
        anis.add(ani);
    }
    return setNetconfObject(moQuery, session, ncDs, anis);
}
#method_after
@Override
public boolean deleteMseaSaFilteringRange(MseaSaFilteringOpParam mseaSaFiltering, NetconfSession session, DatastoreId ncDs) throws NetconfException {
    ModelObjectData moQuery = DefaultModelObjectData.builder().addModelObject((ModelObject) mseaSaFiltering.sourceIpaddressFiltering()).build();
    ArrayList anis = new ArrayList<AnnotatedNodeInfo>();
    if (mseaSaFiltering.sourceIpaddressFiltering().interfaceEth0() != null && mseaSaFiltering.sourceIpaddressFiltering().interfaceEth0().sourceAddressRange() != null) {
        for (SourceAddressRange sar : mseaSaFiltering.sourceIpaddressFiltering().interfaceEth0().sourceAddressRange()) {
            String sarRangeIdStr = String.valueOf(sar.rangeId());
            ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema("source-ipaddress-filtering", MSEA_SA_FILTERING_NS).addBranchPointSchema("interface-eth0", MSEA_SA_FILTERING_NS).addBranchPointSchema("source-address-range", MSEA_SA_FILTERING_NS).addKeyLeaf("range-id", MSEA_SA_FILTERING_NS, sarRangeIdStr);
            AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
            anis.add(ani);
        }
    } else {
        // Delete all
        ResourceId.Builder ridBuilder = ResourceId.builder().addBranchPointSchema("/", null).addBranchPointSchema("source-ipaddress-filtering", MSEA_SA_FILTERING_NS);
        AnnotatedNodeInfo ani = DefaultAnnotatedNodeInfo.builder().resourceId(ridBuilder.build()).addAnnotation(new DefaultAnnotation(NC_OPERATION, OP_DELETE)).build();
        anis.add(ani);
    }
    return setNetconfObject(moQuery, session, ncDs, anis);
}
#end_block

#method_before
// @Override
// public void addListener(MseaCfmEventListener listener) {
// throw new UnsupportedOperationException("Not yet implemented");
// }
// 
// @Override
// public void removeListener(MseaCfmEventListener listener) {
// throw new UnsupportedOperationException("Not yet implemented");
// }
private String buildMepQueryString(String mdName, String maName, int mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdName + "</name>\n");
    rpc.append("<md-level/>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maName + "</name>\n");
    // rpc.append("<ccm-interval>10ms</ccm-interval>\n"); //Have to omit for the moment - YMS problem
    rpc.append("<remote-meps/>\n");
    rpc.append("<component-list/>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId + "</mep-identifier>\n");
    rpc.append("<interface/>\n");
    rpc.append("<primary-vid/>\n");
    rpc.append("<administrative-state/>\n");
    rpc.append("<ccm-ltm-priority/>\n");
    rpc.append("<continuity-check/>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<msea-soam-fm:port-status/>\n");
    rpc.append("<msea-soam-fm:interface-status/>\n");
    // rpc.append("<msea-soam-fm:last-defect-sent/>\n");//Have to omit for the moment - YMS problem
    rpc.append("<msea-soam-fm:rdi-transmit-status/>\n");
    rpc.append("<loopback/>\n");
    rpc.append("<remote-mep-database/>\n");
    rpc.append("<linktrace/>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#method_after
private String buildMepQueryString(String mdName, String maName, int mepId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdName + "</name>\n");
    rpc.append("<md-level/>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maName + "</name>\n");
    rpc.append("<ccm-interval>10ms</ccm-interval>\n");
    rpc.append("<remote-meps/>\n");
    rpc.append("<component-list/>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId + "</mep-identifier>\n");
    rpc.append("<interface/>\n");
    rpc.append("<primary-vid/>\n");
    rpc.append("<administrative-state/>\n");
    rpc.append("<ccm-ltm-priority/>\n");
    rpc.append("<continuity-check/>\n");
    rpc.append("<mac-address/>\n");
    rpc.append("<msea-soam-fm:port-status/>\n");
    rpc.append("<msea-soam-fm:interface-status/>\n");
    rpc.append("<msea-soam-fm:last-defect-sent/>\n");
    rpc.append("<msea-soam-fm:rdi-transmit-status/>\n");
    rpc.append("<loopback/>\n");
    rpc.append("<remote-mep-database/>\n");
    rpc.append("<linktrace/>\n");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#end_block

#method_before
private String buildDmQueryString(String mdName, String maName, int mepId, int dmId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdName + "</name>\n");
    rpc.append("<md-level/>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maName + "</name>\n");
    // rpc.append("<ccm-interval>10ms</ccm-interval>\n"); //Have to omit for the moment - YMS problem
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId + "</mep-identifier>\n");
    rpc.append("<msea-soam-pm:delay-measurements>");
    rpc.append("<msea-soam-pm:delay-measurement>");
    rpc.append("<msea-soam-pm:dm-id>" + dmId + "</msea-soam-pm:dm-id>");
    rpc.append("</msea-soam-pm:delay-measurement>");
    rpc.append("</msea-soam-pm:delay-measurements>");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#method_after
private String buildDmQueryString(String mdName, String maName, int mepId, int dmId) {
    StringBuilder rpc = new StringBuilder();
    rpc.append("<mef-cfm xmlns=\"http://www.microsemi.com/microsemi-edge-assure/msea-cfm\" ");
    rpc.append(" xmlns:msea-soam-fm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-fm\" ");
    rpc.append("xmlns:msea-soam-pm=\"http://www.microsemi.com/microsemi-edge-assure/msea-soam-pm\">\n");
    rpc.append("<maintenance-domain>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + mdName + "</name>\n");
    rpc.append("<md-level/>\n");
    rpc.append("<maintenance-association>\n");
    rpc.append("<id/>\n");
    rpc.append("<name>" + maName + "</name>\n");
    rpc.append("<ccm-interval>10ms</ccm-interval>\n");
    rpc.append("<maintenance-association-end-point>\n");
    rpc.append("<mep-identifier>" + mepId + "</mep-identifier>\n");
    rpc.append("<msea-soam-pm:delay-measurements>");
    rpc.append("<msea-soam-pm:delay-measurement>");
    rpc.append("<msea-soam-pm:dm-id>" + dmId + "</msea-soam-pm:dm-id>");
    rpc.append("</msea-soam-pm:delay-measurement>");
    rpc.append("</msea-soam-pm:delay-measurements>");
    rpc.append("</maintenance-association-end-point>\n");
    rpc.append("</maintenance-association>\n");
    rpc.append("</maintenance-domain>\n");
    rpc.append("</mef-cfm>");
    return rpc.toString();
}
#end_block

#method_before
private static Map<YangModuleId, AppModuleInfo> getAppInfo() {
    Map<YangModuleId, AppModuleInfo> appInfo = new HashMap<>();
    appInfo.put(new DefaultYangModuleId("IetfSystem.class", "2014-08-06"), new DefaultAppModuleInfo(IetfSystem.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-system", "2014-08-06"), new DefaultAppModuleInfo(IetfSystem.class, null));
    return ImmutableMap.copyOf(appInfo);
}
#method_after
private static Map<YangModuleId, AppModuleInfo> getAppInfo() {
    Map<YangModuleId, AppModuleInfo> appInfo = new HashMap<>();
    appInfo.put(new DefaultYangModuleId("fpga-internal", "2015-11-30"), new DefaultAppModuleInfo(FpgaInternal.class, null));
    appInfo.put(new DefaultYangModuleId("iana-if-type", "2014-05-08"), new DefaultAppModuleInfo(IanaIfType.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-yang-types", "2013-07-15"), new DefaultAppModuleInfo(IetfYangTypes.class, null));
    appInfo.put(new DefaultYangModuleId("msea-sa-filtering", "2016-04-12"), new DefaultAppModuleInfo(MseaSaFiltering.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-x509-cert-to-name", "2013-03-26"), new DefaultAppModuleInfo(IetfX509CertToName.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-system", "2014-08-06"), new DefaultAppModuleInfo(IetfSystem.class, null));
    appInfo.put(new DefaultYangModuleId("msea-types", "2016-02-29"), new DefaultAppModuleInfo(MseaTypes.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-inet-types", "2013-07-15"), new DefaultAppModuleInfo(IetfInetTypes.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-netconf-with-defaults", "2010-06-09"), new DefaultAppModuleInfo(IetfNetconfWithDefaults.class, null));
    appInfo.put(new DefaultYangModuleId("msea-uni-evc-service", "2016-03-17"), new DefaultAppModuleInfo(MseaUniEvcService.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-netconf-monitoring", "2010-10-04"), new DefaultAppModuleInfo(IetfNetconfMonitoring.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-netconf-acm", "2012-02-22"), new DefaultAppModuleInfo(IetfNetconfAcm.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-system-tls-auth", "2014-05-24"), new DefaultAppModuleInfo(IetfSystemTlsAuth.class, null));
    appInfo.put(new DefaultYangModuleId("rfc-2544", "2015-10-20"), new DefaultAppModuleInfo(Rfc2544.class, null));
    appInfo.put(new DefaultYangModuleId("msea-cfm", "2016-02-29"), new DefaultAppModuleInfo(MseaCfm.class, null));
    appInfo.put(new DefaultYangModuleId("netopeer-cfgnetopeer", "2013-02-14"), new DefaultAppModuleInfo(NetopeerCfgnetopeer.class, null));
    appInfo.put(new DefaultYangModuleId("ENTITY-STATE-TC-MIB", "2005-11-22"), new DefaultAppModuleInfo(EntityStateTcMib.class, null));
    appInfo.put(new DefaultYangModuleId("msea-soam-fm", "2016-02-29"), new DefaultAppModuleInfo(MseaSoamFm.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-netconf-notifications", "2012-02-06"), new DefaultAppModuleInfo(IetfNetconfNotifications.class, null));
    appInfo.put(new DefaultYangModuleId("nc-notifications", "2008-07-14"), new DefaultAppModuleInfo(NcNotifications.class, null));
    appInfo.put(new DefaultYangModuleId("iana-crypt-hash", "2014-08-06"), new DefaultAppModuleInfo(IanaCryptHash.class, null));
    appInfo.put(new DefaultYangModuleId("msea-uni-evc-interface", "2016-03-17"), new DefaultAppModuleInfo(MseaUniEvcInterface.class, null));
    appInfo.put(new DefaultYangModuleId("msea-soam-pm", "2016-02-29"), new DefaultAppModuleInfo(MseaSoamPm.class, null));
    appInfo.put(new DefaultYangModuleId("ieee-types", "2008-05-22"), new DefaultAppModuleInfo(IeeeTypes.class, null));
    appInfo.put(new DefaultYangModuleId("svc-activation-types", "2015-10-27"), new DefaultAppModuleInfo(SvcActivationTypes.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-netconf", "2011-06-01"), new DefaultAppModuleInfo(IetfNetconf.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-system-microsemi", "2016-05-05"), new DefaultAppModuleInfo(IetfSystemMicrosemi.class, null));
    appInfo.put(new DefaultYangModuleId("notifications", "2008-07-14"), new DefaultAppModuleInfo(Notifications.class, null));
    appInfo.put(new DefaultYangModuleId("y-1564", "2015-10-29"), new DefaultAppModuleInfo(Y1564.class, null));
    appInfo.put(new DefaultYangModuleId("ietf-interfaces", "2014-05-08"), new DefaultAppModuleInfo(IetfInterfaces.class, null));
    return ImmutableMap.copyOf(appInfo);
}
#end_block

#method_before
@Override
public void performMeterOperation(DeviceId deviceId, MeterOperation meterOp) {
    if (meterOp == null || deviceId == null) {
        log.warn("Missing argument for performMeterOperation()");
        return;
    }
    log.debug("{} meterOp {} to Microsemi Meter Store", meterOp.type(), meterOp);
    long meterId = meterOp.meter().id().id();
    String deviceName = deviceId.uri().getSchemeSpecificPart();
    Unit unit = meterOp.meter().unit();
    Profiles profiles = new DefaultProfiles();
    if (meterOp.type() == MeterOperation.Type.ADD || meterOp.type() == MeterOperation.Type.MODIFY) {
        Bwp bwp = new DefaultBwp();
        bwp.cosIndex(COS_INDEX_1);
        bwp.name("BWP-" + String.valueOf(meterId) + "-" + deviceName);
        long cirRateKbps = 0L;
        long cbsRateKbps = 0L;
        long eirRateKbps = 0L;
        long ebsRateKbps = 0L;
        for (Band band : meterOp.meter().bands()) {
            if (band.type() == Band.Type.REMARK) {
                // This relates to CIR/CBS
                cirRateKbps = toBitsPerSec(band.rate(), unit);
                // Already in kbps
                cbsRateKbps = band.burst();
            } else if (band.type() == Band.Type.DROP) {
                // This relates to EIR/EBS
                eirRateKbps = toBitsPerSec(band.rate(), unit);
                // Already in kbps
                ebsRateKbps = band.burst();
            }
        }
        bwp.committedInformationRate(cirRateKbps);
        bwp.excessInformationRate(eirRateKbps - cirRateKbps);
        if (meterOp.meter().isBurst()) {
            bwp.committedBurstSize(cbsRateKbps);
            bwp.excessBurstSize(ebsRateKbps - cbsRateKbps);
        }
        BwpGroup bwpg = new DefaultBwpGroup();
        bwpg.groupIndex((short) meterId);
        bwpg.addToBwp(bwp);
        // Create cos-1 as referenced above - we only support 1 at the moment
        Cos cos = new DefaultCos();
        cos.cosIndex(COS_INDEX_1);
        cos.name("COS-1");
        cos.outgoingCosValue(PriorityType.of(DEFAULT_OUTGOING_PRIO));
        cos.colorAware(true);
        cos.colorForward(true);
        EvcCosTypeAll8PrioTo1EvcColor ect = new DefaultEvcCosTypeAll8PrioTo1EvcColor();
        ect.evcAll8ColorTo(CosColorType.of(CosColorTypeEnum.GREEN));
        profiles.addToBwpGroup(bwpg);
        EvcCosTypeEvcColorId cid = new DefaultEvcCosTypeEvcColorId();
        cid.evcCosTypeAll8PrioTo1EvcColor(ect);
        cos.cosTypeChoice(cid);
        profiles.addToCos(cos);
    } else if (meterOp.type() == MeterOperation.Type.REMOVE) {
        BwpGroup bwpg = new DefaultBwpGroup();
        bwpg.groupIndex((short) meterId);
        profiles.addToBwpGroup(bwpg);
    }
    MefServices mefServices = new DefaultMefServices();
    mefServices.profiles(profiles);
    MseaUniEvcServiceOpParam mseaUniEvcServiceFilter = new MseaUniEvcServiceOpParam();
    mseaUniEvcServiceFilter.mefServices(mefServices);
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        if (meterOp.type() == MeterOperation.Type.REMOVE) {
            mseaUniEvcServiceSvc.deleteMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        } else {
            mseaUniEvcServiceSvc.setMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        }
    } catch (NetconfException e) {
        // This can fail if the BWP Group is deleted before the EVC that is dependent on it
        // The delete of the EVC will be called on a separate thread to that should proceed
        // within a few seconds after which we should try again
        AtomicInteger retry = new AtomicInteger(4);
        if (meterOp.type() == MeterOperation.Type.REMOVE && e.getMessage().startsWith("Failed to run edit-config through NETCONF")) {
            while (retry.getAndDecrement() > 0) {
                try {
                    Thread.sleep(1000L);
                    log.debug("Retrying deletion of Bandwith Profile Group {}", String.valueOf(meterId));
                    mseaUniEvcServiceSvc.setMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
                    // If it did not throw an exception
                    return;
                } catch (InterruptedException e1) {
                    // TODO Auto-generated catch block
                    e1.printStackTrace();
                } catch (NetconfException e1) {
                    log.debug("NETCONF failed to delete profile - trying again in 1 sec");
                    e1.printStackTrace();
                }
            }
            log.error("Error deleting BWPGroup {} from {} after 4 tries: {}", meterId, deviceId, e.getMessage());
        } else {
            log.error("Error adding BWPGroup {} from {}: {}", meterId, deviceId, e.getMessage());
            throw new UnsupportedOperationException(e);
        }
        e.printStackTrace();
    }
}
#method_after
@Override
public void performMeterOperation(DeviceId deviceId, MeterOperation meterOp) {
    if (meterOp == null || deviceId == null) {
        log.warn("Missing argument for performMeterOperation()");
        return;
    }
    log.debug("{} meterOp {} to Microsemi Meter Store", meterOp.type(), meterOp);
    long meterId = meterOp.meter().id().id();
    String deviceName = deviceId.uri().getSchemeSpecificPart();
    Unit unit = meterOp.meter().unit();
    Profiles profiles = new DefaultProfiles();
    if (meterOp.type() == MeterOperation.Type.ADD || meterOp.type() == MeterOperation.Type.MODIFY) {
        Bwp bwp = new DefaultBwp();
        bwp.cosIndex(COS_INDEX_1);
        bwp.name("BWP-" + String.valueOf(meterId) + "-" + deviceName);
        long cirRateKbps = 0L;
        long cbsRateKbps = 0L;
        long eirRateKbps = 0L;
        long ebsRateKbps = 0L;
        for (Band band : meterOp.meter().bands()) {
            if (band.type() == Band.Type.REMARK) {
                // This relates to CIR/CBS
                cirRateKbps = toBitsPerSec(band.rate(), unit);
                // Already in kbps
                cbsRateKbps = band.burst();
            } else if (band.type() == Band.Type.DROP) {
                // This relates to EIR/EBS
                eirRateKbps = toBitsPerSec(band.rate(), unit);
                // Already in kbps
                ebsRateKbps = band.burst();
            }
        }
        bwp.committedInformationRate(cirRateKbps);
        bwp.excessInformationRate(eirRateKbps - cirRateKbps);
        if (meterOp.meter().isBurst()) {
            bwp.committedBurstSize(cbsRateKbps);
            bwp.excessBurstSize(ebsRateKbps - cbsRateKbps);
        }
        BwpGroup bwpg = new DefaultBwpGroup();
        bwpg.groupIndex((short) meterId);
        bwpg.addToBwp(bwp);
        // Create cos-1 as referenced above - we only support 1 at the moment
        Cos cos = new DefaultCos();
        cos.cosIndex(COS_INDEX_1);
        cos.name("COS-1");
        cos.outgoingCosValue(PriorityType.of(DEFAULT_OUTGOING_PRIO));
        cos.colorAware(true);
        cos.colorForward(true);
        EvcCosTypeAll8PrioTo1EvcColor ect = new DefaultEvcCosTypeAll8PrioTo1EvcColor();
        ect.evcAll8ColorTo(CosColorType.of(CosColorTypeEnum.GREEN));
        profiles.addToBwpGroup(bwpg);
        EvcCosTypeEvcColorId cid = new DefaultEvcCosTypeEvcColorId();
        cid.evcCosTypeAll8PrioTo1EvcColor(ect);
        cos.cosTypeChoice(cid);
        profiles.addToCos(cos);
    } else if (meterOp.type() == MeterOperation.Type.REMOVE) {
        BwpGroup bwpg = new DefaultBwpGroup();
        bwpg.groupIndex((short) meterId);
        profiles.addToBwpGroup(bwpg);
    }
    MefServices mefServices = new DefaultMefServices();
    mefServices.profiles(profiles);
    MseaUniEvcServiceOpParam mseaUniEvcServiceFilter = new MseaUniEvcServiceOpParam();
    mseaUniEvcServiceFilter.mefServices(mefServices);
    NetconfSession session = controller.getDevicesMap().get(deviceId).getSession();
    try {
        if (meterOp.type() == MeterOperation.Type.REMOVE) {
            mseaUniEvcServiceSvc.deleteMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        } else {
            mseaUniEvcServiceSvc.setMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        }
    } catch (NetconfException e) {
        // This can fail if the BWP Group is deleted before the EVC that is dependent on it
        // The delete of the EVC will be called on a separate thread to that should proceed
        // within a few seconds after which we should try again
        AtomicInteger retry = new AtomicInteger(4);
        if (meterOp.type() == MeterOperation.Type.REMOVE && e.getMessage().startsWith("Failed to run edit-config through NETCONF")) {
            while (retry.getAndDecrement() > 0) {
                try {
                    Thread.sleep(1000L);
                    log.debug("Retrying deletion of Bandwith Profile Group {}", String.valueOf(meterId));
                    mseaUniEvcServiceSvc.setMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
                    // If it did not throw an exception
                    return;
                } catch (InterruptedException e1) {
                    log.debug("Error when deleting BWP profile on EA1000" + " - trying again in 1 sec", e1);
                } catch (NetconfException e1) {
                    log.debug("NETCONF failed to delete profile - trying again in 1 sec", e1);
                }
            }
            log.error("Error deleting BWPGroup {} from {} after 4 tries: {}", meterId, deviceId, e.getMessage());
        } else {
            log.error("Error adding BWPGroup {} from {}: {}", meterId, deviceId, e.getMessage());
            throw new UnsupportedOperationException(e);
        }
    }
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(MSEA_UNI_EVC_SVC);
    log.info("MseaUniEvcServiceManager Started");
}
#method_after
@Activate
public void activate() {
    super.activate();
    appId = coreService.registerApplication(MSEA_UNI_EVC_SVC);
    log.info("MseaUniEvcServiceManager Started");
}
#end_block

#method_before
@Override
public Collection<FlowEntry> getFlowEntries() {
    Collection<FlowEntry> flowEntryCollection = new HashSet<FlowEntry>();
    UniSideInterfaceAssignmentEnum portAssignment = UniSideInterfaceAssignmentEnum.UNI_C_ON_HOST;
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    CoreService coreService = checkNotNull(handler().get(CoreService.class));
    ApplicationId appId = coreService.getAppId(MICROSEMI_DRIVERS);
    MseaSaFilteringNetconfService mseaSaFilteringService = (MseaSaFilteringNetconfService) checkNotNull(handler().get(MseaSaFilteringNetconfService.class));
    MseaUniEvcServiceNetconfService mseaUniEvcServiceSvc = (MseaUniEvcServiceNetconfService) checkNotNull(handler().get(MseaUniEvcServiceNetconfService.class));
    log.debug("getFlowEntries() called on EA1000FlowRuleProgrammable");
    // First get the MseaSaFiltering rules
    SourceIpaddressFiltering sip = new DefaultSourceIpaddressFiltering();
    MseaSaFilteringOpParam op = new MseaSaFilteringOpParam();
    op.sourceIpaddressFiltering(sip);
    try {
        MseaSaFiltering saFilteringCurrent = mseaSaFilteringService.getMseaSaFiltering(op, session);
        if (saFilteringCurrent != null) {
            flowEntryCollection.addAll(convertSaFilteringToFlowRules(saFilteringCurrent, appId));
        }
    } catch (NetconfException e) {
        log.warn("Unexpected error on getFlowEntries", e);
    }
    // Then get the EVCs - there will be a flow entry per EVC
    MefServices mefServices = new DefaultMefServices();
    mefServices.uni(new DefaultUni());
    MseaUniEvcServiceOpParam mseaUniEvcServiceFilter = new MseaUniEvcServiceOpParam();
    mseaUniEvcServiceFilter.mefServices(mefServices);
    try {
        MseaUniEvcService uniEvcCurrent = mseaUniEvcServiceSvc.getConfigMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        flowEntryCollection.addAll(convertEvcUniToFlowRules(uniEvcCurrent, portAssignment));
    } catch (NetconfException e) {
        log.warn("Unexpected error on getFlowEntries", e);
    }
    return flowEntryCollection;
}
#method_after
@Override
public Collection<FlowEntry> getFlowEntries() {
    Collection<FlowEntry> flowEntryCollection = new HashSet<FlowEntry>();
    UniSideInterfaceAssignmentEnum portAssignment = UniSideInterfaceAssignmentEnum.UNI_C_ON_HOST;
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfDevice ncDevice = controller.getDevicesMap().get(handler().data().deviceId());
    if (ncDevice == null) {
        log.error("Internal ONOS Error. Device has been marked as reachable, " + "but deviceID {} is not in Devices Map. Continuing with empty description", handler().data().deviceId());
        return flowEntryCollection;
    }
    NetconfSession session = ncDevice.getSession();
    CoreService coreService = checkNotNull(handler().get(CoreService.class));
    ApplicationId appId = coreService.getAppId(MICROSEMI_DRIVERS);
    MseaSaFilteringNetconfService mseaSaFilteringService = (MseaSaFilteringNetconfService) checkNotNull(handler().get(MseaSaFilteringNetconfService.class));
    MseaUniEvcServiceNetconfService mseaUniEvcServiceSvc = (MseaUniEvcServiceNetconfService) checkNotNull(handler().get(MseaUniEvcServiceNetconfService.class));
    log.debug("getFlowEntries() called on EA1000FlowRuleProgrammable");
    // First get the MseaSaFiltering rules
    SourceIpaddressFiltering sip = new DefaultSourceIpaddressFiltering();
    MseaSaFilteringOpParam op = new MseaSaFilteringOpParam();
    op.sourceIpaddressFiltering(sip);
    try {
        MseaSaFiltering saFilteringCurrent = mseaSaFilteringService.getMseaSaFiltering(op, session);
        if (saFilteringCurrent != null && saFilteringCurrent.sourceIpaddressFiltering() != null) {
            flowEntryCollection.addAll(convertSaFilteringToFlowRules(saFilteringCurrent, appId));
        }
    } catch (NetconfException e) {
        if (e.getCause() instanceof TimeoutException) {
            log.warn("Timeout exception getting SA Filt Flow Entries from {}", handler().data().deviceId());
            return flowEntryCollection;
        } else {
            log.error("Unexpected error on SA Filt getFlowEntries on {}", handler().data().deviceId(), e);
        }
    }
    // Then get the EVCs - there will be a flow entry per EVC
    MefServices mefServices = new DefaultMefServices();
    mefServices.uni(new DefaultUni());
    MseaUniEvcServiceOpParam mseaUniEvcServiceFilter = new MseaUniEvcServiceOpParam();
    mseaUniEvcServiceFilter.mefServices(mefServices);
    try {
        MseaUniEvcService uniEvcCurrent = mseaUniEvcServiceSvc.getConfigMseaUniEvcService(mseaUniEvcServiceFilter, session, DatastoreId.RUNNING);
        flowEntryCollection.addAll(convertEvcUniToFlowRules(uniEvcCurrent, portAssignment));
    } catch (NetconfException e) {
        if (e.getCause() instanceof TimeoutException) {
            log.warn("Timeout exception getting EVC Flow Entries from {}", handler().data().deviceId());
            return flowEntryCollection;
        } else {
            log.error("Unexpected error on EVC getFlowEntries on {}", handler().data().deviceId(), e);
        }
    }
    return flowEntryCollection;
}
#end_block

#method_before
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rulesToRemove) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    MseaSaFilteringNetconfService mseaSaFilteringService = (MseaSaFilteringNetconfService) checkNotNull(handler().get(MseaSaFilteringNetconfService.class));
    MseaUniEvcServiceNetconfService mseaUniEvcServiceSvc = (MseaUniEvcServiceNetconfService) checkNotNull(handler().get(MseaUniEvcServiceNetconfService.class));
    UniSideInterfaceAssignmentEnum portAssignment = UniSideInterfaceAssignmentEnum.UNI_C_ON_HOST;
    log.debug("removeFlowRules() called on EA1000FlowRuleProgrammable with {} rules.", rulesToRemove.size());
    if (rulesToRemove.size() == 0) {
        return rulesToRemove;
    }
    // Retrieve the list of actual EVCs and the CeVlanMaps from device
    List<Evc> activeEvcs = new ArrayList<>();
    try {
        sessionMutex.acquire();
        MseaUniEvcService evcResponse = mseaUniEvcServiceSvc.getmseaUniEvcCeVlanMaps(session, DatastoreId.RUNNING);
        // There could be zero or more EVCs
        if (evcResponse != null && evcResponse.mefServices() != null && evcResponse.mefServices().uni() != null) {
            activeEvcs.addAll(evcResponse.mefServices().uni().evc());
        }
    } catch (NetconfException | InterruptedException e1) {
        log.warn("Error on removeFlowRules.", e1);
    }
    List<SourceAddressRange> saRangeList = new ArrayList<SourceAddressRange>();
    Map<Integer, String> ceVlanMapMap = new HashMap<>();
    Map<Integer, List<Short>> flowIdMap = new HashMap<>();
    Collection<FlowRule> rulesRemoved = new HashSet<FlowRule>();
    for (FlowRule ruleToRemove : rulesToRemove) {
        // IP SA Filtering can only apply to Port 0 optics
        if (ruleToRemove.selector().getCriterion(Type.IPV4_SRC) != null && ruleToRemove.selector().getCriterion(Type.IN_PORT) != null && ((PortCriterion) ruleToRemove.selector().getCriterion(Type.IN_PORT)).port().toLong() == 0) {
            SourceAddressRange sar = new DefaultSourceAddressRange();
            sar.rangeId((short) ruleToRemove.tableId());
            rulesRemoved.add(ruleToRemove);
            saRangeList.add(sar);
        } else if (ruleToRemove.selector().getCriterion(Type.VLAN_VID) != null && ruleToRemove.selector().getCriterion(Type.IN_PORT) != null) {
            PortNumber portNumber = ((PortCriterion) ruleToRemove.selector().getCriterion(Type.IN_PORT)).port();
            VlanId vlanId = ((VlanIdCriterion) ruleToRemove.selector().getCriterion(Type.VLAN_VID)).vlanId();
            int evcId = ruleToRemove.tableId();
            int evcKey = (evcId << 2) + (int) portNumber.toLong();
            String activeCeVlanMap = "";
            // from the ceVlanMap and not the whole EVC
            if (!ceVlanMapMap.containsKey(evcKey)) {
                for (Evc activeEvc : activeEvcs) {
                    if (activeEvc.evcIndex() == evcId) {
                        if (Ea1000Port.fromNum(portNumber.toLong()).nOrC(portAssignment) == UniSide.CUSTOMER) {
                            activeCeVlanMap = activeEvc.evcPerUni().evcPerUnic().ceVlanMap().string();
                        } else if (Ea1000Port.fromNum(portNumber.toLong()).nOrC(portAssignment) == UniSide.NETWORK) {
                            activeCeVlanMap = activeEvc.evcPerUni().evcPerUnin().ceVlanMap().string();
                        }
                    }
                }
            }
            ceVlanMapMap.put(evcKey, CeVlanMapUtils.removeFromCeVlanMap(activeCeVlanMap, vlanId.id()));
            if (!flowIdMap.containsKey(evcKey)) {
                flowIdMap.put(evcKey, new ArrayList<>());
            }
            flowIdMap.get(evcKey).add(vlanId.id());
            rulesRemoved.add(ruleToRemove);
        } else {
            log.info("Unexpected Flow Rule type removal: " + ruleToRemove);
        }
    }
    // MseaSaFiltering service
    if (saRangeList.size() > 0) {
        try {
            mseaSaFilteringService.deleteMseaSaFilteringRange(buildSaFilteringObject(saRangeList), session, DatastoreId.RUNNING);
        } catch (NetconfException e) {
            log.warn("Remove FlowRule on MseaSaFilteringService could not delete SARule - " + "it may already have been deleted: " + e.getMessage());
        }
    }
    if (ceVlanMapMap.size() > 0) {
        try {
            mseaUniEvcServiceSvc.removeEvcUniFlowEntries(ceVlanMapMap, flowIdMap, session, DatastoreId.RUNNING, portAssignment);
        } catch (NetconfException e) {
            log.warn("Remove FlowRule on MseaUniEvcService could not delete EVC - " + "it may already have been deleted: " + e.getMessage());
        }
    }
    sessionMutex.release();
    return rulesRemoved;
}
#method_after
@Override
public Collection<FlowRule> removeFlowRules(Collection<FlowRule> rulesToRemove) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    MseaSaFilteringNetconfService mseaSaFilteringService = (MseaSaFilteringNetconfService) checkNotNull(handler().get(MseaSaFilteringNetconfService.class));
    MseaUniEvcServiceNetconfService mseaUniEvcServiceSvc = (MseaUniEvcServiceNetconfService) checkNotNull(handler().get(MseaUniEvcServiceNetconfService.class));
    UniSideInterfaceAssignmentEnum portAssignment = UniSideInterfaceAssignmentEnum.UNI_C_ON_HOST;
    log.debug("removeFlowRules() called on EA1000FlowRuleProgrammable with {} rules.", rulesToRemove.size());
    if (rulesToRemove.size() == 0) {
        return rulesToRemove;
    }
    // Retrieve the list of actual EVCs and the CeVlanMaps from device
    List<Evc> activeEvcs = new ArrayList<>();
    List<Short> acvtiveFiltRanges = new ArrayList<>();
    try {
        sessionMutex.acquire();
        MseaUniEvcService evcResponse = mseaUniEvcServiceSvc.getmseaUniEvcCeVlanMaps(session, DatastoreId.RUNNING);
        // There could be zero or more EVCs
        if (evcResponse != null && evcResponse.mefServices() != null && evcResponse.mefServices().uni() != null) {
            activeEvcs.addAll(evcResponse.mefServices().uni().evc());
        }
        mseaSaFilteringService.getConfigMseaSaFilterIds(session).forEach(r -> acvtiveFiltRanges.add(r.rangeId()));
    } catch (NetconfException | InterruptedException e1) {
        log.warn("Error on removeFlowRules.", e1);
    }
    List<SourceAddressRange> saRangeList = new ArrayList<SourceAddressRange>();
    Map<Integer, String> ceVlanMapMap = new HashMap<>();
    Map<Integer, List<Short>> flowIdMap = new HashMap<>();
    Collection<FlowRule> rulesRemoved = new HashSet<FlowRule>();
    for (FlowRule ruleToRemove : rulesToRemove) {
        // IP SA Filtering can only apply to Port 0 optics
        if (ruleToRemove.selector().getCriterion(Type.IPV4_SRC) != null && ruleToRemove.selector().getCriterion(Type.IN_PORT) != null && ((PortCriterion) ruleToRemove.selector().getCriterion(Type.IN_PORT)).port().toLong() == 0) {
            SourceAddressRange sar = new DefaultSourceAddressRange();
            sar.rangeId((short) ruleToRemove.tableId());
            acvtiveFiltRanges.remove(Short.valueOf((short) ruleToRemove.tableId()));
            rulesRemoved.add(ruleToRemove);
            saRangeList.add(sar);
        } else if (ruleToRemove.selector().getCriterion(Type.VLAN_VID) != null && ruleToRemove.selector().getCriterion(Type.IN_PORT) != null) {
            PortNumber portNumber = ((PortCriterion) ruleToRemove.selector().getCriterion(Type.IN_PORT)).port();
            VlanId vlanId = ((VlanIdCriterion) ruleToRemove.selector().getCriterion(Type.VLAN_VID)).vlanId();
            int evcId = ruleToRemove.tableId();
            int evcKey = (evcId << 2) + (int) portNumber.toLong();
            String activeCeVlanMap = "";
            // from the ceVlanMap and not the whole EVC
            if (!ceVlanMapMap.containsKey(evcKey)) {
                for (Evc activeEvc : activeEvcs) {
                    if (activeEvc.evcIndex() == evcId) {
                        if (Ea1000Port.fromNum(portNumber.toLong()).nOrC(portAssignment) == UniSide.CUSTOMER) {
                            activeCeVlanMap = activeEvc.evcPerUni().evcPerUnic().ceVlanMap().string();
                        } else if (Ea1000Port.fromNum(portNumber.toLong()).nOrC(portAssignment) == UniSide.NETWORK) {
                            activeCeVlanMap = activeEvc.evcPerUni().evcPerUnin().ceVlanMap().string();
                        }
                    }
                }
            }
            ceVlanMapMap.put(evcKey, CeVlanMapUtils.removeFromCeVlanMap(activeCeVlanMap, vlanId.id()));
            if (!flowIdMap.containsKey(evcKey)) {
                flowIdMap.put(evcKey, new ArrayList<>());
            }
            flowIdMap.get(evcKey).add(vlanId.id());
            rulesRemoved.add(ruleToRemove);
        } else {
            log.info("Unexpected Flow Rule type removal: " + ruleToRemove);
        }
    }
    // MseaSaFiltering service
    if (saRangeList.size() > 0 && acvtiveFiltRanges.size() == 0) {
        try {
            SourceIpaddressFiltering saFilter = new DefaultSourceIpaddressFiltering();
            MseaSaFilteringOpParam mseaSaFiltering = new MseaSaFilteringOpParam();
            mseaSaFiltering.sourceIpaddressFiltering(saFilter);
            mseaSaFilteringService.deleteMseaSaFilteringRange(mseaSaFiltering, session, DatastoreId.RUNNING);
        } catch (NetconfException e) {
            log.warn("Remove FlowRule on MseaSaFilteringService could not delete all SARules - " + "they may already have been deleted: " + e.getMessage());
        }
    } else if (saRangeList.size() > 0) {
        try {
            mseaSaFilteringService.deleteMseaSaFilteringRange(buildSaFilteringObject(saRangeList), session, DatastoreId.RUNNING);
        } catch (NetconfException e) {
            log.warn("Remove FlowRule on MseaSaFilteringService could not delete SARule - " + "it may already have been deleted: " + e.getMessage());
        }
    }
    if (ceVlanMapMap.size() > 0) {
        try {
            mseaUniEvcServiceSvc.removeEvcUniFlowEntries(ceVlanMapMap, flowIdMap, session, DatastoreId.RUNNING, portAssignment);
        } catch (NetconfException e) {
            log.warn("Remove FlowRule on MseaUniEvcService could not delete EVC - " + "it may already have been deleted: " + e.getMessage());
        }
    }
    sessionMutex.release();
    return rulesRemoved;
}
#end_block

#method_before
private void parseFrForEvcs(Collection<FlowRule> frList, Map<Integer, Evc> evcMap, List<Evc> activeEvcs, UniSideInterfaceAssignmentEnum portAssignment, FlowRule fr) {
    // There could be many Flow Rules for one EVC depending on the ceVlanMap
    // Cannot build up the EVC until we know the details - the key is the tableID and port
    Ea1000Port port = Ea1000Port.fromNum(((PortCriterion) fr.selector().getCriterion(Type.IN_PORT)).port().toLong());
    Integer evcKey = (fr.tableId() << 2) + port.portNum();
    VlanId sourceVid = ((VlanIdCriterion) fr.selector().getCriterion(Type.VLAN_VID)).vlanId();
    FlowMapping fm = new DefaultFlowMapping();
    fm.ceVlanId(VlanIdType.of(sourceVid.id()));
    fm.flowId(BigInteger.valueOf(fr.id().value()));
    if (evcMap.containsKey(evcKey)) {
        // Replace ceVlanMap
        if (port.nOrC(portAssignment) == UniSide.CUSTOMER) {
            evcMap.get(evcKey).evcPerUni().evcPerUnic().addToFlowMapping(fm);
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey).evcPerUni().evcPerUnic().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey).evcPerUni().evcPerUnic().ceVlanMap(newCeVlanMap);
        } else {
            evcMap.get(evcKey).evcPerUni().evcPerUnin().addToFlowMapping(fm);
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey).evcPerUni().evcPerUnin().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey).evcPerUni().evcPerUnin().ceVlanMap(newCeVlanMap);
        }
    } else if (evcMap.containsKey((evcKey ^ 1))) {
        // Is there an entry for this EVC but the opposite port?
        TagManipulation tm = getTagManipulation(fr);
        if (port.nOrC(portAssignment) == UniSide.NETWORK) {
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ceVlanMap(newCeVlanMap);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().tagManipulation(tm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().addToFlowMapping(fm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ingressBwpGroupIndex(getMeterId(fr.treatment()));
        } else {
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ceVlanMap(newCeVlanMap);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().tagManipulation(tm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().addToFlowMapping(fm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ingressBwpGroupIndex(getMeterId(fr.treatment()));
        }
    } else {
        Evc evc = new DefaultEvc();
        EvcPerUnin epun = new DefaultEvcPerUnin();
        EvcPerUnic epuc = new DefaultEvcPerUnic();
        TagManipulation tm = getTagManipulation(fr);
        UniSide side = port.nOrC(portAssignment);
        String oldCeVlanMap = getCeVlanMapForIdxFromEvcList(activeEvcs, fr.tableId(), side);
        String newCeVlanMap = CeVlanMapUtils.addtoCeVlanMap(oldCeVlanMap, sourceVid.id());
        String oppositeCeVlanMap = getCeVlanMapForIdxFromEvcList(activeEvcs, fr.tableId(), port.opposite().nOrC(portAssignment));
        oppositeCeVlanMap = oppositeCeVlanMap.isEmpty() ? "0" : oppositeCeVlanMap;
        if (side == UniSide.NETWORK) {
            epun.ceVlanMap(new ServiceListType(newCeVlanMap));
            epun.tagManipulation(tm);
            epun.addToFlowMapping(fm);
            epun.ingressBwpGroupIndex(getMeterId(fr.treatment()));
            epuc.ceVlanMap(new ServiceListType(oppositeCeVlanMap));
        } else {
            epuc.ceVlanMap(new ServiceListType(newCeVlanMap));
            epuc.tagManipulation(tm);
            epuc.addToFlowMapping(fm);
            epuc.ingressBwpGroupIndex(getMeterId(fr.treatment()));
            epun.ceVlanMap(new ServiceListType(oppositeCeVlanMap));
        }
        evc.evcIndex(fr.tableId());
        evc.name(new Identifier45("EVC-" + String.valueOf(fr.tableId())));
        DefaultEvcPerUni epu = new DefaultEvcPerUni();
        epu.evcPerUnin(epun);
        epu.evcPerUnic(epuc);
        evc.evcPerUni(epu);
        evcMap.put(evcKey, evc);
    }
    frList.add(fr);
}
#method_after
private void parseFrForEvcs(Collection<FlowRule> frList, Map<Integer, Evc> evcMap, List<Evc> activeEvcs, UniSideInterfaceAssignmentEnum portAssignment, FlowRule fr) {
    // There could be many Flow Rules for one EVC depending on the ceVlanMap
    // Cannot build up the EVC until we know the details - the key is the tableID and port
    Ea1000Port port = Ea1000Port.fromNum(((PortCriterion) fr.selector().getCriterion(Type.IN_PORT)).port().toLong());
    Integer evcKey = (fr.tableId() << 2) + port.portNum();
    VlanId sourceVid = ((VlanIdCriterion) fr.selector().getCriterion(Type.VLAN_VID)).vlanId();
    FlowMapping fm = new DefaultFlowMapping();
    fm.ceVlanId(VlanIdType.of(sourceVid.id()));
    fm.flowId(BigInteger.valueOf(fr.id().value()));
    if (evcMap.containsKey(evcKey)) {
        // Replace ceVlanMap
        if (port.nOrC(portAssignment) == UniSide.CUSTOMER) {
            evcMap.get(evcKey).evcPerUni().evcPerUnic().addToFlowMapping(fm);
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey).evcPerUni().evcPerUnic().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey).evcPerUni().evcPerUnic().ceVlanMap(newCeVlanMap);
        } else {
            evcMap.get(evcKey).evcPerUni().evcPerUnin().addToFlowMapping(fm);
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey).evcPerUni().evcPerUnin().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey).evcPerUni().evcPerUnin().ceVlanMap(newCeVlanMap);
        }
    } else if (evcMap.containsKey((evcKey ^ 1))) {
        // Is there an entry for this EVC but the opposite port?
        TagManipulation tm = getTagManipulation(fr);
        if (port.nOrC(portAssignment) == UniSide.NETWORK) {
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ceVlanMap(newCeVlanMap);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().tagManipulation(tm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().addToFlowMapping(fm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnin().ingressBwpGroupIndex(getMeterId(fr.treatment()));
        } else {
            ServiceListType newCeVlanMap = new ServiceListType(CeVlanMapUtils.addtoCeVlanMap(evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ceVlanMap().toString(), sourceVid.toShort()));
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ceVlanMap(newCeVlanMap);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().tagManipulation(tm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().addToFlowMapping(fm);
            evcMap.get(evcKey ^ 1).evcPerUni().evcPerUnic().ingressBwpGroupIndex(getMeterId(fr.treatment()));
        }
    } else {
        Evc evc = new DefaultEvc();
        EvcPerUnin epun = new CustomEvcPerUnin();
        EvcPerUnic epuc = new CustomEvcPerUnic();
        TagManipulation tm = getTagManipulation(fr);
        UniSide side = port.nOrC(portAssignment);
        String oldCeVlanMap = getCeVlanMapForIdxFromEvcList(activeEvcs, fr.tableId(), side);
        String newCeVlanMap = CeVlanMapUtils.addtoCeVlanMap(oldCeVlanMap, sourceVid.id());
        String oppositeCeVlanMap = getCeVlanMapForIdxFromEvcList(activeEvcs, fr.tableId(), port.opposite().nOrC(portAssignment));
        oppositeCeVlanMap = oppositeCeVlanMap.isEmpty() ? "0" : oppositeCeVlanMap;
        if (side == UniSide.NETWORK) {
            epun.ceVlanMap(new ServiceListType(newCeVlanMap));
            epun.tagManipulation(tm);
            epun.addToFlowMapping(fm);
            epun.ingressBwpGroupIndex(getMeterId(fr.treatment()));
            epuc.ceVlanMap(new ServiceListType(oppositeCeVlanMap));
            epuc.ingressBwpGroupIndex(new Long(0));
        } else {
            epuc.ceVlanMap(new ServiceListType(newCeVlanMap));
            epuc.tagManipulation(tm);
            epuc.addToFlowMapping(fm);
            epuc.ingressBwpGroupIndex(getMeterId(fr.treatment()));
            epun.ceVlanMap(new ServiceListType(oppositeCeVlanMap));
            epun.ingressBwpGroupIndex(new Long(0));
        }
        evc.evcIndex(fr.tableId());
        evc.name(new Identifier45("EVC-" + String.valueOf(fr.tableId())));
        DefaultEvcPerUni epu = new DefaultEvcPerUni();
        epu.evcPerUnin(epun);
        epu.evcPerUnic(epuc);
        evc.evcPerUni(epu);
        evcMap.put(evcKey, evc);
    }
    frList.add(fr);
}
#end_block

#method_before
private Collection<FlowEntry> convertSaFilteringToFlowRules(MseaSaFiltering saFilteringCurrent, ApplicationId appId) {
    Collection<FlowEntry> flowEntryCollection = new HashSet<FlowEntry>();
    List<SourceAddressRange> saRangelist = saFilteringCurrent.sourceIpaddressFiltering().interfaceEth0().sourceAddressRange();
    Criterion matchInPort = Criteria.matchInPort(PortNumber.portNumber(0));
    TrafficSelector.Builder tsBuilder = DefaultTrafficSelector.builder();
    for (SourceAddressRange sa : saRangelist) {
        Criterion matchIpSrc = Criteria.matchIPSrc(IpPrefix.valueOf(sa.ipv4AddressPrefix()));
        TrafficSelector selector = tsBuilder.add(matchIpSrc).add(matchInPort).build();
        TrafficTreatment.Builder trBuilder = DefaultTrafficTreatment.builder();
        TrafficTreatment treatment = trBuilder.drop().build();
        FlowRule.Builder feBuilder = new DefaultFlowRule.Builder();
        if (sa.name() != null && sa.name().startsWith("Flow:")) {
            String[] nameParts = sa.name().split(":");
            Long cookie = Long.valueOf(nameParts[1], 16);
            feBuilder = feBuilder.withCookie(cookie);
        } else {
            feBuilder = feBuilder.fromApp(appId);
        }
        FlowRule fr = feBuilder.forDevice(handler().data().deviceId()).withSelector(selector).withTreatment(treatment).forTable(sa.rangeId()).makePermanent().withPriority(PRIORITY_DEFAULT).build();
        flowEntryCollection.add(new DefaultFlowEntry(fr, FlowEntryState.ADDED, 0, 0, 0));
    }
    return flowEntryCollection;
}
#method_after
private Collection<FlowEntry> convertSaFilteringToFlowRules(MseaSaFiltering saFilteringCurrent, ApplicationId appId) {
    Collection<FlowEntry> flowEntryCollection = new HashSet<FlowEntry>();
    List<SourceAddressRange> saRangelist = saFilteringCurrent.sourceIpaddressFiltering().interfaceEth0().sourceAddressRange();
    Criterion matchInPort = Criteria.matchInPort(PortNumber.portNumber(0));
    TrafficSelector.Builder tsBuilder = DefaultTrafficSelector.builder();
    if (saRangelist != null) {
        for (SourceAddressRange sa : saRangelist) {
            Criterion matchIpSrc = Criteria.matchIPSrc(IpPrefix.valueOf(sa.ipv4AddressPrefix()));
            TrafficSelector selector = tsBuilder.add(matchIpSrc).add(matchInPort).build();
            TrafficTreatment.Builder trBuilder = DefaultTrafficTreatment.builder();
            TrafficTreatment treatment = trBuilder.drop().build();
            FlowRule.Builder feBuilder = new DefaultFlowRule.Builder();
            if (sa.name() != null && sa.name().startsWith("Flow:")) {
                String[] nameParts = sa.name().split(":");
                Long cookie = Long.valueOf(nameParts[1], 16);
                feBuilder = feBuilder.withCookie(cookie);
            } else {
                feBuilder = feBuilder.fromApp(appId);
            }
            FlowRule fr = feBuilder.forDevice(handler().data().deviceId()).withSelector(selector).withTreatment(treatment).forTable(sa.rangeId()).makePermanent().withPriority(PRIORITY_DEFAULT).build();
            flowEntryCollection.add(new DefaultFlowEntry(fr, FlowEntryState.ADDED, 0, 0, 0));
        }
    }
    return flowEntryCollection;
}
#end_block

#method_before
private void parseP4Info(P4Info p4info) {
    p4info.getTablesList().forEach(e -> {
        tables.addWithPreamble(e.getPreamble(), e);
        // Index match fields.
        int tableId = e.getPreamble().getId();
        EntityBrowser<MatchField> matchFieldBrowser = new EntityBrowser<>();
        e.getMatchFieldsList().forEach(m -> matchFieldBrowser.add(m.getName(), m.getId(), m));
        matchFields.put(tableId, matchFieldBrowser);
    });
    p4info.getActionsList().forEach(e -> {
        actions.addWithPreamble(e.getPreamble(), e);
        // Index action params.
        int actionId = e.getPreamble().getId();
        EntityBrowser<Action.Param> paramBrowser = new EntityBrowser<>();
        e.getParamsList().forEach(p -> paramBrowser.add(p.getName(), p.getId(), p));
        actionParams.put(actionId, paramBrowser);
    });
    p4info.getActionProfilesList().forEach(e -> actionProfiles.addWithPreamble(e.getPreamble(), e));
    p4info.getCountersList().forEach(e -> counters.addWithPreamble(e.getPreamble(), e));
    p4info.getDirectCountersList().forEach(e -> directCounters.addWithPreamble(e.getPreamble(), e));
    p4info.getMetersList().forEach(e -> meters.addWithPreamble(e.getPreamble(), e));
    p4info.getDirectMetersList().forEach(e -> directMeters.addWithPreamble(e.getPreamble(), e));
    p4info.getControllerPacketMetadataList().forEach(e -> ctrlPktMetadatas.addWithPreamble(e.getPreamble(), e));
}
#method_after
private void parseP4Info(P4Info p4info) {
    p4info.getTablesList().forEach(entity -> {
        tables.addWithPreamble(entity.getPreamble(), entity);
        // Index match fields.
        int tableId = entity.getPreamble().getId();
        String tableName = entity.getPreamble().getName();
        EntityBrowser<MatchField> matchFieldBrowser = new EntityBrowser<>(format("match field for table '%s'", tableName));
        entity.getMatchFieldsList().forEach(m -> matchFieldBrowser.add(m.getName(), m.getId(), m));
        matchFields.put(tableId, matchFieldBrowser);
    });
    p4info.getActionsList().forEach(entity -> {
        actions.addWithPreamble(entity.getPreamble(), entity);
        // Index action params.
        int actionId = entity.getPreamble().getId();
        String actionName = entity.getPreamble().getName();
        EntityBrowser<Action.Param> paramBrowser = new EntityBrowser<>(format("param for action '%s'", actionName));
        entity.getParamsList().forEach(p -> paramBrowser.add(p.getName(), p.getId(), p));
        actionParams.put(actionId, paramBrowser);
    });
    p4info.getActionProfilesList().forEach(entity -> actionProfiles.addWithPreamble(entity.getPreamble(), entity));
    p4info.getCountersList().forEach(entity -> counters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectCountersList().forEach(entity -> directCounters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getMetersList().forEach(entity -> meters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getDirectMetersList().forEach(entity -> directMeters.addWithPreamble(entity.getPreamble(), entity));
    p4info.getControllerPacketMetadataList().forEach(entity -> ctrlPktMetadatas.addWithPreamble(entity.getPreamble(), entity));
}
#end_block

#method_before
EntityBrowser<Action.Param> actionParams(int actionId) throws NotFoundException {
    if (!actionParams.containsKey(actionId)) {
        throw new NotFoundException();
    }
    return actionParams.get(actionId);
}
#method_after
EntityBrowser<Action.Param> actionParams(int actionId) throws NotFoundException {
    // Throws exception if action id is not found.
    actions.getById(actionId);
    return actionParams.get(actionId);
}
#end_block

#method_before
EntityBrowser<MatchField> matchFields(int tableId) throws NotFoundException {
    if (!matchFields.containsKey(tableId)) {
        throw new NotFoundException();
    }
    return matchFields.get(tableId);
}
#method_after
EntityBrowser<MatchField> matchFields(int tableId) throws NotFoundException {
    // Throws exception if action id is not found.
    tables.getById(tableId);
    return matchFields.get(tableId);
}
#end_block

#method_before
@Test
public void testP4InfoBrowser() throws Exception {
    InputStreamReader input = new InputStreamReader(p4InfoStream);
    ExtensionRegistry extensionRegistry = ExtensionRegistry.getEmptyRegistry();
    P4InfoOuterClass.P4Info.Builder builder = P4InfoOuterClass.P4Info.newBuilder();
    builder.clear();
    TextFormat.getParser().merge(input, extensionRegistry, builder);
    P4InfoOuterClass.P4Info p4Info = builder.build();
    P4InfoBrowser browser = new P4InfoBrowser(p4Info);
    assertThat(browser.tables().hasName("table0"), is(true));
    assertThat(browser.actions().hasName("set_egress_port"), is(true));
    int tableId = browser.tables().getName("table0").getPreamble().getId();
    int actionId = browser.actions().getName("set_egress_port").getPreamble().getId();
    assertThat(browser.matchFields(tableId).hasName("standard_metadata.ingress_port"), is(true));
    assertThat(browser.actionParams(actionId).hasName("port"), is(true));
// TODO: improve, assert browsing of other entities (counters, meters, etc.)
}
#method_after
@Test
public void testP4InfoBrowser() throws Exception {
    InputStreamReader input = new InputStreamReader(p4InfoStream);
    ExtensionRegistry extensionRegistry = ExtensionRegistry.getEmptyRegistry();
    P4InfoOuterClass.P4Info.Builder builder = P4InfoOuterClass.P4Info.newBuilder();
    builder.clear();
    TextFormat.getParser().merge(input, extensionRegistry, builder);
    P4InfoOuterClass.P4Info p4Info = builder.build();
    P4InfoBrowser browser = new P4InfoBrowser(p4Info);
    assertThat(browser.tables().hasName("table0"), is(true));
    assertThat(browser.actions().hasName("set_egress_port"), is(true));
    int tableId = browser.tables().getByName("table0").getPreamble().getId();
    int actionId = browser.actions().getByName("set_egress_port").getPreamble().getId();
    assertThat(browser.matchFields(tableId).hasName("standard_metadata.ingress_port"), is(true));
    assertThat(browser.actionParams(actionId).hasName("port"), is(true));
// TODO: improve, assert browsing of other entities (counters, meters, etc.)
}
#end_block

#method_before
@Activate
public void activate(ComponentContext context) {
    this.arpComponent = metricService.registerComponent("arpComponent");
    this.arpFeature = arpComponent.registerFeature("arpFeature");
    this.dhcpComponent = metricService.registerComponent("dhcpComponent");
    this.dhcpFeature = dhcpComponent.registerFeature("dhcpFeature");
    this.lldpComponent = metricService.registerComponent("lldpComponent");
    this.lldpFeature = lldpComponent.registerFeature("lldpFeature");
    this.vlanComponent = metricService.registerComponent("vlanComponent");
    this.vlanFeature = vlanComponent.registerFeature("vlanFeature");
    this.tcpComponent = metricService.registerComponent("tcpComponent");
    this.tcpFeature = tcpComponent.registerFeature("tcpFeature");
    this.icmpComponent = metricService.registerComponent("icmpComponent");
    this.icmpFeature = icmpComponent.registerFeature("icmpFeature");
    this.igmpComponent = metricService.registerComponent("igmpComponent");
    this.igmpFeature = igmpComponent.registerFeature("igmpFeature");
    this.pimComponent = metricService.registerComponent("pimComponent");
    this.pimFeature = pimComponent.registerFeature("pimFeature");
    this.bsnComponent = metricService.registerComponent("bsnComponent");
    this.bsnFeature = bsnComponent.registerFeature("bsnFeature");
    this.rarpComponent = metricService.registerComponent("rarpComponent");
    this.rarpFeature = rarpComponent.registerFeature("rarpFeature");
    this.mplsComponent = metricService.registerComponent("mplsComponent");
    this.mplsFeature = mplsComponent.registerFeature("mplsFeature");
    this.unknownComponent = metricService.registerComponent("unknownComponent");
    this.unknownFeature = unknownComponent.registerFeature("unknownFeature");
    this.arpCounter = metricService.createCounter(arpComponent, arpFeature, "ARP Packet Counter");
    this.dhcpCounter = metricService.createCounter(dhcpComponent, dhcpFeature, "DHCP Packet Counter");
    this.lldpCounter = metricService.createCounter(lldpComponent, lldpFeature, "LLDP Packet Counter");
    this.vlanCounter = metricService.createCounter(vlanComponent, vlanFeature, "VLAN Packet Counter");
    this.icmpCounter = metricService.createCounter(icmpComponent, icmpFeature, "ICMP Packet Counter");
    this.igmpCounter = metricService.createCounter(igmpComponent, igmpFeature, "IGMP Packet Counter");
    this.pimCounter = metricService.createCounter(pimComponent, pimFeature, "PIM Packet Counter");
    this.bsnCounter = metricService.createCounter(bsnComponent, bsnFeature, "BSN Packet Counter");
    this.mplsCounter = metricService.createCounter(bsnComponent, bsnFeature, "MPLS Packet Counter");
    this.unknownCounter = metricService.createCounter(bsnComponent, bsnFeature, "Unknown Packet Counter");
    appId = coreService.registerApplication("org.onosproject.packet-stats");
    packetService.addProcessor(processor, PacketProcessor.director(2));
    log.info("Started", appId.id());
}
#method_after
@Activate
public void activate(ComponentContext context) {
    this.packetStatisticsComponent = metricService.registerComponent("packetStatisticsComponent");
    this.arpFeature = packetStatisticsComponent.registerFeature("arpFeature");
    this.dhcpFeature = packetStatisticsComponent.registerFeature("dhcpFeature");
    this.lldpFeature = packetStatisticsComponent.registerFeature("lldpFeature");
    this.vlanFeature = packetStatisticsComponent.registerFeature("vlanFeature");
    this.tcpFeature = packetStatisticsComponent.registerFeature("tcpFeature");
    this.icmpFeature = packetStatisticsComponent.registerFeature("icmpFeature");
    this.igmpFeature = packetStatisticsComponent.registerFeature("igmpFeature");
    this.pimFeature = packetStatisticsComponent.registerFeature("pimFeature");
    this.bsnFeature = packetStatisticsComponent.registerFeature("bsnFeature");
    this.rarpFeature = packetStatisticsComponent.registerFeature("rarpFeature");
    this.mplsFeature = packetStatisticsComponent.registerFeature("mplsFeature");
    this.unknownFeature = packetStatisticsComponent.registerFeature("unknownFeature");
    this.arpCounter = metricService.createCounter(packetStatisticsComponent, arpFeature, "ARP Packet Counter");
    this.dhcpCounter = metricService.createCounter(packetStatisticsComponent, dhcpFeature, "DHCP Packet Counter");
    this.lldpCounter = metricService.createCounter(packetStatisticsComponent, lldpFeature, "LLDP Packet Counter");
    this.vlanCounter = metricService.createCounter(packetStatisticsComponent, vlanFeature, "VLAN Packet Counter");
    this.icmpCounter = metricService.createCounter(packetStatisticsComponent, icmpFeature, "ICMP Packet Counter");
    this.igmpCounter = metricService.createCounter(packetStatisticsComponent, igmpFeature, "IGMP Packet Counter");
    this.pimCounter = metricService.createCounter(packetStatisticsComponent, pimFeature, "PIM Packet Counter");
    this.bsnCounter = metricService.createCounter(packetStatisticsComponent, bsnFeature, "BSN Packet Counter");
    this.mplsCounter = metricService.createCounter(packetStatisticsComponent, bsnFeature, "MPLS Packet Counter");
    this.unknownCounter = metricService.createCounter(packetStatisticsComponent, bsnFeature, "Unknown Packet Counter");
    appId = coreService.registerApplication("org.onosproject.packet-stats");
    packetService.addProcessor(processor, PacketProcessor.director(2));
    log.info("Started", appId.id());
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    // Indicates whether this is an ARP Packet
    if (ethPkt.getEtherType() == Ethernet.TYPE_ARP) {
        log.info("Packet is an ARP packet");
        arpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_LLDP) {
        log.info("Packet is an LLDP packet");
        lldpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_VLAN) {
        log.info("Packet is an VLAN packet");
        vlanCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_BSN) {
        log.info("Packet is an BSN packet");
        bsnCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_RARP) {
        log.info("Packet is a RARP packet");
        rarpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.MPLS_UNICAST || ethPkt.getEtherType() == Ethernet.MPLS_MULTICAST) {
        log.info("Packet is a MPLS packet");
        mplsCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethPkt.getPayload();
        // Indicates whether this is a TCP Packet
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_TCP) {
            log.info("Packet is a TCP packet");
            tcpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            log.info("Packet is an ICMP packet");
            icmpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_IGMP) {
            log.info("Packet is a IGMP packet");
            igmpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_PIM) {
            log.info("Packet is a PIM packet");
            pimCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            // Indicates whether this packet is a DHCP Packet
            if (udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT || udpPacket.getSourcePort() == UDP.DHCP_SERVER_PORT) {
                log.info("Packet is a DHCP packet");
                dhcpCounter.inc();
            }
        }
    } else {
        log.info("Packet is unknown.");
        unknownCounter.inc();
    }
}
#method_after
@Override
public void process(PacketContext context) {
    InboundPacket pkt = context.inPacket();
    Ethernet ethPkt = pkt.parsed();
    // Indicates whether this is an ARP Packet
    if (ethPkt.getEtherType() == Ethernet.TYPE_ARP) {
        arpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_LLDP) {
        lldpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_VLAN) {
        vlanCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_BSN) {
        bsnCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_RARP) {
        rarpCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.MPLS_UNICAST || ethPkt.getEtherType() == Ethernet.MPLS_MULTICAST) {
        mplsCounter.inc();
    } else if (ethPkt.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) ethPkt.getPayload();
        // Indicates whether this is a TCP Packet
        if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_TCP) {
            tcpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_ICMP) {
            icmpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_IGMP) {
            igmpCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_PIM) {
            pimCounter.inc();
        } else if (ipv4Packet.getProtocol() == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            // Indicates whether this packet is a DHCP Packet
            if (udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT || udpPacket.getSourcePort() == UDP.DHCP_SERVER_PORT) {
                dhcpCounter.inc();
            }
        }
    } else {
        log.info("Packet is unknown.");
        unknownCounter.inc();
    }
}
#end_block

#method_before
protected void listen(RaftCommit<? extends Listen> commit) {
    Long sessionId = commit.session().sessionId().id();
    listeners.computeIfAbsent(sessionId, k -> new SessionListenCommits()).add(new Listener(commit.session(), commit.value().path()));
}
#method_after
protected void listen(Commit<? extends Listen> commit) {
    Long sessionId = commit.session().sessionId().id();
    listeners.computeIfAbsent(sessionId, k -> new SessionListenCommits()).add(new Listener(commit.session(), commit.value().path()));
}
#end_block

#method_before
protected void unlisten(RaftCommit<? extends Unlisten> commit) {
    Long sessionId = commit.session().sessionId().id();
    SessionListenCommits listenCommits = listeners.get(sessionId);
    if (listenCommits != null) {
        listenCommits.remove(commit);
    }
}
#method_after
protected void unlisten(Commit<? extends Unlisten> commit) {
    Long sessionId = commit.session().sessionId().id();
    SessionListenCommits listenCommits = listeners.get(sessionId);
    if (listenCommits != null) {
        listenCommits.remove(commit);
    }
}
#end_block

#method_before
protected Versioned<byte[]> get(RaftCommit<? extends Get> commit) {
    try {
        Versioned<byte[]> value = docTree.get(commit.value().path());
        return value == null ? null : value.map(node -> node == null ? null : node);
    } catch (IllegalStateException e) {
        return null;
    }
}
#method_after
protected Versioned<byte[]> get(Commit<? extends Get> commit) {
    try {
        Versioned<byte[]> value = docTree.get(commit.value().path());
        return value == null ? null : value.map(node -> node == null ? null : node);
    } catch (IllegalStateException e) {
        return null;
    }
}
#end_block

#method_before
protected Map<String, Versioned<byte[]>> getChildren(RaftCommit<? extends GetChildren> commit) {
    return docTree.getChildren(commit.value().path());
}
#method_after
protected Map<String, Versioned<byte[]>> getChildren(Commit<? extends GetChildren> commit) {
    return docTree.getChildren(commit.value().path());
}
#end_block

#method_before
protected DocumentTreeUpdateResult<byte[]> update(RaftCommit<? extends Update> commit) {
    DocumentTreeUpdateResult<byte[]> result = null;
    DocumentPath path = commit.value().path();
    boolean updated = false;
    Versioned<byte[]> currentValue = docTree.get(path);
    try {
        Match<Long> versionMatch = commit.value().versionMatch();
        Match<byte[]> valueMatch = commit.value().valueMatch();
        if (versionMatch.matches(currentValue == null ? null : currentValue.version()) && valueMatch.matches(currentValue == null ? null : currentValue.value())) {
            if (commit.value().value() == null) {
                docTree.removeNode(path);
            } else {
                docTree.set(path, commit.value().value().orElse(null));
            }
            updated = true;
        }
        Versioned<byte[]> newValue = updated ? docTree.get(path) : currentValue;
        Status updateStatus = updated ? Status.OK : commit.value().value() == null ? Status.INVALID_PATH : Status.NOOP;
        result = new DocumentTreeUpdateResult<>(path, updateStatus, newValue, currentValue);
    } catch (IllegalDocumentModificationException e) {
        result = DocumentTreeUpdateResult.illegalModification(path);
    } catch (NoSuchDocumentPathException e) {
        result = DocumentTreeUpdateResult.invalidPath(path);
    } catch (Exception e) {
        getLogger().error("Failed to apply {} to state machine", commit.value(), e);
        throw Throwables.propagate(e);
    }
    notifyListeners(path, result);
    return result;
}
#method_after
protected DocumentTreeUpdateResult<byte[]> update(Commit<? extends Update> commit) {
    DocumentTreeUpdateResult<byte[]> result = null;
    DocumentPath path = commit.value().path();
    boolean updated = false;
    Versioned<byte[]> currentValue = docTree.get(path);
    try {
        Match<Long> versionMatch = commit.value().versionMatch();
        Match<byte[]> valueMatch = commit.value().valueMatch();
        if (versionMatch.matches(currentValue == null ? null : currentValue.version()) && valueMatch.matches(currentValue == null ? null : currentValue.value())) {
            if (commit.value().value() == null) {
                docTree.removeNode(path);
            } else {
                docTree.set(path, commit.value().value().orElse(null));
            }
            updated = true;
        }
        Versioned<byte[]> newValue = updated ? docTree.get(path) : currentValue;
        Status updateStatus = updated ? Status.OK : commit.value().value() == null ? Status.INVALID_PATH : Status.NOOP;
        result = new DocumentTreeUpdateResult<>(path, updateStatus, newValue, currentValue);
    } catch (IllegalDocumentModificationException e) {
        result = DocumentTreeUpdateResult.illegalModification(path);
    } catch (NoSuchDocumentPathException e) {
        result = DocumentTreeUpdateResult.invalidPath(path);
    } catch (Exception e) {
        getLogger().error("Failed to apply {} to state machine", commit.value(), e);
        throw Throwables.propagate(e);
    }
    notifyListeners(path, result);
    return result;
}
#end_block

#method_before
protected void clear(RaftCommit<Void> commit) {
    Queue<DocumentPath> toClearQueue = Queues.newArrayDeque();
    Map<String, Versioned<byte[]>> topLevelChildren = docTree.getChildren(DocumentPath.from("root"));
    toClearQueue.addAll(topLevelChildren.keySet().stream().map(name -> new DocumentPath(name, DocumentPath.from("root"))).collect(Collectors.toList()));
    while (!toClearQueue.isEmpty()) {
        DocumentPath path = toClearQueue.remove();
        Map<String, Versioned<byte[]>> children = docTree.getChildren(path);
        if (children.size() == 0) {
            docTree.removeNode(path);
        } else {
            children.keySet().forEach(name -> toClearQueue.add(new DocumentPath(name, path)));
            toClearQueue.add(path);
        }
    }
}
#method_after
protected void clear(Commit<Void> commit) {
    Queue<DocumentPath> toClearQueue = Queues.newArrayDeque();
    Map<String, Versioned<byte[]>> topLevelChildren = docTree.getChildren(DocumentPath.from("root"));
    toClearQueue.addAll(topLevelChildren.keySet().stream().map(name -> new DocumentPath(name, DocumentPath.from("root"))).collect(Collectors.toList()));
    while (!toClearQueue.isEmpty()) {
        DocumentPath path = toClearQueue.remove();
        Map<String, Versioned<byte[]>> children = docTree.getChildren(path);
        if (children.size() == 0) {
            docTree.removeNode(path);
        } else {
            children.keySet().forEach(name -> toClearQueue.add(new DocumentPath(name, path)));
            toClearQueue.add(path);
        }
    }
}
#end_block

#method_before
public void remove(RaftCommit<? extends Unlisten> commit) {
    // Remove the first listen commit with path matching path in unlisten commit
    Iterator<Listener> iterator = listeners.iterator();
    while (iterator.hasNext()) {
        Listener listener = iterator.next();
        if (listener.path().equals(commit.value().path())) {
            iterator.remove();
        }
    }
    recomputeLeastCommonAncestor();
}
#method_after
public void remove(Commit<? extends Unlisten> commit) {
    // Remove the first listen commit with path matching path in unlisten commit
    Iterator<Listener> iterator = listeners.iterator();
    while (iterator.hasNext()) {
        Listener listener = iterator.next();
        if (listener.path().equals(commit.value().path())) {
            iterator.remove();
        }
    }
    recomputeLeastCommonAncestor();
}
#end_block

#method_before
protected boolean containsKey(RaftCommit<? extends ContainsKey> commit) {
    MapEntryValue value = mapEntries.get(commit.value().key());
    return value != null && value.type() != MapEntryValue.Type.TOMBSTONE;
}
#method_after
protected boolean containsKey(Commit<? extends ContainsKey> commit) {
    MapEntryValue value = mapEntries.get(commit.value().key());
    return value != null && value.type() != MapEntryValue.Type.TOMBSTONE;
}
#end_block

#method_before
protected boolean containsValue(RaftCommit<? extends ContainsValue> commit) {
    Match<byte[]> valueMatch = Match.ifValue(commit.value().value());
    return mapEntries.values().stream().filter(value -> value.type() != MapEntryValue.Type.TOMBSTONE).anyMatch(value -> valueMatch.matches(value.value()));
}
#method_after
protected boolean containsValue(Commit<? extends ContainsValue> commit) {
    Match<byte[]> valueMatch = Match.ifValue(commit.value().value());
    return mapEntries.values().stream().filter(value -> value.type() != MapEntryValue.Type.TOMBSTONE).anyMatch(value -> valueMatch.matches(value.value()));
}
#end_block

#method_before
protected Versioned<byte[]> get(RaftCommit<? extends Get> commit) {
    return toVersioned(mapEntries.get(commit.value().key()));
}
#method_after
protected Versioned<byte[]> get(Commit<? extends Get> commit) {
    return toVersioned(mapEntries.get(commit.value().key()));
}
#end_block

#method_before
protected Versioned<byte[]> getOrDefault(RaftCommit<? extends GetOrDefault> commit) {
    MapEntryValue value = mapEntries.get(commit.value().key());
    if (value == null) {
        return new Versioned<>(commit.value().defaultValue(), 0);
    } else if (value.type() == MapEntryValue.Type.TOMBSTONE) {
        return new Versioned<>(commit.value().defaultValue(), value.version);
    } else {
        return new Versioned<>(value.value(), value.version);
    }
}
#method_after
protected Versioned<byte[]> getOrDefault(Commit<? extends GetOrDefault> commit) {
    MapEntryValue value = mapEntries.get(commit.value().key());
    if (value == null) {
        return new Versioned<>(commit.value().defaultValue(), 0);
    } else if (value.type() == MapEntryValue.Type.TOMBSTONE) {
        return new Versioned<>(commit.value().defaultValue(), value.version);
    } else {
        return new Versioned<>(value.value(), value.version);
    }
}
#end_block

#method_before
protected int size(RaftCommit<Void> commit) {
    return (int) mapEntries.values().stream().filter(value -> value.type() != MapEntryValue.Type.TOMBSTONE).count();
}
#method_after
protected int size(Commit<Void> commit) {
    return (int) mapEntries.values().stream().filter(value -> value.type() != MapEntryValue.Type.TOMBSTONE).count();
}
#end_block

#method_before
protected boolean isEmpty(RaftCommit<Void> commit) {
    return mapEntries.values().stream().noneMatch(value -> value.type() != MapEntryValue.Type.TOMBSTONE);
}
#method_after
protected boolean isEmpty(Commit<Void> commit) {
    return mapEntries.values().stream().noneMatch(value -> value.type() != MapEntryValue.Type.TOMBSTONE);
}
#end_block

#method_before
protected Set<String> keySet(RaftCommit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(Map.Entry::getKey).collect(Collectors.toSet());
}
#method_after
protected Set<String> keySet(Commit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(Map.Entry::getKey).collect(Collectors.toSet());
}
#end_block

#method_before
protected Collection<Versioned<byte[]>> values(RaftCommit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(entry -> toVersioned(entry.getValue())).collect(Collectors.toList());
}
#method_after
protected Collection<Versioned<byte[]>> values(Commit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(entry -> toVersioned(entry.getValue())).collect(Collectors.toList());
}
#end_block

#method_before
protected Set<Map.Entry<String, Versioned<byte[]>>> entrySet(RaftCommit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(e -> Maps.immutableEntry(e.getKey(), toVersioned(e.getValue()))).collect(Collectors.toSet());
}
#method_after
protected Set<Map.Entry<String, Versioned<byte[]>>> entrySet(Commit<Void> commit) {
    return mapEntries.entrySet().stream().filter(entry -> entry.getValue().type() != MapEntryValue.Type.TOMBSTONE).map(e -> Maps.immutableEntry(e.getKey(), toVersioned(e.getValue()))).collect(Collectors.toSet());
}
#end_block

#method_before
protected MapEntryUpdateResult<String, byte[]> updateAndGet(RaftCommit<? extends UpdateAndGet> commit) {
    try {
        MapEntryUpdateResult.Status updateStatus = validate(commit.value());
        String key = commit.value().key();
        MapEntryValue oldCommitValue = mapEntries.get(commit.value().key());
        Versioned<byte[]> oldMapValue = toVersioned(oldCommitValue);
        if (updateStatus != MapEntryUpdateResult.Status.OK) {
            return new MapEntryUpdateResult<>(updateStatus, "", key, oldMapValue, oldMapValue);
        }
        byte[] newValue = commit.value().value();
        currentVersion = commit.index();
        Versioned<byte[]> newMapValue = newValue == null ? null : new Versioned<>(newValue, currentVersion);
        MapEvent.Type updateType = newValue == null ? REMOVE : oldCommitValue == null ? INSERT : UPDATE;
        // If a value existed in the map, remove and discard the value to ensure disk can be freed.
        if (updateType == REMOVE || updateType == UPDATE) {
            mapEntries.remove(key);
        }
        // If this is an insert/update commit, add the commit to the map entries.
        if (updateType == INSERT || updateType == UPDATE) {
            mapEntries.put(key, new MapEntryValue(MapEntryValue.Type.VALUE, commit.index(), commit.value().value()));
        } else if (!activeTransactions.isEmpty()) {
            // If this is a delete but transactions are currently running, ensure tombstones are retained
            // for version checks.
            mapEntries.put(key, new MapEntryValue(MapEntryValue.Type.TOMBSTONE, commit.index(), null));
        }
        publish(Lists.newArrayList(new MapEvent<>("", key, newMapValue, oldMapValue)));
        return new MapEntryUpdateResult<>(updateStatus, "", key, oldMapValue, newMapValue);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
protected MapEntryUpdateResult<String, byte[]> updateAndGet(Commit<? extends UpdateAndGet> commit) {
    try {
        MapEntryUpdateResult.Status updateStatus = validate(commit.value());
        String key = commit.value().key();
        MapEntryValue oldCommitValue = mapEntries.get(commit.value().key());
        Versioned<byte[]> oldMapValue = toVersioned(oldCommitValue);
        if (updateStatus != MapEntryUpdateResult.Status.OK) {
            return new MapEntryUpdateResult<>(updateStatus, "", key, oldMapValue, oldMapValue);
        }
        byte[] newValue = commit.value().value();
        currentVersion = commit.index();
        Versioned<byte[]> newMapValue = newValue == null ? null : new Versioned<>(newValue, currentVersion);
        MapEvent.Type updateType = newValue == null ? REMOVE : oldCommitValue == null ? INSERT : UPDATE;
        // If a value existed in the map, remove and discard the value to ensure disk can be freed.
        if (updateType == REMOVE || updateType == UPDATE) {
            mapEntries.remove(key);
        }
        // If this is an insert/update commit, add the commit to the map entries.
        if (updateType == INSERT || updateType == UPDATE) {
            mapEntries.put(key, new MapEntryValue(MapEntryValue.Type.VALUE, commit.index(), commit.value().value()));
        } else if (!activeTransactions.isEmpty()) {
            // If this is a delete but transactions are currently running, ensure tombstones are retained
            // for version checks.
            mapEntries.put(key, new MapEntryValue(MapEntryValue.Type.TOMBSTONE, commit.index(), null));
        }
        publish(Lists.newArrayList(new MapEvent<>("", key, newMapValue, oldMapValue)));
        return new MapEntryUpdateResult<>(updateStatus, "", key, oldMapValue, newMapValue);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
protected MapEntryUpdateResult.Status clear(RaftCommit<Void> commit) {
    Iterator<Map.Entry<String, MapEntryValue>> iterator = mapEntries.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, MapEntryValue> entry = iterator.next();
        String key = entry.getKey();
        MapEntryValue value = entry.getValue();
        Versioned<byte[]> removedValue = new Versioned<>(value.value(), value.version());
        publish(Lists.newArrayList(new MapEvent<>("", key, null, removedValue)));
        iterator.remove();
    }
    return MapEntryUpdateResult.Status.OK;
}
#method_after
protected MapEntryUpdateResult.Status clear(Commit<Void> commit) {
    Iterator<Map.Entry<String, MapEntryValue>> iterator = mapEntries.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, MapEntryValue> entry = iterator.next();
        String key = entry.getKey();
        MapEntryValue value = entry.getValue();
        Versioned<byte[]> removedValue = new Versioned<>(value.value(), value.version());
        publish(Lists.newArrayList(new MapEvent<>("", key, null, removedValue)));
        iterator.remove();
    }
    return MapEntryUpdateResult.Status.OK;
}
#end_block

#method_before
protected void listen(RaftCommit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#method_after
protected void listen(Commit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#end_block

#method_before
protected void unlisten(RaftCommit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#method_after
protected void unlisten(Commit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#end_block

#method_before
protected long begin(RaftCommit<? extends TransactionBegin> commit) {
    long version = commit.index();
    activeTransactions.put(commit.value().transactionId(), new TransactionScope(version));
    return version;
}
#method_after
protected long begin(Commit<? extends TransactionBegin> commit) {
    long version = commit.index();
    activeTransactions.put(commit.value().transactionId(), new TransactionScope(version));
    return version;
}
#end_block

#method_before
protected PrepareResult prepareAndCommit(RaftCommit<? extends TransactionPrepareAndCommit> commit) {
    TransactionId transactionId = commit.value().transactionLog().transactionId();
    PrepareResult prepareResult = prepare(commit);
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (prepareResult == PrepareResult.OK) {
        this.currentVersion = commit.index();
        transactionScope = transactionScope.prepared(commit);
        commitTransaction(transactionScope);
    }
    discardTombstones();
    return prepareResult;
}
#method_after
protected PrepareResult prepareAndCommit(Commit<? extends TransactionPrepareAndCommit> commit) {
    TransactionId transactionId = commit.value().transactionLog().transactionId();
    PrepareResult prepareResult = prepare(commit);
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (prepareResult == PrepareResult.OK) {
        this.currentVersion = commit.index();
        transactionScope = transactionScope.prepared(commit);
        commitTransaction(transactionScope);
    }
    discardTombstones();
    return prepareResult;
}
#end_block

#method_before
protected PrepareResult prepare(RaftCommit<? extends TransactionPrepare> commit) {
    try {
        TransactionLog<MapUpdate<String, byte[]>> transactionLog = commit.value().transactionLog();
        // Iterate through records in the transaction log and perform isolation checks.
        for (MapUpdate<String, byte[]> record : transactionLog.records()) {
            String key = record.key();
            // version of the state machine.
            if (record.type() == MapUpdate.Type.VERSION_MATCH && key == null) {
                if (record.version() > currentVersion) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                } else {
                    continue;
                }
            }
            // conflict with a concurrent transaction.
            if (preparedKeys.contains(key)) {
                return PrepareResult.CONCURRENT_TRANSACTION;
            }
            // Read the existing value from the map.
            MapEntryValue existingValue = mapEntries.get(key);
            // otherwise a tombstone would have been retained.
            if (existingValue == null) {
                // If the value is null, ensure the version is equal to the transaction version.
                if (record.version() != transactionLog.version()) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                }
            } else {
                // If the value is non-null, compare the current version with the record version.
                if (existingValue.version() > record.version()) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                }
            }
        }
        // No violations detected. Mark modified keys locked for transactions.
        transactionLog.records().forEach(record -> {
            if (record.type() != MapUpdate.Type.VERSION_MATCH) {
                preparedKeys.add(record.key());
            }
        });
        // Update the transaction scope. If the transaction scope is not set on this node, that indicates the
        // coordinator is communicating with another node. Transactions assume that the client is communicating
        // with a single leader in order to limit the overhead of retaining tombstones.
        TransactionScope transactionScope = activeTransactions.get(transactionLog.transactionId());
        if (transactionScope == null) {
            activeTransactions.put(transactionLog.transactionId(), new TransactionScope(transactionLog.version(), commit));
            return PrepareResult.PARTIAL_FAILURE;
        } else {
            activeTransactions.put(transactionLog.transactionId(), transactionScope.prepared(commit));
            return PrepareResult.OK;
        }
    } catch (Exception e) {
        getLogger().warn("Failure applying {}", commit, e);
        throw Throwables.propagate(e);
    }
}
#method_after
protected PrepareResult prepare(Commit<? extends TransactionPrepare> commit) {
    try {
        TransactionLog<MapUpdate<String, byte[]>> transactionLog = commit.value().transactionLog();
        // Iterate through records in the transaction log and perform isolation checks.
        for (MapUpdate<String, byte[]> record : transactionLog.records()) {
            String key = record.key();
            // version of the state machine.
            if (record.type() == MapUpdate.Type.VERSION_MATCH && key == null) {
                if (record.version() > currentVersion) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                } else {
                    continue;
                }
            }
            // conflict with a concurrent transaction.
            if (preparedKeys.contains(key)) {
                return PrepareResult.CONCURRENT_TRANSACTION;
            }
            // Read the existing value from the map.
            MapEntryValue existingValue = mapEntries.get(key);
            // otherwise a tombstone would have been retained.
            if (existingValue == null) {
                // If the value is null, ensure the version is equal to the transaction version.
                if (record.version() != transactionLog.version()) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                }
            } else {
                // If the value is non-null, compare the current version with the record version.
                if (existingValue.version() > record.version()) {
                    return PrepareResult.OPTIMISTIC_LOCK_FAILURE;
                }
            }
        }
        // No violations detected. Mark modified keys locked for transactions.
        transactionLog.records().forEach(record -> {
            if (record.type() != MapUpdate.Type.VERSION_MATCH) {
                preparedKeys.add(record.key());
            }
        });
        // Update the transaction scope. If the transaction scope is not set on this node, that indicates the
        // coordinator is communicating with another node. Transactions assume that the client is communicating
        // with a single leader in order to limit the overhead of retaining tombstones.
        TransactionScope transactionScope = activeTransactions.get(transactionLog.transactionId());
        if (transactionScope == null) {
            activeTransactions.put(transactionLog.transactionId(), new TransactionScope(transactionLog.version(), commit.value().transactionLog()));
            return PrepareResult.PARTIAL_FAILURE;
        } else {
            activeTransactions.put(transactionLog.transactionId(), transactionScope.prepared(commit));
            return PrepareResult.OK;
        }
    } catch (Exception e) {
        getLogger().warn("Failure applying {}", commit, e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
protected CommitResult commit(RaftCommit<? extends TransactionCommit> commit) {
    TransactionId transactionId = commit.value().transactionId();
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (transactionScope == null) {
        return CommitResult.UNKNOWN_TRANSACTION_ID;
    }
    try {
        this.currentVersion = commit.index();
        return commitTransaction(transactionScope.committed(commit));
    } catch (Exception e) {
        getLogger().warn("Failure applying {}", commit, e);
        throw Throwables.propagate(e);
    } finally {
        discardTombstones();
    }
}
#method_after
protected CommitResult commit(Commit<? extends TransactionCommit> commit) {
    TransactionId transactionId = commit.value().transactionId();
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (transactionScope == null) {
        return CommitResult.UNKNOWN_TRANSACTION_ID;
    }
    try {
        this.currentVersion = commit.index();
        return commitTransaction(transactionScope);
    } catch (Exception e) {
        getLogger().warn("Failure applying {}", commit, e);
        throw Throwables.propagate(e);
    } finally {
        discardTombstones();
    }
}
#end_block

#method_before
private CommitResult commitTransaction(TransactionScope transactionScope) {
    TransactionLog<MapUpdate<String, byte[]>> transactionLog = transactionScope.transactionLog();
    boolean retainTombstones = !activeTransactions.isEmpty();
    // Count the total number of keys that will be set by this transaction. This is necessary to do reference
    // counting for garbage collection.
    long totalReferencesToCommit = transactionLog.records().stream().filter(record -> record.type() != MapUpdate.Type.VERSION_MATCH && record.type() != MapUpdate.Type.LOCK && (record.type() != MapUpdate.Type.REMOVE_IF_VERSION_MATCH || retainTombstones)).count();
    List<MapEvent<String, byte[]>> eventsToPublish = Lists.newArrayList();
    for (MapUpdate<String, byte[]> record : transactionLog.records()) {
        if (record.type() == MapUpdate.Type.VERSION_MATCH) {
            continue;
        }
        String key = record.key();
        checkState(preparedKeys.remove(key), "key is not prepared");
        if (record.type() == MapUpdate.Type.LOCK) {
            continue;
        }
        MapEntryValue previousValue = mapEntries.remove(key);
        MapEntryValue newValue = null;
        // If the record is not a delete, create a transactional commit.
        if (record.type() != MapUpdate.Type.REMOVE_IF_VERSION_MATCH) {
            newValue = new MapEntryValue(MapEntryValue.Type.VALUE, currentVersion, record.value());
        } else if (retainTombstones) {
            // For deletes, if tombstones need to be retained then create and store a tombstone commit.
            newValue = new MapEntryValue(MapEntryValue.Type.TOMBSTONE, currentVersion, null);
        }
        eventsToPublish.add(new MapEvent<>("", key, toVersioned(newValue), toVersioned(previousValue)));
        if (newValue != null) {
            mapEntries.put(key, newValue);
        }
    }
    publish(eventsToPublish);
    return CommitResult.OK;
}
#method_after
private CommitResult commitTransaction(TransactionScope transactionScope) {
    TransactionLog<MapUpdate<String, byte[]>> transactionLog = transactionScope.transactionLog();
    boolean retainTombstones = !activeTransactions.isEmpty();
    List<MapEvent<String, byte[]>> eventsToPublish = Lists.newArrayList();
    for (MapUpdate<String, byte[]> record : transactionLog.records()) {
        if (record.type() == MapUpdate.Type.VERSION_MATCH) {
            continue;
        }
        String key = record.key();
        checkState(preparedKeys.remove(key), "key is not prepared");
        if (record.type() == MapUpdate.Type.LOCK) {
            continue;
        }
        MapEntryValue previousValue = mapEntries.remove(key);
        MapEntryValue newValue = null;
        // If the record is not a delete, create a transactional commit.
        if (record.type() != MapUpdate.Type.REMOVE_IF_VERSION_MATCH) {
            newValue = new MapEntryValue(MapEntryValue.Type.VALUE, currentVersion, record.value());
        } else if (retainTombstones) {
            // For deletes, if tombstones need to be retained then create and store a tombstone commit.
            newValue = new MapEntryValue(MapEntryValue.Type.TOMBSTONE, currentVersion, null);
        }
        eventsToPublish.add(new MapEvent<>("", key, toVersioned(newValue), toVersioned(previousValue)));
        if (newValue != null) {
            mapEntries.put(key, newValue);
        }
    }
    publish(eventsToPublish);
    return CommitResult.OK;
}
#end_block

#method_before
protected RollbackResult rollback(RaftCommit<? extends TransactionRollback> commit) {
    TransactionId transactionId = commit.value().transactionId();
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (transactionScope == null) {
        return RollbackResult.UNKNOWN_TRANSACTION_ID;
    } else if (!transactionScope.isPrepared()) {
        discardTombstones();
        return RollbackResult.OK;
    } else {
        try {
            transactionScope.transactionLog().records().forEach(record -> {
                if (record.type() != MapUpdate.Type.VERSION_MATCH) {
                    preparedKeys.remove(record.key());
                }
            });
            return RollbackResult.OK;
        } finally {
            discardTombstones();
        }
    }
}
#method_after
protected RollbackResult rollback(Commit<? extends TransactionRollback> commit) {
    TransactionId transactionId = commit.value().transactionId();
    TransactionScope transactionScope = activeTransactions.remove(transactionId);
    if (transactionScope == null) {
        return RollbackResult.UNKNOWN_TRANSACTION_ID;
    } else if (!transactionScope.isPrepared()) {
        discardTombstones();
        return RollbackResult.OK;
    } else {
        try {
            transactionScope.transactionLog().records().forEach(record -> {
                if (record.type() != MapUpdate.Type.VERSION_MATCH) {
                    preparedKeys.remove(record.key());
                }
            });
            return RollbackResult.OK;
        } finally {
            discardTombstones();
        }
    }
}
#end_block

#method_before
boolean isPrepared() {
    return prepareCommit != null;
}
#method_after
boolean isPrepared() {
    return transactionLog != null;
}
#end_block

#method_before
TransactionLog<MapUpdate<String, byte[]>> transactionLog() {
    checkState(isPrepared());
    return prepareCommit.value().transactionLog();
}
#method_after
TransactionLog<MapUpdate<String, byte[]>> transactionLog() {
    checkState(isPrepared());
    return transactionLog;
}
#end_block

#method_before
TransactionScope prepared(RaftCommit<? extends TransactionPrepare> commit) {
    return new TransactionScope(version, commit);
}
#method_after
TransactionScope prepared(Commit<? extends TransactionPrepare> commit) {
    return new TransactionScope(version, commit.value().transactionLog());
}
#end_block

#method_before
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixAtomicCounterMapService service = new AtomixAtomicCounterMapService();
    service.put(new DefaultRaftCommit<>(2, PUT, new AtomixAtomicCounterMapOperations.Put("foo", 1), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixAtomicCounterMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    long value = service.get(new DefaultRaftCommit<>(2, GET, new AtomixAtomicCounterMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertEquals(1, value);
}
#method_after
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixAtomicCounterMapService service = new AtomixAtomicCounterMapService();
    service.put(new DefaultCommit<>(2, PUT, new AtomixAtomicCounterMapOperations.Put("foo", 1), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixAtomicCounterMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    long value = service.get(new DefaultCommit<>(2, GET, new AtomixAtomicCounterMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertEquals(1, value);
}
#end_block

#method_before
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentSetMultimapService service = new AtomixConsistentSetMultimapService();
    service.put(new DefaultRaftCommit<>(2, PUT, new AtomixConsistentSetMultimapOperations.Put("foo", Arrays.asList("Hello world!".getBytes()), Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentSetMultimapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<Collection<? extends byte[]>> value = service.get(new DefaultRaftCommit<>(2, GET, new AtomixConsistentSetMultimapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(1, value.value().size());
    assertArrayEquals("Hello world!".getBytes(), value.value().iterator().next());
}
#method_after
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentSetMultimapService service = new AtomixConsistentSetMultimapService();
    service.put(new DefaultCommit<>(2, PUT, new AtomixConsistentSetMultimapOperations.Put("foo", Arrays.asList("Hello world!".getBytes()), Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentSetMultimapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<Collection<? extends byte[]>> value = service.get(new DefaultCommit<>(2, GET, new AtomixConsistentSetMultimapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(1, value.value().size());
    assertArrayEquals("Hello world!".getBytes(), value.value().iterator().next());
}
#end_block

#method_before
protected long put(RaftCommit<Put> commit) {
    return primitive(map.put(commit.value().key(), commit.value().value()));
}
#method_after
protected long put(Commit<Put> commit) {
    return primitive(map.put(commit.value().key(), commit.value().value()));
}
#end_block

#method_before
protected long putIfAbsent(RaftCommit<PutIfAbsent> commit) {
    return primitive(map.putIfAbsent(commit.value().key(), commit.value().value()));
}
#method_after
protected long putIfAbsent(Commit<PutIfAbsent> commit) {
    return primitive(map.putIfAbsent(commit.value().key(), commit.value().value()));
}
#end_block

#method_before
protected long get(RaftCommit<Get> commit) {
    return primitive(map.get(commit.value().key()));
}
#method_after
protected long get(Commit<Get> commit) {
    return primitive(map.get(commit.value().key()));
}
#end_block

#method_before
protected boolean replace(RaftCommit<Replace> commit) {
    Long value = map.get(commit.value().key());
    if (value == null) {
        if (commit.value().replace() == 0) {
            map.put(commit.value().key(), commit.value().value());
            return true;
        } else {
            return false;
        }
    } else if (value == commit.value().replace()) {
        map.put(commit.value().key(), commit.value().value());
        return true;
    }
    return false;
}
#method_after
protected boolean replace(Commit<Replace> commit) {
    Long value = map.get(commit.value().key());
    if (value == null) {
        if (commit.value().replace() == 0) {
            map.put(commit.value().key(), commit.value().value());
            return true;
        } else {
            return false;
        }
    } else if (value == commit.value().replace()) {
        map.put(commit.value().key(), commit.value().value());
        return true;
    }
    return false;
}
#end_block

#method_before
protected long remove(RaftCommit<Remove> commit) {
    return primitive(map.remove(commit.value().key()));
}
#method_after
protected long remove(Commit<Remove> commit) {
    return primitive(map.remove(commit.value().key()));
}
#end_block

#method_before
protected boolean removeValue(RaftCommit<RemoveValue> commit) {
    Long value = map.get(commit.value().key());
    if (value == null) {
        if (commit.value().value() == 0) {
            map.remove(commit.value().key());
            return true;
        }
        return false;
    } else if (value == commit.value().value()) {
        map.remove(commit.value().key());
        return true;
    }
    return false;
}
#method_after
protected boolean removeValue(Commit<RemoveValue> commit) {
    Long value = map.get(commit.value().key());
    if (value == null) {
        if (commit.value().value() == 0) {
            map.remove(commit.value().key());
            return true;
        }
        return false;
    } else if (value == commit.value().value()) {
        map.remove(commit.value().key());
        return true;
    }
    return false;
}
#end_block

#method_before
protected long getAndIncrement(RaftCommit<GetAndIncrement> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value + 1);
    return value;
}
#method_after
protected long getAndIncrement(Commit<GetAndIncrement> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value + 1);
    return value;
}
#end_block

#method_before
protected long getAndDecrement(RaftCommit<GetAndDecrement> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value - 1);
    return value;
}
#method_after
protected long getAndDecrement(Commit<GetAndDecrement> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value - 1);
    return value;
}
#end_block

#method_before
protected long incrementAndGet(RaftCommit<IncrementAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), ++value);
    return value;
}
#method_after
protected long incrementAndGet(Commit<IncrementAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), ++value);
    return value;
}
#end_block

#method_before
protected long decrementAndGet(RaftCommit<DecrementAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), --value);
    return value;
}
#method_after
protected long decrementAndGet(Commit<DecrementAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), --value);
    return value;
}
#end_block

#method_before
protected long addAndGet(RaftCommit<AddAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    value += commit.value().delta();
    map.put(commit.value().key(), value);
    return value;
}
#method_after
protected long addAndGet(Commit<AddAndGet> commit) {
    long value = primitive(map.get(commit.value().key()));
    value += commit.value().delta();
    map.put(commit.value().key(), value);
    return value;
}
#end_block

#method_before
protected long getAndAdd(RaftCommit<GetAndAdd> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value + commit.value().delta());
    return value;
}
#method_after
protected long getAndAdd(Commit<GetAndAdd> commit) {
    long value = primitive(map.get(commit.value().key()));
    map.put(commit.value().key(), value + commit.value().delta());
    return value;
}
#end_block

#method_before
protected int size(RaftCommit<Void> commit) {
    return map.size();
}
#method_after
protected int size(Commit<Void> commit) {
    return map.size();
}
#end_block

#method_before
protected boolean isEmpty(RaftCommit<Void> commit) {
    return map.isEmpty();
}
#method_after
protected boolean isEmpty(Commit<Void> commit) {
    return map.isEmpty();
}
#end_block

#method_before
protected void clear(RaftCommit<Void> commit) {
    map.clear();
}
#method_after
protected void clear(Commit<Void> commit) {
    map.clear();
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.submit(IS_EMPTY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.invoke(IS_EMPTY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Integer> size() {
    return proxy.submit(SIZE, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Integer> size() {
    return proxy.invoke(SIZE, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.submit(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.invoke(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.submit(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.invoke(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> get(String key) {
    return proxy.submit(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> get(String key) {
    return proxy.invoke(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> getOrDefault(String key, byte[] defaultValue) {
    return proxy.submit(GET_OR_DEFAULT, SERIALIZER::encode, new GetOrDefault(key, defaultValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> getOrDefault(String key, byte[] defaultValue) {
    return proxy.invoke(GET_OR_DEFAULT, SERIALIZER::encode, new GetOrDefault(key, defaultValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.submit(KEY_SET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.invoke(KEY_SET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Versioned<byte[]>>> values() {
    return proxy.submit(VALUES, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Collection<Versioned<byte[]>>> values() {
    return proxy.invoke(VALUES, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Entry<String, Versioned<byte[]>>>> entrySet() {
    return proxy.submit(ENTRY_SET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Set<Entry<String, Versioned<byte[]>>>> entrySet() {
    return proxy.invoke(ENTRY_SET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> put(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> put(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putAndGet(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putAndGet(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putIfAbsent(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putIfAbsent(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> remove(String key) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> remove(String key) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ifValue(value), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ifValue(value), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, long version) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ifValue(version)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, long version) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ifValue(version)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> replace(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NOT_NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> replace(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NOT_NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, byte[] oldValue, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ifValue(oldValue), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, byte[] oldValue, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ifValue(oldValue), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, long oldVersion, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ANY, Match.ifValue(oldVersion)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, long oldVersion, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ANY, Match.ifValue(oldVersion)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Void> clear() {
    return proxy.<MapEntryUpdateResult.Status>submit(CLEAR, SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r)).thenApply(v -> null);
}
#method_after
@Override
public CompletableFuture<Void> clear() {
    return proxy.<MapEntryUpdateResult.Status>invoke(CLEAR, SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r)).thenApply(v -> null);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> computeIf(String key, Predicate<? super byte[]> condition, BiFunction<? super String, ? super byte[], ? extends byte[]> remappingFunction) {
    return get(key).thenCompose(r1 -> {
        byte[] existingValue = r1 == null ? null : r1.value();
        // if the condition evaluates to false, return existing value.
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<byte[]> computedValue = new AtomicReference<>();
        // if remappingFunction throws an exception, return the exception.
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            CompletableFuture<Versioned<byte[]>> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<byte[]> valueMatch = r1 == null ? Match.NULL : Match.ANY;
        Match<Long> versionMatch = r1 == null ? Match.ANY : Match.ifValue(r1.version());
        return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, computedValue.get(), valueMatch, versionMatch), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenCompose(r -> {
            if (r.status() == MapEntryUpdateResult.Status.PRECONDITION_FAILED || r.status() == MapEntryUpdateResult.Status.WRITE_LOCK) {
                return Tools.exceptionalFuture(new ConsistentMapException.ConcurrentModification());
            }
            return CompletableFuture.completedFuture(r);
        }).thenApply(v -> v.newValue());
    });
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> computeIf(String key, Predicate<? super byte[]> condition, BiFunction<? super String, ? super byte[], ? extends byte[]> remappingFunction) {
    return get(key).thenCompose(r1 -> {
        byte[] existingValue = r1 == null ? null : r1.value();
        // if the condition evaluates to false, return existing value.
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<byte[]> computedValue = new AtomicReference<>();
        // if remappingFunction throws an exception, return the exception.
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            CompletableFuture<Versioned<byte[]>> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<byte[]> valueMatch = r1 == null ? Match.NULL : Match.ANY;
        Match<Long> versionMatch = r1 == null ? Match.ANY : Match.ifValue(r1.version());
        return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, computedValue.get(), valueMatch, versionMatch), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenCompose(r -> {
            if (r.status() == MapEntryUpdateResult.Status.PRECONDITION_FAILED || r.status() == MapEntryUpdateResult.Status.WRITE_LOCK) {
                return Tools.exceptionalFuture(new ConsistentMapException.ConcurrentModification());
            }
            return CompletableFuture.completedFuture(r);
        }).thenApply(v -> v.newValue());
    });
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.submit(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#method_after
@Override
public synchronized CompletableFuture<Void> addListener(MapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.invoke(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> removeListener(MapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.submit(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public synchronized CompletableFuture<Void> removeListener(MapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.invoke(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public CompletableFuture<Version> begin(TransactionId transactionId) {
    return proxy.<TransactionBegin, Long>submit(BEGIN, SERIALIZER::encode, new TransactionBegin(transactionId), SERIALIZER::decode).thenApply(Version::new);
}
#method_after
@Override
public CompletableFuture<Version> begin(TransactionId transactionId) {
    return proxy.<TransactionBegin, Long>invoke(BEGIN, SERIALIZER::encode, new TransactionBegin(transactionId), SERIALIZER::decode).thenApply(Version::new);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> prepare(TransactionLog<MapUpdate<String, byte[]>> transactionLog) {
    return proxy.<TransactionPrepare, PrepareResult>submit(PREPARE, SERIALIZER::encode, new TransactionPrepare(transactionLog), SERIALIZER::decode).thenApply(v -> v == PrepareResult.OK);
}
#method_after
@Override
public CompletableFuture<Boolean> prepare(TransactionLog<MapUpdate<String, byte[]>> transactionLog) {
    return proxy.<TransactionPrepare, PrepareResult>invoke(PREPARE, SERIALIZER::encode, new TransactionPrepare(transactionLog), SERIALIZER::decode).thenApply(v -> v == PrepareResult.OK);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> prepareAndCommit(TransactionLog<MapUpdate<String, byte[]>> transactionLog) {
    return proxy.<TransactionPrepareAndCommit, PrepareResult>submit(PREPARE_AND_COMMIT, SERIALIZER::encode, new TransactionPrepareAndCommit(transactionLog), SERIALIZER::decode).thenApply(v -> v == PrepareResult.OK);
}
#method_after
@Override
public CompletableFuture<Boolean> prepareAndCommit(TransactionLog<MapUpdate<String, byte[]>> transactionLog) {
    return proxy.<TransactionPrepareAndCommit, PrepareResult>invoke(PREPARE_AND_COMMIT, SERIALIZER::encode, new TransactionPrepareAndCommit(transactionLog), SERIALIZER::decode).thenApply(v -> v == PrepareResult.OK);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> commit(TransactionId transactionId) {
    return proxy.<TransactionCommit, CommitResult>submit(COMMIT, SERIALIZER::encode, new TransactionCommit(transactionId), SERIALIZER::decode).thenApply(v -> null);
}
#method_after
@Override
public CompletableFuture<Void> commit(TransactionId transactionId) {
    return proxy.<TransactionCommit, CommitResult>invoke(COMMIT, SERIALIZER::encode, new TransactionCommit(transactionId), SERIALIZER::decode).thenApply(v -> null);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> rollback(TransactionId transactionId) {
    return proxy.submit(ROLLBACK, SERIALIZER::encode, new TransactionRollback(transactionId), SERIALIZER::decode).thenApply(v -> null);
}
#method_after
@Override
public CompletableFuture<Void> rollback(TransactionId transactionId) {
    return proxy.invoke(ROLLBACK, SERIALIZER::encode, new TransactionRollback(transactionId), SERIALIZER::decode).thenApply(v -> null);
}
#end_block

#method_before
protected int size(RaftCommit<Void> commit) {
    return backingMap.values().stream().map(valueCollection -> valueCollection.values().size()).collect(Collectors.summingInt(size -> size));
}
#method_after
protected int size(Commit<Void> commit) {
    return backingMap.values().stream().map(valueCollection -> valueCollection.values().size()).collect(Collectors.summingInt(size -> size));
}
#end_block

#method_before
protected boolean isEmpty(RaftCommit<Void> commit) {
    return backingMap.isEmpty();
}
#method_after
protected boolean isEmpty(Commit<Void> commit) {
    return backingMap.isEmpty();
}
#end_block

#method_before
protected boolean containsKey(RaftCommit<? extends ContainsKey> commit) {
    return backingMap.containsKey(commit.value().key());
}
#method_after
protected boolean containsKey(Commit<? extends ContainsKey> commit) {
    return backingMap.containsKey(commit.value().key());
}
#end_block

#method_before
protected boolean containsValue(RaftCommit<? extends ContainsValue> commit) {
    if (backingMap.values().isEmpty()) {
        return false;
    }
    Match<byte[]> match = Match.ifValue(commit.value().value());
    return backingMap.values().stream().anyMatch(valueList -> valueList.values().stream().anyMatch(byteValue -> match.matches(byteValue)));
}
#method_after
protected boolean containsValue(Commit<? extends ContainsValue> commit) {
    if (backingMap.values().isEmpty()) {
        return false;
    }
    Match<byte[]> match = Match.ifValue(commit.value().value());
    return backingMap.values().stream().anyMatch(valueList -> valueList.values().stream().anyMatch(byteValue -> match.matches(byteValue)));
}
#end_block

#method_before
protected boolean containsEntry(RaftCommit<? extends ContainsEntry> commit) {
    MapEntryValue entryValue = backingMap.get(commit.value().key());
    if (entryValue == null) {
        return false;
    } else {
        Match valueMatch = Match.ifValue(commit.value().value());
        return entryValue.values().stream().anyMatch(byteValue -> valueMatch.matches(byteValue));
    }
}
#method_after
protected boolean containsEntry(Commit<? extends ContainsEntry> commit) {
    MapEntryValue entryValue = backingMap.get(commit.value().key());
    if (entryValue == null) {
        return false;
    } else {
        Match valueMatch = Match.ifValue(commit.value().value());
        return entryValue.values().stream().anyMatch(byteValue -> valueMatch.matches(byteValue));
    }
}
#end_block

#method_before
protected void clear(RaftCommit<Void> commit) {
    backingMap.clear();
}
#method_after
protected void clear(Commit<Void> commit) {
    backingMap.clear();
}
#end_block

#method_before
protected Set<String> keySet(RaftCommit<Void> commit) {
    return ImmutableSet.copyOf(backingMap.keySet());
}
#method_after
protected Set<String> keySet(Commit<Void> commit) {
    return ImmutableSet.copyOf(backingMap.keySet());
}
#end_block

#method_before
protected Multiset<String> keys(RaftCommit<Void> commit) {
    Multiset keys = HashMultiset.create();
    backingMap.forEach((key, mapEntryValue) -> {
        keys.add(key, mapEntryValue.values().size());
    });
    return keys;
}
#method_after
protected Multiset<String> keys(Commit<Void> commit) {
    Multiset keys = HashMultiset.create();
    backingMap.forEach((key, mapEntryValue) -> {
        keys.add(key, mapEntryValue.values().size());
    });
    return keys;
}
#end_block

#method_before
protected Multiset<byte[]> values(RaftCommit<Void> commit) {
    return backingMap.values().stream().collect(new HashMultisetValueCollector());
}
#method_after
protected Multiset<byte[]> values(Commit<Void> commit) {
    return backingMap.values().stream().collect(new HashMultisetValueCollector());
}
#end_block

#method_before
protected Collection<Map.Entry<String, byte[]>> entries(RaftCommit<Void> commit) {
    return backingMap.entrySet().stream().collect(new EntrySetCollector());
}
#method_after
protected Collection<Map.Entry<String, byte[]>> entries(Commit<Void> commit) {
    return backingMap.entrySet().stream().collect(new EntrySetCollector());
}
#end_block

#method_before
protected Versioned<Collection<? extends byte[]>> get(RaftCommit<? extends Get> commit) {
    return toVersioned(backingMap.get(commit.value().key()));
}
#method_after
protected Versioned<Collection<? extends byte[]>> get(Commit<? extends Get> commit) {
    return toVersioned(backingMap.get(commit.value().key()));
}
#end_block

#method_before
protected Versioned<Collection<? extends byte[]>> removeAll(RaftCommit<? extends RemoveAll> commit) {
    String key = commit.value().key();
    if (!backingMap.containsKey(key)) {
        return new Versioned<>(Sets.newHashSet(), -1);
    }
    Versioned<Collection<? extends byte[]>> removedValues = backingMap.get(key).addCommit(commit);
    publish(removedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, null, value)).collect(Collectors.toList()));
    return removedValues;
}
#method_after
protected Versioned<Collection<? extends byte[]>> removeAll(Commit<? extends RemoveAll> commit) {
    String key = commit.value().key();
    if (!backingMap.containsKey(key)) {
        return new Versioned<>(Sets.newHashSet(), -1);
    }
    Versioned<Collection<? extends byte[]>> removedValues = backingMap.get(key).addCommit(commit);
    publish(removedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, null, value)).collect(Collectors.toList()));
    return removedValues;
}
#end_block

#method_before
protected boolean multiRemove(RaftCommit<? extends MultiRemove> commit) {
    String key = commit.value().key();
    if (!backingMap.containsKey(key)) {
        return false;
    }
    Versioned<Collection<? extends byte[]>> removedValues = backingMap.get(key).addCommit(commit);
    if (removedValues != null) {
        if (removedValues.value().isEmpty()) {
            backingMap.remove(key);
        }
        publish(removedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, null, value)).collect(Collectors.toList()));
        return true;
    }
    return false;
}
#method_after
protected boolean multiRemove(Commit<? extends MultiRemove> commit) {
    String key = commit.value().key();
    if (!backingMap.containsKey(key)) {
        return false;
    }
    Versioned<Collection<? extends byte[]>> removedValues = backingMap.get(key).addCommit(commit);
    if (removedValues != null) {
        if (removedValues.value().isEmpty()) {
            backingMap.remove(key);
        }
        publish(removedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, null, value)).collect(Collectors.toList()));
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean put(RaftCommit<? extends Put> commit) {
    String key = commit.value().key();
    if (commit.value().values().isEmpty()) {
        return false;
    }
    if (!backingMap.containsKey(key)) {
        backingMap.put(key, new NonTransactionalCommit());
    }
    Versioned<Collection<? extends byte[]>> addedValues = backingMap.get(key).addCommit(commit);
    if (addedValues != null) {
        publish(addedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, value, null)).collect(Collectors.toList()));
        return true;
    }
    return false;
}
#method_after
protected boolean put(Commit<? extends Put> commit) {
    String key = commit.value().key();
    if (commit.value().values().isEmpty()) {
        return false;
    }
    if (!backingMap.containsKey(key)) {
        backingMap.put(key, new NonTransactionalCommit());
    }
    Versioned<Collection<? extends byte[]>> addedValues = backingMap.get(key).addCommit(commit);
    if (addedValues != null) {
        publish(addedValues.value().stream().map(value -> new MultimapEvent<String, byte[]>("", key, value, null)).collect(Collectors.toList()));
        return true;
    }
    return false;
}
#end_block

#method_before
protected Versioned<Collection<? extends byte[]>> replace(RaftCommit<? extends Replace> commit) {
    if (!backingMap.containsKey(commit.value().key())) {
        backingMap.put(commit.value().key(), new NonTransactionalCommit());
    }
    return backingMap.get(commit.value().key()).addCommit(commit);
}
#method_after
protected Versioned<Collection<? extends byte[]>> replace(Commit<? extends Replace> commit) {
    if (!backingMap.containsKey(commit.value().key())) {
        backingMap.put(commit.value().key(), new NonTransactionalCommit());
    }
    return backingMap.get(commit.value().key()).addCommit(commit);
}
#end_block

#method_before
protected void listen(RaftCommit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#method_after
protected void listen(Commit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#end_block

#method_before
protected void unlisten(RaftCommit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#method_after
protected void unlisten(Commit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#end_block

#method_before
@Override
public Versioned<Collection<? extends byte[]>> addCommit(RaftCommit<? extends MultimapOperation> commit) {
    Preconditions.checkNotNull(commit);
    Preconditions.checkNotNull(commit.value());
    Versioned<Collection<? extends byte[]>> retVersion;
    if (commit.value() instanceof Put) {
        // Using a treeset here sanitizes the input, removing duplicates
        Set<byte[]> valuesToAdd = Sets.newTreeSet(new ByteArrayComparator());
        ((Put) commit.value()).values().forEach(value -> {
            if (!valueSet.contains(value)) {
                valuesToAdd.add(value);
            }
        });
        if (valuesToAdd.isEmpty()) {
            // Do not increment or add the commit if no change resulted
            return null;
        }
        retVersion = new Versioned<>(valuesToAdd, version);
        valuesToAdd.forEach(value -> valueSet.add(value));
        version++;
        return retVersion;
    } else if (commit.value() instanceof Replace) {
        // Will this work??  Need to check before check-in!
        Set<byte[]> removedValues = Sets.newHashSet();
        removedValues.addAll(valueSet);
        retVersion = new Versioned<>(removedValues, version);
        valueSet.clear();
        Set<byte[]> valuesToAdd = Sets.newTreeSet(new ByteArrayComparator());
        ((Replace) commit.value()).values().forEach(value -> {
            valuesToAdd.add(value);
        });
        if (valuesToAdd.isEmpty()) {
            version = globalVersion.incrementAndGet();
            backingMap.remove(((Replace) commit.value()).key());
            return retVersion;
        }
        valuesToAdd.forEach(value -> valueSet.add(value));
        version = globalVersion.incrementAndGet();
        return retVersion;
    } else if (commit.value() instanceof RemoveAll) {
        Set<byte[]> removed = Sets.newHashSet();
        // We can assume here that values only appear once and so we
        // do not need to sanitize the return for duplicates.
        removed.addAll(valueSet);
        retVersion = new Versioned<>(removed, version);
        valueSet.clear();
        // In the case of a removeAll all commits will be removed and
        // unlike the multiRemove case we do not need to consider
        // dependencies among additive and removal commits.
        // Save the key for use after the commit is closed
        String key = ((RemoveAll) commit.value()).key();
        version = globalVersion.incrementAndGet();
        backingMap.remove(key);
        return retVersion;
    } else if (commit.value() instanceof MultiRemove) {
        // Must first calculate how many commits the removal depends on.
        // At this time we also sanitize the removal set by adding to a
        // set with proper handling of byte[] equality.
        Set<byte[]> removed = Sets.newHashSet();
        ((MultiRemove) commit.value()).values().forEach(value -> {
            if (valueSet.contains(value)) {
                removed.add(value);
            }
        });
        // If there is nothing to be removed no action should be taken.
        if (removed.isEmpty()) {
            return null;
        }
        // Save key in case countdown results in closing the commit.
        String removedKey = ((MultiRemove) commit.value()).key();
        removed.forEach(removedValue -> {
            valueSet.remove(removedValue);
        });
        // The version is updated locally as well as globally even if
        // this object will be removed from the map in case any other
        // party still holds a reference to this object.
        retVersion = new Versioned<>(removed, version);
        version = globalVersion.incrementAndGet();
        if (valueSet.isEmpty()) {
            backingMap.remove(removedKey);
        }
        return retVersion;
    } else {
        throw new IllegalArgumentException();
    }
}
#method_after
@Override
public Versioned<Collection<? extends byte[]>> addCommit(Commit<? extends MultimapOperation> commit) {
    Preconditions.checkNotNull(commit);
    Preconditions.checkNotNull(commit.value());
    Versioned<Collection<? extends byte[]>> retVersion;
    if (commit.value() instanceof Put) {
        // Using a treeset here sanitizes the input, removing duplicates
        Set<byte[]> valuesToAdd = Sets.newTreeSet(new ByteArrayComparator());
        ((Put) commit.value()).values().forEach(value -> {
            if (!valueSet.contains(value)) {
                valuesToAdd.add(value);
            }
        });
        if (valuesToAdd.isEmpty()) {
            // Do not increment or add the commit if no change resulted
            return null;
        }
        retVersion = new Versioned<>(valuesToAdd, version);
        valuesToAdd.forEach(value -> valueSet.add(value));
        version++;
        return retVersion;
    } else if (commit.value() instanceof Replace) {
        // Will this work??  Need to check before check-in!
        Set<byte[]> removedValues = Sets.newHashSet();
        removedValues.addAll(valueSet);
        retVersion = new Versioned<>(removedValues, version);
        valueSet.clear();
        Set<byte[]> valuesToAdd = Sets.newTreeSet(new ByteArrayComparator());
        ((Replace) commit.value()).values().forEach(value -> {
            valuesToAdd.add(value);
        });
        if (valuesToAdd.isEmpty()) {
            version = globalVersion.incrementAndGet();
            backingMap.remove(((Replace) commit.value()).key());
            return retVersion;
        }
        valuesToAdd.forEach(value -> valueSet.add(value));
        version = globalVersion.incrementAndGet();
        return retVersion;
    } else if (commit.value() instanceof RemoveAll) {
        Set<byte[]> removed = Sets.newHashSet();
        // We can assume here that values only appear once and so we
        // do not need to sanitize the return for duplicates.
        removed.addAll(valueSet);
        retVersion = new Versioned<>(removed, version);
        valueSet.clear();
        // In the case of a removeAll all commits will be removed and
        // unlike the multiRemove case we do not need to consider
        // dependencies among additive and removal commits.
        // Save the key for use after the commit is closed
        String key = ((RemoveAll) commit.value()).key();
        version = globalVersion.incrementAndGet();
        backingMap.remove(key);
        return retVersion;
    } else if (commit.value() instanceof MultiRemove) {
        // Must first calculate how many commits the removal depends on.
        // At this time we also sanitize the removal set by adding to a
        // set with proper handling of byte[] equality.
        Set<byte[]> removed = Sets.newHashSet();
        ((MultiRemove) commit.value()).values().forEach(value -> {
            if (valueSet.contains(value)) {
                removed.add(value);
            }
        });
        // If there is nothing to be removed no action should be taken.
        if (removed.isEmpty()) {
            return null;
        }
        // Save key in case countdown results in closing the commit.
        String removedKey = ((MultiRemove) commit.value()).key();
        removed.forEach(removedValue -> {
            valueSet.remove(removedValue);
        });
        // The version is updated locally as well as globally even if
        // this object will be removed from the map in case any other
        // party still holds a reference to this object.
        retVersion = new Versioned<>(removed, version);
        version = globalVersion.incrementAndGet();
        if (valueSet.isEmpty()) {
            backingMap.remove(removedKey);
        }
        return retVersion;
    } else {
        throw new IllegalArgumentException();
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Long> get() {
    return proxy.<Long>submit(GET, SERIALIZER::decode).thenApply(this::nullOrZero);
}
#method_after
@Override
public CompletableFuture<Long> get() {
    return proxy.<Long>invoke(GET, SERIALIZER::decode).thenApply(this::nullOrZero);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> set(long value) {
    return proxy.submit(SET, SERIALIZER::encode, new Set(value));
}
#method_after
@Override
public CompletableFuture<Void> set(long value) {
    return proxy.invoke(SET, SERIALIZER::encode, new Set(value));
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> compareAndSet(long expectedValue, long updateValue) {
    return proxy.submit(COMPARE_AND_SET, SERIALIZER::encode, new CompareAndSet(expectedValue, updateValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> compareAndSet(long expectedValue, long updateValue) {
    return proxy.invoke(COMPARE_AND_SET, SERIALIZER::encode, new CompareAndSet(expectedValue, updateValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> addAndGet(long delta) {
    return proxy.submit(ADD_AND_GET, SERIALIZER::encode, new AddAndGet(delta), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> addAndGet(long delta) {
    return proxy.invoke(ADD_AND_GET, SERIALIZER::encode, new AddAndGet(delta), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndAdd(long delta) {
    return proxy.submit(GET_AND_ADD, SERIALIZER::encode, new GetAndAdd(delta), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> getAndAdd(long delta) {
    return proxy.invoke(GET_AND_ADD, SERIALIZER::encode, new GetAndAdd(delta), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> incrementAndGet() {
    return proxy.submit(INCREMENT_AND_GET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> incrementAndGet() {
    return proxy.invoke(INCREMENT_AND_GET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndIncrement() {
    return proxy.submit(GET_AND_INCREMENT, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> getAndIncrement() {
    return proxy.invoke(GET_AND_INCREMENT, SERIALIZER::decode);
}
#end_block

#method_before
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    DefaultServiceContext context = mock(DefaultServiceContext.class);
    expect(context.serviceType()).andReturn(ServiceType.from(LEADER_ELECTOR.name())).anyTimes();
    expect(context.serviceName()).andReturn("test").anyTimes();
    expect(context.serviceId()).andReturn(ServiceId.from(1)).anyTimes();
    expect(context.executor()).andReturn(mock(ThreadContext.class)).anyTimes();
    RaftServerContext server = mock(RaftServerContext.class);
    expect(server.getProtocol()).andReturn(mock(RaftServerProtocol.class));
    replay(context, server);
    AtomixLeaderElectorService service = new AtomixLeaderElectorService();
    service.init(context);
    NodeId nodeId = NodeId.nodeId("1");
    service.run(new DefaultRaftCommit<>(2, RUN, new AtomixLeaderElectorOperations.Run("test", nodeId), new RaftSessionContext(SessionId.from(1), MemberId.from("1"), "test", ServiceType.from(LEADER_ELECTOR.name()), ReadConsistency.LINEARIZABLE, 5000, context, server), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixLeaderElectorService();
    service.init(context);
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Leadership value = service.getLeadership(new DefaultRaftCommit<>(2, GET_LEADERSHIP, new AtomixLeaderElectorOperations.GetLeadership("test"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(value.leader().nodeId(), nodeId);
}
#method_after
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    DefaultServiceContext context = mock(DefaultServiceContext.class);
    expect(context.serviceType()).andReturn(ServiceType.from(LEADER_ELECTOR.name())).anyTimes();
    expect(context.serviceName()).andReturn("test").anyTimes();
    expect(context.serviceId()).andReturn(ServiceId.from(1)).anyTimes();
    expect(context.executor()).andReturn(mock(ThreadContext.class)).anyTimes();
    RaftServerContext server = mock(RaftServerContext.class);
    expect(server.getProtocol()).andReturn(mock(RaftServerProtocol.class));
    replay(context, server);
    AtomixLeaderElectorService service = new AtomixLeaderElectorService();
    service.init(context);
    NodeId nodeId = NodeId.nodeId("1");
    service.run(new DefaultCommit<>(2, RUN, new AtomixLeaderElectorOperations.Run("test", nodeId), new RaftSessionContext(SessionId.from(1), MemberId.from("1"), "test", ServiceType.from(LEADER_ELECTOR.name()), ReadConsistency.LINEARIZABLE, 5000, context, server), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixLeaderElectorService();
    service.init(context);
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Leadership value = service.getLeadership(new DefaultCommit<>(2, GET_LEADERSHIP, new AtomixLeaderElectorOperations.GetLeadership("test"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(value.leader().nodeId(), nodeId);
}
#end_block

#method_before
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    DefaultServiceContext context = mock(DefaultServiceContext.class);
    expect(context.serviceType()).andReturn(ServiceType.from(WORK_QUEUE.name())).anyTimes();
    expect(context.serviceName()).andReturn("test").anyTimes();
    expect(context.serviceId()).andReturn(ServiceId.from(1)).anyTimes();
    expect(context.executor()).andReturn(mock(ThreadContext.class)).anyTimes();
    RaftServerContext server = mock(RaftServerContext.class);
    expect(server.getProtocol()).andReturn(mock(RaftServerProtocol.class));
    replay(context, server);
    RaftSessionContext session = new RaftSessionContext(SessionId.from(1), MemberId.from("1"), "test", ServiceType.from(WORK_QUEUE.name()), ReadConsistency.LINEARIZABLE, 5000, context, server);
    AtomixWorkQueueService service = new AtomixWorkQueueService();
    service.init(context);
    service.add(new DefaultRaftCommit<>(2, ADD, new AtomixWorkQueueOperations.Add(Arrays.asList("Hello world!".getBytes())), session, System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixWorkQueueService();
    service.init(context);
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Collection<Task<byte[]>> value = service.take(new DefaultRaftCommit<>(2, TAKE, new AtomixWorkQueueOperations.Take(1), session, System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(1, value.size());
    assertArrayEquals("Hello world!".getBytes(), value.iterator().next().payload());
}
#method_after
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    DefaultServiceContext context = mock(DefaultServiceContext.class);
    expect(context.serviceType()).andReturn(ServiceType.from(WORK_QUEUE.name())).anyTimes();
    expect(context.serviceName()).andReturn("test").anyTimes();
    expect(context.serviceId()).andReturn(ServiceId.from(1)).anyTimes();
    expect(context.executor()).andReturn(mock(ThreadContext.class)).anyTimes();
    RaftServerContext server = mock(RaftServerContext.class);
    expect(server.getProtocol()).andReturn(mock(RaftServerProtocol.class));
    replay(context, server);
    RaftSessionContext session = new RaftSessionContext(SessionId.from(1), MemberId.from("1"), "test", ServiceType.from(WORK_QUEUE.name()), ReadConsistency.LINEARIZABLE, 5000, context, server);
    AtomixWorkQueueService service = new AtomixWorkQueueService();
    service.init(context);
    service.add(new DefaultCommit<>(2, ADD, new AtomixWorkQueueOperations.Add(Arrays.asList("Hello world!".getBytes())), session, System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixWorkQueueService();
    service.init(context);
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Collection<Task<byte[]>> value = service.take(new DefaultCommit<>(2, TAKE, new AtomixWorkQueueOperations.Take(1), session, System.currentTimeMillis()));
    assertNotNull(value);
    assertEquals(1, value.size());
    assertArrayEquals("Hello world!".getBytes(), value.iterator().next().payload());
}
#end_block

#method_before
protected void basicOperationsTest() throws Throwable {
    AtomixCounter along = newPrimitive("test-long-basic-operations");
    assertEquals(0, along.get().join().longValue());
    assertEquals(1, along.incrementAndGet().join().longValue());
    along.set(100).join();
    assertEquals(100, along.get().join().longValue());
    assertEquals(100, along.getAndAdd(10).join().longValue());
    assertEquals(110, along.get().join().longValue());
    assertFalse(along.compareAndSet(109, 111).join());
    assertTrue(along.compareAndSet(110, 111).join());
    assertEquals(100, along.addAndGet(-11).join().longValue());
    assertEquals(100, along.getAndIncrement().join().longValue());
    assertEquals(101, along.get().join().longValue());
}
#method_after
protected void basicOperationsTest() throws Throwable {
    AtomixCounter along = newPrimitive("test-counter-basic-operations");
    assertEquals(0, along.get().join().longValue());
    assertEquals(1, along.incrementAndGet().join().longValue());
    along.set(100).join();
    assertEquals(100, along.get().join().longValue());
    assertEquals(100, along.getAndAdd(10).join().longValue());
    assertEquals(110, along.get().join().longValue());
    assertFalse(along.compareAndSet(109, 111).join());
    assertTrue(along.compareAndSet(110, 111).join());
    assertEquals(100, along.addAndGet(-11).join().longValue());
    assertEquals(100, along.getAndIncrement().join().longValue());
    assertEquals(101, along.get().join().longValue());
}
#end_block

#method_before
protected WorkQueueStats stats(RaftCommit<Void> commit) {
    return WorkQueueStats.builder().withTotalCompleted(totalCompleted.get()).withTotalPending(unassignedTasks.size()).withTotalInProgress(assignments.size()).build();
}
#method_after
protected WorkQueueStats stats(Commit<Void> commit) {
    return WorkQueueStats.builder().withTotalCompleted(totalCompleted.get()).withTotalPending(unassignedTasks.size()).withTotalInProgress(assignments.size()).build();
}
#end_block

#method_before
protected void clear(RaftCommit<Void> commit) {
    unassignedTasks.clear();
    assignments.clear();
    registeredWorkers.clear();
    totalCompleted.set(0);
}
#method_after
protected void clear(Commit<Void> commit) {
    unassignedTasks.clear();
    assignments.clear();
    registeredWorkers.clear();
    totalCompleted.set(0);
}
#end_block

#method_before
protected void register(RaftCommit<Void> commit) {
    registeredWorkers.put(commit.session().sessionId().id(), commit.session());
}
#method_after
protected void register(Commit<Void> commit) {
    registeredWorkers.put(commit.session().sessionId().id(), commit.session());
}
#end_block

#method_before
protected void unregister(RaftCommit<Void> commit) {
    registeredWorkers.remove(commit.session().sessionId().id());
}
#method_after
protected void unregister(Commit<Void> commit) {
    registeredWorkers.remove(commit.session().sessionId().id());
}
#end_block

#method_before
protected void add(RaftCommit<? extends Add> commit) {
    Collection<byte[]> items = commit.value().items();
    AtomicInteger itemIndex = new AtomicInteger(0);
    items.forEach(item -> {
        String taskId = String.format("%d:%d:%d", commit.session().sessionId().id(), commit.index(), itemIndex.getAndIncrement());
        unassignedTasks.add(new Task<>(taskId, item));
    });
    // Send an event to all sessions that have expressed interest in task processing
    // and are not actively processing a task.
    registeredWorkers.values().forEach(session -> session.publish(TASK_AVAILABLE));
// FIXME: This generates a lot of event traffic.
}
#method_after
protected void add(Commit<? extends Add> commit) {
    Collection<byte[]> items = commit.value().items();
    AtomicInteger itemIndex = new AtomicInteger(0);
    items.forEach(item -> {
        String taskId = String.format("%d:%d:%d", commit.session().sessionId().id(), commit.index(), itemIndex.getAndIncrement());
        unassignedTasks.add(new Task<>(taskId, item));
    });
    // Send an event to all sessions that have expressed interest in task processing
    // and are not actively processing a task.
    registeredWorkers.values().forEach(session -> session.publish(TASK_AVAILABLE));
// FIXME: This generates a lot of event traffic.
}
#end_block

#method_before
protected Collection<Task<byte[]>> take(RaftCommit<? extends Take> commit) {
    try {
        if (unassignedTasks.isEmpty()) {
            return ImmutableList.of();
        }
        long sessionId = commit.session().sessionId().id();
        int maxTasks = commit.value().maxTasks();
        return IntStream.range(0, Math.min(maxTasks, unassignedTasks.size())).mapToObj(i -> {
            Task<byte[]> task = unassignedTasks.poll();
            String taskId = task.taskId();
            TaskAssignment assignment = new TaskAssignment(sessionId, task);
            // bookkeeping
            assignments.put(taskId, assignment);
            return task;
        }).collect(Collectors.toCollection(ArrayList::new));
    } catch (Exception e) {
        getLogger().warn("State machine update failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
protected Collection<Task<byte[]>> take(Commit<? extends Take> commit) {
    try {
        if (unassignedTasks.isEmpty()) {
            return ImmutableList.of();
        }
        long sessionId = commit.session().sessionId().id();
        int maxTasks = commit.value().maxTasks();
        return IntStream.range(0, Math.min(maxTasks, unassignedTasks.size())).mapToObj(i -> {
            Task<byte[]> task = unassignedTasks.poll();
            String taskId = task.taskId();
            TaskAssignment assignment = new TaskAssignment(sessionId, task);
            // bookkeeping
            assignments.put(taskId, assignment);
            return task;
        }).collect(Collectors.toCollection(ArrayList::new));
    } catch (Exception e) {
        getLogger().warn("State machine update failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
protected void complete(RaftCommit<? extends Complete> commit) {
    long sessionId = commit.session().sessionId().id();
    try {
        commit.value().taskIds().forEach(taskId -> {
            TaskAssignment assignment = assignments.get(taskId);
            if (assignment != null && assignment.sessionId() == sessionId) {
                assignments.remove(taskId);
                // bookkeeping
                totalCompleted.incrementAndGet();
            }
        });
    } catch (Exception e) {
        getLogger().warn("State machine update failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
protected void complete(Commit<? extends Complete> commit) {
    long sessionId = commit.session().sessionId().id();
    try {
        commit.value().taskIds().forEach(taskId -> {
            TaskAssignment assignment = assignments.get(taskId);
            if (assignment != null && assignment.sessionId() == sessionId) {
                assignments.remove(taskId);
                // bookkeeping
                totalCompleted.incrementAndGet();
            }
        });
    } catch (Exception e) {
        getLogger().warn("State machine update failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Integer> size() {
    return proxy.submit(SIZE, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Integer> size() {
    return proxy.invoke(SIZE, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.submit(IS_EMPTY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.invoke(IS_EMPTY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.submit(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.invoke(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.submit(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.invoke(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsEntry(String key, byte[] value) {
    return proxy.submit(CONTAINS_ENTRY, SERIALIZER::encode, new ContainsEntry(key, value), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsEntry(String key, byte[] value) {
    return proxy.invoke(CONTAINS_ENTRY, SERIALIZER::encode, new ContainsEntry(key, value), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> put(String key, byte[] value) {
    return proxy.submit(PUT, SERIALIZER::encode, new Put(key, Lists.newArrayList(value), null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> put(String key, byte[] value) {
    return proxy.invoke(PUT, SERIALIZER::encode, new Put(key, Lists.newArrayList(value), null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.submit(REMOVE, SERIALIZER::encode, new MultiRemove(key, Lists.newArrayList(value), null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.invoke(REMOVE, SERIALIZER::encode, new MultiRemove(key, Lists.newArrayList(value), null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> removeAll(String key, Collection<? extends byte[]> values) {
    return proxy.submit(REMOVE, SERIALIZER::encode, new MultiRemove(key, (Collection<byte[]>) values, null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> removeAll(String key, Collection<? extends byte[]> values) {
    return proxy.invoke(REMOVE, SERIALIZER::encode, new MultiRemove(key, (Collection<byte[]>) values, null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> removeAll(String key) {
    return proxy.submit(REMOVE_ALL, SERIALIZER::encode, new RemoveAll(key, null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> removeAll(String key) {
    return proxy.invoke(REMOVE_ALL, SERIALIZER::encode, new RemoveAll(key, null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> putAll(String key, Collection<? extends byte[]> values) {
    return proxy.submit(PUT, SERIALIZER::encode, new Put(key, values, null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> putAll(String key, Collection<? extends byte[]> values) {
    return proxy.invoke(PUT, SERIALIZER::encode, new Put(key, values, null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> replaceValues(String key, Collection<byte[]> values) {
    return proxy.submit(REPLACE, SERIALIZER::encode, new Replace(key, values, null), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> replaceValues(String key, Collection<byte[]> values) {
    return proxy.invoke(REPLACE, SERIALIZER::encode, new Replace(key, values, null), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> clear() {
    return proxy.submit(CLEAR);
}
#method_after
@Override
public CompletableFuture<Void> clear() {
    return proxy.invoke(CLEAR);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> get(String key) {
    return proxy.submit(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<Collection<? extends byte[]>>> get(String key) {
    return proxy.invoke(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.submit(KEY_SET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.invoke(KEY_SET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Multiset<String>> keys() {
    return proxy.submit(KEYS, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Multiset<String>> keys() {
    return proxy.invoke(KEYS, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Multiset<byte[]>> values() {
    return proxy.submit(VALUES, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Multiset<byte[]>> values() {
    return proxy.invoke(VALUES, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Map.Entry<String, byte[]>>> entries() {
    return proxy.submit(ENTRIES, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Collection<Map.Entry<String, byte[]>>> entries() {
    return proxy.invoke(ENTRIES, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> addListener(MultimapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.submit(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#method_after
@Override
public CompletableFuture<Void> addListener(MultimapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.invoke(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.submit(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(MultimapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.invoke(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> destroy() {
    return proxy.submit(CLEAR);
}
#method_after
@Override
public CompletableFuture<Void> destroy() {
    return proxy.invoke(CLEAR);
}
#end_block

#method_before
@Override
public CompletableFuture<Map<String, Versioned<byte[]>>> getChildren(DocumentPath path) {
    return proxy.submit(GET_CHILDREN, SERIALIZER::encode, new GetChildren(checkNotNull(path)), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map<String, Versioned<byte[]>>> getChildren(DocumentPath path) {
    return proxy.invoke(GET_CHILDREN, SERIALIZER::encode, new GetChildren(checkNotNull(path)), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> get(DocumentPath path) {
    return proxy.submit(GET, SERIALIZER::encode, new Get(checkNotNull(path)), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> get(DocumentPath path) {
    return proxy.invoke(GET, SERIALIZER::encode, new Get(checkNotNull(path)), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> set(DocumentPath path, byte[] value) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>submit(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(value), Match.any(), Match.any()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.oldValue());
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> set(DocumentPath path, byte[] value) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>invoke(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(value), Match.any(), Match.any()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.oldValue());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> replace(DocumentPath path, byte[] newValue, long version) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>submit(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(newValue), Match.any(), Match.ifValue(version)), SERIALIZER::decode).thenApply(result -> result.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> replace(DocumentPath path, byte[] newValue, long version) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>invoke(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(newValue), Match.any(), Match.ifValue(version)), SERIALIZER::decode).thenApply(result -> result.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> replace(DocumentPath path, byte[] newValue, byte[] currentValue) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>submit(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(newValue), Match.ifValue(currentValue), Match.any()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.updated());
}
#method_after
@Override
public CompletableFuture<Boolean> replace(DocumentPath path, byte[] newValue, byte[] currentValue) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>invoke(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(newValue), Match.ifValue(currentValue), Match.any()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> removeNode(DocumentPath path) {
    if (path.equals(DocumentPath.from("root"))) {
        return Tools.exceptionalFuture(new IllegalDocumentModificationException());
    }
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>submit(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), null, Match.any(), Match.ifNotNull()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.oldValue());
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> removeNode(DocumentPath path) {
    if (path.equals(DocumentPath.from("root"))) {
        return Tools.exceptionalFuture(new IllegalDocumentModificationException());
    }
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>invoke(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), null, Match.any(), Match.ifNotNull()), SERIALIZER::decode).thenCompose(result -> {
        if (result.status() == INVALID_PATH) {
            return Tools.exceptionalFuture(new NoSuchDocumentPathException());
        } else if (result.status() == ILLEGAL_MODIFICATION) {
            return Tools.exceptionalFuture(new IllegalDocumentModificationException());
        } else {
            return CompletableFuture.completedFuture(result);
        }
    }).thenApply(result -> result.oldValue());
}
#end_block

#method_before
@Override
public CompletableFuture<Void> addListener(DocumentPath path, DocumentTreeListener<byte[]> listener) {
    checkNotNull(path);
    checkNotNull(listener);
    InternalListener internalListener = new InternalListener(path, listener, MoreExecutors.directExecutor());
    // TODO: Support API that takes an executor
    if (!eventListeners.containsKey(listener)) {
        return proxy.submit(ADD_LISTENER, SERIALIZER::encode, new Listen(path)).thenRun(() -> eventListeners.put(listener, internalListener));
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> addListener(DocumentPath path, DocumentTreeListener<byte[]> listener) {
    checkNotNull(path);
    checkNotNull(listener);
    InternalListener internalListener = new InternalListener(path, listener, MoreExecutors.directExecutor());
    // TODO: Support API that takes an executor
    if (!eventListeners.containsKey(listener)) {
        return proxy.invoke(ADD_LISTENER, SERIALIZER::encode, new Listen(path)).thenRun(() -> eventListeners.put(listener, internalListener));
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> removeListener(DocumentTreeListener<byte[]> listener) {
    checkNotNull(listener);
    InternalListener internalListener = eventListeners.remove(listener);
    if (internalListener != null && eventListeners.isEmpty()) {
        return proxy.submit(REMOVE_LISTENER, SERIALIZER::encode, new Unlisten(internalListener.path)).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public CompletableFuture<Void> removeListener(DocumentTreeListener<byte[]> listener) {
    checkNotNull(listener);
    InternalListener internalListener = eventListeners.remove(listener);
    if (internalListener != null && eventListeners.isEmpty()) {
        return proxy.invoke(REMOVE_LISTENER, SERIALIZER::encode, new Unlisten(internalListener.path)).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
private CompletableFuture<DocumentTreeUpdateResult.Status> createInternal(DocumentPath path, byte[] value) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>submit(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(value), Match.any(), Match.ifNull()), SERIALIZER::decode).thenApply(result -> result.status());
}
#method_after
private CompletableFuture<DocumentTreeUpdateResult.Status> createInternal(DocumentPath path, byte[] value) {
    return proxy.<Update, DocumentTreeUpdateResult<byte[]>>invoke(UPDATE, SERIALIZER::encode, new Update(checkNotNull(path), Optional.ofNullable(value), Match.any(), Match.ifNull()), SERIALIZER::decode).thenApply(result -> result.status());
}
#end_block

#method_before
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixCounterService service = new AtomixCounterService();
    service.set(new DefaultRaftCommit<>(2, SET, new AtomixCounterOperations.Set(1L), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixCounterService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    long value = service.get(new DefaultRaftCommit<>(2, GET, null, mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertEquals(1, value);
}
#method_after
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixCounterService service = new AtomixCounterService();
    service.set(new DefaultCommit<>(2, SET, new AtomixCounterOperations.Set(1L), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixCounterService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    long value = service.get(new DefaultCommit<>(2, GET, null, mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertEquals(1, value);
}
#end_block

#method_before
private RaftServer buildServer() {
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName("partition-" + partition.getId()).withProtocol(protocol.get()).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.DISK).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(dataFolder).withMaxEntriesPerSegment(MAX_ENTRIES_PER_LOG_SEGMENT).build());
    StoragePartition.STATE_MACHINES.forEach(builder::addService);
    return builder.build();
}
#method_after
private RaftServer buildServer() {
    RaftServer.Builder builder = RaftServer.newBuilder(localMemberId).withName("partition-" + partition.getId()).withProtocol(protocol.get()).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.DISK).withSerializer(new AtomixSerializerAdapter(Serializer.using(StorageNamespaces.RAFT_STORAGE))).withDirectory(dataFolder).withMaxEntriesPerSegment(MAX_ENTRIES_PER_LOG_SEGMENT).build());
    StoragePartition.RAFT_SERVICES.forEach(builder::addService);
    return builder.build();
}
#end_block

#method_before
protected boolean containsKey(RaftCommit<? extends ContainsKey> commit) {
    return toVersioned(tree.get((commit.value().key()))) != null;
}
#method_after
protected boolean containsKey(Commit<? extends ContainsKey> commit) {
    return toVersioned(tree.get((commit.value().key()))) != null;
}
#end_block

#method_before
protected boolean containsValue(RaftCommit<? extends ContainsValue> commit) {
    Match<byte[]> valueMatch = Match.ifValue(commit.value().value());
    return tree.values().stream().anyMatch(value -> valueMatch.matches(value.value()));
}
#method_after
protected boolean containsValue(Commit<? extends ContainsValue> commit) {
    Match<byte[]> valueMatch = Match.ifValue(commit.value().value());
    return tree.values().stream().anyMatch(value -> valueMatch.matches(value.value()));
}
#end_block

#method_before
protected Versioned<byte[]> get(RaftCommit<? extends Get> commit) {
    return toVersioned(tree.get(commit.value().key()));
}
#method_after
protected Versioned<byte[]> get(Commit<? extends Get> commit) {
    return toVersioned(tree.get(commit.value().key()));
}
#end_block

#method_before
protected Versioned<byte[]> getOrDefault(RaftCommit<? extends GetOrDefault> commit) {
    Versioned<byte[]> value = toVersioned(tree.get(commit.value().key()));
    return value != null ? value : new Versioned<>(commit.value().defaultValue(), 0);
}
#method_after
protected Versioned<byte[]> getOrDefault(Commit<? extends GetOrDefault> commit) {
    Versioned<byte[]> value = toVersioned(tree.get(commit.value().key()));
    return value != null ? value : new Versioned<>(commit.value().defaultValue(), 0);
}
#end_block

#method_before
protected int size(RaftCommit<Void> commit) {
    return tree.size();
}
#method_after
protected int size(Commit<Void> commit) {
    return tree.size();
}
#end_block

#method_before
protected boolean isEmpty(RaftCommit<Void> commit) {
    return tree.isEmpty();
}
#method_after
protected boolean isEmpty(Commit<Void> commit) {
    return tree.isEmpty();
}
#end_block

#method_before
protected Set<String> keySet(RaftCommit<Void> commit) {
    return tree.keySet().stream().collect(Collectors.toSet());
}
#method_after
protected Set<String> keySet(Commit<Void> commit) {
    return tree.keySet().stream().collect(Collectors.toSet());
}
#end_block

#method_before
protected Collection<Versioned<byte[]>> values(RaftCommit<Void> commit) {
    return tree.values().stream().map(this::toVersioned).collect(Collectors.toList());
}
#method_after
protected Collection<Versioned<byte[]>> values(Commit<Void> commit) {
    return tree.values().stream().map(this::toVersioned).collect(Collectors.toList());
}
#end_block

#method_before
protected Set<Map.Entry<String, Versioned<byte[]>>> entrySet(RaftCommit<Void> commit) {
    return tree.entrySet().stream().map(e -> Maps.immutableEntry(e.getKey(), toVersioned(e.getValue()))).collect(Collectors.toSet());
}
#method_after
protected Set<Map.Entry<String, Versioned<byte[]>>> entrySet(Commit<Void> commit) {
    return tree.entrySet().stream().map(e -> Maps.immutableEntry(e.getKey(), toVersioned(e.getValue()))).collect(Collectors.toSet());
}
#end_block

#method_before
protected MapEntryUpdateResult<String, byte[]> updateAndGet(RaftCommit<? extends UpdateAndGet> commit) {
    Status updateStatus = validate(commit.value());
    String key = commit.value().key();
    TreeMapEntryValue oldCommitValue = tree.get(commit.value().key());
    Versioned<byte[]> oldTreeValue = toVersioned(oldCommitValue);
    if (updateStatus != Status.OK) {
        return new MapEntryUpdateResult<>(updateStatus, "", key, oldTreeValue, oldTreeValue);
    }
    byte[] newValue = commit.value().value();
    long newVersion = commit.index();
    Versioned<byte[]> newTreeValue = newValue == null ? null : new Versioned<byte[]>(newValue, newVersion);
    MapEvent.Type updateType = newValue == null ? MapEvent.Type.REMOVE : oldCommitValue == null ? MapEvent.Type.INSERT : MapEvent.Type.UPDATE;
    if (updateType == MapEvent.Type.REMOVE || updateType == MapEvent.Type.UPDATE) {
        tree.remove(key);
    }
    if (updateType == MapEvent.Type.INSERT || updateType == MapEvent.Type.UPDATE) {
        tree.put(key, new TreeMapEntryValue(newVersion, commit.value().value()));
    }
    publish(Lists.newArrayList(new MapEvent<>("", key, newTreeValue, oldTreeValue)));
    return new MapEntryUpdateResult<>(updateStatus, "", key, oldTreeValue, newTreeValue);
}
#method_after
protected MapEntryUpdateResult<String, byte[]> updateAndGet(Commit<? extends UpdateAndGet> commit) {
    Status updateStatus = validate(commit.value());
    String key = commit.value().key();
    TreeMapEntryValue oldCommitValue = tree.get(commit.value().key());
    Versioned<byte[]> oldTreeValue = toVersioned(oldCommitValue);
    if (updateStatus != Status.OK) {
        return new MapEntryUpdateResult<>(updateStatus, "", key, oldTreeValue, oldTreeValue);
    }
    byte[] newValue = commit.value().value();
    long newVersion = commit.index();
    Versioned<byte[]> newTreeValue = newValue == null ? null : new Versioned<byte[]>(newValue, newVersion);
    MapEvent.Type updateType = newValue == null ? MapEvent.Type.REMOVE : oldCommitValue == null ? MapEvent.Type.INSERT : MapEvent.Type.UPDATE;
    if (updateType == MapEvent.Type.REMOVE || updateType == MapEvent.Type.UPDATE) {
        tree.remove(key);
    }
    if (updateType == MapEvent.Type.INSERT || updateType == MapEvent.Type.UPDATE) {
        tree.put(key, new TreeMapEntryValue(newVersion, commit.value().value()));
    }
    publish(Lists.newArrayList(new MapEvent<>("", key, newTreeValue, oldTreeValue)));
    return new MapEntryUpdateResult<>(updateStatus, "", key, oldTreeValue, newTreeValue);
}
#end_block

#method_before
protected Status clear(RaftCommit<Void> commit) {
    Iterator<Map.Entry<String, TreeMapEntryValue>> iterator = tree.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, TreeMapEntryValue> entry = iterator.next();
        String key = entry.getKey();
        TreeMapEntryValue value = entry.getValue();
        Versioned<byte[]> removedValue = new Versioned<byte[]>(value.value(), value.version());
        publish(Lists.newArrayList(new MapEvent<>("", key, null, removedValue)));
        iterator.remove();
    }
    return Status.OK;
}
#method_after
protected Status clear(Commit<Void> commit) {
    Iterator<Map.Entry<String, TreeMapEntryValue>> iterator = tree.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, TreeMapEntryValue> entry = iterator.next();
        String key = entry.getKey();
        TreeMapEntryValue value = entry.getValue();
        Versioned<byte[]> removedValue = new Versioned<byte[]>(value.value(), value.version());
        publish(Lists.newArrayList(new MapEvent<>("", key, null, removedValue)));
        iterator.remove();
    }
    return Status.OK;
}
#end_block

#method_before
protected void listen(RaftCommit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#method_after
protected void listen(Commit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#end_block

#method_before
protected void unlisten(RaftCommit<Void> commit) {
    closeListener(commit.session().sessionId().id());
}
#method_after
protected void unlisten(Commit<Void> commit) {
    closeListener(commit.session().sessionId().id());
}
#end_block

#method_before
protected NavigableMap<String, TreeMapEntryValue> subMap(RaftCommit<? extends SubMap> commit) {
    // Do not support this until lazy communication is possible.  At present
    // it transmits up to the entire map.
    SubMap<String, TreeMapEntryValue> subMap = commit.value();
    return tree.subMap(subMap.fromKey(), subMap.isInclusiveFrom(), subMap.toKey(), subMap.isInclusiveTo());
}
#method_after
protected NavigableMap<String, TreeMapEntryValue> subMap(Commit<? extends SubMap> commit) {
    // Do not support this until lazy communication is possible.  At present
    // it transmits up to the entire map.
    SubMap<String, TreeMapEntryValue> subMap = commit.value();
    return tree.subMap(subMap.fromKey(), subMap.isInclusiveFrom(), subMap.toKey(), subMap.isInclusiveTo());
}
#end_block

#method_before
protected String firstKey(RaftCommit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return tree.firstKey();
}
#method_after
protected String firstKey(Commit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return tree.firstKey();
}
#end_block

#method_before
protected String lastKey(RaftCommit<Void> commit) {
    return tree.isEmpty() ? null : tree.lastKey();
}
#method_after
protected String lastKey(Commit<Void> commit) {
    return tree.isEmpty() ? null : tree.lastKey();
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> higherEntry(RaftCommit<? extends HigherEntry> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.higherEntry(commit.value().key()));
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> higherEntry(Commit<? extends HigherEntry> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.higherEntry(commit.value().key()));
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> firstEntry(RaftCommit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.firstEntry());
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> firstEntry(Commit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.firstEntry());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> lastEntry(RaftCommit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.lastEntry());
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> lastEntry(Commit<Void> commit) {
    if (tree.isEmpty()) {
        return null;
    }
    return toVersionedEntry(tree.lastEntry());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> pollFirstEntry(RaftCommit<Void> commit) {
    return toVersionedEntry(tree.pollFirstEntry());
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> pollFirstEntry(Commit<Void> commit) {
    return toVersionedEntry(tree.pollFirstEntry());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> pollLastEntry(RaftCommit<Void> commit) {
    return toVersionedEntry(tree.pollLastEntry());
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> pollLastEntry(Commit<Void> commit) {
    return toVersionedEntry(tree.pollLastEntry());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> lowerEntry(RaftCommit<? extends LowerEntry> commit) {
    return toVersionedEntry(tree.lowerEntry(commit.value().key()));
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> lowerEntry(Commit<? extends LowerEntry> commit) {
    return toVersionedEntry(tree.lowerEntry(commit.value().key()));
}
#end_block

#method_before
protected String lowerKey(RaftCommit<? extends LowerKey> commit) {
    return tree.lowerKey(commit.value().key());
}
#method_after
protected String lowerKey(Commit<? extends LowerKey> commit) {
    return tree.lowerKey(commit.value().key());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> floorEntry(RaftCommit<? extends FloorEntry> commit) {
    return toVersionedEntry(tree.floorEntry(commit.value().key()));
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> floorEntry(Commit<? extends FloorEntry> commit) {
    return toVersionedEntry(tree.floorEntry(commit.value().key()));
}
#end_block

#method_before
protected String floorKey(RaftCommit<? extends FloorKey> commit) {
    return tree.floorKey(commit.value().key());
}
#method_after
protected String floorKey(Commit<? extends FloorKey> commit) {
    return tree.floorKey(commit.value().key());
}
#end_block

#method_before
protected Map.Entry<String, Versioned<byte[]>> ceilingEntry(RaftCommit<CeilingEntry> commit) {
    return toVersionedEntry(tree.ceilingEntry(commit.value().key()));
}
#method_after
protected Map.Entry<String, Versioned<byte[]>> ceilingEntry(Commit<CeilingEntry> commit) {
    return toVersionedEntry(tree.ceilingEntry(commit.value().key()));
}
#end_block

#method_before
protected String ceilingKey(RaftCommit<CeilingKey> commit) {
    return tree.ceilingKey(commit.value().key());
}
#method_after
protected String ceilingKey(Commit<CeilingKey> commit) {
    return tree.ceilingKey(commit.value().key());
}
#end_block

#method_before
protected String higherKey(RaftCommit<HigherKey> commit) {
    return tree.higherKey(commit.value().key());
}
#method_after
protected String higherKey(Commit<HigherKey> commit) {
    return tree.higherKey(commit.value().key());
}
#end_block

#method_before
@Override
public CompletableFuture<Long> incrementAndGet(String key) {
    return proxy.submit(INCREMENT_AND_GET, SERIALIZER::encode, new IncrementAndGet(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> incrementAndGet(String key) {
    return proxy.invoke(INCREMENT_AND_GET, SERIALIZER::encode, new IncrementAndGet(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> decrementAndGet(String key) {
    return proxy.submit(DECREMENT_AND_GET, SERIALIZER::encode, new DecrementAndGet(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> decrementAndGet(String key) {
    return proxy.invoke(DECREMENT_AND_GET, SERIALIZER::encode, new DecrementAndGet(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndIncrement(String key) {
    return proxy.submit(GET_AND_INCREMENT, SERIALIZER::encode, new GetAndIncrement(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> getAndIncrement(String key) {
    return proxy.invoke(GET_AND_INCREMENT, SERIALIZER::encode, new GetAndIncrement(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndDecrement(String key) {
    return proxy.submit(GET_AND_DECREMENT, SERIALIZER::encode, new GetAndDecrement(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> getAndDecrement(String key) {
    return proxy.invoke(GET_AND_DECREMENT, SERIALIZER::encode, new GetAndDecrement(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> addAndGet(String key, long delta) {
    return proxy.submit(ADD_AND_GET, SERIALIZER::encode, new AddAndGet(key, delta), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> addAndGet(String key, long delta) {
    return proxy.invoke(ADD_AND_GET, SERIALIZER::encode, new AddAndGet(key, delta), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> getAndAdd(String key, long delta) {
    return proxy.submit(GET_AND_ADD, SERIALIZER::encode, new GetAndAdd(key, delta), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> getAndAdd(String key, long delta) {
    return proxy.invoke(GET_AND_ADD, SERIALIZER::encode, new GetAndAdd(key, delta), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> get(String key) {
    return proxy.submit(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> get(String key) {
    return proxy.invoke(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> put(String key, long newValue) {
    return proxy.submit(PUT, SERIALIZER::encode, new Put(key, newValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> put(String key, long newValue) {
    return proxy.invoke(PUT, SERIALIZER::encode, new Put(key, newValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> putIfAbsent(String key, long newValue) {
    return proxy.submit(PUT_IF_ABSENT, SERIALIZER::encode, new PutIfAbsent(key, newValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> putIfAbsent(String key, long newValue) {
    return proxy.invoke(PUT_IF_ABSENT, SERIALIZER::encode, new PutIfAbsent(key, newValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> replace(String key, long expectedOldValue, long newValue) {
    return proxy.submit(REPLACE, SERIALIZER::encode, new Replace(key, expectedOldValue, newValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> replace(String key, long expectedOldValue, long newValue) {
    return proxy.invoke(REPLACE, SERIALIZER::encode, new Replace(key, expectedOldValue, newValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Long> remove(String key) {
    return proxy.submit(REMOVE, SERIALIZER::encode, new Remove(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Long> remove(String key) {
    return proxy.invoke(REMOVE, SERIALIZER::encode, new Remove(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> remove(String key, long value) {
    return proxy.submit(REMOVE_VALUE, SERIALIZER::encode, new RemoveValue(key, value), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> remove(String key, long value) {
    return proxy.invoke(REMOVE_VALUE, SERIALIZER::encode, new RemoveValue(key, value), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Integer> size() {
    return proxy.submit(SIZE, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Integer> size() {
    return proxy.invoke(SIZE, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.submit(IS_EMPTY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.invoke(IS_EMPTY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> clear() {
    return proxy.submit(CLEAR);
}
#method_after
@Override
public CompletableFuture<Void> clear() {
    return proxy.invoke(CLEAR);
}
#end_block

#method_before
protected void set(RaftCommit<Set> commit) {
    value = commit.value().value();
}
#method_after
protected void set(Commit<Set> commit) {
    value = commit.value().value();
}
#end_block

#method_before
protected Long get(RaftCommit<Void> commit) {
    return value;
}
#method_after
protected Long get(Commit<Void> commit) {
    return value;
}
#end_block

#method_before
protected boolean compareAndSet(RaftCommit<CompareAndSet> commit) {
    if (Objects.equals(value, commit.value().expect())) {
        value = commit.value().update();
        return true;
    }
    return false;
}
#method_after
protected boolean compareAndSet(Commit<CompareAndSet> commit) {
    if (Objects.equals(value, commit.value().expect())) {
        value = commit.value().update();
        return true;
    }
    return false;
}
#end_block

#method_before
protected long incrementAndGet(RaftCommit<Void> commit) {
    Long oldValue = value;
    value = oldValue + 1;
    return value;
}
#method_after
protected long incrementAndGet(Commit<Void> commit) {
    Long oldValue = value;
    value = oldValue + 1;
    return value;
}
#end_block

#method_before
protected long getAndIncrement(RaftCommit<Void> commit) {
    Long oldValue = value;
    value = oldValue + 1;
    return oldValue;
}
#method_after
protected long getAndIncrement(Commit<Void> commit) {
    Long oldValue = value;
    value = oldValue + 1;
    return oldValue;
}
#end_block

#method_before
protected long addAndGet(RaftCommit<AddAndGet> commit) {
    Long oldValue = value;
    value = oldValue + commit.value().delta();
    return value;
}
#method_after
protected long addAndGet(Commit<AddAndGet> commit) {
    Long oldValue = value;
    value = oldValue + commit.value().delta();
    return value;
}
#end_block

#method_before
protected long getAndAdd(RaftCommit<GetAndAdd> commit) {
    Long oldValue = value;
    value = oldValue + commit.value().delta();
    return oldValue;
}
#method_after
protected long getAndAdd(Commit<GetAndAdd> commit) {
    Long oldValue = value;
    value = oldValue + commit.value().delta();
    return oldValue;
}
#end_block

#method_before
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixDocumentTreeService service = new AtomixDocumentTreeService();
    service.update(new DefaultRaftCommit<>(2, UPDATE, new AtomixDocumentTreeOperations.Update(DocumentPath.from("root|foo"), Optional.of("Hello world!".getBytes()), Match.any(), Match.ifNull()), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixDocumentTreeService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultRaftCommit<>(2, GET, new AtomixDocumentTreeOperations.Get(DocumentPath.from("root|foo")), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#method_after
@Test
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixDocumentTreeService service = new AtomixDocumentTreeService();
    service.update(new DefaultCommit<>(2, UPDATE, new AtomixDocumentTreeOperations.Update(DocumentPath.from("root|foo"), Optional.of("Hello world!".getBytes()), Match.any(), Match.ifNull()), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixDocumentTreeService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultCommit<>(2, GET, new AtomixDocumentTreeOperations.Get(DocumentPath.from("root|foo")), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#end_block

#method_before
@Override
public <K, V> AsyncConsistentMap<K, V> newAsyncConsistentMap(String name, Serializer serializer) {
    AtomixConsistentMap atomixConsistentMap = new AtomixConsistentMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_MAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withMaxRetries(5).build());
    AsyncConsistentMap<String, byte[]> rawMap = new DelegatingAsyncConsistentMap<String, byte[]>(atomixConsistentMap) {

        @Override
        public String name() {
            return name;
        }
    };
    // We have to ensure serialization is done on the Copycat threads since Kryo is not thread safe.
    AsyncConsistentMap<K, V> transcodedMap = DistributedPrimitives.newTranscodingMap(rawMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)), value -> value == null ? null : serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#method_after
@Override
public <K, V> AsyncConsistentMap<K, V> newAsyncConsistentMap(String name, Serializer serializer) {
    AtomixConsistentMap atomixConsistentMap = new AtomixConsistentMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_MAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
    AsyncConsistentMap<String, byte[]> rawMap = new DelegatingAsyncConsistentMap<String, byte[]>(atomixConsistentMap) {

        @Override
        public String name() {
            return name;
        }
    };
    // We have to ensure serialization is done on the Copycat threads since Kryo is not thread safe.
    AsyncConsistentMap<K, V> transcodedMap = DistributedPrimitives.newTranscodingMap(rawMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)), value -> value == null ? null : serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#end_block

#method_before
@Override
public <V> AsyncConsistentTreeMap<V> newAsyncConsistentTreeMap(String name, Serializer serializer) {
    AtomixConsistentTreeMap atomixConsistentTreeMap = new AtomixConsistentTreeMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_TREEMAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withMaxRetries(5).build());
    AsyncConsistentTreeMap<byte[]> rawMap = new DelegatingAsyncConsistentTreeMap<byte[]>(atomixConsistentTreeMap) {

        @Override
        public String name() {
            return name;
        }
    };
    AsyncConsistentTreeMap<V> transcodedMap = DistributedPrimitives.<V, byte[]>newTranscodingTreeMap(rawMap, value -> value == null ? null : serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#method_after
@Override
public <V> AsyncConsistentTreeMap<V> newAsyncConsistentTreeMap(String name, Serializer serializer) {
    AtomixConsistentTreeMap atomixConsistentTreeMap = new AtomixConsistentTreeMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_TREEMAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
    AsyncConsistentTreeMap<byte[]> rawMap = new DelegatingAsyncConsistentTreeMap<byte[]>(atomixConsistentTreeMap) {

        @Override
        public String name() {
            return name;
        }
    };
    AsyncConsistentTreeMap<V> transcodedMap = DistributedPrimitives.<V, byte[]>newTranscodingTreeMap(rawMap, value -> value == null ? null : serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#end_block

#method_before
@Override
public <K, V> AsyncConsistentMultimap<K, V> newAsyncConsistentSetMultimap(String name, Serializer serializer) {
    AtomixConsistentSetMultimap atomixConsistentSetMultimap = new AtomixConsistentSetMultimap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_MULTIMAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withMaxRetries(5).build());
    AsyncConsistentMultimap<String, byte[]> rawMap = new DelegatingAsyncConsistentMultimap<String, byte[]>(atomixConsistentSetMultimap) {

        @Override
        public String name() {
            return super.name();
        }
    };
    AsyncConsistentMultimap<K, V> transcodedMap = DistributedPrimitives.newTranscodingMultimap(rawMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)), value -> serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#method_after
@Override
public <K, V> AsyncConsistentMultimap<K, V> newAsyncConsistentSetMultimap(String name, Serializer serializer) {
    AtomixConsistentSetMultimap atomixConsistentSetMultimap = new AtomixConsistentSetMultimap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.CONSISTENT_MULTIMAP.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
    AsyncConsistentMultimap<String, byte[]> rawMap = new DelegatingAsyncConsistentMultimap<String, byte[]>(atomixConsistentSetMultimap) {

        @Override
        public String name() {
            return super.name();
        }
    };
    AsyncConsistentMultimap<K, V> transcodedMap = DistributedPrimitives.newTranscodingMultimap(rawMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)), value -> serializer.encode(value), bytes -> serializer.decode(bytes));
    return transcodedMap;
}
#end_block

#method_before
@Override
public <K> AsyncAtomicCounterMap<K> newAsyncAtomicCounterMap(String name, Serializer serializer) {
    AtomixAtomicCounterMap atomixAtomicCounterMap = new AtomixAtomicCounterMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.COUNTER_MAP.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).withMaxRetries(5).build());
    AsyncAtomicCounterMap<K> transcodedMap = DistributedPrimitives.newTranscodingAtomicCounterMap(atomixAtomicCounterMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)));
    return transcodedMap;
}
#method_after
@Override
public <K> AsyncAtomicCounterMap<K> newAsyncAtomicCounterMap(String name, Serializer serializer) {
    AtomixAtomicCounterMap atomixAtomicCounterMap = new AtomixAtomicCounterMap(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.COUNTER_MAP.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
    AsyncAtomicCounterMap<K> transcodedMap = DistributedPrimitives.newTranscodingAtomicCounterMap(atomixAtomicCounterMap, key -> HexString.toHexString(serializer.encode(key)), string -> serializer.decode(HexString.fromHexString(string)));
    return transcodedMap;
}
#end_block

#method_before
@Override
public AsyncAtomicCounter newAsyncCounter(String name) {
    return new AtomixCounter(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.COUNTER.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).build());
}
#method_after
@Override
public AsyncAtomicCounter newAsyncCounter(String name) {
    return new AtomixCounter(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.COUNTER.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
}
#end_block

#method_before
@Override
public <E> WorkQueue<E> newWorkQueue(String name, Serializer serializer) {
    AtomixWorkQueue atomixWorkQueue = new AtomixWorkQueue(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.WORK_QUEUE.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).withMaxRetries(5).build());
    return new DefaultDistributedWorkQueue<>(atomixWorkQueue, serializer);
}
#method_after
@Override
public <E> WorkQueue<E> newWorkQueue(String name, Serializer serializer) {
    AtomixWorkQueue atomixWorkQueue = new AtomixWorkQueue(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.WORK_QUEUE.name()).withReadConsistency(ReadConsistency.LINEARIZABLE_LEASE).withCommunicationStrategy(CommunicationStrategy.LEADER).withTimeout(Duration.ofSeconds(5)).withMaxRetries(5).build().open().join());
    return new DefaultDistributedWorkQueue<>(atomixWorkQueue, serializer);
}
#end_block

#method_before
@Override
public <V> AsyncDocumentTree<V> newAsyncDocumentTree(String name, Serializer serializer) {
    AtomixDocumentTree atomixDocumentTree = new AtomixDocumentTree(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.DOCUMENT_TREE.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withMaxRetries(5).build());
    return new DefaultDistributedDocumentTree<>(name, atomixDocumentTree, serializer);
}
#method_after
@Override
public <V> AsyncDocumentTree<V> newAsyncDocumentTree(String name, Serializer serializer) {
    AtomixDocumentTree atomixDocumentTree = new AtomixDocumentTree(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.DOCUMENT_TREE.name()).withReadConsistency(ReadConsistency.SEQUENTIAL).withCommunicationStrategy(CommunicationStrategy.ANY).withTimeout(Duration.ofSeconds(30)).withMaxRetries(5).build().open().join());
    return new DefaultDistributedDocumentTree<>(name, atomixDocumentTree, serializer);
}
#end_block

#method_before
@Override
public AsyncLeaderElector newAsyncLeaderElector(String name) {
    AtomixLeaderElector leaderElector = new AtomixLeaderElector(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.LEADER_ELECTOR.name()).withReadConsistency(ReadConsistency.LINEARIZABLE).withCommunicationStrategy(CommunicationStrategy.LEADER).build());
    leaderElector.setupCache().join();
    return leaderElector;
}
#method_after
@Override
public AsyncLeaderElector newAsyncLeaderElector(String name) {
    AtomixLeaderElector leaderElector = new AtomixLeaderElector(client.newProxyBuilder().withName(name).withServiceType(DistributedPrimitive.Type.LEADER_ELECTOR.name()).withReadConsistency(ReadConsistency.LINEARIZABLE).withCommunicationStrategy(CommunicationStrategy.LEADER).withTimeout(Duration.ofSeconds(5)).withMaxRetries(5).build().open().join());
    leaderElector.setupCache().join();
    return leaderElector;
}
#end_block

#method_before
public void listen(RaftCommit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#method_after
public void listen(Commit<Void> commit) {
    listeners.put(commit.session().sessionId().id(), commit.session());
}
#end_block

#method_before
public void unlisten(RaftCommit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#method_after
public void unlisten(Commit<Void> commit) {
    listeners.remove(commit.session().sessionId().id());
}
#end_block

#method_before
public Leadership run(RaftCommit<? extends Run> commit) {
    try {
        String topic = commit.value().topic();
        Leadership oldLeadership = leadership(topic);
        Registration registration = new Registration(commit.value().nodeId(), commit.session().sessionId().id());
        elections.compute(topic, (k, v) -> {
            if (v == null) {
                return new ElectionState(registration, termCounter(topic)::incrementAndGet);
            } else {
                if (!v.isDuplicate(registration)) {
                    return new ElectionState(v).addRegistration(registration, termCounter(topic)::incrementAndGet);
                } else {
                    return v;
                }
            }
        });
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return newLeadership;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public Leadership run(Commit<? extends Run> commit) {
    try {
        String topic = commit.value().topic();
        Leadership oldLeadership = leadership(topic);
        Registration registration = new Registration(commit.value().nodeId(), commit.session().sessionId().id());
        elections.compute(topic, (k, v) -> {
            if (v == null) {
                return new ElectionState(registration, termCounter(topic)::incrementAndGet);
            } else {
                if (!v.isDuplicate(registration)) {
                    return new ElectionState(v).addRegistration(registration, termCounter(topic)::incrementAndGet);
                } else {
                    return v;
                }
            }
        });
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return newLeadership;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public void withdraw(RaftCommit<? extends Withdraw> commit) {
    try {
        String topic = commit.value().topic();
        Leadership oldLeadership = leadership(topic);
        elections.computeIfPresent(topic, (k, v) -> v.cleanup(commit.session(), termCounter(topic)::incrementAndGet));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public void withdraw(Commit<? extends Withdraw> commit) {
    try {
        String topic = commit.value().topic();
        Leadership oldLeadership = leadership(topic);
        elections.computeIfPresent(topic, (k, v) -> v.cleanup(commit.session(), termCounter(topic)::incrementAndGet));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public boolean anoint(RaftCommit<? extends Anoint> commit) {
    try {
        String topic = commit.value().topic();
        NodeId nodeId = commit.value().nodeId();
        Leadership oldLeadership = leadership(topic);
        ElectionState electionState = elections.computeIfPresent(topic, (k, v) -> v.transferLeadership(nodeId, termCounter(topic)));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return (electionState != null && electionState.leader() != null && commit.value().nodeId().equals(electionState.leader().nodeId()));
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public boolean anoint(Commit<? extends Anoint> commit) {
    try {
        String topic = commit.value().topic();
        NodeId nodeId = commit.value().nodeId();
        Leadership oldLeadership = leadership(topic);
        ElectionState electionState = elections.computeIfPresent(topic, (k, v) -> v.transferLeadership(nodeId, termCounter(topic)));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return (electionState != null && electionState.leader() != null && commit.value().nodeId().equals(electionState.leader().nodeId()));
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public boolean promote(RaftCommit<? extends Promote> commit) {
    try {
        String topic = commit.value().topic();
        NodeId nodeId = commit.value().nodeId();
        Leadership oldLeadership = leadership(topic);
        if (oldLeadership == null || !oldLeadership.candidates().contains(nodeId)) {
            return false;
        }
        elections.computeIfPresent(topic, (k, v) -> v.promote(nodeId));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return true;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public boolean promote(Commit<? extends Promote> commit) {
    try {
        String topic = commit.value().topic();
        NodeId nodeId = commit.value().nodeId();
        Leadership oldLeadership = leadership(topic);
        if (oldLeadership == null || !oldLeadership.candidates().contains(nodeId)) {
            return false;
        }
        elections.computeIfPresent(topic, (k, v) -> v.promote(nodeId));
        Leadership newLeadership = leadership(topic);
        if (!Objects.equal(oldLeadership, newLeadership)) {
            notifyLeadershipChange(oldLeadership, newLeadership);
        }
        return true;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public void evict(RaftCommit<? extends Evict> commit) {
    try {
        List<Change<Leadership>> changes = Lists.newArrayList();
        NodeId nodeId = commit.value().nodeId();
        Set<String> topics = Maps.filterValues(elections, e -> e.candidates().contains(nodeId)).keySet();
        topics.forEach(topic -> {
            Leadership oldLeadership = leadership(topic);
            elections.compute(topic, (k, v) -> v.evict(nodeId, termCounter(topic)::incrementAndGet));
            Leadership newLeadership = leadership(topic);
            if (!Objects.equal(oldLeadership, newLeadership)) {
                changes.add(new Change<>(oldLeadership, newLeadership));
            }
        });
        notifyLeadershipChanges(changes);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public void evict(Commit<? extends Evict> commit) {
    try {
        List<Change<Leadership>> changes = Lists.newArrayList();
        NodeId nodeId = commit.value().nodeId();
        Set<String> topics = Maps.filterValues(elections, e -> e.candidates().contains(nodeId)).keySet();
        topics.forEach(topic -> {
            Leadership oldLeadership = leadership(topic);
            elections.compute(topic, (k, v) -> v.evict(nodeId, termCounter(topic)::incrementAndGet));
            Leadership newLeadership = leadership(topic);
            if (!Objects.equal(oldLeadership, newLeadership)) {
                changes.add(new Change<>(oldLeadership, newLeadership));
            }
        });
        notifyLeadershipChanges(changes);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public Leadership getLeadership(RaftCommit<? extends GetLeadership> commit) {
    String topic = commit.value().topic();
    try {
        return leadership(topic);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public Leadership getLeadership(Commit<? extends GetLeadership> commit) {
    String topic = commit.value().topic();
    try {
        return leadership(topic);
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public Set<String> electedTopics(RaftCommit<? extends GetElectedTopics> commit) {
    try {
        NodeId nodeId = commit.value().nodeId();
        return ImmutableSet.copyOf(Maps.filterEntries(elections, e -> {
            Leader leader = leadership(e.getKey()).leader();
            return leader != null && leader.nodeId().equals(nodeId);
        }).keySet());
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public Set<String> electedTopics(Commit<? extends GetElectedTopics> commit) {
    try {
        NodeId nodeId = commit.value().nodeId();
        return ImmutableSet.copyOf(Maps.filterEntries(elections, e -> {
            Leader leader = leadership(e.getKey()).leader();
            return leader != null && leader.nodeId().equals(nodeId);
        }).keySet());
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
public Map<String, Leadership> allLeaderships(RaftCommit<Void> commit) {
    Map<String, Leadership> result = new HashMap<>();
    try {
        result.putAll(Maps.transformEntries(elections, (k, v) -> leadership(k)));
        return result;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#method_after
public Map<String, Leadership> allLeaderships(Commit<Void> commit) {
    Map<String, Leadership> result = new HashMap<>();
    try {
        result.putAll(Maps.transformEntries(elections, (k, v) -> leadership(k)));
        return result;
    } catch (Exception e) {
        getLogger().error("State machine operation failed", e);
        throw Throwables.propagate(e);
    }
}
#end_block

#method_before
@Override
public CompletableFuture<Leadership> run(String topic, NodeId nodeId) {
    return proxy.<Run, Leadership>submit(RUN, SERIALIZER::encode, new Run(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#method_after
@Override
public CompletableFuture<Leadership> run(String topic, NodeId nodeId) {
    return proxy.<Run, Leadership>invoke(RUN, SERIALIZER::encode, new Run(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#end_block

#method_before
@Override
public CompletableFuture<Void> withdraw(String topic) {
    return proxy.submit(WITHDRAW, SERIALIZER::encode, new Withdraw(topic)).whenComplete((r, e) -> cache.invalidate(topic));
}
#method_after
@Override
public CompletableFuture<Void> withdraw(String topic) {
    return proxy.invoke(WITHDRAW, SERIALIZER::encode, new Withdraw(topic)).whenComplete((r, e) -> cache.invalidate(topic));
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> anoint(String topic, NodeId nodeId) {
    return proxy.<Anoint, Boolean>submit(ANOINT, SERIALIZER::encode, new Anoint(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#method_after
@Override
public CompletableFuture<Boolean> anoint(String topic, NodeId nodeId) {
    return proxy.<Anoint, Boolean>invoke(ANOINT, SERIALIZER::encode, new Anoint(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> promote(String topic, NodeId nodeId) {
    return proxy.<Promote, Boolean>submit(PROMOTE, SERIALIZER::encode, new Promote(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#method_after
@Override
public CompletableFuture<Boolean> promote(String topic, NodeId nodeId) {
    return proxy.<Promote, Boolean>invoke(PROMOTE, SERIALIZER::encode, new Promote(topic, nodeId), SERIALIZER::decode).whenComplete((r, e) -> cache.invalidate(topic));
}
#end_block

#method_before
@Override
public CompletableFuture<Void> evict(NodeId nodeId) {
    return proxy.submit(EVICT, SERIALIZER::encode, new AtomixLeaderElectorOperations.Evict(nodeId));
}
#method_after
@Override
public CompletableFuture<Void> evict(NodeId nodeId) {
    return proxy.invoke(EVICT, SERIALIZER::encode, new AtomixLeaderElectorOperations.Evict(nodeId));
}
#end_block

#method_before
@Override
public CompletableFuture<Map<String, Leadership>> getLeaderships() {
    return proxy.submit(GET_ALL_LEADERSHIPS, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map<String, Leadership>> getLeaderships() {
    return proxy.invoke(GET_ALL_LEADERSHIPS, SERIALIZER::decode);
}
#end_block

#method_before
public CompletableFuture<Set<String>> getElectedTopics(NodeId nodeId) {
    return proxy.submit(GET_ELECTED_TOPICS, SERIALIZER::encode, new GetElectedTopics(nodeId), SERIALIZER::decode);
}
#method_after
public CompletableFuture<Set<String>> getElectedTopics(NodeId nodeId) {
    return proxy.invoke(GET_ELECTED_TOPICS, SERIALIZER::encode, new GetElectedTopics(nodeId), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> addChangeListener(Consumer<Change<Leadership>> consumer) {
    if (leadershipChangeListeners.isEmpty()) {
        return proxy.submit(ADD_LISTENER).thenRun(() -> leadershipChangeListeners.add(consumer));
    } else {
        leadershipChangeListeners.add(consumer);
        return CompletableFuture.completedFuture(null);
    }
}
#method_after
@Override
public synchronized CompletableFuture<Void> addChangeListener(Consumer<Change<Leadership>> consumer) {
    if (leadershipChangeListeners.isEmpty()) {
        return proxy.invoke(ADD_LISTENER).thenRun(() -> leadershipChangeListeners.add(consumer));
    } else {
        leadershipChangeListeners.add(consumer);
        return CompletableFuture.completedFuture(null);
    }
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> removeChangeListener(Consumer<Change<Leadership>> consumer) {
    if (leadershipChangeListeners.remove(consumer) && leadershipChangeListeners.isEmpty()) {
        return proxy.submit(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public synchronized CompletableFuture<Void> removeChangeListener(Consumer<Change<Leadership>> consumer) {
    if (leadershipChangeListeners.remove(consumer) && leadershipChangeListeners.isEmpty()) {
        return proxy.invoke(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentMapService service = new AtomixConsistentMapService();
    service.updateAndGet(new DefaultRaftCommit<>(2, UPDATE_AND_GET, new AtomixConsistentMapOperations.UpdateAndGet("foo", "Hello world!".getBytes(), Match.ANY, Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultRaftCommit<>(2, GET, new AtomixConsistentMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#method_after
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentMapService service = new AtomixConsistentMapService();
    service.updateAndGet(new DefaultCommit<>(2, UPDATE_AND_GET, new AtomixConsistentMapOperations.UpdateAndGet("foo", "Hello world!".getBytes(), Match.ANY, Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultCommit<>(2, GET, new AtomixConsistentMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#end_block

#method_before
@Override
public CompletableFuture<Void> destroy() {
    executor.shutdown();
    timer.cancel();
    return proxy.submit(CLEAR);
}
#method_after
@Override
public CompletableFuture<Void> destroy() {
    executor.shutdown();
    timer.cancel();
    return proxy.invoke(CLEAR);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> addMultiple(Collection<byte[]> items) {
    if (items.isEmpty()) {
        return CompletableFuture.completedFuture(null);
    }
    return proxy.submit(ADD, SERIALIZER::encode, new Add(items));
}
#method_after
@Override
public CompletableFuture<Void> addMultiple(Collection<byte[]> items) {
    if (items.isEmpty()) {
        return CompletableFuture.completedFuture(null);
    }
    return proxy.invoke(ADD, SERIALIZER::encode, new Add(items));
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Task<byte[]>>> take(int maxTasks) {
    if (maxTasks <= 0) {
        return CompletableFuture.completedFuture(ImmutableList.of());
    }
    return proxy.submit(TAKE, SERIALIZER::encode, new Take(maxTasks), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Collection<Task<byte[]>>> take(int maxTasks) {
    if (maxTasks <= 0) {
        return CompletableFuture.completedFuture(ImmutableList.of());
    }
    return proxy.invoke(TAKE, SERIALIZER::encode, new Take(maxTasks), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Void> complete(Collection<String> taskIds) {
    if (taskIds.isEmpty()) {
        return CompletableFuture.completedFuture(null);
    }
    return proxy.submit(COMPLETE, SERIALIZER::encode, new Complete(taskIds));
}
#method_after
@Override
public CompletableFuture<Void> complete(Collection<String> taskIds) {
    if (taskIds.isEmpty()) {
        return CompletableFuture.completedFuture(null);
    }
    return proxy.invoke(COMPLETE, SERIALIZER::encode, new Complete(taskIds));
}
#end_block

#method_before
@Override
public CompletableFuture<WorkQueueStats> stats() {
    return proxy.submit(STATS, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<WorkQueueStats> stats() {
    return proxy.invoke(STATS, SERIALIZER::decode);
}
#end_block

#method_before
private CompletableFuture<Void> register() {
    return proxy.submit(REGISTER).thenRun(() -> isRegistered.set(true));
}
#method_after
private CompletableFuture<Void> register() {
    return proxy.invoke(REGISTER).thenRun(() -> isRegistered.set(true));
}
#end_block

#method_before
private CompletableFuture<Void> unregister() {
    return proxy.submit(UNREGISTER).thenRun(() -> isRegistered.set(false));
}
#method_after
private CompletableFuture<Void> unregister() {
    return proxy.invoke(UNREGISTER).thenRun(() -> isRegistered.set(false));
}
#end_block

#method_before
protected T newPrimitive(String name) {
    RaftClient client = createClient();
    RaftProxy proxy = client.newProxyBuilder().withName(name).withServiceType("test").withReadConsistency(readConsistency()).withCommunicationStrategy(communicationStrategy()).build();
    return createPrimitive(proxy);
}
#method_after
protected T newPrimitive(String name) {
    RaftClient client = createClient();
    RaftProxy proxy = client.newProxyBuilder().withName(name).withServiceType("test").withReadConsistency(readConsistency()).withCommunicationStrategy(communicationStrategy()).build().open().join();
    return createPrimitive(proxy);
}
#end_block

#method_before
private RaftServer createServer(RaftMember member) {
    RaftServer.Builder builder = RaftServer.newBuilder(member.memberId()).withType(member.getType()).withProtocol(new RaftServerCommunicator("test", PROTOCOL_SERIALIZER, communicationServiceFactory.newCommunicationService(NodeId.nodeId(member.memberId().id())))).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.MEMORY).withDirectory(new File(String.format("target/primitives/%s", member.memberId()))).withSerializer(new AtomixSerializerAdapter(STORAGE_SERIALIZER)).withMaxSegmentSize(1024 * 1024).build()).addService("test", this::createService);
    RaftServer server = builder.build();
    servers.add(server);
    return server;
}
#method_after
private RaftServer createServer(RaftMember member) {
    RaftServer.Builder builder = RaftServer.newBuilder(member.memberId()).withType(member.getType()).withProtocol(new RaftServerCommunicator(PartitionId.from(1), PROTOCOL_SERIALIZER, communicationServiceFactory.newCommunicationService(NodeId.nodeId(member.memberId().id())))).withStorage(RaftStorage.newBuilder().withStorageLevel(StorageLevel.MEMORY).withDirectory(new File(String.format("target/primitives/%s", member.memberId()))).withSerializer(new AtomixSerializerAdapter(STORAGE_SERIALIZER)).withMaxSegmentSize(1024 * 1024).build()).addService("test", this::createService);
    RaftServer server = builder.build();
    servers.add(server);
    return server;
}
#end_block

#method_before
private RaftClient createClient() {
    MemberId memberId = nextMemberId();
    RaftClient client = RaftClient.newBuilder().withMemberId(memberId).withProtocol(new RaftClientCommunicator("test", PROTOCOL_SERIALIZER, communicationServiceFactory.newCommunicationService(NodeId.nodeId(memberId.id())))).build();
    client.connect(members.stream().map(RaftMember::memberId).collect(Collectors.toList())).join();
    clients.add(client);
    return client;
}
#method_after
private RaftClient createClient() {
    MemberId memberId = nextMemberId();
    RaftClient client = RaftClient.newBuilder().withMemberId(memberId).withProtocol(new RaftClientCommunicator(PartitionId.from(1), PROTOCOL_SERIALIZER, communicationServiceFactory.newCommunicationService(NodeId.nodeId(memberId.id())))).build();
    client.connect(members.stream().map(RaftMember::memberId).collect(Collectors.toList())).join();
    clients.add(client);
    return client;
}
#end_block

#method_before
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentTreeMapService service = new AtomixConsistentTreeMapService();
    service.updateAndGet(new DefaultRaftCommit<>(2, UPDATE_AND_GET, new AtomixConsistentTreeMapOperations.UpdateAndGet("foo", "Hello world!".getBytes(), Match.ANY, Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentTreeMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultRaftCommit<>(2, GET, new AtomixConsistentTreeMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#method_after
@Test
@SuppressWarnings("unchecked")
public void testSnapshot() throws Exception {
    SnapshotStore store = new SnapshotStore(RaftStorage.newBuilder().withPrefix("test").withStorageLevel(StorageLevel.MEMORY).build());
    Snapshot snapshot = store.newSnapshot(ServiceId.from(1), 2, new WallClockTimestamp());
    AtomixConsistentTreeMapService service = new AtomixConsistentTreeMapService();
    service.updateAndGet(new DefaultCommit<>(2, UPDATE_AND_GET, new AtomixConsistentTreeMapOperations.UpdateAndGet("foo", "Hello world!".getBytes(), Match.ANY, Match.ANY), mock(RaftSessionContext.class), System.currentTimeMillis()));
    try (SnapshotWriter writer = snapshot.openWriter()) {
        service.snapshot(writer);
    }
    snapshot.complete();
    service = new AtomixConsistentTreeMapService();
    try (SnapshotReader reader = snapshot.openReader()) {
        service.install(reader);
    }
    Versioned<byte[]> value = service.get(new DefaultCommit<>(2, GET, new AtomixConsistentTreeMapOperations.Get("foo"), mock(RaftSessionContext.class), System.currentTimeMillis()));
    assertNotNull(value);
    assertArrayEquals("Hello world!".getBytes(), value.value());
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.submit(IS_EMPTY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> isEmpty() {
    return proxy.invoke(IS_EMPTY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Integer> size() {
    return proxy.submit(SIZE, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Integer> size() {
    return proxy.invoke(SIZE, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.submit(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsKey(String key) {
    return proxy.invoke(CONTAINS_KEY, SERIALIZER::encode, new ContainsKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.submit(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Boolean> containsValue(byte[] value) {
    return proxy.invoke(CONTAINS_VALUE, SERIALIZER::encode, new ContainsValue(value), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> get(String key) {
    return proxy.submit(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> get(String key) {
    return proxy.invoke(GET, SERIALIZER::encode, new Get(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Versioned<byte[]>> getOrDefault(String key, byte[] defaultValue) {
    return proxy.submit(GET_OR_DEFAULT, SERIALIZER::encode, new GetOrDefault(key, defaultValue), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Versioned<byte[]>> getOrDefault(String key, byte[] defaultValue) {
    return proxy.invoke(GET_OR_DEFAULT, SERIALIZER::encode, new GetOrDefault(key, defaultValue), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.submit(KEY_SET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Set<String>> keySet() {
    return proxy.invoke(KEY_SET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Collection<Versioned<byte[]>>> values() {
    return proxy.submit(VALUES, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Collection<Versioned<byte[]>>> values() {
    return proxy.invoke(VALUES, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Set<Map.Entry<String, Versioned<byte[]>>>> entrySet() {
    return proxy.submit(ENTRY_SET, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Set<Map.Entry<String, Versioned<byte[]>>>> entrySet() {
    return proxy.invoke(ENTRY_SET, SERIALIZER::decode);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> put(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> put(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putAndGet(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putAndGet(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putIfAbsent(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> putIfAbsent(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> remove(String key) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> remove(String key) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ifValue(value), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ifValue(value), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, long version) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ifValue(version)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> remove(String key, long version) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, null, Match.ANY, Match.ifValue(version)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> replace(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NOT_NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> replace(String key, byte[] value) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, value, Match.NOT_NULL, Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.oldValue());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, byte[] oldValue, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ifValue(oldValue), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, byte[] oldValue, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ifValue(oldValue), Match.ANY), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, long oldVersion, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ANY, Match.ifValue(oldVersion)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Boolean> replace(String key, long oldVersion, byte[] newValue) {
    return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, newValue, Match.ANY, Match.ifValue(oldVersion)), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.updated());
}
#end_block

#method_before
@Override
public CompletableFuture<Void> clear() {
    return proxy.<MapEntryUpdateResult.Status>submit(CLEAR, SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r)).thenApply(v -> null);
}
#method_after
@Override
public CompletableFuture<Void> clear() {
    return proxy.<MapEntryUpdateResult.Status>invoke(CLEAR, SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r)).thenApply(v -> null);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> computeIf(String key, Predicate<? super byte[]> condition, BiFunction<? super String, ? super byte[], ? extends byte[]> remappingFunction) {
    return get(key).thenCompose(r1 -> {
        byte[] existingValue = r1 == null ? null : r1.value();
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<byte[]> computedValue = new AtomicReference<byte[]>();
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            CompletableFuture<Versioned<byte[]>> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<byte[]> valueMatch = r1 == null ? Match.NULL : Match.ANY;
        Match<Long> versionMatch = r1 == null ? Match.ANY : Match.ifValue(r1.version());
        return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>submit(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, computedValue.get(), valueMatch, versionMatch), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
    });
}
#method_after
@Override
@SuppressWarnings("unchecked")
public CompletableFuture<Versioned<byte[]>> computeIf(String key, Predicate<? super byte[]> condition, BiFunction<? super String, ? super byte[], ? extends byte[]> remappingFunction) {
    return get(key).thenCompose(r1 -> {
        byte[] existingValue = r1 == null ? null : r1.value();
        if (!condition.test(existingValue)) {
            return CompletableFuture.completedFuture(r1);
        }
        AtomicReference<byte[]> computedValue = new AtomicReference<byte[]>();
        try {
            computedValue.set(remappingFunction.apply(key, existingValue));
        } catch (Exception e) {
            CompletableFuture<Versioned<byte[]>> future = new CompletableFuture<>();
            future.completeExceptionally(e);
            return future;
        }
        if (computedValue.get() == null && r1 == null) {
            return CompletableFuture.completedFuture(null);
        }
        Match<byte[]> valueMatch = r1 == null ? Match.NULL : Match.ANY;
        Match<Long> versionMatch = r1 == null ? Match.ANY : Match.ifValue(r1.version());
        return proxy.<UpdateAndGet, MapEntryUpdateResult<String, byte[]>>invoke(UPDATE_AND_GET, SERIALIZER::encode, new UpdateAndGet(key, computedValue.get(), valueMatch, versionMatch), SERIALIZER::decode).whenComplete((r, e) -> throwIfLocked(r.status())).thenApply(v -> v.newValue());
    });
}
#end_block

#method_before
@Override
public CompletableFuture<Void> addListener(MapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.submit(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#method_after
@Override
public CompletableFuture<Void> addListener(MapEventListener<String, byte[]> listener, Executor executor) {
    if (mapEventListeners.isEmpty()) {
        return proxy.invoke(ADD_LISTENER).thenRun(() -> mapEventListeners.put(listener, executor));
    } else {
        mapEventListeners.put(listener, executor);
        return CompletableFuture.completedFuture(null);
    }
}
#end_block

#method_before
@Override
public synchronized CompletableFuture<Void> removeListener(MapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.submit(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#method_after
@Override
public synchronized CompletableFuture<Void> removeListener(MapEventListener<String, byte[]> listener) {
    if (mapEventListeners.remove(listener) != null && mapEventListeners.isEmpty()) {
        return proxy.invoke(REMOVE_LISTENER).thenApply(v -> null);
    }
    return CompletableFuture.completedFuture(null);
}
#end_block

#method_before
@Override
public CompletableFuture<String> firstKey() {
    return proxy.submit(FIRST_KEY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> firstKey() {
    return proxy.invoke(FIRST_KEY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<String> lastKey() {
    return proxy.submit(LAST_KEY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> lastKey() {
    return proxy.invoke(LAST_KEY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> ceilingEntry(String key) {
    return proxy.submit(CEILING_ENTRY, SERIALIZER::encode, new CeilingEntry(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> ceilingEntry(String key) {
    return proxy.invoke(CEILING_ENTRY, SERIALIZER::encode, new CeilingEntry(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> floorEntry(String key) {
    return proxy.submit(FLOOR_ENTRY, SERIALIZER::encode, new FloorEntry(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> floorEntry(String key) {
    return proxy.invoke(FLOOR_ENTRY, SERIALIZER::encode, new FloorEntry(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> higherEntry(String key) {
    return proxy.submit(HIGHER_ENTRY, SERIALIZER::encode, new HigherEntry(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> higherEntry(String key) {
    return proxy.invoke(HIGHER_ENTRY, SERIALIZER::encode, new HigherEntry(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> lowerEntry(String key) {
    return proxy.submit(LOWER_ENTRY, SERIALIZER::encode, new LowerEntry(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> lowerEntry(String key) {
    return proxy.invoke(LOWER_ENTRY, SERIALIZER::encode, new LowerEntry(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> firstEntry() {
    return proxy.submit(FIRST_ENTRY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> firstEntry() {
    return proxy.invoke(FIRST_ENTRY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> lastEntry() {
    return proxy.submit(LAST_ENTRY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> lastEntry() {
    return proxy.invoke(LAST_ENTRY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> pollFirstEntry() {
    return proxy.submit(POLL_FIRST_ENTRY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> pollFirstEntry() {
    return proxy.invoke(POLL_FIRST_ENTRY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> pollLastEntry() {
    return proxy.submit(POLL_LAST_ENTRY, SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<Map.Entry<String, Versioned<byte[]>>> pollLastEntry() {
    return proxy.invoke(POLL_LAST_ENTRY, SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<String> lowerKey(String key) {
    return proxy.submit(LOWER_KEY, SERIALIZER::encode, new LowerKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> lowerKey(String key) {
    return proxy.invoke(LOWER_KEY, SERIALIZER::encode, new LowerKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<String> floorKey(String key) {
    return proxy.submit(FLOOR_KEY, SERIALIZER::encode, new FloorKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> floorKey(String key) {
    return proxy.invoke(FLOOR_KEY, SERIALIZER::encode, new FloorKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<String> ceilingKey(String key) {
    return proxy.submit(CEILING_KEY, SERIALIZER::encode, new CeilingKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> ceilingKey(String key) {
    return proxy.invoke(CEILING_KEY, SERIALIZER::encode, new CeilingKey(key), SERIALIZER::decode);
}
#end_block

#method_before
@Override
public CompletableFuture<String> higherKey(String key) {
    return proxy.submit(HIGHER_KEY, SERIALIZER::encode, new HigherKey(key), SERIALIZER::decode);
}
#method_after
@Override
public CompletableFuture<String> higherKey(String key) {
    return proxy.invoke(HIGHER_KEY, SERIALIZER::encode, new HigherKey(key), SERIALIZER::decode);
}
#end_block

#method_before
private boolean handlePipeconf(DeviceId deviceId, Driver driver, DriverData driverData) {
    PiPipelineProgrammable pipelineProg = getBehaviour(driver, PiPipelineProgrammable.class, driverData);
    if (pipelineProg == null) {
        // Device is not pipeline programmable.
        return true;
    }
    PiPipeconfId pipeconfId = piPipeconfService.ofDevice(deviceId).orElseGet(() -> {
        // Check if device driver provides a default one.
        if (pipelineProg.getDefaultPipeconf().isPresent()) {
            PiPipeconf defaultPipeconf = pipelineProg.getDefaultPipeconf().get();
            log.info("Using default pipeconf {} for {}", defaultPipeconf.id(), deviceId);
            // TODO: this should be performed at driver loading.
            if (!piPipeconfService.getPipeconf(defaultPipeconf.id()).isPresent()) {
                piPipeconfService.register(defaultPipeconf);
            }
            return defaultPipeconf.id();
        } else {
            return null;
        }
    });
    if (pipeconfId == null) {
        log.warn("Device {} is pipeline programmable but no pipeconf can be associated to it.", deviceId);
        return true;
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(pipeconfId).orElseThrow(() -> new IllegalStateException("Pipeconf is not registered: " + pipeconfId));
    try {
        if (!pipelineProg.deployPipeconf(pipeconf).get()) {
            log.error("Unable to deploy pipeconf {} to {}. Aborting device discovery.", pipeconfId, deviceId);
            return false;
        }
        if (!piPipeconfService.bindToDevice(pipeconfId, deviceId).get()) {
            log.error("Unable to merge driver {} for device {} with pipeconf {}. Aborting device discovery.", driver.name(), deviceId, pipeconfId);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalStateException(e);
    }
    return true;
}
#method_after
private boolean handlePipeconf(DeviceId deviceId, Driver driver, DriverData driverData) {
    PiPipelineProgrammable pipelineProg = getBehaviour(driver, PiPipelineProgrammable.class, driverData);
    if (pipelineProg == null) {
        // Device is not pipeline programmable.
        return true;
    }
    PiPipeconfId pipeconfId = piPipeconfService.ofDevice(deviceId).orElseGet(() -> {
        // Check if device driver provides a default one.
        if (pipelineProg.getDefaultPipeconf().isPresent()) {
            PiPipeconf defaultPipeconf = pipelineProg.getDefaultPipeconf().get();
            log.info("Using default pipeconf {} for {}", defaultPipeconf.id(), deviceId);
            // TODO: this should be performed at driver loading.
            if (!piPipeconfService.getPipeconf(defaultPipeconf.id()).isPresent()) {
                piPipeconfService.register(defaultPipeconf);
            }
            return defaultPipeconf.id();
        } else {
            return null;
        }
    });
    if (pipeconfId == null) {
        log.warn("Device {} is pipeline programmable but no pipeconf can be associated to it.", deviceId);
        return true;
    }
    PiPipeconf pipeconf = piPipeconfService.getPipeconf(pipeconfId).orElseThrow(() -> new IllegalStateException("Pipeconf is not registered: " + pipeconfId));
    try {
        if (!pipelineProg.deployPipeconf(pipeconf).get()) {
            log.error("Unable to deploy pipeconf {} to {}, aborting device discovery", pipeconfId, deviceId);
            return false;
        }
        if (!piPipeconfService.bindToDevice(pipeconfId, deviceId).get()) {
            log.error("Unable to merge driver {} for device {} with pipeconf {}, aborting device discovery", driver.name(), deviceId, pipeconfId);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        throw new IllegalStateException(e);
    }
    return true;
}
#end_block

#method_before
private boolean doDeployConfig(PiPipeconf pipeconf) {
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    DeviceId deviceId = handler().data().deviceId();
    if (!controller.hasClient(deviceId)) {
        log.warn("Unable to find client for {}. Aborting pipeconf deploy.", deviceId);
        return false;
    }
    P4RuntimeClient client = controller.getClient(deviceId);
    if (!pipeconf.extension(BMV2_JSON).isPresent()) {
        log.warn("Missing BMv2 JSON config in pipeconf {}", pipeconf.id());
        return false;
    }
    if (!pipeconf.extension(P4_INFO_TEXT).isPresent()) {
        log.warn("Missing P4Info in pipeconf {}", pipeconf.id());
        return false;
    }
    InputStream p4InfoStream = pipeconf.extension(P4_INFO_TEXT).get();
    InputStream jsonStream = pipeconf.extension(BMV2_JSON).get();
    try {
        if (!client.setPipelineConfig(p4InfoStream, jsonStream).get()) {
            log.warn("Unable to deploy pipeconf {} to {}", pipeconf.id(), deviceId);
            return false;
        }
        // command if a P4info has not been set first.
        if (!client.initStreamChannel().get()) {
            log.warn("Unable to init stream channel to {}", deviceId);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
    return true;
}
#method_after
private boolean doDeployConfig(PiPipeconf pipeconf) {
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    DeviceId deviceId = handler().data().deviceId();
    if (!controller.hasClient(deviceId)) {
        log.warn("Unable to find client for {}, aborting pipeconf deploy", deviceId);
        return false;
    }
    P4RuntimeClient client = controller.getClient(deviceId);
    if (!pipeconf.extension(BMV2_JSON).isPresent()) {
        log.warn("Missing BMv2 JSON config in pipeconf {}, aborting pipeconf deploy", pipeconf.id());
        return false;
    }
    if (!pipeconf.extension(P4_INFO_TEXT).isPresent()) {
        log.warn("Missing P4Info in pipeconf {}, aborting pipeconf deploy", pipeconf.id());
        return false;
    }
    InputStream p4InfoStream = pipeconf.extension(P4_INFO_TEXT).get();
    InputStream jsonStream = pipeconf.extension(BMV2_JSON).get();
    try {
        if (!client.setPipelineConfig(p4InfoStream, jsonStream).get()) {
            log.warn("Unable to deploy pipeconf {} to {}", pipeconf.id(), deviceId);
            return false;
        }
        // command if a P4info has not been set first.
        if (!client.initStreamChannel().get()) {
            log.warn("Unable to init stream channel to {}.", deviceId);
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        throw new RuntimeException(e);
    }
    return true;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> connect() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    SharedExecutors.getPoolThreadExecutor().submit(() -> result.complete(doConnect()));
    return result;
}
#method_after
// TODO: consider abstract class with empty connect method and  implementation into a protected one for reusability.
@Override
public CompletableFuture<Boolean> connect() {
    return CompletableFuture.supplyAsync(this::doConnect);
}
#end_block

#method_before
private boolean doConnect() {
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    DeviceId deviceId = handler().data().deviceId();
    // DeviceKeyService deviceKeyService = handler().get(DeviceKeyService.class);
    DriverData data = data();
    String serverAddr = data.value("p4runtime_ip");
    int serverPort = Integer.valueOf(data.value("p4runtime_port"));
    String[] idPieces = deviceId.toString().split(":");
    int p4DeviceId = Integer.valueOf(idPieces[idPieces.length - 1]);
    if (!controller.createClient(deviceId, serverAddr, serverPort, p4DeviceId)) {
        log.warn("Unable to create P4runtime client for {}", deviceId);
        return false;
    }
    return true;
}
#method_after
private boolean doConnect() {
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    DeviceId deviceId = handler().data().deviceId();
    // DeviceKeyService deviceKeyService = handler().get(DeviceKeyService.class);
    DriverData data = data();
    String serverAddr = data.value("p4runtime_ip");
    int serverPort = Integer.valueOf(data.value("p4runtime_port"));
    int p4DeviceId = Integer.valueOf(data.value("p4runtime_deviceId"));
    ManagedChannelBuilder channelBuilder = NettyChannelBuilder.forAddress(serverAddr, serverPort).usePlaintext(true);
    if (!controller.createClient(deviceId, p4DeviceId, channelBuilder)) {
        log.warn("Unable to create P4runtime client for {}", deviceId);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> disconnect() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    P4RuntimeController controller = handler().get(P4RuntimeController.class);
    DeviceId deviceId = handler().data().deviceId();
    controller.removeClient(deviceId);
    result.complete(true);
    return result;
}
#method_after
@Override
public CompletableFuture<Boolean> disconnect() {
    return CompletableFuture.supplyAsync(() -> {
        P4RuntimeController controller = handler().get(P4RuntimeController.class);
        DeviceId deviceId = handler().data().deviceId();
        controller.removeClient(deviceId);
        return true;
    });
}
#end_block

#method_before
@Override
public CompletableFuture<Boolean> isReachable() {
    CompletableFuture<Boolean> result = new CompletableFuture<>();
    log.warn("isReachable not implemented");
    result.complete(true);
    // TODO.
    return result;
}
#method_after
@Override
public CompletableFuture<Boolean> isReachable() {
    return CompletableFuture.supplyAsync(() -> {
        P4RuntimeController controller = handler().get(P4RuntimeController.class);
        DeviceId deviceId = handler().data().deviceId();
        return controller.isReacheable(deviceId);
    });
}
#end_block

#method_before
@Override
public ManagedChannel connectChannel(GrpcChannelId channelId, ManagedChannelBuilder<?> channelBuilder) throws IOException {
    ManagedChannel channel = channelBuilder.build();
    // Forced connection not yet implemented. Use workaround.
    // channel.getState(true);
    DummyServiceGrpc.DummyServiceBlockingStub dummyStub = DummyServiceGrpc.newBlockingStub(channel);
    try {
        dummyStub.sayHello(Dummy.DummyMessageThatNoOneWouldReallyUse.getDefaultInstance());
    } catch (StatusRuntimeException e) {
        if (e.getStatus() != Status.UNIMPLEMENTED) {
            // UNIMPLEMENTED means that the channel is open.
            throw new IOException(e);
        }
    }
    channelBuilders.put(channelId, channelBuilder);
    channels.put(channelId, channel);
    return channel;
}
#method_after
@Override
public ManagedChannel connectChannel(GrpcChannelId channelId, ManagedChannelBuilder<?> channelBuilder) throws IOException {
    ManagedChannel channel = channelBuilder.build();
    // Forced connection not yet implemented. Use workaround...
    // channel.getState(true);
    doDummyMessage(channel);
    channelBuilders.put(channelId, channelBuilder);
    channels.put(channelId, channel);
    return channel;
}
#end_block

#method_before
@Override
public void disconnectChannel(GrpcChannelId channelId) {
    channels.get(channelId).shutdownNow();
    channels.remove(channelId);
    channelBuilders.remove(channelId);
}
#method_after
@Override
public void disconnectChannel(GrpcChannelId channelId) {
    if (!channels.containsKey(channelId)) {
        // Nothing to do.
        return;
    }
    ManagedChannel channel = channels.get(channelId);
    try {
        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        log.warn("Channel {} didn't shut down in time.");
        channel.shutdownNow();
    }
    channels.remove(channelId);
    channelBuilders.remove(channelId);
}
#end_block

#method_before
private void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, "controller", c.getRow().uuid()));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#method_after
private void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, BRIDGE_CONTROLLER, c.getRow().uuid()));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, BRIDGE_CONTROLLER, bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#end_block

#method_before
private UiTokenService tokenService() {
    UiTokenService service = directory.get(UiTokenService.class);
    return service;
}
#method_after
private UiTokenService tokenService() {
    return directory.get(UiTokenService.class);
}
#end_block

#method_before
private DeviceNotificationProto buildDeviceProtoMessage(DeviceEvent deviceEvent) {
    DeviceNotificationProto.Builder notificationBuilder = DeviceNotificationProto.newBuilder();
    DeviceProto deviceCore = DeviceProto.newBuilder().setChassisId(deviceEvent.subject().chassisId().id().toString()).setDeviceId(deviceEvent.subject().id().toString()).setHwVersion(deviceEvent.subject().hwVersion()).setManufacturer(deviceEvent.subject().manufacturer()).setSerialNumber(deviceEvent.subject().serialNumber()).setSwVersion(deviceEvent.subject().swVersion()).setType(DeviceEnumsProto.DeviceTypeProto.valueOf(deviceEvent.subject().type().name())).build();
    PortProtoOuterClass.PortProto portProto = null;
    if (deviceEvent.port() != null) {
        portProto = PortProtoOuterClass.PortProto.newBuilder().setIsEnabled(deviceEvent.port().isEnabled()).setPortNumber(deviceEvent.port().number().toString()).setPortSpeed(deviceEvent.port().portSpeed()).setType(PortEnumsProto.PortTypeProto.valueOf(deviceEvent.port().type().name())).build();
        notificationBuilder.setPort(portProto);
    }
    notificationBuilder.setDeviceEventType(getProtoType(deviceEvent)).setDevice(deviceCore);
    return notificationBuilder.build();
}
#method_after
private DeviceNotificationProto buildDeviceProtoMessage(DeviceEvent deviceEvent) {
    DeviceNotificationProto.Builder notificationBuilder = DeviceNotificationProto.newBuilder();
    DeviceProto deviceCore = DeviceProto.newBuilder().setChassisId(deviceEvent.subject().chassisId().id().toString()).setDeviceId(deviceEvent.subject().id().toString()).setHwVersion(deviceEvent.subject().hwVersion()).setManufacturer(deviceEvent.subject().manufacturer()).setSerialNumber(deviceEvent.subject().serialNumber()).setSwVersion(deviceEvent.subject().swVersion()).setType(DeviceTypeProto.valueOf(deviceEvent.subject().type().name())).build();
    PortProtoOuterClass.PortProto portProto = null;
    if (deviceEvent.port() != null) {
        portProto = PortProtoOuterClass.PortProto.newBuilder().setIsEnabled(deviceEvent.port().isEnabled()).setPortNumber(deviceEvent.port().number().toString()).setPortSpeed(deviceEvent.port().portSpeed()).setType(PortEnumsProto.PortTypeProto.valueOf(deviceEvent.port().type().name())).build();
        notificationBuilder.setPort(portProto);
    }
    notificationBuilder.setDeviceEventType(getProtoType(deviceEvent)).setDevice(deviceCore);
    return notificationBuilder.build();
}
#end_block

#method_before
private LinkDescription translate(LinkDescriptionProto linkDescription) {
    ConnectPoint src = translate(linkDescription.getSrc());
    ConnectPoint dst = translate(linkDescription.getDst());
    Link.Type type = translate(linkDescription.getType());
    SparseAnnotations annotations = ProtobufUtils.asAnnotations(linkDescription.getAnnotations());
    return new DefaultLinkDescription(src, dst, type, annotations);
}
#method_after
private LinkDescription translate(LinkDescriptionProto linkDescription) {
    ConnectPoint src = translate(linkDescription.getSrc());
    ConnectPoint dst = translate(linkDescription.getDst());
    Type type = translate(linkDescription.getType());
    SparseAnnotations annotations = ProtobufUtils.asAnnotations(linkDescription.getAnnotations());
    return new DefaultLinkDescription(src, dst, type, annotations);
}
#end_block

#method_before
private Link.Type translate(LinkTypeProto type) {
    switch(type) {
        case DIRECT:
            return Link.Type.DIRECT;
        case EDGE:
            return Link.Type.EDGE;
        case INDIRECT:
            return Link.Type.INDIRECT;
        case OPTICAL:
            return Link.Type.INDIRECT;
        case TUNNEL:
            return Link.Type.TUNNEL;
        case VIRTUAL:
            return Link.Type.VIRTUAL;
        case UNRECOGNIZED:
        default:
            return Link.Type.DIRECT;
    }
}
#method_after
private Type translate(LinkTypeProto type) {
    switch(type) {
        case DIRECT:
            return Type.DIRECT;
        case EDGE:
            return Type.EDGE;
        case INDIRECT:
            return Type.INDIRECT;
        case OPTICAL:
            return Type.INDIRECT;
        case TUNNEL:
            return Type.TUNNEL;
        case VIRTUAL:
            return Type.VIRTUAL;
        case UNRECOGNIZED:
        default:
            return Type.DIRECT;
    }
}
#end_block

#method_before
public static DeviceDescription translate(DeviceDescriptionProto deviceDescription) {
    URI uri = URI.create(deviceDescription.getDeviceUri());
    Device.Type type = translate(deviceDescription.getType());
    String manufacturer = deviceDescription.getManufacturer();
    String hwVersion = deviceDescription.getHwVersion();
    String swVersion = deviceDescription.getSwVersion();
    String serialNumber = deviceDescription.getSerialNumber();
    ChassisId chassis = new ChassisId(deviceDescription.getChassisId());
    boolean defaultAvailable = deviceDescription.getIsDefaultAvailable();
    return new DefaultDeviceDescription(uri, type, manufacturer, hwVersion, swVersion, serialNumber, chassis, defaultAvailable, asAnnotations(deviceDescription.getAnnotationsMap()));
}
#method_after
public static DeviceDescription translate(DeviceDescriptionProto devDescProto) {
    URI uri = URI.create(devDescProto.getDeviceUri());
    Device.Type type = translate(devDescProto.getType());
    String manufacturer = devDescProto.getManufacturer();
    String hwVersion = devDescProto.getHwVersion();
    String swVersion = devDescProto.getSwVersion();
    String serialNumber = devDescProto.getSerialNumber();
    ChassisId chassis = new ChassisId(devDescProto.getChassisId());
    boolean defaultAvailable = devDescProto.getIsDefaultAvailable();
    return new DefaultDeviceDescription(uri, type, manufacturer, hwVersion, swVersion, serialNumber, chassis, defaultAvailable, asAnnotations(devDescProto.getAnnotationsMap()));
}
#end_block

#method_before
@Activate
public void activate() {
    teTopologyConsistentMap = storageService.<TeTopologyKey, InternalTeTopology>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TETOPOLOGYKEY_INTERNALTETOPOLOGY).withRelaxedReadConsistency().build();
    teTopologyConsistentMap.addListener(teTopologyListener);
    teTopologyMap = teTopologyConsistentMap.asJavaMap();
    networkConsistentMap = storageService.<KeyId, InternalNetwork>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKID_NETWORK).withRelaxedReadConsistency().build();
    networkConsistentMap.addListener(networkListener);
    networkMap = networkConsistentMap.asJavaMap();
    teNodeConsistentMap = storageService.<TeNodeKey, InternalTeNode>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TENODEKEY_INTERNALTENODE).withRelaxedReadConsistency().build();
    teNodeConsistentMap.addListener(teNodeListener);
    teNodeMap = teNodeConsistentMap.asJavaMap();
    connMatrixConsistentMap = storageService.<ConnectivityMatrixKey, ConnectivityMatrix>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(CONNMATRIXKEY_CONNECTIVITYMATRIX).withRelaxedReadConsistency().build();
    connMatrixMap = connMatrixConsistentMap.asJavaMap();
    networkNodeConsistentMap = storageService.<NetworkNodeKey, InternalNetworkNode>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKNODEKEY_INTERNALNETWORKNODE).withRelaxedReadConsistency().build();
    networkNodeConsistentMap.addListener(networkNodeListener);
    networkNodeMap = networkNodeConsistentMap.asJavaMap();
    teLinkConsistentMap = storageService.<TeLinkTpGlobalKey, InternalTeLink>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TELINKGLOBALKEY_INTERNALTELINK).withRelaxedReadConsistency().build();
    teLinkConsistentMap.addListener(teLinkListener);
    teLinkMap = teLinkConsistentMap.asJavaMap();
    networkLinkConsistentMap = storageService.<NetworkLinkKey, InternalNetworkLink>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKLINKKEY_INTERNALNETWORKLINK).withRelaxedReadConsistency().build();
    networkLinkConsistentMap.addListener(networkLinkListener);
    networkLinkMap = networkLinkConsistentMap.asJavaMap();
    tpConsistentMap = storageService.<TerminationPointKey, InternalTerminationPoint>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TPKEY_INTERNALTERMINATIONPOINT).withRelaxedReadConsistency().build();
    tpMap = tpConsistentMap.asJavaMap();
    tpKeyConsistentMap = storageService.<TeLinkTpGlobalKey, TerminationPointKey>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TELINKTPGLOBALKEY_TERMINATIONPOINTKEY).withRelaxedReadConsistency().build();
    tpKeyMap = tpKeyConsistentMap.asJavaMap();
    ttpConsistentMap = storageService.<TtpKey, TunnelTerminationPoint>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TTPKEY_TUNNELTERMINATIONPOINT).withRelaxedReadConsistency().build();
    ttpMap = ttpConsistentMap.asJavaMap();
    nextTeTopologyId = storageService.getAtomicCounter("COUNTER_NAME");
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    teTopologyConsistentMap = storageService.<TeTopologyKey, InternalTeTopology>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TETOPOLOGYKEY_INTERNALTETOPOLOGY).withRelaxedReadConsistency().build();
    teTopologyConsistentMap.addListener(teTopologyListener);
    teTopologyMap = teTopologyConsistentMap.asJavaMap();
    networkConsistentMap = storageService.<KeyId, InternalNetwork>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKID_NETWORK).withRelaxedReadConsistency().build();
    networkConsistentMap.addListener(networkListener);
    networkMap = networkConsistentMap.asJavaMap();
    teNodeConsistentMap = storageService.<TeNodeKey, InternalTeNode>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TENODEKEY_INTERNALTENODE).withRelaxedReadConsistency().build();
    teNodeConsistentMap.addListener(teNodeListener);
    teNodeMap = teNodeConsistentMap.asJavaMap();
    connMatrixConsistentMap = storageService.<ConnectivityMatrixKey, ConnectivityMatrix>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(CONNMATRIXKEY_CONNECTIVITYMATRIX).withRelaxedReadConsistency().build();
    connMatrixMap = connMatrixConsistentMap.asJavaMap();
    networkNodeConsistentMap = storageService.<NetworkNodeKey, InternalNetworkNode>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKNODEKEY_INTERNALNETWORKNODE).withRelaxedReadConsistency().build();
    networkNodeConsistentMap.addListener(networkNodeListener);
    networkNodeMap = networkNodeConsistentMap.asJavaMap();
    teLinkConsistentMap = storageService.<TeLinkTpGlobalKey, InternalTeLink>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TELINKGLOBALKEY_INTERNALTELINK).withRelaxedReadConsistency().build();
    teLinkConsistentMap.addListener(teLinkListener);
    teLinkMap = teLinkConsistentMap.asJavaMap();
    networkLinkConsistentMap = storageService.<NetworkLinkKey, InternalNetworkLink>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(NETWORKLINKKEY_INTERNALNETWORKLINK).withRelaxedReadConsistency().build();
    networkLinkConsistentMap.addListener(networkLinkListener);
    networkLinkMap = networkLinkConsistentMap.asJavaMap();
    tpConsistentMap = storageService.<TerminationPointKey, InternalTerminationPoint>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TPKEY_INTERNALTERMINATIONPOINT).withRelaxedReadConsistency().build();
    tpMap = tpConsistentMap.asJavaMap();
    tpKeyConsistentMap = storageService.<TeLinkTpGlobalKey, TerminationPointKey>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TELINKTPGLOBALKEY_TERMINATIONPOINTKEY).withRelaxedReadConsistency().build();
    tpKeyMap = tpKeyConsistentMap.asJavaMap();
    ttpConsistentMap = storageService.<TtpKey, TunnelTerminationPoint>consistentMapBuilder().withSerializer(TETOPOLOGY_SERIALIZER).withName(TTPKEY_TUNNELTERMINATIONPOINT).withRelaxedReadConsistency().build();
    ttpMap = ttpConsistentMap.asJavaMap();
    nextTeTopologyId = storageService.getAtomicCounter(COUNTER_NAME);
    log.info("Started");
}
#end_block

#method_before
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    removeTeNodeMapEntrys(node);
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#method_after
private void removeTeNode(TeNodeKey nodeKey, boolean teNodeRemove) {
    // Remove it from InternalTeTopology first
    InternalTeTopology intTopo = teTopologyMap.get(nodeKey.teTopologyKey());
    if (intTopo != null && CollectionUtils.isNotEmpty(intTopo.teNodeKeys())) {
        intTopo.setChildUpdate(true);
        intTopo.teNodeKeys().remove(nodeKey);
    }
    // Then remove it from teNodeMap
    InternalTeNode node = teNodeMap.remove(nodeKey);
    if (node == null) {
        log.error("No node found for nodeKey {}", nodeKey);
        return;
    }
    removeTeNodeMapEntrys(node);
    // Remove it from networkNodeMap
    if (teNodeRemove && node != null) {
        removeNetworkNode(node.networkNodeKey(), teNodeRemove);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    OpenstackNodeService osNodeService = AbstractShellCommand.get(OpenstackNodeService.class);
    OpenstackNodeAdminService osNodeAdminService = AbstractShellCommand.get(OpenstackNodeAdminService.class);
    if (!isAll && hostnames == null) {
        print("Please specify either hostnames or --all option.");
        return;
    }
    if (isAll) {
        List<String> osNodes = osNodeService.nodes().stream().map(OpenstackNode::hostname).collect(Collectors.toList());
        hostnames = osNodes.toArray(new String[osNodes.size()]);
    }
    for (String hostname : hostnames) {
        OpenstackNode osNode = osNodeService.node(hostname);
        if (osNode == null) {
            print("Unable to find %s", hostname);
            continue;
        }
        print("Initializing %s", hostname);
        OpenstackNode updated = osNode.updateState(NodeState.INIT);
        osNodeAdminService.updateNode(updated);
    }
    print("Done.");
}
#method_after
@Override
protected void execute() {
    OpenstackNodeService osNodeService = AbstractShellCommand.get(OpenstackNodeService.class);
    OpenstackNodeAdminService osNodeAdminService = AbstractShellCommand.get(OpenstackNodeAdminService.class);
    if ((!isAll && !isIncomplete && hostnames == null) || (isAll && isIncomplete) || (isIncomplete && hostnames != null) || (hostnames != null && isAll)) {
        print("Please specify one of hostname, --all, and --incomplete options.");
        return;
    }
    if (isAll) {
        List<String> osNodes = osNodeService.nodes().stream().map(OpenstackNode::hostname).collect(Collectors.toList());
        hostnames = osNodes.toArray(new String[osNodes.size()]);
    } else if (isIncomplete) {
        List<String> osNodes = osNodeService.nodes().stream().filter(osNode -> osNode.state() != NodeState.COMPLETE).map(OpenstackNode::hostname).collect(Collectors.toList());
        hostnames = osNodes.toArray(new String[osNodes.size()]);
    }
    for (String hostname : hostnames) {
        OpenstackNode osNode = osNodeService.node(hostname);
        if (osNode == null) {
            print("Unable to find %s", hostname);
            continue;
        }
        print("Initializing %s", hostname);
        OpenstackNode updated = osNode.updateState(NodeState.INIT);
        osNodeAdminService.updateNode(updated);
    }
    print("Done.");
}
#end_block

#method_before
private void initializePipeline(DeviceId deviceId) {
    connectTables(deviceId, Constants.SRC_VNI_TABLE, Constants.ACL_TABLE);
    connectTables(deviceId, Constants.ACL_TABLE, Constants.JUMP_TABLE);
    setUpTableMissEntry(deviceId, Constants.ACL_TABLE);
    setupJumpTable(deviceId);
}
#method_after
private void initializePipeline(DeviceId deviceId) {
    connectTables(deviceId, Constants.SRC_VNI_TABLE, Constants.ACL_TABLE);
    connectTables(deviceId, Constants.ACL_TABLE, Constants.JUMP_TABLE);
    setupJumpTable(deviceId);
}
#end_block

#method_before
private void connectTables(DeviceId deviceId, int fromTable, int toTable) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRules(true, flowRule);
}
#method_after
private void connectTables(DeviceId deviceId, int fromTable, int toTable) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
private void setUpTableMissEntry(DeviceId deviceId, int table) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.drop();
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(table).build();
    applyRules(true, flowRule);
}
#method_after
private void setUpTableMissEntry(DeviceId deviceId, int table) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.drop();
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(table).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
private void setupJumpTable(DeviceId deviceId) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    treatment.transition(Constants.ROUTING_TABLE);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGH_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRules(true, flowRule);
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(Constants.FORWARDING_TABLE);
    flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRules(true, flowRule);
}
#method_after
private void setupJumpTable(DeviceId deviceId) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    treatment.transition(Constants.ROUTING_TABLE);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGH_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRule(flowRule, true);
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(Constants.FORWARDING_TABLE);
    flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    osNodeStore.removeListener(osNodeMapListener);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    osNodeStore.removeListener(osNodeMapListener);
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    OpenstackNode localNode = osNodeService.node(instPort.deviceId());
    if (localNode == null) {
        final String error = String.format("Cannot find openstack node for %s", instPort.deviceId());
        throw new IllegalStateException(error);
    }
    osNodeService.completeNodes(COMPUTE).stream().filter(remoteNode -> !remoteNode.intgBridge().equals(localNode.intgBridge())).forEach(remoteNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, remoteNode.intgBridge(), localNode.dataIp().getIp4Address()), remoteNode.intgBridge()).setOutput(remoteNode.tunnelPortNum()).build();
        RulePopulatorUtil.setRule(osFlowRuleService, appId, remoteNode.intgBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#method_after
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    OpenstackNode localNode = osNodeService.node(instPort.deviceId());
    if (localNode == null) {
        final String error = String.format("Cannot find openstack node for %s", instPort.deviceId());
        throw new IllegalStateException(error);
    }
    osNodeService.completeNodes(COMPUTE).stream().filter(remoteNode -> !remoteNode.intgBridge().equals(localNode.intgBridge())).forEach(remoteNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, remoteNode.intgBridge(), localNode.dataIp().getIp4Address()), remoteNode.intgBridge()).setOutput(remoteNode.tunnelPortNum()).build();
        osFlowRuleService.setRule(appId, remoteNode.intgBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#end_block

#method_before
private void setForwardingRulesForVlan(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchVlanId(getVlanId(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes(COMPUTE).stream().filter(remoteNode -> !remoteNode.intgBridge().equals(instPort.deviceId()) && remoteNode.vlanIntf() != null).forEach(remoteNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().setOutput(remoteNode.vlanPortNum()).build();
        RulePopulatorUtil.setRule(osFlowRuleService, appId, remoteNode.intgBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#method_after
private void setForwardingRulesForVlan(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchVlanId(getVlanId(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes(COMPUTE).stream().filter(remoteNode -> !remoteNode.intgBridge().equals(instPort.deviceId()) && remoteNode.vlanIntf() != null).forEach(remoteNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().setOutput(remoteNode.vlanPortNum()).build();
        osFlowRuleService.setRule(appId, remoteNode.intgBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#end_block

#method_before
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).transition(ACL_TABLE).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#method_after
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).transition(ACL_TABLE).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
private void setVlanTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(getVlanId(instPort)).transition(ACL_TABLE).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#method_after
private void setVlanTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(getVlanId(instPort)).transition(ACL_TABLE).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    OpenstackNode cNode = osNodeService.node(instPort.deviceId());
    if (cNode == null) {
        final String error = String.format("Cannot find openstack node for device %s", instPort.deviceId());
        throw new IllegalStateException(error);
    }
    if (osNet.getNetworkType() == NetworkType.VXLAN && cNode.dataIp() == null) {
        final String error = String.format(ERR_FLOW + "VXLAN mode is not ready for %s", floatingIp, cNode.hostname());
        throw new IllegalStateException(error);
    }
    if (osNet.getNetworkType() == NetworkType.VLAN && cNode.vlanIntf() == null) {
        final String error = String.format(ERR_FLOW + "VLAN mode is not ready for %s", floatingIp, cNode.hostname());
        throw new IllegalStateException(error);
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder externalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                externalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gNode.intgBridge(), cNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(gNode.tunnelPortNum());
                break;
            case VLAN:
                externalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(gNode.vlanPortNum());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gNode.intgBridge(), externalSelector, externalBuilder.build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
        // access from one VM to the others via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(gNode.tunnelPortNum()).build();
        TrafficTreatment.Builder internalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                internalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gNode.intgBridge(), cNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(PortNumber.IN_PORT);
                break;
            case VLAN:
                internalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(PortNumber.IN_PORT);
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gNode.intgBridge(), internalSelector, internalBuilder.build(), PRIORITY_FLOATING_INTERNAL, GW_COMMON_TABLE, install);
    });
}
#method_after
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    OpenstackNode cNode = osNodeService.node(instPort.deviceId());
    if (cNode == null) {
        final String error = String.format("Cannot find openstack node for device %s", instPort.deviceId());
        throw new IllegalStateException(error);
    }
    if (osNet.getNetworkType() == NetworkType.VXLAN && cNode.dataIp() == null) {
        final String error = String.format(ERR_FLOW + "VXLAN mode is not ready for %s", floatingIp, cNode.hostname());
        throw new IllegalStateException(error);
    }
    if (osNet.getNetworkType() == NetworkType.VLAN && cNode.vlanIntf() == null) {
        final String error = String.format(ERR_FLOW + "VLAN mode is not ready for %s", floatingIp, cNode.hostname());
        throw new IllegalStateException(error);
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder externalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                externalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gNode.intgBridge(), cNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(gNode.tunnelPortNum());
                break;
            case VLAN:
                externalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(gNode.vlanPortNum());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, gNode.intgBridge(), externalSelector, externalBuilder.build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
        // access from one VM to the others via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(gNode.tunnelPortNum()).build();
        TrafficTreatment.Builder internalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                internalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gNode.intgBridge(), cNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(PortNumber.IN_PORT);
                break;
            case VLAN:
                internalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(PortNumber.IN_PORT);
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, gNode.intgBridge(), internalSelector, internalBuilder.build(), PRIORITY_FLOATING_INTERNAL, GW_COMMON_TABLE, install);
    });
}
#end_block

#method_before
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(instPort.ipAddress().toIpPrefix());
    switch(osNet.getNetworkType()) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.valueOf(osNet.getProviderSegID()));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(osNet.getProviderSegID()));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
            throw new IllegalStateException(error);
    }
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC);
        if (osNet.getNetworkType().equals(NetworkType.VLAN)) {
            tBuilder.popVlan();
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gNode.intgBridge(), sBuilder.build(), tBuilder.setOutput(gNode.patchPortNum()).build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
    });
}
#method_after
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(instPort.ipAddress().toIpPrefix());
    switch(osNet.getNetworkType()) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.valueOf(osNet.getProviderSegID()));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(osNet.getProviderSegID()));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType());
            throw new IllegalStateException(error);
    }
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC);
        if (osNet.getNetworkType().equals(NetworkType.VLAN)) {
            tBuilder.popVlan();
        }
        osFlowRuleService.setRule(appId, gNode.intgBridge(), sBuilder.build(), tBuilder.setOutput(gNode.patchPortNum()).build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
    });
}
#end_block

#method_before
private boolean isGroupCreated(OpenstackNode osNode) {
    if (osNode.dataIp() != null) {
        Group osGroup = groupService.getGroup(osNode.intgBridge(), osNode.gatewayGroupKey(VXLAN));
        if (osGroup == null || osGroup.state() != Group.GroupState.ADDED) {
            return false;
        }
    }
    if (osNode.vlanIntf() != null) {
        Group osGroup = groupService.getGroup(osNode.intgBridge(), osNode.gatewayGroupKey(VLAN));
        if (osGroup == null || osGroup.state() != Group.GroupState.ADDED) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isGroupCreated(OpenstackNode osNode) {
    for (OpenstackNode gNode : osNodeService.completeNodes(GATEWAY)) {
        if (!isGatewayBucketAdded(osNode, gNode)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isGatewayBucketAdded(OpenstackNode cNode, OpenstackNode gNode) {
    if (cNode.dataIp() != null) {
        Group osGroup = groupService.getGroup(cNode.intgBridge(), cNode.gatewayGroupKey(VXLAN));
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(tunnelDstTreatment(gNode.intgBridge(), gNode.dataIp()), cNode.intgBridge()).setOutput(cNode.tunnelPortNum()).build();
        GroupBucket bucket = createSelectGroupBucket(treatment);
        if (osGroup == null || !osGroup.buckets().buckets().contains(bucket)) {
            return false;
        }
    }
    if (cNode.vlanIntf() != null) {
        Group osGroup = groupService.getGroup(cNode.intgBridge(), cNode.gatewayGroupKey(VLAN));
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(gNode.vlanPortMac()).setOutput(cNode.vlanPortNum()).build();
        GroupBucket bucket = createSelectGroupBucket(treatment);
        if (osGroup == null || !osGroup.buckets().buckets().contains(bucket)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isGatewayBucketAdded(OpenstackNode cNode, OpenstackNode gNode) {
    if (cNode.dataIp() != null) {
        Group osGroup = groupService.getGroup(cNode.intgBridge(), cNode.gatewayGroupKey(VXLAN));
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().extension(tunnelDstTreatment(gNode.intgBridge(), gNode.dataIp()), cNode.intgBridge()).setOutput(cNode.tunnelPortNum()).build();
        GroupBucket bucket = createSelectGroupBucket(treatment);
        if (osGroup == null || osGroup.state() != Group.GroupState.ADDED || !osGroup.buckets().buckets().contains(bucket)) {
            return false;
        }
    }
    if (cNode.vlanIntf() != null) {
        Group osGroup = groupService.getGroup(cNode.intgBridge(), cNode.gatewayGroupKey(VLAN));
        TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(gNode.vlanPortMac()).setOutput(cNode.vlanPortNum()).build();
        GroupBucket bucket = createSelectGroupBucket(treatment);
        if (osGroup == null || osGroup.state() != Group.GroupState.ADDED || !osGroup.buckets().buckets().contains(bucket)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#method_after
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.getIp4Address().toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#method_after
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet.getIp4Prefix()).matchIPDst(dstSubnet.getIp4Prefix()).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGateway(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix()).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNode.gatewayGroupId(NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesToController(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC).setOutput(PortNumber.CONTROLLER);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(osNode.vlanPortMac());
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    RulePopulatorUtil.setRule(osFlowRuleService, appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#method_after
private void setRulesToController(OpenstackNode osNode, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet.getIp4Prefix());
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC).setOutput(PortNumber.CONTROLLER);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(osNode.vlanPortMac());
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    osFlowRuleService.setRule(appId, osNode.intgBridge(), sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, osNode.intgBridge(), selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGatewayWithDstIp(OpenstackNode osNode, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.getIp4Address().toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, osNode.intgBridge(), selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setDownstreamRules(InstancePort srcInstPort, String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(networkType) {
        case VXLAN:
            tBuilder.setTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            tBuilder.pushVlan().setVlanId(VlanId.vlanId(segmentId)).setEthSrc(DEFAULT_GATEWAY_MAC);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    OpenstackNode srcNode = osNodeService.node(srcInstPort.deviceId());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        switch(networkType) {
            case VXLAN:
                tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, gNode.intgBridge(), srcNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(gNode.tunnelPortNum());
                break;
            case VLAN:
                tmpBuilder.setOutput(gNode.vlanPortNum());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gNode.intgBridge(), sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#method_after
private void setDownstreamRules(InstancePort srcInstPort, String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp.getIp4Address(), 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(networkType) {
        case VXLAN:
            tBuilder.setTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            tBuilder.pushVlan().setVlanId(VlanId.vlanId(segmentId)).setEthSrc(DEFAULT_GATEWAY_MAC);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    OpenstackNode srcNode = osNodeService.node(srcInstPort.deviceId());
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        switch(networkType) {
            case VXLAN:
                tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, gNode.intgBridge(), srcNode.dataIp().getIp4Address()), gNode.intgBridge()).setOutput(gNode.tunnelPortNum());
                break;
            case VLAN:
                tmpBuilder.setOutput(gNode.vlanPortNum());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, gNode.intgBridge(), sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#end_block

#method_before
private void setUpstreamRules(String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(gNode.patchPortNum());
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gNode.intgBridge(), sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#method_after
private void setUpstreamRules(String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.completeNodes(GATEWAY).forEach(gNode -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(gNode.patchPortNum());
        osFlowRuleService.setRule(appId, gNode.intgBridge(), sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#end_block

#method_before
@Test
public void testConstruction() {
    final ImmutableByteSequence high = copyFrom(0x50);
    final ImmutableByteSequence low = copyFrom(0x00);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of("vlan_tag_t", "vid");
    PiRangeFieldMatch piRangeFieldMatch = new PiRangeFieldMatch(piHeaderField, low, high);
    assertThat(piRangeFieldMatch, is(notNullValue()));
    assertThat(piRangeFieldMatch.lowValue(), is(low));
    assertThat(piRangeFieldMatch.highValue(), is(high));
    assertThat(piRangeFieldMatch.type(), is(PiMatchType.RANGE));
}
#method_after
@Test
public void testConstruction() {
    final ImmutableByteSequence high = copyFrom(0x50);
    final ImmutableByteSequence low = copyFrom(0x00);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(VLAN_HEADER_NAME, VID);
    PiRangeFieldMatch piRangeFieldMatch = new PiRangeFieldMatch(piHeaderField, low, high);
    assertThat(piRangeFieldMatch, is(notNullValue()));
    assertThat(piRangeFieldMatch.lowValue(), is(low));
    assertThat(piRangeFieldMatch.highValue(), is(high));
    assertThat(piRangeFieldMatch.type(), is(PiMatchType.RANGE));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String name = "ipv4_t";
    final String field = "dstAddr";
    final PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of(name, field);
    assertThat(piHeaderFieldId, is(notNullValue()));
    assertThat(piHeaderFieldId.headerName(), is(name));
    assertThat(piHeaderFieldId.fieldName(), is(field));
}
#method_after
@Test
public void testConstruction() {
    final String name = IPV4_HEADER_NAME;
    final String field = DST_ADDR;
    final PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of(name, field);
    assertThat(piHeaderFieldId, is(notNullValue()));
    assertThat(piHeaderFieldId.headerName(), is(name));
    assertThat(piHeaderFieldId.fieldName(), is(field));
}
#end_block

#method_before
@Test
public void testConstructionWithIndex() {
    final String name = "ipv4_t";
    final String field = "dstAddr";
    final int index = 1;
    final PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of(name, field, index);
    assertThat(piHeaderFieldId, is(notNullValue()));
    assertThat(piHeaderFieldId.headerName(), is(name));
    assertThat(piHeaderFieldId.fieldName(), is(field));
    assertThat(piHeaderFieldId.index(), is(index));
}
#method_after
@Test
public void testConstructionWithIndex() {
    final String name = IPV4_HEADER_NAME;
    final String field = DST_ADDR;
    final int index = 1;
    final PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of(name, field, index);
    assertThat(piHeaderFieldId, is(notNullValue()));
    assertThat(piHeaderFieldId.headerName(), is(name));
    assertThat(piHeaderFieldId.fieldName(), is(field));
    assertThat(piHeaderFieldId.index(), is(index));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final boolean isValid = true;
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of("vlan_tag_t", "vid");
    PiValidFieldMatch piTernaryFieldMatch = new PiValidFieldMatch(piHeaderField, isValid);
    assertThat(piTernaryFieldMatch, is(notNullValue()));
    assertThat(piTernaryFieldMatch.isValid(), is(isValid));
    assertThat(piTernaryFieldMatch.type(), is(PiMatchType.VALID));
}
#method_after
@Test
public void testConstruction() {
    final boolean isValid = true;
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(VLAN_HEADER_NAME, VID);
    PiValidFieldMatch piTernaryFieldMatch = new PiValidFieldMatch(piHeaderField, isValid);
    assertThat(piTernaryFieldMatch, is(notNullValue()));
    assertThat(piTernaryFieldMatch.isValid(), is(isValid));
    assertThat(piTernaryFieldMatch.type(), is(PiMatchType.VALID));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0806);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of("ethernet_t", "etherType");
    PiExactFieldMatch piExactFieldMatch = new PiExactFieldMatch(piHeaderField, value);
    assertThat(piExactFieldMatch, is(notNullValue()));
    assertThat(piExactFieldMatch.value(), is(value));
    assertThat(piExactFieldMatch.type(), is(PiMatchType.EXACT));
}
#method_after
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0806);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(ETH_HEADER_NAME, ETH_TYPE);
    PiExactFieldMatch piExactFieldMatch = new PiExactFieldMatch(piHeaderField, value);
    assertThat(piExactFieldMatch, is(notNullValue()));
    assertThat(piExactFieldMatch.value(), is(value));
    assertThat(piExactFieldMatch.type(), is(PiMatchType.EXACT));
}
#end_block

#method_before
@Test
public void testBuilder() {
    PiTableId piTableId = PiTableId.of("table10");
    long cookie = 0xfff0323;
    int priority = 100;
    double timeout = 1000;
    PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of("ipv4_t", "dstAddr");
    PiFieldMatch piFieldMatch = new PiExactFieldMatch(piHeaderFieldId, ImmutableByteSequence.copyFrom(0x0a010101));
    PiAction piAction = PiAction.builder().withId(PiActionId.of("drop")).build();
    final Map<PiHeaderFieldId, PiFieldMatch> fieldMatches = Maps.newHashMap();
    fieldMatches.put(piHeaderFieldId, piFieldMatch);
    final PiTableEntry piTableEntry = PiTableEntry.builder().forTable(piTableId).withFieldMatches(fieldMatches.values()).withAction(piAction).withCookie(cookie).withPriority(priority).withTimeout(timeout).build();
    assertThat(piTableEntry.table(), is(piTableId));
    assertThat(piTableEntry.cookie(), is(cookie));
    assertThat(piTableEntry.priority().get(), is(priority));
    assertThat(piTableEntry.timeout().get(), is(timeout));
    assertThat("Incorrect match param value", CollectionUtils.isEqualCollection(piTableEntry.fieldMatches(), fieldMatches.values()));
    assertThat(piTableEntry.action(), is(piAction));
}
#method_after
@Test
public void testBuilder() {
    PiTableId piTableId = PiTableId.of("table10");
    long cookie = 0xfff0323;
    int priority = 100;
    double timeout = 1000;
    PiHeaderFieldId piHeaderFieldId = PiHeaderFieldId.of(IPV4_HEADER_NAME, DST_ADDR);
    PiFieldMatch piFieldMatch = new PiExactFieldMatch(piHeaderFieldId, ImmutableByteSequence.copyFrom(0x0a010101));
    PiAction piAction = PiAction.builder().withId(PiActionId.of(DROP)).build();
    final Map<PiHeaderFieldId, PiFieldMatch> fieldMatches = Maps.newHashMap();
    fieldMatches.put(piHeaderFieldId, piFieldMatch);
    final PiTableEntry piTableEntry = PiTableEntry.builder().forTable(piTableId).withFieldMatches(fieldMatches.values()).withAction(piAction).withCookie(cookie).withPriority(priority).withTimeout(timeout).build();
    assertThat(piTableEntry.table(), is(piTableId));
    assertThat(piTableEntry.cookie(), is(cookie));
    assertThat(piTableEntry.priority().get(), is(priority));
    assertThat(piTableEntry.timeout().get(), is(timeout));
    assertThat("Incorrect match param value", CollectionUtils.isEqualCollection(piTableEntry.fieldMatches(), fieldMatches.values()));
    assertThat(piTableEntry.action(), is(piAction));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String param = "srcAddr";
    final PiActionParamId actionParamId = PiActionParamId.of("srcAddr");
    assertThat(actionParamId, is(notNullValue()));
    assertThat(actionParamId.name(), is(param));
}
#method_after
@Test
public void testConstruction() {
    final String param = SRC_ADDR;
    final PiActionParamId actionParamId = PiActionParamId.of(SRC_ADDR);
    assertThat(actionParamId, is(notNullValue()));
    assertThat(actionParamId.name(), is(param));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final String id = "dec_ttl";
    final PiActionId actionId = PiActionId.of(id);
    assertThat(actionId, is(notNullValue()));
    assertThat(actionId.name(), is(id));
}
#method_after
@Test
public void testConstruction() {
    final String id = DEC_TTL;
    final PiActionId actionId = PiActionId.of(id);
    assertThat(actionId, is(notNullValue()));
    assertThat(actionId.name(), is(id));
}
#end_block

#method_before
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0a01010a);
    int lpmMask = 0x00ffffff;
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of("ipv4_t", "dstAddr");
    PiLpmFieldMatch piLpmFieldMatch = new PiLpmFieldMatch(piHeaderField, value, lpmMask);
    assertThat(piLpmFieldMatch, is(notNullValue()));
    assertThat(piLpmFieldMatch.value(), is(value));
    assertThat(piLpmFieldMatch.prefixLength(), is(lpmMask));
    assertThat(piLpmFieldMatch.type(), is(PiMatchType.LPM));
}
#method_after
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0a01010a);
    int prefix = 24;
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(IPV4_HEADER_NAME, DST_ADDR);
    PiLpmFieldMatch piLpmFieldMatch = new PiLpmFieldMatch(piHeaderField, value, prefix);
    assertThat(piLpmFieldMatch, is(notNullValue()));
    assertThat(piLpmFieldMatch.value(), is(value));
    assertThat(piLpmFieldMatch.prefixLength(), is(prefix));
    assertThat(piLpmFieldMatch.type(), is(PiMatchType.LPM));
}
#end_block

#method_before
@Test
public void basics() {
    PiHeaderFieldId id = PiHeaderFieldId.of("of", "foo.bar");
}
#method_after
@Test
public void basics() {
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(ETH_HEADER_NAME, ETH_TYPE);
    PiFieldMatch piFieldMatch = new PiExactFieldMatch(piHeaderField, copyFrom(0x0806));
    assertEquals(piFieldMatch.fieldId(), piHeaderField);
    assertEquals(piFieldMatch.type(), PiMatchType.EXACT);
}
#end_block

#method_before
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0a01010a);
    final ImmutableByteSequence mask = copyFrom(0x00ffffff);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of("ipv4_t", "dstAddr");
    PiTernaryFieldMatch piTernaryFieldMatch = new PiTernaryFieldMatch(piHeaderField, value, mask);
    assertThat(piTernaryFieldMatch, is(notNullValue()));
    assertThat(piTernaryFieldMatch.value(), is(value));
    assertThat(piTernaryFieldMatch.mask(), is(mask));
    assertThat(piTernaryFieldMatch.type(), is(PiMatchType.TERNARY));
}
#method_after
@Test
public void testConstruction() {
    final ImmutableByteSequence value = copyFrom(0x0a01010a);
    final ImmutableByteSequence mask = copyFrom(0x00ffffff);
    final PiHeaderFieldId piHeaderField = PiHeaderFieldId.of(IPV4_HEADER_NAME, DST_ADDR);
    PiTernaryFieldMatch piTernaryFieldMatch = new PiTernaryFieldMatch(piHeaderField, value, mask);
    assertThat(piTernaryFieldMatch, is(notNullValue()));
    assertThat(piTernaryFieldMatch.value(), is(value));
    assertThat(piTernaryFieldMatch.mask(), is(mask));
    assertThat(piTernaryFieldMatch.type(), is(PiMatchType.TERNARY));
}
#end_block

#method_before
@Test
public void testConstruction() {
    ImmutableByteSequence value = copyFrom(0x0b010102);
    final PiActionParamId piActionParamId = PiActionParamId.of("srcAddr");
    final PiActionParam piActionParam = new PiActionParam(piActionParamId, value);
    assertThat(piActionParam, is(notNullValue()));
    assertThat(piActionParam.id(), is(piActionParamId));
    assertThat(piActionParam.value(), is(value));
}
#method_after
@Test
public void testConstruction() {
    ImmutableByteSequence value = copyFrom(0x0b010102);
    final PiActionParamId piActionParamId = PiActionParamId.of(SRC_ADDR);
    final PiActionParam piActionParam = new PiActionParam(piActionParamId, value);
    assertThat(piActionParam, is(notNullValue()));
    assertThat(piActionParam.id(), is(piActionParamId));
    assertThat(piActionParam.value(), is(value));
}
#end_block

#method_before
@Test
public void testMethodWithParameter() {
    PiActionId piActionId = PiActionId.of("mod_nw_dst");
    PiActionParam piActionParam = new PiActionParam(PiActionParamId.of("dstAddr"), copyFrom(0x0a010101));
    final PiAction piAction = PiAction.builder().withId(piActionId).withParameter(piActionParam).build();
    assertThat(piAction, is(notNullValue()));
    assertThat(piAction.id(), is(piActionId));
    assertThat(piAction.type(), is(PiTableAction.Type.ACTION));
}
#method_after
@Test
public void testMethodWithParameter() {
    PiActionId piActionId = PiActionId.of(MOD_NW_DST);
    PiActionParam piActionParam = new PiActionParam(PiActionParamId.of(DST_ADDR), copyFrom(0x0a010101));
    final PiAction piAction = PiAction.builder().withId(piActionId).withParameter(piActionParam).build();
    assertThat(piAction, is(notNullValue()));
    assertThat(piAction.id(), is(piActionId));
    assertThat(piAction.type(), is(PiTableAction.Type.ACTION));
}
#end_block

#method_before
@Test
public void testMethodWithParameters() {
    PiActionId piActionId = PiActionId.of("mod_nw_dst");
    Collection<PiActionParam> runtimeParams = Lists.newArrayList();
    PiActionParam piActionParam = new PiActionParam(PiActionParamId.of("dstAddr"), copyFrom(0x0a010101));
    runtimeParams.add(piActionParam);
    final PiAction piAction = PiAction.builder().withId(piActionId).withParameters(runtimeParams).build();
    assertThat(piAction, is(notNullValue()));
    assertThat(piAction.id(), is(piActionId));
    assertThat(piAction.parameters(), is(runtimeParams));
    assertThat(piAction.type(), is(PiTableAction.Type.ACTION));
}
#method_after
@Test
public void testMethodWithParameters() {
    PiActionId piActionId = PiActionId.of(MOD_NW_DST);
    Collection<PiActionParam> runtimeParams = Lists.newArrayList();
    PiActionParam piActionParam = new PiActionParam(PiActionParamId.of(DST_ADDR), copyFrom(0x0a010101));
    runtimeParams.add(piActionParam);
    final PiAction piAction = PiAction.builder().withId(piActionId).withParameters(runtimeParams).build();
    assertThat(piAction, is(notNullValue()));
    assertThat(piAction.id(), is(piActionId));
    assertThat(piAction.parameters(), is(runtimeParams));
    assertThat(piAction.type(), is(PiTableAction.Type.ACTION));
}
#end_block

#method_before
public static MacAddress valueOf(final String address) {
    if (!validateMAC(address)) {
        throw new IllegalArgumentException("Specified MAC Address must contain 12 hex digits" + " separated pairwise by :'s." + address);
    }
    final String[] elements = address.split(":");
    final byte[] addressInBytes = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    for (int i = 0; i < MacAddress.MAC_ADDRESS_LENGTH; i++) {
        final String element = elements[i];
        addressInBytes[i] = (byte) Integer.parseInt(element, 16);
    }
    return new MacAddress(addressInBytes);
}
#method_after
public static MacAddress valueOf(final String address) {
    if (!isValid(address)) {
        throw new IllegalArgumentException("Specified MAC Address must contain 12 hex digits" + " separated pairwise by :'s.");
    }
    final String[] elements = address.split(":");
    final byte[] addressInBytes = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    for (int i = 0; i < MacAddress.MAC_ADDRESS_LENGTH; i++) {
        final String element = elements[i];
        addressInBytes[i] = (byte) Integer.parseInt(element, 16);
    }
    return new MacAddress(addressInBytes);
}
#end_block

#method_before
public MsgType getPacketType() {
    return this.options.parallelStream().filter(op -> op.getCode() == DHCPOptionCode.OptionCode_MessageType.getValue()).map(DhcpOption::getData).map(data -> data[0]).map(MsgType::getType).findFirst().orElse(null);
}
#method_after
public MsgType getPacketType() {
    return this.options.parallelStream().filter(op -> op.getCode() == DHCPOptionCode.OptionCode_MessageType.getValue()).map(DhcpOption::getData).filter(data -> data.length != 0).map(data -> data[0]).map(MsgType::getType).findFirst().orElse(null);
}
#end_block

#method_before
@Override
public byte[] serialize() {
    // not guaranteed to retain length/exact format
    this.resetChecksum();
    // minimum size 240 including magic cookie, options generally padded to
    // 300
    int optionsLength = 0;
    for (final DhcpOption option : this.options) {
        if (option.getCode() == 0 || option.getCode() == ((byte) 255)) {
            optionsLength += 1;
        } else {
            optionsLength += 2 + (0xff & option.getLength());
        }
    }
    int optionsPadLength = 0;
    if (optionsLength < 60) {
        optionsPadLength = 60 - optionsLength;
    }
    final byte[] data = new byte[240 + optionsLength + optionsPadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.opCode);
    bb.put(this.hardwareType);
    bb.put(this.hardwareAddressLength);
    bb.put(this.hops);
    bb.putInt(this.transactionId);
    bb.putShort(this.seconds);
    bb.putShort(this.flags);
    bb.putInt(this.clientIPAddress);
    bb.putInt(this.yourIPAddress);
    bb.putInt(this.serverIPAddress);
    bb.putInt(this.gatewayIPAddress);
    checkArgument(this.clientHardwareAddress.length <= 16, "Hardware address is too long (%s bytes)", this.clientHardwareAddress.length);
    bb.put(this.clientHardwareAddress);
    if (this.clientHardwareAddress.length < 16) {
        for (int i = 0; i < 16 - this.clientHardwareAddress.length; ++i) {
            bb.put((byte) 0x0);
        }
    }
    this.writeString(this.serverName, bb, 64);
    this.writeString(this.bootFileName, bb, 128);
    // magic cookie
    bb.put((byte) 0x63);
    bb.put((byte) 0x82);
    bb.put((byte) 0x53);
    bb.put((byte) 0x63);
    for (final DhcpOption option : this.options) {
        bb.put(option.serialize());
    }
    // assume the rest is padded out with zeroes
    return data;
}
#method_after
@Override
public byte[] serialize() {
    // not guaranteed to retain length/exact format
    this.resetChecksum();
    // minimum size 240 including magic cookie, options generally padded to
    // 300
    int optionsLength = 0;
    for (final DhcpOption option : this.options) {
        if (option.getCode() == DHCPOptionCode.OptionCode_Pad.getValue() || option.getCode() == DHCPOptionCode.OptionCode_END.getValue()) {
            optionsLength += 1;
        } else {
            optionsLength += 2 + (UNSIGNED_BYTE_MASK & option.getLength());
        }
    }
    int optionsPadLength = 0;
    if (optionsLength < BASE_OPTION_LEN) {
        optionsPadLength = BASE_OPTION_LEN - optionsLength;
    }
    final byte[] data = new byte[MIN_DHCP_LEN + optionsLength + optionsPadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.opCode);
    bb.put(this.hardwareType);
    bb.put(this.hardwareAddressLength);
    bb.put(this.hops);
    bb.putInt(this.transactionId);
    bb.putShort(this.seconds);
    bb.putShort(this.flags);
    bb.putInt(this.clientIPAddress);
    bb.putInt(this.yourIPAddress);
    bb.putInt(this.serverIPAddress);
    bb.putInt(this.gatewayIPAddress);
    checkArgument(this.clientHardwareAddress.length <= BASE_HW_ADDR_LEN, "Hardware address is too long (%s bytes)", this.clientHardwareAddress.length);
    bb.put(this.clientHardwareAddress);
    if (this.clientHardwareAddress.length < BASE_HW_ADDR_LEN) {
        for (int i = 0; i < BASE_HW_ADDR_LEN - this.clientHardwareAddress.length; ++i) {
            bb.put(PAD_BYTE);
        }
    }
    this.writeString(this.serverName, bb, BASE_SERVER_NAME_LEN);
    this.writeString(this.bootFileName, bb, BASE_BOOT_FILE_NAME_LEN);
    // magic cookie
    bb.putInt(MAGIC_COOKIE);
    for (final DhcpOption option : this.options) {
        bb.put(option.serialize());
    }
    // assume the rest is padded out with zeroes
    return data;
}
#end_block

#method_before
protected void writeString(final String string, final ByteBuffer bb, final int maxLength) {
    if (string == null) {
        for (int i = 0; i < maxLength; ++i) {
            bb.put((byte) 0x0);
        }
    } else {
        byte[] bytes;
        try {
            bytes = string.getBytes("ascii");
        } catch (final UnsupportedEncodingException e) {
            throw new RuntimeException("Failure encoding server name", e);
        }
        int writeLength = bytes.length;
        if (writeLength > maxLength) {
            writeLength = maxLength;
        }
        bb.put(bytes, 0, writeLength);
        for (int i = writeLength; i < maxLength; ++i) {
            bb.put((byte) 0x0);
        }
    }
}
#method_after
protected void writeString(final String string, final ByteBuffer bb, final int maxLength) {
    if (string == null) {
        for (int i = 0; i < maxLength; ++i) {
            bb.put(PAD_BYTE);
        }
    } else {
        byte[] bytes;
        bytes = string.getBytes(StandardCharsets.US_ASCII);
        int writeLength = bytes.length;
        if (writeLength > maxLength) {
            writeLength = maxLength;
        }
        bb.put(bytes, 0, writeLength);
        for (int i = writeLength; i < maxLength; ++i) {
            bb.put((byte) 0x0);
        }
    }
}
#end_block

#method_before
private static String readString(final ByteBuffer bb, final int maxLength) {
    final byte[] bytes = new byte[maxLength];
    bb.get(bytes);
    String result = null;
    try {
        result = new String(bytes, "ascii").trim();
    } catch (final UnsupportedEncodingException e) {
        throw new RuntimeException("Failure decoding string", e);
    }
    return result;
}
#method_after
private static String readString(final ByteBuffer bb, final int maxLength) {
    final byte[] bytes = new byte[maxLength];
    bb.get(bytes);
    String result;
    result = new String(bytes, StandardCharsets.US_ASCII).trim();
    return result;
}
#end_block

#method_before
public static Deserializer<DHCP> deserializer() {
    return (data, offset, length) -> {
        checkInput(data, offset, length, MIN_HEADER_LENGTH);
        ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        DHCP dhcp = new DHCP();
        dhcp.opCode = bb.get();
        dhcp.hardwareType = bb.get();
        dhcp.hardwareAddressLength = bb.get();
        dhcp.hops = bb.get();
        dhcp.transactionId = bb.getInt();
        dhcp.seconds = bb.getShort();
        dhcp.flags = bb.getShort();
        dhcp.clientIPAddress = bb.getInt();
        dhcp.yourIPAddress = bb.getInt();
        dhcp.serverIPAddress = bb.getInt();
        dhcp.gatewayIPAddress = bb.getInt();
        final int hardwareAddressLength = 0xff & dhcp.hardwareAddressLength;
        dhcp.clientHardwareAddress = new byte[hardwareAddressLength];
        bb.get(dhcp.clientHardwareAddress);
        for (int i = hardwareAddressLength; i < 16; ++i) {
            bb.get();
        }
        dhcp.serverName = readString(bb, 64);
        dhcp.bootFileName = readString(bb, 128);
        // read the magic cookie
        // magic cookie
        bb.get();
        bb.get();
        bb.get();
        bb.get();
        // read options
        boolean foundEndOptionsMarker = false;
        while (bb.hasRemaining()) {
            DhcpOption option;
            int pos = bb.position();
            // to unsigned integer
            int optCode = 0xff & bb.array()[pos];
            int optLen;
            byte[] optData;
            if (optCode == DHCPOptionCode.OptionCode_Pad.value) {
                // pad, skip
                // read option code
                bb.get();
                continue;
            }
            if (optCode == (0xff & DHCPOptionCode.OptionCode_END.value)) {
                // end of dhcp options or invalid option and set the END option
                option = new DhcpOption();
                option.setCode((byte) optCode);
                dhcp.options.add(option);
                foundEndOptionsMarker = true;
                break;
            }
            if (bb.remaining() < 2) {
                // No option length
                throw new DeserializationException("Buffer underflow while reading DHCP option");
            }
            optLen = 0xff & bb.array()[pos + 1];
            if (bb.remaining() < DhcpOption.DEFAULT_LEN + optLen) {
                // Invalid option length
                throw new DeserializationException("Buffer underflow while reading DHCP option");
            }
            optData = new byte[DhcpOption.DEFAULT_LEN + optLen];
            bb.get(optData);
            if (OPTION_DESERIALIZERS.containsKey((byte) optCode)) {
                option = OPTION_DESERIALIZERS.get((byte) optCode).deserialize(optData, 0, optData.length);
                dhcp.options.add(option);
            } else {
                // default option
                option = DhcpOption.deserializer().deserialize(optData, 0, optData.length);
                dhcp.options.add(option);
            }
        }
        if (!foundEndOptionsMarker) {
            throw new DeserializationException("DHCP End options marker was missing");
        }
        return dhcp;
    };
}
#method_after
public static Deserializer<DHCP> deserializer() {
    return (data, offset, length) -> {
        checkInput(data, offset, length, MIN_HEADER_LENGTH);
        ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
        DHCP dhcp = new DHCP();
        dhcp.opCode = bb.get();
        dhcp.hardwareType = bb.get();
        dhcp.hardwareAddressLength = bb.get();
        dhcp.hops = bb.get();
        dhcp.transactionId = bb.getInt();
        dhcp.seconds = bb.getShort();
        dhcp.flags = bb.getShort();
        dhcp.clientIPAddress = bb.getInt();
        dhcp.yourIPAddress = bb.getInt();
        dhcp.serverIPAddress = bb.getInt();
        dhcp.gatewayIPAddress = bb.getInt();
        final int hardwareAddressLength = UNSIGNED_BYTE_MASK & dhcp.hardwareAddressLength;
        dhcp.clientHardwareAddress = new byte[hardwareAddressLength];
        bb.get(dhcp.clientHardwareAddress);
        for (int i = hardwareAddressLength; i < BASE_HW_ADDR_LEN; ++i) {
            bb.get();
        }
        dhcp.serverName = readString(bb, BASE_SERVER_NAME_LEN);
        dhcp.bootFileName = readString(bb, BASE_BOOT_FILE_NAME_LEN);
        // read the magic cookie
        // magic cookie
        bb.getInt();
        // read options
        boolean foundEndOptionsMarker = false;
        while (bb.hasRemaining()) {
            DhcpOption option;
            int pos = bb.position();
            // to unsigned integer
            int optCode = UNSIGNED_BYTE_MASK & bb.array()[pos];
            int optLen;
            byte[] optData;
            if (optCode == DHCPOptionCode.OptionCode_Pad.value) {
                // pad, skip
                // read option code
                bb.get();
                continue;
            }
            if (optCode == (UNSIGNED_BYTE_MASK & DHCPOptionCode.OptionCode_END.value)) {
                // end of dhcp options or invalid option and set the END option
                option = new DhcpOption();
                option.setCode((byte) optCode);
                dhcp.options.add(option);
                foundEndOptionsMarker = true;
                break;
            }
            if (bb.remaining() < 2) {
                // No option length
                throw new DeserializationException("Buffer underflow while reading DHCP option");
            }
            optLen = UNSIGNED_BYTE_MASK & bb.array()[pos + 1];
            if (bb.remaining() < DhcpOption.DEFAULT_LEN + optLen) {
                // Invalid option length
                throw new DeserializationException("Buffer underflow while reading DHCP option");
            }
            optData = new byte[DhcpOption.DEFAULT_LEN + optLen];
            bb.get(optData);
            if (OPTION_DESERIALIZERS.containsKey((byte) optCode)) {
                option = OPTION_DESERIALIZERS.get((byte) optCode).deserialize(optData, 0, optData.length);
                dhcp.options.add(option);
            } else {
                // default option
                option = DhcpOption.deserializer().deserialize(optData, 0, optData.length);
                dhcp.options.add(option);
            }
        }
        if (!foundEndOptionsMarker) {
            throw new DeserializationException("DHCP End options marker was missing");
        }
        return dhcp;
    };
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + this.code;
    result = prime * result + Arrays.hashCode(this.data);
    result = prime * result + this.length;
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(code, length, data);
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof DhcpOption)) {
        return false;
    }
    final DhcpOption other = (DhcpOption) obj;
    if (this.code != other.code) {
        return false;
    }
    if (!Arrays.equals(this.data, other.data)) {
        return false;
    }
    if (this.length != other.length) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof DhcpOption)) {
        return false;
    }
    final DhcpOption other = (DhcpOption) obj;
    return Objects.equals(this.code, other.code) && Objects.equals(this.length, other.length) && Arrays.equals(this.data, other.data);
}
#end_block

#method_before
public static CircuitId deserialize(byte[] circuitId) {
    String cIdString = new String(circuitId, StandardCharsets.US_ASCII);
    List<String> split = Lists.newArrayList(cIdString.split(SEPERATOR));
    checkArgument(split.size() > 1, "Illegal circuit id.");
    // remove last element (vlan id)
    String vlanId = split.remove(split.size() - 1);
    String connectPoint = String.join(SEPERATOR, split);
    return new CircuitId(connectPoint, VlanId.vlanId(vlanId));
}
#method_after
public static CircuitId deserialize(byte[] circuitId) {
    String cIdString = new String(circuitId, StandardCharsets.US_ASCII);
    List<String> split = Lists.newArrayList(cIdString.split(SEPARATOR));
    checkArgument(split.size() > 1, "Illegal circuit id.");
    // remove last element (vlan id)
    String vlanId = split.remove(split.size() - 1);
    String connectPoint = String.join(SEPARATOR, split);
    return new CircuitId(connectPoint, VlanId.vlanId(vlanId));
}
#end_block

#method_before
private void initializePipeline(DeviceId deviceId) {
    connectTables(deviceId, Constants.SRC_VNI_TABLE, Constants.ACL_TABLE);
    connectTables(deviceId, Constants.ACL_TABLE, Constants.JUMP_TABLE);
    setUpTableMissEntry(deviceId, Constants.ACL_TABLE);
    setupJumpTable(deviceId);
}
#method_after
private void initializePipeline(DeviceId deviceId) {
    connectTables(deviceId, Constants.SRC_VNI_TABLE, Constants.ACL_TABLE);
    connectTables(deviceId, Constants.ACL_TABLE, Constants.JUMP_TABLE);
    setupJumpTable(deviceId);
}
#end_block

#method_before
private void connectTables(DeviceId deviceId, int fromTable, int toTable) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRules(true, flowRule);
}
#method_after
private void connectTables(DeviceId deviceId, int fromTable, int toTable) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.transition(toTable);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(fromTable).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
private void setUpTableMissEntry(DeviceId deviceId, int table) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.drop();
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(table).build();
    applyRules(true, flowRule);
}
#method_after
private void setUpTableMissEntry(DeviceId deviceId, int table) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.drop();
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(table).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
private void setupJumpTable(DeviceId deviceId) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    treatment.transition(Constants.ROUTING_TABLE);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGH_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRules(true, flowRule);
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(Constants.FORWARDING_TABLE);
    flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRules(true, flowRule);
}
#method_after
private void setupJumpTable(DeviceId deviceId) {
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    selector.matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    treatment.transition(Constants.ROUTING_TABLE);
    FlowRule flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(HIGH_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRule(flowRule, true);
    selector = DefaultTrafficSelector.builder();
    treatment = DefaultTrafficTreatment.builder();
    treatment.transition(Constants.FORWARDING_TABLE);
    flowRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DROP_PRIORITY).fromApp(appId).makePermanent().forTable(Constants.JUMP_TABLE).build();
    applyRule(flowRule, true);
}
#end_block

#method_before
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#method_after
private void setGatewayIcmpRule(IpAddress gatewayIp, DeviceId deviceId, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).matchIPDst(gatewayIp.toIpPrefix()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(PortNumber.CONTROLLER).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_ICMP_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#method_after
private void setInternalRouterRules(DeviceId deviceId, String srcSegmentId, String dstSegmentId, IpPrefix srcSubnet, IpPrefix dstSubnet, NetworkType networkType, boolean install) {
    TrafficSelector selector;
    TrafficTreatment treatment;
    switch(networkType) {
        case VXLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.parseLong(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setTunnelId(Long.parseLong(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        case VLAN:
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(srcSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(dstSegmentId)).matchIPSrc(srcSubnet).matchIPDst(dstSubnet).build();
            treatment = DefaultTrafficTreatment.builder().setVlanId(VlanId.vlanId(dstSegmentId)).transition(FORWARDING_TABLE).build();
            osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_INTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
}
#end_block

#method_before
private void setRulesToGateway(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGateway(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficTreatment treatment;
    GroupId groupId;
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VXLAN);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            groupId = osNodeService.gatewayGroupId(deviceId, NetworkMode.VLAN);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), treatment, PRIORITY_EXTERNAL_ROUTING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(MacAddress.valueOf(vlanPortMac(deviceId)));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC);
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.setOutput(PortNumber.CONTROLLER);
    RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#method_after
private void setRulesToController(DeviceId deviceId, String segmentId, IpPrefix srcSubnet, NetworkType networkType, boolean install) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(srcSubnet);
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId)).matchEthDst(Constants.DEFAULT_GATEWAY_MAC);
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId)).matchEthDst(MacAddress.valueOf(vlanPortMac(deviceId)));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(Constants.DEFAULT_GATEWAY_MAC);
    if (networkType.equals(NetworkType.VLAN)) {
        tBuilder.popVlan();
    }
    tBuilder.setOutput(PortNumber.CONTROLLER);
    osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tBuilder.build(), PRIORITY_EXTERNAL_ROUTING_RULE, Constants.GW_COMMON_TABLE, install);
}
#end_block

#method_before
private void setRulesToGatewayWithDstIp(DeviceId deviceId, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#method_after
private void setRulesToGatewayWithDstIp(DeviceId deviceId, GroupId groupId, String segmentId, IpAddress dstIp, NetworkMode networkMode, boolean install) {
    TrafficSelector selector;
    if (networkMode.equals(NetworkMode.VXLAN)) {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Long.valueOf(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    } else {
        selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchVlanId(VlanId.vlanId(segmentId)).matchIPDst(dstIp.toIpPrefix()).build();
    }
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().group(groupId).build();
    osFlowRuleService.setRule(appId, deviceId, selector, treatment, PRIORITY_SWITCHING_RULE, ROUTING_TABLE, install);
}
#end_block

#method_before
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> !osNode.intBridge().equals(instPort.deviceId())).forEach(osNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, osNode.intBridge(), osNodeService.dataIp(instPort.deviceId()).get().getIp4Address()), osNode.intBridge()).setOutput(osNodeService.tunnelPort(osNode.intBridge()).get()).build();
        RulePopulatorUtil.setRule(osFlowRuleService, appId, osNode.intBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#method_after
private void setForwardingRules(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchTunnelId(getVni(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> !osNode.intBridge().equals(instPort.deviceId())).forEach(osNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().extension(buildExtension(deviceService, osNode.intBridge(), osNodeService.dataIp(instPort.deviceId()).get().getIp4Address()), osNode.intBridge()).setOutput(osNodeService.tunnelPort(osNode.intBridge()).get()).build();
        osFlowRuleService.setRule(appId, osNode.intBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#end_block

#method_before
private void setForwardingRulesForVlan(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchVlanId(getVlanId(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> !osNode.intBridge().equals(instPort.deviceId())).filter(osNode -> osNode.vlanPort().isPresent()).forEach(osNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().setOutput(osNodeService.vlanPort(osNode.intBridge()).get()).build();
        RulePopulatorUtil.setRule(osFlowRuleService, appId, osNode.intBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#method_after
private void setForwardingRulesForVlan(InstancePort instPort, boolean install) {
    // switching rules for the instPorts in the same node
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(instPort.ipAddress().toIpPrefix()).matchVlanId(getVlanId(instPort)).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().popVlan().setEthDst(instPort.macAddress()).setOutput(instPort.portNumber()).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    // switching rules for the instPorts in the remote node
    osNodeService.completeNodes().stream().filter(osNode -> osNode.type() == COMPUTE).filter(osNode -> !osNode.intBridge().equals(instPort.deviceId())).filter(osNode -> osNode.vlanPort().isPresent()).forEach(osNode -> {
        TrafficTreatment treatmentToRemote = DefaultTrafficTreatment.builder().setOutput(osNodeService.vlanPort(osNode.intBridge()).get()).build();
        osFlowRuleService.setRule(appId, osNode.intBridge(), selector, treatmentToRemote, PRIORITY_SWITCHING_RULE, FORWARDING_TABLE, install);
    });
}
#end_block

#method_before
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).transition(ACL_TABLE).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#method_after
private void setTunnelTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setTunnelId(getVni(instPort)).transition(ACL_TABLE).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
private void setVlanTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(getVlanId(instPort)).transition(ACL_TABLE).build();
    RulePopulatorUtil.setRule(osFlowRuleService, appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#method_after
private void setVlanTagFlowRules(InstancePort instPort, boolean install) {
    TrafficSelector selector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchInPort(instPort.portNumber()).build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().pushVlan().setVlanId(getVlanId(instPort)).transition(ACL_TABLE).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), selector, treatment, PRIORITY_TUNNEL_TAG_RULE, SRC_VNI_TABLE, install);
}
#end_block

#method_before
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    Optional<IpAddress> dataIp = osNodeService.dataIp(instPort.deviceId());
    if (!dataIp.isPresent()) {
        log.warn(ERR_FLOW + "compute node {} is not ready", floatingIp, instPort.deviceId());
        return;
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment.Builder externalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                externalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(osNodeService.tunnelPort(gnodeId).get());
                break;
            case VLAN:
                externalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(osNodeService.vlanPort(gnodeId).get());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gnodeId, externalSelector, externalBuilder.build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
        // access from one VM to the other via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(osNodeService.tunnelPort(gnodeId).get()).build();
        TrafficTreatment.Builder internalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                internalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(PortNumber.IN_PORT);
                break;
            case VLAN:
                internalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(PortNumber.IN_PORT);
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gnodeId, internalSelector, internalBuilder.build(), PRIORITY_FLOATING_INTERNAL, GW_COMMON_TABLE, install);
    });
}
#method_after
private void setDownstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    Optional<IpAddress> dataIp = osNodeService.dataIp(instPort.deviceId());
    if (!dataIp.isPresent()) {
        log.warn(ERR_FLOW + "compute node {} is not ready", floatingIp, instPort.deviceId());
        return;
    }
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector externalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).build();
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment.Builder externalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                externalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(osNodeService.tunnelPort(gnodeId).get());
                break;
            case VLAN:
                externalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(osNodeService.vlanPort(gnodeId).get());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, gnodeId, externalSelector, externalBuilder.build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
        // access from one VM to the other via floating IP
        TrafficSelector internalSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPDst(floating.toIpPrefix()).matchInPort(osNodeService.tunnelPort(gnodeId).get()).build();
        TrafficTreatment.Builder internalBuilder = DefaultTrafficTreatment.builder().setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(instPort.macAddress()).setIpDst(instPort.ipAddress().getIp4Address());
        switch(osNet.getNetworkType()) {
            case VXLAN:
                internalBuilder.setTunnelId(Long.valueOf(osNet.getProviderSegID())).extension(buildExtension(deviceService, gnodeId, dataIp.get().getIp4Address()), gnodeId).setOutput(PortNumber.IN_PORT);
                break;
            case VLAN:
                internalBuilder.pushVlan().setVlanId(VlanId.vlanId(osNet.getProviderSegID())).setOutput(PortNumber.IN_PORT);
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, gnodeId, internalSelector, internalBuilder.build(), PRIORITY_FLOATING_INTERNAL, GW_COMMON_TABLE, install);
    });
}
#end_block

#method_before
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(instPort.ipAddress().toIpPrefix());
    switch(osNet.getNetworkType()) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.valueOf(osNet.getProviderSegID()));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(osNet.getProviderSegID()));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC);
        if (osNet.getNetworkType().equals(NetworkType.VLAN)) {
            tBuilder.popVlan();
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, gnodeId, sBuilder.build(), tBuilder.setOutput(osNodeService.externalPort(gnodeId).get()).build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
    });
}
#method_after
private void setUpstreamRules(NetFloatingIP floatingIp, Network osNet, InstancePort instPort, boolean install) {
    IpAddress floating = IpAddress.valueOf(floatingIp.getFloatingIpAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPSrc(instPort.ipAddress().toIpPrefix());
    switch(osNet.getNetworkType()) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.valueOf(osNet.getProviderSegID()));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(osNet.getProviderSegID()));
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", osNet.getNetworkType().toString());
            throw new IllegalStateException(error);
    }
    osNodeService.gatewayDeviceIds().forEach(gnodeId -> {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setIpSrc(floating.getIp4Address()).setEthSrc(Constants.DEFAULT_GATEWAY_MAC).setEthDst(Constants.DEFAULT_EXTERNAL_ROUTER_MAC);
        if (osNet.getNetworkType().equals(NetworkType.VLAN)) {
            tBuilder.popVlan();
        }
        osFlowRuleService.setRule(appId, gnodeId, sBuilder.build(), tBuilder.setOutput(osNodeService.externalPort(gnodeId).get()).build(), PRIORITY_FLOATING_EXTERNAL, GW_COMMON_TABLE, install);
    });
}
#end_block

#method_before
private void setDownstreamRules(InstancePort srcInstPort, String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(networkType) {
        case VXLAN:
            tBuilder.setTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            tBuilder.pushVlan().setVlanId(VlanId.vlanId(segmentId)).setEthSrc(DEFAULT_GATEWAY_MAC);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        DeviceId srcDeviceId = srcInstPort.deviceId();
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        switch(networkType) {
            case VXLAN:
                tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, deviceId, osNodeService.dataIp(srcDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get());
                break;
            case VLAN:
                tmpBuilder.setOutput(osNodeService.vlanPort(deviceId).get());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
                throw new IllegalStateException(error);
        }
        RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#method_after
private void setDownstreamRules(InstancePort srcInstPort, String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    IpAddress internalIp = IpAddress.valueOf(iPacket.getSourceAddress());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder().setEthDst(packetIn.parsed().getSourceMAC()).setIpDst(internalIp);
    switch(networkType) {
        case VXLAN:
            tBuilder.setTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            tBuilder.pushVlan().setVlanId(VlanId.vlanId(segmentId)).setEthSrc(DEFAULT_GATEWAY_MAC);
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(patPort);
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(patPort);
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        DeviceId srcDeviceId = srcInstPort.deviceId();
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        switch(networkType) {
            case VXLAN:
                tmpBuilder.extension(RulePopulatorUtil.buildExtension(deviceService, deviceId, osNodeService.dataIp(srcDeviceId).get().getIp4Address()), deviceId).setOutput(osNodeService.tunnelPort(deviceId).get());
                break;
            case VLAN:
                tmpBuilder.setOutput(osNodeService.vlanPort(deviceId).get());
                break;
            default:
                final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
                throw new IllegalStateException(error);
        }
        osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#end_block

#method_before
private void setUpstreamRules(String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(osNodeService.externalPort(deviceId).get());
        RulePopulatorUtil.setRule(osFlowRuleService, appId, deviceId, sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#method_after
private void setUpstreamRules(String segmentId, NetworkType networkType, IpAddress externalIp, TpPort patPort, InboundPacket packetIn) {
    IPv4 iPacket = (IPv4) packetIn.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(networkType) {
        case VXLAN:
            sBuilder.matchTunnelId(Long.parseLong(segmentId));
            break;
        case VLAN:
            sBuilder.matchVlanId(VlanId.vlanId(segmentId));
            tBuilder.popVlan();
            break;
        default:
            final String error = String.format(ERR_UNSUPPORTED_NET_TYPE + "%s", networkType.toString());
            throw new IllegalStateException(error);
    }
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(patPort).setEthDst(DEFAULT_EXTERNAL_ROUTER_MAC);
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    osNodeService.gatewayDeviceIds().forEach(deviceId -> {
        TrafficTreatment.Builder tmpBuilder = DefaultTrafficTreatment.builder(tBuilder.build());
        tmpBuilder.setOutput(osNodeService.externalPort(deviceId).get());
        osFlowRuleService.setRule(appId, deviceId, sBuilder.build(), tmpBuilder.build(), PRIORITY_SNAT_RULE, GW_COMMON_TABLE, true);
    });
}
#end_block

#method_before
private void populateSecurityGroupRule(SecurityGroupRule sgRule, InstancePort instPort, IpPrefix remoteIp, boolean install) {
    ForwardingObjective.Builder foBuilder = buildFlowObjective(sgRule, Ip4Address.valueOf(instPort.ipAddress().toInetAddress()), remoteIp);
    if (foBuilder == null) {
        return;
    }
    if (install) {
        osFlowRuleService.forward(instPort.deviceId(), foBuilder.add(), ACL_TABLE);
    } else {
        osFlowRuleService.forward(instPort.deviceId(), foBuilder.remove(), ACL_TABLE);
    }
}
#method_after
private void populateSecurityGroupRule(SecurityGroupRule sgRule, InstancePort instPort, IpPrefix remoteIp, boolean install) {
    Ip4Address vmIp = Ip4Address.valueOf(instPort.ipAddress().toInetAddress());
    if (remoteIp != null && remoteIp.equals(IpPrefix.valueOf(vmIp, 32))) {
        // do nothing if the remote IP is my IP
        return;
    }
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    buildMatchs(sBuilder, sgRule, vmIp, remoteIp);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().transition(JUMP_TABLE).build();
    osFlowRuleService.setRule(appId, instPort.deviceId(), sBuilder.build(), treatment, PRIORITY_ACL_RULE, ACL_TABLE, install);
}
#end_block

#method_before
private void addOFSwitch(NetworkId networkId, DeviceId deviceId) {
    OFSwitch ofSwitch = DefaultOFSwitch.of(dpidWithDeviceId(deviceId), DEFAULT_CAPABILITIES);
    ofSwitchMap.put(deviceId, ofSwitch);
    log.info("Added virtual OF switch for {}", deviceId);
    OFAgent ofAgent = ofAgentService.agent(networkId);
    if (ofAgent == null) {
        log.error("OFAgent for network %s does not exist", networkId);
        return;
    }
    if (ofAgent.state() == STARTED) {
        connectController(ofSwitch, ofAgent.controllers());
    }
}
#method_after
private void addOFSwitch(NetworkId networkId, DeviceId deviceId) {
    OFSwitch ofSwitch = DefaultOFSwitch.of(dpidWithDeviceId(deviceId), DEFAULT_CAPABILITIES);
    ofSwitchMap.put(deviceId, ofSwitch);
    log.info("Added virtual OF switch for {}", deviceId);
    OFAgent ofAgent = ofAgentService.agent(networkId);
    if (ofAgent == null) {
        log.error("OFAgent for network {} does not exist", networkId);
        return;
    }
    if (ofAgent.state() == STARTED) {
        connectController(ofSwitch, ofAgent.controllers());
    }
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        preSelector = DefaultTrafficSelector.builder();
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
            selector.extension(ofdpaMatchVlanVid, deviceId);
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
            OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(VlanId.NONE);
            treatment.setVlanId(assignedVlan);
            preSelector.matchVlanId(assignedVlan);
        }
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (requireVlanExtensions()) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (PortNumber.ALL.equals(portCriterion.port())) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilter(PortCriterion portCriterion, VlanIdCriterion vidCriterion, VlanId assignedVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    TrafficSelector.Builder preSelector = null;
    TrafficTreatment.Builder preTreatment = null;
    treatment.transition(TMAC_TABLE);
    if (vidCriterion.vlanId() == VlanId.NONE) {
        // untagged packets are assigned vlans
        preSelector = DefaultTrafficSelector.builder();
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(VlanId.NONE);
            selector.extension(ofdpaMatchVlanVid, deviceId);
            OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
            treatment.extension(ofdpaSetVlanVid, deviceId);
            OfdpaMatchVlanVid preOfdpaMatchVlanVid = new OfdpaMatchVlanVid(assignedVlan);
            preSelector.extension(preOfdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(VlanId.NONE);
            treatment.setVlanId(assignedVlan);
            preSelector.matchVlanId(assignedVlan);
        }
        preTreatment = DefaultTrafficTreatment.builder().transition(TMAC_TABLE);
    } else {
        if (requireVlanExtensions()) {
            OfdpaMatchVlanVid ofdpaMatchVlanVid = new OfdpaMatchVlanVid(vidCriterion.vlanId());
            selector.extension(ofdpaMatchVlanVid, deviceId);
        } else {
            selector.matchVlanId(vidCriterion.vlanId());
        }
        if (!assignedVlan.equals(vidCriterion.vlanId())) {
            if (requireVlanExtensions()) {
                OfdpaSetVlanVid ofdpaSetVlanVid = new OfdpaSetVlanVid(assignedVlan);
                treatment.extension(ofdpaSetVlanVid, deviceId);
            } else {
                treatment.setVlanId(assignedVlan);
            }
        }
    }
    // ofdpa cannot match on ALL portnumber, so we need to use separate
    // rules for each port.
    List<PortNumber> portnums = new ArrayList<>();
    if (portCriterion != null && PortNumber.ALL.equals(portCriterion.port())) {
        for (Port port : deviceService.getPorts(deviceId)) {
            if (port.number().toLong() > 0 && port.number().toLong() < OFPP_MAX) {
                portnums.add(port.number());
            }
        }
    } else {
        portnums.add(portCriterion.port());
    }
    for (PortNumber pnum : portnums) {
        // create rest of flowrule
        selector.matchInPort(pnum);
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
        if (preSelector != null) {
            preSelector.matchInPort(pnum);
            FlowRule preRule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(preSelector.build()).withTreatment(preTreatment.build()).withPriority(DEFAULT_PRIORITY).fromApp(applicationId).makePermanent().forTable(VLAN_TABLE).build();
            rules.add(preRule);
        }
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
public static PortDescription translate(PortDescriptionProto.PortDescription portDescription) {
    PortNumber number = PortNumber.fromString(portDescription.getPortNumber());
    boolean isEnabled = portDescription.getIsEnabled();
    Port.Type type = translate(portDescription.getType());
    long portSpeed = portDescription.getPortSpeed();
    SparseAnnotations annotations = asAnnotations(portDescription.getAnnotationsMap());
    // TODO How to deal with more specific Port...
    return new DefaultPortDescription(number, isEnabled, type, portSpeed, annotations);
}
#method_after
public static PortDescription translate(PortDescriptionProto.PortDescription portDescription) {
    PortNumber number = PortNumber.fromString(portDescription.getPortNumber());
    boolean isEnabled = portDescription.getIsEnabled();
    Port.Type type = translate(portDescription.getType());
    long portSpeed = portDescription.getPortSpeed();
    SparseAnnotations annotations = asAnnotations(portDescription.getAnnotationsMap());
    return new DefaultPortDescription(number, isEnabled, type, portSpeed, annotations);
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    OpenFlowSwitch sw = this.getSwitch(dpid);
    // Check if someone is waiting for this message
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.get(dpid);
    if (xids != null) {
        CompletableFuture<OFMessage> future = xids.remove(msg.getXid());
        if (future != null) {
            future.complete(msg);
        }
    }
    checkMessageType(dpid, msg, sw);
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFTableStatsEntry> tableStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    Collection<OFQueueStatsEntry> queueStatsEntries;
    OpenFlowSwitch sw = this.getSwitch(dpid);
    // Check if someone is waiting for this message
    ConcurrentMap<Long, CompletableFuture<OFMessage>> xids = responses.get(dpid);
    if (xids != null) {
        CompletableFuture<OFMessage> future = xids.remove(msg.getXid());
        if (future != null) {
            future.complete(msg);
        }
    }
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            if (sw == null) {
                log.error("Ignoring PACKET_IN, switch {} is not found", dpid);
                break;
            }
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(sw, (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
            executorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case ERROR:
            log.debug("Received error message from {}: {}", dpid, msg);
            errorMsgs.putIfAbsent(msg.getXid(), true);
            executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case QUEUE:
                    queueStatsEntries = publishQueueStats(dpid, (OFQueueStatsReply) reply);
                    if (queueStatsEntries != null) {
                        OFQueueStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildQueueStatsReply();
                        rep.setEntries(Lists.newLinkedList(queueStatsEntries));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case TABLE:
                    tableStats = publishTableStats(dpid, (OFTableStatsReply) reply);
                    if (tableStats != null) {
                        OFTableStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildTableStatsReply();
                        rep.setEntries(Lists.newLinkedList(tableStats));
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case PORT:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case METER:
                    executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    break;
                case EXPERIMENTER:
                    if (reply instanceof OFCalientFlowStatsReply) {
                        // TODO: parse remaining fields such as power levels etc. when we have proper monitoring API
                        if (sw == null) {
                            log.error("Switch {} is not found", dpid);
                            break;
                        }
                        OFFlowStatsReply.Builder fsr = sw.factory().buildFlowStatsReply();
                        List<OFFlowStatsEntry> entries = new LinkedList<>();
                        for (OFCalientFlowStatsEntry entry : ((OFCalientFlowStatsReply) msg).getEntries()) {
                            // Single instruction, i.e., output to port
                            OFActionOutput action = OFFactories.getFactory(msg.getVersion()).actions().buildOutput().setPort(entry.getOutPort()).build();
                            OFInstruction instruction = OFFactories.getFactory(msg.getVersion()).instructions().applyActions(Collections.singletonList(action));
                            OFFlowStatsEntry fs = sw.factory().buildFlowStatsEntry().setMatch(entry.getMatch()).setTableId(entry.getTableId()).setDurationSec(entry.getDurationSec()).setDurationNsec(entry.getDurationNsec()).setPriority(entry.getPriority()).setIdleTimeout(entry.getIdleTimeout()).setHardTimeout(entry.getHardTimeout()).setFlags(entry.getFlags()).setCookie(entry.getCookie()).setInstructions(Collections.singletonList(instruction)).build();
                            entries.add(fs);
                        }
                        fsr.setEntries(entries);
                        flowStats = publishFlowStats(dpid, fsr.build());
                        if (flowStats != null) {
                            OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                            rep.setEntries(Lists.newLinkedList(flowStats));
                            executorMsgs.execute(new OFMessageHandler(dpid, rep.build()));
                        }
                    } else {
                        executorMsgs.execute(new OFMessageHandler(dpid, reply));
                    }
                    break;
                default:
                    log.warn("Discarding unknown stats reply type {}", reply.getStatsType());
                    break;
            }
            break;
        case BARRIER_REPLY:
            if (errorMsgs.containsKey(msg.getXid())) {
                // To make oferror msg handling and corresponding barrier reply serialized,
                // executorErrorMsgs is used for both transaction
                errorMsgs.remove(msg.getXid());
                executorErrorMsgs.execute(new OFMessageHandler(dpid, msg));
            } else {
                executorBarrier.execute(new OFMessageHandler(dpid, msg));
            }
            break;
        case EXPERIMENTER:
            if (sw == null) {
                log.error("Switch {} is not found", dpid);
                break;
            }
            long experimenter = ((OFExperimenter) msg).getExperimenter();
            if (experimenter == 0x748771) {
                // LINC-OE port stats
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = sw.factory().buildPortStatus();
                OFPortDesc.Builder portDesc = sw.factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
@Override
public void forward(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    if (fwd.treatment() != null) {
        // Deal with SPECIFIC and VERSATILE in the same manner.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(fwd.treatment());
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    } else {
        NextObjective nextObjective;
        NextGroup next;
        TrafficTreatment treatment;
        if (fwd.op() == ADD) {
            // Give a try to the cache. Doing an operation
            // on the store seems to be very expensive.
            nextObjective = pendingAddNext.getIfPresent(fwd.nextId());
            // We will try with the store
            if (nextObjective == null) {
                next = flowObjectiveStore.getNextGroup(fwd.nextId());
                // the treatment in order to re-build the flow rule.
                if (next == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                    return;
                }
                treatment = appKryo.deserialize(next.data());
            } else {
                pendingAddNext.invalidate(fwd.nextId());
                treatment = getTreatment(nextObjective);
                if (treatment == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.UNSUPPORTED));
                    return;
                }
            }
        } else {
            // We get the NextGroup from the remove operation.
            // Doing an operation on the store seems to be very expensive.
            next = flowObjectiveStore.getNextGroup(fwd.nextId());
            if (next == null) {
                treatment = null;
            } else {
                treatment = appKryo.deserialize(next.data());
            }
        }
        // If the treatment is null we cannot re-build the original flow
        if (treatment == null) {
            fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
            return;
        }
        // Finally we build the flow rule and push to the flow rule subsystem.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(treatment);
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    }
}
#method_after
@Override
public void forward(ForwardingObjective fwd) {
    TrafficSelector selector = fwd.selector();
    if (fwd.treatment() != null) {
        // Deal with SPECIFIC and VERSATILE in the same manner.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(fwd.treatment());
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    } else {
        NextObjective nextObjective;
        NextGroup next;
        TrafficTreatment treatment;
        if (fwd.op() == ADD) {
            // Give a try to the cache. Doing an operation
            // on the store seems to be very expensive.
            nextObjective = pendingAddNext.getIfPresent(fwd.nextId());
            // We will try with the store
            if (nextObjective == null) {
                next = flowObjectiveStore.getNextGroup(fwd.nextId());
                // the treatment in order to re-build the flow rule.
                if (next == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
                    return;
                }
                treatment = appKryo.deserialize(next.data());
            } else {
                pendingAddNext.invalidate(fwd.nextId());
                treatment = getTreatment(nextObjective);
                if (treatment == null) {
                    fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.UNSUPPORTED));
                    return;
                }
            }
        } else {
            // We get the NextGroup from the remove operation.
            // Doing an operation on the store seems to be very expensive.
            next = flowObjectiveStore.getNextGroup(fwd.nextId());
            treatment = (next != null) ? appKryo.deserialize(next.data()) : null;
        }
        // If the treatment is null we cannot re-build the original flow
        if (treatment == null) {
            fwd.context().ifPresent(c -> c.onError(fwd, ObjectiveError.GROUPMISSING));
            return;
        }
        // Finally we build the flow rule and push to the flow rule subsystem.
        FlowRule.Builder ruleBuilder = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).fromApp(fwd.appId()).withPriority(fwd.priority()).withTreatment(treatment);
        if (fwd.permanent()) {
            ruleBuilder.makePermanent();
        } else {
            ruleBuilder.makeTemporary(fwd.timeout());
        }
        installObjective(ruleBuilder, fwd);
    }
}
#end_block

#method_before
private TrafficTreatment getTreatment(NextObjective nextObjective) {
    Collection<TrafficTreatment> treatments = nextObjective.next();
    switch(nextObjective.type()) {
        case SIMPLE:
            return treatments.iterator().next();
        case BROADCAST:
            TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
            treatments.forEach(builder::addTreatment);
            return builder.build();
        default:
            // Unsupported next type
            return null;
    }
}
#method_after
private TrafficTreatment getTreatment(NextObjective nextObjective) {
    Collection<TrafficTreatment> treatments = nextObjective.next();
    switch(nextObjective.type()) {
        case SIMPLE:
            if (treatments.size() != 1) {
                log.error("Next Objectives of type SIMPLE should have only " + "one traffic treatment. NexObjective: {}", nextObjective.toString());
                return null;
            }
            return treatments.iterator().next();
        case BROADCAST:
            TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
            treatments.forEach(builder::addTreatment);
            return builder.build();
        default:
            log.error("Unsupported next objective type {}.", nextObjective.type());
            return null;
    }
}
#end_block

#method_before
private static String uriDecodedString(String keyStr) {
    if (keyStr.contains(URI_ENCODED_SLASH)) {
        keyStr = keyStr.replaceAll(URI_ENCODED_SLASH, SLASH);
    }
    if (keyStr.contains(URI_ENCODED_COLCON)) {
        keyStr = keyStr.replaceAll(URI_ENCODED_COLCON, COLON);
    }
    return keyStr;
}
#method_after
private static String uriDecodedString(String keyStr) {
    /*
         * replaceAll() may be an expensive operation. So, call
         * contains() to determine if replaceAll() is really need
         * to be invoked.
         */
    if (keyStr.contains(URI_ENCODED_SLASH)) {
        keyStr = keyStr.replaceAll(URI_ENCODED_SLASH, SLASH);
    }
    if (keyStr.contains(URI_ENCODED_COLON)) {
        keyStr = keyStr.replaceAll(URI_ENCODED_COLON, COLON);
    }
    return keyStr;
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    providerService = providerRegistry.register(this);
    factories.forEach(cfgService::registerConfigFactory);
    cfgService.addListener(cfgLister);
    executor = Executors.newFixedThreadPool(5, groupedThreads("onos/restsbprovider", "device-installer-%d", log));
    executor.execute(RestDeviceProvider.this::createAndConnectDevices);
    executor.execute(RestDeviceProvider.this::createDevices);
    scheduledTask = schedulePolling();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_NAME);
    providerService = providerRegistry.register(this);
    factories.forEach(cfgService::registerConfigFactory);
    executor = Executors.newFixedThreadPool(5, groupedThreads("onos/restsbprovider", "device-installer-%d", log));
    cfgService.addListener(cfgLister);
    executor.execute(RestDeviceProvider.this::createAndConnectDevices);
    executor.execute(RestDeviceProvider.this::createDevices);
    scheduledTask = schedulePolling();
    log.info("Started");
}
#end_block

#method_before
public Builder withParameter(PiActionParamId paramId, ImmutableByteSequence value) {
    PiActionParam param = new PiActionParam(paramId, value);
    runtimeParams.put(paramId, param);
    return this;
}
#method_after
public Builder withParameter(PiActionParam param) {
    checkNotNull(param);
    runtimeParams.put(param.id(), param);
    return this;
}
#end_block

#method_before
protected String getUrlString(DeviceId device, String request) {
    if (deviceMap.get(device).url() != null) {
        return deviceMap.get(device).protocol() + COLON + DOUBLESLASH + deviceMap.get(device).url() + request;
    } else {
        return deviceMap.get(device).protocol() + COLON + DOUBLESLASH + deviceMap.get(device).ip().toString() + COLON + deviceMap.get(device).port() + request;
    }
}
#method_after
protected String getUrlString(DeviceId deviceId, String request) {
    RestSBDevice restSBDevice = deviceMap.get(deviceId);
    if (restSBDevice == null) {
        log.warn("restSbDevice cannot be NULL!");
        return "";
    }
    if (restSBDevice.url() != null) {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.url() + request;
    } else {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.ip().toString() + COLON + restSBDevice.port() + request;
    }
}
#end_block

#method_before
@Test
public void dualEdgeMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, W1), new TestEdge(A, C, W3), new TestEdge(B, D, W2), new TestEdge(B, C, W1), new TestEdge(B, E, W4), new TestEdge(C, E, W1), new TestEdge(D, H, W5), new TestEdge(D, E, W1), new TestEdge(E, F, W1), new TestEdge(F, D, W1), new TestEdge(F, G, W1), new TestEdge(F, H, W1), new TestEdge(A, E, W3), new TestEdge(B, D, W1)));
    executeSearch(graphSearch(), graph, A, E, weigher, 3, W3);
    executeSinglePathSearch(graphSearch(), graph, A, E, weigher, 1, W3);
    GraphPathSearch<TestVertex, TestEdge> gs = graphSearch();
    Set<Path<TestVertex, TestEdge>> pathF = gs.search(graph, A, F, weigher, GraphPathSearch.ALL_PATHS).paths();
    Set<Path<TestVertex, TestEdge>> pathE = gs.search(graph, A, E, weigher, GraphPathSearch.ALL_PATHS).paths();
    assertEquals(0, pathF.size() - pathE.size());
    assertEquals(new TestDoubleWeight(1.0), (pathF.iterator().next().cost().subtract(pathE.iterator().next().cost())));
}
#method_after
@Test
public void dualEdgeMultiplePath() {
    graph = new AdjacencyListsGraph<>(of(A, B, C, D, E, F, G, H), of(new TestEdge(A, B, W1), new TestEdge(A, C, W3), new TestEdge(B, D, W2), new TestEdge(B, C, W1), new TestEdge(B, E, W4), new TestEdge(C, E, W1), new TestEdge(D, H, W5), new TestEdge(D, E, W1), new TestEdge(E, F, W1), new TestEdge(F, D, W1), new TestEdge(F, G, W1), new TestEdge(F, H, W1), new TestEdge(A, E, W3), new TestEdge(B, D, W1)));
    executeSearch(graphSearch(), graph, A, E, weigher, 3, W3);
    executeSinglePathSearch(graphSearch(), graph, A, E, weigher, 1, W3);
    GraphPathSearch<TestVertex, TestEdge> gs = graphSearch();
    Set<Path<TestVertex, TestEdge>> pathF = gs.search(graph, A, F, weigher, GraphPathSearch.ALL_PATHS).paths();
    Set<Path<TestVertex, TestEdge>> pathE = gs.search(graph, A, E, weigher, GraphPathSearch.ALL_PATHS).paths();
    assertEquals(0, pathF.size() - pathE.size());
    assertEquals(new TestDoubleWeight(1.0), pathF.iterator().next().cost().subtract(pathE.iterator().next().cost()));
}
#end_block

#method_before
protected String getUrlString(DeviceId deviceId, String request) {
    RestSBDevice restSBDevice = deviceMap.get(deviceId);
    checkNotNull(restSBDevice, "restSbDevice cannot be NULL!");
    if (restSBDevice.url() != null) {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.url() + request;
    } else {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.ip().toString() + COLON + restSBDevice.port() + request;
    }
}
#method_after
protected String getUrlString(DeviceId deviceId, String request) {
    RestSBDevice restSBDevice = deviceMap.get(deviceId);
    if (restSBDevice == null) {
        log.warn("restSbDevice cannot be NULL!");
        return "";
    }
    if (restSBDevice.url() != null) {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.url() + request;
    } else {
        return restSBDevice.protocol() + COLON + DOUBLESLASH + restSBDevice.ip().toString() + COLON + restSBDevice.port() + request;
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    cfgService.removeListener(cfgLister);
    controller.getDevices().keySet().forEach(this::deviceRemoved);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    deviceUpdateExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    cfgService.removeListener(cfgLister);
    controller.getDevices().keySet().forEach(this::deviceRemoved);
    providerRegistry.unregister(this);
    providerService = null;
    factories.forEach(cfgService::unregisterConfigFactory);
    scheduledTask.cancel(true);
    log.info("Stopped");
}
#end_block

#method_before
private void checkAndUpdateDevice(DeviceId deviceId) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                    providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
            updatePortStatistics(device);
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#method_after
private void checkAndUpdateDevice(DeviceId deviceId) {
    if (deviceService.getDevice(deviceId) == null) {
        log.warn("Device {} has not been added to store, " + "maybe due to a problem in connectivity", deviceId);
    } else {
        boolean isReachable = isReachable(deviceId);
        if (isReachable && deviceService.isAvailable(deviceId)) {
            Device device = deviceService.getDevice(deviceId);
            if (device.is(DeviceDescriptionDiscovery.class)) {
                DeviceDescriptionDiscovery deviceDescriptionDiscovery = device.as(DeviceDescriptionDiscovery.class);
                DeviceDescription updatedDeviceDescription = deviceDescriptionDiscovery.discoverDeviceDetails();
                if (updatedDeviceDescription != null && !descriptionEquals(device, updatedDeviceDescription)) {
                    providerService.deviceConnected(deviceId, new DefaultDeviceDescription(updatedDeviceDescription, true, updatedDeviceDescription.annotations()));
                    // if ports are not discovered, retry the discovery
                    if (deviceService.getPorts(deviceId).isEmpty()) {
                        discoverPorts(deviceId);
                    }
                }
            } else {
                log.warn("No DeviceDescriptionDiscovery behaviour for device {}", deviceId);
            }
        } else if (!isReachable && deviceService.isAvailable(deviceId)) {
            providerService.deviceDisconnected(deviceId);
        }
    }
}
#end_block

#method_before
private ScheduledFuture schedulePolling() {
    return deviceUpdateExecutor.scheduleAtFixedRate(this::checkAndUpdateDevices, DEFAULT_POLL_FREQUENCY_SECONDS / 2, DEFAULT_POLL_FREQUENCY_SECONDS, TimeUnit.SECONDS);
}
#method_after
private ScheduledFuture schedulePolling() {
    return portStatisticsExecutor.scheduleAtFixedRate(this::executePortStatisticsUpdate, DEFAULT_POLL_FREQUENCY_SECONDS / 2, DEFAULT_POLL_FREQUENCY_SECONDS, TimeUnit.SECONDS);
}
#end_block

#method_before
private void updatePortStatistics(Device device) {
    DeviceId deviceId = device.id();
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery portStatisticsDiscovery = device.as(PortStatisticsDiscovery.class);
        Collection<PortStatistics> portStatistics = portStatisticsDiscovery.discoverPortStatistics();
        if (portStatistics != null) {
            providerService.updatePortStatistics(deviceId, portStatistics);
        }
    } else {
        log.debug("No port statistics getter behaviour for device {}", deviceId);
    }
}
#method_after
private void updatePortStatistics(DeviceId deviceId) {
    Device device = deviceService.getDevice(deviceId);
    checkNotNull(device, "device cannot be null");
    if (device.is(PortStatisticsDiscovery.class)) {
        PortStatisticsDiscovery portStatisticsDiscovery = device.as(PortStatisticsDiscovery.class);
        Collection<PortStatistics> portStatistics = portStatisticsDiscovery.discoverPortStatistics();
        if (portStatistics != null && !portStatistics.isEmpty()) {
            providerService.updatePortStatistics(deviceId, portStatistics);
        }
    } else {
        log.debug("No port statistics getter behaviour for device {}", deviceId);
    }
}
#end_block

#method_before
public static DeviceKeyId deviceKeyId(String id) {
    checkArgument(id.length() <= ID_MAX_LENGTH, "id exceeds maximum length " + ID_MAX_LENGTH);
    return new DeviceKeyId(id);
}
#method_after
public static DeviceKeyId deviceKeyId(String id) {
    if (id != null) {
        checkArgument(id.length() <= ID_MAX_LENGTH, "id exceeds maximum length " + ID_MAX_LENGTH);
    }
    return new DeviceKeyId(id);
}
#end_block

