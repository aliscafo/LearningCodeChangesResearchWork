369
#method_before
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            final int dexFlags = DEXOPT_DISABLE_HIDDEN_API_CHECKS;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion);
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
}
#method_after
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            // Dexopt with a flag which lifts restrictions on hidden API usage.
            // Offending methods would otherwise be re-verified at runtime and
            // we want to avoid the performance overhead of that.
            final int dexFlags = DEXOPT_DISABLE_HIDDEN_API_CHECKS;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion);
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
}
#end_block

#method_before
private int getDexFlags(ApplicationInfo info, String compilerFilter, DexoptOptions options) {
    int flags = info.flags;
    boolean debuggable = (flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // Profile guide compiled oat files should not be public.
    boolean isProfileGuidedFilter = isProfileGuidedCompilerFilter(compilerFilter);
    boolean isPublic = !info.isForwardLocked() && !isProfileGuidedFilter;
    int profileFlag = isProfileGuidedFilter ? DEXOPT_PROFILE_GUIDED : 0;
    int dexFlags = (isPublic ? DEXOPT_PUBLIC : 0) | (debuggable ? DEXOPT_DEBUGGABLE : 0) | profileFlag | (options.isBootComplete() ? DEXOPT_BOOTCOMPLETE : 0) | (options.isDexoptIdleBackgroundJob() ? DEXOPT_IDLE_BACKGROUND_JOB : 0) | (info.isSystemApp() ? DEXOPT_DISABLE_HIDDEN_API_CHECKS : 0);
    return adjustDexoptFlags(dexFlags);
}
#method_after
private int getDexFlags(ApplicationInfo info, String compilerFilter, DexoptOptions options) {
    int flags = info.flags;
    boolean debuggable = (flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    // Profile guide compiled oat files should not be public.
    boolean isProfileGuidedFilter = isProfileGuidedCompilerFilter(compilerFilter);
    boolean isPublic = !info.isForwardLocked() && !isProfileGuidedFilter;
    int profileFlag = isProfileGuidedFilter ? DEXOPT_PROFILE_GUIDED : 0;
    // System apps are invoked with a runtime flag which exempts them from
    // restrictions on hidden API usage. We dexopt with the same runtime flag
    // otherwise offending methods would have to be re-verified at runtime
    // and we want to avoid the performance overhead of that.
    int hiddenApiFlag = info.isAllowedToUseHiddenApi() ? DEXOPT_DISABLE_HIDDEN_API_CHECKS : 0;
    int dexFlags = (isPublic ? DEXOPT_PUBLIC : 0) | (debuggable ? DEXOPT_DEBUGGABLE : 0) | profileFlag | (options.isBootComplete() ? DEXOPT_BOOTCOMPLETE : 0) | (options.isDexoptIdleBackgroundJob() ? DEXOPT_IDLE_BACKGROUND_JOB : 0) | hiddenApiFlag;
    return adjustDexoptFlags(dexFlags);
}
#end_block

#method_before
public void currentLinkCapacityEstimate(int indicationType, android.hardware.radio.V1_2.LinkCapacityEstimate lce) {
// no-op
}
#method_after
public void currentLinkCapacityEstimate(int indicationType, android.hardware.radio.V1_2.LinkCapacityEstimate lce) {
// TODO(b/70638175) Implement method.
}
#end_block

#method_before
public void setBluetoothScoOnInt(boolean on, String eventSource) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "setBluetoothScoOnInt: " + on + " " + eventSource);
    }
    if (on) {
        // do not accept SCO ON if SCO audio is not connected
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null) {
                if (mBluetoothHeadsetDevice == null) {
                    setBtScoActiveDevice(mBluetoothHeadset.getActiveDevice());
                }
                if (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice) != BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                    mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                    Log.w(TAG, "setBluetoothScoOnInt(" + on + ") failed because " + mBluetoothHeadsetDevice + " is not in audio connected mode");
                    return;
                }
            }
        }
        mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
    } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
        mForcedUseForComm = AudioSystem.FORCE_NONE;
    }
    mForcedUseForCommExt = mForcedUseForComm;
    AudioSystem.setParameters("BT_SCO=" + (on ? "on" : "off"));
    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
}
#method_after
public void setBluetoothScoOnInt(boolean on, String eventSource) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "setBluetoothScoOnInt: " + on + " " + eventSource);
    }
    if (on) {
        // do not accept SCO ON if SCO audio is not connected
        synchronized (mScoClients) {
            if (mBluetoothHeadset != null) {
                if (mBluetoothHeadsetDevice == null) {
                    BluetoothDevice activeDevice = mBluetoothHeadset.getActiveDevice();
                    if (activeDevice != null) {
                        // setBtScoActiveDevice() might trigger resetBluetoothSco() which
                        // will call setBluetoothScoOnInt(false, "resetBluetoothSco")
                        setBtScoActiveDevice(activeDevice);
                    }
                }
                if (mBluetoothHeadset.getAudioState(mBluetoothHeadsetDevice) != BluetoothHeadset.STATE_AUDIO_CONNECTED) {
                    mForcedUseForCommExt = AudioSystem.FORCE_BT_SCO;
                    Log.w(TAG, "setBluetoothScoOnInt(true) failed because " + mBluetoothHeadsetDevice + " is not in audio connected mode");
                    return;
                }
            }
        }
        mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
    } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
        mForcedUseForComm = AudioSystem.FORCE_NONE;
    }
    mForcedUseForCommExt = mForcedUseForComm;
    AudioSystem.setParameters("BT_SCO=" + (on ? "on" : "off"));
    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, eventSource, 0);
    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_RECORD, mForcedUseForComm, eventSource, 0);
}
#end_block

#method_before
private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
    if (btDevice == null) {
        return true;
    }
    String address = btDevice.getAddress();
    BluetoothClass btClass = btDevice.getBluetoothClass();
    int outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
    int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
    if (btClass != null) {
        switch(btClass.getDeviceClass()) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                break;
            case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                break;
        }
    }
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    String btDeviceName = btDevice.getName();
    return handleDeviceConnection(isActive, outDevice, address, btDeviceName) && handleDeviceConnection(isActive, inDevice, address, btDeviceName);
}
#method_after
private boolean handleBtScoActiveDeviceChange(BluetoothDevice btDevice, boolean isActive) {
    if (btDevice == null) {
        return true;
    }
    String address = btDevice.getAddress();
    BluetoothClass btClass = btDevice.getBluetoothClass();
    int outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
    int inDevice = AudioSystem.DEVICE_IN_BLUETOOTH_SCO_HEADSET;
    if (btClass != null) {
        switch(btClass.getDeviceClass()) {
            case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                break;
            case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                break;
        }
    }
    if (!BluetoothAdapter.checkBluetoothAddress(address)) {
        address = "";
    }
    String btDeviceName = btDevice.getName();
    boolean result = handleDeviceConnection(isActive, outDevice, address, btDeviceName);
    // handleDeviceConnection() && result to make sure the method get executed
    result = handleDeviceConnection(isActive, inDevice, address, btDeviceName) && result;
    return result;
}
#end_block

#method_before
private void setBtScoActiveDevice(BluetoothDevice btDevice) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "setBtScoActiveDevice(" + btDevice + ")");
    }
    synchronized (mScoClients) {
        final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
        if (!Objects.equals(btDevice, previousActiveDevice)) {
            if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                Log.w(TAG, "setBtScoActiveDevice() failed to remove previous device " + previousActiveDevice);
                return;
            }
            if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                Log.w(TAG, "setBtScoActiveDevice() failed to add new device " + btDevice);
                return;
            }
            mBluetoothHeadsetDevice = btDevice;
            if (mBluetoothHeadsetDevice == null) {
                resetBluetoothSco();
            }
        }
    }
}
#method_after
void setBtScoActiveDevice(BluetoothDevice btDevice) {
    if (DEBUG_DEVICES) {
        Log.d(TAG, "setBtScoActiveDevice(" + btDevice + ")");
    }
    synchronized (mScoClients) {
        final BluetoothDevice previousActiveDevice = mBluetoothHeadsetDevice;
        if (!Objects.equals(btDevice, previousActiveDevice)) {
            if (!handleBtScoActiveDeviceChange(previousActiveDevice, false)) {
                Log.w(TAG, "setBtScoActiveDevice() failed to remove previous device " + previousActiveDevice);
            }
            if (!handleBtScoActiveDeviceChange(btDevice, true)) {
                Log.e(TAG, "setBtScoActiveDevice() failed to add new device " + btDevice);
                // set mBluetoothHeadsetDevice to null when failing to add new device
                btDevice = null;
            }
            mBluetoothHeadsetDevice = btDevice;
            if (mBluetoothHeadsetDevice == null) {
                resetBluetoothSco();
            }
        }
    }
}
#end_block

#method_before
void disconnectHeadset() {
    synchronized (mScoClients) {
        setBtScoActiveDevice(null);
    }
}
#method_after
void disconnectHeadset() {
    synchronized (mScoClients) {
        setBtScoActiveDevice(null);
        mBluetoothHeadset = null;
    }
}
#end_block

#method_before
public void cleanup() {
    listenForPhoneState(false);
    if (mOnSubscriptionsChangedListener != null) {
        mSubscriptionManager.removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
        mOnSubscriptionsChangedListener = null;
    }
}
#method_after
public void cleanup() {
    listenForPhoneState(false);
    mSubscriptionManager.removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
}
#end_block

#method_before
@Override
public String toString() {
    return "HeadsetPhoneState [mTelephonyServiceAvailability=" + mCindService + ", mNumActive=" + mNumActive + ", mCallState=" + mCallState + ", mNumHeld=" + mNumHeld + ", mSignal=" + mCindSignal + ", mRoam=" + mCindRoam + ", mBatteryCharge=" + mCindBatteryCharge + ", mListening=" + mListening + ", mSlcReady=" + mSlcReady + "]";
}
#method_after
@Override
public String toString() {
    return "HeadsetPhoneState [mTelephonyServiceAvailability=" + mCindService + ", mNumActive=" + mNumActive + ", mCallState=" + mCallState + ", mNumHeld=" + mNumHeld + ", mSignal=" + mCindSignal + ", mRoam=" + mCindRoam + ", mBatteryCharge=" + mCindBatteryCharge + ", mListening=" + mListening + "]";
}
#end_block

#method_before
@VisibleForTesting
public void listenForPhoneState(boolean start) {
    mSlcReady = start;
    if (start) {
        startListenForPhoneState();
    } else {
        stopListenForPhoneState();
    }
}
#method_after
@VisibleForTesting
public void listenForPhoneState(boolean start) {
    synchronized (mTelephonyManager) {
        if (start) {
            startListenForPhoneState();
        } else {
            stopListenForPhoneState();
        }
    }
}
#end_block

#method_before
private void startListenForPhoneState() {
    if (!mListening && mSlcReady) {
        int subId = SubscriptionManager.getDefaultSubscriptionId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            mPhoneStateListener = getPhoneStateListener(subId);
            mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
            mListening = true;
        }
    }
}
#method_after
private void startListenForPhoneState() {
    if (!mListening) {
        int subId = SubscriptionManager.getDefaultSubscriptionId();
        if (SubscriptionManager.isValidSubscriptionId(subId)) {
            mPhoneStateListener = new HeadsetPhoneStateListener(subId, mHeadsetService.getStateMachinesThreadLooper());
            mTelephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE | PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
            mListening = true;
        } else {
            Log.w(TAG, "startListenForPhoneState, invalid subscription ID " + subId);
        }
    }
}
#end_block

#method_before
@Override
public synchronized IProfileServiceBinder initBinder() {
    return new BluetoothHeadsetBinder(this);
}
#method_after
@Override
public IProfileServiceBinder initBinder() {
    return new BluetoothHeadsetBinder(this);
}
#end_block

#method_before
@Override
protected synchronized void create() {
    Log.i(TAG, "create()");
    if (mCreated) {
        Log.wtfStack(TAG, "create() called twice");
        return;
    }
    mCreated = true;
}
#method_after
@Override
protected void create() {
    Log.i(TAG, "create()");
    if (mCreated) {
        throw new IllegalStateException("create() called twice");
    }
    mCreated = true;
}
#end_block

#method_before
@Override
protected synchronized boolean start() {
    Log.i(TAG, "start()");
    if (mStarted) {
        Log.wtfStack(TAG, "start() called twice");
        return false;
    }
    // Step 1: Start handler thread for state machines
    mStateMachinesThread = new HandlerThread("HeadsetService.StateMachines");
    mStateMachinesThread.start();
    // Step 2: Initialize system interface
    mSystemInterface = HeadsetObjectsFactory.getInstance().makeSystemInterface(this);
    mSystemInterface.init();
    // Step 3: Initialize native interface
    mNativeInterface = HeadsetObjectsFactory.getInstance().getNativeInterface();
    mNativeInterface.init(MAX_HEADSET_CONNECTIONS, BluetoothHeadset.isInbandRingingSupported(this));
    // Step 4: Initialize state machine
    // Nothing
    // Step 5: Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    registerReceiver(mHeadsetReceiver, filter);
    // Step 6: Mark service as started
    setHeadsetService(this);
    mStarted = true;
    return true;
}
#method_after
@Override
protected boolean start() {
    Log.i(TAG, "start()");
    if (mStarted) {
        throw new IllegalStateException("start() called twice");
    }
    // Step 1: Get adapter service, should never be null
    mAdapterService = Objects.requireNonNull(AdapterService.getAdapterService(), "AdapterService cannot be null when HeadsetService starts");
    // Step 2: Start handler thread for state machines
    mStateMachinesThread = new HandlerThread("HeadsetService.StateMachines");
    mStateMachinesThread.start();
    // Step 3: Initialize system interface
    mSystemInterface = HeadsetObjectsFactory.getInstance().makeSystemInterface(this);
    mSystemInterface.init();
    // Step 4: Initialize native interface
    mMaxHeadsetConnections = mAdapterService.getMaxConnectedAudioDevices();
    mNativeInterface = HeadsetObjectsFactory.getInstance().getNativeInterface();
    // Add 1 to allow a pending device to be connecting or disconnecting
    mNativeInterface.init(mMaxHeadsetConnections + 1, isInbandRingingEnabled());
    // Step 5: Check if state machine table is empty, crash if not
    if (mStateMachines.size() > 0) {
        throw new IllegalStateException("start(): mStateMachines is not empty, " + mStateMachines.size() + " is already created. Was stop() called properly?");
    }
    // Step 6: Setup broadcast receivers
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
    filter.addAction(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY);
    filter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
    registerReceiver(mHeadsetReceiver, filter);
    // Step 7: Mark service as started
    setHeadsetService(this);
    mStarted = true;
    return true;
}
#end_block

#method_before
@Override
protected synchronized boolean stop() {
    Log.i(TAG, "stop()");
    if (!mStarted) {
        Log.w(TAG, "stop() called before start()");
        // Still return true because it is considered "stopped"
        return true;
    }
    // Step 6: Mark service as stopped
    mStarted = false;
    setHeadsetService(null);
    // Step 5: Tear down broadcast receivers
    unregisterReceiver(mHeadsetReceiver);
    // Step 4: Destroy state machines
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            HeadsetObjectsFactory.getInstance().destroyStateMachine(stateMachine);
        }
        mStateMachines.clear();
    }
    // Step 3: Destroy native interface
    mNativeInterface.cleanup();
    // Step 2: Destroy system interface
    mSystemInterface.stop();
    // Step 1: Stop handler thread
    mStateMachinesThread.quitSafely();
    mStateMachinesThread = null;
    return true;
}
#method_after
@Override
protected boolean stop() {
    Log.i(TAG, "stop()");
    if (!mStarted) {
        Log.w(TAG, "stop() called before start()");
        // impact on the user
        return true;
    }
    // Step 7: Mark service as stopped
    mStarted = false;
    setHeadsetService(null);
    // Reset active device to null
    mActiveDevice = null;
    mInbandRingingRuntimeDisable = false;
    mForceScoAudio = false;
    mAudioRouteAllowed = true;
    mMaxHeadsetConnections = 1;
    mVoiceRecognitionStarted = false;
    // Step 6: Tear down broadcast receivers
    unregisterReceiver(mHeadsetReceiver);
    // Step 5: Destroy state machines
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            HeadsetObjectsFactory.getInstance().destroyStateMachine(stateMachine);
        }
        mStateMachines.clear();
    }
    // Step 4: Destroy native interface
    mNativeInterface.cleanup();
    // Step 3: Destroy system interface
    mSystemInterface.stop();
    // Step 2: Stop handler thread
    mStateMachinesThread.quitSafely();
    mStateMachinesThread = null;
    // Step 1: Clear
    mAdapterService = null;
    return true;
}
#end_block

#method_before
@Override
protected synchronized boolean cleanup() {
    Log.i(TAG, "cleanup()");
    if (!mCreated) {
        Log.w(TAG, "cleanup() called before create()");
        // Still return true as it is considered "not created"
        return true;
    }
    mCreated = false;
    return true;
}
#method_after
@Override
protected void cleanup() {
    Log.i(TAG, "cleanup");
    if (!mCreated) {
        Log.w(TAG, "cleanup() called before create()");
    }
    mCreated = false;
}
#end_block

#method_before
public synchronized boolean isAlive() {
    return isAvailable() && mCreated && mStarted;
}
#method_after
public boolean isAlive() {
    return isAvailable() && mCreated && mStarted;
}
#end_block

#method_before
synchronized Looper getStateMachinesThreadLooper() {
    return mStateMachinesThread.getLooper();
}
#method_after
Looper getStateMachinesThreadLooper() {
    return mStateMachinesThread.getLooper();
}
#end_block

#method_before
synchronized void onDeviceStateChanged(HeadsetDeviceState deviceState) {
    broadCastMessageToStateMachines(HeadsetStateMachine.DEVICE_STATE_CHANGED, deviceState);
}
#method_after
void onDeviceStateChanged(HeadsetDeviceState deviceState) {
    doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.DEVICE_STATE_CHANGED, deviceState));
}
#end_block

#method_before
synchronized void messageFromNative(HeadsetStackEvent stackEvent) {
    if (stackEvent.device == null) {
        Log.wtfStack(TAG, "messageFromNative, device is null, event: " + stackEvent);
        return;
    }
    synchronized (mStateMachines) {
        HeadsetStateMachine stateMachine = mStateMachines.get(stackEvent.device);
        if (stackEvent.type == HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED) {
            List<BluetoothDevice> connectedDevices = getConnectedDevices();
            switch(stackEvent.valueInt) {
                case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
                case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
                    if (connectedDevices.size() >= MAX_HEADSET_CONNECTIONS) {
                        Log.i(TAG, "Max connection has reached, rejecting connection from " + stackEvent.device);
                        if (!mNativeInterface.disconnectHfp(stackEvent.device)) {
                            Log.e(TAG, "Failed to disconnect from " + stackEvent.device);
                        }
                        return;
                    }
                    // Create new state machine if none is found
                    if (stateMachine == null) {
                        stateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mStateMachinesThread.getLooper(), this, mNativeInterface, mSystemInterface);
                        mStateMachines.put(stackEvent.device, stateMachine);
                    }
                    break;
            }
        } else if (stateMachine == null) {
            Log.wtfStack(TAG, "State machine not found for stack event: " + stackEvent);
            return;
        }
        stateMachine.sendMessage(HeadsetStateMachine.STACK_EVENT, stackEvent);
    }
}
#method_after
void messageFromNative(HeadsetStackEvent stackEvent) {
    if (stackEvent.device == null) {
        Log.wtfStack(TAG, "messageFromNative, device is null, event: " + stackEvent);
        return;
    }
    synchronized (mStateMachines) {
        HeadsetStateMachine stateMachine = mStateMachines.get(stackEvent.device);
        if (stackEvent.type == HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED) {
            switch(stackEvent.valueInt) {
                case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
                case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
                    {
                        // Create new state machine if none is found
                        if (stateMachine == null) {
                            stateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(stackEvent.device, mStateMachinesThread.getLooper(), this, mNativeInterface, mSystemInterface);
                            mStateMachines.put(stackEvent.device, stateMachine);
                        }
                        break;
                    }
            }
        } else if (stateMachine == null) {
            Log.wtfStack(TAG, "State machine not found for stack event: " + stackEvent);
            return;
        }
        stateMachine.sendMessage(HeadsetStateMachine.STACK_EVENT, stackEvent);
    }
}
#end_block

#method_before
@Override
public boolean cleanup() {
    mService = null;
    return true;
}
#method_after
@Override
public void cleanup() {
    mService = null;
}
#end_block

#method_before
@Override
public boolean disconnect(BluetoothDevice device) {
    HeadsetService service = getService();
    if (service == null) {
        return false;
    }
    if (DBG) {
        Log.d(TAG, "disconnect in HeadsetService");
    }
    return service.disconnect(device);
}
#method_after
@Override
public boolean disconnect(BluetoothDevice device) {
    HeadsetService service = getService();
    if (service == null) {
        return false;
    }
    logD("disconnect in HeadsetService");
    return service.disconnect(device);
}
#end_block

#method_before
public boolean connect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    Log.i(TAG, "connect: device=" + device);
    if (getPriority(device) == BluetoothProfile.PRIORITY_OFF) {
        Log.w(TAG, "connect: PRIORITY_OFF, device=" + device);
        return false;
    }
    synchronized (mStateMachines) {
        List<BluetoothDevice> connectedDevices = getConnectedDevices();
        if (connectedDevices.size() >= MAX_HEADSET_CONNECTIONS) {
            Log.i(TAG, "Max connection has reached, rejecting connection to " + device);
            return false;
        }
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            stateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mStateMachinesThread.getLooper(), this, mNativeInterface, mSystemInterface);
            mStateMachines.put(device, stateMachine);
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState == BluetoothProfile.STATE_CONNECTED || connectionState == BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "connect: device " + device + " is already connected/connecting, connectionState=" + connectionState);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.CONNECT, device);
    }
    return true;
}
#method_after
public boolean connect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    if (getPriority(device) == BluetoothProfile.PRIORITY_OFF) {
        Log.w(TAG, "connect: PRIORITY_OFF, device=" + device);
        return false;
    }
    synchronized (mStateMachines) {
        Log.i(TAG, "connect: device=" + device);
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            stateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(device, mStateMachinesThread.getLooper(), this, mNativeInterface, mSystemInterface);
            mStateMachines.put(device, stateMachine);
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState == BluetoothProfile.STATE_CONNECTED || connectionState == BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "connect: device " + device + " is already connected/connecting, connectionState=" + connectionState);
            return false;
        }
        List<BluetoothDevice> connectingConnectedDevices = getDevicesMatchingConnectionStates(CONNECTING_CONNECTED_STATES);
        boolean disconnectExisting = false;
        if (connectingConnectedDevices.size() >= mMaxHeadsetConnections) {
            // When there is maximum one device, we automatically disconnect the current one
            if (mMaxHeadsetConnections == 1) {
                disconnectExisting = true;
            } else {
                Log.w(TAG, "Max connection has reached, rejecting connection to " + device);
                return false;
            }
        }
        if (disconnectExisting) {
            for (BluetoothDevice connectingConnectedDevice : connectingConnectedDevices) {
                disconnect(connectingConnectedDevice);
            }
            setActiveDevice(null);
        }
        stateMachine.sendMessage(HeadsetStateMachine.CONNECT, device);
    }
    return true;
}
#end_block

#method_before
boolean disconnect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    Log.i(TAG, "disconnect: device=" + device);
    synchronized (mStateMachines) {
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnect: device " + device + " not ever connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "disconnect: device " + device + " not connected/connecting, connectionState=" + connectionState);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device);
    }
    return true;
}
#method_after
boolean disconnect(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    synchronized (mStateMachines) {
        Log.i(TAG, "disconnect: device=" + device);
        HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnect: device " + device + " not ever connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "disconnect: device " + device + " not connected/connecting, connectionState=" + connectionState);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT, device);
    }
    return true;
}
#end_block

#method_before
public List<BluetoothDevice> getConnectedDevices() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    ArrayList<BluetoothDevice> devices = new ArrayList<>();
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            if (stateMachine.getConnectionState() == BluetoothProfile.STATE_CONNECTED) {
                devices.add(stateMachine.getCurrentDevice());
            }
        }
    }
    return devices;
}
#method_after
public List<BluetoothDevice> getConnectedDevices() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    ArrayList<BluetoothDevice> devices = new ArrayList<>();
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            if (stateMachine.getConnectionState() == BluetoothProfile.STATE_CONNECTED) {
                devices.add(stateMachine.getDevice());
            }
        }
    }
    return devices;
}
#end_block

#method_before
private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    ArrayList<BluetoothDevice> devices = new ArrayList<>();
    if (states == null) {
        return devices;
    }
    final AdapterService adapterService = AdapterService.getAdapterService();
    if (adapterService == null) {
        return devices;
    }
    final BluetoothDevice[] bondedDevices = adapterService.getBondedDevices();
    if (bondedDevices == null) {
        return devices;
    }
    synchronized (mStateMachines) {
        for (BluetoothDevice device : bondedDevices) {
            final ParcelUuid[] featureUuids = adapterService.getRemoteUuids(device);
            if (!BluetoothUuid.containsAnyUuid(featureUuids, HEADSET_UUIDS)) {
                continue;
            }
            int connectionState = getConnectionState(device);
            for (int state : states) {
                if (connectionState == state) {
                    devices.add(device);
                    break;
                }
            }
        }
    }
    return devices;
}
#method_after
private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    ArrayList<BluetoothDevice> devices = new ArrayList<>();
    if (states == null) {
        return devices;
    }
    final BluetoothDevice[] bondedDevices = mAdapterService.getBondedDevices();
    if (bondedDevices == null) {
        return devices;
    }
    synchronized (mStateMachines) {
        for (BluetoothDevice device : bondedDevices) {
            final ParcelUuid[] featureUuids = mAdapterService.getRemoteUuids(device);
            if (!BluetoothUuid.containsAnyUuid(featureUuids, HEADSET_UUIDS)) {
                continue;
            }
            int connectionState = getConnectionState(device);
            for (int state : states) {
                if (connectionState == state) {
                    devices.add(device);
                    break;
                }
            }
        }
    }
    return devices;
}
#end_block

#method_before
public int getPriority(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    return Settings.Global.getInt(getContentResolver(), Settings.Global.getBluetoothHeadsetPriorityKey(device.getAddress()), BluetoothProfile.PRIORITY_UNDEFINED);
}
#method_after
public int getPriority(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    return Settings.Global.getInt(getContentResolver(), Settings.Global.getBluetoothHeadsetPriorityKey(device.getAddress()), BluetoothProfile.PRIORITY_UNDEFINED);
}
#end_block

#method_before
boolean startVoiceRecognition(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VOICE_RECOGNITION_START, device);
    }
    return true;
}
#method_after
boolean startVoiceRecognition(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            return false;
        }
        mVoiceRecognitionStarted = true;
        stateMachine.sendMessage(HeadsetStateMachine.VOICE_RECOGNITION_START, device);
    }
    return true;
}
#end_block

#method_before
boolean stopVoiceRecognition(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return false;
        }
        // It seem that we really need to check the AudioOn state.
        // But since we allow startVoiceRecognition in STATE_CONNECTED and
        // STATE_CONNECTING state, we do these 2 in this method
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VOICE_RECOGNITION_STOP, device);
    }
    return true;
}
#method_after
boolean stopVoiceRecognition(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return false;
        }
        // It seem that we really need to check the AudioOn state.
        // But since we allow startVoiceRecognition in STATE_CONNECTED and
        // STATE_CONNECTING state, we do these 2 in this method
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            return false;
        }
        mVoiceRecognitionStarted = false;
        stateMachine.sendMessage(HeadsetStateMachine.VOICE_RECOGNITION_STOP, device);
    }
    return true;
}
#end_block

#method_before
boolean isAudioOn() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            if (stateMachine.getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                return true;
            }
        }
    }
    return false;
}
#method_after
boolean isAudioOn() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    return getNonIdleAudioDevices().size() > 0;
}
#end_block

#method_before
int getAudioState(BluetoothDevice device) {
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
        }
        return stateMachine.getAudioState();
    }
}
#method_after
int getAudioState(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
        }
        return stateMachine.getAudioState();
    }
}
#end_block

#method_before
public void setAudioRouteAllowed(boolean allowed) {
    mAudioRouteAllowed = allowed;
    mNativeInterface.setScoAllowed(allowed);
}
#method_after
public void setAudioRouteAllowed(boolean allowed) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    mAudioRouteAllowed = allowed;
    mNativeInterface.setScoAllowed(allowed);
}
#end_block

#method_before
public boolean getAudioRouteAllowed() {
    return mAudioRouteAllowed;
}
#method_after
public boolean getAudioRouteAllowed() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    return mAudioRouteAllowed;
}
#end_block

#method_before
boolean connectAudio() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    Log.i(TAG, "connectAudio");
    synchronized (mStateMachines) {
        final BluetoothDevice device = getLastConnectedDevice();
        if (device == null) {
            Log.w(TAG, "connectAudio: no device is connected");
            return false;
        }
        return connectAudio(device);
    }
}
#method_after
boolean connectAudio() {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    synchronized (mStateMachines) {
        BluetoothDevice device = mActiveDevice;
        if (device == null) {
            Log.w(TAG, "connectAudio: no active device is selected");
            return false;
        }
        return connectAudio(device);
    }
}
#end_block

#method_before
boolean connectAudio(BluetoothDevice device) {
    // TODO(BT) BLUETOOTH or BLUETOOTH_ADMIN permission
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    Log.i(TAG, "connectAudio, device=" + device);
    if (device == null) {
        Log.w(TAG, "connectAudio: device is null");
        return false;
    }
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "connectAudio: device " + device + " was never connected/connecting");
            return false;
        }
        if (stateMachine.getConnectionState() != BluetoothProfile.STATE_CONNECTED) {
            Log.w(TAG, "connectAudio: profile not connected");
            return false;
        }
        if (isAudioOn()) {
            Log.w(TAG, "connectAudio: audio is not idle, current audio device is " + getCurrentAudioDevice());
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.CONNECT_AUDIO, device);
    }
    return true;
}
#method_after
boolean connectAudio(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    if (device == null) {
        Log.w(TAG, "connectAudio: device is null");
        return false;
    }
    if (!device.equals(mActiveDevice)) {
        Log.w(TAG, "connectAudio: device is not active, active device is " + mActiveDevice);
        return false;
    }
    synchronized (mStateMachines) {
        Log.i(TAG, "connectAudio, device=" + device);
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "connectAudio: device " + device + " was never connected/connecting");
            return false;
        }
        if (stateMachine.getConnectionState() != BluetoothProfile.STATE_CONNECTED) {
            Log.w(TAG, "connectAudio: profile not connected");
            return false;
        }
        if (stateMachine.getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            logD("connectAudio: audio is not idle for device " + device);
            return true;
        }
        if (isAudioOn()) {
            Log.w(TAG, "connectAudio: audio is not idle, current audio devices are " + Arrays.toString(getNonIdleAudioDevices().toArray()));
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.CONNECT_AUDIO, device);
    }
    return true;
}
#end_block

#method_before
boolean disconnectAudio() {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    Log.i(TAG, "disconnectAudio");
    boolean result = false;
    synchronized (mStateMachines) {
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            if (stateMachine.getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                final BluetoothDevice device = stateMachine.getCurrentDevice();
                if (!disconnectAudio(device)) {
                    Log.e(TAG, "disconnectAudio() from " + device + " failed");
                } else {
                    result = true;
                }
            }
        }
    }
    if (!result) {
        logD("disconnectAudio() no active audio connection");
    }
    return result;
}
#method_after
boolean disconnectAudio() {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    boolean result = false;
    synchronized (mStateMachines) {
        for (BluetoothDevice device : getNonIdleAudioDevices()) {
            if (!disconnectAudio(device)) {
                Log.e(TAG, "disconnectAudio() from " + device + " failed");
            } else {
                result = true;
            }
        }
    }
    if (!result) {
        logD("disconnectAudio() no active audio connection");
    }
    return result;
}
#end_block

#method_before
boolean disconnectAudio(BluetoothDevice device) {
    // TODO(BT) BLUETOOTH or BLUETOOTH_ADMIN permission
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    Log.i(TAG, "disconnectAudio, device=" + device);
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnectAudio: device " + device + " was never connected/connecting");
            return false;
        }
        if (stateMachine.getAudioState() == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            Log.w(TAG, "disconnectAudio, audio is already disconnected for " + device);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, device);
    }
    return true;
}
#method_after
boolean disconnectAudio(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH_ADMIN permission");
    synchronized (mStateMachines) {
        Log.i(TAG, "disconnectAudio, device=" + device);
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "disconnectAudio: device " + device + " was never connected/connecting");
            return false;
        }
        if (stateMachine.getAudioState() == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            Log.w(TAG, "disconnectAudio, audio is already disconnected for " + device);
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, device);
    }
    return true;
}
#end_block

#method_before
boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "startScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_START, device);
    }
    return true;
}
#method_after
boolean startScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "startScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_START, device);
    }
    return true;
}
#end_block

#method_before
boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " is neither connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_STOP, device);
    }
    return true;
}
#method_after
boolean stopScoUsingVirtualVoiceCall(BluetoothDevice device) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH permission");
    synchronized (mStateMachines) {
        final HeadsetStateMachine stateMachine = mStateMachines.get(device);
        if (stateMachine == null) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " was never connected/connecting");
            return false;
        }
        int connectionState = stateMachine.getConnectionState();
        if (connectionState != BluetoothProfile.STATE_CONNECTED && connectionState != BluetoothProfile.STATE_CONNECTING) {
            Log.w(TAG, "stopScoUsingVirtualVoiceCall: device " + device + " is neither connected/connecting");
            return false;
        }
        stateMachine.sendMessage(HeadsetStateMachine.VIRTUAL_CALL_STOP, device);
    }
    return true;
}
#end_block

#method_before
private void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type) {
    enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
    broadCastMessageToStateMachines(HeadsetStateMachine.CALL_STATE_CHANGED, new HeadsetCallState(numActive, numHeld, callState, number, type));
}
#method_after
private void phoneStateChanged(int numActive, int numHeld, int callState, String number, int type) {
    enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
    doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.CALL_STATE_CHANGED, new HeadsetCallState(numActive, numHeld, callState, number, type)));
}
#end_block

#method_before
private void clccResponse(int index, int direction, int status, int mode, boolean mpty, String number, int type) {
    enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
    broadCastMessageToStateMachines(HeadsetStateMachine.SEND_CCLC_RESPONSE, new HeadsetClccResponse(index, direction, status, mode, mpty, number, type));
}
#method_after
private void clccResponse(int index, int direction, int status, int mode, boolean mpty, String number, int type) {
    enforceCallingOrSelfPermission(MODIFY_PHONE_STATE, null);
    doForEachConnectedStateMachine(stateMachine -> stateMachine.sendMessage(HeadsetStateMachine.SEND_CCLC_RESPONSE, new HeadsetClccResponse(index, direction, status, mode, mpty, number, type)));
}
#end_block

#method_before
@Override
public void dump(StringBuilder sb) {
    super.dump(sb);
    for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
        stateMachine.dump(sb);
    }
}
#method_after
@Override
public void dump(StringBuilder sb) {
    synchronized (mStateMachines) {
        super.dump(sb);
        ProfileService.println(sb, "mMaxHeadsetConnections: " + mMaxHeadsetConnections);
        ProfileService.println(sb, "DefaultMaxHeadsetConnections: " + mAdapterService.getMaxConnectedAudioDevices());
        ProfileService.println(sb, "mActiveDevice: " + mActiveDevice);
        ProfileService.println(sb, "isInbandRingingEnabled: " + isInbandRingingEnabled());
        ProfileService.println(sb, "isInbandRingingSupported: " + BluetoothHeadset.isInbandRingingSupported(this));
        ProfileService.println(sb, "mInbandRingingRuntimeDisable: " + mInbandRingingRuntimeDisable);
        ProfileService.println(sb, "mAudioRouteAllowed: " + mAudioRouteAllowed);
        ProfileService.println(sb, "mForceScoAudio: " + mForceScoAudio);
        ProfileService.println(sb, "mCreated: " + mCreated);
        ProfileService.println(sb, "mStarted: " + mStarted);
        ProfileService.println(sb, "AudioManager.isBluetoothScoOn(): " + mSystemInterface.getAudioManager().isBluetoothScoOn());
        ProfileService.println(sb, "Telecom.isInCall(): " + mSystemInterface.isInCall());
        ProfileService.println(sb, "Telecom.isRinging(): " + mSystemInterface.isRinging());
        for (HeadsetStateMachine stateMachine : mStateMachines.values()) {
            ProfileService.println(sb, "==== StateMachine for " + stateMachine.getDevice() + " ====");
            stateMachine.dump(sb);
        }
    }
}
#end_block

#method_before
@BeforeClass
public static void setUpClassOnlyOnce() throws Exception {
    sAdapterService = mock(AdapterService.class);
    // We cannot mock AdapterService.getAdapterService() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the AdapterService.sAdapterService field.
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(sAdapterService, sAdapterService);
    // We cannot mock HeadsetObjectsFactory.getInstance() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the HeadsetObjectsFactory.sInstance field.
    sObjectsFactory = spy(HeadsetObjectsFactory.getInstance());
    method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(sObjectsFactory, sObjectsFactory);
}
#method_after
@BeforeClass
public static void setUpClassOnlyOnce() throws Exception {
    sAdapterService = mock(AdapterService.class);
    // We cannot mock AdapterService.getAdapterService() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the AdapterService.sAdapterService field.
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(null, sAdapterService);
    // We cannot mock HeadsetObjectsFactory.getInstance() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the HeadsetObjectsFactory.sInstance field.
    sObjectsFactory = spy(HeadsetObjectsFactory.getInstance());
    method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, sObjectsFactory);
}
#end_block

#method_before
@AfterClass
public static void tearDownClassOnlyOnce() throws Exception {
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(sAdapterService, (AdapterService) null);
    sAdapterService = null;
    method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(sObjectsFactory, (HeadsetObjectsFactory) null);
    sObjectsFactory = null;
}
#method_after
@AfterClass
public static void tearDownClassOnlyOnce() throws Exception {
    Method method = AdapterService.class.getDeclaredMethod("clearAdapterService");
    method.setAccessible(true);
    method.invoke(null);
    sAdapterService = null;
    method = HeadsetObjectsFactory.class.getDeclaredMethod("setInstanceForTesting", HeadsetObjectsFactory.class);
    method.setAccessible(true);
    method.invoke(null, (HeadsetObjectsFactory) null);
    sObjectsFactory = null;
}
#end_block

#method_before
@Before
public void setUp() throws TimeoutException {
    MockitoAnnotations.initMocks(this);
    doReturn(true).when(sAdapterService).isEnabled();
    doReturn(new ParcelUuid[] { BluetoothUuid.Handsfree }).when(sAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Mock system interface
    doNothing().when(mSystemInterface).init();
    doNothing().when(mSystemInterface).stop();
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // Mock methods in HeadsetNativeInterface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doNothing().when(mNativeInterface).cleanup();
    doReturn(true).when(mNativeInterface).connectHfp(mCurrentDevice);
    doReturn(true).when(mNativeInterface).disconnectHfp(mCurrentDevice);
    doReturn(true).when(mNativeInterface).connectAudio(mCurrentDevice);
    doReturn(true).when(mNativeInterface).disconnectAudio(mCurrentDevice);
    // Mock methods in HeadsetObjectsFactory
    doAnswer(invocation -> {
        Assert.assertNotNull(mCurrentDevice);
        final HeadsetStateMachine stateMachine = mock(HeadsetStateMachine.class);
        when(stateMachine.getConnectionState()).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
        when(stateMachine.getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
        mStateMachines.put(mCurrentDevice, stateMachine);
        return stateMachine;
    }).when(sObjectsFactory).makeStateMachine(any(), any(), any(), any());
    doReturn(mSystemInterface).when(sObjectsFactory).makeSystemInterface(any());
    doReturn(mNativeInterface).when(sObjectsFactory).getNativeInterface();
    Intent startIntent = new Intent(InstrumentationRegistry.getTargetContext(), HeadsetService.class);
    startIntent.putExtra(AdapterService.EXTRA_ACTION, AdapterService.ACTION_SERVICE_STATE_CHANGED);
    startIntent.putExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_ON);
    mServiceRule.startService(startIntent);
    verify(sAdapterService, timeout(ASYNC_CALL_TIMEOUT_MILLIS)).onProfileServiceStateChanged(eq(HeadsetService.class.getName()), eq(BluetoothAdapter.STATE_ON));
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNotNull(mHeadsetService);
    verify(sObjectsFactory).makeSystemInterface(mHeadsetService);
}
#method_after
@Before
public void setUp() throws TimeoutException {
    MockitoAnnotations.initMocks(this);
    doReturn(true).when(sAdapterService).isEnabled();
    doReturn(MAX_HEADSET_CONNECTIONS).when(sAdapterService).getMaxConnectedAudioDevices();
    doReturn(new ParcelUuid[] { BluetoothUuid.Handsfree }).when(sAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Mock methods in AdapterService
    doReturn(FAKE_HEADSET_UUID).when(sAdapterService).getRemoteUuids(any(BluetoothDevice.class));
    doAnswer(invocation -> {
        Set<BluetoothDevice> keys = mStateMachines.keySet();
        return keys.toArray(new BluetoothDevice[keys.size()]);
    }).when(sAdapterService).getBondedDevices();
    // Mock system interface
    doNothing().when(mSystemInterface).init();
    doNothing().when(mSystemInterface).stop();
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // Mock methods in HeadsetNativeInterface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doNothing().when(mNativeInterface).cleanup();
    doReturn(true).when(mNativeInterface).connectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectHfp(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).connectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).disconnectAudio(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).setActiveDevice(any(BluetoothDevice.class));
    doReturn(true).when(mNativeInterface).sendBsir(any(BluetoothDevice.class), anyBoolean());
    // Mock methods in HeadsetObjectsFactory
    doAnswer(invocation -> {
        Assert.assertNotNull(mCurrentDevice);
        final HeadsetStateMachine stateMachine = mock(HeadsetStateMachine.class);
        doReturn(BluetoothProfile.STATE_DISCONNECTED).when(stateMachine).getConnectionState();
        doReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED).when(stateMachine).getAudioState();
        mStateMachines.put(mCurrentDevice, stateMachine);
        return stateMachine;
    }).when(sObjectsFactory).makeStateMachine(any(), any(), any(), any(), any());
    doReturn(mSystemInterface).when(sObjectsFactory).makeSystemInterface(any());
    doReturn(mNativeInterface).when(sObjectsFactory).getNativeInterface();
    Intent startIntent = new Intent(InstrumentationRegistry.getTargetContext(), HeadsetService.class);
    startIntent.putExtra(AdapterService.EXTRA_ACTION, AdapterService.ACTION_SERVICE_STATE_CHANGED);
    startIntent.putExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_ON);
    mServiceRule.startService(startIntent);
    verify(sAdapterService, timeout(ASYNC_CALL_TIMEOUT_MILLIS)).onProfileServiceStateChanged(eq(HeadsetService.class.getName()), eq(BluetoothAdapter.STATE_ON));
    mHeadsetService = HeadsetService.getHeadsetService();
    Assert.assertNotNull(mHeadsetService);
    verify(sObjectsFactory).makeSystemInterface(mHeadsetService);
}
#end_block

#method_before
@Test
public void testConnectDevice_connectDeviceBelowLimit() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mHeadsetService.getConnectionState(mCurrentDevice));
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.singletonList(mCurrentDevice), mHeadsetService.getConnectedDevices());
    // 2nd connection attempt will fail
    Assert.assertFalse(mHeadsetService.connect(mCurrentDevice));
    // Verify makeStateMachine is only called once
    verify(sObjectsFactory).makeStateMachine(any(), any(), any(), any());
    // Verify CONNECT is only sent once
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any());
}
#method_after
@Test
public void testConnectDevice_connectDeviceBelowLimit() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTING, mHeadsetService.getConnectionState(mCurrentDevice));
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.singletonList(mCurrentDevice), mHeadsetService.getConnectedDevices());
    // 2nd connection attempt will fail
    Assert.assertFalse(mHeadsetService.connect(mCurrentDevice));
    // Verify makeStateMachine is only called once
    verify(sObjectsFactory).makeStateMachine(any(), any(), any(), any(), any());
    // Verify CONNECT is only sent once
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any());
}
#end_block

#method_before
@Test
public void testConnectDevice_connectDeviceAboveLimit() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < HeadsetService.MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
    }
    // Connect the next device will fail
    mCurrentDevice = getTestDevice(HeadsetService.MAX_HEADSET_CONNECTIONS);
    Assert.assertFalse(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory, times(HeadsetService.MAX_HEADSET_CONNECTIONS)).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
}
#method_after
@Test
public void testConnectDevice_connectDeviceAboveLimit() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(any(BluetoothDevice.class), eq(mHeadsetService.getStateMachinesThreadLooper()), eq(mHeadsetService), eq(mNativeInterface), eq(mSystemInterface));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
    }
    // Connect the next device will fail
    mCurrentDevice = getTestDevice(MAX_HEADSET_CONNECTIONS);
    Assert.assertFalse(mHeadsetService.connect(mCurrentDevice));
    // Though connection failed, a new state machine is still lazily created for the device
    verify(sObjectsFactory, times(MAX_HEADSET_CONNECTIONS + 1)).makeStateMachine(any(BluetoothDevice.class), eq(mHeadsetService.getStateMachinesThreadLooper()), eq(mHeadsetService), eq(mNativeInterface), eq(mSystemInterface));
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
}
#end_block

#method_before
@Test
public void testConnectAudio_withOneDevice() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.singletonList(mCurrentDevice), mHeadsetService.getConnectedDevices());
    // Test connect audio
    Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
    // 2nd connection attempt will fail
    Assert.assertFalse(mHeadsetService.connectAudio(mCurrentDevice));
    // Verify CONNECT_AUDIO is only sent once
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
    // Test disconnect audio
    Assert.assertTrue(mHeadsetService.disconnectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
    // Further disconnection requests will fail
    Assert.assertFalse(mHeadsetService.disconnectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.DISCONNECT_AUDIO), any(BluetoothDevice.class));
}
#method_after
@Test
public void testConnectAudio_withOneDevice() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
    when(mStateMachines.get(mCurrentDevice).getConnectingTimestampMs()).thenReturn(SystemClock.uptimeMillis());
    Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.singletonList(mCurrentDevice), mHeadsetService.getConnectedDevices());
    mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTED);
    // Test connect audio, the first connected device should be the default active device
    Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
    // 2nd connection attempt for the same device will succeed as well
    Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
    // Verify CONNECT_AUDIO is only sent once
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
    // Test disconnect audio
    Assert.assertTrue(mHeadsetService.disconnectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
    // Further disconnection requests will fail
    Assert.assertFalse(mHeadsetService.disconnectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.DISCONNECT_AUDIO), any(BluetoothDevice.class));
}
#end_block

#method_before
@Test
public void testConnectAudio_withMultipleDevices() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < HeadsetService.MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Try to connect audio
        Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, mCurrentDevice);
        // Put device to audio connecting state
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
        // 2nd connection attempt will fail
        Assert.assertFalse(mHeadsetService.connectAudio(mCurrentDevice));
        // Verify CONNECT_AUDIO is only sent once
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
        // Put device to audio connected state
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTED);
        // Disconnect audio
        Assert.assertTrue(mHeadsetService.disconnectAudio(mCurrentDevice));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
        // Further disconnection requests will fail
        Assert.assertFalse(mHeadsetService.disconnectAudio(mCurrentDevice));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.DISCONNECT_AUDIO), any(BluetoothDevice.class));
    }
}
#method_after
@Test
public void testConnectAudio_withMultipleDevices() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(any(BluetoothDevice.class), eq(mHeadsetService.getStateMachinesThreadLooper()), eq(mHeadsetService), eq(mNativeInterface), eq(mSystemInterface));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        when(mStateMachines.get(mCurrentDevice).getConnectingTimestampMs()).thenReturn(SystemClock.uptimeMillis());
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_CONNECTED);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Try to connect audio
        if (i == 0) {
            // Should only succeed with the first device
            Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
        } else {
            // Should fail for other devices
            Assert.assertFalse(mHeadsetService.connectAudio(mCurrentDevice));
            // Should succeed after setActiveDevice()
            Assert.assertTrue(mHeadsetService.setActiveDevice(mCurrentDevice));
            Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
        }
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, mCurrentDevice);
        // Put device to audio connecting state
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
        // 2nd connection attempt will also succeed
        Assert.assertTrue(mHeadsetService.connectAudio(mCurrentDevice));
        // Verify CONNECT_AUDIO is only sent once
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
        // Put device to audio connected state
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTED);
        // Disconnect audio
        Assert.assertTrue(mHeadsetService.disconnectAudio(mCurrentDevice));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.DISCONNECT_AUDIO, mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
        // Further disconnection requests will fail
        Assert.assertFalse(mHeadsetService.disconnectAudio(mCurrentDevice));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.DISCONNECT_AUDIO), any(BluetoothDevice.class));
    }
}
#end_block

#method_before
@Test
public void testConnectAudio_connectTwoAudioChannelsShouldFail() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < HeadsetService.MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
    }
    if (HeadsetService.MAX_HEADSET_CONNECTIONS >= 2) {
        // Try to connect audio
        BluetoothDevice firstDevice = connectedDevices.get(0);
        BluetoothDevice secondDevice = connectedDevices.get(1);
        Assert.assertTrue(mHeadsetService.connectAudio(firstDevice));
        verify(mStateMachines.get(firstDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, firstDevice);
        // Put device to audio connecting state
        when(mStateMachines.get(firstDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
        // 2nd connection attempt will fail
        Assert.assertFalse(mHeadsetService.connectAudio(firstDevice));
        // Connect to 2nd device will fail
        Assert.assertFalse(mHeadsetService.connectAudio(secondDevice));
        verify(mStateMachines.get(secondDevice), never()).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, secondDevice);
        // Put device to audio connected state
        when(mStateMachines.get(firstDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTED);
        // Connect to 2nd device will fail
        Assert.assertFalse(mHeadsetService.connectAudio(secondDevice));
        verify(mStateMachines.get(secondDevice), never()).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, secondDevice);
    }
}
#method_after
@Test
public void testConnectAudio_connectTwoAudioChannelsShouldFail() {
    ArrayList<BluetoothDevice> connectedDevices = new ArrayList<>();
    for (int i = 0; i < MAX_HEADSET_CONNECTIONS; ++i) {
        mCurrentDevice = getTestDevice(i);
        Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
        verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
        verify(sObjectsFactory, times(i + 1)).makeStateMachine(any(BluetoothDevice.class), eq(mHeadsetService.getStateMachinesThreadLooper()), eq(mHeadsetService), eq(mNativeInterface), eq(mSystemInterface));
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
        verify(mStateMachines.get(mCurrentDevice)).sendMessage(eq(HeadsetStateMachine.CONNECT), any(BluetoothDevice.class));
        // Put device to connecting
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTING);
        mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTING);
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
        // Put device to connected
        connectedDevices.add(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
        when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_CONNECTED);
        when(mStateMachines.get(mCurrentDevice).getConnectingTimestampMs()).thenReturn(SystemClock.uptimeMillis());
        mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_CONNECTED);
        Assert.assertEquals(BluetoothProfile.STATE_CONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
        Assert.assertThat(mHeadsetService.getConnectedDevices(), Matchers.containsInAnyOrder(connectedDevices.toArray()));
    }
    if (MAX_HEADSET_CONNECTIONS >= 2) {
        // Try to connect audio
        BluetoothDevice firstDevice = connectedDevices.get(0);
        BluetoothDevice secondDevice = connectedDevices.get(1);
        // First device is the default device
        Assert.assertTrue(mHeadsetService.connectAudio(firstDevice));
        verify(mStateMachines.get(firstDevice)).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, firstDevice);
        // Put device to audio connecting state
        when(mStateMachines.get(firstDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTING);
        // 2nd connection attempt will succeed for the same device
        Assert.assertTrue(mHeadsetService.connectAudio(firstDevice));
        // Connect to 2nd device will fail
        Assert.assertFalse(mHeadsetService.connectAudio(secondDevice));
        verify(mStateMachines.get(secondDevice), never()).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, secondDevice);
        // Put device to audio connected state
        when(mStateMachines.get(firstDevice).getAudioState()).thenReturn(BluetoothHeadset.STATE_AUDIO_CONNECTED);
        // Connect to 2nd device will fail
        Assert.assertFalse(mHeadsetService.connectAudio(secondDevice));
        verify(mStateMachines.get(secondDevice), never()).sendMessage(HeadsetStateMachine.CONNECT_AUDIO, secondDevice);
    }
}
#end_block

#method_before
@Test
public void testConnectAudio_deviceDisconnected() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getCurrentDevice()).thenReturn(mCurrentDevice);
    // Put device in disconnected state
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.EMPTY_LIST, mHeadsetService.getConnectedDevices());
    // connectAudio should fail
    Assert.assertFalse(mHeadsetService.connectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice), never()).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
}
#method_after
@Test
public void testConnectAudio_deviceDisconnected() {
    mCurrentDevice = getTestDevice(0);
    Assert.assertTrue(mHeadsetService.connect(mCurrentDevice));
    verify(sObjectsFactory).makeStateMachine(mCurrentDevice, mHeadsetService.getStateMachinesThreadLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
    verify(mStateMachines.get(mCurrentDevice)).sendMessage(HeadsetStateMachine.CONNECT, mCurrentDevice);
    when(mStateMachines.get(mCurrentDevice).getDevice()).thenReturn(mCurrentDevice);
    // Put device in disconnected state
    when(mStateMachines.get(mCurrentDevice).getConnectionState()).thenReturn(BluetoothProfile.STATE_DISCONNECTED);
    Assert.assertEquals(BluetoothProfile.STATE_DISCONNECTED, mHeadsetService.getConnectionState(mCurrentDevice));
    Assert.assertEquals(Collections.EMPTY_LIST, mHeadsetService.getConnectedDevices());
    mHeadsetService.onConnectionStateChangedFromStateMachine(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED);
    // connectAudio should fail
    Assert.assertFalse(mHeadsetService.connectAudio(mCurrentDevice));
    verify(mStateMachines.get(mCurrentDevice), never()).sendMessage(eq(HeadsetStateMachine.CONNECT_AUDIO), any());
}
#end_block

#method_before
static HeadsetStateMachine make(Looper looper, HeadsetService service, HeadsetNativeInterface nativeInterface, HeadsetSystemInterface systemInterface) {
    Log.i(TAG, "make");
    HeadsetStateMachine stateMachine = new HeadsetStateMachine(looper, service, nativeInterface, systemInterface);
    stateMachine.start();
    return stateMachine;
}
#method_after
static HeadsetStateMachine make(BluetoothDevice device, Looper looper, HeadsetService service, HeadsetNativeInterface nativeInterface, HeadsetSystemInterface systemInterface) {
    Log.i(TAG, "make");
    HeadsetStateMachine stateMachine = new HeadsetStateMachine(device, looper, service, nativeInterface, systemInterface);
    stateMachine.start();
    return stateMachine;
}
#end_block

#method_before
public void dump(StringBuilder sb) {
    ProfileService.println(sb, "mCurrentDevice: " + mCurrentDevice);
    ProfileService.println(sb, "mVirtualCallStarted: " + mVirtualCallStarted);
    ProfileService.println(sb, "mVoiceRecognitionStarted: " + mVoiceRecognitionStarted);
    ProfileService.println(sb, "mWaitingForVoiceRecognition: " + mWaitingForVoiceRecognition);
    ProfileService.println(sb, "mDialingOut: " + mDialingOut);
    ProfileService.println(sb, "mAudioRouteAllowed: " + mAudioRouteAllowed);
    ProfileService.println(sb, "StateMachine: " + this);
    ProfileService.println(sb, "PreviousState: " + mPrevState);
    ProfileService.println(sb, "mAudioState: " + getAudioState());
    // Dump the state machine logs
    StringWriter stringWriter = new StringWriter();
    PrintWriter printWriter = new PrintWriter(stringWriter);
    super.dump(new FileDescriptor(), printWriter, new String[] {});
    printWriter.flush();
    stringWriter.flush();
    ProfileService.println(sb, "StateMachineLog: " + stringWriter.toString());
}
#method_after
public void dump(StringBuilder sb) {
    ProfileService.println(sb, "  mCurrentDevice: " + mDevice);
    ProfileService.println(sb, "  mCurrentState: " + getCurrentState());
    ProfileService.println(sb, "  mPrevState: " + mPrevState);
    ProfileService.println(sb, "  mConnectionState: " + getConnectionState());
    ProfileService.println(sb, "  mAudioState: " + getAudioState());
    ProfileService.println(sb, "  mVirtualCallStarted: " + mVirtualCallStarted);
    ProfileService.println(sb, "  mVoiceRecognitionStarted: " + mVoiceRecognitionStarted);
    ProfileService.println(sb, "  mWaitingForVoiceRecognition: " + mWaitingForVoiceRecognition);
    ProfileService.println(sb, "  mDialingOut: " + mDialingOut);
    ProfileService.println(sb, "  mSpeakerVolume: " + mSpeakerVolume);
    ProfileService.println(sb, "  mMicVolume: " + mMicVolume);
    ProfileService.println(sb, "  mConnectingTimestampMs(uptimeMillis): " + mConnectingTimestampMs);
    ProfileService.println(sb, "  StateMachine: " + this);
    // Dump the state machine logs
    StringWriter stringWriter = new StringWriter();
    PrintWriter printWriter = new PrintWriter(stringWriter);
    super.dump(new FileDescriptor(), printWriter, new String[] {});
    printWriter.flush();
    stringWriter.flush();
    ProfileService.println(sb, "  StateMachineLog:");
    Scanner scanner = new Scanner(stringWriter.toString());
    while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        ProfileService.println(sb, "    " + line);
    }
    scanner.close();
}
#end_block

#method_before
@Override
public void enter() {
    // Crash if current device is null and state is not Disconnected
    if (!(this instanceof Disconnected) && mCurrentDevice == null) {
        stateLogWtfStack("mCurrentDevice is null on enter()");
    }
    // Crash if mPrevState is null and state is not Disconnected
    if (!(this instanceof Disconnected) && mPrevState == null) {
        stateLogWtfStack("mPrevState is null on enter()");
    }
}
#method_after
@Override
public void enter() {
    // Crash if mPrevState is null and state is not Disconnected
    if (!(this instanceof Disconnected) && mPrevState == null) {
        throw new IllegalStateException("mPrevState is null on enter()");
    }
    enforceValidConnectionStateTransition();
}
#end_block

#method_before
@Override
public void exit() {
    Message message = getCurrentMessage();
    if (message != null && !isQuit(message) && mCurrentDevice == null) {
        stateLogWtfStack("mCurrentDevice is null on exit() to non-quitting state");
    }
    mPrevState = this;
}
#method_after
@Override
public void exit() {
    mPrevState = this;
}
#end_block

#method_before
void stateLogD(String msg) {
    log(getName() + ": " + msg);
}
#method_after
void stateLogD(String msg) {
    log(getName() + ": currentDevice=" + mDevice + ", msg=" + msg);
}
#end_block

#method_before
void stateLogW(String msg) {
    logw(getName() + ": " + msg);
}
#method_after
void stateLogW(String msg) {
    logw(getName() + ": currentDevice=" + mDevice + ", msg=" + msg);
}
#end_block

#method_before
void stateLogE(String msg) {
    loge(getName() + ": " + msg);
}
#method_after
void stateLogE(String msg) {
    loge(getName() + ": currentDevice=" + mDevice + ", msg=" + msg);
}
#end_block

#method_before
void stateLogV(String msg) {
    logv(getName() + ": " + msg);
}
#method_after
void stateLogV(String msg) {
    logv(getName() + ": currentDevice=" + mDevice + ", msg=" + msg);
}
#end_block

#method_before
void stateLogI(String msg) {
    logi(getName() + ": " + msg);
}
#method_after
void stateLogI(String msg) {
    logi(getName() + ": currentDevice=" + mDevice + ", msg=" + msg);
}
#end_block

#method_before
@Override
public void enter() {
    super.enter();
    mConnectingTimestampMillis = Long.MIN_VALUE;
    mPhonebook.resetAtState();
    mSystemInterface.getHeadsetPhoneState().listenForPhoneState(false);
    mVoiceRecognitionStarted = false;
    mWaitingForVoiceRecognition = false;
    mAudioParams.clear();
    processWBSEvent(0);
    /* disable WBS audio parameters */
    if (mPrevState == mConnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState == mDisconnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTING);
    } else if (mPrevState instanceof ConnectedBase) {
        // Broadcast audio state change first, if any
        if (mPrevState == mAudioConnecting) {
            broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTING);
        } else if (mPrevState == mAudioOn || mPrevState == mAudioDisconnecting) {
            broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTED);
        }
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_CONNECTED);
    } else if (mPrevState != null) {
        // null is the default state before Disconnected
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
    mCurrentDevice = null;
}
#method_after
@Override
public void enter() {
    super.enter();
    mConnectingTimestampMs = Long.MIN_VALUE;
    mPhonebook.resetAtState();
    mSystemInterface.getHeadsetPhoneState().listenForPhoneState(false);
    mVoiceRecognitionStarted = false;
    mWaitingForVoiceRecognition = false;
    mAudioParams.clear();
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (mCurrentDevice != null) {
        stateLogE("mCurrentDevice is not null");
        return NOT_HANDLED;
    }
    switch(message.what) {
        case CONNECT:
            BluetoothDevice device = (BluetoothDevice) message.obj;
            stateLogD("Connecting to " + device);
            if (!mNativeInterface.connectHfp(device)) {
                // No state transition is involved, fire broadcast immediately
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
                break;
            }
            mCurrentDevice = device;
            transitionTo(mConnecting);
            break;
        case DISCONNECT:
            // ignore
            break;
        case CALL_STATE_CHANGED:
            processCallState((HeadsetCallState) message.obj, message.arg1 == 1);
            break;
        case DEVICE_STATE_CHANGED:
            stateLogD("Ignoring DEVICE_STATE_CHANGED event");
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt, event.device);
                    break;
                default:
                    stateLogE("Unexpected stack event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
            BluetoothDevice device = (BluetoothDevice) message.obj;
            stateLogD("Connecting to " + device);
            if (!mDevice.equals(device)) {
                stateLogE("CONNECT failed, device=" + device + ", currentDevice=" + mDevice);
                break;
            }
            if (!mNativeInterface.connectHfp(device)) {
                stateLogE("CONNECT failed for connectHfp(" + device + ")");
                // No state transition is involved, fire broadcast immediately
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
                break;
            }
            transitionTo(mConnecting);
            break;
        case DISCONNECT:
            // ignore
            break;
        case CALL_STATE_CHANGED:
            stateLogD("Ignoring CALL_STATE_CHANGED event");
            break;
        case DEVICE_STATE_CHANGED:
            stateLogD("Ignoring DEVICE_STATE_CHANGED event");
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            if (!mDevice.equals(event.device)) {
                stateLogE("Event device does not match currentDevice[" + mDevice + "], event: " + event);
                break;
            }
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt);
                    break;
                default:
                    stateLogE("Unexpected stack event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processConnectionEvent(Message message, int state, BluetoothDevice device) {
    stateLogD("processConnectionEvent, state=" + state + ", device=" + device);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogW("ignore DISCONNECTED event, device=" + device);
            break;
        // Both events result in Connecting state as SLC establishment is still required
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
            if (okToAcceptConnection(device)) {
                stateLogI("connected/connecting incoming HF, device=" + device);
                mCurrentDevice = device;
                transitionTo(mConnecting);
            } else {
                stateLogI("rejected incoming HF, priority=" + mService.getPriority(device) + " bondState=" + device.getBondState() + ", device=" + device);
                // reject the connection and stay in Disconnected state itself
                mNativeInterface.disconnectHfp(device);
                // fire broadcast in case other profile connection should be initiated
                // fire immediately as no state transition occurred
                broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
            }
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            stateLogW("Ignore DISCONNECTING event, device=" + device);
            break;
        default:
            stateLogE("Incorrect state: " + state);
            break;
    }
}
#method_after
@Override
public void processConnectionEvent(Message message, int state) {
    stateLogD("processConnectionEvent, state=" + state);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogW("ignore DISCONNECTED event");
            break;
        // Both events result in Connecting state as SLC establishment is still required
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
            if (mService.okToAcceptConnection(mDevice)) {
                stateLogI("accept incoming connection");
                transitionTo(mConnecting);
            } else {
                stateLogI("rejected incoming HF, priority=" + mService.getPriority(mDevice) + " bondState=" + mDevice.getBondState());
                // Reject the connection and stay in Disconnected state itself
                if (!mNativeInterface.disconnectHfp(mDevice)) {
                    stateLogE("failed to disconnect");
                }
                // Indicate rejection to other components.
                broadcastConnectionState(mDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
            }
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            stateLogW("Ignore DISCONNECTING event");
            break;
        default:
            stateLogE("Incorrect state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    super.enter();
    mConnectingTimestampMillis = SystemClock.uptimeMillis();
    sendMessageDelayed(CONNECT_TIMEOUT, mCurrentDevice, sConnectTimeoutMillis);
    if (mPrevState == mDisconnected) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_DISCONNECTED);
    } else {
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    super.enter();
    mConnectingTimestampMs = SystemClock.uptimeMillis();
    sendMessageDelayed(CONNECT_TIMEOUT, mDevice, sConnectTimeoutMs);
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            // We timed out trying to connect, transition to disconnected.
            stateLogW("Connection timeout for " + mCurrentDevice);
            transitionTo(mDisconnected);
            break;
        case CALL_STATE_CHANGED:
            processCallState((HeadsetCallState) message.obj, message.arg1 == 1);
            break;
        case BIND_RESPONSE:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("Connecting: Unknown device " + device);
                    break;
                }
                mNativeInterface.bindResponse(device, message.arg1, message.arg2 == 1);
                break;
            }
        case DEVICE_STATE_CHANGED:
            stateLogD("ignoring DEVICE_STATE_CHANGED event");
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CHLD:
                    processAtChld(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CIND:
                    processAtCind(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_WBS:
                    processWBSEvent(event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIND:
                    processAtBind(event.valueString, event.device);
                    break;
                // Unexpected AT commands, we only handle them for comparability reasons
                case HeadsetStackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    stateLogW("Unexpected VR event, device=" + event.device + ", state=" + event.valueInt);
                    processVrEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_DIAL_CALL:
                    stateLogW("Unexpected dial event, device=" + event.device);
                    processDialCall(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SUBSCRIBER_NUMBER_REQUEST:
                    stateLogW("Unexpected subscriber number event for" + event.device + ", state=" + event.valueInt);
                    processSubscriberNumberRequest(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_COPS:
                    stateLogW("Unexpected COPS event for " + event.device);
                    processAtCops(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CLCC:
                    Log.w(TAG, "Connecting: Unexpected CLCC event for" + event.device);
                    processAtClcc(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_UNKNOWN_AT:
                    stateLogW("Unexpected unknown AT event for" + event.device + ", cmd=" + event.valueString);
                    processUnknownAt(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_KEY_PRESSED:
                    stateLogW("Unexpected key-press event for " + event.device);
                    processKeyPressed(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIEV:
                    stateLogW("Unexpected BIEV event for " + event.device + ", indId=" + event.valueInt + ", indVal=" + event.valueInt2);
                    processAtBiev(event.valueInt, event.valueInt2, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    stateLogW("Unexpected volume event for " + event.device);
                    processVolumeEvent(event.valueInt, event.valueInt2, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_ANSWER_CALL:
                    stateLogW("Unexpected answer event for " + event.device);
                    mSystemInterface.answerCall(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_HANGUP_CALL:
                    stateLogW("Unexpected hangup event for " + event.device);
                    mSystemInterface.hangupCall(event.device, isVirtualCallInProgress());
                    break;
                default:
                    stateLogE("Unexpected event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                // We timed out trying to connect, transition to Disconnected state
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogE("Unknown device timeout " + device);
                    break;
                }
                stateLogW("CONNECT_TIMEOUT");
                transitionTo(mDisconnected);
                break;
            }
        case CALL_STATE_CHANGED:
            stateLogD("ignoring CALL_STATE_CHANGED event");
            break;
        case DEVICE_STATE_CHANGED:
            stateLogD("ignoring DEVICE_STATE_CHANGED event");
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            if (!mDevice.equals(event.device)) {
                stateLogE("Event device does not match currentDevice[" + mDevice + "], event: " + event);
                break;
            }
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CHLD:
                    processAtChld(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CIND:
                    processAtCind(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_WBS:
                    processWBSEvent(event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIND:
                    processAtBind(event.valueString, event.device);
                    break;
                // Unexpected AT commands, we only handle them for comparability reasons
                case HeadsetStackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    stateLogW("Unexpected VR event, device=" + event.device + ", state=" + event.valueInt);
                    processVrEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_DIAL_CALL:
                    stateLogW("Unexpected dial event, device=" + event.device);
                    processDialCall(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SUBSCRIBER_NUMBER_REQUEST:
                    stateLogW("Unexpected subscriber number event for" + event.device + ", state=" + event.valueInt);
                    processSubscriberNumberRequest(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_COPS:
                    stateLogW("Unexpected COPS event for " + event.device);
                    processAtCops(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CLCC:
                    Log.w(TAG, "Connecting: Unexpected CLCC event for" + event.device);
                    processAtClcc(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_UNKNOWN_AT:
                    stateLogW("Unexpected unknown AT event for" + event.device + ", cmd=" + event.valueString);
                    processUnknownAt(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_KEY_PRESSED:
                    stateLogW("Unexpected key-press event for " + event.device);
                    processKeyPressed(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIEV:
                    stateLogW("Unexpected BIEV event for " + event.device + ", indId=" + event.valueInt + ", indVal=" + event.valueInt2);
                    processAtBiev(event.valueInt, event.valueInt2, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    stateLogW("Unexpected volume event for " + event.device);
                    processVolumeEvent(event.valueInt, event.valueInt2);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_ANSWER_CALL:
                    stateLogW("Unexpected answer event for " + event.device);
                    mSystemInterface.answerCall(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_HANGUP_CALL:
                    stateLogW("Unexpected hangup event for " + event.device);
                    mSystemInterface.hangupCall(event.device, isVirtualCallInProgress());
                    break;
                default:
                    stateLogE("Unexpected event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processConnectionEvent(Message message, int state, BluetoothDevice device) {
    stateLogD("processConnectionEvent, state=" + state + ", device=" + device);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            if (!mCurrentDevice.equals(device)) {
                stateLogW("Unknown device disconnected" + device);
                break;
            }
            transitionTo(mDisconnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
            stateLogD("RFCOMM connected for " + device);
            if (!mCurrentDevice.equals(device)) {
                stateLogW("Reject connection from unknown device " + device);
                if (!mNativeInterface.disconnectHfp(device)) {
                    stateLogE("Disconnect from " + device + " failed");
                }
            }
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            stateLogD("SLC connected for " + device);
            if (!mCurrentDevice.equals(device)) {
                stateLogW("Reject SLC from unknown device " + device);
                if (!mNativeInterface.disconnectHfp(device)) {
                    stateLogE("Disconnect SLC from " + device + " failed");
                }
                break;
            }
            configAudioParameters(device);
            mSystemInterface.queryPhoneState();
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
            // Ignored
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            stateLogD("Disconnecting for " + device);
            if (mCurrentDevice.equals(device)) {
                stateLogW("Current device disconnecting");
            // ignored, wait for it to be disconnected
            }
            break;
        default:
            stateLogE("Incorrect state " + state);
            break;
    }
}
#method_after
@Override
public void processConnectionEvent(Message message, int state) {
    stateLogD("processConnectionEvent, state=" + state);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogW("Disconnected");
            transitionTo(mDisconnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
            stateLogD("RFCOMM connected");
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            stateLogD("SLC connected");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTING:
            // Ignored
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            stateLogW("Disconnecting");
            break;
        default:
            stateLogE("Incorrect state " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    sendMessageDelayed(CONNECT_TIMEOUT, mCurrentDevice, sConnectTimeoutMillis);
    mConnectingTimestampMillis = Long.MIN_VALUE;
    if (mPrevState instanceof ConnectedBase) {
        // Broadcast audio state change first, if any
        if (mPrevState == mAudioConnecting) {
            broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTING);
        } else if (mPrevState == mAudioOn || mPrevState == mAudioDisconnecting) {
            broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTED);
        }
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTING, BluetoothProfile.STATE_CONNECTED);
    } else {
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    super.enter();
    sendMessageDelayed(CONNECT_TIMEOUT, mDevice, sConnectTimeoutMs);
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            stateLogE("timeout");
            transitionTo(mDisconnected);
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt, event.device);
                    break;
                default:
                    stateLogE("Unexpected event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogE("Unknown device timeout " + device);
                    break;
                }
                stateLogE("timeout");
                transitionTo(mDisconnected);
                break;
            }
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            if (!mDevice.equals(event.device)) {
                stateLogE("Event device does not match currentDevice[" + mDevice + "], event: " + event);
                break;
            }
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt);
                    break;
                default:
                    stateLogE("Unexpected event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processConnectionEvent(Message message, int state, BluetoothDevice device) {
    if (!mCurrentDevice.equals(device)) {
        stateLogW("processConnectionEvent, unknown device " + device);
        return;
    }
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogD("Device disconnected, device=" + device);
            transitionTo(mDisconnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            stateLogD("Device connected, device=" + device);
            transitionTo(mConnected);
            break;
        default:
            stateLogE("Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processConnectionEvent(Message message, int state) {
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogD("processConnectionEvent: Disconnected");
            transitionTo(mDisconnected);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            stateLogD("processConnectionEvent: Connected");
            transitionTo(mConnected);
            break;
        default:
            stateLogE("processConnectionEvent: Bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
        case CONNECT_TIMEOUT:
            stateLogWtfStack("Illegal message in generic handler: " + message);
            break;
        case VOICE_RECOGNITION_START:
            processLocalVrEvent(HeadsetHalConstants.VR_STATE_STARTED, (BluetoothDevice) message.obj);
            break;
        case VOICE_RECOGNITION_STOP:
            processLocalVrEvent(HeadsetHalConstants.VR_STATE_STOPPED, (BluetoothDevice) message.obj);
            break;
        case CALL_STATE_CHANGED:
            processCallState((HeadsetCallState) message.obj, message.arg1 == 1);
            break;
        case DEVICE_STATE_CHANGED:
            processDeviceStateChanged((HeadsetDeviceState) message.obj);
            break;
        case SEND_CCLC_RESPONSE:
            processSendClccResponse((HeadsetClccResponse) message.obj);
            break;
        case CLCC_RSP_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
            }
            break;
        case SEND_VENDOR_SPECIFIC_RESULT_CODE:
            processSendVendorSpecificResultCode((HeadsetVendorSpecificResultCode) message.obj);
            break;
        case DIALING_OUT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (mDialingOut) {
                    mDialingOut = false;
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
            }
            break;
        case VIRTUAL_CALL_START:
            initiateScoUsingVirtualVoiceCall();
            break;
        case VIRTUAL_CALL_STOP:
            terminateScoUsingVirtualVoiceCall();
            break;
        case ENABLE_WBS:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                mNativeInterface.configureWBS(device, WBS_CODEC);
                break;
            }
        case DISABLE_WBS:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                mNativeInterface.configureWBS(device, NBS_CODEC);
                break;
            }
        case BIND_RESPONSE:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                mNativeInterface.bindResponse(device, message.arg1, message.arg2 == 1);
                break;
            }
        case START_VR_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (mWaitingForVoiceRecognition) {
                    device = (BluetoothDevice) message.obj;
                    mWaitingForVoiceRecognition = false;
                    stateLogE("Timeout waiting for voice recognition to start");
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
            }
            break;
        case INTENT_CONNECTION_ACCESS_REPLY:
            handleAccessPermissionResult((Intent) message.obj);
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    processAudioEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    processVrEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_ANSWER_CALL:
                    mSystemInterface.answerCall(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_HANGUP_CALL:
                    mSystemInterface.hangupCall(event.device, mVirtualCallStarted);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    processVolumeEvent(event.valueInt, event.valueInt2, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_DIAL_CALL:
                    processDialCall(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SEND_DTMF:
                    mSystemInterface.sendDtmf(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_NOICE_REDUCTION:
                    processNoiceReductionEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_WBS:
                    processWBSEvent(event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CHLD:
                    processAtChld(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SUBSCRIBER_NUMBER_REQUEST:
                    processSubscriberNumberRequest(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CIND:
                    processAtCind(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_COPS:
                    processAtCops(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CLCC:
                    processAtClcc(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_UNKNOWN_AT:
                    processUnknownAt(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_KEY_PRESSED:
                    processKeyPressed(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIND:
                    processAtBind(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIEV:
                    processAtBiev(event.valueInt, event.valueInt2, event.device);
                    break;
                default:
                    stateLogE("Unknown stack event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
        case CONNECT_TIMEOUT:
            throw new IllegalStateException("Illegal message in generic handler: " + message);
        case VOICE_RECOGNITION_START:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("VOICE_RECOGNITION_START failed " + device + " is not currentDevice");
                    break;
                }
                processLocalVrEvent(HeadsetHalConstants.VR_STATE_STARTED);
                break;
            }
        case VOICE_RECOGNITION_STOP:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("VOICE_RECOGNITION_STOP failed " + device + " is not currentDevice");
                    break;
                }
                processLocalVrEvent(HeadsetHalConstants.VR_STATE_STOPPED);
                break;
            }
        case CALL_STATE_CHANGED:
            processCallState((HeadsetCallState) message.obj, message.arg1 == 1);
            break;
        case DEVICE_STATE_CHANGED:
            mNativeInterface.notifyDeviceStatus(mDevice, (HeadsetDeviceState) message.obj);
            break;
        case SEND_CCLC_RESPONSE:
            processSendClccResponse((HeadsetClccResponse) message.obj);
            break;
        case CLCC_RSP_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("CLCC_RSP_TIMEOUT failed " + device + " is not currentDevice");
                    break;
                }
                mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
            }
            break;
        case SEND_VENDOR_SPECIFIC_RESULT_CODE:
            processSendVendorSpecificResultCode((HeadsetVendorSpecificResultCode) message.obj);
            break;
        case SEND_BSIR:
            mNativeInterface.sendBsir(mDevice, message.arg1 == 1);
            break;
        case DIALING_OUT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("DIALING_OUT_TIMEOUT failed " + device + " is not currentDevice");
                    break;
                }
                if (mDialingOut) {
                    mDialingOut = false;
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
            }
            break;
        case VIRTUAL_CALL_START:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("VIRTUAL_CALL_START failed " + device + " is not currentDevice");
                    break;
                }
                initiateScoUsingVirtualVoiceCall();
                break;
            }
        case VIRTUAL_CALL_STOP:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("VIRTUAL_CALL_STOP failed " + device + " is not currentDevice");
                    break;
                }
                terminateScoUsingVirtualVoiceCall();
                break;
            }
        case START_VR_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("START_VR_TIMEOUT failed " + device + " is not currentDevice");
                    break;
                }
                if (mWaitingForVoiceRecognition) {
                    mWaitingForVoiceRecognition = false;
                    stateLogE("Timeout waiting for voice recognition to start");
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
            }
            break;
        case INTENT_CONNECTION_ACCESS_REPLY:
            handleAccessPermissionResult((Intent) message.obj);
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            if (!mDevice.equals(event.device)) {
                stateLogE("Event device does not match currentDevice[" + mDevice + "], event: " + event);
                break;
            }
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    processAudioEvent(event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    processVrEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_ANSWER_CALL:
                    mSystemInterface.answerCall(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_HANGUP_CALL:
                    mSystemInterface.hangupCall(event.device, mVirtualCallStarted);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    processVolumeEvent(event.valueInt, event.valueInt2);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_DIAL_CALL:
                    processDialCall(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SEND_DTMF:
                    mSystemInterface.sendDtmf(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_NOICE_REDUCTION:
                    processNoiseReductionEvent(event.valueInt == 1);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_WBS:
                    processWBSEvent(event.valueInt);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CHLD:
                    processAtChld(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SUBSCRIBER_NUMBER_REQUEST:
                    processSubscriberNumberRequest(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CIND:
                    processAtCind(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_COPS:
                    processAtCops(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CLCC:
                    processAtClcc(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_UNKNOWN_AT:
                    processUnknownAt(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_KEY_PRESSED:
                    processKeyPressed(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIND:
                    processAtBind(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIEV:
                    processAtBiev(event.valueInt, event.valueInt2, event.device);
                    break;
                default:
                    stateLogE("Unknown stack event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processConnectionEvent(Message message, int state, BluetoothDevice device) {
    stateLogD("processConnectionEvent, state=" + state + ", device=" + device);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
            if (mCurrentDevice.equals(device)) {
                stateLogWtfStack("Same device connect RFCOMM again, should never happen");
                break;
            }
            // reject the connection and stay in Connected state itself
            stateLogI("Incoming Hf rejected. priority=" + mService.getPriority(device) + " bondState=" + device.getBondState());
            if (!mNativeInterface.disconnectHfp(device)) {
                stateLogW("Fail to disconnect " + device);
                break;
            }
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            // Should have been rejected in CONNECTION_STATE_CONNECTED
            if (mCurrentDevice.equals(device)) {
                stateLogWtfStack("Same device connected SLC again, should never happen");
                break;
            }
            // reject the connection and stay in Connected state itself
            stateLogI("Incoming Hf SLC rejected. priority=" + mService.getPriority(device) + " bondState=" + device.getBondState());
            if (!mNativeInterface.disconnectHfp(device)) {
                stateLogW("Fail to disconnect " + device);
                break;
            }
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            if (!mCurrentDevice.equals(device)) {
                stateLogW("Unknown device disconnecting, device=" + device);
                break;
            }
            stateLogI("Current device disconnecting " + mCurrentDevice);
            transitionTo(mDisconnecting);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            if (!mCurrentDevice.equals(device)) {
                stateLogW("Unknown device disconnected " + device);
                break;
            }
            stateLogI("Current device disconnected " + mCurrentDevice);
            transitionTo(mDisconnected);
            break;
        default:
            stateLogE("Connection State Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processConnectionEvent(Message message, int state) {
    stateLogD("processConnectionEvent, state=" + state);
    switch(state) {
        case HeadsetHalConstants.CONNECTION_STATE_CONNECTED:
            stateLogE("processConnectionEvent: RFCOMM connected again, shouldn't happen");
            break;
        case HeadsetHalConstants.CONNECTION_STATE_SLC_CONNECTED:
            stateLogE("processConnectionEvent: SLC connected again, shouldn't happen");
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTING:
            stateLogI("processConnectionEvent: Disconnecting");
            transitionTo(mDisconnecting);
            break;
        case HeadsetHalConstants.CONNECTION_STATE_DISCONNECTED:
            stateLogI("processConnectionEvent: Disconnected");
            transitionTo(mDisconnected);
            break;
        default:
            stateLogE("processConnectionEvent: bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    super.enter();
    if (mConnectingTimestampMillis == Long.MIN_VALUE) {
        mConnectingTimestampMillis = SystemClock.uptimeMillis();
    }
    // start phone state listener here so that the CIND response as part of SLC can be
    // responded to, correctly.
    // listenForPhoneState(boolean) internally handles multiple calls to start listen
    mSystemInterface.getHeadsetPhoneState().listenForPhoneState(true);
    if (mPrevState == mConnecting) {
        // Remove pending connection attempts that were deferred during the pending
        // state. This is to prevent auto connect attempts from disconnecting
        // devices that previously successfully connected.
        removeDeferredMessages(CONNECT);
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTING);
    } else if (mPrevState == mDisconnected) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTED);
    } else if (mPrevState == mDisconnecting) {
        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_DISCONNECTING);
    } else if (mPrevState == mAudioConnecting) {
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTING);
    } else if (mPrevState == mAudioDisconnecting || mPrevState == mAudioOn) {
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTED);
    } else {
        // Above are all possible scenario, crash the stack if otherwise
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    super.enter();
    if (mConnectingTimestampMs == Long.MIN_VALUE) {
        mConnectingTimestampMs = SystemClock.uptimeMillis();
    }
    // start phone state listener here so that the CIND response as part of SLC can be
    // responded to, correctly.
    // listenForPhoneState(boolean) internally handles multiple calls to start listen
    mSystemInterface.getHeadsetPhoneState().listenForPhoneState(true);
    if (mPrevState == mConnecting) {
        // Reset NREC on connect event. Headset will override later
        processNoiseReductionEvent(true);
        // Query phone state for initial setup
        mSystemInterface.queryPhoneState();
        // Remove pending connection attempts that were deferred during the pending
        // state. This is to prevent auto connect attempts from disconnecting
        // devices that previously successfully connected.
        removeDeferredMessages(CONNECT);
    }
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogI("CONNECT, device " + device);
                if (mCurrentDevice.equals(device)) {
                    stateLogW("CONNECT, device " + device + " is already connected");
                    break;
                }
                stateLogD("CONNECT, disconnect current device " + mCurrentDevice);
                if (!mNativeInterface.disconnectHfp(mCurrentDevice)) {
                    stateLogW("CONNECT, Failed to disconnect " + mCurrentDevice);
                    // broadcast immediately as no state transition is involved
                    broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
                    break;
                }
                // Defer connect message to future state
                deferMessage(message);
                transitionTo(mDisconnecting);
            }
            break;
        case DISCONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogD("DISCONNECT from device=" + device);
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("DISCONNECT, device " + device + " not connected");
                    break;
                }
                if (!mNativeInterface.disconnectHfp(device)) {
                    // broadcast immediately as no state transition is involved
                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTED);
                    break;
                }
                transitionTo(mDisconnecting);
            }
            break;
        case CONNECT_AUDIO:
            stateLogD("CONNECT_AUDIO, device=" + mCurrentDevice);
            if (!isScoAcceptable()) {
                stateLogW("CONNECT_AUDIO No Active/Held call, no call setup, and no " + "in-band ringing, not allowing SCO, device=" + mCurrentDevice);
                break;
            }
            if (!mNativeInterface.connectAudio(mCurrentDevice)) {
                stateLogE("Failed to connect SCO audio for " + mCurrentDevice);
                // No state change involved, fire broadcast immediately
                broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
                break;
            }
            transitionTo(mAudioConnecting);
            break;
        case DISCONNECT_AUDIO:
            stateLogD("DISCONNECT_AUDIO, device=" + mCurrentDevice);
            // ignore
            break;
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogW("CONNECT, ignored, device=" + device + ", currentDevice" + mDevice);
                break;
            }
        case DISCONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogD("DISCONNECT from device=" + device);
                if (!mDevice.equals(device)) {
                    stateLogW("DISCONNECT, device " + device + " not connected");
                    break;
                }
                if (!mNativeInterface.disconnectHfp(device)) {
                    // broadcast immediately as no state transition is involved
                    stateLogE("DISCONNECT from " + device + " failed");
                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.STATE_CONNECTED);
                    break;
                }
                transitionTo(mDisconnecting);
            }
            break;
        case CONNECT_AUDIO:
            stateLogD("CONNECT_AUDIO, device=" + mDevice);
            if (!isScoAcceptable()) {
                stateLogW("CONNECT_AUDIO No Active/Held call, no call setup, and no " + "in-band ringing, not allowing SCO, device=" + mDevice);
                break;
            }
            if (!mNativeInterface.connectAudio(mDevice)) {
                stateLogE("Failed to connect SCO audio for " + mDevice);
                // No state change involved, fire broadcast immediately
                broadcastAudioState(mDevice, BluetoothHeadset.STATE_AUDIO_DISCONNECTED, BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
                break;
            }
            transitionTo(mAudioConnecting);
            break;
        case DISCONNECT_AUDIO:
            stateLogD("ignore DISCONNECT_AUDIO, device=" + mDevice);
            // ignore
            break;
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processAudioEvent(int state, BluetoothDevice device) {
    stateLogD("processAudioEvent, state=" + state + ", device=" + device);
    if (!mCurrentDevice.equals(device)) {
        // Crash if audio is connected for unknown device
        stateLogWtfStack("Audio changed on unknown device: " + device);
        return;
    }
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            if (!isScoAcceptable()) {
                stateLogW("Rejecting incoming audio connection from " + device);
                if (!mNativeInterface.disconnectAudio(device)) {
                    stateLogE("Fail to disconnect audio for " + device);
                }
                break;
            }
            stateLogI("Audio connected for " + device);
            transitionTo(mAudioOn);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            if (!isScoAcceptable()) {
                stateLogW("Rejecting incoming pending audio connection from " + device);
                if (!mNativeInterface.disconnectAudio(device)) {
                    stateLogE("Fail to disconnect audio for " + device);
                }
                break;
            }
            stateLogI("Audio connecting for " + device);
            transitionTo(mAudioConnecting);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore
            break;
        default:
            stateLogE("Audio State Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processAudioEvent(int state) {
    stateLogD("processAudioEvent, state=" + state);
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            if (!isScoAcceptable()) {
                stateLogW("processAudioEvent: reject incoming audio connection");
                if (!mNativeInterface.disconnectAudio(mDevice)) {
                    stateLogE("processAudioEvent: failed to disconnect audio");
                }
                break;
            }
            stateLogI("processAudioEvent: audio connected");
            transitionTo(mAudioOn);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            if (!isScoAcceptable()) {
                stateLogW("processAudioEvent: reject incoming pending audio connection");
                if (!mNativeInterface.disconnectAudio(mDevice)) {
                    stateLogE("processAudioEvent: failed to disconnect pending audio");
                }
                break;
            }
            stateLogI("processAudioEvent: audio connecting");
            transitionTo(mAudioConnecting);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore
            break;
        default:
            stateLogE("processAudioEvent: bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    super.enter();
    sendMessageDelayed(CONNECT_TIMEOUT, mCurrentDevice, sConnectTimeoutMillis);
    if (mPrevState == mConnected) {
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_CONNECTING, BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
    } else {
        // Above are all possible scenario, crash the stack if otherwise
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    super.enter();
    sendMessageDelayed(CONNECT_TIMEOUT, mDevice, sConnectTimeoutMs);
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("CONNECT_TIMEOUT for unknown device " + device);
                    break;
                }
                stateLogW("CONNECT_TIMEOUT");
                transitionTo(mConnected);
                break;
            }
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("CONNECT_TIMEOUT for unknown device " + device);
                    break;
                }
                stateLogW("CONNECT_TIMEOUT");
                transitionTo(mConnected);
                break;
            }
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processAudioEvent(int state, BluetoothDevice device) {
    if (!mCurrentDevice.equals(device)) {
        // Crash on unknown device audio state change
        stateLogWtfStack("Audio state changed on unknown device: " + device);
        return;
    }
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogW("Audio connection failed");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            // ignore already in audio connecting
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore, there is no BluetoothHeadset.STATE_AUDIO_DISCONNECTING
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            stateLogI("Audio connected for device " + device);
            transitionTo(mAudioOn);
            break;
        default:
            stateLogE("Audio State Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processAudioEvent(int state) {
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogW("processAudioEvent: audio connection failed");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            // ignore, already in audio connecting state
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore, there is no BluetoothHeadset.STATE_AUDIO_DISCONNECTING
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            stateLogI("processAudioEvent: audio connected");
            transitionTo(mAudioOn);
            break;
        default:
            stateLogE("processAudioEvent: bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    setAudioParameters(mCurrentDevice);
    /*Set proper Audio Paramters.*/
    mSystemInterface.getAudioManager().setBluetoothScoOn(true);
    if (mPrevState == mAudioConnecting) {
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_CONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTING);
    } else if (mPrevState == mConnected) {
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_CONNECTED, BluetoothHeadset.STATE_AUDIO_DISCONNECTED);
    } else if (mPrevState == mAudioDisconnecting) {
        // Firing this intend only to indicate that audio disconnection failed because
        // there is no audio disconnecting state
        broadcastAudioState(mCurrentDevice, BluetoothHeadset.STATE_AUDIO_CONNECTED, BluetoothHeadset.STATE_AUDIO_CONNECTED);
    } else {
        // Above are all possible scenario, crash the stack if otherwise
        stateLogWtfStack("Illegal state transition from " + mPrevState + ", mCurrentDevice=" + mCurrentDevice);
    }
}
#method_after
@Override
public void enter() {
    super.enter();
    removeDeferredMessages(CONNECT_AUDIO);
    // mis-match between native and Java.
    if (!mDevice.equals(mService.getActiveDevice())) {
        mService.setActiveDevice(mDevice);
    }
    setAudioParameters();
    mSystemInterface.getAudioManager().setBluetoothScoOn(true);
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogD("CONNECT, device=" + device);
                if (mCurrentDevice.equals(device)) {
                    stateLogW("CONNECT, device " + device + " is connected");
                    break;
                }
                // When connecting separate device, disconnect the current one first
                // Disconnect audio and then disconnect SLC
                stateLogD("Disconnecting SCO, device=" + mCurrentDevice);
                if (!mNativeInterface.disconnectAudio(mCurrentDevice)) {
                    stateLogE("Disconnect SCO failed, device=" + mCurrentDevice + ", abort connection to " + device);
                    broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTED);
                    break;
                }
                deferMessage(message);
                transitionTo(mAudioDisconnecting);
                break;
            }
        case DISCONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogD("DISCONNECT, device=" + device);
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("DISCONNECT, device " + device + " not connected");
                    break;
                }
                // Disconnect BT SCO first
                if (!mNativeInterface.disconnectAudio(mCurrentDevice)) {
                    stateLogW("DISCONNECT failed, device=" + mCurrentDevice);
                // if disconnect BT SCO failed, transition to mConnected state to force
                // disconnect device
                }
                deferMessage(obtainMessage(DISCONNECT, mCurrentDevice));
                transitionTo(mConnected);
                break;
            }
        case CONNECT_AUDIO:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("CONNECT_AUDIO device is not connected " + device);
                    break;
                }
                stateLogW("CONNECT_AUDIO device auido is already connected " + device);
                break;
            }
        case DISCONNECT_AUDIO:
            if (mNativeInterface.disconnectAudio(mCurrentDevice)) {
                stateLogD("DISCONNECT_AUDIO, device=" + mCurrentDevice);
                transitionTo(mAudioDisconnecting);
            } else {
                stateLogW("DISCONNECT_AUDIO failed, device=" + mCurrentDevice);
            }
            break;
        case VOICE_RECOGNITION_START:
            processLocalVrEvent(HeadsetHalConstants.VR_STATE_STARTED, (BluetoothDevice) message.obj);
            break;
        case VOICE_RECOGNITION_STOP:
            processLocalVrEvent(HeadsetHalConstants.VR_STATE_STOPPED, (BluetoothDevice) message.obj);
            break;
        case INTENT_SCO_VOLUME_CHANGED:
            processIntentScoVolume((Intent) message.obj, mCurrentDevice);
            break;
        case CALL_STATE_CHANGED:
            processCallState((HeadsetCallState) message.obj, message.arg1 == 1);
            break;
        case DEVICE_STATE_CHANGED:
            processDeviceStateChanged((HeadsetDeviceState) message.obj);
            break;
        case SEND_CCLC_RESPONSE:
            processSendClccResponse((HeadsetClccResponse) message.obj);
            break;
        case CLCC_RSP_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
                break;
            }
        case SEND_VENDOR_SPECIFIC_RESULT_CODE:
            processSendVendorSpecificResultCode((HeadsetVendorSpecificResultCode) message.obj);
            break;
        case VIRTUAL_CALL_START:
            initiateScoUsingVirtualVoiceCall();
            break;
        case VIRTUAL_CALL_STOP:
            terminateScoUsingVirtualVoiceCall();
            break;
        case DIALING_OUT_TIMEOUT:
            {
                if (mDialingOut) {
                    BluetoothDevice device = (BluetoothDevice) message.obj;
                    mDialingOut = false;
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
                break;
            }
        case START_VR_TIMEOUT:
            {
                if (mWaitingForVoiceRecognition) {
                    BluetoothDevice device = (BluetoothDevice) message.obj;
                    mWaitingForVoiceRecognition = false;
                    stateLogE("Timeout waiting for voice recognition to start");
                    mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                }
                break;
            }
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(message, event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    processAudioEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VR_STATE_CHANGED:
                    processVrEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_ANSWER_CALL:
                    mSystemInterface.answerCall(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_HANGUP_CALL:
                    mSystemInterface.hangupCall(event.device, mVirtualCallStarted);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_VOLUME_CHANGED:
                    processVolumeEvent(event.valueInt, event.valueInt2, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_DIAL_CALL:
                    processDialCall(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SEND_DTMF:
                    mSystemInterface.sendDtmf(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_NOICE_REDUCTION:
                    processNoiceReductionEvent(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CHLD:
                    processAtChld(event.valueInt, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_SUBSCRIBER_NUMBER_REQUEST:
                    processSubscriberNumberRequest(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CIND:
                    processAtCind(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_COPS:
                    processAtCops(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_AT_CLCC:
                    processAtClcc(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_UNKNOWN_AT:
                    processUnknownAt(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_KEY_PRESSED:
                    processKeyPressed(event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIND:
                    processAtBind(event.valueString, event.device);
                    break;
                case HeadsetStackEvent.EVENT_TYPE_BIEV:
                    processAtBiev(event.valueInt, event.valueInt2, event.device);
                    break;
                default:
                    stateLogE("Unknown stack event: " + event);
                    break;
            }
            break;
        default:
            stateLogE("Unexpected msg " + getMessageName(message.what) + ": " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogW("CONNECT, ignored, device=" + device + ", currentDevice" + mDevice);
                break;
            }
        case DISCONNECT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                stateLogD("DISCONNECT, device=" + device);
                if (!mDevice.equals(device)) {
                    stateLogW("DISCONNECT, device " + device + " not connected");
                    break;
                }
                // Disconnect BT SCO first
                if (!mNativeInterface.disconnectAudio(mDevice)) {
                    stateLogW("DISCONNECT failed, device=" + mDevice);
                // if disconnect BT SCO failed, transition to mConnected state to force
                // disconnect device
                }
                deferMessage(obtainMessage(DISCONNECT, mDevice));
                transitionTo(mAudioDisconnecting);
                break;
            }
        case CONNECT_AUDIO:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("CONNECT_AUDIO device is not connected " + device);
                    break;
                }
                stateLogW("CONNECT_AUDIO device auido is already connected " + device);
                break;
            }
        case DISCONNECT_AUDIO:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("DISCONNECT_AUDIO, failed, device=" + device + ", currentDevice=" + mDevice);
                    break;
                }
                if (mNativeInterface.disconnectAudio(mDevice)) {
                    stateLogD("DISCONNECT_AUDIO, device=" + mDevice);
                    transitionTo(mAudioDisconnecting);
                } else {
                    stateLogW("DISCONNECT_AUDIO failed, device=" + mDevice);
                }
                break;
            }
        case INTENT_SCO_VOLUME_CHANGED:
            processIntentScoVolume((Intent) message.obj, mDevice);
            break;
        case STACK_EVENT:
            HeadsetStackEvent event = (HeadsetStackEvent) message.obj;
            stateLogD("STACK_EVENT: " + event);
            if (!mDevice.equals(event.device)) {
                stateLogE("Event device does not match currentDevice[" + mDevice + "], event: " + event);
                break;
            }
            switch(event.type) {
                case HeadsetStackEvent.EVENT_TYPE_WBS:
                    stateLogE("Cannot change WBS state when audio is connected: " + event);
                    break;
                default:
                    super.processMessage(message);
                    break;
            }
            break;
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processAudioEvent(int state, BluetoothDevice device) {
    if (!mCurrentDevice.equals(device)) {
        stateLogE("Audio changed on unknown device: " + device);
        return;
    }
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogI("Audio disconnected by remote");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            stateLogI("Audio being disconnected by remote");
            transitionTo(mAudioDisconnecting);
            break;
        default:
            stateLogE("Audio State Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processAudioEvent(int state) {
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogI("processAudioEvent: audio disconnected by remote");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            stateLogI("processAudioEvent: audio being disconnected by remote");
            transitionTo(mAudioDisconnecting);
            break;
        default:
            stateLogE("processAudioEvent: bad state: " + state);
            break;
    }
}
#end_block

#method_before
@Override
public void enter() {
    super.enter();
    sendMessageDelayed(CONNECT_TIMEOUT, mCurrentDevice, sConnectTimeoutMillis);
// No audio state change broadcast due to lack of audio disconnecting intent
}
#method_after
@Override
public void enter() {
    super.enter();
    sendMessageDelayed(CONNECT_TIMEOUT, mDevice, sConnectTimeoutMs);
    broadcastStateTransitions();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mCurrentDevice.equals(device)) {
                    stateLogW("CONNECT_TIMEOUT for unknown device " + device);
                    break;
                }
                stateLogW("CONNECT_TIMEOUT");
                transitionTo(mConnected);
                break;
            }
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CONNECT:
        case DISCONNECT:
        case CONNECT_AUDIO:
        case DISCONNECT_AUDIO:
            deferMessage(message);
            break;
        case CONNECT_TIMEOUT:
            {
                BluetoothDevice device = (BluetoothDevice) message.obj;
                if (!mDevice.equals(device)) {
                    stateLogW("CONNECT_TIMEOUT for unknown device " + device);
                    break;
                }
                stateLogW("CONNECT_TIMEOUT");
                transitionTo(mConnected);
                break;
            }
        default:
            return super.processMessage(message);
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void processAudioEvent(int state, BluetoothDevice device) {
    if (!mCurrentDevice.equals(device)) {
        // Crash if audio state change happen for unknown device
        stateLogWtfStack("Audio changed on unknown device: " + device);
        return;
    }
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogI("Audio disconnected for " + device);
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            stateLogW("Audio disconnection failed for " + device);
            transitionTo(mAudioOn);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            // ignore, see if it goes into connected state, otherwise, timeout
            break;
        default:
            stateLogE("Audio State Device: " + device + " bad state: " + state);
            break;
    }
}
#method_after
@Override
public void processAudioEvent(int state) {
    switch(state) {
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTED:
            stateLogI("processAudioEvent: audio disconnected");
            transitionTo(mConnected);
            break;
        case HeadsetHalConstants.AUDIO_STATE_DISCONNECTING:
            // ignore
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTED:
            stateLogW("processAudioEvent: audio disconnection failed");
            transitionTo(mAudioOn);
            break;
        case HeadsetHalConstants.AUDIO_STATE_CONNECTING:
            // ignore, see if it goes into connected state, otherwise, timeout
            break;
        default:
            stateLogE("processAudioEvent: bad state: " + state);
            break;
    }
}
#end_block

#method_before
public synchronized int getConnectionState() {
    IState currentState = getCurrentState();
    if (currentState == mConnecting) {
        return BluetoothProfile.STATE_CONNECTING;
    } else if (currentState instanceof ConnectedBase) {
        return BluetoothProfile.STATE_CONNECTED;
    } else if (currentState == mDisconnecting) {
        return BluetoothProfile.STATE_DISCONNECTING;
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
#method_after
@VisibleForTesting
public synchronized int getConnectionState() {
    HeadsetStateBase state = (HeadsetStateBase) getCurrentState();
    if (state == null) {
        return BluetoothHeadset.STATE_DISCONNECTED;
    }
    return state.getConnectionStateInt();
}
#end_block

#method_before
public synchronized int getAudioState() {
    IState state = getCurrentState();
    if (state == mAudioConnecting) {
        return BluetoothHeadset.STATE_AUDIO_CONNECTING;
    } else if (state == mAudioDisconnecting || state == mAudioOn) {
        return BluetoothHeadset.STATE_AUDIO_CONNECTED;
    } else {
        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
    }
}
#method_after
public synchronized int getAudioState() {
    HeadsetStateBase state = (HeadsetStateBase) getCurrentState();
    if (state == null) {
        return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
    }
    return state.getAudioStateInt();
}
#end_block

#method_before
private void processVrEvent(int state, BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processVrEvent device is null");
        return;
    }
    Log.d(TAG, "processVrEvent: state=" + state + " mVoiceRecognitionStarted: " + mVoiceRecognitionStarted + " mWaitingforVoiceRecognition: " + mWaitingForVoiceRecognition + " isInCall: " + isInCall());
    if (state == HeadsetHalConstants.VR_STATE_STARTED) {
        if (!isVirtualCallInProgress() && !isInCall()) {
            IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
            if (dic != null) {
                try {
                    dic.exitIdle("voice-command");
                } catch (RemoteException e) {
                }
            }
            try {
                mService.startActivity(VOICE_COMMAND_INTENT);
            } catch (ActivityNotFoundException e) {
                mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                return;
            }
            expectVoiceRecognition(device);
        } else {
            // send error response if call is ongoing
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        }
    } else if (state == HeadsetHalConstants.VR_STATE_STOPPED) {
        if (mVoiceRecognitionStarted || mWaitingForVoiceRecognition) {
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            mVoiceRecognitionStarted = false;
            mWaitingForVoiceRecognition = false;
            if (!isInCall() && (getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                mNativeInterface.disconnectAudio(mCurrentDevice);
                mSystemInterface.getAudioManager().setParameters("A2dpSuspended=false");
            }
        } else {
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        }
    } else {
        Log.e(TAG, "Bad Voice Recognition state: " + state);
    }
}
#method_after
private void processVrEvent(int state, BluetoothDevice device) {
    Log.d(TAG, "processVrEvent: state=" + state + " mVoiceRecognitionStarted: " + mVoiceRecognitionStarted + " mWaitingforVoiceRecognition: " + mWaitingForVoiceRecognition + " isInCall: " + mSystemInterface.isInCall());
    if (state == HeadsetHalConstants.VR_STATE_STARTED) {
        if (!isVirtualCallInProgress() && !mSystemInterface.isInCall()) {
            IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
            if (dic != null) {
                try {
                    dic.exitIdle("voice-command");
                } catch (RemoteException e) {
                }
            }
            try {
                mService.startActivity(VOICE_COMMAND_INTENT);
            } catch (ActivityNotFoundException e) {
                mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
                return;
            }
            expectVoiceRecognition(device);
        } else {
            // send error response if call is ongoing
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        }
    } else if (state == HeadsetHalConstants.VR_STATE_STOPPED) {
        if (mVoiceRecognitionStarted || mWaitingForVoiceRecognition) {
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            mVoiceRecognitionStarted = false;
            mWaitingForVoiceRecognition = false;
            if (!mSystemInterface.isInCall() && (getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED)) {
                mNativeInterface.disconnectAudio(mDevice);
                mSystemInterface.getAudioManager().setParameters("A2dpSuspended=false");
            }
        } else {
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        }
    } else {
        Log.e(TAG, "Bad Voice Recognition state: " + state);
    }
}
#end_block

#method_before
private void processLocalVrEvent(int state, BluetoothDevice device1) {
    BluetoothDevice device = null;
    if (state == HeadsetHalConstants.VR_STATE_STARTED) {
        boolean needAudio = true;
        if (mVoiceRecognitionStarted || isInCall()) {
            Log.e(TAG, "Voice recognition started when call is active. isInCall:" + isInCall() + " mVoiceRecognitionStarted: " + mVoiceRecognitionStarted);
            return;
        }
        mVoiceRecognitionStarted = true;
        if (mWaitingForVoiceRecognition) {
            device = getDeviceForMessage(START_VR_TIMEOUT);
            if (device == null) {
                return;
            }
            Log.d(TAG, "Voice recognition started successfully");
            mWaitingForVoiceRecognition = false;
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            removeMessages(START_VR_TIMEOUT);
        } else {
            Log.d(TAG, "Voice recognition started locally");
            needAudio = mNativeInterface.startVoiceRecognition(mCurrentDevice);
            if (mCurrentDevice != null) {
                device = mCurrentDevice;
            }
        }
        if (needAudio && getAudioState() == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            Log.d(TAG, "Initiating audio connection for Voice Recognition");
            // At this stage, we need to be sure that AVDTP is not streaming. This is needed
            // to be compliant with the AV+HFP Whitepaper as we cannot have A2DP in
            // streaming state while a SCO connection is established.
            // This is needed for VoiceDial scenario alone and not for
            // incoming call/outgoing call scenarios as the phone enters MODE_RINGTONE
            // or MODE_IN_CALL which shall automatically suspend the AVDTP stream if needed.
            // Whereas for VoiceDial we want to activate the SCO connection but we are still
            // in MODE_NORMAL and hence the need to explicitly suspend the A2DP stream
            mSystemInterface.getAudioManager().setParameters("A2dpSuspended=true");
            if (device != null) {
                mNativeInterface.connectAudio(device);
            } else {
                Log.e(TAG, "device not found for VR");
            }
        }
        if (mSystemInterface.getVoiceRecognitionWakeLock().isHeld()) {
            mSystemInterface.getVoiceRecognitionWakeLock().release();
        }
    } else {
        Log.d(TAG, "Voice Recognition stopped. mVoiceRecognitionStarted: " + mVoiceRecognitionStarted + " mWaitingForVoiceRecognition: " + mWaitingForVoiceRecognition);
        if (mVoiceRecognitionStarted || mWaitingForVoiceRecognition) {
            mVoiceRecognitionStarted = false;
            mWaitingForVoiceRecognition = false;
            if (mNativeInterface.stopVoiceRecognition(mCurrentDevice) && !isInCall() && getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mNativeInterface.disconnectAudio(mCurrentDevice);
                mSystemInterface.getAudioManager().setParameters("A2dpSuspended=false");
            }
        }
    }
}
#method_after
private void processLocalVrEvent(int state) {
    if (state == HeadsetHalConstants.VR_STATE_STARTED) {
        boolean needAudio = true;
        if (mVoiceRecognitionStarted || mSystemInterface.isInCall()) {
            Log.e(TAG, "Voice recognition started when call is active. isInCall:" + mSystemInterface.isInCall() + " mVoiceRecognitionStarted: " + mVoiceRecognitionStarted);
            return;
        }
        mVoiceRecognitionStarted = true;
        if (mWaitingForVoiceRecognition) {
            if (!hasMessages(START_VR_TIMEOUT)) {
                return;
            }
            Log.d(TAG, "Voice recognition started successfully");
            mWaitingForVoiceRecognition = false;
            mNativeInterface.atResponseCode(mDevice, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            removeMessages(START_VR_TIMEOUT);
        } else {
            Log.d(TAG, "Voice recognition started locally");
            needAudio = mNativeInterface.startVoiceRecognition(mDevice);
        }
        if (needAudio && getAudioState() == BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            Log.d(TAG, "Initiating audio connection for Voice Recognition");
            // At this stage, we need to be sure that AVDTP is not streaming. This is needed
            // to be compliant with the AV+HFP Whitepaper as we cannot have A2DP in
            // streaming state while a SCO connection is established.
            // This is needed for VoiceDial scenario alone and not for
            // incoming call/outgoing call scenarios as the phone enters MODE_RINGTONE
            // or MODE_IN_CALL which shall automatically suspend the AVDTP stream if needed.
            // Whereas for VoiceDial we want to activate the SCO connection but we are still
            // in MODE_NORMAL and hence the need to explicitly suspend the A2DP stream
            mSystemInterface.getAudioManager().setParameters("A2dpSuspended=true");
            mNativeInterface.connectAudio(mDevice);
        }
        if (mSystemInterface.getVoiceRecognitionWakeLock().isHeld()) {
            mSystemInterface.getVoiceRecognitionWakeLock().release();
        }
    } else {
        Log.d(TAG, "Voice Recognition stopped. mVoiceRecognitionStarted: " + mVoiceRecognitionStarted + " mWaitingForVoiceRecognition: " + mWaitingForVoiceRecognition);
        if (mVoiceRecognitionStarted || mWaitingForVoiceRecognition) {
            mVoiceRecognitionStarted = false;
            mWaitingForVoiceRecognition = false;
            if (mNativeInterface.stopVoiceRecognition(mDevice) && !mSystemInterface.isInCall() && getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
                mNativeInterface.disconnectAudio(mDevice);
                mSystemInterface.getAudioManager().setParameters("A2dpSuspended=false");
            }
        }
    }
}
#end_block

#method_before
private synchronized void expectVoiceRecognition(BluetoothDevice device) {
    mWaitingForVoiceRecognition = true;
    Message m = obtainMessage(START_VR_TIMEOUT);
    m.obj = getMatchingDevice(device);
    sendMessageDelayed(m, START_VR_TIMEOUT_MILLIS);
    if (!mSystemInterface.getVoiceRecognitionWakeLock().isHeld()) {
        mSystemInterface.getVoiceRecognitionWakeLock().acquire(START_VR_TIMEOUT_MILLIS);
    }
}
#method_after
private synchronized void expectVoiceRecognition(BluetoothDevice device) {
    mWaitingForVoiceRecognition = true;
    mService.setActiveDevice(device);
    sendMessageDelayed(START_VR_TIMEOUT, device, START_VR_TIMEOUT_MS);
    if (!mSystemInterface.getVoiceRecognitionWakeLock().isHeld()) {
        mSystemInterface.getVoiceRecognitionWakeLock().acquire(START_VR_TIMEOUT_MS);
    }
}
#end_block

#method_before
private void setAudioParameters(BluetoothDevice device) {
    // 1. update nrec value
    // 2. update headset name
    int mNrec = 0;
    if (!mAudioParams.isEmpty()) {
        mNrec = mAudioParams.get("NREC");
    } else {
        Log.e(TAG, "setAudioParameters: audioParam not found");
    }
    if (mNrec == 1) {
        Log.d(TAG, "Set NREC: 1 for device:" + device);
        mSystemInterface.getAudioManager().setParameters(HEADSET_NREC + "=on");
    } else {
        Log.d(TAG, "Set NREC: 0 for device:" + device);
        mSystemInterface.getAudioManager().setParameters(HEADSET_NREC + "=off");
    }
    mSystemInterface.getAudioManager().setParameters(HEADSET_NAME + "=" + getCurrentDeviceName(device));
}
#method_after
private void setAudioParameters() {
    String keyValuePairs = String.join(";", new String[] { HEADSET_NAME + "=" + getCurrentDeviceName(), HEADSET_NREC + "=" + mAudioParams.getOrDefault(HEADSET_NREC, HEADSET_AUDIO_FEATURE_OFF), HEADSET_WBS + "=" + mAudioParams.getOrDefault(HEADSET_WBS, HEADSET_AUDIO_FEATURE_OFF) });
    Log.i(TAG, "setAudioParameters for " + mDevice + ": " + keyValuePairs);
    mSystemInterface.getAudioManager().setParameters(keyValuePairs);
}
#end_block

#method_before
private String parseUnknownAt(String atString) {
    StringBuilder atCommand = new StringBuilder(atString.length());
    String result = null;
    for (int i = 0; i < atString.length(); i++) {
        char c = atString.charAt(i);
        if (c == '"') {
            // search for closing "
            int j = atString.indexOf('"', i + 1);
            if (j == -1) {
                // unmatched ", insert one.
                atCommand.append(atString.substring(i, atString.length()));
                atCommand.append('"');
                break;
            }
            atCommand.append(atString.substring(i, j + 1));
            i = j;
        } else if (c != ' ') {
            atCommand.append(Character.toUpperCase(c));
        }
    }
    result = atCommand.toString();
    return result;
}
#method_after
private String parseUnknownAt(String atString) {
    StringBuilder atCommand = new StringBuilder(atString.length());
    for (int i = 0; i < atString.length(); i++) {
        char c = atString.charAt(i);
        if (c == '"') {
            // search for closing "
            int j = atString.indexOf('"', i + 1);
            if (j == -1) {
                // unmatched ", insert one.
                atCommand.append(atString.substring(i, atString.length()));
                atCommand.append('"');
                break;
            }
            atCommand.append(atString.substring(i, j + 1));
            i = j;
        } else if (c != ' ') {
            atCommand.append(Character.toUpperCase(c));
        }
    }
    return atCommand.toString();
}
#end_block

#method_before
private synchronized boolean initiateScoUsingVirtualVoiceCall() {
    log("initiateScoUsingVirtualVoiceCall: Received");
    // 1. Check if the SCO state is idle
    if (isInCall() || mVoiceRecognitionStarted) {
        Log.e(TAG, "initiateScoUsingVirtualVoiceCall: Call in progress.");
        return false;
    }
    // 2. Send virtual phone state changed to initialize SCO
    processCallState(new HeadsetCallState(0, 0, HeadsetHalConstants.CALL_STATE_DIALING, "", 0), true);
    processCallState(new HeadsetCallState(0, 0, HeadsetHalConstants.CALL_STATE_ALERTING, "", 0), true);
    processCallState(new HeadsetCallState(1, 0, HeadsetHalConstants.CALL_STATE_IDLE, "", 0), true);
    setVirtualCallInProgress(true);
    // Done
    log("initiateScoUsingVirtualVoiceCall: Done");
    return true;
}
#method_after
// NOTE: Currently the VirtualCall API does not support handling of call transfers. If it is
// initiated from the handsfree device, HeadsetStateMachine will end the virtual call by
private boolean initiateScoUsingVirtualVoiceCall() {
    log("initiateScoUsingVirtualVoiceCall: Received");
    // 1. Check if the SCO state is idle
    if (mSystemInterface.isInCall() || mVoiceRecognitionStarted) {
        Log.e(TAG, "initiateScoUsingVirtualVoiceCall: Call in progress.");
        return false;
    }
    // 2. Send virtual phone state changed to initialize SCO
    processCallState(new HeadsetCallState(0, 0, HeadsetHalConstants.CALL_STATE_DIALING, "", 0), true);
    processCallState(new HeadsetCallState(0, 0, HeadsetHalConstants.CALL_STATE_ALERTING, "", 0), true);
    processCallState(new HeadsetCallState(1, 0, HeadsetHalConstants.CALL_STATE_IDLE, "", 0), true);
    setVirtualCallInProgress(true);
    // Done
    log("initiateScoUsingVirtualVoiceCall: Done");
    return true;
}
#end_block

#method_before
private void processDialCall(String number, BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processDialCall device is null");
        return;
    }
    String dialNumber;
    if (mDialingOut) {
        log("processDialCall, already dialling");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        return;
    }
    if ((number == null) || (number.length() == 0)) {
        dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processDialCall, last dial number null");
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
    } else if (number.charAt(0) == '>') {
        // Just dial last number for now
        if (number.startsWith(">9999")) {
            // for PTS test
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
        log("processDialCall, memory dial do last dial for now");
        dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processDialCall, last dial number null");
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
    } else {
        // Remove trailing ';'
        if (number.charAt(number.length() - 1) == ';') {
            number = number.substring(0, number.length() - 1);
        }
        dialNumber = PhoneNumberUtils.convertPreDial(number);
    }
    // Check for virtual call to terminate before sending Call Intent
    terminateScoUsingVirtualVoiceCall();
    Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, Uri.fromParts(SCHEME_TEL, dialNumber, null));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mService.startActivity(intent);
    // TODO(BT) continue send OK reults code after call starts
    // hold wait lock, start a timer, set wait call flag
    // Get call started indication from bluetooth phone
    mDialingOut = true;
    Message m = obtainMessage(DIALING_OUT_TIMEOUT);
    m.obj = getMatchingDevice(device);
    sendMessageDelayed(m, DIALING_OUT_TIMEOUT_MILLIS);
}
#method_after
private void processDialCall(String number, BluetoothDevice device) {
    String dialNumber;
    if (mDialingOut) {
        log("processDialCall, already dialling");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
        return;
    }
    if ((number == null) || (number.length() == 0)) {
        dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processDialCall, last dial number null");
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
    } else if (number.charAt(0) == '>') {
        // Just dial last number for now
        if (number.startsWith(">9999")) {
            // for PTS test
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
        log("processDialCall, memory dial do last dial for now");
        dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processDialCall, last dial number null");
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
            return;
        }
    } else {
        // Remove trailing ';'
        if (number.charAt(number.length() - 1) == ';') {
            number = number.substring(0, number.length() - 1);
        }
        dialNumber = PhoneNumberUtils.convertPreDial(number);
    }
    // Check for virtual call to terminate before sending Call Intent
    terminateScoUsingVirtualVoiceCall();
    mService.setActiveDevice(mDevice);
    Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, Uri.fromParts(SCHEME_TEL, dialNumber, null));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    mService.startActivity(intent);
    // TODO(BT) continue send OK reults code after call starts
    // hold wait lock, start a timer, set wait call flag
    // Get call started indication from bluetooth phone
    mDialingOut = true;
    sendMessageDelayed(DIALING_OUT_TIMEOUT, device, DIALING_OUT_TIMEOUT_MS);
}
#end_block

#method_before
private void processVolumeEvent(int volumeType, int volume, BluetoothDevice device) {
    if (!mCurrentDevice.equals(device)) {
        Log.w(TAG, "processVolumeEvent, ignored for unknown device " + device);
        return;
    }
    // When there is an active call, only device in audio focus can change SCO volume
    if (mSystemInterface.getHeadsetPhoneState().isInCall() && getAudioState() != BluetoothHeadset.STATE_AUDIO_CONNECTED) {
        Log.w(TAG, "processVolumeEvent, ignored because " + mCurrentDevice + " does not have audio focus");
    }
    if (volumeType == HeadsetHalConstants.VOLUME_TYPE_SPK) {
        mSpeakerVolume = volume;
        int flag = (getCurrentState() == mAudioOn) ? AudioManager.FLAG_SHOW_UI : 0;
        mSystemInterface.getAudioManager().setStreamVolume(AudioManager.STREAM_BLUETOOTH_SCO, volume, flag);
    } else if (volumeType == HeadsetHalConstants.VOLUME_TYPE_MIC) {
        // Not used currently
        mMicVolume = volume;
    } else {
        Log.e(TAG, "Bad voluem type: " + volumeType);
    }
}
#method_after
private void processVolumeEvent(int volumeType, int volume) {
    // When there is an active call, only device in audio focus can change SCO volume
    if (mSystemInterface.getHeadsetPhoneState().isInCall() && getAudioState() != BluetoothHeadset.STATE_AUDIO_CONNECTED) {
        Log.w(TAG, "processVolumeEvent, ignored because " + mDevice + " does not have audio focus");
    }
    if (volumeType == HeadsetHalConstants.VOLUME_TYPE_SPK) {
        mSpeakerVolume = volume;
        int flag = (getCurrentState() == mAudioOn) ? AudioManager.FLAG_SHOW_UI : 0;
        mSystemInterface.getAudioManager().setStreamVolume(AudioManager.STREAM_BLUETOOTH_SCO, volume, flag);
    } else if (volumeType == HeadsetHalConstants.VOLUME_TYPE_MIC) {
        // Not used currently
        mMicVolume = volume;
    } else {
        Log.e(TAG, "Bad voluem type: " + volumeType);
    }
}
#end_block

#method_before
private void processCallState(HeadsetCallState callState, boolean isVirtualCall) {
    mSystemInterface.getHeadsetPhoneState().setNumActiveCall(callState.mNumActive);
    mSystemInterface.getHeadsetPhoneState().setNumHeldCall(callState.mNumHeld);
    mSystemInterface.getHeadsetPhoneState().setCallState(callState.mCallState);
    if (mDialingOut) {
        if (callState.mCallState == HeadsetHalConstants.CALL_STATE_DIALING) {
            BluetoothDevice device = getDeviceForMessage(DIALING_OUT_TIMEOUT);
            if (device == null) {
                return;
            }
            mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            removeMessages(DIALING_OUT_TIMEOUT);
        } else if (callState.mCallState == HeadsetHalConstants.CALL_STATE_ACTIVE || callState.mCallState == HeadsetHalConstants.CALL_STATE_IDLE) {
            mDialingOut = false;
        }
    }
    log("mNumActive: " + callState.mNumActive + " mNumHeld: " + callState.mNumHeld + " mCallState: " + callState.mCallState);
    log("mNumber: " + callState.mNumber + " mType: " + callState.mType);
    if (isVirtualCall) {
        // virtual call state update
        if (getCurrentState() != mDisconnected) {
            mNativeInterface.phoneStateChange(callState);
        }
    } else {
        // stop virtual voice call if there is a CSV call ongoing
        if (callState.mNumActive > 0 || callState.mNumHeld > 0 || callState.mCallState != HeadsetHalConstants.CALL_STATE_IDLE) {
            terminateScoUsingVirtualVoiceCall();
        }
        // SCO for VOIP call is not terminated via SDK API call.
        if (mSystemInterface.getHeadsetPhoneState().getCallState() != callState.mCallState) {
            mSystemInterface.getHeadsetPhoneState().setCallState(callState.mCallState);
        }
        // let virtual call continue and skip phone state update
        if (!isVirtualCallInProgress()) {
            if (getCurrentState() != mDisconnected) {
                mNativeInterface.phoneStateChange(callState);
            }
        }
    }
}
#method_after
private void processCallState(HeadsetCallState callState, boolean isVirtualCall) {
    mSystemInterface.getHeadsetPhoneState().setNumActiveCall(callState.mNumActive);
    mSystemInterface.getHeadsetPhoneState().setNumHeldCall(callState.mNumHeld);
    mSystemInterface.getHeadsetPhoneState().setCallState(callState.mCallState);
    if (mDialingOut) {
        if (callState.mCallState == HeadsetHalConstants.CALL_STATE_DIALING) {
            if (!hasMessages(DIALING_OUT_TIMEOUT)) {
                return;
            }
            mService.setActiveDevice(mDevice);
            mNativeInterface.atResponseCode(mDevice, HeadsetHalConstants.AT_RESPONSE_OK, 0);
            removeMessages(DIALING_OUT_TIMEOUT);
        } else if (callState.mCallState == HeadsetHalConstants.CALL_STATE_ACTIVE || callState.mCallState == HeadsetHalConstants.CALL_STATE_IDLE) {
            mDialingOut = false;
        }
    }
    log("processCallState: mNumActive: " + callState.mNumActive + " mNumHeld: " + callState.mNumHeld + " mCallState: " + callState.mCallState);
    log("processCallState: mNumber: " + callState.mNumber + " mType: " + callState.mType);
    if (isVirtualCall) {
        // virtual call state update
        if (getCurrentState() != mDisconnected) {
            mNativeInterface.phoneStateChange(mDevice, callState);
        }
    } else {
        // stop virtual voice call if there is a CSV call ongoing
        if (callState.mNumActive > 0 || callState.mNumHeld > 0 || callState.mCallState != HeadsetHalConstants.CALL_STATE_IDLE) {
            terminateScoUsingVirtualVoiceCall();
        }
        // SCO for VOIP call is not terminated via SDK API call.
        if (mSystemInterface.getHeadsetPhoneState().getCallState() != callState.mCallState) {
            mSystemInterface.getHeadsetPhoneState().setCallState(callState.mCallState);
        }
        // let virtual call continue and skip phone state update
        if (!isVirtualCallInProgress()) {
            if (getCurrentState() != mDisconnected) {
                mNativeInterface.phoneStateChange(mDevice, callState);
            }
        }
    }
}
#end_block

#method_before
// 2 - WBS on
private void processWBSEvent(int enable) {
    if (enable == 2) {
        Log.d(TAG, "AudioManager.setParameters: bt_wbs=on, device=");
        mSystemInterface.getAudioManager().setParameters(HEADSET_WBS + "=on");
    } else {
        Log.d(TAG, "AudioManager.setParameters: bt_wbs=off, enable=" + enable);
        mSystemInterface.getAudioManager().setParameters(HEADSET_WBS + "=off");
    }
}
#method_after
private void processWBSEvent(int wbsConfig) {
    String prevWbs = mAudioParams.getOrDefault(HEADSET_WBS, HEADSET_AUDIO_FEATURE_OFF);
    switch(wbsConfig) {
        case HeadsetHalConstants.BTHF_WBS_YES:
            mAudioParams.put(HEADSET_WBS, HEADSET_AUDIO_FEATURE_ON);
            break;
        case HeadsetHalConstants.BTHF_WBS_NO:
        case HeadsetHalConstants.BTHF_WBS_NONE:
            mAudioParams.put(HEADSET_WBS, HEADSET_AUDIO_FEATURE_OFF);
            break;
        default:
            Log.e(TAG, "processWBSEvent: unknown wbsConfig " + wbsConfig);
            return;
    }
    log("processWBSEvent: " + HEADSET_NREC + " change " + prevWbs + " -> " + mAudioParams.get(HEADSET_WBS));
}
#end_block

#method_before
private void processAtChld(int chld, BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processAtChld device is null");
        return;
    }
    if (mSystemInterface.processChld(chld)) {
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
    } else {
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
    }
}
#method_after
private void processAtChld(int chld, BluetoothDevice device) {
    if (mSystemInterface.processChld(chld)) {
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
    } else {
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
    }
}
#end_block

#method_before
private void processSubscriberNumberRequest(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processSubscriberNumberRequest device is null");
        return;
    }
    String number = mSystemInterface.getSubscriberNumber();
    if (number != null) {
        mNativeInterface.atResponseString(device, "+CNUM: ,\"" + number + "\"," + PhoneNumberUtils.toaFromString(number) + ",,4");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
    } else {
        Log.e(TAG, "getSubscriberNumber returns null");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
    }
}
#method_after
private void processSubscriberNumberRequest(BluetoothDevice device) {
    String number = mSystemInterface.getSubscriberNumber();
    if (number != null) {
        mNativeInterface.atResponseString(device, "+CNUM: ,\"" + number + "\"," + PhoneNumberUtils.toaFromString(number) + ",,4");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_OK, 0);
    } else {
        Log.e(TAG, "getSubscriberNumber returns null");
        mNativeInterface.atResponseCode(device, HeadsetHalConstants.AT_RESPONSE_ERROR, 0);
    }
}
#end_block

#method_before
private void processAtCind(BluetoothDevice device) {
    int call, callSetup;
    if (device == null) {
        Log.w(TAG, "processAtCind device is null");
        return;
    }
    final HeadsetPhoneState phoneState = mSystemInterface.getHeadsetPhoneState();
    /* Handsfree carkits expect that +CIND is properly responded to
         Hence we ensure that a proper response is sent
         for the virtual call too.*/
    if (isVirtualCallInProgress()) {
        call = 1;
        callSetup = 0;
    } else {
        // regular phone call
        call = phoneState.getNumActiveCall();
        callSetup = phoneState.getNumHeldCall();
    }
    mNativeInterface.cindResponse(device, phoneState.getCindService(), call, callSetup, phoneState.getCallState(), phoneState.getCindSignal(), phoneState.getCindRoam(), phoneState.getCindBatteryCharge());
}
#method_after
private void processAtCind(BluetoothDevice device) {
    int call, callSetup;
    final HeadsetPhoneState phoneState = mSystemInterface.getHeadsetPhoneState();
    /* Handsfree carkits expect that +CIND is properly responded to
         Hence we ensure that a proper response is sent
         for the virtual call too.*/
    if (isVirtualCallInProgress()) {
        call = 1;
        callSetup = 0;
    } else {
        // regular phone call
        call = phoneState.getNumActiveCall();
        callSetup = phoneState.getNumHeldCall();
    }
    mNativeInterface.cindResponse(device, phoneState.getCindService(), call, callSetup, phoneState.getCallState(), phoneState.getCindSignal(), phoneState.getCindRoam(), phoneState.getCindBatteryCharge());
}
#end_block

#method_before
private void processAtCops(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processAtCops device is null");
        return;
    }
    String operatorName = mSystemInterface.getNetworkOperator();
    if (operatorName == null) {
        operatorName = "";
    }
    mNativeInterface.copsResponse(device, operatorName);
}
#method_after
private void processAtCops(BluetoothDevice device) {
    String operatorName = mSystemInterface.getNetworkOperator();
    if (operatorName == null) {
        operatorName = "";
    }
    mNativeInterface.copsResponse(device, operatorName);
}
#end_block

#method_before
private void processAtClcc(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processAtClcc device is null");
        return;
    }
    if (isVirtualCallInProgress()) {
        // In virtual call, send our phone number instead of remote phone number
        String phoneNumber = mSystemInterface.getSubscriberNumber();
        if (phoneNumber == null) {
            phoneNumber = "";
        }
        int type = PhoneNumberUtils.toaFromString(phoneNumber);
        mNativeInterface.clccResponse(device, 1, 0, 0, 0, false, phoneNumber, type);
        mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
    } else {
        // In Telecom call, ask Telecom to send send remote phone number
        if (!mSystemInterface.listCurrentCalls()) {
            Log.e(TAG, "processAtClcc: failed to list current calls for " + device);
            mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
        } else {
            Message m = obtainMessage(CLCC_RSP_TIMEOUT);
            m.obj = getMatchingDevice(device);
            sendMessageDelayed(m, CLCC_RSP_TIMEOUT_MILLIS);
        }
    }
}
#method_after
private void processAtClcc(BluetoothDevice device) {
    if (isVirtualCallInProgress()) {
        // In virtual call, send our phone number instead of remote phone number
        String phoneNumber = mSystemInterface.getSubscriberNumber();
        if (phoneNumber == null) {
            phoneNumber = "";
        }
        int type = PhoneNumberUtils.toaFromString(phoneNumber);
        mNativeInterface.clccResponse(device, 1, 0, 0, 0, false, phoneNumber, type);
        mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
    } else {
        // In Telecom call, ask Telecom to send send remote phone number
        if (!mSystemInterface.listCurrentCalls()) {
            Log.e(TAG, "processAtClcc: failed to list current calls for " + device);
            mNativeInterface.clccResponse(device, 0, 0, 0, 0, false, "", 0);
        } else {
            sendMessageDelayed(CLCC_RSP_TIMEOUT, device, CLCC_RSP_TIMEOUT_MS);
        }
    }
}
#end_block

#method_before
private void processKeyPressed(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "processKeyPressed device is null");
        return;
    }
    final HeadsetPhoneState phoneState = mSystemInterface.getHeadsetPhoneState();
    if (phoneState.getCallState() == HeadsetHalConstants.CALL_STATE_INCOMING) {
        mSystemInterface.answerCall(device);
    } else if (phoneState.getNumActiveCall() > 0) {
        if (getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            mNativeInterface.connectAudio(mCurrentDevice);
        } else {
            mSystemInterface.hangupCall(device, false);
        }
    } else {
        String dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processKeyPressed, last dial number null");
            return;
        }
        Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, Uri.fromParts(SCHEME_TEL, dialNumber, null));
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mService.startActivity(intent);
    }
}
#method_after
private void processKeyPressed(BluetoothDevice device) {
    final HeadsetPhoneState phoneState = mSystemInterface.getHeadsetPhoneState();
    if (phoneState.getCallState() == HeadsetHalConstants.CALL_STATE_INCOMING) {
        mSystemInterface.answerCall(device);
    } else if (phoneState.getNumActiveCall() > 0) {
        if (getAudioState() != BluetoothHeadset.STATE_AUDIO_DISCONNECTED) {
            mService.setActiveDevice(mDevice);
            mNativeInterface.connectAudio(mDevice);
        } else {
            mSystemInterface.hangupCall(device, false);
        }
    } else {
        String dialNumber = mPhonebook.getLastDialledNumber();
        if (dialNumber == null) {
            log("processKeyPressed, last dial number null");
            return;
        }
        mService.setActiveDevice(mDevice);
        Intent intent = new Intent(Intent.ACTION_CALL_PRIVILEGED, Uri.fromParts(SCHEME_TEL, dialNumber, null));
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mService.startActivity(intent);
    }
}
#end_block

#method_before
private void processSendClccResponse(HeadsetClccResponse clcc) {
    BluetoothDevice device = getDeviceForMessage(CLCC_RSP_TIMEOUT);
    if (device == null) {
        return;
    }
    if (clcc.mIndex == 0) {
        removeMessages(CLCC_RSP_TIMEOUT);
    }
    mNativeInterface.clccResponse(device, clcc.mIndex, clcc.mDirection, clcc.mStatus, clcc.mMode, clcc.mMpty, clcc.mNumber, clcc.mType);
}
#method_after
private void processSendClccResponse(HeadsetClccResponse clcc) {
    if (!hasMessages(CLCC_RSP_TIMEOUT)) {
        return;
    }
    if (clcc.mIndex == 0) {
        removeMessages(CLCC_RSP_TIMEOUT);
    }
    mNativeInterface.clccResponse(mDevice, clcc.mIndex, clcc.mDirection, clcc.mStatus, clcc.mMode, clcc.mMpty, clcc.mNumber, clcc.mType);
}
#end_block

#method_before
private String getCurrentDeviceName(BluetoothDevice device) {
    String defaultName = "<unknown>";
    if (device == null) {
        return defaultName;
    }
    String deviceName = device.getName();
    if (deviceName == null) {
        return defaultName;
    }
    return deviceName;
}
#method_after
private String getCurrentDeviceName() {
    String deviceName = mDevice.getName();
    if (deviceName == null) {
        return "<unknown>";
    }
    return deviceName;
}
#end_block

#method_before
// Accept incoming SCO only when there is in-band ringing, incoming call,
private boolean isScoAcceptable() {
    if (mService.getForceScoAudio()) {
        return true;
    }
    return mAudioRouteAllowed && (mVoiceRecognitionStarted || isInCall() || (BluetoothHeadset.isInbandRingingSupported(mService) && isRinging()));
}
#method_after
// Accept incoming SCO only when there is in-band ringing, incoming call,
private boolean isScoAcceptable() {
    if (mService.getForceScoAudio()) {
        return true;
    }
    BluetoothDevice activeDevice = mService.getActiveDevice();
    if (!mDevice.equals(activeDevice)) {
        Log.w(TAG, "isScoAcceptable: rejected SCO since " + mDevice + " is not the current active device " + activeDevice);
        return false;
    }
    if (!mService.getAudioRouteAllowed()) {
        Log.w(TAG, "isScoAcceptabl: rejected SCO since audio route is not allowed");
        return false;
    }
    if (mSystemInterface.isInCall() || mVoiceRecognitionStarted) {
        return true;
    }
    if (mSystemInterface.isRinging() && mService.isInbandRingingEnabled()) {
        return true;
    }
    Log.w(TAG, "isScoAcceptable: rejected SCO, inCall=" + mSystemInterface.isInCall() + ", voiceRecognition=" + mVoiceRecognitionStarted + ", ringing=" + mSystemInterface.isRinging() + ", inbandRinging=" + mService.isInbandRingingEnabled());
    return false;
}
#end_block

#method_before
private void handleAccessPermissionResult(Intent intent) {
    log("handleAccessPermissionResult");
    BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    if (!mPhonebook.getCheckingAccessPermission()) {
        return;
    }
    int atCommandResult = 0;
    int atCommandErrorCode = 0;
    // has set mCheckingAccessPermission to false
    if (intent.getAction().equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                mCurrentDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
            }
            atCommandResult = mPhonebook.processCpbrCommand(device);
        } else {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                mCurrentDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
            }
        }
    }
    mPhonebook.setCpbrIndex(-1);
    mPhonebook.setCheckingAccessPermission(false);
    if (atCommandResult >= 0) {
        mNativeInterface.atResponseCode(device, atCommandResult, atCommandErrorCode);
    } else {
        log("handleAccessPermissionResult - RESULT_NONE");
    }
}
#method_after
private void handleAccessPermissionResult(Intent intent) {
    log("handleAccessPermissionResult");
    BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    if (!mPhonebook.getCheckingAccessPermission()) {
        return;
    }
    int atCommandResult = 0;
    int atCommandErrorCode = 0;
    // has set mCheckingAccessPermission to false
    if (intent.getAction().equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_REPLY)) {
        if (intent.getIntExtra(BluetoothDevice.EXTRA_CONNECTION_ACCESS_RESULT, BluetoothDevice.CONNECTION_ACCESS_NO) == BluetoothDevice.CONNECTION_ACCESS_YES) {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_ALLOWED);
            }
            atCommandResult = mPhonebook.processCpbrCommand(device);
        } else {
            if (intent.getBooleanExtra(BluetoothDevice.EXTRA_ALWAYS_ALLOWED, false)) {
                mDevice.setPhonebookAccessPermission(BluetoothDevice.ACCESS_REJECTED);
            }
        }
    }
    mPhonebook.setCpbrIndex(-1);
    mPhonebook.setCheckingAccessPermission(false);
    if (atCommandResult >= 0) {
        mNativeInterface.atResponseCode(device, atCommandResult, atCommandErrorCode);
    } else {
        log("handleAccessPermissionResult - RESULT_NONE");
    }
}
#end_block

#method_before
static String getMessageName(int what) {
    switch(what) {
        case CONNECT:
            return "CONNECT";
        case DISCONNECT:
            return "DISCONNECT";
        case CONNECT_AUDIO:
            return "CONNECT_AUDIO";
        case DISCONNECT_AUDIO:
            return "DISCONNECT_AUDIO";
        case VOICE_RECOGNITION_START:
            return "VOICE_RECOGNITION_START";
        case VOICE_RECOGNITION_STOP:
            return "VOICE_RECOGNITION_STOP";
        case INTENT_SCO_VOLUME_CHANGED:
            return "INTENT_SCO_VOLUME_CHANGED";
        case INTENT_CONNECTION_ACCESS_REPLY:
            return "INTENT_CONNECTION_ACCESS_REPLY";
        case CALL_STATE_CHANGED:
            return "CALL_STATE_CHANGED";
        case DEVICE_STATE_CHANGED:
            return "DEVICE_STATE_CHANGED";
        case SEND_CCLC_RESPONSE:
            return "SEND_CCLC_RESPONSE";
        case SEND_VENDOR_SPECIFIC_RESULT_CODE:
            return "SEND_VENDOR_SPECIFIC_RESULT_CODE";
        case VIRTUAL_CALL_START:
            return "VIRTUAL_CALL_START";
        case VIRTUAL_CALL_STOP:
            return "VIRTUAL_CALL_STOP";
        case ENABLE_WBS:
            return "ENABLE_WBS";
        case DISABLE_WBS:
            return "DISABLE_WBS";
        case BIND_RESPONSE:
            return "BIND_RESPONSE";
        case STACK_EVENT:
            return "STACK_EVENT";
        case DIALING_OUT_TIMEOUT:
            return "DIALING_OUT_TIMEOUT";
        case START_VR_TIMEOUT:
            return "START_VR_TIMEOUT";
        case CLCC_RSP_TIMEOUT:
            return "CLCC_RSP_TIMEOUT";
        case CONNECT_TIMEOUT:
            return "CONNECT_TIMEOUT";
        default:
            return "UNKNOWN";
    }
}
#method_after
private static String getMessageName(int what) {
    switch(what) {
        case CONNECT:
            return "CONNECT";
        case DISCONNECT:
            return "DISCONNECT";
        case CONNECT_AUDIO:
            return "CONNECT_AUDIO";
        case DISCONNECT_AUDIO:
            return "DISCONNECT_AUDIO";
        case VOICE_RECOGNITION_START:
            return "VOICE_RECOGNITION_START";
        case VOICE_RECOGNITION_STOP:
            return "VOICE_RECOGNITION_STOP";
        case INTENT_SCO_VOLUME_CHANGED:
            return "INTENT_SCO_VOLUME_CHANGED";
        case INTENT_CONNECTION_ACCESS_REPLY:
            return "INTENT_CONNECTION_ACCESS_REPLY";
        case CALL_STATE_CHANGED:
            return "CALL_STATE_CHANGED";
        case DEVICE_STATE_CHANGED:
            return "DEVICE_STATE_CHANGED";
        case SEND_CCLC_RESPONSE:
            return "SEND_CCLC_RESPONSE";
        case SEND_VENDOR_SPECIFIC_RESULT_CODE:
            return "SEND_VENDOR_SPECIFIC_RESULT_CODE";
        case VIRTUAL_CALL_START:
            return "VIRTUAL_CALL_START";
        case VIRTUAL_CALL_STOP:
            return "VIRTUAL_CALL_STOP";
        case STACK_EVENT:
            return "STACK_EVENT";
        case DIALING_OUT_TIMEOUT:
            return "DIALING_OUT_TIMEOUT";
        case START_VR_TIMEOUT:
            return "START_VR_TIMEOUT";
        case CLCC_RSP_TIMEOUT:
            return "CLCC_RSP_TIMEOUT";
        case CONNECT_TIMEOUT:
            return "CONNECT_TIMEOUT";
        default:
            return "UNKNOWN";
    }
}
#end_block

#method_before
@VisibleForTesting
public void answerCall(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "answerCall device is null");
        return;
    }
    if (mPhoneProxy != null) {
        try {
            mPhoneProxy.answerCall();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    } else {
        Log.e(TAG, "Handsfree phone proxy null for answering call");
    }
}
#method_after
@VisibleForTesting
public void answerCall(BluetoothDevice device) {
    if (device == null) {
        Log.w(TAG, "answerCall device is null");
        return;
    }
    if (mPhoneProxy != null) {
        try {
            mHeadsetService.setActiveDevice(device);
            mPhoneProxy.answerCall();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    } else {
        Log.e(TAG, "Handsfree phone proxy null for answering call");
    }
}
#end_block

#method_before
protected boolean cleanup() {
    return true;
}
#method_after
protected void cleanup() {
}
#end_block

#method_before
private void doStart(Intent intent) {
    // Start service
    if (mAdapter == null) {
        Log.e(mName, "Error starting profile. BluetoothAdapter is null");
    } else {
        if (DBG) {
            log("start()");
        }
        mStartError = !start();
        if (!mStartError) {
            notifyProfileServiceStateChanged(BluetoothAdapter.STATE_ON);
        } else {
            Log.e(mName, "Error starting profile. BluetoothAdapter is null");
        }
    }
}
#method_after
private void doStart(Intent intent) {
    // Start service
    if (mAdapter == null) {
        Log.e(mName, "Error starting profile. BluetoothAdapter is null");
    } else {
        if (DBG) {
            log("start()");
        }
        mStartError = !start();
        if (!mStartError) {
            notifyProfileServiceStateChanged(BluetoothAdapter.STATE_ON);
        } else {
            Log.e(mName, "Error starting profile. start() returned false.");
        }
    }
}
#end_block

#method_before
private static void setInstanceForTesting(HeadsetObjectsFactory objectsFactory) {
    Utils.enforceInstrumentationTestMode();
    synchronized (INSTANCE_LOCK) {
        sInstance = objectsFactory;
    }
}
#method_after
private static void setInstanceForTesting(HeadsetObjectsFactory objectsFactory) {
    Utils.enforceInstrumentationTestMode();
    synchronized (INSTANCE_LOCK) {
        Log.d(TAG, "setInstanceForTesting(), set to " + objectsFactory);
        sInstance = objectsFactory;
    }
}
#end_block

#method_before
public HeadsetStateMachine makeStateMachine(Looper looper, HeadsetService service, HeadsetNativeInterface nativeInterface, HeadsetSystemInterface systemInterface) {
    return HeadsetStateMachine.make(looper, service, nativeInterface, systemInterface);
}
#method_after
public HeadsetStateMachine makeStateMachine(BluetoothDevice device, Looper looper, HeadsetService service, HeadsetNativeInterface nativeInterface, HeadsetSystemInterface systemInterface) {
    return HeadsetStateMachine.make(device, looper, service, nativeInterface, systemInterface);
}
#end_block

#method_before
@BeforeClass
public static void setUpClassOnlyOnce() throws Exception {
    sAdapterService = mock(AdapterService.class);
    // We cannot mock AdapterService.getAdapterService() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the AdapterService.sAdapterService field.
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(sAdapterService, sAdapterService);
}
#method_after
@BeforeClass
public static void setUpClassOnlyOnce() throws Exception {
    sAdapterService = mock(AdapterService.class);
    // We cannot mock AdapterService.getAdapterService() with Mockito.
    // Hence we need to use reflection to call a private method to
    // initialize properly the AdapterService.sAdapterService field.
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(null, sAdapterService);
}
#end_block

#method_before
@AfterClass
public static void tearDownOnlyOnce() throws Exception {
    Method method = AdapterService.class.getDeclaredMethod("setAdapterService", AdapterService.class);
    method.setAccessible(true);
    method.invoke(sAdapterService, (AdapterService) null);
    sAdapterService = null;
}
#method_after
@AfterClass
public static void tearDownOnlyOnce() throws Exception {
    Method method = AdapterService.class.getDeclaredMethod("clearAdapterService");
    method.setAccessible(true);
    method.invoke(null);
    sAdapterService = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    // Setup mocks and test assets
    MockitoAnnotations.initMocks(this);
    // Stub system interface
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Spy on native interface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doReturn(true).when(mNativeInterface).connectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).connectAudio(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectAudio(mTestDevice);
    // Stub headset service
    when(mHeadsetService.bindService(any(Intent.class), any(ServiceConnection.class), anyInt())).thenReturn(true);
    when(mHeadsetService.getResources()).thenReturn(InstrumentationRegistry.getTargetContext().getResources());
    when(mHeadsetService.getPackageManager()).thenReturn(InstrumentationRegistry.getContext().getPackageManager());
    when(mHeadsetService.getPriority(any(BluetoothDevice.class))).thenReturn(BluetoothProfile.PRIORITY_ON);
    when(mHeadsetService.getForceScoAudio()).thenReturn(true);
    // Setup thread and looper
    mHandlerThread = new HandlerThread("HeadsetStateMachineTestHandlerThread");
    mHandlerThread.start();
    // Modify CONNECT timeout to a smaller value for test only
    HeadsetStateMachine.sConnectTimeoutMillis = CONNECT_TIMEOUT_TEST_MILLIS;
    mHeadsetStateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mHandlerThread.getLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
}
#method_after
@Before
public void setUp() throws Exception {
    // Setup mocks and test assets
    MockitoAnnotations.initMocks(this);
    // Stub system interface
    when(mSystemInterface.getHeadsetPhoneState()).thenReturn(mPhoneState);
    when(mSystemInterface.getAudioManager()).thenReturn(mAudioManager);
    // This line must be called to make sure relevant objects are initialized properly
    mAdapter = BluetoothAdapter.getDefaultAdapter();
    // Get a device for testing
    mTestDevice = mAdapter.getRemoteDevice("00:01:02:03:04:05");
    // Spy on native interface
    mNativeInterface = spy(HeadsetNativeInterface.getInstance());
    doNothing().when(mNativeInterface).init(anyInt(), anyBoolean());
    doReturn(true).when(mNativeInterface).connectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectHfp(mTestDevice);
    doReturn(true).when(mNativeInterface).connectAudio(mTestDevice);
    doReturn(true).when(mNativeInterface).disconnectAudio(mTestDevice);
    // Stub headset service
    when(mHeadsetService.bindService(any(Intent.class), any(ServiceConnection.class), anyInt())).thenReturn(true);
    when(mHeadsetService.getResources()).thenReturn(InstrumentationRegistry.getTargetContext().getResources());
    when(mHeadsetService.getPackageManager()).thenReturn(InstrumentationRegistry.getContext().getPackageManager());
    when(mHeadsetService.getPriority(any(BluetoothDevice.class))).thenReturn(BluetoothProfile.PRIORITY_ON);
    when(mHeadsetService.getForceScoAudio()).thenReturn(true);
    when(mHeadsetService.okToAcceptConnection(any(BluetoothDevice.class))).thenReturn(true);
    // Setup thread and looper
    mHandlerThread = new HandlerThread("HeadsetStateMachineTestHandlerThread");
    mHandlerThread.start();
    // Modify CONNECT timeout to a smaller value for test only
    HeadsetStateMachine.sConnectTimeoutMs = CONNECT_TIMEOUT_TEST_MILLIS;
    mHeadsetStateMachine = HeadsetObjectsFactory.getInstance().makeStateMachine(mTestDevice, mHandlerThread.getLooper(), mHeadsetService, mNativeInterface, mSystemInterface);
}
#end_block

#method_before
public static boolean isInstrumentationTestMode() {
    try {
        if (Class.forName("com.android.bluetooth.FileSystemWriteTest") != null) {
            return true;
        }
    } catch (ClassNotFoundException exception) {
        return false;
    }
    return false;
}
#method_after
public static boolean isInstrumentationTestMode() {
    try {
        return Class.forName("com.android.bluetooth.FileSystemWriteTest") != null;
    } catch (ClassNotFoundException exception) {
        return false;
    }
}
#end_block

#method_before
public static synchronized AdapterService getAdapterService() {
    if (sAdapterService != null && !sAdapterService.mCleaningUp) {
        Log.d(TAG, "getAdapterService() - returning " + sAdapterService);
        return sAdapterService;
    }
    if (DBG) {
        if (sAdapterService == null) {
            Log.d(TAG, "getAdapterService() - Service not available");
        } else if (sAdapterService.mCleaningUp) {
            Log.d(TAG, "getAdapterService() - Service is cleaning up");
        }
    }
    return null;
}
#method_after
public static synchronized AdapterService getAdapterService() {
    Log.d(TAG, "getAdapterService() - returning " + sAdapterService);
    return sAdapterService;
}
#end_block

#method_before
private static synchronized void setAdapterService(AdapterService instance) {
    if (instance != null && !instance.mCleaningUp) {
        if (DBG) {
            Log.d(TAG, "setAdapterService() - set to: " + sAdapterService);
        }
        sAdapterService = instance;
    } else {
        if (DBG) {
            if (sAdapterService == null) {
                Log.d(TAG, "setAdapterService() - Service not available");
            } else if (sAdapterService.mCleaningUp) {
                Log.d(TAG, "setAdapterService() - Service is cleaning up");
            }
        }
    }
}
#method_after
private static synchronized void setAdapterService(AdapterService instance) {
    Log.d(TAG, "setAdapterService() - trying to set service to " + instance);
    if (instance == null) {
        return;
    }
    sAdapterService = instance;
}
#end_block

#method_before
private static synchronized void clearAdapterService() {
    sAdapterService = null;
}
#method_after
private static synchronized void clearAdapterService(AdapterService current) {
    if (sAdapterService == current) {
        sAdapterService = null;
    }
}
#end_block

#method_before
private void processProfileServiceStateChanged(String serviceName, int state) {
    boolean doUpdate = false;
    boolean isBleTurningOn;
    boolean isBleTurningOff;
    boolean isTurningOn;
    boolean isTurningOff;
    synchronized (mProfileServicesState) {
        Integer prevState = mProfileServicesState.get(serviceName);
        if (prevState != null && prevState != state) {
            mProfileServicesState.put(serviceName, state);
            doUpdate = true;
        }
    }
    if (!doUpdate) {
        return;
    }
    synchronized (mAdapterStateMachine) {
        isTurningOff = mAdapterStateMachine.isTurningOff();
        isTurningOn = mAdapterStateMachine.isTurningOn();
        isBleTurningOn = mAdapterStateMachine.isBleTurningOn();
        isBleTurningOff = mAdapterStateMachine.isBleTurningOff();
    }
    debugLog("processProfileServiceStateChanged() - serviceName=" + serviceName + " isTurningOn=" + isTurningOn + " isTurningOff=" + isTurningOff + " isBleTurningOn=" + isBleTurningOn + " isBleTurningOff=" + isBleTurningOff);
    if (isBleTurningOn) {
        if (serviceName.equals("com.android.bluetooth.gatt.GattService")) {
            debugLog("GattService is started");
            mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
            return;
        }
    } else if (isBleTurningOff) {
        if (serviceName.equals("com.android.bluetooth.gatt.GattService")) {
            debugLog("GattService stopped");
            mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STOPPED));
            return;
        }
    } else if (isTurningOff) {
        // Check if all services are stopped if so, do cleanup
        synchronized (mProfileServicesState) {
            Iterator<Map.Entry<String, Integer>> i = mProfileServicesState.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<String, Integer> entry = i.next();
                if (entry.getKey().equals("com.android.bluetooth.gatt.GattService")) {
                    continue;
                }
                if (BluetoothAdapter.STATE_OFF != entry.getValue()) {
                    debugLog("onProfileServiceStateChange() - Profile still running: " + entry.getKey());
                    return;
                }
            }
        }
        debugLog("onProfileServiceStateChange() - All profile services stopped...");
        // Send message to state machine
        mProfilesStarted = false;
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STOPPED));
    } else if (isTurningOn) {
        updateInteropDatabase();
        // Check if all services are started if so, update state
        synchronized (mProfileServicesState) {
            Iterator<Map.Entry<String, Integer>> i = mProfileServicesState.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<String, Integer> entry = i.next();
                if (entry.getKey().equals("com.android.bluetooth.gatt.GattService")) {
                    continue;
                }
                if (BluetoothAdapter.STATE_ON != entry.getValue()) {
                    debugLog("onProfileServiceStateChange() - Profile still not running:" + entry.getKey());
                    return;
                }
            }
        }
        debugLog("onProfileServiceStateChange() - All profile services started.");
        mProfilesStarted = true;
        // Send message to state machine
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
    }
}
#method_after
private void processProfileServiceStateChanged(String serviceName, int state) {
    boolean doUpdate = false;
    boolean isBleTurningOn;
    boolean isBleTurningOff;
    boolean isTurningOn;
    boolean isTurningOff;
    synchronized (mProfileServicesState) {
        Integer prevState = mProfileServicesState.get(serviceName);
        if (prevState != null && prevState != state) {
            mProfileServicesState.put(serviceName, state);
            doUpdate = true;
        }
    }
    if (!doUpdate) {
        return;
    }
    synchronized (mAdapterStateMachine) {
        isTurningOff = mAdapterStateMachine.isTurningOff();
        isTurningOn = mAdapterStateMachine.isTurningOn();
        isBleTurningOn = mAdapterStateMachine.isBleTurningOn();
        isBleTurningOff = mAdapterStateMachine.isBleTurningOff();
    }
    debugLog("processProfileServiceStateChanged() - serviceName=" + serviceName + " isTurningOn=" + isTurningOn + " isTurningOff=" + isTurningOff + " isBleTurningOn=" + isBleTurningOn + " isBleTurningOff=" + isBleTurningOff);
    if (isBleTurningOn) {
        if (GattService.class.getName().equals(serviceName)) {
            debugLog("GattService is started");
            mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STARTED));
            return;
        }
    } else if (isBleTurningOff) {
        if (GattService.class.getName().equals(serviceName)) {
            debugLog("GattService stopped");
            mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BLE_STOPPED));
            return;
        }
    } else if (isTurningOff) {
        // Check if all services are stopped if so, do cleanup
        synchronized (mProfileServicesState) {
            Iterator<Map.Entry<String, Integer>> i = mProfileServicesState.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<String, Integer> entry = i.next();
                if (GattService.class.getName().equals(entry.getKey())) {
                    continue;
                }
                if (BluetoothAdapter.STATE_OFF != entry.getValue()) {
                    debugLog("onProfileServiceStateChange() - Profile still running: " + entry.getKey());
                    return;
                }
            }
        }
        debugLog("onProfileServiceStateChange() - All profile services stopped...");
        // Send message to state machine
        mProfilesStarted = false;
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STOPPED));
    } else if (isTurningOn) {
        updateInteropDatabase();
        // Check if all services are started if so, update state
        synchronized (mProfileServicesState) {
            Iterator<Map.Entry<String, Integer>> i = mProfileServicesState.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<String, Integer> entry = i.next();
                if (GattService.class.getName().equals(entry.getKey())) {
                    continue;
                }
                if (BluetoothAdapter.STATE_ON != entry.getValue()) {
                    debugLog("onProfileServiceStateChange() - Profile still not running:" + entry.getKey());
                    return;
                }
            }
        }
        debugLog("onProfileServiceStateChange() - All profile services started.");
        mProfilesStarted = true;
        // Send message to state machine
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
    }
}
#end_block

#method_before
void bleOnProcessStart() {
    debugLog("bleOnProcessStart()");
    if (getResources().getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {
        Config.init(getApplicationContext());
    }
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    // Initialize data objects
    for (int i = 0; i < supportedProfileServices.length; i++) {
        mProfileServicesState.put(supportedProfileServices[i].getName(), BluetoothAdapter.STATE_OFF);
    }
    // Reset |mRemoteDevices| whenever BLE is turned off then on
    // This is to replace the fact that |mRemoteDevices| was
    // reinitialized in previous code.
    // 
    // TODO(apanicke): The reason is unclear but
    // I believe it is to clear the variable every time BLE was
    // turned off then on. The same effect can be achieved by
    // calling cleanup but this may not be necessary at all
    // We should figure out why this is needed later
    mRemoteDevices.reset();
    mAdapterProperties.init(mRemoteDevices);
    debugLog("bleOnProcessStart() - Make Bond State Machine");
    mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);
    mJniCallbacks.init(mBondStateMachine, mRemoteDevices);
    try {
        mBatteryStats.noteResetBleScan();
    } catch (RemoteException e) {
    // Ignore.
    }
    // Start Gatt service
    setGattProfileServiceState(supportedProfileServices, BluetoothAdapter.STATE_ON);
}
#method_after
void bleOnProcessStart() {
    debugLog("bleOnProcessStart()");
    if (getResources().getBoolean(R.bool.config_bluetooth_reload_supported_profiles_when_enabled)) {
        Config.init(getApplicationContext());
    }
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    // Initialize data objects
    for (Class service : supportedProfileServices) {
        mProfileServicesState.put(service.getName(), BluetoothAdapter.STATE_OFF);
    }
    // Reset |mRemoteDevices| whenever BLE is turned off then on
    // This is to replace the fact that |mRemoteDevices| was
    // reinitialized in previous code.
    // 
    // TODO(apanicke): The reason is unclear but
    // I believe it is to clear the variable every time BLE was
    // turned off then on. The same effect can be achieved by
    // calling cleanup but this may not be necessary at all
    // We should figure out why this is needed later
    mRemoteDevices.reset();
    mAdapterProperties.init(mRemoteDevices);
    debugLog("bleOnProcessStart() - Make Bond State Machine");
    mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);
    mJniCallbacks.init(mBondStateMachine, mRemoteDevices);
    try {
        mBatteryStats.noteResetBleScan();
    } catch (RemoteException e) {
    // Ignore.
    }
    // Start Gatt service
    setGattProfileServiceState(supportedProfileServices, BluetoothAdapter.STATE_ON);
}
#end_block

#method_before
void startCoreServices() {
    debugLog("startCoreServices()");
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    // Start profile services
    if (!mProfilesStarted && supportedProfileServices.length > 0) {
        // Startup all profile services
        setProfileServiceState(supportedProfileServices, BluetoothAdapter.STATE_ON);
    } else {
        debugLog("startCoreProfiles(): Profile Services alreay started");
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
    }
}
#method_after
void startCoreServices() {
    debugLog("startCoreServices()");
    Class[] supportedProfileServices = Config.getSupportedProfiles();
    // Start profile services
    if (!mProfilesStarted && supportedProfileServices.length > 0 && !(supportedProfileServices.length == 1 && supportedProfileServices[0] == GattService.class)) {
        // Startup all profile services
        setProfileServiceState(supportedProfileServices, BluetoothAdapter.STATE_ON);
    } else {
        debugLog("startCoreProfiles(): Profile Services alreay started");
        mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
    }
}
#end_block

#method_before
void cleanup() {
    debugLog("cleanup()");
    if (mCleaningUp) {
        errorLog("cleanup() - Service already starting to cleanup, ignoring request...");
        return;
    }
    mCleaningUp = true;
    unregisterReceiver(mAlarmBroadcastReceiver);
    if (mPendingAlarm != null) {
        mAlarmManager.cancel(mPendingAlarm);
        mPendingAlarm = null;
    }
    // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.
    synchronized (this) {
        if (mWakeLock != null) {
            if (mWakeLock.isHeld()) {
                mWakeLock.release();
            }
            mWakeLock = null;
        }
    }
    if (mAdapterStateMachine != null) {
        mAdapterStateMachine.doQuit();
    }
    if (mBondStateMachine != null) {
        mBondStateMachine.doQuit();
    }
    if (mRemoteDevices != null) {
        mRemoteDevices.cleanup();
    }
    if (mSdpManager != null) {
        mSdpManager.cleanup();
        mSdpManager = null;
    }
    if (mNativeAvailable) {
        debugLog("cleanup() - Cleaning up adapter native");
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mAdapterProperties != null) {
        mAdapterProperties.cleanup();
    }
    if (mJniCallbacks != null) {
        mJniCallbacks.cleanup();
    }
    if (mPhonePolicy != null) {
        mPhonePolicy.cleanup();
    }
    if (mProfileServicesState != null) {
        mProfileServicesState.clear();
    }
    clearAdapterService();
    if (mBinder != null) {
        mBinder.cleanup();
        // Do not remove. Otherwise Binder leak!
        mBinder = null;
    }
    if (mCallbacks != null) {
        mCallbacks.kill();
    }
}
#method_after
void cleanup() {
    debugLog("cleanup()");
    if (mCleaningUp) {
        errorLog("cleanup() - Service already starting to cleanup, ignoring request...");
        return;
    }
    clearAdapterService(this);
    mCleaningUp = true;
    unregisterReceiver(mAlarmBroadcastReceiver);
    if (mPendingAlarm != null) {
        mAlarmManager.cancel(mPendingAlarm);
        mPendingAlarm = null;
    }
    // {@link #releaseWakeLock(String lockName)}, so a synchronization is needed here.
    synchronized (this) {
        if (mWakeLock != null) {
            if (mWakeLock.isHeld()) {
                mWakeLock.release();
            }
            mWakeLock = null;
        }
    }
    if (mAdapterStateMachine != null) {
        mAdapterStateMachine.doQuit();
    }
    if (mBondStateMachine != null) {
        mBondStateMachine.doQuit();
    }
    if (mRemoteDevices != null) {
        mRemoteDevices.cleanup();
    }
    if (mSdpManager != null) {
        mSdpManager.cleanup();
        mSdpManager = null;
    }
    if (mNativeAvailable) {
        debugLog("cleanup() - Cleaning up adapter native");
        cleanupNative();
        mNativeAvailable = false;
    }
    if (mAdapterProperties != null) {
        mAdapterProperties.cleanup();
    }
    if (mJniCallbacks != null) {
        mJniCallbacks.cleanup();
    }
    if (mPhonePolicy != null) {
        mPhonePolicy.cleanup();
    }
    if (mProfileServicesState != null) {
        mProfileServicesState.clear();
    }
    if (mBinder != null) {
        mBinder.cleanup();
        // Do not remove. Otherwise Binder leak!
        mBinder = null;
    }
    if (mCallbacks != null) {
        mCallbacks.kill();
    }
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setGattProfileServiceState(Class[] services, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        Log.w(TAG, "setGattProfileServiceState(): invalid state...Leaving...");
        return;
    }
    int expectedCurrentState = BluetoothAdapter.STATE_OFF;
    int pendingState = BluetoothAdapter.STATE_TURNING_ON;
    if (state == BluetoothAdapter.STATE_OFF) {
        expectedCurrentState = BluetoothAdapter.STATE_ON;
        pendingState = BluetoothAdapter.STATE_TURNING_OFF;
    }
    for (int i = 0; i < services.length; i++) {
        String serviceName = services[i].getName();
        String simpleName = services[i].getSimpleName();
        if (simpleName.equals("GattService")) {
            Integer serviceState = mProfileServicesState.get(serviceName);
            if (serviceState != null && serviceState != expectedCurrentState) {
                debugLog("setProfileServiceState() - Unable to " + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop") + " service " + serviceName + ". Invalid state: " + serviceState);
                continue;
            }
            debugLog("setProfileServiceState() - " + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting") + " service " + serviceName);
            mProfileServicesState.put(serviceName, pendingState);
            Intent intent = new Intent(this, services[i]);
            intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);
            intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);
            startService(intent);
            return;
        }
    }
}
#method_after
@SuppressWarnings("rawtypes")
private void setGattProfileServiceState(Class[] services, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        Log.w(TAG, "setGattProfileServiceState(): invalid state...Leaving...");
        return;
    }
    int expectedCurrentState = BluetoothAdapter.STATE_OFF;
    int pendingState = BluetoothAdapter.STATE_TURNING_ON;
    if (state == BluetoothAdapter.STATE_OFF) {
        expectedCurrentState = BluetoothAdapter.STATE_ON;
        pendingState = BluetoothAdapter.STATE_TURNING_OFF;
    }
    for (Class service : services) {
        String serviceName = service.getName();
        String simpleName = service.getSimpleName();
        if (GattService.class.getSimpleName().equals(simpleName)) {
            Integer serviceState = mProfileServicesState.get(serviceName);
            if (serviceState != null && serviceState != expectedCurrentState) {
                debugLog("setProfileServiceState() - Unable to " + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop") + " service " + serviceName + ". Invalid state: " + serviceState);
                continue;
            }
            debugLog("setProfileServiceState() - " + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting") + " service " + serviceName);
            mProfileServicesState.put(serviceName, pendingState);
            Intent intent = new Intent(this, service);
            intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);
            intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);
            startService(intent);
            return;
        }
    }
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
private void setProfileServiceState(Class[] services, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        debugLog("setProfileServiceState() - Invalid state, leaving...");
        return;
    }
    int expectedCurrentState = BluetoothAdapter.STATE_OFF;
    int pendingState = BluetoothAdapter.STATE_TURNING_ON;
    if (state == BluetoothAdapter.STATE_OFF) {
        expectedCurrentState = BluetoothAdapter.STATE_ON;
        pendingState = BluetoothAdapter.STATE_TURNING_OFF;
    }
    for (int i = 0; i < services.length; i++) {
        String serviceName = services[i].getName();
        String simpleName = services[i].getSimpleName();
        if (simpleName.equals("GattService")) {
            continue;
        }
        Integer serviceState = mProfileServicesState.get(serviceName);
        if (serviceState != null && serviceState != expectedCurrentState) {
            debugLog("setProfileServiceState() - Unable to " + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop") + " service " + serviceName + ". Invalid state: " + serviceState);
            continue;
        }
        debugLog("setProfileServiceState() - " + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting") + " service " + serviceName);
        mProfileServicesState.put(serviceName, pendingState);
        Intent intent = new Intent(this, services[i]);
        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);
        startService(intent);
    }
}
#method_after
@SuppressWarnings("rawtypes")
private void setProfileServiceState(Class[] services, int state) {
    if (state != BluetoothAdapter.STATE_ON && state != BluetoothAdapter.STATE_OFF) {
        debugLog("setProfileServiceState() - Invalid state, leaving...");
        return;
    }
    int expectedCurrentState = BluetoothAdapter.STATE_OFF;
    int pendingState = BluetoothAdapter.STATE_TURNING_ON;
    if (state == BluetoothAdapter.STATE_OFF) {
        expectedCurrentState = BluetoothAdapter.STATE_ON;
        pendingState = BluetoothAdapter.STATE_TURNING_OFF;
    }
    for (Class service : services) {
        String serviceName = service.getName();
        String simpleName = service.getSimpleName();
        if (GattService.class.getSimpleName().equals(simpleName)) {
            continue;
        }
        Integer serviceState = mProfileServicesState.get(serviceName);
        if (serviceState != null && serviceState != expectedCurrentState) {
            debugLog("setProfileServiceState() - Unable to " + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop") + " service " + serviceName + ". Invalid state: " + serviceState);
            continue;
        }
        debugLog("setProfileServiceState() - " + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting") + " service " + serviceName);
        mProfileServicesState.put(serviceName, pendingState);
        Intent intent = new Intent(this, service);
        intent.putExtra(EXTRA_ACTION, ACTION_SERVICE_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, state);
        startService(intent);
    }
}
#end_block

#method_before
public boolean cleanup() {
    mService = null;
    return true;
}
#method_after
public void cleanup() {
    mService = null;
}
#end_block

#method_before
public synchronized boolean enable(boolean quietMode) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    // Enforce the user restriction for disallowing Bluetooth if it was set.
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {
        debugLog("enable() called when Bluetooth was disallowed");
        return false;
    }
    debugLog("enable() - Enable called with quiet mode status =  " + mQuietmode);
    mQuietmode = quietMode;
    Message m = mAdapterStateMachine.obtainMessage(AdapterState.BLE_TURN_ON);
    mAdapterStateMachine.sendMessage(m);
    mBluetoothStartTime = System.currentTimeMillis();
    return true;
}
#method_after
public synchronized boolean enable(boolean quietMode) {
    enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM, "Need BLUETOOTH ADMIN permission");
    // Enforce the user restriction for disallowing Bluetooth if it was set.
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_BLUETOOTH, UserHandle.SYSTEM)) {
        debugLog("enable() called when Bluetooth was disallowed");
        return false;
    }
    debugLog("enable() - Enable called with quiet mode status =  " + quietMode);
    mQuietmode = quietMode;
    Message m = mAdapterStateMachine.obtainMessage(AdapterState.BLE_TURN_ON);
    mAdapterStateMachine.sendMessage(m);
    mBluetoothStartTime = System.currentTimeMillis();
    return true;
}
#end_block

#method_before
boolean setBluetoothClass(BluetoothClass bluetoothClass) {
    enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, "Need BLUETOOTH PRIVILEGED permission");
    boolean result = mAdapterProperties.setBluetoothClass(bluetoothClass);
    if (!result) {
        Log.e(TAG, "Failed to set BluetoothClass (" + bluetoothClass + ") on local Bluetooth adapter.");
    }
    return result && storeBluetoothClassConfig(bluetoothClass.getClassOfDevice());
}
#method_after
boolean setBluetoothClass(BluetoothClass bluetoothClass) {
    enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED, "Need BLUETOOTH PRIVILEGED permission");
    debugLog("setBluetoothClass() to " + bluetoothClass);
    boolean result = mAdapterProperties.setBluetoothClass(bluetoothClass);
    if (!result) {
        Log.e(TAG, "setBluetoothClass() to " + bluetoothClass + " failed");
    }
    return result && storeBluetoothClassConfig(bluetoothClass.getClassOfDevice());
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    if (args.length > 0) {
        verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
        if (args[0].startsWith("--proto")) {
            if (args[0].equals("--proto-java-bin")) {
                dumpJava(fd);
            } else {
                dumpNative(fd, args);
            }
            return;
        }
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    // Dump profile information
    StringBuilder sb = new StringBuilder();
    synchronized (mProfiles) {
        for (ProfileService profile : mProfiles) {
            profile.dump(sb);
        }
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
    if (args.length == 0) {
        writer.println("Skipping dump in APP SERVICES, see bluetooth_manager section.");
        writer.println("Use --print argument for dumpsys direct from AdapterService.");
        return;
    }
    verboseLog("dumpsys arguments, check for protobuf output: " + TextUtils.join(" ", args));
    if (args[0].startsWith("--proto")) {
        if (args[0].equals("--proto-java-bin")) {
            dumpJava(fd);
        } else {
            dumpNative(fd, args);
        }
        return;
    }
    writer.println("Bonded devices:");
    for (BluetoothDevice device : getBondedDevices()) {
        writer.println("  " + device.getAddress() + " [" + DEVICE_TYPE_NAMES[device.getType()] + "] " + device.getName());
    }
    // Dump profile information
    StringBuilder sb = new StringBuilder();
    synchronized (mProfiles) {
        for (ProfileService profile : mProfiles) {
            profile.dump(sb);
        }
    }
    writer.write(sb.toString());
    writer.flush();
    dumpNative(fd, args);
}
#end_block

#method_before
@Override
protected void finalize() {
    debugLog("finalize() - clean up object " + this);
    cleanup();
    if (TRACE_REF) {
        synchronized (AdapterService.class) {
            sRefCount--;
            debugLog("finalize() - REFCOUNT: FINALIZED. INSTANCE_COUNT= " + sRefCount);
        }
    }
}
#method_after
@Override
public void finalize() {
    if (TRACE_REF) {
        synchronized (AdapterService.class) {
            sRefCount--;
            debugLog("finalize() - REFCOUNT: FINALIZED. INSTANCE_COUNT= " + sRefCount);
        }
    }
}
#end_block

#method_before
public void switchSlots(int[] physicalSlots) {
// TODO(amitmahajan): Method implementation.
}
#method_after
public void switchSlots(int[] physicalSlots, Message response) {
    mRadioConfig.setSimSlotsMapping(physicalSlots, response);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    synchronized (mLock) {
        Integer phoneId = getCiIndex(msg);
        if (phoneId < 0 || phoneId >= mCis.length) {
            Rlog.e(LOG_TAG, "Invalid phoneId : " + phoneId + " received with event " + msg.what);
            return;
        }
        AsyncResult ar = (AsyncResult) msg.obj;
        switch(msg.what) {
            case EVENT_ICC_STATUS_CHANGED:
                if (DBG)
                    log("Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
                mCis[phoneId].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, phoneId));
                break;
            case EVENT_RADIO_AVAILABLE:
            case EVENT_RADIO_ON:
                if (DBG) {
                    log("Received EVENT_RADIO_AVAILABLE/EVENT_RADIO_ON, calling " + "getIccCardStatus");
                }
                mCis[phoneId].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, phoneId));
                // slot status should be the same on all RILs; request it only for phoneId 0
                if (phoneId == 0) {
                    if (DBG) {
                        log("Received EVENT_RADIO_AVAILABLE/EVENT_RADIO_ON for phoneId 0, " + "calling getIccSlotsStatus");
                    }
                    mCis[phoneId].getIccSlotsStatus(obtainMessage(EVENT_GET_SLOT_STATUS_DONE, phoneId));
                }
                break;
            case EVENT_GET_ICC_STATUS_DONE:
                if (DBG)
                    log("Received EVENT_GET_ICC_STATUS_DONE");
                onGetIccCardStatusDone(ar, phoneId);
                break;
            case EVENT_SLOT_STATUS_CHANGED:
            case EVENT_GET_SLOT_STATUS_DONE:
                if (DBG) {
                    log("Received EVENT_SLOT_STATUS_CHANGED or EVENT_GET_SLOT_STATUS_DONE");
                }
                onGetSlotStatusDone(ar);
                break;
            case EVENT_RADIO_UNAVAILABLE:
                if (DBG)
                    log("EVENT_RADIO_UNAVAILABLE, dispose card");
                UiccSlot uiccSlot = getUiccSlotForPhone(phoneId);
                if (uiccSlot != null) {
                    uiccSlot.onRadioStateUnavailable();
                }
                mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, phoneId, null));
                break;
            case EVENT_SIM_REFRESH:
                if (DBG)
                    log("Received EVENT_SIM_REFRESH");
                onSimRefresh(ar, phoneId);
                break;
            default:
                Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
                break;
        }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    synchronized (mLock) {
        Integer phoneId = getCiIndex(msg);
        if (phoneId < 0 || phoneId >= mCis.length) {
            Rlog.e(LOG_TAG, "Invalid phoneId : " + phoneId + " received with event " + msg.what);
            return;
        }
        AsyncResult ar = (AsyncResult) msg.obj;
        switch(msg.what) {
            case EVENT_ICC_STATUS_CHANGED:
                if (DBG)
                    log("Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
                mCis[phoneId].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, phoneId));
                break;
            case EVENT_RADIO_AVAILABLE:
            case EVENT_RADIO_ON:
                if (DBG) {
                    log("Received EVENT_RADIO_AVAILABLE/EVENT_RADIO_ON, calling " + "getIccCardStatus");
                }
                mCis[phoneId].getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, phoneId));
                // slot status should be the same on all RILs; request it only for phoneId 0
                if (phoneId == 0) {
                    if (DBG) {
                        log("Received EVENT_RADIO_AVAILABLE/EVENT_RADIO_ON for phoneId 0, " + "calling getIccSlotsStatus");
                    }
                    mRadioConfig.getSimSlotsStatus(obtainMessage(EVENT_GET_SLOT_STATUS_DONE, phoneId));
                }
                break;
            case EVENT_GET_ICC_STATUS_DONE:
                if (DBG)
                    log("Received EVENT_GET_ICC_STATUS_DONE");
                onGetIccCardStatusDone(ar, phoneId);
                break;
            case EVENT_SLOT_STATUS_CHANGED:
            case EVENT_GET_SLOT_STATUS_DONE:
                if (DBG) {
                    log("Received EVENT_SLOT_STATUS_CHANGED or EVENT_GET_SLOT_STATUS_DONE");
                }
                onGetSlotStatusDone(ar);
                break;
            case EVENT_RADIO_UNAVAILABLE:
                if (DBG)
                    log("EVENT_RADIO_UNAVAILABLE, dispose card");
                UiccSlot uiccSlot = getUiccSlotForPhone(phoneId);
                if (uiccSlot != null) {
                    uiccSlot.onRadioStateUnavailable();
                }
                mIccChangedRegistrants.notifyRegistrants(new AsyncResult(null, phoneId, null));
                break;
            case EVENT_SIM_REFRESH:
                if (DBG)
                    log("Received EVENT_SIM_REFRESH");
                onSimRefresh(ar, phoneId);
                break;
            default:
                Rlog.e(LOG_TAG, " Unknown Event " + msg.what);
                break;
        }
    }
}
#end_block

#method_before
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            Rlog.e(LOG_TAG, "Unexpected error getting slot status.", ar.exception);
        } else {
            // REQUEST_NOT_SUPPORTED
            log("onGetSlotStatusDone: request not supported; marking mIsSlotStatusSupported " + "to false");
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    int numActiveSlots = 0;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidCardIndex(iss.logicalSlotIndex)) {
                throw new RuntimeException("Logical slot index " + iss.logicalSlotIndex + " invalid for physical slot " + i);
            }
            mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss);
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        throw new RuntimeException("Number of active slots " + numActiveSlots + " does not match the expected value " + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to muptiple phoneIds");
        }
        slotIds.add(slotId);
    }
}
#method_after
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            Rlog.e(LOG_TAG, "Unexpected error getting slot status.", ar.exception);
        } else {
            // REQUEST_NOT_SUPPORTED
            log("onGetSlotStatusDone: request not supported; marking mIsSlotStatusSupported " + "to false");
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    if (!slotStatusChanged(status)) {
        log("onGetSlotStatusDone: No change in slot status");
        return;
    }
    int numActiveSlots = 0;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidCardIndex(iss.logicalSlotIndex)) {
                throw new RuntimeException("Logical slot index " + iss.logicalSlotIndex + " invalid for physical slot " + i);
            }
            mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss);
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        throw new RuntimeException("Number of active slots " + numActiveSlots + " does not match the expected value " + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to multiple phoneIds");
        }
        slotIds.add(slotId);
    }
    // broadcast slot status changed
    Intent intent = new Intent(TelephonyManager.ACTION_SIM_SLOT_STATUS_CHANGED);
    mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
}
#end_block

#method_before
public int getSimState() {
    int slotIndex = getSlotIndex();
    // sim state
    if (slotIndex < 0) {
        // return unknown
        for (int i = 0; i < getPhoneCount(); i++) {
            int simState = getSimState(i);
            if (simState != SIM_STATE_ABSENT) {
                Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", sim state for " + "slotIndex=" + i + " is " + simState + ", return state as unknown");
                return SIM_STATE_UNKNOWN;
            }
        }
        Rlog.d(TAG, "getSimState: default sim:" + slotIndex + ", all SIMs absent, return " + "state as absent");
        return SIM_STATE_ABSENT;
    }
    return getSimState(slotIndex);
}
#method_after
public int getSimState() {
    int simState = getSimStateIncludingLoaded();
    if (simState == SIM_STATE_LOADED) {
        simState = SIM_STATE_READY;
    }
    return simState;
}
#end_block

#method_before
public int getSimState(int slotIndex) {
    int simState = SubscriptionManager.getSimStateForSlotIndex(slotIndex);
    return simState;
}
#method_after
public int getSimState(int slotIndex) {
    int simState = SubscriptionManager.getSimStateForSlotIndex(slotIndex);
    if (simState == SIM_STATE_LOADED) {
        simState = SIM_STATE_READY;
    }
    return simState;
}
#end_block

#method_before
public UiccSlotInfo[] getUiccSlotsInfo() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            return null;
        }
        return telephony.getUiccSlotsInfo();
    } catch (RemoteException e) {
        return null;
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
public UiccSlotInfo[] getUiccSlotsInfo() {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            return null;
        }
        return telephony.getUiccSlotsInfo();
    } catch (RemoteException e) {
        return null;
    }
}
#end_block

#method_before
public void switchSlots(int[] physicalSlots) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            return;
        }
        telephony.switchSlots(physicalSlots);
    } catch (RemoteException e) {
        return;
    }
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
public boolean switchSlots(int[] physicalSlots) {
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null) {
            return false;
        }
        return telephony.switchSlots(physicalSlots);
    } catch (RemoteException e) {
        return false;
    }
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeByte((byte) (isActive ? 1 : 0));
    dest.writeByte((byte) (isEuicc ? 1 : 0));
    dest.writeInt(cardId);
    dest.writeInt(cardStateInfo);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeByte((byte) (isActive ? 1 : 0));
    dest.writeByte((byte) (isEuicc ? 1 : 0));
    dest.writeString(cardId);
    dest.writeInt(cardStateInfo);
}
#end_block

#method_before
public int getCardId() {
    return cardId;
}
#method_after
public String getCardId() {
    return cardId;
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 1;
    result = 31 * result + (isActive ? 1 : 0);
    result = 31 * result + (isEuicc ? 1 : 0);
    result = 31 * result + cardId;
    result = 31 * result + cardStateInfo;
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = 1;
    result = 31 * result + (isActive ? 1 : 0);
    result = 31 * result + (isEuicc ? 1 : 0);
    result = 31 * result + Objects.hashCode(cardId);
    result = 31 * result + cardStateInfo;
    return result;
}
#end_block

#method_before
@Override
public void freeUnderlyingResources() {
    int spi = mSpi.getSpi();
    try {
        mSrvConfig.getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, mConfig.getXfrmMarkValue(), mConfig.getXfrmMarkMask());
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to delete SA with ID: " + mResourceId);
    }
    getResourceTracker().give();
}
#method_after
@Override
public void freeUnderlyingResources() {
    int spi = mSpi.getSpi();
    try {
        mSrvConfig.getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, mConfig.getSourceAddress(), mConfig.getDestinationAddress(), spi, mConfig.getMarkValue(), mConfig.getMarkMask());
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to delete SA with ID: " + mResourceId);
    }
    getResourceTracker().give();
}
#end_block

#method_before
@Override
public synchronized IpSecTransformResponse createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException {
    checkIpSecConfig(c);
    checkNotNull(binder, "Null Binder passed to createTransportModeTransform");
    final int resourceId = mNextResourceId++;
    UserRecord userRecord = mUserResourceTracker.getUserRecord(Binder.getCallingUid());
    // Avoid resizing by creating a dependency array of min-size 2 (1 UDP encap + 1 SPI)
    List<RefcountedResource> dependencies = new ArrayList<>(2);
    if (!userRecord.mTransformQuotaTracker.isAvailable()) {
        return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
    }
    int encapType, encapLocalPort = 0, encapRemotePort = 0;
    EncapSocketRecord socketRecord = null;
    encapType = c.getEncapType();
    if (encapType != IpSecTransform.ENCAP_NONE) {
        RefcountedResource<EncapSocketRecord> refcountedSocketRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(c.getEncapSocketResourceId());
        dependencies.add(refcountedSocketRecord);
        socketRecord = refcountedSocketRecord.getResource();
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    IpSecAlgorithm auth = c.getAuthentication();
    IpSecAlgorithm crypt = c.getEncryption();
    IpSecAlgorithm authCrypt = c.getAuthenticatedEncryption();
    RefcountedResource<SpiRecord> refcountedSpiRecord = userRecord.mSpiRecords.getRefcountedResourceOrThrow(c.getSpiResourceId());
    dependencies.add(refcountedSpiRecord);
    SpiRecord spiRecord = refcountedSpiRecord.getResource();
    try {
        mSrvConfig.getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), c.getSourceAddress(), c.getDestinationAddress(), (c.getNetwork() != null) ? c.getNetwork().netId : 0, spiRecord.getSpi(), c.getXfrmMarkValue(), c.getXfrmMarkMask(), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : new byte[] {}, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : new byte[] {}, (crypt != null) ? crypt.getTruncationLengthBits() : 0, (authCrypt != null) ? authCrypt.getName() : "", (authCrypt != null) ? authCrypt.getKey() : new byte[] {}, (authCrypt != null) ? authCrypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
    } catch (ServiceSpecificException e) {
        // FIXME: get the error code and throw is at an IOException from Errno Exception
        return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
    }
    // Both SAs were created successfully, time to construct a record and lock it away
    userRecord.mTransformRecords.put(resourceId, new RefcountedResource<TransformRecord>(new TransformRecord(resourceId, c, spiRecord, socketRecord), binder, dependencies.toArray(new RefcountedResource[dependencies.size()])));
    return new IpSecTransformResponse(IpSecManager.Status.OK, resourceId);
}
#method_after
@Override
public synchronized IpSecTransformResponse createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException {
    checkIpSecConfig(c);
    checkNotNull(binder, "Null Binder passed to createTransportModeTransform");
    final int resourceId = mNextResourceId++;
    UserRecord userRecord = mUserResourceTracker.getUserRecord(Binder.getCallingUid());
    // Avoid resizing by creating a dependency array of min-size 2 (1 UDP encap + 1 SPI)
    List<RefcountedResource> dependencies = new ArrayList<>(2);
    if (!userRecord.mTransformQuotaTracker.isAvailable()) {
        return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
    }
    int encapType, encapLocalPort = 0, encapRemotePort = 0;
    EncapSocketRecord socketRecord = null;
    encapType = c.getEncapType();
    if (encapType != IpSecTransform.ENCAP_NONE) {
        RefcountedResource<EncapSocketRecord> refcountedSocketRecord = userRecord.mEncapSocketRecords.getRefcountedResourceOrThrow(c.getEncapSocketResourceId());
        dependencies.add(refcountedSocketRecord);
        socketRecord = refcountedSocketRecord.getResource();
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    IpSecAlgorithm auth = c.getAuthentication();
    IpSecAlgorithm crypt = c.getEncryption();
    IpSecAlgorithm authCrypt = c.getAuthenticatedEncryption();
    RefcountedResource<SpiRecord> refcountedSpiRecord = userRecord.mSpiRecords.getRefcountedResourceOrThrow(c.getSpiResourceId());
    dependencies.add(refcountedSpiRecord);
    SpiRecord spiRecord = refcountedSpiRecord.getResource();
    try {
        mSrvConfig.getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), c.getSourceAddress(), c.getDestinationAddress(), (c.getNetwork() != null) ? c.getNetwork().netId : 0, spiRecord.getSpi(), c.getMarkValue(), c.getMarkMask(), (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : new byte[] {}, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : new byte[] {}, (crypt != null) ? crypt.getTruncationLengthBits() : 0, (authCrypt != null) ? authCrypt.getName() : "", (authCrypt != null) ? authCrypt.getKey() : new byte[] {}, (authCrypt != null) ? authCrypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
    } catch (ServiceSpecificException e) {
        // FIXME: get the error code and throw is at an IOException from Errno Exception
        return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
    }
    // Both SAs were created successfully, time to construct a record and lock it away
    userRecord.mTransformRecords.put(resourceId, new RefcountedResource<TransformRecord>(new TransformRecord(resourceId, c, spiRecord, socketRecord), binder, dependencies.toArray(new RefcountedResource[dependencies.size()])));
    return new IpSecTransformResponse(IpSecManager.Status.OK, resourceId);
}
#end_block

#method_before
@VisibleForTesting
public static /**
 * Equals method used for testing
 */
boolean equals(IpSecConfig lhs, IpSecConfig rhs) {
    if (lhs == null || rhs == null)
        return (lhs == rhs);
    return (lhs.mMode == rhs.mMode && lhs.mSourceAddress.equals(rhs.mSourceAddress) && lhs.mDestinationAddress.equals(rhs.mDestinationAddress) && ((lhs.mNetwork != null && lhs.mNetwork.equals(rhs.mNetwork)) || (lhs.mNetwork == rhs.mNetwork)) && lhs.mEncapType == rhs.mEncapType && lhs.mEncapSocketResourceId == rhs.mEncapSocketResourceId && lhs.mEncapRemotePort == rhs.mEncapRemotePort && lhs.mNattKeepaliveInterval == rhs.mNattKeepaliveInterval && lhs.mSpiResourceId == rhs.mSpiResourceId && IpSecAlgorithm.equals(lhs.mEncryption, rhs.mEncryption) && IpSecAlgorithm.equals(lhs.mAuthenticatedEncryption, rhs.mAuthenticatedEncryption) && IpSecAlgorithm.equals(lhs.mAuthentication, rhs.mAuthentication) && lhs.mMarkValue == rhs.mMarkValue) && lhs.mMarkMask == rhs.mMarkMask;
}
#method_after
@VisibleForTesting
public static /**
 * Equals method used for testing
 */
boolean equals(IpSecConfig lhs, IpSecConfig rhs) {
    if (lhs == null || rhs == null)
        return (lhs == rhs);
    return (lhs.mMode == rhs.mMode && lhs.mSourceAddress.equals(rhs.mSourceAddress) && lhs.mDestinationAddress.equals(rhs.mDestinationAddress) && ((lhs.mNetwork != null && lhs.mNetwork.equals(rhs.mNetwork)) || (lhs.mNetwork == rhs.mNetwork)) && lhs.mEncapType == rhs.mEncapType && lhs.mEncapSocketResourceId == rhs.mEncapSocketResourceId && lhs.mEncapRemotePort == rhs.mEncapRemotePort && lhs.mNattKeepaliveInterval == rhs.mNattKeepaliveInterval && lhs.mSpiResourceId == rhs.mSpiResourceId && IpSecAlgorithm.equals(lhs.mEncryption, rhs.mEncryption) && IpSecAlgorithm.equals(lhs.mAuthenticatedEncryption, rhs.mAuthenticatedEncryption) && IpSecAlgorithm.equals(lhs.mAuthentication, rhs.mAuthentication) && lhs.mMarkValue == rhs.mMarkValue && lhs.mMarkMask == rhs.mMarkMask);
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzState.handleNetworkUnavailable();
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED, cancelling notifications.");
            cancelAllNotifications();
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            if (mUiccApplcation != null && mUiccApplcation.getState() != AppState.APPSTATE_READY) {
                mIsSimReady = false;
                updateSpnDisplay();
            }
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        case EVENT_RADIO_POWER_OFF_DONE:
            if (DBG)
                log("EVENT_RADIO_POWER_OFF_DONE");
            if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
                // during shutdown the modem may not send radio state changed event
                // as a result of radio power request
                // Hence, issuing shut down regardless of radio power response
                mCi.requestShutdown(null);
            }
            break;
        // GSM
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            mIsSimReady = true;
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_SIM_NOT_INSERTED:
            if (DBG)
                log("EVENT_SIM_NOT_INSERTED");
            cancelAllNotifications();
            mMdn = null;
            mMin = null;
            mIsMinInfoReady = false;
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        case EVENT_IMS_SERVICE_STATE_CHANGED:
            if (DBG)
                log("EVENT_IMS_SERVICE_STATE_CHANGED");
            // GsmCdma phone is not STATE_IN_SERVICE.
            if (mSS.getState() != ServiceState.STATE_IN_SERVICE) {
                mPhone.notifyServiceStateChanged(mPhone.getServiceState());
            }
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    int combinedRegState = getCombinedRegState();
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled() && (combinedRegState == ServiceState.STATE_IN_SERVICE)) {
        // In Wi-Fi Calling mode show SPN or PLMN + WiFi Calling
        // 
        // 1) Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
        // is satisfied or SPN override is enabled for this carrier
        // 
        // 2) Show PLMN + Wi-Fi Calling if there is no valid SPN in case 1
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            // Force display no service
            final boolean forceDisplayNoService = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_display_no_service_when_sim_unready) && !mIsSimReady;
            if (mEmergencyOnly && !forceDisplayNoService) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // Show SPN + Wi-Fi Calling If SIM has SPN and SPN display condition
            // is satisfied or SPN override is enabled for this carrier.
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // Show PLMN + Wi-Fi Calling if there is no valid SPN in the above case
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlpha contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
protected void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#method_after
protected final void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#end_block

#method_before
protected void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#method_after
protected final void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.handleNetworkUnavailable();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through it's rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkAvailable();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
        mNitzState.handleNetworkUnavailable();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String prevCountryIsoCode = tm.getNetworkCountryIso(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.handleNetworkUnavailable();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update IDD.
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            // Update ISO.
            String countryIsoCode = "";
            try {
                String mcc = operatorNumeric.substring(0, 3);
                countryIsoCode = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), countryIsoCode);
            // Update Time Zone.
            boolean iccCardExists = iccCardExists();
            boolean networkIsoChanged = networkCountryIsoChanged(countryIsoCode, prevCountryIsoCode);
            // Determine countryChanged: networkIso is only reliable if there's an ICC card.
            boolean countryChanged = iccCardExists && networkIsoChanged;
            if (DBG) {
                long ctm = System.currentTimeMillis();
                log("Before handleNetworkCountryCodeKnown:" + " countryChanged=" + countryChanged + " iccCardExist=" + iccCardExists + " countryIsoChanged=" + networkIsoChanged + " operatorNumeric=" + operatorNumeric + " prevOperatorNumeric=" + prevOperatorNumeric + " countryIsoCode=" + countryIsoCode + " prevCountryIsoCode=" + prevCountryIsoCode + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            mNitzState.handleNetworkCountryCodeSet(countryChanged);
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#method_after
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name)) && (!mIsSubscriptionFromRuim)) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#end_block

#method_before
protected boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#method_after
private boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#end_block

#method_before
protected String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mSavedTimeZone is null, TimeZone would get the default timeZone,
    // and the fixTimeZone couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone = false;
    int timeZone = 0;
    TimeZone tzone = null;
    if (mSavedTimeZone != null) {
        timeZone = TimeZone.getTimeZone(mSavedTimeZone).getRawOffset() / MS_PER_HOUR;
        isNitzTimeZone = true;
    } else {
        tzone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (tzone != null)
            timeZone = tzone.getRawOffset() / MS_PER_HOUR;
    }
    int mcc = mHbpcdUtils.getMcc(sid, timeZone, (mZoneDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#method_after
private String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mNitzState.getSavedTimeZoneId() is null, TimeZone would get the default timeZone,
    // and the mNitzState.fixTimeZone() couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone;
    TimeZone tzone;
    if (mNitzState.getSavedTimeZoneId() != null) {
        tzone = TimeZone.getTimeZone(mNitzState.getSavedTimeZoneId());
        isNitzTimeZone = true;
    } else {
        NitzData lastNitzData = mNitzState.getCachedNitzData();
        if (lastNitzData == null) {
            tzone = null;
        } else {
            tzone = TimeZoneLookupHelper.guessZoneByNitzStatic(lastNitzData);
            if (ServiceStateTracker.DBG) {
                log("fixUnknownMcc(): guessNitzTimeZone returned " + (tzone == null ? tzone : tzone.getID()));
            }
        }
        isNitzTimeZone = false;
    }
    int utcOffsetHours = 0;
    if (tzone != null) {
        utcOffsetHours = tzone.getRawOffset() / MS_PER_HOUR;
    }
    NitzData nitzData = mNitzState.getCachedNitzData();
    boolean isDst = nitzData != null && nitzData.isDst();
    int mcc = mHbpcdUtils.getMcc(sid, utcOffsetHours, (isDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#end_block

#method_before
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        String tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " getAutoTimeZone()=" + getAutoTimeZone();
        if (DBG) {
            log(tmpLog);
        }
        mTimeZoneLog.log(tmpLog);
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz;
                if (DBG) {
                    log(tmpLog);
                }
                mTimeLog.log(tmpLog);
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#method_after
private void setTimeFromNITZString(String nitzString, long nitzReceiveTime) {
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        Rlog.d(LOG_TAG, "NITZ: " + nitzString + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    NitzData newNitzData = NitzData.parse(nitzString);
    if (newNitzData != null) {
        try {
            TimeStampedValue<NitzData> nitzSignal = new TimeStampedValue<>(newNitzData, nitzReceiveTime);
            mNitzState.handleNitzReceived(nitzSignal);
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                Rlog.d(LOG_TAG, "NITZ: end=" + end + " dur=" + (end - start));
            }
        }
    }
}
#end_block

#method_before
private void cancelAllNotifications() {
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancelAll();
}
#method_after
private void cancelAllNotifications() {
    if (DBG)
        log("setNotification: cancelAllNotifications");
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancel(PS_NOTIFICATION);
    notificationManager.cancel(CS_NOTIFICATION);
    notificationManager.cancel(CS_REJECT_CAUSE_NOTIFICATION);
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            if (mPhone.isPhoneTypeGsm() || mPhone.isPhoneTypeCdma() || mPhone.isPhoneTypeCdmaLte()) {
                int dds = SubscriptionManager.getDefaultDataSubscriptionId();
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    // hang up all active voice calls first
                    if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                        mPhone.mCT.mRingingCall.hangupIfAlive();
                        mPhone.mCT.mBackgroundCall.hangupIfAlive();
                        mPhone.mCT.mForegroundCall.hangupIfAlive();
                    }
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                        if (DBG)
                            log("Data is active on DDS.  Wait for all data disconnect");
                        // Data is not disconnected on DDS. Wait for the data disconnect complete
                        // before sending the RADIO_POWER off.
                        ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                        mPendingRadioPowerOffAfterDataOff = true;
                    }
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                        mPendingRadioPowerOffAfterDataOff = false;
                    }
                }
            } else {
                // In some network, deactivate PDP connection cause releasing of RRC connection,
                // which MM/IMSI detaching request needs. Without this detaching, network can
                // not release the network resources previously attached.
                // So we are avoiding data detaching on these networks.
                String[] networkNotClearData = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.networks_not_clear_data);
                String currentNetwork = mSS.getOperatorNumeric();
                if ((networkNotClearData != null) && (currentNetwork != null)) {
                    for (int i = 0; i < networkNotClearData.length; i++) {
                        if (currentNetwork.equals(networkNotClearData[i])) {
                            // Don't clear data connection for this carrier
                            if (DBG)
                                log("Not disconnecting data for " + currentNetwork);
                            hangupAndPowerOff();
                            return;
                        }
                    }
                }
                // both if else paths instead of before this isDisconnected test.
                if (dcTracker.isDisconnected()) {
                    // To minimize race conditions we do this after isDisconnected
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    if (DBG)
                        log("Data disconnected, turn off radio right away.");
                    hangupAndPowerOff();
                } else {
                    dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                    Message msg = Message.obtain(this);
                    msg.what = EVENT_SET_RADIO_POWER_OFF;
                    msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                    if (sendMessageDelayed(msg, 30000)) {
                        if (DBG)
                            log("Wait upto 30s for data to disconnect, then turn off radio.");
                        mPendingRadioPowerOffAfterDataOff = true;
                    } else {
                        log("Cannot send delayed Msg, turn off radio right away.");
                        hangupAndPowerOff();
                    }
                }
            }
        }
    }
}
#method_after
public void powerOffRadioSafely(DcTracker dcTracker) {
    synchronized (this) {
        if (!mPendingRadioPowerOffAfterDataOff) {
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            // both if else paths instead of before this isDisconnected test.
            if (dcTracker.isDisconnected() && (dds == mPhone.getSubId() || (dds != mPhone.getSubId() && ProxyController.getInstance().isDataDisconnected(dds)))) {
                // To minimize race conditions we do this after isDisconnected
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (DBG)
                    log("Data disconnected, turn off radio right away.");
                hangupAndPowerOff();
            } else {
                // hang up all active voice calls first
                if (mPhone.isPhoneTypeGsm() && mPhone.isInCall()) {
                    mPhone.mCT.mRingingCall.hangupIfAlive();
                    mPhone.mCT.mBackgroundCall.hangupIfAlive();
                    mPhone.mCT.mForegroundCall.hangupIfAlive();
                }
                dcTracker.cleanUpAllConnections(Phone.REASON_RADIO_TURNED_OFF);
                if (dds != mPhone.getSubId() && !ProxyController.getInstance().isDataDisconnected(dds)) {
                    if (DBG)
                        log("Data is active on DDS.  Wait for all data disconnect");
                    // Data is not disconnected on DDS. Wait for the data disconnect complete
                    // before sending the RADIO_POWER off.
                    ProxyController.getInstance().registerForAllDataDisconnected(dds, this, EVENT_ALL_DATA_DISCONNECTED, null);
                    mPendingRadioPowerOffAfterDataOff = true;
                }
                Message msg = Message.obtain(this);
                msg.what = EVENT_SET_RADIO_POWER_OFF;
                msg.arg1 = ++mPendingRadioPowerOffAfterDataOffTag;
                if (sendMessageDelayed(msg, 30000)) {
                    if (DBG)
                        log("Wait upto 30s for data to disconnect, then turn off radio.");
                    mPendingRadioPowerOffAfterDataOff = true;
                } else {
                    log("Cannot send delayed Msg, turn off radio right away.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                }
            }
        }
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        if (dataRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && voiceRat == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) {
            mSignalStrength.fixType();
        } else {
            mSignalStrength.setGsm(isGsm);
        }
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
        mSignalStrength.setUseOnlyRsrpForLteLevel(isUseOnlyRsrpForLteLevel());
        mSignalStrength.setLteRsrpThresholds(getLteRsrpThresholds());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
protected void hangupAndPowerOff() {
    // hang up all active voice calls
    if (!mPhone.isPhoneTypeGsm() || mPhone.isInCall()) {
        mPhone.mCT.mRingingCall.hangupIfAlive();
        mPhone.mCT.mBackgroundCall.hangupIfAlive();
        mPhone.mCT.mForegroundCall.hangupIfAlive();
    }
    mCi.setRadioPower(false, null);
}
#method_after
protected void hangupAndPowerOff() {
    // hang up all active voice calls
    if (!mPhone.isPhoneTypeGsm() || mPhone.isInCall()) {
        mPhone.mCT.mRingingCall.hangupIfAlive();
        mPhone.mCT.mBackgroundCall.hangupIfAlive();
        mPhone.mCT.mForegroundCall.hangupIfAlive();
    }
    mCi.setRadioPower(false, obtainMessage(EVENT_RADIO_POWER_OFF_DONE));
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.flush();
    mNitzState.dumpState(pw);
    pw.flush();
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    mNitzState.dumpLogs(fd, ipw, args);
}
#end_block

#method_before
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
}
#method_after
private void initOnce(CommandsInterface ci) {
    if (ci instanceof SimulatedRadioControl) {
        mSimulatedRadioControl = (SimulatedRadioControl) ci;
    }
    mCT = mTelephonyComponentFactory.makeGsmCdmaCallTracker(this);
    mIccPhoneBookIntManager = mTelephonyComponentFactory.makeIccPhoneBookInterfaceManager(this);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
    mIccSmsInterfaceManager = mTelephonyComponentFactory.makeIccSmsInterfaceManager(this);
    mIccCardProxy = mTelephonyComponentFactory.makeIccCardProxy(mContext, mCi, mPhoneId);
    mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
    mCi.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, null);
    mCi.registerForOn(this, EVENT_RADIO_ON, null);
    mCi.setOnSuppServiceNotification(this, EVENT_SSN, null);
    // GSM
    mCi.setOnUSSD(this, EVENT_USSD, null);
    mCi.setOnSs(this, EVENT_SS, null);
    // CDMA
    mCdmaSSM = mTelephonyComponentFactory.getCdmaSubscriptionSourceManagerInstance(mContext, mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
    mEriManager = mTelephonyComponentFactory.makeEriManager(this, mContext, EriManager.ERI_FROM_XML);
    mCi.setEmergencyCallbackMode(this, EVENT_EMERGENCY_CALLBACK_MODE_ENTER, null);
    mCi.registerForExitEmergencyCallbackMode(this, EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE, null);
    mCi.registerForModemReset(this, EVENT_MODEM_RESET, null);
    // get the string that specifies the carrier OTA Sp number
    mCarrierOtaSpNumSchema = TelephonyManager.from(mContext).getOtaSpNumberSchemaForPhone(getPhoneId(), "");
    mResetModemOnRadioTechnologyChange = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RESET_ON_RADIO_TECH_CHANGE, false);
    mCi.registerForRilConnected(this, EVENT_RIL_CONNECTED, null);
    mCi.registerForVoiceRadioTechChanged(this, EVENT_VOICE_RADIO_TECH_CHANGED, null);
    mContext.registerReceiver(mBroadcastReceiver, new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED));
    mCDM = new CarrierKeyDownloadManager(this);
}
#end_block

#method_before
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    logd("Precise phone type " + mPrecisePhoneType);
    TelephonyManager tm = TelephonyManager.from(mContext);
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
        // This is needed to handle phone process crashes
        mIsPhoneInEcmState = getInEcmMode();
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP) == null || isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
            if (!TextUtils.isEmpty(operatorAlpha)) {
                logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
                tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
            }
            if (!TextUtils.isEmpty(operatorNumeric)) {
                logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
                logd("update icc_operator_numeric=" + operatorNumeric);
                tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
                SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
                // Sets iso country property by retrieving from build-time system property
                setIsoCountryProperty(operatorNumeric);
                // Updates MCC MNC device configuration information
                logd("update mccmnc=" + operatorNumeric);
                MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
            }
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#method_after
private void initRatSpecific(int precisePhoneType) {
    mPendingMMIs.clear();
    mIccPhoneBookIntManager.updateIccRecords(null);
    mEsn = null;
    mMeid = null;
    mPrecisePhoneType = precisePhoneType;
    logd("Precise phone type " + mPrecisePhoneType);
    TelephonyManager tm = TelephonyManager.from(mContext);
    if (isPhoneTypeGsm()) {
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_GSM);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_GSM);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
        // This is needed to handle phone process crashes
        mIsPhoneInEcmState = getInEcmMode();
        if (mIsPhoneInEcmState) {
            // Send a message which will invoke handleExitEmergencyCallbackMode
            mCi.exitEmergencyCallbackMode(obtainMessage(EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE));
        }
        mCi.setPhoneType(PhoneConstants.PHONE_TYPE_CDMA);
        tm.setPhoneType(getPhoneId(), PhoneConstants.PHONE_TYPE_CDMA);
        mIccCardProxy.setVoiceRadioTech(ServiceState.RIL_RADIO_TECHNOLOGY_1xRTT);
        // Sets operator properties by retrieving from build-time system property
        String operatorAlpha = SystemProperties.get("ro.cdma.home.operator.alpha");
        String operatorNumeric = SystemProperties.get(PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
        logd("init: operatorAlpha='" + operatorAlpha + "' operatorNumeric='" + operatorNumeric + "'");
        if (!TextUtils.isEmpty(operatorAlpha)) {
            logd("init: set 'gsm.sim.operator.alpha' to operator='" + operatorAlpha + "'");
            tm.setSimOperatorNameForPhone(mPhoneId, operatorAlpha);
        }
        if (!TextUtils.isEmpty(operatorNumeric)) {
            logd("init: set 'gsm.sim.operator.numeric' to operator='" + operatorNumeric + "'");
            logd("update icc_operator_numeric=" + operatorNumeric);
            tm.setSimOperatorNumericForPhone(mPhoneId, operatorNumeric);
            SubscriptionController.getInstance().setMccMnc(operatorNumeric, getSubId());
            // Sets iso country property by retrieving from build-time system property
            setIsoCountryProperty(operatorNumeric);
            // Updates MCC MNC device configuration information
            logd("update mccmnc=" + operatorNumeric);
            MccTable.updateMccMncConfiguration(mContext, operatorNumeric, false);
        }
        // Sets current entry in the telephony carrier table
        updateCurrentCarrierInProvider(operatorNumeric);
    }
}
#end_block

#method_before
// override for allowing access from other classes of this package
@Override
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
    } else {
        super.setSystemProperty(property, value);
    }
}
#method_after
// override for allowing access from other classes of this package
@Override
public void setSystemProperty(String property, String value) {
    if (getUnitTestMode()) {
        return;
    }
    TelephonyManager.setTelephonyProperty(mPhoneId, property, value);
}
#end_block

#method_before
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    if (!isPhoneTypeGsm() && uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.isNonTtyOrTtyOnVolteEnabled(mContext) && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
    } else {
        return dialInternal(dialString, null, videoState, intentExtras);
    }
}
#method_after
@Override
public Connection dial(String dialString, UUSInfo uusInfo, int videoState, Bundle intentExtras) throws CallStateException {
    if (!isPhoneTypeGsm() && uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.getInstance(mContext, mPhoneId).isNonTtyOrTtyOnVolteEnabled() && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mPhoneId, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, uusInfo, videoState, intentExtras);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, null, VideoProfile.STATE_AUDIO_ONLY, intentExtras);
    } else {
        return dialInternal(dialString, null, videoState, intentExtras);
    }
}
#end_block

#method_before
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_telephony_use_own_number_for_voicemail)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#method_after
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null && b.getBoolean(CarrierConfigManager.KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#end_block

#method_before
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType);
}
#method_after
@Override
public ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int keyType) {
    return CarrierInfoManager.getCarrierInfoForImsiEncryption(keyType, mContext);
}
#end_block

#method_before
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo);
}
#method_after
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext);
}
#end_block

#method_before
@Override
public String getSystemProperty(String property, String defValue) {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        if (getUnitTestMode()) {
            return null;
        }
        return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
    } else {
        return super.getSystemProperty(property, defValue);
    }
}
#method_after
@Override
public String getSystemProperty(String property, String defValue) {
    if (getUnitTestMode()) {
        return null;
    }
    return TelephonyManager.getTelephonyProperty(mPhoneId, property, defValue);
}
#end_block

#method_before
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void getOutgoingCallerIdDisplay(Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.getOutgoingCallerIdDisplay(onComplete);
            return;
        }
        mCi.getCLIR(onComplete);
    } else {
        loge("getOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE)) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#method_after
@Override
public void setOutgoingCallerIdDisplay(int commandInterfaceCLIRMode, Message onComplete) {
    if (isPhoneTypeGsm()) {
        Phone imsPhone = mImsPhone;
        if ((imsPhone != null) && ((imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE) || imsPhone.isUtEnabled())) {
            imsPhone.setOutgoingCallerIdDisplay(commandInterfaceCLIRMode, onComplete);
            return;
        }
        // Packing CLIR value in the message. This will be required for
        // SharedPreference caching, if the message comes back as part of
        // a success response.
        mCi.setCLIR(commandInterfaceCLIRMode, obtainMessage(EVENT_SET_CLIR_COMPLETE, commandInterfaceCLIRMode, 0, onComplete));
    } else {
        loge("setOutgoingCallerIdDisplay: not possible in CDMA");
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.updateImsServiceConfig(mContext, mPhoneId, true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service
            ImsManager.getInstance(mContext, mPhoneId).updateImsServiceConfig(true);
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            if (!isPhoneTypeGsm()) {
                mSST.pollState();
            }
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            notifyCallForwardingIndicator();
            break;
    }
}
#method_after
private void processIccRecordEvents(int eventCode) {
    switch(eventCode) {
        case IccRecords.EVENT_CFI:
            logi("processIccRecordEvents: EVENT_CFI");
            notifyCallForwardingIndicator();
            break;
    }
}
#end_block

#method_before
@Override
public boolean updateCurrentCarrierInProvider() {
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
        String operatorNumeric = getOperatorNumeric();
        logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
        if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
            try {
                Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
                ContentValues map = new ContentValues();
                map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
                mContext.getContentResolver().insert(uri, map);
                return true;
            } catch (SQLException e) {
                Rlog.e(LOG_TAG, "Can't store current operator", e);
            }
        }
        return false;
    } else {
        return true;
    }
}
#method_after
@Override
public boolean updateCurrentCarrierInProvider() {
    long currentDds = SubscriptionManager.getDefaultDataSubscriptionId();
    String operatorNumeric = getOperatorNumeric();
    logd("updateCurrentCarrierInProvider: mSubId = " + getSubId() + " currentDds = " + currentDds + " operatorNumeric = " + operatorNumeric);
    if (!TextUtils.isEmpty(operatorNumeric) && (getSubId() == currentDds)) {
        try {
            Uri uri = Uri.withAppendedPath(Telephony.Carriers.CONTENT_URI, "current");
            ContentValues map = new ContentValues();
            map.put(Telephony.Carriers.NUMERIC, operatorNumeric);
            mContext.getContentResolver().insert(uri, map);
            return true;
        } catch (SQLException e) {
            Rlog.e(LOG_TAG, "Can't store current operator", e);
        }
    }
    return false;
}
#end_block

#method_before
protected void copyFrom(SignalStrength s) {
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mLteRsrpBoost = s.mLteRsrpBoost;
    mTdScdmaRscp = s.mTdScdmaRscp;
    isGsm = s.isGsm;
}
#method_after
protected void copyFrom(SignalStrength s) {
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mTdScdmaRscp = s.mTdScdmaRscp;
    mLteRsrpBoost = s.mLteRsrpBoost;
    mIsGsm = s.mIsGsm;
    mUseOnlyRsrpForLteLevel = s.mUseOnlyRsrpForLteLevel;
    setLteRsrpThresholds(s.mLteRsrpThresholds);
}
#end_block

#method_before
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mLteRsrpBoost);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(isGsm ? 1 : 0);
}
#method_after
public void writeToParcel(Parcel out, int flags) {
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(mLteRsrpBoost);
    out.writeBoolean(mIsGsm);
    out.writeBoolean(mUseOnlyRsrpForLteLevel);
    out.writeIntArray(mLteRsrpThresholds);
}
#end_block

#method_before
public void setGsm(boolean gsmFlag) {
    isGsm = gsmFlag;
}
#method_after
public void setGsm(boolean gsmFlag) {
    mIsGsm = gsmFlag;
}
#end_block

#method_before
public int getLevel() {
    int level = 0;
    if (isGsm) {
        level = getLteLevel();
        if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            level = getTdScdmaLevel();
            if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                level = getGsmLevel();
            }
        }
    } else {
        int cdmaLevel = getCdmaLevel();
        int evdoLevel = getEvdoLevel();
        if (evdoLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know evdo, use cdma */
            level = cdmaLevel;
        } else if (cdmaLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know cdma, use evdo */
            level = evdoLevel;
        } else {
            /* We know both, use the lowest level */
            level = cdmaLevel < evdoLevel ? cdmaLevel : evdoLevel;
        }
    }
    if (DBG)
        log("getLevel=" + level);
    return level;
}
#method_after
public int getLevel() {
    int level = mIsGsm ? getGsmRelatedSignalStrength() : getCdmaRelatedSignalStrength();
    if (DBG)
        log("getLevel=" + level);
    return level;
}
#end_block

#method_before
public int getAsuLevel() {
    int asuLevel = 0;
    if (isGsm) {
        if (mLteRsrp == SignalStrength.INVALID) {
            if (mTdScdmaRscp == SignalStrength.INVALID) {
                asuLevel = getGsmAsuLevel();
            } else {
                asuLevel = getTdScdmaAsuLevel();
            }
        } else {
            asuLevel = getLteAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
#method_after
public int getAsuLevel() {
    int asuLevel = 0;
    if (mIsGsm) {
        if (mLteRsrp != SignalStrength.INVALID) {
            asuLevel = getLteAsuLevel();
        } else if (mTdScdmaRscp != SignalStrength.INVALID) {
            asuLevel = getTdScdmaAsuLevel();
        } else {
            asuLevel = getGsmAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
#end_block

#method_before
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5]) {
            rsrpIconLevel = -1;
        } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mLteRsrp >= (threshRsrp[3] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mLteRsrp >= (threshRsrp[2] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mLteRsrp >= (threshRsrp[1] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        } else if (mLteRsrp >= threshRsrp[0]) {
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#method_after
public int getLteLevel() {
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > mLteRsrpThresholds[5]) {
        rsrpIconLevel = -1;
    } else if (mLteRsrp >= (mLteRsrpThresholds[4] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    } else if (mLteRsrp >= (mLteRsrpThresholds[3] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    } else if (mLteRsrp >= (mLteRsrpThresholds[2] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    } else if (mLteRsrp >= (mLteRsrpThresholds[1] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    } else if (mLteRsrp >= mLteRsrpThresholds[0]) {
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    }
    if (useOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
#end_block

#method_before
public boolean isGsm() {
    return this.isGsm;
}
#method_after
public boolean isGsm() {
    return this.mIsGsm;
}
#end_block

#method_before
@Override
public int hashCode() {
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mLteRsrpBoost * primeNum) + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
}
#method_after
@Override
public int hashCode() {
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mLteRsrpBoost * primeNum) + (mTdScdmaRscp * primeNum) + (mIsGsm ? 1 : 0) + (mUseOnlyRsrpForLteLevel ? 1 : 0) + (Arrays.hashCode(mLteRsrpThresholds)));
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mLteRsrpBoost == s.mLteRsrpBoost && mTdScdmaRscp == s.mTdScdmaRscp && isGsm == s.isGsm);
}
#method_after
@Override
public boolean equals(Object o) {
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mLteRsrpBoost == s.mLteRsrpBoost && mTdScdmaRscp == s.mTdScdmaRscp && mIsGsm == s.mIsGsm && mUseOnlyRsrpForLteLevel == s.mUseOnlyRsrpForLteLevel && Arrays.equals(mLteRsrpThresholds, s.mLteRsrpThresholds));
}
#end_block

#method_before
@Override
public String toString() {
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma"));
}
#method_after
@Override
public String toString() {
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (mIsGsm ? "gsm|lte" : "cdma") + " " + (mUseOnlyRsrpForLteLevel ? "use_only_rsrp_for_lte_level" : "use_rsrp_and_rssnr_for_lte_level") + " " + (Arrays.toString(mLteRsrpThresholds)));
}
#end_block

#method_before
private void setFromNotifierBundle(Bundle m) {
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mLteRsrpBoost = m.getInt("lteRsrpBoost");
    mTdScdmaRscp = m.getInt("TdScdma");
    isGsm = m.getBoolean("isGsm");
}
#method_after
private void setFromNotifierBundle(Bundle m) {
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mLteRsrpBoost = m.getInt("LteRsrpBoost");
    mTdScdmaRscp = m.getInt("TdScdma");
    mIsGsm = m.getBoolean("IsGsm");
    mUseOnlyRsrpForLteLevel = m.getBoolean("UseOnlyRsrpForLteLevel");
    ArrayList<Integer> lteRsrpThresholds = m.getIntegerArrayList("lteRsrpThresholds");
    for (int i = 0; i < lteRsrpThresholds.size(); i++) {
        mLteRsrpThresholds[i] = lteRsrpThresholds.get(i);
    }
}
#end_block

#method_before
public void fillInNotifierBundle(Bundle m) {
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("lteRsrpBoost", mLteRsrpBoost);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", isGsm);
}
#method_after
public void fillInNotifierBundle(Bundle m) {
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("LteRsrpBoost", mLteRsrpBoost);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("IsGsm", mIsGsm);
    m.putBoolean("UseOnlyRsrpForLteLevel", mUseOnlyRsrpForLteLevel);
    ArrayList<Integer> lteRsrpThresholds = new ArrayList<Integer>();
    for (int value : mLteRsrpThresholds) {
        lteRsrpThresholds.add(value);
    }
    m.putIntegerArrayList("lteRsrpThresholds", lteRsrpThresholds);
}
#end_block

#method_before
public UiccSlot getUiccSlotForCardId(String cardId) {
    synchronized (mLock) {
        // first look up based on cardId
        for (UiccSlot uiccSlot : mUiccSlots) {
            if (uiccSlot != null) {
                UiccCard uiccCard = uiccSlot.getUiccCard();
                if (uiccCard != null) {
                    // if (cardId.equals(uiccCard.getCardId())) {
                    if (false) {
                        return uiccSlot;
                    }
                }
            }
        }
        // if a match is not found, do a lookup based on ICCID
        for (UiccSlot uiccSlot : mUiccSlots) {
            if (uiccSlot != null && cardId.equals(uiccSlot.getIccId())) {
                return uiccSlot;
            }
        }
        return null;
    }
}
#method_after
public int getUiccSlotForCardId(String cardId) {
    synchronized (mLock) {
        // first look up based on cardId
        for (int idx = 0; idx < mUiccSlots.length; idx++) {
            if (mUiccSlots[idx] != null) {
                UiccCard uiccCard = mUiccSlots[idx].getUiccCard();
                if (uiccCard != null) {
                    // if (cardId.equals(uiccCard.getCardId())) {
                    if (false) {
                        return idx;
                    }
                }
            }
        }
        // if a match is not found, do a lookup based on ICCID
        for (int idx = 0; idx < mUiccSlots.length; idx++) {
            if (mUiccSlots[idx] != null && cardId.equals(mUiccSlots[idx].getIccId())) {
                return idx;
            }
        }
        return INVALID_SLOT_ID;
    }
}
#end_block

#method_before
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            Rlog.e(LOG_TAG, "Unexpected error getting slot status.", ar.exception);
        } else {
            // REQUEST_NOT_SUPPORTED
            log("onGetSlotStatusDone: request not supported; marking mIsSlotStatusSupported " + "to false");
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    if (!slotStatusChanged(status)) {
        log("onGetSlotStatusDone: No change in slot status");
        return;
    }
    int numActiveSlots = 0;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidCardIndex(iss.logicalSlotIndex)) {
                throw new RuntimeException("Logical slot index " + iss.logicalSlotIndex + " invalid for physical slot " + i);
            }
            mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss);
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        throw new RuntimeException("Number of active slots " + numActiveSlots + " does not match the expected value " + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to multiple phoneIds");
        }
        slotIds.add(slotId);
    }
    // broadcast slot status changed
    Intent intent = new Intent(Intent.ACTION_SIM_SLOT_STATUS_CHANGED);
    mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
}
#method_after
private synchronized void onGetSlotStatusDone(AsyncResult ar) {
    if (!mIsSlotStatusSupported) {
        if (VDBG)
            log("onGetSlotStatusDone: ignoring since mIsSlotStatusSupported is false");
        return;
    }
    Throwable e = ar.exception;
    if (e != null) {
        if (!(e instanceof CommandException) || ((CommandException) e).getCommandError() != CommandException.Error.REQUEST_NOT_SUPPORTED) {
            // this is not expected; there should be no exception other than
            // REQUEST_NOT_SUPPORTED
            Rlog.e(LOG_TAG, "Unexpected error getting slot status.", ar.exception);
        } else {
            // REQUEST_NOT_SUPPORTED
            log("onGetSlotStatusDone: request not supported; marking mIsSlotStatusSupported " + "to false");
            mIsSlotStatusSupported = false;
        }
        return;
    }
    ArrayList<IccSlotStatus> status = (ArrayList<IccSlotStatus>) ar.result;
    if (!slotStatusChanged(status)) {
        log("onGetSlotStatusDone: No change in slot status");
        return;
    }
    int numActiveSlots = 0;
    for (int i = 0; i < status.size(); i++) {
        IccSlotStatus iss = status.get(i);
        boolean isActive = (iss.slotState == IccSlotStatus.SlotState.SLOTSTATE_ACTIVE);
        if (isActive) {
            numActiveSlots++;
            // sanity check: logicalSlotIndex should be valid for an active slot
            if (!isValidCardIndex(iss.logicalSlotIndex)) {
                throw new RuntimeException("Logical slot index " + iss.logicalSlotIndex + " invalid for physical slot " + i);
            }
            mPhoneIdToSlotId[iss.logicalSlotIndex] = i;
        }
        if (mUiccSlots[i] == null) {
            if (VDBG) {
                log("Creating mUiccSlot[" + i + "]; mUiccSlots.length = " + mUiccSlots.length);
            }
            mUiccSlots[i] = new UiccSlot(mContext, isActive);
        }
        mUiccSlots[i].update(isActive ? mCis[iss.logicalSlotIndex] : null, iss);
    }
    if (VDBG)
        logPhoneIdToSlotIdMapping();
    // sanity check: number of active slots should be valid
    if (numActiveSlots != mPhoneIdToSlotId.length) {
        throw new RuntimeException("Number of active slots " + numActiveSlots + " does not match the expected value " + mPhoneIdToSlotId.length);
    }
    // sanity check: slotIds should be unique in mPhoneIdToSlotId
    Set<Integer> slotIds = new HashSet<>();
    for (int slotId : mPhoneIdToSlotId) {
        if (slotIds.contains(slotId)) {
            throw new RuntimeException("slotId " + slotId + " mapped to multiple phoneIds");
        }
        slotIds.add(slotId);
    }
    // broadcast slot status changed
    Intent intent = new Intent(TelephonyManager.ACTION_SIM_SLOT_STATUS_CHANGED);
    mContext.sendBroadcast(intent, android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
}
#end_block

#method_before
public int ioctlInt(FileDescriptor fd, int cmd, MutableInt arg) throws ErrnoException {
    return os.ioctlInt(fd, cmd, arg);
}
#method_after
public int ioctlInt(FileDescriptor fd, int cmd, Int32Ref arg) throws ErrnoException {
    return os.ioctlInt(fd, cmd, arg);
}
#end_block

#method_before
public long sendfile(FileDescriptor outFd, FileDescriptor inFd, MutableLong inOffset, long byteCount) throws ErrnoException {
    return os.sendfile(outFd, inFd, inOffset, byteCount);
}
#method_after
public long sendfile(FileDescriptor outFd, FileDescriptor inFd, Int64Ref offset, long byteCount) throws ErrnoException {
    return os.sendfile(outFd, inFd, offset, byteCount);
}
#end_block

#method_before
public long splice(FileDescriptor fdIn, MutableLong offIn, FileDescriptor fdOut, MutableLong offOut, long len, int flags) throws ErrnoException {
    return os.splice(fdIn, offIn, fdOut, offOut, len, flags);
}
#method_after
public long splice(FileDescriptor fdIn, Int64Ref offIn, FileDescriptor fdOut, Int64Ref offOut, long len, int flags) throws ErrnoException {
    return os.splice(fdIn, offIn, fdOut, offOut, len, flags);
}
#end_block

#method_before
public int waitpid(int pid, MutableInt status, int options) throws ErrnoException {
    return os.waitpid(pid, status, options);
}
#method_after
public int waitpid(int pid, Int32Ref status, int options) throws ErrnoException {
    return os.waitpid(pid, status, options);
}
#end_block

#method_before
public void test_sendfile_errno() throws Exception {
    try {
        // FileDescriptor.out is not open for input, will cause EBADF
        MutableLong offset = new MutableLong(10);
        Libcore.os.sendfile(FileDescriptor.out, FileDescriptor.out, offset, 10);
        fail();
    } catch (ErrnoException expected) {
    }
}
#method_after
public void test_sendfile_errno() throws Exception {
    try {
        // FileDescriptor.out is not open for input, will cause EBADF
        Int64Ref offset = new Int64Ref(10);
        Libcore.os.sendfile(FileDescriptor.out, FileDescriptor.out, offset, 10);
        fail();
    } catch (ErrnoException expected) {
    }
}
#end_block

#method_before
private static String checkSendfile(SendFileImpl sendFileImplToUse, File in, Long startOffset, int maxBytes, Long expectedEndOffset) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName() + "_checkSendFile_" + sendFileImplToUse, ".out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            switch(sendFileImplToUse) {
                case ANDROID_SYSTEM_OS_INT64_REF:
                    {
                        Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
                        android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                case LIBCORE_OS:
                    {
                        libcore.util.MutableLong offset = (startOffset == null) ? null : new libcore.util.MutableLong(startOffset);
                        libcore.io.Libcore.os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                default:
                    {
                        fail();
                        break;
                    }
            }
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#method_after
private static String checkSendfile(SendFileImpl sendFileImplToUse, File in, Long startOffset, int maxBytes, Long expectedEndOffset) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName() + "_checkSendFile_" + sendFileImplToUse, ".out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            switch(sendFileImplToUse) {
                case ANDROID_SYSTEM_OS_INT64_REF:
                    {
                        Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
                        android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                case LIBCORE_OS:
                    {
                        Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
                        libcore.io.Libcore.os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                default:
                    {
                        fail();
                        break;
                    }
            }
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#end_block

#method_before
public void test_splice() throws Exception {
    FileDescriptor[] pipe = Libcore.os.pipe2(0);
    File in = createTempFile("splice1", "foobar");
    File out = createTempFile("splice2", "");
    MutableLong inOff = new MutableLong(1);
    MutableLong outOff = new MutableLong(0);
    // Splice into pipe
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        long result = Libcore.os.splice(inFd, inOff, pipe[1], null, 5, 0);
        assertEquals(5, result);
        assertEquals(6, inOff.value);
    }
    // Splice from pipe
    try (FileOutputStream outStream = new FileOutputStream(out)) {
        FileDescriptor outFd = outStream.getFD();
        long result = Libcore.os.splice(pipe[0], null, outFd, outOff, 5, 0);
        assertEquals(5, result);
        assertEquals(5, outOff.value);
    }
    assertEquals("oobar", IoUtils.readFileAsString(out.getPath()));
}
#method_after
public void test_splice() throws Exception {
    FileDescriptor[] pipe = Libcore.os.pipe2(0);
    File in = createTempFile("splice1", "foobar");
    File out = createTempFile("splice2", "");
    Int64Ref offIn = new Int64Ref(1);
    Int64Ref offOut = new Int64Ref(0);
    // Splice into pipe
    try (FileInputStream streamIn = new FileInputStream(in)) {
        FileDescriptor fdIn = streamIn.getFD();
        long result = Libcore.os.splice(fdIn, offIn, pipe[1], null, /* offOut */
        10, /* len */
        0);
        assertEquals(5, result);
        assertEquals(6, offIn.value);
    }
    // Splice from pipe
    try (FileOutputStream streamOut = new FileOutputStream(out)) {
        FileDescriptor fdOut = streamOut.getFD();
        long result = Libcore.os.splice(pipe[0], null, /* offIn */
        fdOut, offOut, 10, /* len */
        0);
        assertEquals(5, result);
        assertEquals(5, offOut.value);
    }
    assertEquals("oobar", IoUtils.readFileAsString(out.getPath()));
    Libcore.os.close(pipe[0]);
    Libcore.os.close(pipe[1]);
}
#end_block

#method_before
public static int ioctlInt(FileDescriptor fd, int cmd, Int32Ref arg) throws ErrnoException {
    libcore.util.MutableInt internalArg = new libcore.util.MutableInt(arg.value);
    try {
        return Libcore.os.ioctlInt(fd, cmd, internalArg);
    } finally {
        arg.value = internalArg.value;
    }
}
#method_after
public static int ioctlInt(FileDescriptor fd, int cmd, Int32Ref arg) throws ErrnoException {
    return Libcore.os.ioctlInt(fd, cmd, arg);
}
#end_block

#method_before
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, Int64Ref inOffset, long byteCount) throws ErrnoException {
    if (inOffset == null) {
        return Libcore.os.sendfile(outFd, inFd, null, byteCount);
    } else {
        libcore.util.MutableLong internalInOffset = new libcore.util.MutableLong(inOffset.value);
        try {
            return Libcore.os.sendfile(outFd, inFd, internalInOffset, byteCount);
        } finally {
            inOffset.value = internalInOffset.value;
        }
    }
}
#method_after
public static long sendfile(FileDescriptor outFd, FileDescriptor inFd, Int64Ref offset, long byteCount) throws ErrnoException {
    return Libcore.os.sendfile(outFd, inFd, offset, byteCount);
}
#end_block

#method_before
public static long splice(FileDescriptor fdIn, Int64Ref offIn, FileDescriptor fdOut, Int64Ref offOut, long len, int flags) throws ErrnoException {
    libcore.util.MutableLong internalOffIn = (offIn == null) ? null : new libcore.util.MutableLong(offIn.value);
    libcore.util.MutableLong internalOffOut = (offOut == null) ? null : new libcore.util.MutableLong(offOut.value);
    try {
        return Libcore.os.splice(fdIn, internalOffIn, fdOut, internalOffOut, len, flags);
    } finally {
        if (offIn != null) {
            offIn.value = internalOffIn.value;
        }
        if (offOut != null) {
            offOut.value = internalOffOut.value;
        }
    }
}
#method_after
public static long splice(FileDescriptor fdIn, Int64Ref offIn, FileDescriptor fdOut, Int64Ref offOut, long len, int flags) throws ErrnoException {
    return Libcore.os.splice(fdIn, offIn, fdOut, offOut, len, flags);
}
#end_block

#method_before
public static int waitpid(int pid, Int32Ref status, int options) throws ErrnoException {
    if (status == null) {
        return Libcore.os.waitpid(pid, null, options);
    } else {
        libcore.util.MutableInt internalStatus = new libcore.util.MutableInt(status.value);
        try {
            return Libcore.os.waitpid(pid, internalStatus, options);
        } finally {
            status.value = internalStatus.value;
        }
    }
}
#method_after
public static int waitpid(int pid, Int32Ref status, int options) throws ErrnoException {
    return Libcore.os.waitpid(pid, status, options);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null);
            broadcastSimCardStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            broadcastSimApplicationStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimCardStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimApplicationStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
            break;
        case EVENT_SIM_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_READY, null);
            broadcastSimCardStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
            break;
        case EVENT_SIM_IMSI:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
            break;
        case EVENT_SIM_NOT_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
            broadcastSimCardStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_GET_NETWORK_SELECTION_MODE_DONE:
            {
                AsyncResult ar = (AsyncResult) msg.obj;
                Integer slotId = (Integer) ar.userObj;
                if (ar.exception == null && ar.result != null) {
                    int[] modes = (int[]) ar.result;
                    if (modes[0] == 1) {
                        // Manual mode.
                        mPhone[slotId].setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    logd("EVENT_GET_NETWORK_SELECTION_MODE_DONE: error getting network mode.");
                }
                break;
            }
        case EVENT_SIM_LOADED:
            handleSimLoaded(msg.arg1);
            break;
        case EVENT_SIM_ABSENT:
            handleSimAbsent(msg.arg1);
            break;
        case EVENT_SIM_LOCKED:
            handleSimLocked(msg.arg1, (String) msg.obj);
            break;
        case EVENT_SIM_UNKNOWN:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_UNKNOWN, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_UNKNOWN);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_UNKNOWN);
            break;
        case EVENT_SIM_IO_ERROR:
            handleSimError(msg.arg1);
            break;
        case EVENT_SIM_RESTRICTED:
            updateCarrierServices(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED, IccCardConstants.INTENT_VALUE_ICC_CARD_RESTRICTED);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_CARD_RESTRICTED);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
            break;
        case EVENT_SIM_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_READY, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
            break;
        case EVENT_SIM_IMSI:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_IMSI, null);
            break;
        case EVENT_SIM_NOT_READY:
            broadcastSimStateChanged(msg.arg1, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
            broadcastSimCardStateChanged(msg.arg1, TelephonyManager.SIM_STATE_PRESENT);
            broadcastSimApplicationStateChanged(msg.arg1, TelephonyManager.SIM_STATE_NOT_READY);
        case EVENT_REFRESH_EMBEDDED_SUBSCRIPTIONS:
            if (updateEmbeddedSubscriptions()) {
                SubscriptionController.getInstance().notifySubscriptionInfoChanged();
            }
            if (msg.obj != null) {
                ((Runnable) msg.obj).run();
            }
            break;
        default:
            logd("Unknown msg:" + msg.what);
    }
}
#end_block

#method_before
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    String iccId = mIccId[slotId];
    if (iccId == null) {
        IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
        if (stripIccIdSuffix(records.getFullIccId()) == null) {
            logd("handleSimLocked: IccID null");
            return;
        }
        mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    } else {
        logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
    }
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
    broadcastSimCardStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_PRESENT);
    broadcastSimApplicationStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
}
#method_after
private void handleSimLocked(int slotId, String reason) {
    if (mIccId[slotId] != null && mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug in");
        mIccId[slotId] = null;
    }
    String iccId = mIccId[slotId];
    if (iccId == null) {
        IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
        if (stripIccIdSuffix(records.getFullIccId()) == null) {
            logd("handleSimLocked: IccID null");
            return;
        }
        mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    } else {
        logd("NOT Querying IccId its already set sIccid[" + slotId + "]=" + iccId);
    }
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_LOCKED, reason);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_PRESENT);
    broadcastSimApplicationStateChanged(slotId, getSimStateFromLockedReason(reason));
}
#end_block

#method_before
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (stripIccIdSuffix(records.getFullIccId()) == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                ContentValues number = new ContentValues(1);
                number.put(SubscriptionManager.NUMBER, msisdn);
                contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            ContentValues name = new ContentValues(1);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
                logd("sim name = " + nameToSet);
                contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    broadcastSimCardStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_PRESENT);
    broadcastSimApplicationStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#method_after
private void handleSimLoaded(int slotId) {
    logd("handleSimLoaded: slotId: " + slotId);
    // The SIM should be loaded at this state, but it is possible in cases such as SIM being
    // removed or a refresh RESET that the IccRecords could be null. The right behavior is to
    // not broadcast the SIM loaded.
    int loadedSlotId = slotId;
    IccRecords records = mPhone[slotId].getIccCard().getIccRecords();
    if (records == null) {
        // Possibly a race condition.
        logd("handleSimLoaded: IccRecords null");
        return;
    }
    if (stripIccIdSuffix(records.getFullIccId()) == null) {
        logd("handleSimLoaded: IccID null");
        return;
    }
    mIccId[slotId] = stripIccIdSuffix(records.getFullIccId());
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
        int[] subIds = mSubscriptionManager.getActiveSubscriptionIdList();
        for (int subId : subIds) {
            TelephonyManager tm = TelephonyManager.getDefault();
            String operator = tm.getSimOperatorNumeric(subId);
            slotId = SubscriptionController.getInstance().getPhoneId(subId);
            if (!TextUtils.isEmpty(operator)) {
                if (subId == SubscriptionController.getInstance().getDefaultSubId()) {
                    MccTable.updateMccMncConfiguration(mContext, operator, false);
                }
                SubscriptionController.getInstance().setMccMnc(operator, subId);
            } else {
                logd("EVENT_RECORDS_LOADED Operator name is null");
            }
            String msisdn = tm.getLine1Number(subId);
            ContentResolver contentResolver = mContext.getContentResolver();
            if (msisdn != null) {
                ContentValues number = new ContentValues(1);
                number.put(SubscriptionManager.NUMBER, msisdn);
                contentResolver.update(SubscriptionManager.CONTENT_URI, number, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
            String nameToSet;
            String simCarrierName = tm.getSimOperatorName(subId);
            ContentValues name = new ContentValues(1);
            if (subInfo != null && subInfo.getNameSource() != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                if (!TextUtils.isEmpty(simCarrierName)) {
                    nameToSet = simCarrierName;
                } else {
                    nameToSet = "CARD " + Integer.toString(slotId + 1);
                }
                name.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
                logd("sim name = " + nameToSet);
                contentResolver.update(SubscriptionManager.CONTENT_URI, name, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                // refresh Cached Active Subscription Info List
                SubscriptionController.getInstance().refreshCachedActiveSubscriptionInfoList();
            }
            /* Update preferred network type and network selection mode on SIM change.
                 * Storing last subId in SharedPreference for now to detect SIM change. */
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);
            int storedSubId = sp.getInt(CURR_SUBID + slotId, -1);
            if (storedSubId != subId) {
                int networkType = RILConstants.PREFERRED_NETWORK_MODE;
                // Set the modem network mode
                mPhone[slotId].setPreferredNetworkType(networkType, null);
                Settings.Global.putInt(mPhone[slotId].getContext().getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE + subId, networkType);
                // Only support automatic selection mode on SIM change.
                mPhone[slotId].getNetworkSelectionMode(obtainMessage(EVENT_GET_NETWORK_SELECTION_MODE_DONE, new Integer(slotId)));
                // Update stored subId
                SharedPreferences.Editor editor = sp.edit();
                editor.putInt(CURR_SUBID + slotId, subId);
                editor.apply();
            }
        }
    }
    // Update set of enabled carrier apps now that the privilege rules may have changed.
    CarrierAppUtils.disableCarrierAppsUntilPrivileged(mContext.getOpPackageName(), mPackageManager, TelephonyManager.getDefault(), mContext.getContentResolver(), mCurrentlyActiveUserId);
    broadcastSimStateChanged(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED, null);
    broadcastSimCardStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_PRESENT);
    broadcastSimApplicationStateChanged(loadedSlotId, TelephonyManager.SIM_STATE_LOADED);
    updateCarrierServices(loadedSlotId, IccCardConstants.INTENT_VALUE_ICC_LOADED);
}
#end_block

#method_before
private void handleSimAbsent(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug out");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT, null);
    broadcastSimCardStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
    broadcastSimApplicationStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
}
#method_after
private void handleSimAbsent(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " hot plug out");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_ABSENT, null);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_ABSENT);
    broadcastSimApplicationStateChanged(slotId, TelephonyManager.SIM_STATE_NOT_READY);
}
#end_block

#method_before
private void handleSimError(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " Error ");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimCardStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimApplicationStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_NOT_READY, null);
}
#method_after
private void handleSimError(int slotId) {
    if (mIccId[slotId] != null && !mIccId[slotId].equals(ICCID_STRING_FOR_NO_SIM)) {
        logd("SIM" + (slotId + 1) + " Error ");
    }
    mIccId[slotId] = ICCID_STRING_FOR_NO_SIM;
    if (isAllIccIdQueryDone()) {
        updateSubscriptionInfoByIccId();
    }
    updateCarrierServices(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimStateChanged(slotId, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR, IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR);
    broadcastSimCardStateChanged(slotId, TelephonyManager.SIM_STATE_CARD_IO_ERROR);
    broadcastSimApplicationStateChanged(slotId, TelephonyManager.SIM_STATE_NOT_READY);
}
#end_block

#method_before
private void broadcastSimCardStateChanged(int phoneId, String state) {
    if (!state.equals(sSimCardState[phoneId])) {
        sSimCardState[phoneId] = state;
        Intent i = new Intent(Intent.ACTION_SIM_CARD_STATE_CHANGED);
        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        i.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, state);
        SubscriptionManager.putPhoneIdAndSubIdExtra(i, phoneId);
        logd("Broadcasting intent ACTION_SIM_CARD_STATE_CHANGED " + state + " for phone: " + phoneId);
        ActivityManager.broadcastStickyIntent(i, UserHandle.USER_ALL);
    }
}
#method_after
private void broadcastSimCardStateChanged(int phoneId, int state) {
    if (state != sSimCardState[phoneId]) {
        sSimCardState[phoneId] = state;
        Intent i = new Intent(Intent.ACTION_SIM_CARD_STATE_CHANGED);
        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        i.putExtra(TelephonyManager.EXTRA_SIM_STATE, state);
        SubscriptionManager.putPhoneIdAndSubIdExtra(i, phoneId);
        logd("Broadcasting intent ACTION_SIM_CARD_STATE_CHANGED " + simStateString(state) + " for phone: " + phoneId);
        mContext.sendBroadcast(i, Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
    }
}
#end_block

#method_before
private void broadcastSimApplicationStateChanged(int phoneId, String state, String reason) {
    if (!state.equals(sSimApplicationState[phoneId])) {
        sSimApplicationState[phoneId] = state;
        Intent i = new Intent(Intent.ACTION_SIM_APPLICATION_STATE_CHANGED);
        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        i.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, state);
        i.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
        SubscriptionManager.putPhoneIdAndSubIdExtra(i, phoneId);
        logd("Broadcasting intent ACTION_SIM_APPLICATION_STATE_CHANGED " + state + " reason " + reason + " for phone: " + phoneId);
        IntentBroadcaster.getInstance().broadcastStickyIntent(i, UserHandle.USER_ALL);
    }
}
#method_after
private void broadcastSimApplicationStateChanged(int phoneId, int state) {
    // after SIM is PRESENT
    if (!(state == sSimApplicationState[phoneId] || (state == TelephonyManager.SIM_STATE_NOT_READY && sSimApplicationState[phoneId] == TelephonyManager.SIM_STATE_UNKNOWN))) {
        sSimApplicationState[phoneId] = state;
        Intent i = new Intent(Intent.ACTION_SIM_APPLICATION_STATE_CHANGED);
        i.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        i.putExtra(TelephonyManager.EXTRA_SIM_STATE, state);
        SubscriptionManager.putPhoneIdAndSubIdExtra(i, phoneId);
        logd("Broadcasting intent ACTION_SIM_APPLICATION_STATE_CHANGED " + simStateString(state) + " for phone: " + phoneId);
        mContext.sendBroadcast(i, Manifest.permission.READ_PRIVILEGED_PHONE_STATE);
    }
}
#end_block

#method_before
private SubscriptionInfo getSubInfoRecord(Cursor cursor) {
    int id = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
    String iccId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.ICC_ID));
    int simSlotIndex = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.SIM_SLOT_INDEX));
    String displayName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.DISPLAY_NAME));
    String carrierName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARRIER_NAME));
    int nameSource = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.NAME_SOURCE));
    int iconTint = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.COLOR));
    String number = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.NUMBER));
    int dataRoaming = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.DATA_ROAMING));
    // Get the blank bitmap for this SubInfoRecord
    Bitmap iconBitmap = BitmapFactory.decodeResource(mContext.getResources(), com.android.internal.R.drawable.ic_sim_card_multi_24px_clr);
    int mcc = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.MCC));
    int mnc = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.MNC));
    String cardId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARD_ID));
    // FIXME: consider stick this into database too
    String countryIso = getSubscriptionCountryIso(id);
    boolean isEmbedded = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_EMBEDDED)) == 1;
    UiccAccessRule[] accessRules;
    if (isEmbedded) {
        accessRules = UiccAccessRule.decodeRules(cursor.getBlob(cursor.getColumnIndexOrThrow(SubscriptionManager.ACCESS_RULES)));
    } else {
        accessRules = null;
    }
    if (VDBG) {
        String iccIdToPrint = SubscriptionInfo.givePrintableIccid(iccId);
        String cardIdToPrint = SubscriptionInfo.givePrintableIccid(cardId);
        logd("[getSubInfoRecord] id:" + id + " iccid:" + iccIdToPrint + " simSlotIndex:" + simSlotIndex + " displayName:" + displayName + " nameSource:" + nameSource + " iconTint:" + iconTint + " dataRoaming:" + dataRoaming + " mcc:" + mcc + " mnc:" + mnc + " countIso:" + countryIso + " isEmbedded:" + isEmbedded + " accessRules:" + Arrays.toString(accessRules) + " cardid:" + cardIdToPrint);
    }
    // If line1number has been set to a different number, use it instead.
    String line1Number = mTelephonyManager.getLine1Number(id);
    if (!TextUtils.isEmpty(line1Number) && !line1Number.equals(number)) {
        number = line1Number;
    }
    return new SubscriptionInfo(id, iccId, simSlotIndex, displayName, carrierName, nameSource, iconTint, number, dataRoaming, iconBitmap, mcc, mnc, countryIso, isEmbedded, accessRules, cardId);
}
#method_after
private SubscriptionInfo getSubInfoRecord(Cursor cursor) {
    int id = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
    String iccId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.ICC_ID));
    int simSlotIndex = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.SIM_SLOT_INDEX));
    String displayName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.DISPLAY_NAME));
    String carrierName = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARRIER_NAME));
    int nameSource = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.NAME_SOURCE));
    int iconTint = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.COLOR));
    String number = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.NUMBER));
    int dataRoaming = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.DATA_ROAMING));
    // Get the blank bitmap for this SubInfoRecord
    Bitmap iconBitmap = BitmapFactory.decodeResource(mContext.getResources(), com.android.internal.R.drawable.ic_sim_card_multi_24px_clr);
    int mcc = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.MCC));
    int mnc = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.MNC));
    String cardId = cursor.getString(cursor.getColumnIndexOrThrow(SubscriptionManager.CARD_ID));
    // FIXME: consider stick this into database too
    String countryIso = getSubscriptionCountryIso(id);
    boolean isEmbedded = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.IS_EMBEDDED)) == 1;
    UiccAccessRule[] accessRules;
    if (isEmbedded) {
        accessRules = UiccAccessRule.decodeRules(cursor.getBlob(cursor.getColumnIndexOrThrow(SubscriptionManager.ACCESS_RULES)));
    } else {
        accessRules = null;
    }
    if (VDBG) {
        String iccIdToPrint = SubscriptionInfo.givePrintableIccid(iccId);
        String cardIdToPrint = SubscriptionInfo.givePrintableIccid(cardId);
        logd("[getSubInfoRecord] id:" + id + " iccid:" + iccIdToPrint + " simSlotIndex:" + simSlotIndex + " displayName:" + displayName + " nameSource:" + nameSource + " iconTint:" + iconTint + " dataRoaming:" + dataRoaming + " mcc:" + mcc + " mnc:" + mnc + " countIso:" + countryIso + " isEmbedded:" + isEmbedded + " accessRules:" + Arrays.toString(accessRules) + " cardId:" + cardIdToPrint);
    }
    // If line1number has been set to a different number, use it instead.
    String line1Number = mTelephonyManager.getLine1Number(id);
    if (!TextUtils.isEmpty(line1Number) && !line1Number.equals(number)) {
        number = line1Number;
    }
    return new SubscriptionInfo(id, iccId, simSlotIndex, displayName, carrierName, nameSource, iconTint, number, dataRoaming, iconBitmap, mcc, mnc, countryIso, isEmbedded, accessRules, cardId);
}
#end_block

#method_before
public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
    synchronized (mLock) {
        CardState oldState = mCardState;
        mCardState = ics.mCardState;
        mContext = c;
        mCi = ci;
        mIccid = ics.iccid;
        // For EuiccCard, override the mCardId with EID.
        mCardId = ics.iccid;
        if (mCardState != CardState.CARDSTATE_ABSENT) {
            if (mUiccProfile == null) {
                mUiccProfile = new UiccProfile(mContext, mCi, ics, mPhoneId, this);
            } else {
                mUiccProfile.update(mContext, mCi, ics);
            }
        } else {
            throw new RuntimeException("Card state is absent when updating!");
        }
    }
}
#method_after
public void update(Context c, CommandsInterface ci, IccCardStatus ics) {
    synchronized (mLock) {
        CardState oldState = mCardState;
        mCardState = ics.mCardState;
        mContext = c;
        mCi = ci;
        mIccid = ics.iccid;
        updateCardId();
        if (mCardState != CardState.CARDSTATE_ABSENT) {
            if (mUiccProfile == null) {
                mUiccProfile = new UiccProfile(mContext, mCi, ics, mPhoneId, this);
            } else {
                mUiccProfile.update(mContext, mCi, ics);
            }
        } else {
            throw new RuntimeException("Card state is absent when updating!");
        }
    }
}
#end_block

#method_before
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG)
        Log.d(TAG, "onCreate");
    View view = getLayoutInflater().inflate(R.layout.manual_printer_add, null);
    setView(view);
    setTitle(R.string.add_printer_by_ip);
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    setButton(AlertDialog.BUTTON_POSITIVE, getContext().getString(R.string.add), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    mAddButton = getButton(AlertDialog.BUTTON_POSITIVE);
    mHostnameView = (TextView) findViewById(R.id.hostname);
    mProgressBar = (ProgressBar) findViewById(R.id.progress);
    mAddButton.setOnClickListener(view1 -> addPrinter());
    // Update add button as contents change
    mHostnameView.addTextChangedListener(this);
    mHostnameView.setOnEditorActionListener(this);
    mHostnameView.setOnKeyListener(this);
    // Force open keyboard if appropriate
    openKeyboard(mHostnameView);
    updateButtonState();
}
#method_after
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG)
        Log.d(TAG, "onCreate");
    View view = getLayoutInflater().inflate(R.layout.manual_printer_add, null);
    setView(view);
    setTitle(R.string.add_printer_by_ip);
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    setButton(AlertDialog.BUTTON_POSITIVE, getContext().getString(R.string.add), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    mAddButton = getButton(AlertDialog.BUTTON_POSITIVE);
    mHostnameView = findViewById(R.id.hostname);
    mProgressBar = findViewById(R.id.progress);
    mAddButton.setOnClickListener(view1 -> addPrinter());
    // Update add button as contents change
    mHostnameView.addTextChangedListener(this);
    mHostnameView.setOnEditorActionListener(this);
    mHostnameView.setOnKeyListener(this);
    // Force open keyboard if appropriate
    openKeyboard(mHostnameView);
    updateButtonState();
}
#end_block

#method_before
private void updateButtonState() {
    String hostname = mHostnameView.getText().toString();
    Matcher uriMatcher = PRINTER_URI_PATTERN.matcher(hostname);
    mAddButton.setEnabled(uriMatcher.matches());
}
#method_after
private void updateButtonState() {
    String hostname = mHostnameView.getText().toString();
    Matcher uriMatcher = FULL_URI_PATTERN.matcher(hostname);
    mAddButton.setEnabled(uriMatcher.matches());
}
#end_block

#method_before
private void addPrinter() {
    // Disable other actions while we are checking
    mAddButton.setEnabled(false);
    mHostnameView.setEnabled(false);
    mProgressBar.setVisibility(View.VISIBLE);
    // Begin an attempt to add the printer
    mDiscovery.addManualPrinter(mHostnameView.getText().toString(), new ManualDiscovery.PrinterAddCallback() {

        @Override
        public void onFound(DiscoveredPrinter printer, boolean supported) {
            if (supported) {
                // Success case
                dismiss();
                mActivity.finish();
            } else {
                error(getContext().getString(R.string.printer_not_supported));
            }
        }

        @Override
        public void onNotFound() {
            error(getContext().getString(R.string.no_printer_found));
        }
    });
}
#method_after
private void addPrinter() {
    // Disable other actions while we are checking
    mAddButton.setEnabled(false);
    mHostnameView.setEnabled(false);
    mProgressBar.setVisibility(View.VISIBLE);
    // Begin an attempt to add the printer
    String uriString = mHostnameView.getText().toString();
    Uri printerUri;
    if (uriString.contains("://")) {
        printerUri = Uri.parse(uriString);
    } else {
        // create a schemeless URI
        printerUri = Uri.parse("://" + uriString);
    }
    mDiscovery.addManualPrinter(printerUri, this);
}
#end_block

#method_before
public void addManualPrinter(String uriString, PrinterAddCallback callback) {
    if (DEBUG)
        Log.d(TAG, "addManualPrinter " + uriString);
    Uri printerUri = Uri.parse("ipp://" + uriString);
    int givenPort = printerUri.getPort();
    String givenPath = printerUri.getPath();
    String hostname = printerUri.getHost();
    // Use LinkedHashSet to eliminate duplicates but maintain order
    Set<Uri> uris = new LinkedHashSet<>();
    for (Uri uri : IPP_URIS) {
        String authority = hostname + ":" + (givenPort == -1 ? uri.getPort() : givenPort);
        String path = TextUtils.isEmpty(givenPath) ? uri.getPath() : givenPath;
        uris.add(uri.buildUpon().encodedAuthority(authority).path(path).build());
    }
    new CapabilitiesFinder(uris, callback);
}
#method_after
public void addManualPrinter(Uri printerUri, PrinterAddCallback callback) {
    if (DEBUG)
        Log.d(TAG, "addManualPrinter " + printerUri);
    int givenPort = printerUri.getPort();
    String givenPath = printerUri.getPath();
    String hostname = printerUri.getHost();
    String givenScheme = printerUri.getScheme();
    // Use LinkedHashSet to eliminate duplicates but maintain order
    Set<Uri> uris = new LinkedHashSet<>();
    for (Uri uri : IPP_URIS) {
        String scheme = uri.getScheme();
        if (!TextUtils.isEmpty(givenScheme) && !scheme.equals(givenScheme)) {
            // If scheme was supplied and doesn't match this uri template, skip
            continue;
        }
        String authority = hostname + ":" + (givenPort == -1 ? uri.getPort() : givenPort);
        String path = TextUtils.isEmpty(givenPath) ? uri.getPath() : givenPath;
        Uri targetUri = uri.buildUpon().scheme(scheme).encodedAuthority(authority).path(path).build();
        uris.add(targetUri);
    }
    mAddRequests.add(new CapabilitiesFinder(uris, callback));
}
#end_block

#method_before
void handleCapabilities(Uri printerPath, LocalPrinterCapabilities capabilities) {
    if (DEBUG)
        Log.d(TAG, "request " + printerPath + " cap=" + capabilities);
    if (capabilities == null) {
        if (mRequests.isEmpty()) {
            mFinalCallback.onNotFound();
        }
        return;
    }
    // Success, so cancel all other requests
    for (CapabilitiesCache.OnLocalPrinterCapabilities request : mRequests) {
        mCapabilitiesCache.cancel(request);
    }
    mRequests.clear();
    // Deliver a successful response
    Uri uuid = TextUtils.isEmpty(capabilities.uuid) ? null : Uri.parse(capabilities.uuid);
    String name = TextUtils.isEmpty(capabilities.name) ? printerPath.getHost() : capabilities.name;
    DiscoveredPrinter resolvedPrinter = new DiscoveredPrinter(uuid, name, printerPath, capabilities.location);
    // Only add supported printers
    if (capabilities.isSupported) {
        if (addSavedPrinter(resolvedPrinter)) {
            printerFound(resolvedPrinter);
        }
    }
    mFinalCallback.onFound(resolvedPrinter, capabilities.isSupported);
}
#method_after
void handleCapabilities(Uri printerPath, LocalPrinterCapabilities capabilities) {
    if (DEBUG)
        Log.d(TAG, "request " + printerPath + " cap=" + capabilities);
    if (capabilities == null) {
        if (mRequests.isEmpty()) {
            mAddRequests.remove(this);
            mFinalCallback.onNotFound();
        }
        return;
    }
    // Success, so cancel all other requests
    for (CapabilitiesCache.OnLocalPrinterCapabilities request : mRequests) {
        mCapabilitiesCache.cancel(request);
    }
    mRequests.clear();
    // Deliver a successful response
    Uri uuid = TextUtils.isEmpty(capabilities.uuid) ? null : Uri.parse(capabilities.uuid);
    String name = TextUtils.isEmpty(capabilities.name) ? printerPath.getHost() : capabilities.name;
    DiscoveredPrinter resolvedPrinter = new DiscoveredPrinter(uuid, name, printerPath, capabilities.location);
    // Only add supported printers
    if (capabilities.isSupported) {
        if (addSavedPrinter(resolvedPrinter)) {
            printerFound(resolvedPrinter);
        }
    }
    mAddRequests.remove(this);
    mFinalCallback.onFound(resolvedPrinter, capabilities.isSupported);
}
#end_block

#method_before
public void testTranslucentAssistantActivityStackVisibility() throws Exception {
    enableAssistant();
    // Go home, launch the assistant and check to see that home is visible
    removeStacks(FULLSCREEN_WORKSPACE_STACK_ID);
    launchHomeActivity();
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
    mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    if (!noHomeScreen()) {
        mAmWmState.assertHomeActivityVisible(true);
    }
    // Launch a fullscreen app and then launch the assistant and check to see that it is
    // also visible
    removeStacks(ASSISTANT_STACK_ID);
    launchActivity(TEST_ACTIVITY);
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
    mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    mAmWmState.assertVisibility(TEST_ACTIVITY, true);
    // Go home, launch assistant, launch app into fullscreen with activity present, and go back.
    // Ensure home is visible.
    removeStacks(ASSISTANT_STACK_ID);
    launchHomeActivity();
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true), EXTRA_LAUNCH_NEW_TASK, TEST_ACTIVITY);
    mAmWmState.waitForValidState(mDevice, TEST_ACTIVITY, FULLSCREEN_WORKSPACE_STACK_ID);
    mAmWmState.assertHomeActivityVisible(false);
    pressBackButton();
    Thread.sleep(1000);
    mAmWmState.waitForFocusedStack(mDevice, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    if (!noHomeScreen()) {
        mAmWmState.assertHomeActivityVisible(true);
    }
    // is also visible
    if (supportsSplitScreenMultiWindow()) {
        removeStacks(ASSISTANT_STACK_ID);
        launchActivityInDockStack(DOCKED_ACTIVITY);
        launchActivity(TEST_ACTIVITY);
        mAmWmState.assertContainsStack("Must contain docked stack.", DOCKED_STACK_ID);
        launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
        mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
        assertAssistantStackExists();
        mAmWmState.assertVisibility(DOCKED_ACTIVITY, true);
        mAmWmState.assertVisibility(TEST_ACTIVITY, true);
    }
    disableAssistant();
}
#method_after
public void testTranslucentAssistantActivityStackVisibility() throws Exception {
    enableAssistant();
    // Go home, launch the assistant and check to see that home is visible
    removeStacks(FULLSCREEN_WORKSPACE_STACK_ID);
    launchHomeActivity();
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
    mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    if (!noHomeScreen()) {
        mAmWmState.assertHomeActivityVisible(true);
    }
    // Launch a fullscreen app and then launch the assistant and check to see that it is
    // also visible
    removeStacks(ASSISTANT_STACK_ID);
    launchActivity(TEST_ACTIVITY);
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
    mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    mAmWmState.assertVisibility(TEST_ACTIVITY, true);
    // Go home, launch assistant, launch app into fullscreen with activity present, and go back.
    // Ensure home is visible.
    removeStacks(ASSISTANT_STACK_ID);
    launchHomeActivity();
    launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true), EXTRA_LAUNCH_NEW_TASK, TEST_ACTIVITY);
    mAmWmState.waitForValidState(mDevice, TEST_ACTIVITY, FULLSCREEN_WORKSPACE_STACK_ID);
    mAmWmState.assertHomeActivityVisible(false);
    pressBackButton();
    mAmWmState.waitForFocusedStack(mDevice, ASSISTANT_STACK_ID);
    assertAssistantStackExists();
    if (!noHomeScreen()) {
        mAmWmState.waitForHomeActivityVisible(mDevice);
        mAmWmState.assertHomeActivityVisible(true);
    }
    // is also visible
    if (supportsSplitScreenMultiWindow()) {
        removeStacks(ASSISTANT_STACK_ID);
        launchActivityInDockStack(DOCKED_ACTIVITY);
        launchActivity(TEST_ACTIVITY);
        mAmWmState.assertContainsStack("Must contain docked stack.", DOCKED_STACK_ID);
        launchActivity(LAUNCH_ASSISTANT_ACTIVITY_INTO_STACK, EXTRA_IS_TRANSLUCENT, String.valueOf(true));
        mAmWmState.waitForValidState(mDevice, TRANSLUCENT_ASSISTANT_ACTIVITY, ASSISTANT_STACK_ID);
        assertAssistantStackExists();
        mAmWmState.assertVisibility(DOCKED_ACTIVITY, true);
        mAmWmState.assertVisibility(TEST_ACTIVITY, true);
    }
    disableAssistant();
}
#end_block

#method_before
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzState.clearNitzTimeZoneDetectionSuccessful();
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
    } else {
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
protected void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#method_after
protected final void log(String s) {
    Rlog.d(LOG_TAG, s);
}
#end_block

#method_before
protected void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#method_after
protected final void loge(String s) {
    Rlog.e(LOG_TAG, s);
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.setNetworkCountryIsoAvailable(false);
            mNitzState.clearNitzTimeZoneDetectionSuccessful();
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mNitzState.setNetworkCountryIsoAvailable(false);
            mNitzState.clearNitzTimeZoneDetectionSuccessful();
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (Build.IS_DEBUGGABLE && mPhone.mTelephonyTester != null) {
        mPhone.mTelephonyTester.overrideServiceState(mNewSS);
    }
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // ratchet the new tech up through it's rat family but don't drop back down
    // until cell change or device is OOS
    boolean isDataInService = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    if (!hasLocationChanged && isDataInService) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    ServiceState oldMergedSS = mPhone.getServiceState();
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: hasRegistered," + " current mNitzState.getNitzTimeZoneDetectionSuccessful()=" + mNitzState.getNitzTimeZoneDetectionSuccessful() + ". Calling mNitzState.clearNitzTimeZoneDetectionSuccessful()");
        }
        mNitzState.clearNitzTimeZoneDetectionSuccessful();
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mNitzState.setNetworkCountryIsoAvailable(false);
            mNitzState.clearNitzTimeZoneDetectionSuccessful();
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mNitzState.setNetworkCountryIsoAvailable(true);
            if (!mcc.equals("000") && !TextUtils.isEmpty(iso) && mNitzState.shouldUpdateTimeZoneUsingCountryCode()) {
                mNitzState.updateTimeZoneByNetworkCountryCode(iso);
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            boolean mccChanged = mccChanged(operatorNumeric, prevOperatorNumeric);
            boolean fixTimeZoneCallNeeded = mNitzState.fixTimeZoneCallNeeded();
            if (mccChanged || fixTimeZoneCallNeeded) {
                // came in we didn't know the country code.
                if (DBG) {
                    log("shouldFixTimeZoneNow: mccChanged=" + mccChanged + " fixTimeZoneCallNeeded=" + fixTimeZoneCallNeeded);
                }
                mNitzState.fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify service state changed only if the merged service state is changed.
        if (!oldMergedSS.equals(mPhone.getServiceState())) {
            mPhone.notifyServiceStateChanged(mPhone.getServiceState());
        }
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
protected boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#method_after
private boolean isInvalidOperatorNumeric(String operatorNumeric) {
    return operatorNumeric == null || operatorNumeric.length() < 5 || operatorNumeric.startsWith(INVALID_MCC);
}
#end_block

#method_before
protected String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mSavedTimeZone is null, TimeZone would get the default timeZone,
    // and the fixTimeZone couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone = false;
    int timeZone = 0;
    TimeZone tzone = null;
    if (mSavedTimeZone != null) {
        timeZone = TimeZone.getTimeZone(mSavedTimeZone).getRawOffset() / MS_PER_HOUR;
        isNitzTimeZone = true;
    } else {
        tzone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (tzone != null)
            timeZone = tzone.getRawOffset() / MS_PER_HOUR;
    }
    int mcc = mHbpcdUtils.getMcc(sid, timeZone, (mZoneDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#method_after
private String fixUnknownMcc(String operatorNumeric, int sid) {
    if (sid <= 0) {
        // no cdma information is available, do nothing
        return operatorNumeric;
    }
    // resolve the mcc from sid;
    // if mNitzState.getSavedTimeZoneId() is null, TimeZone would get the default timeZone,
    // and the mNitzState.fixTimeZone() couldn't help, because it depends on operator Numeric;
    // if the sid is conflict and timezone is unavailable, the mcc may be not right.
    boolean isNitzTimeZone;
    TimeZone tzone;
    if (mNitzState.getSavedTimeZoneId() != null) {
        tzone = TimeZone.getTimeZone(mNitzState.getSavedTimeZoneId());
        isNitzTimeZone = true;
    } else {
        NitzData lastNitzData = mNitzState.getCachedNitzData();
        if (lastNitzData == null) {
            tzone = null;
        } else {
            tzone = NitzData.guessTimeZone(lastNitzData);
            if (ServiceStateTracker.DBG) {
                log("fixUnknownMcc(): guessNitzTimeZone returned " + (tzone == null ? tzone : tzone.getID()));
            }
        }
        isNitzTimeZone = false;
    }
    int utcOffsetHours = 0;
    if (tzone != null) {
        utcOffsetHours = tzone.getRawOffset() / MS_PER_HOUR;
    }
    NitzData nitzData = mNitzState.getCachedNitzData();
    boolean isDst = nitzData != null && nitzData.isDst();
    int mcc = mHbpcdUtils.getMcc(sid, utcOffsetHours, (isDst ? 1 : 0), isNitzTimeZone);
    if (mcc > 0) {
        operatorNumeric = Integer.toString(mcc) + DEFAULT_MNC;
    }
    return operatorNumeric;
}
#end_block

#method_before
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        String tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " getAutoTimeZone()=" + getAutoTimeZone();
        if (DBG) {
            log(tmpLog);
        }
        mTimeZoneLog.log(tmpLog);
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz;
                if (DBG) {
                    log(tmpLog);
                }
                mTimeLog.log(tmpLog);
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#method_after
private void setTimeFromNITZString(String nitzString, long nitzReceiveTime) {
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        Rlog.d(LOG_TAG, "NITZ: " + nitzString + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    NitzData newNitzData = NitzData.parse(nitzString);
    if (newNitzData != null) {
        try {
            mNitzState.setTimeAndTimeZoneFromNitz(newNitzData, nitzReceiveTime);
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                Rlog.d(LOG_TAG, "NITZ: end=" + end + " dur=" + (end - start));
            }
        }
    }
}
#end_block

#method_before
private void cancelAllNotifications() {
    if (DBG)
        log("setNotification: cancelAllNotifications");
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancelAll();
}
#method_after
private void cancelAllNotifications() {
    if (DBG)
        log("setNotification: cancelAllNotifications");
    NotificationManager notificationManager = (NotificationManager) mPhone.getContext().getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancel(PS_NOTIFICATION);
    notificationManager.cancel(CS_NOTIFICATION);
    notificationManager.cancel(CS_REJECT_CAUSE_NOTIFICATION);
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + Rlog.pii(VDBG, mCellLoc));
    pw.println(" mNewCellLoc=" + Rlog.pii(VDBG, mNewCellLoc));
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.flush();
    mNitzState.dumpState(pw);
    pw.flush();
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    mNitzState.dumpLogs(fd, ipw, args);
}
#end_block

#method_before
private void deductTrafficFromVpnApp(int tunUid, String underlyingIface, Entry moved) {
    // Add debug info
    moved.uid = tunUid;
    moved.set = SET_DBG_VPN_OUT;
    moved.tag = TAG_NONE;
    moved.iface = underlyingIface;
    moved.metered = METERED_ALL;
    moved.roaming = ROAMING_ALL;
    moved.defaultNetwork = DEFAULT_NETWORK_ALL;
    combineValues(moved);
    // Caveat: if the vpn software uses tag, the total tagged traffic may be greater than
    // the TAG_NONE traffic.
    // 
    // Relies on the fact that the underlying traffic only has state ROAMING_NO and METERED_NO,
    // which should be the case as it comes directly from the /proc file. We only blend in the
    // roaming data after applying these adjustments, by checking the NetworkIdentity of the
    // underlying iface.
    int idxVpnBackground = findIndex(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES);
    if (idxVpnBackground != -1) {
        tunSubtract(idxVpnBackground, this, moved);
    }
    int idxVpnForeground = findIndex(underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES);
    if (idxVpnForeground != -1) {
        tunSubtract(idxVpnForeground, this, moved);
    }
}
#method_after
private void deductTrafficFromVpnApp(int tunUid, String underlyingIface, Entry moved) {
    // Add debug info
    moved.uid = tunUid;
    moved.set = SET_DBG_VPN_OUT;
    moved.tag = TAG_NONE;
    moved.iface = underlyingIface;
    moved.metered = METERED_ALL;
    moved.roaming = ROAMING_ALL;
    moved.defaultNetwork = DEFAULT_NETWORK_ALL;
    combineValues(moved);
    // Caveat: if the vpn software uses tag, the total tagged traffic may be greater than
    // the TAG_NONE traffic.
    // 
    // Relies on the fact that the underlying traffic only has state ROAMING_NO and METERED_NO,
    // which should be the case as it comes directly from the /proc file. We only blend in the
    // roaming data after applying these adjustments, by checking the NetworkIdentity of the
    // underlying iface.
    int idxVpnBackground = findIndex(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO);
    if (idxVpnBackground != -1) {
        tunSubtract(idxVpnBackground, this, moved);
    }
    int idxVpnForeground = findIndex(underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO);
    if (idxVpnForeground != -1) {
        tunSubtract(idxVpnForeground, this, moved);
    }
}
#end_block

#method_before
@Test
public void testCombineExisting() throws Exception {
    final NetworkStats stats = new NetworkStats(TEST_START, 10);
    stats.addValues(TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 10);
    stats.addValues(TEST_IFACE, 1001, SET_DEFAULT, 0xff, 128L, 1L, 128L, 1L, 2);
    stats.combineValues(TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, -128L, -1L, -128L, -1L, -1);
    assertValues(stats, 0, TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 384L, 3L, 128L, 1L, 9);
    assertValues(stats, 1, TEST_IFACE, 1001, SET_DEFAULT, 0xff, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 1L, 128L, 1L, 2);
    // now try combining that should create row
    stats.combineValues(TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 3);
    assertValues(stats, 2, TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 1L, 128L, 1L, 3);
    stats.combineValues(TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 3);
    assertValues(stats, 2, TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 256L, 2L, 256L, 2L, 6);
}
#method_after
@Test
public void testCombineExisting() throws Exception {
    final NetworkStats stats = new NetworkStats(TEST_START, 10);
    stats.addValues(TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 10);
    stats.addValues(TEST_IFACE, 1001, SET_DEFAULT, 0xff, 128L, 1L, 128L, 1L, 2);
    stats.combineValues(TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, -128L, -1L, -128L, -1L, -1);
    assertValues(stats, 0, TEST_IFACE, 1001, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 384L, 3L, 128L, 1L, 9);
    assertValues(stats, 1, TEST_IFACE, 1001, SET_DEFAULT, 0xff, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 128L, 1L, 128L, 1L, 2);
    // now try combining that should create row
    stats.combineValues(TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 3);
    assertValues(stats, 2, TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 128L, 1L, 128L, 1L, 3);
    stats.combineValues(TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 3);
    assertValues(stats, 2, TEST_IFACE, 5005, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 256L, 2L, 256L, 2L, 6);
}
#end_block

#method_before
@Test
public void testSubtractIdenticalData() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats result = after.subtract(before);
    // identical data should result in zero delta
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void testSubtractIdenticalData() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats result = after.subtract(before);
    // identical data should result in zero delta
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0);
}
#end_block

#method_before
@Test
public void testSubtractIdenticalRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1025L, 9L, 2L, 1L, 15).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 3L, 1L, 1028L, 9L, 20);
    final NetworkStats result = after.subtract(before);
    // expect delta between measurements
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 1L, 2L, 1L, 4);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 3L, 1L, 4L, 1L, 8);
}
#method_after
@Test
public void testSubtractIdenticalRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1025L, 9L, 2L, 1L, 15).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 3L, 1L, 1028L, 9L, 20);
    final NetworkStats result = after.subtract(before);
    // expect delta between measurements
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1L, 1L, 2L, 1L, 4);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 3L, 1L, 4L, 1L, 8);
}
#end_block

#method_before
@Test
public void testSubtractNewRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 3).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12).addValues(TEST_IFACE, 102, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 20);
    final NetworkStats result = after.subtract(before);
    // its okay to have new rows
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 2, TEST_IFACE, 102, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1024L, 8L, 1024L, 8L, 20);
}
#method_after
@Test
public void testSubtractNewRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12);
    final NetworkStats after = new NetworkStats(TEST_START, 3).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 1024L, 8L, 0L, 0L, 11).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 0L, 0L, 1024L, 8L, 12).addValues(TEST_IFACE, 102, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 20);
    final NetworkStats result = after.subtract(before);
    // its okay to have new rows
    assertValues(result, 0, TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 1, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0);
    assertValues(result, 2, TEST_IFACE, 102, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1024L, 8L, 1024L, 8L, 20);
}
#end_block

#method_before
@Test
public void testSubtractMissingRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, UID_ALL, SET_DEFAULT, TAG_NONE, 1024L, 0L, 0L, 0L, 0).addValues(TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, 2048L, 0L, 0L, 0L, 0);
    final NetworkStats after = new NetworkStats(TEST_START, 1).addValues(TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, 2049L, 2L, 3L, 4L, 0);
    final NetworkStats result = after.subtract(before);
    // should silently drop omitted rows
    assertEquals(1, result.size());
    assertValues(result, 0, TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 2L, 3L, 4L, 0);
    assertEquals(4L, result.getTotalBytes());
}
#method_after
@Test
public void testSubtractMissingRows() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 2).addValues(TEST_IFACE, UID_ALL, SET_DEFAULT, TAG_NONE, 1024L, 0L, 0L, 0L, 0).addValues(TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, 2048L, 0L, 0L, 0L, 0);
    final NetworkStats after = new NetworkStats(TEST_START, 1).addValues(TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, 2049L, 2L, 3L, 4L, 0);
    final NetworkStats result = after.subtract(before);
    // should silently drop omitted rows
    assertEquals(1, result.size());
    assertValues(result, 0, TEST_IFACE2, UID_ALL, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1L, 2L, 3L, 4L, 0);
    assertEquals(4L, result.getTotalBytes());
}
#end_block

#method_before
@Test
public void testWithoutUid() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 3).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 128L, 8L, 0L, 2L, 20L).addValues(TEST_IFACE2, 100, SET_DEFAULT, TAG_NONE, 512L, 32L, 0L, 0L, 0L).addValues(TEST_IFACE2, 100, SET_DEFAULT, 0xF00D, 64L, 4L, 0L, 0L, 0L).addValues(TEST_IFACE2, 100, SET_FOREGROUND, TAG_NONE, 512L, 32L, 0L, 0L, 0L).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 128L, 8L, 0L, 0L, 0L).addValues(TEST_IFACE, 101, SET_DEFAULT, 0xF00D, 128L, 8L, 0L, 0L, 0L);
    final NetworkStats after = before.withoutUids(new int[] { 100 });
    assertEquals(6, before.size());
    assertEquals(2, after.size());
    assertValues(after, 0, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 8L, 0L, 0L, 0L);
    assertValues(after, 1, TEST_IFACE, 101, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 8L, 0L, 0L, 0L);
}
#method_after
@Test
public void testWithoutUid() throws Exception {
    final NetworkStats before = new NetworkStats(TEST_START, 3).addValues(TEST_IFACE, 100, SET_DEFAULT, TAG_NONE, 128L, 8L, 0L, 2L, 20L).addValues(TEST_IFACE2, 100, SET_DEFAULT, TAG_NONE, 512L, 32L, 0L, 0L, 0L).addValues(TEST_IFACE2, 100, SET_DEFAULT, 0xF00D, 64L, 4L, 0L, 0L, 0L).addValues(TEST_IFACE2, 100, SET_FOREGROUND, TAG_NONE, 512L, 32L, 0L, 0L, 0L).addValues(TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, 128L, 8L, 0L, 0L, 0L).addValues(TEST_IFACE, 101, SET_DEFAULT, 0xF00D, 128L, 8L, 0L, 0L, 0L);
    final NetworkStats after = before.withoutUids(new int[] { 100 });
    assertEquals(6, before.size());
    assertEquals(2, after.size());
    assertValues(after, 0, TEST_IFACE, 101, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 128L, 8L, 0L, 0L, 0L);
    assertValues(after, 1, TEST_IFACE, 101, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 128L, 8L, 0L, 0L, 0L);
}
#end_block

#method_before
@Test
public void testMigrateTun() throws Exception {
    final int tunUid = 10030;
    final String tunIface = "tun0";
    final String underlyingIface = "wlan0";
    final int testTag1 = 8888;
    NetworkStats delta = new NetworkStats(TEST_START, 17).addValues(tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 39605L, 46L, 12259L, 55L, 0L).addValues(tunIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L).addValues(tunIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 72667L, 197L, 43909L, 241L, 0L).addValues(tunIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 9297L, 17L, 4128L, 21L, 0L).addValues(tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 4983L, 10L, 1801L, 12L, 0L).addValues(tunIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L).addValues(tunIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 21691L, 41L, 13820L, 51L, 0L).addValues(tunIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1281L, 2L, 665L, 2L, 0L).addValues(TEST_IFACE, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1685L, 5L, 2070L, 6L, 0L).addValues(underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 5178L, 8L, 2139L, 11L, 0L).addValues(underlyingIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L).addValues(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 149873L, 287L, 59217L, /* smaller than sum(tun0) */
    299L, /* smaller than sum(tun0) */
    0L).addValues(underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L);
    assertTrue(delta.migrateTun(tunUid, tunIface, underlyingIface));
    assertEquals(20, delta.size());
    // tunIface and TEST_IFACE entries are not changed.
    assertValues(delta, 0, tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 39605L, 46L, 12259L, 55L, 0L);
    assertValues(delta, 1, tunIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L);
    assertValues(delta, 2, tunIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 72667L, 197L, 43909L, 241L, 0L);
    assertValues(delta, 3, tunIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 9297L, 17L, 4128L, 21L, 0L);
    assertValues(delta, 4, tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 4983L, 10L, 1801L, 12L, 0L);
    assertValues(delta, 5, tunIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L);
    assertValues(delta, 6, tunIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 21691L, 41L, 13820L, 51L, 0L);
    assertValues(delta, 7, tunIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1281L, 2L, 665L, 2L, 0L);
    assertValues(delta, 8, TEST_IFACE, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1685L, 5L, 2070L, 6L, 0L);
    // Existing underlying Iface entries are updated
    assertValues(delta, 9, underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 44783L, 54L, 14178L, 62L, 0L);
    assertValues(delta, 10, underlyingIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L);
    // VPN underlying Iface entries are updated
    assertValues(delta, 11, underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 28304L, 27L, 1L, 2L, 0L);
    assertValues(delta, 12, underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 0L, 0L, 0L, 0L, 0L);
    // New entries are added for new application's underlying Iface traffic
    assertContains(delta, underlyingIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 72667L, 197L, 43123L, 227L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 9297L, 17L, 4054, 19L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 21691L, 41L, 13572L, 48L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1281L, 2L, 653L, 1L, 0L);
    // New entries are added for debug purpose
    assertContains(delta, underlyingIface, 10100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 39605L, 46L, 12039, 51, 0);
    assertContains(delta, underlyingIface, 10120, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 81964, 214, 47177, 246, 0);
    assertContains(delta, underlyingIface, tunUid, SET_DBG_VPN_OUT, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 121569, 260, 59216, 297, 0);
}
#method_after
@Test
public void testMigrateTun() throws Exception {
    final int tunUid = 10030;
    final String tunIface = "tun0";
    final String underlyingIface = "wlan0";
    final int testTag1 = 8888;
    NetworkStats delta = new NetworkStats(TEST_START, 17).addValues(tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 39605L, 46L, 12259L, 55L, 0L).addValues(tunIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L).addValues(tunIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 72667L, 197L, 43909L, 241L, 0L).addValues(tunIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 9297L, 17L, 4128L, 21L, 0L).addValues(tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 4983L, 10L, 1801L, 12L, 0L).addValues(tunIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L).addValues(tunIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 21691L, 41L, 13820L, 51L, 0L).addValues(tunIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1281L, 2L, 665L, 2L, 0L).addValues(TEST_IFACE, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1685L, 5L, 2070L, 6L, 0L).addValues(underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 5178L, 8L, 2139L, 11L, 0L).addValues(underlyingIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L).addValues(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 149873L, 287L, 59217L, /* smaller than sum(tun0) */
    299L, /* smaller than sum(tun0) */
    0L).addValues(underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L);
    assertTrue(delta.toString(), delta.migrateTun(tunUid, tunIface, underlyingIface));
    assertEquals(20, delta.size());
    // tunIface and TEST_IFACE entries are not changed.
    assertValues(delta, 0, tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 39605L, 46L, 12259L, 55L, 0L);
    assertValues(delta, 1, tunIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L);
    assertValues(delta, 2, tunIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 72667L, 197L, 43909L, 241L, 0L);
    assertValues(delta, 3, tunIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 9297L, 17L, 4128L, 21L, 0L);
    assertValues(delta, 4, tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 4983L, 10L, 1801L, 12L, 0L);
    assertValues(delta, 5, tunIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L);
    assertValues(delta, 6, tunIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 21691L, 41L, 13820L, 51L, 0L);
    assertValues(delta, 7, tunIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1281L, 2L, 665L, 2L, 0L);
    assertValues(delta, 8, TEST_IFACE, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1685L, 5L, 2070L, 6L, 0L);
    // Existing underlying Iface entries are updated
    assertValues(delta, 9, underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 44783L, 54L, 14178L, 62L, 0L);
    assertValues(delta, 10, underlyingIface, 10100, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L);
    // VPN underlying Iface entries are updated
    assertValues(delta, 11, underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 28304L, 27L, 1L, 2L, 0L);
    assertValues(delta, 12, underlyingIface, tunUid, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 0L, 0L, 0L, 0L, 0L);
    // New entries are added for new application's underlying Iface traffic
    assertContains(delta, underlyingIface, 10120, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 72667L, 197L, 43123L, 227L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 9297L, 17L, 4054, 19L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_DEFAULT, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 21691L, 41L, 13572L, 48L, 0L);
    assertContains(delta, underlyingIface, 10120, SET_FOREGROUND, testTag1, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1281L, 2L, 653L, 1L, 0L);
    // New entries are added for debug purpose
    assertContains(delta, underlyingIface, 10100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 39605L, 46L, 12039, 51, 0);
    assertContains(delta, underlyingIface, 10120, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 81964, 214, 47177, 246, 0);
    assertContains(delta, underlyingIface, tunUid, SET_DBG_VPN_OUT, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 121569, 260, 59216, 297, 0);
}
#end_block

#method_before
// Tests a case where all of the data received by the tun0 interface is echo back into the tun0
// interface by the vpn app before it's sent out of the underlying interface. The VPN app should
// not be charged for the echoed data but it should still be charged for any extra data it sends
@Test
public void testMigrateTun_VpnAsLoopback() {
    final int tunUid = 10030;
    final String tunIface = "tun0";
    final String underlyingIface = "wlan0";
    NetworkStats delta = new NetworkStats(TEST_START, 9).addValues(tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50000L, 25L, 100000L, 50L, 0L).addValues(tunIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 500L, 2L, 200L, 5L, 0L).addValues(tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 240000, 100L, 120000L, 60L, 0L).addValues(underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1000L, 10L, 2000L, 20L, 0L).addValues(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 75500L, 37L, 130000L, 70L, 0L);
    assertTrue(delta.migrateTun(tunUid, tunIface, underlyingIface));
    assertEquals(9, delta.size());
    // tunIface entries should not be changed.
    assertValues(delta, 0, tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50000L, 25L, 100000L, 50L, 0L);
    assertValues(delta, 1, tunIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 500L, 2L, 200L, 5L, 0L);
    assertValues(delta, 2, tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 240000L, 100L, 120000L, 60L, 0L);
    // Existing underlying Iface entries are updated
    assertValues(delta, 3, underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 51000L, 35L, 102000L, 70L, 0L);
    // VPN underlying Iface entries are updated
    assertValues(delta, 4, underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 25000L, 10L, 29800L, 15L, 0L);
    // New entries are added for new application's underlying Iface traffic
    assertContains(delta, underlyingIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 500L, 2L, 200L, 5L, 0L);
    // New entries are added for debug purpose
    assertContains(delta, underlyingIface, 10100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50000L, 25L, 100000L, 50L, 0L);
    assertContains(delta, underlyingIface, 20100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 500, 2L, 200L, 5L, 0L);
    assertContains(delta, underlyingIface, tunUid, SET_DBG_VPN_OUT, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 50500L, 27L, 100200L, 55, 0);
}
#method_after
// Tests a case where all of the data received by the tun0 interface is echo back into the tun0
// interface by the vpn app before it's sent out of the underlying interface. The VPN app should
// not be charged for the echoed data but it should still be charged for any extra data it sends
@Test
public void testMigrateTun_VpnAsLoopback() {
    final int tunUid = 10030;
    final String tunIface = "tun0";
    final String underlyingIface = "wlan0";
    NetworkStats delta = new NetworkStats(TEST_START, 9).addValues(tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L).addValues(tunIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 500L, 2L, 200L, 5L, 0L).addValues(tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 240000, 100L, 120000L, 60L, 0L).addValues(underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 1000L, 10L, 2000L, 20L, 0L).addValues(underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 75500L, 37L, 130000L, 70L, 0L);
    assertTrue(delta.migrateTun(tunUid, tunIface, underlyingIface));
    assertEquals(9, delta.size());
    // tunIface entries should not be changed.
    assertValues(delta, 0, tunIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
    assertValues(delta, 1, tunIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 500L, 2L, 200L, 5L, 0L);
    assertValues(delta, 2, tunIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 240000L, 100L, 120000L, 60L, 0L);
    // Existing underlying Iface entries are updated
    assertValues(delta, 3, underlyingIface, 10100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 51000L, 35L, 102000L, 70L, 0L);
    // VPN underlying Iface entries are updated
    assertValues(delta, 4, underlyingIface, tunUid, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 25000L, 10L, 29800L, 15L, 0L);
    // New entries are added for new application's underlying Iface traffic
    assertContains(delta, underlyingIface, 20100, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 500L, 2L, 200L, 5L, 0L);
    // New entries are added for debug purpose
    assertContains(delta, underlyingIface, 10100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 50000L, 25L, 100000L, 50L, 0L);
    assertContains(delta, underlyingIface, 20100, SET_DBG_VPN_IN, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO, 500, 2L, 200L, 5L, 0L);
    assertContains(delta, underlyingIface, tunUid, SET_DBG_VPN_OUT, TAG_NONE, METERED_ALL, ROAMING_ALL, DEFAULT_NETWORK_ALL, 50500L, 27L, 100200L, 55, 0);
}
#end_block

#method_before
private static void assertStatsEntry(NetworkStats stats, String iface, int uid, int set, int tag, long rxBytes, long txBytes) {
    final int i = stats.findIndex(iface, uid, set, tag, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES);
    if (i < 0) {
        fail(String.format("no NetworkStats for (iface: %s, uid: %d, set: %d, tag: %d)", iface, uid, set, tag));
    }
    final NetworkStats.Entry entry = stats.getValues(i, null);
    assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
    assertEquals("unexpected txBytes", txBytes, entry.txBytes);
}
#method_after
private static void assertStatsEntry(NetworkStats stats, String iface, int uid, int set, int tag, long rxBytes, long txBytes) {
    final int i = stats.findIndex(iface, uid, set, tag, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO);
    if (i < 0) {
        fail(String.format("no NetworkStats for (iface: %s, uid: %d, set: %d, tag: %d)", iface, uid, set, tag));
    }
    final NetworkStats.Entry entry = stats.getValues(i, null);
    assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
    assertEquals("unexpected txBytes", txBytes, entry.txBytes);
}
#end_block

#method_before
private static void assertStatsEntry(NetworkStats stats, String iface, int uid, int set, int tag, long rxBytes, long rxPackets, long txBytes, long txPackets) {
    final int i = stats.findIndex(iface, uid, set, tag, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES);
    if (i < 0) {
        fail(String.format("no NetworkStats for (iface: %s, uid: %d, set: %d, tag: %d)", iface, uid, set, tag));
    }
    final NetworkStats.Entry entry = stats.getValues(i, null);
    assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
    assertEquals("unexpected rxPackets", rxPackets, entry.rxPackets);
    assertEquals("unexpected txBytes", txBytes, entry.txBytes);
    assertEquals("unexpected txPackets", txPackets, entry.txPackets);
}
#method_after
private static void assertStatsEntry(NetworkStats stats, String iface, int uid, int set, int tag, long rxBytes, long rxPackets, long txBytes, long txPackets) {
    final int i = stats.findIndex(iface, uid, set, tag, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_NO);
    if (i < 0) {
        fail(String.format("no NetworkStats for (iface: %s, uid: %d, set: %d, tag: %d)", iface, uid, set, tag));
    }
    final NetworkStats.Entry entry = stats.getValues(i, null);
    assertEquals("unexpected rxBytes", rxBytes, entry.rxBytes);
    assertEquals("unexpected rxPackets", rxPackets, entry.rxPackets);
    assertEquals("unexpected txBytes", txBytes, entry.txBytes);
    assertEquals("unexpected txPackets", txPackets, entry.txPackets);
}
#end_block

#method_before
private void handleSetOsdName(HdmiCecMessage cmd) {
    Preconditions.checkState(mProcessedDeviceCount < mDevices.size());
    DeviceInfo current = mDevices.get(mProcessedDeviceCount);
    if (current.mLogicalAddress != cmd.getSource()) {
        Slog.w(TAG, "Unmatched address[expected:" + current.mLogicalAddress + ", actual:" + cmd.getSource());
        return;
    }
    String displayName = null;
    try {
        displayName = new String(cmd.getParams(), "US-ASCII");
    } catch (UnsupportedEncodingException e) {
        Slog.w(TAG, "Failed to decode display name: " + cmd.toString());
        // If failed to get display name, use the default name of device.
        displayName = HdmiUtils.getDefaultDeviceName(current.mLogicalAddress);
    }
    if (cmd.getOpcode() == Constants.MESSAGE_FEATURE_ABORT) {
        displayName = HdmiUtils.getDefaultDeviceName(current.mLogicalAddress);
    }
    current.mDisplayName = displayName;
    increaseProcessedDeviceCount();
    checkAndProceedStage();
}
#method_after
private void handleSetOsdName(HdmiCecMessage cmd) {
    Preconditions.checkState(mProcessedDeviceCount < mDevices.size());
    DeviceInfo current = mDevices.get(mProcessedDeviceCount);
    if (current.mLogicalAddress != cmd.getSource()) {
        Slog.w(TAG, "Unmatched address[expected:" + current.mLogicalAddress + ", actual:" + cmd.getSource());
        return;
    }
    String displayName = null;
    try {
        if (cmd.getOpcode() == Constants.MESSAGE_FEATURE_ABORT) {
            displayName = HdmiUtils.getDefaultDeviceName(current.mLogicalAddress);
        } else {
            displayName = new String(cmd.getParams(), "US-ASCII");
        }
    } catch (UnsupportedEncodingException e) {
        Slog.w(TAG, "Failed to decode display name: " + cmd.toString());
        // If failed to get display name, use the default name of device.
        displayName = HdmiUtils.getDefaultDeviceName(current.mLogicalAddress);
    }
    current.mDisplayName = displayName;
    increaseProcessedDeviceCount();
    checkAndProceedStage();
}
#end_block

#method_before
void setAudioStatus(boolean mute, int volume) {
    if (!isTvDeviceEnabled() || !tv().isSystemAudioActivated()) {
        return;
    }
    AudioManager audioManager = getAudioManager();
    boolean muted = audioManager.isStreamMute(AudioManager.STREAM_MUSIC);
    if (mute) {
        if (!muted) {
            audioManager.setStreamMute(AudioManager.STREAM_MUSIC, true);
        }
    } else {
        if (muted) {
            audioManager.setStreamMute(AudioManager.STREAM_MUSIC, false);
        }
        // FLAG_HDMI_SYSTEM_AUDIO_VOLUME prevents audio manager from announcing
        // volume change notification back to hdmi control service.
        int flag = AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME;
        if (0 <= volume && volume <= 100) {
            Slog.i(TAG, "volume: " + volume);
            flag |= AudioManager.FLAG_SHOW_UI;
        }
        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume, flag);
    }
}
#method_after
void setAudioStatus(boolean mute, int volume) {
    if (!isTvDeviceEnabled() || !tv().isSystemAudioActivated()) {
        return;
    }
    AudioManager audioManager = getAudioManager();
    boolean muted = audioManager.isStreamMute(AudioManager.STREAM_MUSIC);
    if (mute) {
        if (!muted) {
            audioManager.setStreamMute(AudioManager.STREAM_MUSIC, true);
        }
    } else {
        if (muted) {
            audioManager.setStreamMute(AudioManager.STREAM_MUSIC, false);
        }
        // FLAG_HDMI_SYSTEM_AUDIO_VOLUME prevents audio manager from announcing
        // volume change notification back to hdmi control service.
        int flag = AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME;
        if (0 <= volume && volume <= 100) {
            Slog.i(TAG, "volume: " + volume);
            flag |= AudioManager.FLAG_SHOW_UI;
            audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume, flag);
        }
    }
}
#end_block

#method_before
void setSystemAudioMode(boolean on) {
    if (!isSystemAudioControlFeatureEnabled() && on) {
        HdmiLogger.debug("Cannot turn on system audio mode " + "because the System Audio Control feature is disabled.");
        return;
    }
    HdmiLogger.debug("System Audio Mode change[old:%b new:%b]", mSystemAudioActivated, on);
    updateAudioManagerForSystemAudio(on);
    synchronized (mLock) {
        if (mSystemAudioActivated != on) {
            mSystemAudioActivated = on;
            mService.announceSystemAudioModeChange(on);
        }
    }
}
#method_after
void setSystemAudioMode(boolean on) {
    if (!isSystemAudioControlFeatureEnabled() && on) {
        HdmiLogger.debug("Cannot turn on system audio mode " + "because the System Audio Control feature is disabled.");
        return;
    }
    HdmiLogger.debug("System Audio Mode change[old:%b new:%b]", mSystemAudioActivated, on);
    updateAudioManagerForSystemAudio(on);
    synchronized (mLock) {
        if (mSystemAudioActivated != on) {
            mSystemAudioActivated = on;
            mService.announceSystemAudioModeChange(on);
        }
        startArcAction(on);
    }
}
#end_block

#method_before
public String toString() {
    return PrivateDnsConfig.class.getSimpleName() + "{" + useTls + ":" + hostname + "/" + stringify(ips) + "}";
}
#method_after
public String toString() {
    return PrivateDnsConfig.class.getSimpleName() + "{" + useTls + ":" + hostname + "/" + Arrays.toString(ips) + "}";
}
#end_block

#method_before
public static PrivateDnsConfig getPrivateDnsConfig(ContentResolver cr) {
    final String mode = getPrivateDnsMode(cr);
    final boolean useTls = mode.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || mode.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    if (mode.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME)) {
        final String specifier = getStringSetting(cr, PRIVATE_DNS_SPECIFIER);
        return new PrivateDnsConfig(specifier, null);
    }
    return new PrivateDnsConfig(useTls);
}
#method_after
public static PrivateDnsConfig getPrivateDnsConfig(ContentResolver cr) {
    final String mode = getPrivateDnsMode(cr);
    final boolean useTls = !TextUtils.isEmpty(mode) && !PRIVATE_DNS_MODE_OFF.equals(mode);
    if (PRIVATE_DNS_MODE_PROVIDER_HOSTNAME.equals(mode)) {
        final String specifier = getStringSetting(cr, PRIVATE_DNS_SPECIFIER);
        return new PrivateDnsConfig(specifier, null);
    }
    return new PrivateDnsConfig(useTls);
}
#end_block

#method_before
public static PrivateDnsConfig getPrivateDnsConfig(ContentResolver cr) {
    final String mode = getPrivateDnsMode(cr);
    final boolean useTls = mode.equals(PRIVATE_DNS_MODE_OPPORTUNISTIC) || mode.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME);
    if (mode.startsWith(PRIVATE_DNS_MODE_PROVIDER_HOSTNAME)) {
        final String specifier = getStringSetting(cr, PRIVATE_DNS_SPECIFIER);
        return new PrivateDnsConfig(specifier, null);
    }
    return new PrivateDnsConfig(useTls);
}
#method_after
public PrivateDnsConfig getPrivateDnsConfig() {
    return getPrivateDnsConfig(mContentResolver);
}
#end_block

#method_before
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.get(netId);
    final boolean useTls = (privateDnsCfg != null) ? privateDnsCfg.useTls : false;
    final boolean strictMode = useTls && privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] serverStrs = NetworkUtils.makeStrings(strictMode ? Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList()) : lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, stringify(serverStrs), stringify(domainStrs), stringify(params), useTls, tlsHostname));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, serverStrs, domainStrs, params, useTls, tlsHostname);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#method_after
public void setDnsConfigurationForNetwork(int netId, LinkProperties lp, boolean isDefaultNetwork) {
    // We only use the PrivateDnsConfig data pushed to this class instance
    // from ConnectivityService because it works in coordination with
    // NetworkMonitor to decide which networks need validation and runs the
    // blocking calls to resolve Private DNS strict mode hostnames.
    // 
    // At this time we do attempt to enable Private DNS on non-Internet
    // networks like IMS.
    final PrivateDnsConfig privateDnsCfg = mPrivateDnsMap.get(netId);
    final boolean useTls = (privateDnsCfg != null) && privateDnsCfg.useTls;
    final boolean strictMode = (privateDnsCfg != null) && privateDnsCfg.inStrictMode();
    final String tlsHostname = strictMode ? privateDnsCfg.hostname : "";
    final String[] serverStrs = NetworkUtils.makeStrings(strictMode ? Arrays.stream(privateDnsCfg.ips).filter((ip) -> lp.isReachable(ip)).collect(Collectors.toList()) : lp.getDnsServers());
    final String[] domainStrs = getDomainStrings(lp.getDomains());
    updateParametersSettings();
    final int[] params = { mSampleValidity, mSuccessThreshold, mMinSamples, mMaxSamples };
    Slog.d(TAG, String.format("setDnsConfigurationForNetwork(%d, %s, %s, %s, %s, %s)", netId, Arrays.toString(serverStrs), Arrays.toString(domainStrs), Arrays.toString(params), useTls, tlsHostname));
    try {
        mNMS.setDnsConfigurationForNetwork(netId, serverStrs, domainStrs, params, useTls, tlsHostname);
    } catch (Exception e) {
        Slog.e(TAG, "Error setting DNS configuration: " + e);
        return;
    }
    // the privacy protections of things like DNS-over-TLS.
    if (isDefaultNetwork)
        setDefaultDnsSystemProperties(lp.getDnsServers());
    flushVmDnsCache();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            log("Forcing reevaluation for UID " + message.arg1);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, 0, /* no UID */
                    0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "!" on the system UI icon may still be a good idea.
                    transitionTo(mValidatedState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, null));
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        default:
            return HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_NETWORK_CONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_CONNECTED);
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_NETWORK_DISCONNECTED:
            logNetworkEvent(NetworkEvent.NETWORK_DISCONNECTED);
            if (mLaunchCaptivePortalAppBroadcastReceiver != null) {
                mContext.unregisterReceiver(mLaunchCaptivePortalAppBroadcastReceiver);
                mLaunchCaptivePortalAppBroadcastReceiver = null;
            }
            quit();
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
        case CMD_CAPTIVE_PORTAL_RECHECK:
            log("Forcing reevaluation for UID " + message.arg1);
            mUidResponsibleForReeval = message.arg1;
            transitionTo(mEvaluatingState);
            return HANDLED;
        case CMD_CAPTIVE_PORTAL_APP_FINISHED:
            log("CaptivePortal App responded with " + message.arg1);
            // If the user has seen and acted on a captive portal notification, and the
            // captive portal app is now closed, disable HTTPS probes. This avoids the
            // following pathological situation:
            // 
            // 1. HTTP probe returns a captive portal, HTTPS probe fails or times out.
            // 2. User opens the app and logs into the captive portal.
            // 3. HTTP starts working, but HTTPS still doesn't work for some other reason -
            // perhaps due to the network blocking HTTPS?
            // 
            // In this case, we'll fail to validate the network even after the app is
            // dismissed. There is now no way to use this network, because the app is now
            // gone, so the user cannot select "Use this network as is".
            mUseHttps = false;
            switch(message.arg1) {
                case APP_RETURN_DISMISSED:
                    sendMessage(CMD_FORCE_REEVALUATION, 0, /* no UID */
                    0);
                    break;
                case APP_RETURN_WANTED_AS_IS:
                    mDontDisplaySigninNotification = true;
                    // TODO: Distinguish this from a network that actually validates.
                    // Displaying the "!" on the system UI icon may still be a good idea.
                    transitionTo(mValidatedState);
                    break;
                case APP_RETURN_UNWANTED:
                    mDontDisplaySigninNotification = true;
                    mUserDoesNotWant = true;
                    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, null));
                    // TODO: Should teardown network.
                    mUidResponsibleForReeval = 0;
                    transitionTo(mEvaluatingState);
                    break;
            }
            return HANDLED;
        case CMD_PRIVATE_DNS_SETTINGS_CHANGED:
            if (isValidationRequired()) {
                // This performs a blocking DNS resolution of the
                // strict mode hostname, if required.
                resolvePrivateDnsConfig((DnsManager.PrivateDnsConfig) message.obj);
                if ((mPrivateDnsCfg != null) && mPrivateDnsCfg.inStrictMode()) {
                    mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_PRIVATE_DNS_CONFIG_RESOLVED, 0, mNetId, new DnsManager.PrivateDnsConfig(mPrivateDnsCfg)));
                }
            }
            return HANDLED;
        default:
            return HANDLED;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_REEVALUATE:
            if (message.arg1 != mReevaluateToken || mUserDoesNotWant)
                return HANDLED;
            // expensive metered network, or unwanted leaking of the User Agent string.
            if (!mDefaultRequest.networkCapabilities.satisfiedByNetworkCapabilities(mNetworkAgentInfo.networkCapabilities)) {
                validationLog("Network would not satisfy default request, not validating");
                mPrivateDnsCfg = null;
                transitionTo(mValidatedState);
                return HANDLED;
            }
            mAttempts++;
            // Note: This call to isCaptivePortal() could take up to a minute. Resolving the
            // server's IP addresses could hit the DNS timeout, and attempting connections
            // to each of the server's several IP addresses (currently one IPv4 and one
            // IPv6) could each take SOCKET_TIMEOUT_MS.  During this time this StateMachine
            // will be unresponsive. isCaptivePortal() could be executed on another Thread
            // if this is found to cause problems.
            CaptivePortalProbeResult probeResult = isCaptivePortal();
            if (probeResult.isSuccessful()) {
                updatePrivateDnsConfig();
                transitionTo(mValidatedState);
            } else if (probeResult.isPortal()) {
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                mLastPortalProbeResult = probeResult;
                transitionTo(mCaptivePortalState);
            } else {
                final Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, 0);
                sendMessageDelayed(msg, mReevaluateDelayMs);
                logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                if (mAttempts >= BLAME_FOR_EVALUATION_ATTEMPTS) {
                    // Don't continue to blame UID forever.
                    TrafficStats.clearThreadStatsUid();
                }
                mReevaluateDelayMs *= 2;
                if (mReevaluateDelayMs > MAX_REEVALUATE_DELAY_MS) {
                    mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;
                }
            }
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
            // evaluation process via EvaluatingState#enter.
            return (mAttempts < IGNORE_REEVALUATE_ATTEMPTS) ? HANDLED : NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_REEVALUATE:
            if (message.arg1 != mReevaluateToken || mUserDoesNotWant)
                return HANDLED;
            // expensive metered network, or unwanted leaking of the User Agent string.
            if (!isValidationRequired()) {
                validationLog("Network would not satisfy default request, not validating");
                mPrivateDnsCfg = null;
                transitionTo(mValidatedState);
                return HANDLED;
            }
            mAttempts++;
            // Note: This call to isCaptivePortal() could take up to a minute. Resolving the
            // server's IP addresses could hit the DNS timeout, and attempting connections
            // to each of the server's several IP addresses (currently one IPv4 and one
            // IPv6) could each take SOCKET_TIMEOUT_MS.  During this time this StateMachine
            // will be unresponsive. isCaptivePortal() could be executed on another Thread
            // if this is found to cause problems.
            CaptivePortalProbeResult probeResult = isCaptivePortal();
            if (probeResult.isSuccessful()) {
                resolvePrivateDnsConfig();
                transitionTo(mValidatedState);
            } else if (probeResult.isPortal()) {
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                mLastPortalProbeResult = probeResult;
                transitionTo(mCaptivePortalState);
            } else {
                final Message msg = obtainMessage(CMD_REEVALUATE, ++mReevaluateToken, 0);
                sendMessageDelayed(msg, mReevaluateDelayMs);
                logNetworkEvent(NetworkEvent.NETWORK_VALIDATION_FAILED);
                mConnectivityServiceHandler.sendMessage(obtainMessage(EVENT_NETWORK_TESTED, NETWORK_TEST_RESULT_INVALID, mNetId, probeResult.redirectUrl));
                if (mAttempts >= BLAME_FOR_EVALUATION_ATTEMPTS) {
                    // Don't continue to blame UID forever.
                    TrafficStats.clearThreadStatsUid();
                }
                mReevaluateDelayMs *= 2;
                if (mReevaluateDelayMs > MAX_REEVALUATE_DELAY_MS) {
                    mReevaluateDelayMs = MAX_REEVALUATE_DELAY_MS;
                }
            }
            return HANDLED;
        case CMD_FORCE_REEVALUATION:
            // evaluation process via EvaluatingState#enter.
            return (mAttempts < IGNORE_REEVALUATE_ATTEMPTS) ? HANDLED : NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
private void registerPrivateDnsSettingsCallbacks() {
    for (Uri u : DnsManager.getPrivateDnsSettingsUris()) {
        mSettingsObserver.observe(u, EVENT_PRIVATE_DNS_CHANGED);
    }
}
#method_after
private void registerPrivateDnsSettingsCallbacks() {
    for (Uri u : DnsManager.getPrivateDnsSettingsUris()) {
        mSettingsObserver.observe(u, EVENT_PRIVATE_DNS_SETTINGS_CHANGED);
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai != null) {
                    final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                    final boolean wasValidated = nai.lastValidated;
                    final boolean wasDefault = isDefaultNetwork(nai);
                    boolean revalidationRequired = false;
                    if (valid) {
                        final PrivateDnsConfig privateDnsCfg = (PrivateDnsConfig) msg.obj;
                        revalidationRequired = updatePrivateDns(nai, privateDnsCfg);
                        // Rewrite for friendly logging below.
                        msg.obj = (privateDnsCfg != null) ? privateDnsCfg.toString() : null;
                    }
                    if (DBG)
                        log(nai.name() + " validation " + (valid ? "passed" : "failed") + (msg.obj == null ? "" : " with redirect to " + (String) msg.obj));
                    // trigger revalidation of the network to test it.
                    if (revalidationRequired) {
                        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, Process.SYSTEM_UID);
                        break;
                    }
                    if (valid != nai.lastValidated) {
                        if (wasDefault) {
                            metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                        }
                        final int oldScore = nai.getCurrentScore();
                        nai.lastValidated = valid;
                        nai.everValidated |= valid;
                        updateCapabilities(oldScore, nai, nai.networkCapabilities);
                        // If score has changed, rebroadcast to NetworkFactories. b/17726566
                        if (oldScore != nai.getCurrentScore())
                            sendUpdatedScoreToFactories(nai);
                    }
                    updateInetCondition(nai);
                    // Let the NetworkAgent know the state of its network
                    Bundle redirectUrlBundle = new Bundle();
                    redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, (String) msg.obj);
                    nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                    if (wasValidated && !nai.lastValidated) {
                        handleNetworkUnvalidated(nai);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(netId);
                }
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final PrivateDnsConfig privateDnsCfg = (msg.obj instanceof PrivateDnsConfig) ? (PrivateDnsConfig) msg.obj : null;
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                final boolean reevaluationRequired;
                final String logMsg;
                if (valid) {
                    reevaluationRequired = updatePrivateDns(nai, privateDnsCfg);
                    logMsg = (DBG && (privateDnsCfg != null)) ? " with " + privateDnsCfg.toString() : "";
                } else {
                    reevaluationRequired = false;
                    logMsg = (DBG && !TextUtils.isEmpty(redirectUrl)) ? " with redirect to " + redirectUrl : "";
                }
                if (DBG) {
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                // trigger reevaluation of the network to test it.
                if (reevaluationRequired) {
                    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, Process.SYSTEM_UID);
                    break;
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(netId);
                }
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai;
                synchronized (mNetworkForNetId) {
                    nai = mNetworkForNetId.get(msg.arg2);
                }
                if (nai == null)
                    break;
                final PrivateDnsConfig cfg = (PrivateDnsConfig) msg.obj;
                final boolean reevaluationRequired = updatePrivateDns(nai, cfg);
                if (nai.lastValidated && reevaluationRequired) {
                    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_FORCE_REEVALUATION, Process.SYSTEM_UID);
                }
                break;
            }
    }
    return true;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_CHANGED:
            handleEventPrivateDnsChanged();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                handleDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_MOBILE_DATA_ALWAYS_ON:
            {
                handleMobileDataAlwaysOn();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
    }
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities networkCapabilities) {
    // Once a NetworkAgent is connected, complain if some immutable capabilities are removed.
    if (nai.everConnected && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(networkCapabilities)) {
        // TODO: consider not complaining when a network agent degrade its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(networkCapabilities);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    if (nai.lastValidated) {
        networkCapabilities.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        networkCapabilities.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        networkCapabilities.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (Objects.equals(nai.networkCapabilities, networkCapabilities))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(networkCapabilities);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = networkCapabilities;
    }
    if (nai.getCurrentScore() == oldScore && networkCapabilities.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != networkCapabilities.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != networkCapabilities.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        // bubble those changes through.
        synchronized (mVpns) {
            for (int i = 0; i < mVpns.size(); i++) {
                final Vpn vpn = mVpns.valueAt(i);
                vpn.updateCapabilities();
            }
        }
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(newNc);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    // Report changes that are interesting for network statistics tracking.
    if (prevNc != null) {
        final boolean meteredChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_METERED) != newNc.hasCapability(NET_CAPABILITY_NOT_METERED);
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // bubble those changes through.
        synchronized (mVpns) {
            for (int i = 0; i < mVpns.size(); i++) {
                final Vpn vpn = mVpns.valueAt(i);
                vpn.updateCapabilities();
            }
        }
    }
}
#end_block

#method_before
private synchronized boolean onConnect(BluetoothDevice device, BluetoothSocket conSocket) {
    if (D) {
        Log.d(mTag, "onConnect() socket: " + conSocket);
    }
    if (mConHandler.onConnect(device, conSocket)) {
        return true;
    }
    return false;
}
#method_after
private synchronized boolean onConnect(BluetoothDevice device, BluetoothSocket conSocket) {
    if (D) {
        Log.d(mTag, "onConnect() socket: " + conSocket);
    }
    return mConHandler.onConnect(device, conSocket);
}
#end_block

#method_before
public synchronized void startSocketListeners() {
    if (D) {
        Log.d(mTag, "Map Service startSocketListeners");
    }
    if (mServerSession != null) {
        if (D) {
            Log.d(mTag, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        if (D) {
            Log.d(mTag, "mObserver exists - shutting it down...");
        }
        mObserver.deinit();
        mObserver = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mAcceptNewConnect = true;
    } else {
        mServerSockets = ObexServerSockets.create(this);
        mAcceptNewConnect = true;
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(mTag, "Failed to start the listeners");
            return;
        }
        removeSdpRecord();
        mSdpHandle = createMasSdpRecord(mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm());
        // Here we might have changed crucial data, hence reset DB identifier
        if (V) {
            Log.d(mTag, "Creating new SDP record for MAS instance: " + mMasInstanceId + " Object reference: " + this + "SDP handle: " + mSdpHandle);
        }
        updateDbIdentifier();
    }
}
#method_after
public synchronized void startSocketListeners() {
    if (D) {
        Log.d(mTag, "Map Service startSocketListeners");
    }
    if (mServerSession != null) {
        if (D) {
            Log.d(mTag, "mServerSession exists - shutting it down...");
        }
        mServerSession.close();
        mServerSession = null;
    }
    if (mObserver != null) {
        if (D) {
            Log.d(mTag, "mObserver exists - shutting it down...");
        }
        mObserver.deinit();
        mObserver = null;
    }
    closeConnectionSocket();
    if (mServerSockets != null) {
        mAcceptNewConnections = true;
    } else {
        mServerSockets = ObexServerSockets.create(this);
        mAcceptNewConnections = true;
        if (mServerSockets == null) {
            // TODO: Handle - was not handled before
            Log.e(mTag, "Failed to start the listeners");
            return;
        }
        removeSdpRecord();
        mSdpHandle = createMasSdpRecord(mServerSockets.getRfcommChannel(), mServerSockets.getL2capPsm());
        // Here we might have changed crucial data, hence reset DB identifier
        if (V) {
            Log.d(mTag, "Creating new SDP record for MAS instance: " + mMasInstanceId + " Object reference: " + this + "SDP handle: " + mSdpHandle);
        }
        updateDbIdentifier();
    }
}
#end_block

#method_before
@Override
public synchronized boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (!mAcceptNewConnect) {
        return false;
    }
    /* Signal to the service that we have received an incoming connection.
         */
    boolean isValid = mMapService.onConnect(device, BluetoothMapMasInstance.this);
    if (isValid) {
        mRemoteDevice = device;
        mConnSocket = socket;
        mAcceptNewConnect = false;
    }
    return isValid;
}
#method_after
@Override
public synchronized boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (!mAcceptNewConnections) {
        return false;
    }
    /* Signal to the service that we have received an incoming connection.
         */
    boolean isValid = mMapService.onConnect(device, BluetoothMapMasInstance.this);
    if (isValid) {
        mRemoteDevice = device;
        mConnSocket = socket;
        mAcceptNewConnections = false;
    }
    return isValid;
}
#end_block

#method_before
private void startSocketListener() {
    if (D) {
        Log.d(TAG, "start Socket Listeners");
    }
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    mAcceptNewConnect = true;
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    mOppSdpHandle = sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SUPPORTED_OPP_FORMAT);
    if (D) {
        Log.d(TAG, "mOppSdpHandle :" + mOppSdpHandle);
    }
}
#method_after
private void startSocketListener() {
    if (D) {
        Log.d(TAG, "start Socket Listeners");
    }
    stopListeners();
    mServerSocket = ObexServerSockets.createInsecure(this);
    acceptNewConnections();
    SdpManager sdpManager = SdpManager.getDefaultManager();
    if (sdpManager == null || mServerSocket == null) {
        Log.e(TAG, "ERROR:serversocket object is NULL  sdp manager :" + sdpManager + " mServerSocket:" + mServerSocket);
        return;
    }
    mOppSdpHandle = sdpManager.createOppOpsRecord("OBEX Object Push", mServerSocket.getRfcommChannel(), mServerSocket.getL2capPsm(), 0x0102, SUPPORTED_OPP_FORMAT);
    if (D) {
        Log.d(TAG, "mOppSdpHandle :" + mOppSdpHandle);
    }
}
#end_block

#method_before
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    }
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = mHandler.obtainMessage(MSG_INCOMING_BTOPP_CONNECTION);
    msg.obj = transport;
    msg.sendToTarget();
    mAcceptNewConnect = false;
    return true;
}
#method_after
@Override
public boolean onConnect(BluetoothDevice device, BluetoothSocket socket) {
    if (D) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " \n :device :" + device);
    }
    if (!mAcceptNewConnections) {
        Log.d(TAG, " onConnect BluetoothSocket :" + socket + " rejected");
        return false;
    }
    BluetoothObexTransport transport = new BluetoothObexTransport(socket);
    Message msg = mHandler.obtainMessage(MSG_INCOMING_BTOPP_CONNECTION);
    msg.obj = transport;
    msg.sendToTarget();
    mAcceptNewConnections = false;
    return true;
}
#end_block

#method_before
@Override
public void onClose() {
    if (D) {
        Log.d(TAG, "onClose");
    }
    releaseWakeLocks();
    mBluetoothOppService.mAcceptNewConnect = true;
    BluetoothOppUtility.cancelNotification(mContext);
    /* onClose could happen even before start() where mCallback is set */
    if (mCallback != null) {
        Message msg = Message.obtain(mCallback);
        msg.what = BluetoothOppObexSession.MSG_SESSION_COMPLETE;
        msg.obj = mInfo;
        msg.sendToTarget();
    }
}
#method_after
@Override
public void onClose() {
    if (D) {
        Log.d(TAG, "onClose");
    }
    releaseWakeLocks();
    mBluetoothOppService.acceptNewConnections();
    BluetoothOppUtility.cancelNotification(mContext);
    /* onClose could happen even before start() where mCallback is set */
    if (mCallback != null) {
        Message msg = Message.obtain(mCallback);
        msg.what = BluetoothOppObexSession.MSG_SESSION_COMPLETE;
        msg.obj = mInfo;
        msg.sendToTarget();
    }
}
#end_block

#method_before
@Override
public synchronized Cursor query(Uri url, String[] projectionIn, String selection, String[] selectionArgs, String sort) {
    if (VDBG)
        log("query: url=" + url + ", projectionIn=" + projectionIn + ", selection=" + selection + "selectionArgs=" + selectionArgs + ", sort=" + sort);
    TelephonyManager mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String subIdString;
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    // a little protection from injection attacks
    qb.setStrict(true);
    qb.setTables(CARRIERS_TABLE);
    List<String> constraints = new ArrayList<String>();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(NUMERIC + " = '" + mTelephonyManager.getSimOperator(subId) + "'");
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_TELEPHONY:
            {
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_CURRENT:
            {
                constraints.add("current IS NOT NULL");
                constraints.add(IS_NOT_OWNED_BY_DPC);
                // selection = null;
                break;
            }
        case URL_ID:
            {
                constraints.add("_id = " + url.getPathSegments().get(1));
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                constraints.add("_id = " + getPreferredApnId(subId, true));
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                // DPC query only returns DPC records.
                constraints.add(IS_OWNED_BY_DPC);
                break;
            }
        case URL_FILTERED_ID:
            {
                constraints.add("_id = " + url.getLastPathSegment());
            }
        case URL_FILTERED:
            {
                if (isManagedApnEnforced()) {
                    // If enforced, return DPC records only.
                    constraints.add(IS_OWNED_BY_DPC);
                } else {
                    // Otherwise return non-DPC records only.
                    constraints.add(IS_NOT_OWNED_BY_DPC);
                }
                break;
            }
        case URL_ENFORCE_MANAGED:
            {
                ensureCallingFromSystemOrPhoneUid("URL_ENFORCE_MANAGED called from non SYSTEM_UID.");
                MatrixCursor cursor = new MatrixCursor(new String[] { ENFORCED_KEY });
                cursor.addRow(new Object[] { isManagedApnEnforced() ? 1 : 0 });
                return cursor;
            }
        case URL_SIMINFO:
            {
                qb.setTables(SIMINFO_TABLE);
                break;
            }
        default:
            {
                return null;
            }
    }
    // appendWhere doesn't add ANDs so we do it ourselves
    if (constraints.size() > 0) {
        qb.appendWhere(TextUtils.join(" AND ", constraints));
    }
    if (match != URL_SIMINFO) {
        if (projectionIn != null) {
            for (String column : projectionIn) {
                if (TYPE.equals(column) || MMSC.equals(column) || MMSPROXY.equals(column) || MMSPORT.equals(column) || APN.equals(column)) {
                // noop
                } else {
                    checkPermission();
                    break;
                }
            }
        } else {
            // null returns all columns, so need permission check
            checkPermission();
        }
    }
    SQLiteDatabase db = getReadableDatabase();
    Cursor ret = null;
    try {
        // Exclude entries marked deleted
        if (CARRIERS_TABLE.equals(qb.getTables())) {
            if (TextUtils.isEmpty(selection)) {
                selection = "";
            } else {
                selection += " and ";
            }
            selection += IS_NOT_USER_DELETED + " and " + IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + " and " + IS_NOT_CARRIER_DELETED + " and " + IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;
            if (VDBG)
                log("query: selection modified to " + selection);
        }
        ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);
    } catch (SQLException e) {
        loge("got exception when querying: " + e);
    }
    if (ret != null)
        ret.setNotificationUri(getContext().getContentResolver(), url);
    return ret;
}
#method_after
@Override
public synchronized Cursor query(Uri url, String[] projectionIn, String selection, String[] selectionArgs, String sort) {
    if (VDBG)
        log("query: url=" + url + ", projectionIn=" + projectionIn + ", selection=" + selection + "selectionArgs=" + selectionArgs + ", sort=" + sort);
    TelephonyManager mTelephonyManager = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    String subIdString;
    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
    // a little protection from injection attacks
    qb.setStrict(true);
    qb.setTables(CARRIERS_TABLE);
    List<String> constraints = new ArrayList<String>();
    int match = s_urlMatcher.match(url);
    switch(match) {
        case URL_TELEPHONY_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(NUMERIC + " = '" + mTelephonyManager.getSimOperator(subId) + "'");
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_TELEPHONY:
            {
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_CURRENT_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_CURRENT:
            {
                constraints.add("current IS NOT NULL");
                constraints.add(IS_NOT_OWNED_BY_DPC);
                // selection = null;
                break;
            }
        case URL_ID:
            {
                constraints.add("_id = " + url.getPathSegments().get(1));
                constraints.add(IS_NOT_OWNED_BY_DPC);
                break;
            }
        case URL_PREFERAPN_USING_SUBID:
        case URL_PREFERAPN_NO_UPDATE_USING_SUBID:
            {
                subIdString = url.getLastPathSegment();
                try {
                    subId = Integer.parseInt(subIdString);
                } catch (NumberFormatException e) {
                    loge("NumberFormatException" + e);
                    return null;
                }
                if (DBG)
                    log("subIdString = " + subIdString + " subId = " + subId);
                constraints.add(SUBSCRIPTION_ID + "=" + subIdString);
            }
        // intentional fall through from above case
        case URL_PREFERAPN:
        case URL_PREFERAPN_NO_UPDATE:
            {
                constraints.add("_id = " + getPreferredApnId(subId, true));
                break;
            }
        case URL_DPC:
            {
                ensureCallingFromSystemOrPhoneUid("URL_DPC called from non SYSTEM_UID.");
                // DPC query only returns DPC records.
                constraints.add(IS_OWNED_BY_DPC);
                break;
            }
        case URL_FILTERED_ID:
            {
                constraints.add("_id = " + url.getLastPathSegment());
            }
        // intentional fall through from above case
        case URL_FILTERED:
            {
                if (isManagedApnEnforced()) {
                    // If enforced, return DPC records only.
                    constraints.add(IS_OWNED_BY_DPC);
                } else {
                    // Otherwise return non-DPC records only.
                    constraints.add(IS_NOT_OWNED_BY_DPC);
                }
                break;
            }
        case URL_ENFORCE_MANAGED:
            {
                ensureCallingFromSystemOrPhoneUid("URL_ENFORCE_MANAGED called from non SYSTEM_UID.");
                MatrixCursor cursor = new MatrixCursor(new String[] { ENFORCED_KEY });
                cursor.addRow(new Object[] { isManagedApnEnforced() ? 1 : 0 });
                return cursor;
            }
        case URL_SIMINFO:
            {
                qb.setTables(SIMINFO_TABLE);
                break;
            }
        default:
            {
                return null;
            }
    }
    // appendWhere doesn't add ANDs so we do it ourselves
    if (constraints.size() > 0) {
        qb.appendWhere(TextUtils.join(" AND ", constraints));
    }
    if (match != URL_SIMINFO) {
        if (projectionIn != null) {
            for (String column : projectionIn) {
                if (TYPE.equals(column) || MMSC.equals(column) || MMSPROXY.equals(column) || MMSPORT.equals(column) || APN.equals(column)) {
                // noop
                } else {
                    checkPermission();
                    break;
                }
            }
        } else {
            // null returns all columns, so need permission check
            checkPermission();
        }
    }
    SQLiteDatabase db = getReadableDatabase();
    Cursor ret = null;
    try {
        // Exclude entries marked deleted
        if (CARRIERS_TABLE.equals(qb.getTables())) {
            if (TextUtils.isEmpty(selection)) {
                selection = "";
            } else {
                selection += " and ";
            }
            selection += IS_NOT_USER_DELETED + " and " + IS_NOT_USER_DELETED_BUT_PRESENT_IN_XML + " and " + IS_NOT_CARRIER_DELETED + " and " + IS_NOT_CARRIER_DELETED_BUT_PRESENT_IN_XML;
            if (VDBG)
                log("query: selection modified to " + selection);
        }
        ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);
    } catch (SQLException e) {
        loge("got exception when querying: " + e);
    }
    if (ret != null)
        ret.setNotificationUri(getContext().getContentResolver(), url);
    return ret;
}
#end_block

#method_before
@Test
@SmallTest
public void testEnforceManagedUri() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Set enforced = false.
    ContentValues enforceManagedValue = new ContentValues();
    enforceManagedValue.put(ENFORCED_KEY, false);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = false: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to false in TelephonyProvider.
    Cursor enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(0, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns non-DPC record.
    final String[] testProjection = { Carriers._ID, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorNotEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorNotEnforced);
    assertEquals(1, cursorNotEnforced.getCount());
    cursorNotEnforced.moveToFirst();
    assertEquals(othersRecordId, cursorNotEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_OTHERS, cursorNotEnforced.getInt(1));
    // Verify that URL_FILTED_ID cannot get DPC record.
    Cursor cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 0);
    // Verify that URL_FILTED_ID can get non-DPC record.
    Cursor cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 1);
    // Set enforced = true.
    enforceManagedValue.put(ENFORCED_KEY, true);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = true: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to true in TelephonyProvider.
    enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(1, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns DPC record.
    Cursor cursorEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorEnforced);
    assertEquals(1, cursorEnforced.getCount());
    cursorEnforced.moveToFirst();
    assertEquals(dpcRecordId, cursorEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_DPC, cursorEnforced.getInt(1));
    // Verify that URL_FILTED_ID can get DPC record.
    cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 1);
    // Verify that URL_FILTED_ID cannot get non-DPC record.
    cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 0);
    // Delete testing records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), "", new String[] {});
    assertEquals(1, numRowsDeleted);
}
#method_after
@Test
@SmallTest
public void testEnforceManagedUri() {
    mTelephonyProviderTestable.fakeCallingUid(Process.SYSTEM_UID);
    final int current = 1;
    final String numeric = "123456789";
    // Insert DPC record.
    final String dpcRecordApn = "exampleApnNameDPC";
    final String dpcRecordName = "exampleNameDPC";
    int dpcRecordId = insertApnRecord(URI_DPC, dpcRecordApn, dpcRecordName, current, numeric);
    // Insert non-DPC record.
    final String othersRecordApn = "exampleApnNameOTHERS";
    final String othersRecordName = "exampleNameDPOTHERS";
    int othersRecordId = insertApnRecord(URI_TELEPHONY, othersRecordApn, othersRecordName, current, numeric);
    // Set enforced = false.
    ContentValues enforceManagedValue = new ContentValues();
    enforceManagedValue.put(ENFORCED_KEY, false);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = false: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to false in TelephonyProvider.
    Cursor enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(0, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns non-DPC record.
    final String[] testProjection = { Carriers._ID, Carriers.OWNED_BY };
    final String selection = Carriers.NUMERIC + "=?";
    String[] selectionArgs = { numeric };
    Cursor cursorNotEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorNotEnforced);
    assertEquals(1, cursorNotEnforced.getCount());
    cursorNotEnforced.moveToFirst();
    assertEquals(othersRecordId, cursorNotEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_OTHERS, cursorNotEnforced.getInt(1));
    // Verify that URL_FILTERED_ID cannot get DPC record.
    Cursor cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 0);
    // Verify that URL_FILTERED_ID can get non-DPC record.
    Cursor cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 1);
    // Set enforced = true.
    enforceManagedValue.put(ENFORCED_KEY, true);
    Log.d(TAG, "testEnforceManagedUri Updating enforced = true: " + enforceManagedValue);
    mContentResolver.update(URI_ENFORCE_MANAGED, enforceManagedValue, "", new String[] {});
    // Verify that enforced is set to true in TelephonyProvider.
    enforceCursor = mContentResolver.query(URI_ENFORCE_MANAGED, null, null, null, null);
    assertNotNull(enforceCursor);
    assertEquals(1, enforceCursor.getCount());
    enforceCursor.moveToFirst();
    assertEquals(1, enforceCursor.getInt(0));
    // Verify URL_FILTERED query only returns DPC record.
    Cursor cursorEnforced = mContentResolver.query(URI_FILTERED, testProjection, selection, selectionArgs, null);
    assertNotNull(cursorEnforced);
    assertEquals(1, cursorEnforced.getCount());
    cursorEnforced.moveToFirst();
    assertEquals(dpcRecordId, cursorEnforced.getInt(0));
    assertEquals(Carriers.OWNED_BY_DPC, cursorEnforced.getInt(1));
    // Verify that URL_FILTERED_ID can get DPC record.
    cursorNotEnforcedDpc = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(dpcRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedDpc);
    assertTrue(cursorNotEnforcedDpc.getCount() == 1);
    // Verify that URL_FILTERED_ID cannot get non-DPC record.
    cursorNotEnforcedOthers = mContentResolver.query(Uri.withAppendedPath(URI_FILTERED, Integer.toString(othersRecordId)), null, null, null, null);
    assertNotNull(cursorNotEnforcedOthers);
    assertTrue(cursorNotEnforcedOthers.getCount() == 0);
    // Delete testing records.
    int numRowsDeleted = mContentResolver.delete(URI_TELEPHONY, selection, selectionArgs);
    assertEquals(1, numRowsDeleted);
    numRowsDeleted = mContentResolver.delete(Uri.parse(URI_DPC + "/" + dpcRecordId), "", new String[] {});
    assertEquals(1, numRowsDeleted);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof DiscoveredPrinter))
        return false;
    DiscoveredPrinter other = (DiscoveredPrinter) obj;
    return Objects.equals(uuid, other.uuid) && Objects.equals(name, other.name) && Objects.equals(path, other.path) && Objects.equals(location, other.location);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof DiscoveredPrinter)) {
        return false;
    }
    DiscoveredPrinter other = (DiscoveredPrinter) obj;
    return Objects.equals(uuid, other.uuid) && Objects.equals(name, other.name) && Objects.equals(path, other.path) && Objects.equals(location, other.location);
}
#end_block

#method_before
public Stoppable start(Listener listener) {
    mListeners.add(listener);
    // If printers are already present, safely signal them to the listener after return
    if (!mPrinters.isEmpty()) {
        mHandler.post(() -> {
            if (!mListeners.contains(listener))
                return;
            new ArrayList<>(mPrinters.values()).forEach(listener::onPrinterFound);
        });
    }
    start();
    return () -> {
        mListeners.remove(listener);
        if (mListeners.isEmpty()) {
            stop();
        }
    };
}
#method_after
public void start(Listener listener) {
    mListeners.add(listener);
    // If printers are already present, signal them to the listener
    if (!mPrinters.isEmpty()) {
        if (!mListeners.contains(listener)) {
            return;
        }
        for (DiscoveredPrinter printer : new ArrayList<>(mPrinters.values())) {
            listener.onPrinterFound(printer);
        }
    }
    start();
}
#end_block

#method_before
private void stop() {
    if (mStarted) {
        mStarted = false;
        onStop();
        mPrinters.clear();
        mHandler.removeCallbacksAndMessages(null);
    }
}
#method_after
public void stop(Listener listener) {
    mListeners.remove(listener);
    if (mListeners.isEmpty()) {
        stop();
    }
}
#end_block

#method_before
void printerLost(Uri printerUri) {
    DiscoveredPrinter printer = mPrinters.remove(printerUri);
    if (printer == null)
        return;
    for (Listener listener : mListeners) {
        listener.onPrinterLost(printer);
    }
}
#method_after
void printerLost(Uri printerUri) {
    DiscoveredPrinter printer = mPrinters.remove(printerUri);
    if (printer == null) {
        return;
    }
    for (Listener listener : mListeners) {
        listener.onPrinterLost(printer);
    }
}
#end_block

#method_before
void allPrintersLost() {
    new ArrayList<>(mPrinters.keySet()).forEach(this::printerLost);
}
#method_after
void allPrintersLost() {
    for (Uri uri : new ArrayList<>(mPrinters.keySet())) {
        printerLost(uri);
    }
}
#end_block

#method_before
public Collection<DiscoveredPrinter> getSavedPrinters() {
    return getChildren().stream().filter(child -> child != this).flatMap(child -> child.getSavedPrinters().stream()).collect(Collectors.toList());
}
#method_after
public Collection<DiscoveredPrinter> getSavedPrinters() {
    List<DiscoveredPrinter> printers = new ArrayList<>();
    for (Discovery child : getChildren()) {
        if (child != this) {
            printers.addAll(child.getSavedPrinters());
        }
    }
    return printers;
}
#end_block

#method_before
public void removeSavedPrinter(Uri printerPath) {
    getChildren().stream().filter(child -> child != this).forEach(child -> child.removeSavedPrinter(printerPath));
}
#method_after
public void removeSavedPrinter(Uri printerPath) {
    for (Discovery child : getChildren()) {
        if (child != this) {
            child.removeSavedPrinter(printerPath);
        }
    }
}
#end_block

#method_before
public synchronized void unlock() {
    if (!mLocked)
        throw new IllegalArgumentException("not locked");
    mLocked = false;
    notifyAll();
}
#method_after
public synchronized void unlock() {
    if (!mLocked) {
        throw new IllegalArgumentException("not locked");
    }
    mLocked = false;
    notifyAll();
}
#end_block

#method_before
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop()");
    if (mPeerDiscovery != null) {
        mPeerDiscovery.stop();
        mPeerDiscovery = null;
        allPrintersLost();
    }
}
#method_after
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop()");
    if (mDiscoveringPeers) {
        mDiscoveringPeers = false;
        getPrintService().getP2pMonitor().stopDiscover(this);
        allPrintersLost();
    }
}
#end_block

#method_before
private void startPeerDiscovery() {
    // Ignore if already started or no known P2P printers exist
    if (mPeerDiscovery != null)
        return;
    if (getSavedPrinters().isEmpty())
        return;
    mPeerDiscovery = getPrintService().getP2pMonitor().discover(this);
}
#method_after
private void startPeerDiscovery() {
    // Ignore if already started or no known P2P printers exist
    if (mDiscoveringPeers || getSavedPrinters().isEmpty()) {
        return;
    }
    mDiscoveringPeers = true;
    getPrintService().getP2pMonitor().discover(this);
}
#end_block

#method_before
@Override
public void onPeerFound(WifiP2pDevice peer) {
    DiscoveredPrinter printer = toPrinter(peer);
    if (DEBUG)
        Log.d(TAG, "onPeerFound " + printer);
    // Only find saved printers
    getSavedPrinters().forEach(saved -> {
        if (saved.path.equals(printer.path)) {
            printerFound(saved);
        }
    });
}
#method_after
@Override
public void onPeerFound(WifiP2pDevice peer) {
    DiscoveredPrinter printer = toPrinter(peer);
    if (DEBUG)
        Log.d(TAG, "onPeerFound " + printer);
    // Only find saved printers
    for (DiscoveredPrinter saved : getSavedPrinters()) {
        if (saved.path.equals(printer.path)) {
            printerFound(saved);
        }
    }
}
#end_block

#method_before
public void addValidPrinter(DiscoveredPrinter printer) {
    if (addSavedPrinter(printer)) {
        printerFound(printer);
        if (isStarted())
            startPeerDiscovery();
    }
}
#method_after
public void addValidPrinter(DiscoveredPrinter printer) {
    if (addSavedPrinter(printer)) {
        printerFound(printer);
        if (isStarted()) {
            startPeerDiscovery();
        }
    }
}
#end_block

#method_before
public Stoppable receiveBroadcasts(BroadcastReceiver receiver, String... actions) {
    return new StoppableReceiver(this, receiver, actions);
}
#method_after
public BroadcastMonitor receiveBroadcasts(BroadcastReceiver receiver, String... actions) {
    return new BroadcastMonitor(this, receiver, actions);
}
#end_block

#method_before
public Stoppable delay(int delay, Runnable toRun) {
    mMainHandler.postDelayed(toRun, delay);
    return () -> mMainHandler.removeCallbacks(toRun);
}
#method_after
public DelayedAction delay(int delay, Runnable toRun) {
    mMainHandler.postDelayed(toRun, delay);
    return () -> mMainHandler.removeCallbacks(toRun);
}
#end_block

#method_before
public String getDescription(DiscoveredPrinter printer) {
    if (P2pUtils.isP2p(printer) || P2pUtils.isOnConnectedInterface(this, printer)) {
        return getString(R.string.wifi_direct);
    }
    String host = printer.path.getHost().replaceAll(":[0-9]+", "");
    if (!TextUtils.isEmpty(printer.location)) {
        return getString(R.string.printer_description, host, printer.location);
    } else {
        return host;
    }
}
#method_after
public String getDescription(DiscoveredPrinter printer) {
    if (P2pUtils.isP2p(printer) || P2pUtils.isOnConnectedInterface(this, printer)) {
        return getString(R.string.wifi_direct);
    }
    String host = printer.getHost();
    if (!TextUtils.isEmpty(printer.location)) {
        return getString(R.string.printer_description, host, printer.location);
    } else {
        return host;
    }
}
#end_block

#method_before
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart");
    mCapabilitiesCache = getPrintService().getCapabilitiesCache();
    // Upon any network change scan for all manually added printers
    mWifiMonitor = new WifiMonitor(getPrintService(), isConnected -> {
        if (isConnected) {
            for (DiscoveredPrinter printer : getSavedPrinters()) {
                mCapabilitiesCache.request(printer, false, capabilities -> {
                    if (capabilities != null) {
                        printerFound(printer);
                    }
                });
            }
        } else {
            allPrintersLost();
        }
    });
}
#method_after
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart");
    // Upon any network change scan for all manually added printers
    mWifiMonitor = new WifiMonitor(getPrintService(), isConnected -> {
        if (isConnected) {
            for (DiscoveredPrinter printer : getSavedPrinters()) {
                mCapabilitiesCache.request(printer, false, capabilities -> {
                    if (capabilities != null) {
                        printerFound(printer);
                    }
                });
            }
        } else {
            allPrintersLost();
        }
    });
}
#end_block

#method_before
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop");
    mWifiMonitor.stop();
    allPrintersLost();
}
#method_after
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop");
    mWifiMonitor.close();
    allPrintersLost();
}
#end_block

#method_before
void handleCapabilities(Uri printerPath, LocalPrinterCapabilities capabilities) {
    if (DEBUG)
        Log.d(TAG, "request " + printerPath + " cap=" + capabilities);
    if (capabilities == null) {
        if (mRequests.isEmpty()) {
            mFinalCallback.onNotFound();
        }
        return;
    }
    // Success, so cancel all other requests
    mRequests.forEach(mCapabilitiesCache::cancel);
    mRequests.clear();
    // Deliver a successful response
    Uri uuid = TextUtils.isEmpty(capabilities.uuid) ? null : Uri.parse(capabilities.uuid);
    String name = TextUtils.isEmpty(capabilities.name) ? printerPath.getHost() : capabilities.name;
    DiscoveredPrinter resolvedPrinter = new DiscoveredPrinter(uuid, name, printerPath, capabilities.location);
    // Only add supported printers
    if (capabilities.isSupported) {
        if (addSavedPrinter(resolvedPrinter)) {
            printerFound(resolvedPrinter);
        }
    }
    mFinalCallback.onFound(resolvedPrinter, capabilities.isSupported);
}
#method_after
void handleCapabilities(Uri printerPath, LocalPrinterCapabilities capabilities) {
    if (DEBUG)
        Log.d(TAG, "request " + printerPath + " cap=" + capabilities);
    if (capabilities == null) {
        if (mRequests.isEmpty()) {
            mFinalCallback.onNotFound();
        }
        return;
    }
    // Success, so cancel all other requests
    for (CapabilitiesCache.OnLocalPrinterCapabilities request : mRequests) {
        mCapabilitiesCache.cancel(request);
    }
    mRequests.clear();
    // Deliver a successful response
    Uri uuid = TextUtils.isEmpty(capabilities.uuid) ? null : Uri.parse(capabilities.uuid);
    String name = TextUtils.isEmpty(capabilities.name) ? printerPath.getHost() : capabilities.name;
    DiscoveredPrinter resolvedPrinter = new DiscoveredPrinter(uuid, name, printerPath, capabilities.location);
    // Only add supported printers
    if (capabilities.isSupported) {
        if (addSavedPrinter(resolvedPrinter)) {
            printerFound(resolvedPrinter);
        }
    }
    mFinalCallback.onFound(resolvedPrinter, capabilities.isSupported);
}
#end_block

#method_before
public void print(Uri uri, PrintJob printJob, LocalPrinterCapabilities capabilities, Consumer<JobStatus> listener) {
    if (DEBUG)
        Log.d(TAG, "print()");
    mJobStatusListener = listener;
    mCurrentJobStatus = new JobStatus();
    mStartTask = new StartJobTask(mContext, this, uri, printJob, capabilities) {

        @Override
        public void onCancelled(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onCancelled " + result);
            onPostExecute(ERROR_CANCEL);
        }

        @Override
        protected void onPostExecute(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onPostExecute " + result);
            mStartTask = null;
            if (result > 0) {
                mCurrentJobStatus = new JobStatus.Builder(mCurrentJobStatus).setId(result).build();
            } else if (mJobStatusListener != null) {
                String jobResult = BackendConstants.JOB_DONE_ERROR;
                if (result == ERROR_CANCEL) {
                    jobResult = BackendConstants.JOB_DONE_CANCELLED;
                } else if (result == ERROR_FILE) {
                    jobResult = BackendConstants.JOB_DONE_CORRUPT;
                }
                // If the start attempt failed and we are still listening, notify and be done
                mCurrentJobStatus = new JobStatus.Builder().setJobState(BackendConstants.JOB_STATE_DONE).setJobResult(jobResult).build();
                mJobStatusListener.accept(mCurrentJobStatus);
                mJobStatusListener = null;
            }
        }
    };
    mStartTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#method_after
public void print(Uri uri, PrintJob printJob, LocalPrinterCapabilities capabilities, Consumer<JobStatus> listener) {
    if (DEBUG)
        Log.d(TAG, "print()");
    mJobStatusListener = listener;
    mCurrentJobStatus = new JobStatus();
    mStartTask = new StartJobTask(mContext, this, uri, printJob, capabilities) {

        @Override
        public void onCancelled(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask onCancelled " + result);
            onPostExecute(ERROR_CANCEL);
        }

        @Override
        protected void onPostExecute(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask onPostExecute " + result);
            mStartTask = null;
            if (result > 0) {
                mCurrentJobStatus = new JobStatus.Builder(mCurrentJobStatus).setId(result).build();
            } else if (mJobStatusListener != null) {
                String jobResult = BackendConstants.JOB_DONE_ERROR;
                if (result == ERROR_CANCEL) {
                    jobResult = BackendConstants.JOB_DONE_CANCELLED;
                } else if (result == ERROR_FILE) {
                    jobResult = BackendConstants.JOB_DONE_CORRUPT;
                }
                // If the start attempt failed and we are still listening, notify and be done
                mCurrentJobStatus = new JobStatus.Builder().setJobState(BackendConstants.JOB_STATE_DONE).setJobResult(jobResult).build();
                mJobStatusListener.accept(mCurrentJobStatus);
                mJobStatusListener = null;
            }
        }
    };
    mStartTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#end_block

#method_before
PrinterInfo createPrinterInfo(boolean knownGood) {
    if (mCapabilities == null) {
        if (P2pUtils.isP2p(mDiscoveredPrinter)) {
            // Allow user to select a P2P to establish a connection
            PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, mDiscoveredPrinter.name, PrinterInfo.STATUS_IDLE).setIconResourceId(R.drawable.ic_printer).setDescription(mPrintService.getDescription(mDiscoveredPrinter));
            return builder.build();
        } else if (!knownGood) {
            // Ignore unknown LAN printers with no caps
            return null;
        }
    } else if (!mCapabilities.isSupported) {
        // Fail out if capabilities indicate not-supported.
        return null;
    }
    // Get the most recently discovered version of this printer
    DiscoveredPrinter printer = mPrintService.getDiscovery().getPrinter(mDiscoveredPrinter.getUri());
    if (printer == null)
        return null;
    boolean idle = mFound && mCapabilities != null;
    PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, printer.name, idle ? PrinterInfo.STATUS_IDLE : PrinterInfo.STATUS_UNAVAILABLE).setIconResourceId(R.drawable.ic_printer).setDescription(mPrintService.getDescription(mDiscoveredPrinter));
    if (mCapabilities != null) {
        // Add capabilities if we have them
        PrinterCapabilitiesInfo.Builder capabilitiesBuilder = new PrinterCapabilitiesInfo.Builder(mPrinterId);
        mCapabilities.buildCapabilities(mPrintService, capabilitiesBuilder);
        builder.setCapabilities(capabilitiesBuilder.build());
    }
    return builder.build();
}
#method_after
PrinterInfo createPrinterInfo(boolean knownGood) {
    if (mCapabilities == null) {
        if (P2pUtils.isP2p(mDiscoveredPrinter)) {
            // Allow user to select a P2P to establish a connection
            PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, mDiscoveredPrinter.name, PrinterInfo.STATUS_IDLE).setIconResourceId(R.drawable.ic_printer).setDescription(mPrintService.getDescription(mDiscoveredPrinter));
            return builder.build();
        } else if (!knownGood) {
            // Ignore unknown LAN printers with no caps
            return null;
        }
    } else if (!mCapabilities.isSupported) {
        // Fail out if capabilities indicate not-supported.
        return null;
    }
    // Get the most recently discovered version of this printer
    DiscoveredPrinter printer = mPrintService.getDiscovery().getPrinter(mDiscoveredPrinter.getUri());
    if (printer == null) {
        return null;
    }
    boolean idle = mFound && mCapabilities != null;
    PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, printer.name, idle ? PrinterInfo.STATUS_IDLE : PrinterInfo.STATUS_UNAVAILABLE).setIconResourceId(R.drawable.ic_printer).setDescription(mPrintService.getDescription(mDiscoveredPrinter));
    if (mCapabilities != null) {
        // Add capabilities if we have them
        PrinterCapabilitiesInfo.Builder capabilitiesBuilder = new PrinterCapabilitiesInfo.Builder(mPrinterId);
        mCapabilities.buildCapabilities(mPrintService, capabilitiesBuilder);
        builder.setCapabilities(capabilitiesBuilder.build());
    }
    return builder.build();
}
#end_block

#method_before
@Override
public void onCapabilities(LocalPrinterCapabilities capabilities) {
    if (mSession.isDestroyed() || !mSession.isKnown(mPrinterId))
        return;
    if (capabilities == null) {
        if (DEBUG)
            Log.d(TAG, "No capabilities so removing printer " + this);
        mSession.removePrinters(Collections.singletonList(mPrinterId));
    } else {
        mCapabilities = capabilities;
        mSession.handlePrinter(this);
    }
}
#method_after
@Override
public void onCapabilities(LocalPrinterCapabilities capabilities) {
    if (mSession.isDestroyed() || !mSession.isKnown(mPrinterId)) {
        return;
    }
    if (capabilities == null) {
        if (DEBUG)
            Log.d(TAG, "No capabilities so removing printer " + this);
        mSession.removePrinters(Collections.singletonList(mPrinterId));
    } else {
        mCapabilities = capabilities;
        mSession.handlePrinter(this);
    }
}
#end_block

#method_before
private void startTracking() {
    mTracking = true;
    if (mTrackingConnection != null)
        return;
    // For any P2P printer, obtain a connection
    if (P2pUtils.isP2p(mDiscoveredPrinter) || P2pUtils.isOnConnectedInterface(mPrintService, mDiscoveredPrinter)) {
        ConnectionListener listener = new ConnectionListener() {

            @Override
            public void onConnectionComplete(DiscoveredPrinter printer) {
                if (DEBUG)
                    Log.d(TAG, "connection complete " + printer);
                if (printer == null) {
                    mTrackingConnection = null;
                }
            }

            @Override
            public void onConnectionDelayed(boolean delayed) {
                if (DEBUG)
                    Log.d(TAG, "connection delayed=" + delayed);
                if (delayed) {
                    Toast.makeText(mPrintService, R.string.connect_hint_text, Toast.LENGTH_LONG).show();
                }
            }
        };
        mTrackingConnection = P2pPrinterConnection.connectPrinter(mPrintService, mDiscoveredPrinter, listener);
    }
}
#method_after
private void startTracking() {
    mTracking = true;
    if (mTrackingConnection != null) {
        return;
    }
    // For any P2P printer, obtain a connection
    if (P2pUtils.isP2p(mDiscoveredPrinter) || P2pUtils.isOnConnectedInterface(mPrintService, mDiscoveredPrinter)) {
        ConnectionListener listener = new ConnectionListener() {

            @Override
            public void onConnectionComplete(DiscoveredPrinter printer) {
                if (DEBUG)
                    Log.d(TAG, "connection complete " + printer);
                if (printer == null) {
                    mTrackingConnection = null;
                }
            }

            @Override
            public void onConnectionDelayed(boolean delayed) {
                if (DEBUG)
                    Log.d(TAG, "connection delayed=" + delayed);
                if (delayed) {
                    Toast.makeText(mPrintService, R.string.connect_hint_text, Toast.LENGTH_LONG).show();
                }
            }
        };
        mTrackingConnection = new P2pPrinterConnection(mPrintService, mDiscoveredPrinter, listener);
    }
}
#end_block

#method_before
void stopTracking() {
    if (mTrackingConnection != null) {
        mTrackingConnection.stop();
        mTrackingConnection = null;
    }
    mTracking = false;
}
#method_after
void stopTracking() {
    if (mTrackingConnection != null) {
        mTrackingConnection.close();
        mTrackingConnection = null;
    }
    mTracking = false;
}
#end_block

#method_before
public Stoppable resolve(NsdServiceInfo serviceInfo, NsdManager.ResolveListener listener) {
    if (DEBUG) {
        Log.d(TAG, "Adding resolve of " + serviceInfo.getServiceName() + " to queue size=" + mResolveRequests.size());
    }
    NsdResolveRequest request = new NsdResolveRequest(mNsdManager, serviceInfo, listener);
    mResolveRequests.addLast(request);
    if (mResolveRequests.size() == 1) {
        resolveNextRequest();
    }
    return () -> {
        if (mResolveRequests.contains(request) && mResolveRequests.get(0) != request) {
            mResolveRequests.remove(request);
        }
    };
}
#method_after
public NsdResolveRequest resolve(NsdServiceInfo serviceInfo, NsdManager.ResolveListener listener) {
    if (DEBUG) {
        Log.d(TAG, "Adding resolve of " + serviceInfo.getServiceName() + " to queue size=" + mResolveRequests.size());
    }
    NsdResolveRequest request = new NsdResolveRequest(mNsdManager, serviceInfo, listener);
    mResolveRequests.addLast(request);
    if (mResolveRequests.size() == 1) {
        resolveNextRequest();
    }
    return request;
}
#end_block

#method_before
public void start() {
    mStartTime = System.currentTimeMillis();
    if (DEBUG)
        Log.d(TAG, "resolveService " + mServiceInfo.getServiceName());
    mNsdManager.resolveService(mServiceInfo, this);
}
#method_after
private void start() {
    mStartTime = System.currentTimeMillis();
    if (DEBUG)
        Log.d(TAG, "resolveService " + mServiceInfo.getServiceName());
    mNsdManager.resolveService(mServiceInfo, this);
}
#end_block

#method_before
@Override
public void onConnectionOpen(String networkInterface, WifiP2pInfo info) {
    if (mListener == null)
        return;
    try {
        mInterface = NetworkInterface.getByName(networkInterface);
    } catch (SocketException ignored) {
    }
    if (mInterface == null) {
        if (DEBUG)
            Log.d(TAG, "Failed to get interface from " + networkInterface);
        mListener.onConnectionComplete(null);
        stop();
        return;
    }
    if (DEBUG)
        Log.d(TAG, "Connected on network interface " + mInterface);
    // Timeout after a while if MDNS does not find a printer
    mMdnsDiscoveryTimeout = mService.delay(TIMEOUT_DISCOVERY, () -> {
        mMdnsDiscovery.stop();
        if (mListener != null)
            mListener.onConnectionComplete(null);
        stop();
    });
    mMdnsDiscovery = mService.getMdnsDiscovery().start(this);
}
#method_after
@Override
public void onConnectionOpen(String networkInterface, WifiP2pInfo info) {
    if (mListener == null) {
        return;
    }
    try {
        mInterface = NetworkInterface.getByName(networkInterface);
    } catch (SocketException ignored) {
    }
    if (mInterface == null) {
        if (DEBUG)
            Log.d(TAG, "Failed to get interface from " + networkInterface);
        mListener.onConnectionComplete(null);
        close();
        return;
    }
    if (DEBUG)
        Log.d(TAG, "Connected on network interface " + mInterface);
    // Timeout after a while if MDNS does not find a printer
    mMdnsDiscoveryTimeout = mService.delay(TIMEOUT_DISCOVERY, () -> {
        mMdnsDiscovery.stop(this);
        if (mListener != null) {
            mListener.onConnectionComplete(null);
        }
        close();
    });
    mMdnsDiscovery.start(this);
}
#end_block

#method_before
@Override
public void onConnectionClosed() {
    if (DEBUG)
        Log.d(TAG, "closed/failed connection to " + P2pMonitor.toString(mPeer));
    if (mListener != null) {
        mListener.onConnectionComplete(null);
    }
    stop();
}
#method_after
@Override
public void onConnectionClosed() {
    if (DEBUG)
        Log.d(TAG, "closed/failed connection to " + P2pMonitor.toString(mPeer));
    if (mListener != null) {
        mListener.onConnectionComplete(null);
    }
    close();
}
#end_block

#method_before
@Override
public void onConnectionDelayed(boolean delayed) {
    if (mListener == null)
        return;
    mListener.onConnectionDelayed(delayed);
}
#method_after
@Override
public void onConnectionDelayed(boolean delayed) {
    if (mListener == null) {
        return;
    }
    mListener.onConnectionDelayed(delayed);
}
#end_block

#method_before
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (DEBUG)
        Log.d(TAG, "onPrinterFound(" + printer + ")");
    if (mListener == null)
        return;
    Inet4Address printerAddress;
    try {
        printerAddress = (Inet4Address) Inet4Address.getByName(printer.path.getHost());
    } catch (UnknownHostException e) {
        return;
    }
    if (mInterface != null && P2pUtils.isOnInterface(mInterface, printerAddress)) {
        // Stop discovery and start capabilities query
        mMdnsDiscovery.stop();
        mMdnsDiscoveryTimeout.stop();
        mService.getCapabilitiesCache().request(printer, true, capabilities -> onCapabilities(printer, capabilities));
    }
}
#method_after
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (DEBUG)
        Log.d(TAG, "onPrinterFound(" + printer + ")");
    if (mListener == null) {
        return;
    }
    Inet4Address printerAddress;
    try {
        printerAddress = (Inet4Address) Inet4Address.getByName(printer.path.getHost());
    } catch (UnknownHostException e) {
        return;
    }
    if (mInterface != null && P2pUtils.isOnInterface(mInterface, printerAddress)) {
        // Stop discovery and start capabilities query
        mMdnsDiscovery.stop(this);
        mMdnsDiscoveryTimeout.cancel();
        mService.getCapabilitiesCache().request(printer, true, capabilities -> onCapabilities(printer, capabilities));
    }
}
#end_block

#method_before
private void onCapabilities(DiscoveredPrinter printer, LocalPrinterCapabilities capabilities) {
    if (mListener == null)
        return;
    if (DEBUG)
        Log.d(TAG, "Printer " + printer + " caps=" + capabilities);
    if (capabilities == null) {
        mListener.onConnectionComplete(null);
        stop();
    } else {
        // Make a copy of the printer bearing its P2P path
        DiscoveredPrinter p2pPrinter = new DiscoveredPrinter(printer.uuid, printer.name, P2pDiscovery.toPath(mPeer), printer.location);
        mListener.onConnectionComplete(p2pPrinter);
    }
}
#method_after
private void onCapabilities(DiscoveredPrinter printer, LocalPrinterCapabilities capabilities) {
    if (mListener == null) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, "Printer " + printer + " caps=" + capabilities);
    if (capabilities == null) {
        mListener.onConnectionComplete(null);
        close();
    } else {
        // Make a copy of the printer bearing its P2P path
        DiscoveredPrinter p2pPrinter = new DiscoveredPrinter(printer.uuid, printer.name, P2pDiscovery.toPath(mPeer), printer.location);
        mListener.onConnectionComplete(p2pPrinter);
    }
}
#end_block

#method_before
private DiscoveredPrinter first(Uri printerUri) {
    for (Discovery discovery : getChildren()) {
        DiscoveredPrinter found = discovery.getPrinter(printerUri);
        if (found != null)
            return found;
    }
    return null;
}
#method_after
private DiscoveredPrinter first(Uri printerUri) {
    for (Discovery discovery : getChildren()) {
        DiscoveredPrinter found = discovery.getPrinter(printerUri);
        if (found != null) {
            return found;
        }
    }
    return null;
}
#end_block

#method_before
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart()");
    for (Discovery discovery : mDiscoveries) {
        mStarted.add(discovery.start(mChildListener));
    }
}
#method_after
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart()");
    for (Discovery discovery : mDiscoveries) {
        discovery.start(mChildListener);
        mStartedDiscoveries.add(discovery);
    }
}
#end_block

#method_before
private void stopAndClearAll() {
    for (Stoppable started : mStarted) {
        started.stop();
    }
    mStarted.clear();
    allPrintersLost();
}
#method_after
private void stopAndClearAll() {
    for (Discovery discovery : mStartedDiscoveries) {
        discovery.stop(mChildListener);
    }
    mStartedDiscoveries.clear();
    allPrintersLost();
}
#end_block

#method_before
@Override
Collection<Discovery> getChildren() {
    return mDiscoveries.stream().flatMap(child -> child.getChildren().stream()).collect(Collectors.toList());
}
#method_after
@Override
Collection<Discovery> getChildren() {
    List<Discovery> children = new ArrayList<>();
    for (Discovery child : mDiscoveries) {
        children.addAll(child.getChildren());
    }
    return children;
}
#end_block

#method_before
@Override
protected LocalPrinterCapabilities doInBackground(Void... dummy) {
    long start = System.currentTimeMillis();
    LocalPrinterCapabilities printerCaps = new LocalPrinterCapabilities();
    try {
        printerCaps.inetAddress = InetAddress.getByName(mUri.getHost());
    } catch (UnknownHostException e) {
        return null;
    }
    boolean online = isDeviceOnline(mUri);
    if (DEBUG) {
        Log.d(TAG, "isDeviceOnline uri=" + mUri + " online=" + online + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    if (!online || isCancelled())
        return null;
    // Do not permit more than a single call to this API or crashes may result
    try {
        // Always allow priority capability requests to execute first
        sLock.lock(mPriority ? 1 : 0);
    } catch (InterruptedException e) {
        return null;
    }
    int status = -1;
    start = System.currentTimeMillis();
    try {
        if (isCancelled())
            return null;
        status = mBackend.nativeGetCapabilities(Backend.getIp(mUri.getHost()), mUri.getPort(), mUri.getPath(), mUri.getScheme(), mTimeout, printerCaps);
    } finally {
        sLock.unlock();
    }
    if (DEBUG) {
        Log.d(TAG, "callNativeGetCapabilities uri=" + mUri + " status=" + status + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    return status == BackendConstants.STATUS_OK ? printerCaps : null;
}
#method_after
@Override
protected LocalPrinterCapabilities doInBackground(Void... dummy) {
    long start = System.currentTimeMillis();
    LocalPrinterCapabilities printerCaps = new LocalPrinterCapabilities();
    try {
        printerCaps.inetAddress = InetAddress.getByName(mUri.getHost());
    } catch (UnknownHostException e) {
        return null;
    }
    boolean online = isDeviceOnline(mUri);
    if (DEBUG) {
        Log.d(TAG, "isDeviceOnline uri=" + mUri + " online=" + online + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    if (!online || isCancelled()) {
        return null;
    }
    // Do not permit more than a single call to this API or crashes may result
    try {
        // Always allow priority capability requests to execute first
        sLock.lock(mPriority ? 1 : 0);
    } catch (InterruptedException e) {
        return null;
    }
    int status = -1;
    start = System.currentTimeMillis();
    try {
        if (isCancelled()) {
            return null;
        }
        status = mBackend.nativeGetCapabilities(Backend.getIp(mUri.getHost()), mUri.getPort(), mUri.getPath(), mUri.getScheme(), mTimeout, printerCaps);
    } finally {
        sLock.unlock();
    }
    if (DEBUG) {
        Log.d(TAG, "callNativeGetCapabilities uri=" + mUri + " status=" + status + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    return status == BackendConstants.STATUS_OK ? printerCaps : null;
}
#end_block

#method_before
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart() " + mServiceName);
    NsdServiceListener serviceListener = new NsdServiceListener() {

        @Override
        public void onStartDiscoveryFailed(String s, int i) {
        }
    };
    NsdManager nsdManager = mNsdResolveQueue.getNsdManager();
    nsdManager.discoverServices(mServiceName, NsdManager.PROTOCOL_DNS_SD, serviceListener);
    mToStop.add(() -> nsdManager.stopServiceDiscovery(serviceListener));
}
#method_after
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart() " + mServiceName);
    NsdServiceListener serviceListener = new NsdServiceListener() {

        @Override
        public void onStartDiscoveryFailed(String s, int i) {
        // Do nothing
        }
    };
    NsdManager nsdManager = mNsdResolveQueue.getNsdManager();
    nsdManager.discoverServices(mServiceName, NsdManager.PROTOCOL_DNS_SD, serviceListener);
    mServiceListeners.add(serviceListener);
}
#end_block

#method_before
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop() " + mServiceName);
    mToStop.forEach(Stoppable::stop);
    mToStop.clear();
}
#method_after
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop() " + mServiceName);
    NsdManager nsdManager = mNsdResolveQueue.getNsdManager();
    for (NsdServiceListener listener : mServiceListeners) {
        nsdManager.stopServiceDiscovery(listener);
    }
    mServiceListeners.clear();
    for (Resolver resolver : mResolvers) {
        resolver.cancel();
    }
    mResolvers.clear();
}
#end_block

#method_before
@Override
public void onServiceFound(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "found " + mServiceName + " name=" + info.getServiceName());
    getHandler().post(() -> mToStop.add(new Resolver(info)));
}
#method_after
@Override
public void onServiceFound(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "found " + mServiceName + " name=" + info.getServiceName());
    getHandler().post(() -> mResolvers.add(new Resolver(info)));
}
#end_block

#method_before
@Override
public void onResolveFailed(final NsdServiceInfo info, final int errorCode) {
    mToStop.remove(this);
    mResolve = null;
}
#method_after
@Override
public void onResolveFailed(final NsdServiceInfo info, final int errorCode) {
    mResolvers.remove(this);
}
#end_block

#method_before
@Override
public void onServiceResolved(final NsdServiceInfo info) {
    mToStop.remove(this);
    mResolve = null;
    if (!isStarted())
        return;
    DiscoveredPrinter printer = toNetworkPrinter(info);
    if (DEBUG)
        Log.d(TAG, "Service " + info.getServiceName() + " resolved to " + printer);
    if (printer == null)
        return;
    printerFound(printer);
}
#method_after
@Override
public void onServiceResolved(final NsdServiceInfo info) {
    mResolvers.remove(this);
    if (!isStarted()) {
        return;
    }
    DiscoveredPrinter printer = toNetworkPrinter(info);
    if (DEBUG)
        Log.d(TAG, "Service " + info.getServiceName() + " resolved to " + printer);
    if (printer == null) {
        return;
    }
    printerFound(printer);
}
#end_block

#method_before
private void updateSavedPrinters() {
    int savedCount = mPrintService.getDiscovery().getSavedPrinters().size();
    if (savedCount == 0) {
        if (getPreferenceScreen().findPreference(mSavedPrintersCategory.getKey()) != null) {
            getPreferenceScreen().removePreference(mSavedPrintersCategory);
        }
    } else {
        if (getPreferenceScreen().findPreference(mSavedPrintersCategory.getKey()) == null) {
            getPreferenceScreen().addPreference(mSavedPrintersCategory);
        }
        mSavedPrintersCategory.removeAll();
        // With the service enumerate all saved printers
        mPrintService.getDiscovery().getSavedPrinters().forEach(printer -> {
            if (DEBUG)
                Log.d(TAG, "Adding saved printer " + printer);
            PrinterPreference pref = new PrinterPreference(getContext(), mPrintService, printer, false);
            pref.setOrder(ORDER_SAVED);
            pref.setOnPreferenceClickListener(preference -> {
                showRemovalDialog(printer);
                return true;
            });
            mSavedPrintersCategory.addPreference(pref);
        });
    }
}
#method_after
private void updateSavedPrinters() {
    int savedCount = mPrintService.getDiscovery().getSavedPrinters().size();
    if (savedCount == 0) {
        if (getPreferenceScreen().findPreference(mSavedPrintersCategory.getKey()) != null) {
            getPreferenceScreen().removePreference(mSavedPrintersCategory);
        }
    } else {
        if (getPreferenceScreen().findPreference(mSavedPrintersCategory.getKey()) == null) {
            getPreferenceScreen().addPreference(mSavedPrintersCategory);
        }
        mSavedPrintersCategory.removeAll();
        // With the service enumerate all saved printers
        for (DiscoveredPrinter printer : mPrintService.getDiscovery().getSavedPrinters()) {
            if (DEBUG)
                Log.d(TAG, "Adding saved printer " + printer);
            PrinterPreference pref = new PrinterPreference(getContext(), mPrintService, printer, false);
            pref.setOrder(ORDER_SAVED);
            pref.setOnPreferenceClickListener(preference -> {
                showRemovalDialog(printer);
                return true;
            });
            mSavedPrintersCategory.addPreference(pref);
        }
    }
}
#end_block

#method_before
private void showRemovalDialog(DiscoveredPrinter printer) {
    new AlertDialog.Builder(getContext()).setTitle(printer.name).setMessage(mPrintService.getDescription(printer)).setPositiveButton(android.R.string.cancel, null).setNeutralButton(R.string.forget, (dialog, which) -> {
        mPrintService.getDiscovery().removeSavedPrinter(printer.path);
        updateSavedPrinters();
    }).show();
}
#method_after
private void showRemovalDialog(DiscoveredPrinter printer) {
    String message;
    if (P2pUtils.isP2p(printer)) {
        message = mPrintService.getString(R.string.connects_via_wifi_direct);
    } else {
        message = mPrintService.getString(R.string.connects_via_network, printer.getHost());
    }
    new AlertDialog.Builder(getContext()).setTitle(printer.name).setMessage(message).setNegativeButton(android.R.string.cancel, null).setPositiveButton(R.string.forget, (dialog, which) -> {
        mPrintService.getDiscovery().removeSavedPrinter(printer.path);
        updateSavedPrinters();
    }).show();
}
#end_block

#method_before
@Override
public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
    if (DEBUG)
        Log.d(TAG, "onServiceConnected");
    mPrintService = BuiltInPrintService.getInstance();
    if (mPrintService == null)
        return;
    // If we do not yet have permissions, ask.
    if (getContext().checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
        getActivity().requestPermissions(new String[] { Manifest.permission.ACCESS_COARSE_LOCATION }, REQUEST_PERMISSION);
    } else {
        startP2pDiscovery();
    }
}
#method_after
@Override
public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
    if (DEBUG)
        Log.d(TAG, "onServiceConnected");
    mPrintService = BuiltInPrintService.getInstance();
    if (mPrintService == null) {
        return;
    }
    // If we do not yet have permissions, ask.
    if (getContext().checkSelfPermission(Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
        getActivity().requestPermissions(new String[] { Manifest.permission.ACCESS_COARSE_LOCATION }, REQUEST_PERMISSION);
    } else {
        startP2pDiscovery();
    }
}
#end_block

#method_before
private void startP2pDiscovery() {
    if (mPrintService != null && mPeerDiscovery == null) {
        mPeerDiscovery = mPrintService.getP2pMonitor().discover(new P2pListener());
    }
}
#method_after
private void startP2pDiscovery() {
    if (mPrintService != null && mPeerDiscoveryListener == null) {
        mPeerDiscoveryListener = new P2pListener();
        mPrintService.getP2pMonitor().discover(mPeerDiscoveryListener);
    }
}
#end_block

#method_before
@Override
public void onPeerFound(WifiP2pDevice peer) {
    if (DEBUG)
        Log.d(TAG, "onPeerFound: " + P2pMonitor.toString(peer));
    if (mPrintService == null)
        return;
    DiscoveredPrinter printer = P2pDiscovery.toPrinter(peer);
    // Ignore printers we have already added
    for (DiscoveredPrinter prior : mPrintService.getP2pDiscovery().getSavedPrinters()) {
        if (prior.path.equals(printer.path))
            return;
    }
    // Install a preference so the user can add this printer
    PrinterPreference pref = getPrinterPreference(printer.getUri());
    if (pref != null) {
        pref.updatePrinter(printer);
    } else {
        pref = new PrinterPreference(getContext(), mPrintService, printer, true);
        pref.setOnPreferenceClickListener(preference -> {
            if (DEBUG)
                Log.d(TAG, "add " + P2pDiscovery.toPrinter(peer));
            new AddP2pPrinterDialog(FindP2pPrintersFragment.this, mPrintService, peer).show();
            return true;
        });
        mAvailableCategory.addPreference(pref);
    }
}
#method_after
@Override
public void onPeerFound(WifiP2pDevice peer) {
    if (DEBUG)
        Log.d(TAG, "onPeerFound: " + P2pMonitor.toString(peer));
    if (mPrintService == null) {
        return;
    }
    DiscoveredPrinter printer = P2pDiscovery.toPrinter(peer);
    // Ignore printers we have already added
    for (DiscoveredPrinter prior : mPrintService.getP2pDiscovery().getSavedPrinters()) {
        if (prior.path.equals(printer.path)) {
            return;
        }
    }
    // Install a preference so the user can add this printer
    PrinterPreference pref = getPrinterPreference(printer.getUri());
    if (pref != null) {
        pref.updatePrinter(printer);
    } else {
        pref = new PrinterPreference(getContext(), mPrintService, printer, true);
        pref.setOnPreferenceClickListener(preference -> {
            if (DEBUG)
                Log.d(TAG, "add " + P2pDiscovery.toPrinter(peer));
            new AddP2pPrinterDialog(FindP2pPrintersFragment.this, mPrintService, peer).show();
            return true;
        });
        mAvailableCategory.addPreference(pref);
    }
}
#end_block

#method_before
@Override
public void onPeerLost(WifiP2pDevice peer) {
    if (DEBUG)
        Log.d(TAG, "onPeerLost: " + P2pMonitor.toString(peer));
    if (mPrintService == null)
        return;
    DiscoveredPrinter printer = P2pDiscovery.toPrinter(peer);
    // Remove this preference because the printer is no longer available
    PrinterPreference pref = getPrinterPreference(printer.path);
    if (pref != null) {
        mAvailableCategory.removePreference(pref);
    }
}
#method_after
@Override
public void onPeerLost(WifiP2pDevice peer) {
    if (DEBUG)
        Log.d(TAG, "onPeerLost: " + P2pMonitor.toString(peer));
    if (mPrintService == null) {
        return;
    }
    DiscoveredPrinter printer = P2pDiscovery.toPrinter(peer);
    // Remove this preference because the printer is no longer available
    PrinterPreference pref = getPrinterPreference(printer.path);
    if (pref != null) {
        mAvailableCategory.removePreference(pref);
    }
}
#end_block

#method_before
boolean addSavedPrinter(DiscoveredPrinter printer) {
    Uri printerUri = printer.getUri();
    DiscoveredPrinter old = find(printerUri);
    if (old != null) {
        if (printer.equals(old))
            return false;
        mSavedPrinters.remove(old);
    }
    mSavedPrinters.add(0, printer);
    save();
    return true;
}
#method_after
boolean addSavedPrinter(DiscoveredPrinter printer) {
    Uri printerUri = printer.getUri();
    DiscoveredPrinter old = find(printerUri);
    if (old != null) {
        if (printer.equals(old)) {
            return false;
        }
        mSavedPrinters.remove(old);
    }
    mSavedPrinters.add(0, printer);
    save();
    return true;
}
#end_block

#method_before
private DiscoveredPrinter find(Uri printerUri) {
    return mSavedPrinters.stream().filter(printer -> printer.getUri().equals(printerUri)).findFirst().orElse(null);
}
#method_after
private DiscoveredPrinter find(Uri printerUri) {
    for (DiscoveredPrinter printer : mSavedPrinters) {
        if (printer.getUri().equals(printerUri)) {
            return printer;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void removeSavedPrinter(Uri printerPath) {
    mSavedPrinters.stream().filter(printer -> printer.path.equals(printerPath)).findFirst().ifPresent(printer -> {
        mSavedPrinters.remove(printer);
        save();
    });
}
#method_after
@Override
public void removeSavedPrinter(Uri printerPath) {
    for (DiscoveredPrinter printer : mSavedPrinters) {
        if (printer.path.equals(printerPath)) {
            mSavedPrinters.remove(printer);
            save();
            return;
        }
    }
}
#end_block

#method_before
private List<DiscoveredPrinter> load() {
    List<DiscoveredPrinter> printers = new ArrayList<>();
    if (!mCacheFile.exists())
        return printers;
    try (JsonReader reader = new JsonReader(new BufferedReader(new FileReader(mCacheFile)))) {
        reader.beginObject();
        while (reader.hasNext()) {
            String itemName = reader.nextName();
            if (PRINTER_LIST_NAMES.contains(itemName)) {
                reader.beginArray();
                while (reader.hasNext()) {
                    printers.add(new DiscoveredPrinter(reader));
                }
                reader.endArray();
            }
        }
        reader.endObject();
    } catch (IllegalStateException | IOException ignored) {
        Log.w(TAG, "Error while loading from " + mCacheFile, ignored);
    }
    if (DEBUG)
        Log.d(TAG, "Loaded size=" + printers.size() + " from " + mCacheFile);
    return printers;
}
#method_after
private List<DiscoveredPrinter> load() {
    List<DiscoveredPrinter> printers = new ArrayList<>();
    if (!mCacheFile.exists()) {
        return printers;
    }
    try (JsonReader reader = new JsonReader(new BufferedReader(new FileReader(mCacheFile)))) {
        reader.beginObject();
        while (reader.hasNext()) {
            String itemName = reader.nextName();
            if (PRINTER_LIST_NAMES.contains(itemName)) {
                reader.beginArray();
                while (reader.hasNext()) {
                    printers.add(new DiscoveredPrinter(reader));
                }
                reader.endArray();
            }
        }
        reader.endObject();
    } catch (IllegalStateException | IOException ignored) {
        Log.w(TAG, "Error while loading from " + mCacheFile, ignored);
    }
    if (DEBUG)
        Log.d(TAG, "Loaded size=" + printers.size() + " from " + mCacheFile);
    return printers;
}
#end_block

#method_before
@Override
public void close() {
    if (DEBUG)
        Log.d(TAG, "stop()");
    mStopped = true;
    mWifiMonitor.stop();
    mP2pMonitor.stop();
}
#method_after
@Override
public void close() {
    if (DEBUG)
        Log.d(TAG, "stop()");
    mIsStopped = true;
    mWifiMonitor.close();
    mP2pMonitor.close();
}
#end_block

#method_before
public void request(DiscoveredPrinter printer, boolean highPriority, OnLocalPrinterCapabilities onLocalPrinterCapabilities) {
    if (DEBUG)
        Log.d(TAG, "request() printer=" + printer + " high=" + highPriority);
    LocalPrinterCapabilities capabilities = get(printer);
    if (capabilities != null && capabilities.nativeData != null) {
        onLocalPrinterCapabilities.onCapabilities(capabilities);
        return;
    }
    if (P2pUtils.isOnConnectedInterface(mService, printer)) {
        if (DEBUG)
            Log.d(TAG, "Adding to P2P evict list: " + printer);
        mToEvictP2p.add(printer.path);
    } else {
        if (DEBUG)
            Log.d(TAG, "Adding to WLAN evict list: " + printer);
        mToEvict.add(printer.path);
    }
    // Create a new request with timeout based on priority
    Request request = mRequests.computeIfAbsent(printer.path, uri -> new Request(printer, highPriority ? SECOND_PASS_TIMEOUT : FIRST_PASS_TIMEOUT));
    if (highPriority)
        request.mHighPriority = true;
    request.mCallbacks.add(onLocalPrinterCapabilities);
    startNextRequest();
}
#method_after
public void request(DiscoveredPrinter printer, boolean highPriority, OnLocalPrinterCapabilities onLocalPrinterCapabilities) {
    if (DEBUG)
        Log.d(TAG, "request() printer=" + printer + " high=" + highPriority);
    LocalPrinterCapabilities capabilities = get(printer);
    if (capabilities != null && capabilities.nativeData != null) {
        onLocalPrinterCapabilities.onCapabilities(capabilities);
        return;
    }
    if (P2pUtils.isOnConnectedInterface(mService, printer)) {
        if (DEBUG)
            Log.d(TAG, "Adding to P2P evict list: " + printer);
        mToEvictP2p.add(printer.path);
    } else {
        if (DEBUG)
            Log.d(TAG, "Adding to WLAN evict list: " + printer);
        mToEvict.add(printer.path);
    }
    // Create a new request with timeout based on priority
    Request request = mRequests.computeIfAbsent(printer.path, uri -> new Request(printer, highPriority ? SECOND_PASS_TIMEOUT : FIRST_PASS_TIMEOUT));
    if (highPriority) {
        request.mHighPriority = true;
    }
    request.mCallbacks.add(onLocalPrinterCapabilities);
    startNextRequest();
}
#end_block

#method_before
public void cancel(OnLocalPrinterCapabilities onLocalPrinterCapabilities) {
    List<Uri> toDrop = new ArrayList<>();
    for (Map.Entry<Uri, Request> entry : mRequests.entrySet()) {
        Request request = entry.getValue();
        request.mCallbacks.remove(onLocalPrinterCapabilities);
        if (request.mCallbacks.isEmpty()) {
            toDrop.add(entry.getKey());
            request.stop();
        }
    }
    toDrop.forEach(mRequests::remove);
}
#method_after
public void cancel(OnLocalPrinterCapabilities onLocalPrinterCapabilities) {
    List<Uri> toDrop = new ArrayList<>();
    for (Map.Entry<Uri, Request> entry : mRequests.entrySet()) {
        Request request = entry.getValue();
        request.mCallbacks.remove(onLocalPrinterCapabilities);
        if (request.mCallbacks.isEmpty()) {
            toDrop.add(entry.getKey());
            request.cancel();
        }
    }
    for (Uri request : toDrop) {
        mRequests.remove(request);
    }
}
#end_block

#method_before
private void startNextRequest() {
    final Request request = getNextRequest();
    if (request == null)
        return;
    request.mQuery = mBackend.getCapabilities(request.mPrinter.path, request.mTimeout, request.mHighPriority, capabilities -> {
        DiscoveredPrinter printer = request.mPrinter;
        if (DEBUG)
            Log.d(TAG, "Capabilities for " + printer + " cap=" + capabilities);
        if (mStopped)
            return;
        mRequests.remove(printer.path);
        // Grab uuid from capabilities if possible
        Uri capUuid = null;
        if (capabilities != null) {
            if (!TextUtils.isEmpty(capabilities.uuid)) {
                capUuid = Uri.parse(capabilities.uuid);
            }
            if (printer.uuid != null && !printer.uuid.equals(capUuid)) {
                Log.w(TAG, "UUID mismatch for " + printer + "; rejecting capabilities");
                capabilities = null;
            }
        }
        if (capabilities == null) {
            if (request.mTimeout == FIRST_PASS_TIMEOUT) {
                // Printer did not respond quickly, try again in the slow lane
                request.mTimeout = SECOND_PASS_TIMEOUT;
                request.mQuery = null;
                mRequests.put(printer.path, request);
                startNextRequest();
                return;
            } else {
                remove(printer.getUri());
            }
        } else {
            put(printer.path, capabilities);
        }
        LocalPrinterCapabilities result = capabilities;
        request.mCallbacks.forEach(callback -> callback.onCapabilities(result));
        startNextRequest();
    });
}
#method_after
private void startNextRequest() {
    final Request request = getNextRequest();
    if (request == null) {
        return;
    }
    request.start();
}
#end_block

#method_before
private Request getNextRequest() {
    Request found = null;
    int total = 0;
    for (Request request : mRequests.values()) {
        if (request.mQuery != null) {
            total++;
        } else if (found == null || (!found.mHighPriority && request.mHighPriority) || (found.mHighPriority == request.mHighPriority && request.mTimeout < found.mTimeout)) {
            // First valid or higher priority request
            found = request;
        }
    }
    if (total >= mMaxConcurrent)
        return null;
    return found;
}
#method_after
private Request getNextRequest() {
    Request found = null;
    int total = 0;
    for (Request request : mRequests.values()) {
        if (request.mQuery != null) {
            total++;
        } else if (found == null || (!found.mHighPriority && request.mHighPriority) || (found.mHighPriority == request.mHighPriority && request.mTimeout < found.mTimeout)) {
            // First valid or higher priority request
            found = request;
        }
    }
    if (total >= mMaxConcurrent) {
        return null;
    }
    return found;
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(intent.getAction())) {
        NetworkInfo network = intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        WifiP2pGroup group = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP);
        WifiP2pInfo info = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO);
        if (DEBUG)
            Log.d(TAG, "Connection state=" + network.getState());
        if (network.isConnected()) {
            if (isConnectedToPeer(group)) {
                if (DEBUG)
                    Log.d(TAG, "Group=" + group.getNetworkName() + ", info=" + info);
                if (mDelayed) {
                    // We notified a delay in the past, remove this
                    mListeners.forEach(listener -> listener.onConnectionDelayed(false));
                } else {
                    // Cancel any future delayed indications
                    if (mDetectDelayed != null)
                        mDetectDelayed.stop();
                }
                mNetwork = group.getInterface();
                mInfo = info;
                mListeners.forEach(listener -> listener.onConnectionOpen(mNetwork, mInfo));
            }
        } else if (mInvited) {
            // Only signal connection closure if we reached the invitation phase
            mListeners.forEach(P2pConnectionListener::onConnectionClosed);
            stop();
        }
    } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(intent.getAction())) {
        WifiP2pDeviceList list = intent.getParcelableExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST);
        WifiP2pDevice device = list.get(mPeer.deviceAddress);
        if (DEBUG)
            Log.d(TAG, "Peers changed, device is " + P2pMonitor.toString(device));
        if (!mInvited && device != null && device.status == WifiP2pDevice.INVITED) {
            // Upon first invite, start timer to detect delayed connection
            mInvited = true;
            mDetectDelayed = mService.delay(P2P_CONNECT_DELAYED_PERIOD, () -> {
                mDelayed = true;
                mListeners.forEach(listener -> listener.onConnectionDelayed(true));
            });
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(intent.getAction())) {
        NetworkInfo network = intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        WifiP2pGroup group = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_GROUP);
        WifiP2pInfo info = intent.getParcelableExtra(WifiP2pManager.EXTRA_WIFI_P2P_INFO);
        if (DEBUG)
            Log.d(TAG, "Connection state=" + network.getState());
        if (network.isConnected()) {
            if (isConnectedToPeer(group)) {
                if (DEBUG)
                    Log.d(TAG, "Group=" + group.getNetworkName() + ", info=" + info);
                if (mDelayed) {
                    // We notified a delay in the past, remove this
                    for (P2pConnectionListener listener : mListeners) {
                        listener.onConnectionDelayed(false);
                    }
                } else {
                    // Cancel any future delayed indications
                    if (mDetectDelayed != null) {
                        mDetectDelayed.cancel();
                    }
                }
                mNetwork = group.getInterface();
                mInfo = info;
                for (P2pConnectionListener listener : mListeners) {
                    listener.onConnectionOpen(mNetwork, mInfo);
                }
            }
        } else if (mInvited) {
            // Only signal connection closure if we reached the invitation phase
            for (P2pConnectionListener listener : mListeners) {
                listener.onConnectionClosed();
            }
            close();
        }
    } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(intent.getAction())) {
        WifiP2pDeviceList list = intent.getParcelableExtra(WifiP2pManager.EXTRA_P2P_DEVICE_LIST);
        WifiP2pDevice device = list.get(mPeer.deviceAddress);
        if (DEBUG)
            Log.d(TAG, "Peers changed, device is " + P2pMonitor.toString(device));
        if (!mInvited && device != null && device.status == WifiP2pDevice.INVITED) {
            // Upon first invite, start timer to detect delayed connection
            mInvited = true;
            mDetectDelayed = mService.delay(P2P_CONNECT_DELAYED_PERIOD, () -> {
                mDelayed = true;
                for (P2pConnectionListener listener : mListeners) {
                    listener.onConnectionDelayed(true);
                }
            });
        }
    }
}
#end_block

#method_before
private boolean isConnectedToPeer(WifiP2pGroup group) {
    WifiP2pDevice owner = group.getOwner();
    if (owner != null && owner.deviceAddress.equals(mPeer.deviceAddress))
        return true;
    for (WifiP2pDevice client : group.getClientList()) {
        if (client.deviceAddress.equals(mPeer.deviceAddress))
            return true;
    }
    return false;
}
#method_after
private boolean isConnectedToPeer(WifiP2pGroup group) {
    WifiP2pDevice owner = group.getOwner();
    if (owner != null && owner.deviceAddress.equals(mPeer.deviceAddress)) {
        return true;
    }
    for (WifiP2pDevice client : group.getClientList()) {
        if (client.deviceAddress.equals(mPeer.deviceAddress)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public Stoppable discover(P2pPeerListener listener) {
    if (DEBUG)
        Log.d(TAG, "discover()");
    if (mP2pManager == null) {
        return STOPPED;
    }
    if (mPeerDiscovery == null) {
        mPeerDiscovery = new P2pDiscoveryProcedure(mService, mP2pManager, listener);
    } else {
        mPeerDiscovery.addListener(listener);
    }
    return () -> {
        if (DEBUG)
            Log.d(TAG, "discover.stop()");
        if (mPeerDiscovery != null) {
            mPeerDiscovery.removeListener(listener);
            if (mPeerDiscovery.getListeners().isEmpty()) {
                mPeerDiscovery.stop();
                mPeerDiscovery = null;
            }
        }
    };
}
#method_after
public void discover(P2pPeerListener listener) {
    if (DEBUG)
        Log.d(TAG, "discover()");
    if (mP2pManager == null) {
        return;
    }
    if (mPeerDiscovery == null) {
        mPeerDiscovery = new P2pDiscoveryProcedure(mService, mP2pManager, listener);
    } else {
        mPeerDiscovery.addListener(listener);
    }
}
#end_block

#method_before
public Stoppable connect(WifiP2pDevice peer, P2pConnectionListener listener) {
    if (DEBUG)
        Log.d(TAG, "connect(" + toString(peer) + ")");
    if (mP2pManager == null) {
        // Device has no P2P support so indicate failure
        mService.getMainHandler().post(listener::onConnectionClosed);
        return STOPPED;
    }
    // Check for competing connection
    if (mConnection != null && !peer.deviceAddress.equals(mConnection.getPeer().deviceAddress)) {
        if (mConnection.getListenerCount() == 1) {
            // The only listener is our internal one, so close this connection to make room
            mConnection.stop();
            mConnection = null;
        } else {
            // Cannot open connection
            mService.getMainHandler().post(listener::onConnectionClosed);
            return STOPPED;
        }
    }
    // Check for existing connection to the same device
    if (mConnection == null) {
        // Create a new connection request with our internal listener
        mConnection = new P2pConnectionProcedure(mService, mP2pManager, peer, new P2pConnectionListener() {

            @Override
            public void onConnectionOpen(String networkInterface, WifiP2pInfo info) {
                mConnectedInterface = networkInterface;
            }

            @Override
            public void onConnectionClosed() {
                mConnectedInterface = null;
            }

            @Override
            public void onConnectionDelayed(boolean delayed) {
            }
        });
    }
    mConnection.addListener(listener);
    final P2pConnectionProcedure connection = mConnection;
    return () -> {
        if (DEBUG)
            Log.d(TAG, "connect.stop() " + toString(peer));
        connection.removeListener(listener);
        // If current connection attempt is incomplete and no longer required, cancel it.
        if (mConnection == connection && connection.getListenerCount() == 1 && mConnectedInterface == null) {
            if (DEBUG)
                Log.d(TAG, "Abandoning connection request");
            mConnection.stop();
            mConnection = null;
        }
    };
}
#method_after
public void connect(WifiP2pDevice peer, P2pConnectionListener listener) {
    if (DEBUG)
        Log.d(TAG, "connect(" + toString(peer) + ")");
    if (mP2pManager == null) {
        // Device has no P2P support so indicate failure
        mService.getMainHandler().post(listener::onConnectionClosed);
        return;
    }
    // Check for competing connection
    if (mConnection != null && !peer.deviceAddress.equals(mConnection.getPeer().deviceAddress)) {
        if (mConnection.getListenerCount() == 1) {
            // The only listener is our internal one, so close this connection to make room
            mConnection.close();
            mConnection = null;
        } else {
            // Cannot open connection
            mService.getMainHandler().post(listener::onConnectionClosed);
            return;
        }
    }
    // Check for existing connection to the same device
    if (mConnection == null) {
        // Create a new connection request with our internal listener
        mConnection = new P2pConnectionProcedure(mService, mP2pManager, peer, new P2pConnectionListener() {

            @Override
            public void onConnectionOpen(String networkInterface, WifiP2pInfo info) {
                mConnectedInterface = networkInterface;
            }

            @Override
            public void onConnectionClosed() {
                mConnectedInterface = null;
            }

            @Override
            public void onConnectionDelayed(boolean delayed) {
            }
        });
    }
    mConnection.addListener(listener);
}
#end_block

#method_before
public void stopAll() {
    if (mConnection != null) {
        mConnection.stop();
        mConnection = null;
        mConnectedInterface = null;
    }
    if (mPeerDiscovery != null) {
        mPeerDiscovery.stop();
        mPeerDiscovery = null;
    }
}
#method_after
public void stopAll() {
    if (mConnection != null) {
        mConnection.close();
        mConnection = null;
        mConnectedInterface = null;
    }
    if (mPeerDiscovery != null) {
        mPeerDiscovery.cancel();
        mPeerDiscovery = null;
    }
}
#end_block

#method_before
private static Inet4Address toInet4Address(Uri path) {
    if (!IPV4_PATTERN.matcher(path.getHost()).find())
        return null;
    try {
        return (Inet4Address) InetAddress.getByName(path.getHost());
    } catch (UnknownHostException ignored) {
    }
    return null;
}
#method_after
private static Inet4Address toInet4Address(Uri path) {
    if (!IPV4_PATTERN.matcher(path.getHost()).find()) {
        return null;
    }
    try {
        return (Inet4Address) InetAddress.getByName(path.getHost());
    } catch (UnknownHostException ignored) {
    }
    return null;
}
#end_block

#method_before
private static NetworkInterface toNetworkInterface(String name) {
    if (name == null)
        return null;
    try {
        return NetworkInterface.getByName(name);
    } catch (SocketException e) {
        return null;
    }
}
#method_after
private static NetworkInterface toNetworkInterface(String name) {
    if (name == null) {
        return null;
    }
    try {
        return NetworkInterface.getByName(name);
    } catch (SocketException e) {
        return null;
    }
}
#end_block

#method_before
static boolean isOnInterface(NetworkInterface iface, Inet4Address address) {
    long addressLong = toLong(address);
    for (InterfaceAddress ifaceAddress : iface.getInterfaceAddresses()) {
        if (!(ifaceAddress.getAddress() instanceof Inet4Address))
            continue;
        Inet4Address networkAddress = (Inet4Address) ifaceAddress.getAddress();
        BitSet bitSet = new BitSet(32);
        bitSet.set(32 - ifaceAddress.getNetworkPrefixLength(), 32);
        long netMask = bitSet.toLongArray()[0];
        if ((toLong(networkAddress) & netMask) == (addressLong & netMask)) {
            return true;
        }
    }
    return false;
}
#method_after
static boolean isOnInterface(NetworkInterface iface, Inet4Address address) {
    long addressLong = toLong(address);
    for (InterfaceAddress ifaceAddress : iface.getInterfaceAddresses()) {
        if (!(ifaceAddress.getAddress() instanceof Inet4Address)) {
            continue;
        }
        Inet4Address networkAddress = (Inet4Address) ifaceAddress.getAddress();
        BitSet bitSet = new BitSet(32);
        bitSet.set(32 - ifaceAddress.getNetworkPrefixLength(), 32);
        long netMask = bitSet.toLongArray()[0];
        if ((toLong(networkAddress) & netMask) == (addressLong & netMask)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void onStartPrinterDiscovery(List<PrinterId> priorityList) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterDiscovery() " + priorityList);
    // Mark all known printers as "not found". They may return shortly or may expire
    mPrinters.values().forEach(LocalPrinter::notFound);
    monitorExpiredPrinters();
    mDiscover = mPrintService.getDiscovery().start(this);
    mPrintManager.addPrintServicesChangeListener(this, null);
    onPrintServicesChanged();
    mPrintManager.addPrintServiceRecommendationsChangeListener(this, null);
    onPrintServiceRecommendationsChanged();
}
#method_after
@Override
public void onStartPrinterDiscovery(List<PrinterId> priorityList) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterDiscovery() " + priorityList);
    // Mark all known printers as "not found". They may return shortly or may expire
    for (LocalPrinter printer : mPrinters.values()) {
        printer.notFound();
    }
    monitorExpiredPrinters();
    mPrintService.getDiscovery().start(this);
    mPrintManager.addPrintServicesChangeListener(this, null);
    onPrintServicesChanged();
    mPrintManager.addPrintServiceRecommendationsChangeListener(this, null);
    onPrintServiceRecommendationsChanged();
}
#end_block

#method_before
@Override
public void onStopPrinterDiscovery() {
    if (DEBUG)
        Log.d(TAG, "onStopPrinterDiscovery()");
    mDiscover.stop();
    PrintManager printManager = mPrintService.getSystemService(PrintManager.class);
    printManager.removePrintServicesChangeListener(this);
    printManager.removePrintServiceRecommendationsChangeListener(this);
    if (mExpirePrinters != null) {
        mExpirePrinters.stop();
        mExpirePrinters = null;
    }
}
#method_after
@Override
public void onStopPrinterDiscovery() {
    if (DEBUG)
        Log.d(TAG, "onStopPrinterDiscovery()");
    mPrintService.getDiscovery().stop(this);
    PrintManager printManager = mPrintService.getSystemService(PrintManager.class);
    printManager.removePrintServicesChangeListener(this);
    printManager.removePrintServiceRecommendationsChangeListener(this);
    if (mExpirePrinters != null) {
        mExpirePrinters.cancel();
        mExpirePrinters = null;
    }
}
#end_block

#method_before
@Override
public void onStartPrinterStateTracking(final PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterStateTracking() " + printerId);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    mTrackingIds.add(printerId);
    // We cannot track the printer yet; wait until it is discovered
    if (localPrinter == null || !localPrinter.isFound())
        return;
    localPrinter.track();
}
#method_after
@Override
public void onStartPrinterStateTracking(final PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterStateTracking() " + printerId);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    mTrackingIds.add(printerId);
    // We cannot track the printer yet; wait until it is discovered
    if (localPrinter == null || !localPrinter.isFound()) {
        return;
    }
    localPrinter.track();
}
#end_block

#method_before
@Override
public void onPrinterFound(DiscoveredPrinter discoveredPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterFound() " + discoveredPrinter);
    if (isDestroyed()) {
        Log.w(TAG, "Destroyed; ignoring");
        return;
    }
    PrinterId printerId = discoveredPrinter.getId(mPrintService);
    LocalPrinter localPrinter = mPrinters.computeIfAbsent(printerId, id -> new LocalPrinter(mPrintService, this, discoveredPrinter));
    localPrinter.found(discoveredPrinter);
    if (mTrackingIds.contains(printerId))
        localPrinter.track();
}
#method_after
@Override
public void onPrinterFound(DiscoveredPrinter discoveredPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterFound() " + discoveredPrinter);
    if (isDestroyed()) {
        Log.w(TAG, "Destroyed; ignoring");
        return;
    }
    PrinterId printerId = discoveredPrinter.getId(mPrintService);
    LocalPrinter localPrinter = mPrinters.computeIfAbsent(printerId, id -> new LocalPrinter(mPrintService, this, discoveredPrinter));
    localPrinter.found(discoveredPrinter);
    if (mTrackingIds.contains(printerId)) {
        localPrinter.track();
    }
}
#end_block

#method_before
@Override
public void onPrinterLost(DiscoveredPrinter lostPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterLost() " + lostPrinter);
    mPrintService.getCapabilitiesCache().remove(lostPrinter.path);
    PrinterId printerId = lostPrinter.getId(mPrintService);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    if (localPrinter == null)
        return;
    localPrinter.notFound();
    handlePrinter(localPrinter);
    monitorExpiredPrinters();
}
#method_after
@Override
public void onPrinterLost(DiscoveredPrinter lostPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterLost() " + lostPrinter);
    mPrintService.getCapabilitiesCache().remove(lostPrinter.path);
    PrinterId printerId = lostPrinter.getId(mPrintService);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    if (localPrinter == null) {
        return;
    }
    localPrinter.notFound();
    handlePrinter(localPrinter);
    monitorExpiredPrinters();
}
#end_block

#method_before
private void monitorExpiredPrinters() {
    if (mExpirePrinters == null && !mPrinters.isEmpty()) {
        mExpirePrinters = mPrintService.delay(PRINTER_EXPIRATION_MILLIS, () -> {
            mExpirePrinters = null;
            boolean allFound = true;
            List<PrinterId> idsToRemove = new ArrayList<>();
            for (LocalPrinter localPrinter : mPrinters.values()) {
                if (localPrinter.isExpired()) {
                    if (DEBUG)
                        Log.d(TAG, "Expiring " + localPrinter);
                    idsToRemove.add(localPrinter.getPrinterId());
                }
                if (!localPrinter.isFound())
                    allFound = false;
            }
            idsToRemove.forEach(mPrinters::remove);
            removePrinters(idsToRemove);
            if (!allFound) {
                monitorExpiredPrinters();
            }
        });
    }
}
#method_after
private void monitorExpiredPrinters() {
    if (mExpirePrinters == null && !mPrinters.isEmpty()) {
        mExpirePrinters = mPrintService.delay(PRINTER_EXPIRATION_MILLIS, () -> {
            mExpirePrinters = null;
            boolean allFound = true;
            List<PrinterId> idsToRemove = new ArrayList<>();
            for (LocalPrinter localPrinter : mPrinters.values()) {
                if (localPrinter.isExpired()) {
                    if (DEBUG)
                        Log.d(TAG, "Expiring " + localPrinter);
                    idsToRemove.add(localPrinter.getPrinterId());
                }
                if (!localPrinter.isFound()) {
                    allFound = false;
                }
            }
            for (PrinterId id : idsToRemove) {
                mPrinters.remove(id);
            }
            removePrinters(idsToRemove);
            if (!allFound) {
                monitorExpiredPrinters();
            }
        });
    }
}
#end_block

#method_before
void handlePrinter(LocalPrinter localPrinter) {
    if (DEBUG)
        Log.d(TAG, "handlePrinter record " + localPrinter);
    boolean knownGood = mInfo.isKnownGood(localPrinter.getPrinterId());
    PrinterInfo info = localPrinter.createPrinterInfo(knownGood);
    if (info == null)
        return;
    if (info.getStatus() == PrinterInfo.STATUS_IDLE && localPrinter.getUuid() != null) {
        // Mark UUID-based printers with IDLE status as known-good
        mInfo.setKnownGood(localPrinter.getPrinterId());
    }
    for (PrinterInfo knownInfo : getPrinters()) {
        if (knownInfo.getId().equals(info.getId()) && (info.getCapabilities() == null)) {
            if (DEBUG)
                Log.d(TAG, "Ignore update with no caps " + localPrinter);
            return;
        }
    }
    if (DEBUG) {
        Log.d(TAG, "handlePrinter: reporting " + localPrinter + " caps=" + (info.getCapabilities() != null) + " status=" + info.getStatus() + " summary=" + info.getDescription());
    }
    if (!isHandledByOtherService(localPrinter)) {
        addPrinters(Collections.singletonList(info));
    }
}
#method_after
void handlePrinter(LocalPrinter localPrinter) {
    if (DEBUG)
        Log.d(TAG, "handlePrinter record " + localPrinter);
    boolean knownGood = mInfo.isKnownGood(localPrinter.getPrinterId());
    PrinterInfo info = localPrinter.createPrinterInfo(knownGood);
    if (info == null) {
        return;
    }
    if (info.getStatus() == PrinterInfo.STATUS_IDLE && localPrinter.getUuid() != null) {
        // Mark UUID-based printers with IDLE status as known-good
        mInfo.setKnownGood(localPrinter.getPrinterId());
    }
    for (PrinterInfo knownInfo : getPrinters()) {
        if (knownInfo.getId().equals(info.getId()) && (info.getCapabilities() == null)) {
            if (DEBUG)
                Log.d(TAG, "Ignore update with no caps " + localPrinter);
            return;
        }
    }
    if (DEBUG) {
        Log.d(TAG, "handlePrinter: reporting " + localPrinter + " caps=" + (info.getCapabilities() != null) + " status=" + info.getStatus() + " summary=" + info.getDescription());
    }
    if (!isHandledByOtherService(localPrinter)) {
        addPrinters(Collections.singletonList(info));
    }
}
#end_block

#method_before
private boolean isHandledByOtherService(LocalPrinter printer) {
    InetAddress address = printer.getAddress();
    if (address == null)
        return false;
    ArrayList<String> printerServices = mPrintersOfOtherService.get(printer.getAddress());
    if (printerServices != null) {
        int numServices = printerServices.size();
        for (int i = 0; i < numServices; i++) {
            if (mEnabledServices.contains(printerServices.get(i))) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isHandledByOtherService(LocalPrinter printer) {
    InetAddress address = printer.getAddress();
    if (address == null) {
        return false;
    }
    ArrayList<String> printerServices = mPrintersOfOtherService.get(printer.getAddress());
    if (printerServices != null) {
        int numServices = printerServices.size();
        for (int i = 0; i < numServices; i++) {
            if (mEnabledServices.contains(printerServices.get(i))) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
void start(Consumer<LocalPrintJob> callback) {
    if (DEBUG)
        Log.d(TAG, "start() " + mPrintJob);
    if (mState != STATE_INIT) {
        Log.w(TAG, "Invalid start state " + mState);
        return;
    }
    mPrintJob.start();
    // Acquire a lock so that WiFi isn't put to sleep while we send the job
    mPrintService.lockWifi();
    mState = STATE_DISCOVERY;
    mCompleteConsumer = callback;
    mDiscovery = mPrintService.getDiscovery().start(this);
    mDiscoveryTimeout = mPrintService.delay(DISCOVERY_TIMEOUT, () -> {
        if (DEBUG)
            Log.d(TAG, "Discovery timeout");
        if (mState == STATE_DISCOVERY) {
            finish(false, mPrintService.getString(R.string.printer_offline));
        }
    });
}
#method_after
void start(Consumer<LocalPrintJob> callback) {
    if (DEBUG)
        Log.d(TAG, "start() " + mPrintJob);
    if (mState != STATE_INIT) {
        Log.w(TAG, "Invalid start state " + mState);
        return;
    }
    mPrintJob.start();
    // Acquire a lock so that WiFi isn't put to sleep while we send the job
    mPrintService.lockWifi();
    mState = STATE_DISCOVERY;
    mCompleteConsumer = callback;
    mDiscoveryTimeout = mPrintService.delay(DISCOVERY_TIMEOUT, () -> {
        if (DEBUG)
            Log.d(TAG, "Discovery timeout");
        if (mState == STATE_DISCOVERY) {
            finish(false, mPrintService.getString(R.string.printer_offline));
        }
    });
    mPrintService.getDiscovery().start(this);
}
#end_block

#method_before
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (mState != STATE_DISCOVERY)
        return;
    if (!printer.getId(mPrintService).equals(mPrintJob.getInfo().getPrinterId()))
        return;
    if (DEBUG)
        Log.d(TAG, "onPrinterFound() " + printer.name + " state=" + mState);
    if (P2pUtils.isP2p(printer)) {
        // Launch a P2P connection attempt
        mConnection = P2pPrinterConnection.connectPrinter(mPrintService, printer, this);
        return;
    }
    if (P2pUtils.isOnConnectedInterface(mPrintService, printer) && mConnection == null) {
        // Hold the P2P connection up during printing
        mConnection = P2pPrinterConnection.connectPrinter(mPrintService, printer, this);
    }
    // We have a good path so stop discovering and get capabilities
    if (mDiscovery != null)
        mDiscovery.stop();
    mState = STATE_CAPABILITIES;
    mPath = printer.path;
    mPrintService.getCapabilitiesCache().request(printer, true, this::handleCapabilities);
}
#method_after
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (mState != STATE_DISCOVERY) {
        return;
    }
    if (!printer.getId(mPrintService).equals(mPrintJob.getInfo().getPrinterId())) {
        return;
    }
    if (DEBUG)
        Log.d(TAG, "onPrinterFound() " + printer.name + " state=" + mState);
    if (P2pUtils.isP2p(printer)) {
        // Launch a P2P connection attempt
        mConnection = new P2pPrinterConnection(mPrintService, printer, this);
        return;
    }
    if (P2pUtils.isOnConnectedInterface(mPrintService, printer) && mConnection == null) {
        // Hold the P2P connection up during printing
        mConnection = new P2pPrinterConnection(mPrintService, printer, this);
    }
    // We have a good path so stop discovering and get capabilities
    mPrintService.getDiscovery().stop(this);
    mState = STATE_CAPABILITIES;
    mPath = printer.path;
    mPrintService.getCapabilitiesCache().request(printer, true, this);
}
#end_block

#method_before
@Override
public void onConnectionComplete(DiscoveredPrinter printer) {
    // Ignore late connection events
    if (mState != STATE_DISCOVERY)
        return;
    if (printer == null) {
        finish(false, mPrintService.getString(R.string.failed_printer_connection));
    } else if (mPrintJob.isBlocked()) {
        mPrintJob.start();
    }
}
#method_after
@Override
public void onConnectionComplete(DiscoveredPrinter printer) {
    // Ignore late connection events
    if (mState != STATE_DISCOVERY) {
        return;
    }
    if (printer == null) {
        finish(false, mPrintService.getString(R.string.failed_printer_connection));
    } else if (mPrintJob.isBlocked()) {
        mPrintJob.start();
    }
}
#end_block

#method_before
@Override
public void onConnectionDelayed(boolean delayed) {
    if (DEBUG)
        Log.d(TAG, "onConnectionDelayed " + delayed);
    // Ignore late events
    if (mState != STATE_DISCOVERY)
        return;
    if (delayed) {
        mPrintJob.block(mPrintService.getString(R.string.connect_hint_text));
    } else {
        // Remove block message
        mPrintJob.start();
    }
}
#method_after
@Override
public void onConnectionDelayed(boolean delayed) {
    if (DEBUG)
        Log.d(TAG, "onConnectionDelayed " + delayed);
    // Ignore late events
    if (mState != STATE_DISCOVERY) {
        return;
    }
    if (delayed) {
        mPrintJob.block(mPrintService.getString(R.string.connect_hint_text));
    } else {
        // Remove block message
        mPrintJob.start();
    }
}
#end_block

#method_before
private void handleJobStatus(JobStatus jobStatus) {
    if (DEBUG)
        Log.d(TAG, "onJobStatus() " + jobStatus);
    switch(jobStatus.getJobState()) {
        case BackendConstants.JOB_STATE_DONE:
            switch(jobStatus.getJobResult()) {
                case BackendConstants.JOB_DONE_OK:
                    finish(true, null);
                    break;
                case BackendConstants.JOB_DONE_CANCELLED:
                    mState = STATE_CANCEL;
                    finish(false, null);
                    break;
                case BackendConstants.JOB_DONE_CORRUPT:
                    finish(false, mPrintService.getString(R.string.unreadable_input));
                    break;
                default:
                    // Job failed
                    finish(false, null);
                    break;
            }
            break;
        case BackendConstants.JOB_STATE_BLOCKED:
            if (mState == STATE_CANCEL)
                return;
            int blockedId = jobStatus.getBlockedReasonId();
            blockedId = (blockedId == 0) ? R.string.printer_check : blockedId;
            String blockedReason = mPrintService.getString(blockedId);
            mPrintJob.block(blockedReason);
            break;
        case BackendConstants.JOB_STATE_RUNNING:
            if (mState == STATE_CANCEL)
                return;
            mPrintJob.start();
            break;
    }
}
#method_after
private void handleJobStatus(JobStatus jobStatus) {
    if (DEBUG)
        Log.d(TAG, "onJobStatus() " + jobStatus);
    switch(jobStatus.getJobState()) {
        case BackendConstants.JOB_STATE_DONE:
            switch(jobStatus.getJobResult()) {
                case BackendConstants.JOB_DONE_OK:
                    finish(true, null);
                    break;
                case BackendConstants.JOB_DONE_CANCELLED:
                    mState = STATE_CANCEL;
                    finish(false, null);
                    break;
                case BackendConstants.JOB_DONE_CORRUPT:
                    finish(false, mPrintService.getString(R.string.unreadable_input));
                    break;
                default:
                    // Job failed
                    finish(false, null);
                    break;
            }
            break;
        case BackendConstants.JOB_STATE_BLOCKED:
            if (mState == STATE_CANCEL) {
                return;
            }
            int blockedId = jobStatus.getBlockedReasonId();
            blockedId = (blockedId == 0) ? R.string.printer_check : blockedId;
            String blockedReason = mPrintService.getString(blockedId);
            mPrintJob.block(blockedReason);
            break;
        case BackendConstants.JOB_STATE_RUNNING:
            if (mState == STATE_CANCEL) {
                return;
            }
            mPrintJob.start();
            break;
    }
}
#end_block

#method_before
private void finish(boolean success, String error) {
    if (DEBUG)
        Log.d(TAG, "finish() success=" + success + ", error=" + error);
    if (mDiscovery != null)
        mDiscovery.stop();
    if (mDiscoveryTimeout != null)
        mDiscoveryTimeout.stop();
    if (mConnection != null)
        mConnection.stop();
    mPrintService.unlockWifi();
    mBackend.closeDocument();
    if (success) {
        // Job must not be blocked before completion
        mPrintJob.start();
        mPrintJob.complete();
    } else if (mState == STATE_CANCEL) {
        mPrintJob.cancel();
    } else {
        mPrintJob.fail(error);
    }
    mState = STATE_DONE;
    mCompleteConsumer.accept(LocalPrintJob.this);
}
#method_after
private void finish(boolean success, String error) {
    if (DEBUG)
        Log.d(TAG, "finish() success=" + success + ", error=" + error);
    mPrintService.getDiscovery().stop(this);
    if (mDiscoveryTimeout != null) {
        mDiscoveryTimeout.cancel();
    }
    if (mConnection != null) {
        mConnection.close();
    }
    mPrintService.unlockWifi();
    mBackend.closeDocument();
    if (success) {
        // Job must not be blocked before completion
        mPrintJob.start();
        mPrintJob.complete();
    } else if (mState == STATE_CANCEL) {
        mPrintJob.cancel();
    } else {
        mPrintJob.fail(error);
    }
    mState = STATE_DONE;
    mCompleteConsumer.accept(LocalPrintJob.this);
}
#end_block

#method_before
@Override
void onStart() {
    if (mStartDelay == 0) {
        mDiscovery = mChild.start(mChildListener);
    } else {
        mDelayedStart = getPrintService().delay(mStartDelay, () -> {
            if (!isStarted())
                return;
            mDiscovery = mChild.start(mChildListener);
        });
    }
}
#method_after
@Override
void onStart() {
    if (mStartDelay == 0) {
        mChild.start(mChildListener);
    } else {
        mDelayedStart = getPrintService().delay(mStartDelay, () -> {
            if (!isStarted()) {
                return;
            }
            mChild.start(mChildListener);
        });
    }
}
#end_block

#method_before
@Override
void onStop() {
    if (mDelayedStart != null)
        mDelayedStart.stop();
    if (mDiscovery != null)
        mDiscovery.stop();
    mPending.clear();
}
#method_after
@Override
void onStop() {
    if (mDelayedStart != null) {
        mDelayedStart.cancel();
    }
    mChild.stop(mChildListener);
    mPending.clear();
}
#end_block

#method_before
void addListener(P2pPeerListener listener) {
    mListeners.add(listener);
    if (!mPeers.isEmpty()) {
        new Handler(Looper.getMainLooper()).post(() -> {
            if (mListeners.contains(listener)) {
                mPeers.forEach(listener::onPeerFound);
            }
        });
    }
}
#method_after
void addListener(P2pPeerListener listener) {
    mListeners.add(listener);
    if (!mPeers.isEmpty()) {
        for (WifiP2pDevice peer : mPeers) {
            listener.onPeerFound(peer);
        }
    }
}
#end_block

#method_before
private void updatePeers(Collection<WifiP2pDevice> newPeers) {
    List<WifiP2pDevice> oldPeers = new ArrayList<>(mPeers);
    // Reset peer list and populate with new printer-type devices
    mPeers.clear();
    for (WifiP2pDevice peer : newPeers) {
        if (PRINTER_PATTERN.matcher(peer.primaryDeviceType).find()) {
            mPeers.add(peer);
        }
    }
    // Notify newly found devices
    Set<String> foundAddresses = new HashSet<>();
    for (WifiP2pDevice peer : mPeers) {
        foundAddresses.add(peer.deviceAddress);
        WifiP2pDevice old = getDevice(oldPeers, peer.deviceAddress);
        if (old == null || !old.equals(peer)) {
            mListeners.forEach(listener -> listener.onPeerFound(peer));
        }
    }
    // Notify lost devices
    for (WifiP2pDevice oldPeer : oldPeers) {
        if (!foundAddresses.contains(oldPeer.deviceAddress)) {
            mListeners.forEach(listener -> listener.onPeerLost(oldPeer));
        }
    }
}
#method_after
private void updatePeers(Collection<WifiP2pDevice> newPeers) {
    List<WifiP2pDevice> oldPeers = new ArrayList<>(mPeers);
    // Reset peer list and populate with new printer-type devices
    mPeers.clear();
    for (WifiP2pDevice peer : newPeers) {
        if (PRINTER_PATTERN.matcher(peer.primaryDeviceType).find()) {
            mPeers.add(peer);
        }
    }
    // Notify newly found devices
    Set<String> foundAddresses = new HashSet<>();
    for (WifiP2pDevice peer : mPeers) {
        foundAddresses.add(peer.deviceAddress);
        WifiP2pDevice old = getDevice(oldPeers, peer.deviceAddress);
        if (old == null || !old.equals(peer)) {
            for (P2pPeerListener listener : mListeners) {
                listener.onPeerFound(peer);
            }
        }
    }
    // Notify lost devices
    for (WifiP2pDevice oldPeer : oldPeers) {
        if (!foundAddresses.contains(oldPeer.deviceAddress)) {
            for (P2pPeerListener listener : mListeners) {
                listener.onPeerLost(oldPeer);
            }
        }
    }
}
#end_block

#method_before
private WifiP2pDevice getDevice(Collection<WifiP2pDevice> peers, String address) {
    for (WifiP2pDevice found : peers) {
        if (found.deviceAddress.equals(address))
            return found;
    }
    return null;
}
#method_after
private WifiP2pDevice getDevice(Collection<WifiP2pDevice> peers, String address) {
    for (WifiP2pDevice found : peers) {
        if (found.deviceAddress.equals(address)) {
            return found;
        }
    }
    return null;
}
#end_block

#method_before
private void load() {
    if (!mCacheFile.exists())
        return;
    try (JsonReader reader = new JsonReader(new FileReader(mCacheFile))) {
        reader.beginObject();
        while (reader.hasNext()) {
            switch(reader.nextName()) {
                case NAME_KNOWN_GOOD:
                    mKnownGood.addAll(loadPrinterIds(reader));
                    break;
                case NAME_PRIORITY:
                    mPriority.addAll(loadPrinterIds(reader));
                    break;
                default:
                    reader.skipValue();
                    break;
            }
        }
        reader.endObject();
    } catch (IOException e) {
        Log.w(TAG, "Failed to read info from " + CACHE_FILE, e);
    }
}
#method_after
private void load() {
    if (!mCacheFile.exists()) {
        return;
    }
    try (JsonReader reader = new JsonReader(new FileReader(mCacheFile))) {
        reader.beginObject();
        while (reader.hasNext()) {
            switch(reader.nextName()) {
                case NAME_KNOWN_GOOD:
                    mKnownGood.addAll(loadPrinterIds(reader));
                    break;
                case NAME_PRIORITY:
                    mPriority.addAll(loadPrinterIds(reader));
                    break;
                default:
                    reader.skipValue();
                    break;
            }
        }
        reader.endObject();
    } catch (IOException e) {
        Log.w(TAG, "Failed to read info from " + CACHE_FILE, e);
    }
}
#end_block

#method_before
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    // Prepare the dialog for display
    setView(getLayoutInflater().inflate(R.layout.manual_printer_add, null));
    setTitle(getContext().getString(R.string.connecting_to, mPeer.deviceName));
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    findViewById(R.id.labelHostname).setVisibility(View.GONE);
    findViewById(R.id.hostname).setVisibility(View.GONE);
    findViewById(R.id.progress).setVisibility(View.VISIBLE);
    setOnDismissListener(d -> mValidating.stop());
    // Attempt to add the discovered device as a P2P printer
    mValidating = P2pPrinterConnection.connectPrinter(mPrintService, mPeer, this);
}
#method_after
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    // Prepare the dialog for display
    setView(getLayoutInflater().inflate(R.layout.manual_printer_add, null));
    setTitle(getContext().getString(R.string.connecting_to, mPeer.deviceName));
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    findViewById(R.id.labelHostname).setVisibility(View.GONE);
    findViewById(R.id.hostname).setVisibility(View.GONE);
    findViewById(R.id.progress).setVisibility(View.VISIBLE);
    setOnDismissListener(d -> mValidating.close());
    // Attempt to add the discovered device as a P2P printer
    mValidating = new P2pPrinterConnection(mPrintService, mPeer, this);
}
#end_block

#method_before
@Override
public void onConnectionComplete(DiscoveredPrinter printer) {
    if (printer != null) {
        // Callback could arrive quickly if we are already connected, so run later
        mPrintService.getMainHandler().post(() -> {
            mValidating.stop();
            mPrintService.getP2pDiscovery().addValidPrinter(printer);
            mFragment.getActivity().finish();
        });
        dismiss();
    } else {
        fail();
    }
}
#method_after
@Override
public void onConnectionComplete(DiscoveredPrinter printer) {
    if (printer != null) {
        // Callback could arrive quickly if we are already connected, so run later
        mPrintService.getMainHandler().post(() -> {
            mValidating.close();
            mPrintService.getP2pDiscovery().addValidPrinter(printer);
            mFragment.getActivity().finish();
        });
        dismiss();
    } else {
        fail();
    }
}
#end_block

#method_before
private void handleBindApplication(AppBindData data) {
    // Register the UI Thread as a sensitive thread to the runtime.
    VMRuntime.registerSensitiveThread();
    if (data.trackAllocation) {
        DdmVmInternal.enableRecentAllocations(true);
    }
    // Note when this process has started.
    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    mProfiler = new Profiler();
    String agent = null;
    if (data.initProfilerInfo != null) {
        mProfiler.profileFile = data.initProfilerInfo.profileFile;
        mProfiler.profileFd = data.initProfilerInfo.profileFd;
        mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;
        mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;
        mProfiler.streamingOutput = data.initProfilerInfo.streamingOutput;
        if (data.initProfilerInfo.bindTimeAgentAttach) {
            agent = data.initProfilerInfo.agent;
        }
    }
    // send up app name; do this *before* waiting for debugger
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());
    if (mProfiler.profileFd != null) {
        mProfiler.startProfiling();
    }
    // main thread so the main looper is set right.
    if (data.appInfo.targetSdkVersion <= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) {
        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);
    /*
         * Before spawning a new process, reset the time zone to be the system time zone.
         * This needs to be done because the system time zone could have changed after the
         * the spawning of this process. Without doing this this process would have the incorrect
         * system time zone.
         */
    TimeZone.setDefault(null);
    /*
         * Set the LocaleList. This may change once we create the App Context.
         */
    LocaleList.setDefault(data.config.getLocales());
    synchronized (mResourcesManager) {
        /*
             * Update the system configuration since its preloaded and might not
             * reflect configuration changes. The configuration object passed
             * in AppBindData can be safely assumed to be up to date
             */
        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);
        mCurDefaultDisplayDpi = data.config.densityDpi;
        // This calls mResourcesManager so keep it within the synchronized block.
        applyCompatConfiguration(mCurDefaultDisplayDpi);
    }
    data.loadedApk = getLoadedApkNoCheck(data.appInfo, data.compatInfo);
    if (agent != null) {
        handleAttachAgent(agent, data.loadedApk);
    }
    /**
     * Switch this process to density compatibility mode if needed.
     */
    if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
        mDensityCompatMode = true;
        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
    }
    updateDefaultDensity();
    final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);
    Boolean is24Hr = null;
    if (use24HourSetting != null) {
        is24Hr = "24".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;
    }
    // null : use locale default for 12/24 hour formatting,
    // false : use 12 hour format,
    // true : use 24 hour format.
    DateFormat.set24HourTimePref(is24Hr);
    View.mDebugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0;
    /**
     * For system applications on userdebug/eng builds, log stack
     * traces of disk and network access to dropbox for analysis.
     */
    if ((data.appInfo.flags & (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != 0) {
        StrictMode.conditionallyEnableDebugLogging();
    }
    /**
     * For apps targetting Honeycomb or later, we don't allow network usage
     * on the main event loop / UI thread. This is what ultimately throws
     * {@link NetworkOnMainThreadException}.
     */
    if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB) {
        StrictMode.enableDeathOnNetwork();
    }
    /**
     * For apps targetting N or later, we don't allow file:// Uri exposure.
     * This is what ultimately throws {@link FileUriExposedException}.
     */
    if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.N) {
        StrictMode.enableDeathOnFileUriExposure();
    }
    // before any app code has been loaded.
    try {
        Field field = Build.class.getDeclaredField("SERIAL");
        field.setAccessible(true);
        field.set(Build.class, data.buildSerial);
    } catch (NoSuchFieldException | IllegalAccessException e) {
    /* ignore */
    }
    if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) {
        // XXX should have option to change the port.
        Debug.changeDebugPort(8100);
        if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) {
            Slog.w(TAG, "Application " + data.loadedApk.getPackageName() + " is waiting for the debugger on port 8100...");
            IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.showWaitingForDebugger(mAppThread, true);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            Debug.waitForDebugger();
            try {
                mgr.showWaitingForDebugger(mAppThread, false);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } else {
            Slog.w(TAG, "Application " + data.loadedApk.getPackageName() + " can be debugged on port 8100...");
        }
    }
    // Allow application-generated systrace messages if we're debuggable.
    boolean isAppDebuggable = (data.appInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    Trace.setAppTracingAllowed(isAppDebuggable);
    if (isAppDebuggable && data.enableBinderTracking) {
        Binder.enableTracing();
    }
    /**
     * Initialize the default http proxy in this process for the reasons we set the time zone.
     */
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Setup proxies");
    final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
    if (b != null) {
        // In pre-boot mode (doing initial launch to collect password), not
        // all system is up.  This includes the connectivity service, so don't
        // crash if we can't get it.
        final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
        try {
            final ProxyInfo proxyInfo = service.getProxyForNetwork(null);
            Proxy.setHttpProxySystemProperty(proxyInfo);
        } catch (RemoteException e) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw e.rethrowFromSystemServer();
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Instrumentation info affects the class loader, so load it before
    // setting up the app context.
    final InstrumentationInfo ii;
    if (data.instrumentationName != null) {
        try {
            ii = new ApplicationPackageManager(null, getPackageManager()).getInstrumentationInfo(data.instrumentationName, 0);
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Unable to find instrumentation info for: " + data.instrumentationName);
        }
        mInstrumentationPackageName = ii.packageName;
        mInstrumentationAppDir = ii.sourceDir;
        mInstrumentationSplitAppDirs = ii.splitSourceDirs;
        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);
        mInstrumentedAppDir = data.loadedApk.getAppDir();
        mInstrumentedSplitAppDirs = data.loadedApk.getSplitAppDirs();
        mInstrumentedLibDir = data.loadedApk.getLibDir();
    } else {
        ii = null;
    }
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.loadedApk);
    updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());
    if (!Process.isIsolated()) {
        setupGraphicsSupport(appContext);
    }
    // complete application startup.
    if (SystemProperties.getBoolean("dalvik.vm.usejitprofiles", false)) {
        BaseDexClassLoader.setReporter(DexLoadReporter.getInstance());
    }
    // Install the Network Security Config Provider. This must happen before the application
    // code is loaded to prevent issues with instances of TLS objects being created before
    // the provider is installed.
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "NetworkSecurityConfigProvider.install");
    NetworkSecurityConfigProvider.install(appContext);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Continue loading instrumentation.
    if (ii != null) {
        final ApplicationInfo instrApp = new ApplicationInfo();
        ii.copyTo(instrApp);
        instrApp.initForUser(UserHandle.myUserId());
        final LoadedApk loadedApk = getLoadedApk(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false);
        final ContextImpl instrContext = ContextImpl.createAppContext(this, loadedApk);
        try {
            final ClassLoader cl = instrContext.getClassLoader();
            mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate instrumentation " + data.instrumentationName + ": " + e.toString(), e);
        }
        final ComponentName component = new ComponentName(ii.packageName, ii.name);
        mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);
        if (mProfiler.profileFile != null && !ii.handleProfiling && mProfiler.profileFd == null) {
            mProfiler.handlingProfiling = true;
            final File file = new File(mProfiler.profileFile);
            file.getParentFile().mkdirs();
            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
        }
    } else {
        mInstrumentation = new Instrumentation();
    }
    if ((data.appInfo.flags & ApplicationInfo.FLAG_LARGE_HEAP) != 0) {
        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();
    } else {
        // Small heap, clamp to the current growth limit and let the heap release
        // pages after the growth limit to the non growth limit capacity. b/18387825
        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();
    }
    // Allow disk access during application and provider setup. This could
    // block processing ordered broadcasts, but later processing would
    // probably end up doing the same disk access.
    Application app;
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();
    final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();
    try {
        // If the app is being launched for full backup or restore, bring it up in
        // a restricted environment with the base application class.
        app = data.loadedApk.makeApplication(data.restrictedBackupMode, null);
        mInitialApplication = app;
        // app's custom Application class
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
                // For process that contains content providers, we want to
                // ensure that the JIT is enabled "at some point".
                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10 * 1000);
            }
        }
        // test thread at this point, and we don't want that racing.
        try {
            mInstrumentation.onCreate(data.instrumentationArgs);
        } catch (Exception e) {
            throw new RuntimeException("Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e);
        }
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!mInstrumentation.onException(app, e)) {
                throw new RuntimeException("Unable to create application " + app.getClass().getName() + ": " + e.toString(), e);
            }
        }
    } finally {
        // during startup, clobber the policy to maintain behavior of b/36951662
        if (data.appInfo.targetSdkVersion <= Build.VERSION_CODES.O || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
    // Preload fonts resources
    FontsContract.setApplicationContextForResources(appContext);
    try {
        final ApplicationInfo info = getPackageManager().getApplicationInfo(data.appInfo.packageName, PackageManager.GET_META_DATA, /*flags*/
        UserHandle.myUserId());
        if (info.metaData != null) {
            final int preloadedFontsResource = info.metaData.getInt(ApplicationInfo.METADATA_PRELOADED_FONTS, 0);
            if (preloadedFontsResource != 0) {
                data.loadedApk.getResources().preloadFonts(preloadedFontsResource);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
private void handleBindApplication(AppBindData data) {
    // Register the UI Thread as a sensitive thread to the runtime.
    VMRuntime.registerSensitiveThread();
    if (data.trackAllocation) {
        DdmVmInternal.enableRecentAllocations(true);
    }
    // Note when this process has started.
    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());
    mBoundApplication = data;
    mConfiguration = new Configuration(data.config);
    mCompatConfiguration = new Configuration(data.config);
    mProfiler = new Profiler();
    String agent = null;
    if (data.initProfilerInfo != null) {
        mProfiler.profileFile = data.initProfilerInfo.profileFile;
        mProfiler.profileFd = data.initProfilerInfo.profileFd;
        mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;
        mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;
        mProfiler.streamingOutput = data.initProfilerInfo.streamingOutput;
        if (data.initProfilerInfo.attachAgentDuringBind) {
            agent = data.initProfilerInfo.agent;
        }
    }
    // send up app name; do this *before* waiting for debugger
    Process.setArgV0(data.processName);
    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());
    if (mProfiler.profileFd != null) {
        mProfiler.startProfiling();
    }
    // main thread so the main looper is set right.
    if (data.appInfo.targetSdkVersion <= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) {
        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);
    /*
         * Before spawning a new process, reset the time zone to be the system time zone.
         * This needs to be done because the system time zone could have changed after the
         * the spawning of this process. Without doing this this process would have the incorrect
         * system time zone.
         */
    TimeZone.setDefault(null);
    /*
         * Set the LocaleList. This may change once we create the App Context.
         */
    LocaleList.setDefault(data.config.getLocales());
    synchronized (mResourcesManager) {
        /*
             * Update the system configuration since its preloaded and might not
             * reflect configuration changes. The configuration object passed
             * in AppBindData can be safely assumed to be up to date
             */
        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);
        mCurDefaultDisplayDpi = data.config.densityDpi;
        // This calls mResourcesManager so keep it within the synchronized block.
        applyCompatConfiguration(mCurDefaultDisplayDpi);
    }
    data.loadedApk = getLoadedApkNoCheck(data.appInfo, data.compatInfo);
    if (agent != null) {
        handleAttachAgent(agent, data.loadedApk);
    }
    /**
     * Switch this process to density compatibility mode if needed.
     */
    if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
        mDensityCompatMode = true;
        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
    }
    updateDefaultDensity();
    final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);
    Boolean is24Hr = null;
    if (use24HourSetting != null) {
        is24Hr = "24".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;
    }
    // null : use locale default for 12/24 hour formatting,
    // false : use 12 hour format,
    // true : use 24 hour format.
    DateFormat.set24HourTimePref(is24Hr);
    View.mDebugViewAttributes = mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0;
    /**
     * For system applications on userdebug/eng builds, log stack
     * traces of disk and network access to dropbox for analysis.
     */
    if ((data.appInfo.flags & (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != 0) {
        StrictMode.conditionallyEnableDebugLogging();
    }
    /**
     * For apps targetting Honeycomb or later, we don't allow network usage
     * on the main event loop / UI thread. This is what ultimately throws
     * {@link NetworkOnMainThreadException}.
     */
    if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB) {
        StrictMode.enableDeathOnNetwork();
    }
    /**
     * For apps targetting N or later, we don't allow file:// Uri exposure.
     * This is what ultimately throws {@link FileUriExposedException}.
     */
    if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.N) {
        StrictMode.enableDeathOnFileUriExposure();
    }
    // before any app code has been loaded.
    try {
        Field field = Build.class.getDeclaredField("SERIAL");
        field.setAccessible(true);
        field.set(Build.class, data.buildSerial);
    } catch (NoSuchFieldException | IllegalAccessException e) {
    /* ignore */
    }
    if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) {
        // XXX should have option to change the port.
        Debug.changeDebugPort(8100);
        if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) {
            Slog.w(TAG, "Application " + data.loadedApk.getPackageName() + " is waiting for the debugger on port 8100...");
            IActivityManager mgr = ActivityManager.getService();
            try {
                mgr.showWaitingForDebugger(mAppThread, true);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            Debug.waitForDebugger();
            try {
                mgr.showWaitingForDebugger(mAppThread, false);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        } else {
            Slog.w(TAG, "Application " + data.loadedApk.getPackageName() + " can be debugged on port 8100...");
        }
    }
    // Allow application-generated systrace messages if we're debuggable.
    boolean isAppDebuggable = (data.appInfo.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
    Trace.setAppTracingAllowed(isAppDebuggable);
    if (isAppDebuggable && data.enableBinderTracking) {
        Binder.enableTracing();
    }
    /**
     * Initialize the default http proxy in this process for the reasons we set the time zone.
     */
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Setup proxies");
    final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
    if (b != null) {
        // In pre-boot mode (doing initial launch to collect password), not
        // all system is up.  This includes the connectivity service, so don't
        // crash if we can't get it.
        final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
        try {
            final ProxyInfo proxyInfo = service.getProxyForNetwork(null);
            Proxy.setHttpProxySystemProperty(proxyInfo);
        } catch (RemoteException e) {
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            throw e.rethrowFromSystemServer();
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Instrumentation info affects the class loader, so load it before
    // setting up the app context.
    final InstrumentationInfo ii;
    if (data.instrumentationName != null) {
        try {
            ii = new ApplicationPackageManager(null, getPackageManager()).getInstrumentationInfo(data.instrumentationName, 0);
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Unable to find instrumentation info for: " + data.instrumentationName);
        }
        mInstrumentationPackageName = ii.packageName;
        mInstrumentationAppDir = ii.sourceDir;
        mInstrumentationSplitAppDirs = ii.splitSourceDirs;
        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);
        mInstrumentedAppDir = data.loadedApk.getAppDir();
        mInstrumentedSplitAppDirs = data.loadedApk.getSplitAppDirs();
        mInstrumentedLibDir = data.loadedApk.getLibDir();
    } else {
        ii = null;
    }
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.loadedApk);
    updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());
    if (!Process.isIsolated()) {
        setupGraphicsSupport(appContext);
    }
    // complete application startup.
    if (SystemProperties.getBoolean("dalvik.vm.usejitprofiles", false)) {
        BaseDexClassLoader.setReporter(DexLoadReporter.getInstance());
    }
    // Install the Network Security Config Provider. This must happen before the application
    // code is loaded to prevent issues with instances of TLS objects being created before
    // the provider is installed.
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "NetworkSecurityConfigProvider.install");
    NetworkSecurityConfigProvider.install(appContext);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    // Continue loading instrumentation.
    if (ii != null) {
        final ApplicationInfo instrApp = new ApplicationInfo();
        ii.copyTo(instrApp);
        instrApp.initForUser(UserHandle.myUserId());
        final LoadedApk loadedApk = getLoadedApk(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false);
        final ContextImpl instrContext = ContextImpl.createAppContext(this, loadedApk);
        try {
            final ClassLoader cl = instrContext.getClassLoader();
            mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Unable to instantiate instrumentation " + data.instrumentationName + ": " + e.toString(), e);
        }
        final ComponentName component = new ComponentName(ii.packageName, ii.name);
        mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);
        if (mProfiler.profileFile != null && !ii.handleProfiling && mProfiler.profileFd == null) {
            mProfiler.handlingProfiling = true;
            final File file = new File(mProfiler.profileFile);
            file.getParentFile().mkdirs();
            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
        }
    } else {
        mInstrumentation = new Instrumentation();
    }
    if ((data.appInfo.flags & ApplicationInfo.FLAG_LARGE_HEAP) != 0) {
        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();
    } else {
        // Small heap, clamp to the current growth limit and let the heap release
        // pages after the growth limit to the non growth limit capacity. b/18387825
        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();
    }
    // Allow disk access during application and provider setup. This could
    // block processing ordered broadcasts, but later processing would
    // probably end up doing the same disk access.
    Application app;
    final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();
    final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();
    try {
        // If the app is being launched for full backup or restore, bring it up in
        // a restricted environment with the base application class.
        app = data.loadedApk.makeApplication(data.restrictedBackupMode, null);
        mInitialApplication = app;
        // app's custom Application class
        if (!data.restrictedBackupMode) {
            if (!ArrayUtils.isEmpty(data.providers)) {
                installContentProviders(app, data.providers);
                // For process that contains content providers, we want to
                // ensure that the JIT is enabled "at some point".
                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10 * 1000);
            }
        }
        // test thread at this point, and we don't want that racing.
        try {
            mInstrumentation.onCreate(data.instrumentationArgs);
        } catch (Exception e) {
            throw new RuntimeException("Exception thrown in onCreate() of " + data.instrumentationName + ": " + e.toString(), e);
        }
        try {
            mInstrumentation.callApplicationOnCreate(app);
        } catch (Exception e) {
            if (!mInstrumentation.onException(app, e)) {
                throw new RuntimeException("Unable to create application " + app.getClass().getName() + ": " + e.toString(), e);
            }
        }
    } finally {
        // during startup, clobber the policy to maintain behavior of b/36951662
        if (data.appInfo.targetSdkVersion <= Build.VERSION_CODES.O || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
    // Preload fonts resources
    FontsContract.setApplicationContextForResources(appContext);
    try {
        final ApplicationInfo info = getPackageManager().getApplicationInfo(data.appInfo.packageName, PackageManager.GET_META_DATA, /*flags*/
        UserHandle.myUserId());
        if (info.metaData != null) {
            final int preloadedFontsResource = info.metaData.getInt(ApplicationInfo.METADATA_PRELOADED_FONTS, 0);
            if (preloadedFontsResource != 0) {
                data.loadedApk.getResources().preloadFonts(preloadedFontsResource);
            }
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        ProfilerInfo profilerInfo = null;
        String preBindAgent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            if (mProfilerInfo != null) {
                // Send a profiler info object to the app if either a file is given, or
                // an agent should be loaded at bind-time.
                profilerInfo = (mProfilerInfo.profileFile != null || mProfilerInfo.bindTimeAgentAttach) ? new ProfilerInfo(mProfilerInfo) : null;
                if (!mProfilerInfo.bindTimeAgentAttach) {
                    preBindAgent = mProfilerInfo.agent;
                }
            }
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null, false);
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (preBindAgent != null) {
            thread.attachAgent(preBindAgent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#method_after
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    long startTime = SystemClock.uptimeMillis();
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToImportant = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    checkTime(startTime, "attachApplicationLocked: before bindApplication");
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = ApplicationThreadConstants.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        ProfilerInfo profilerInfo = null;
        String preBindAgent = null;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            if (mProfilerInfo != null) {
                // Send a profiler info object to the app if either a file is given, or
                // an agent should be loaded at bind-time.
                boolean needsInfo = mProfilerInfo.profileFile != null || mProfilerInfo.attachAgentDuringBind;
                profilerInfo = needsInfo ? new ProfilerInfo(mProfilerInfo) : null;
                if (!mProfilerInfo.attachAgentDuringBind) {
                    preBindAgent = mProfilerInfo.agent;
                }
            }
        } else if (app.instr != null && app.instr.mProfileFile != null) {
            profilerInfo = new ProfilerInfo(app.instr.mProfileFile, null, 0, false, false, null, false);
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instr != null) {
            notifyPackageUse(app.instr.mClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + getGlobalConfiguration());
        ApplicationInfo appInfo = app.instr != null ? app.instr.mTargetInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profilerInfo != null && profilerInfo.profileFd != null) {
            profilerInfo.profileFd = profilerInfo.profileFd.dup();
        }
        // We deprecated Build.SERIAL and it is not accessible to
        // apps that target the v2 security sandbox. Since access to
        // the serial is now behind a permission we push down the value.
        String buildSerial = appInfo.targetSandboxVersion < 2 ? sTheRealBuildSerial : Build.UNKNOWN;
        // instrumentation process.)
        if (mActiveInstrumentation.size() > 0 && app.instr == null) {
            for (int i = mActiveInstrumentation.size() - 1; i >= 0 && app.instr == null; i--) {
                ActiveInstrumentation aInstr = mActiveInstrumentation.get(i);
                if (!aInstr.mFinished && aInstr.mTargetInfo.uid == app.uid) {
                    if (aInstr.mTargetProcesses.length == 0) {
                        // the target instrumentation should be included.
                        if (aInstr.mTargetInfo.packageName.equals(app.info.packageName)) {
                            app.instr = aInstr;
                            aInstr.mRunningProcesses.add(app);
                        }
                    } else {
                        for (String proc : aInstr.mTargetProcesses) {
                            if (proc.equals(app.processName)) {
                                app.instr = aInstr;
                                aInstr.mRunningProcesses.add(app);
                                break;
                            }
                        }
                    }
                }
            }
        }
        // application code.
        if (preBindAgent != null) {
            thread.attachAgent(preBindAgent);
        }
        checkTime(startTime, "attachApplicationLocked: immediately before bindApplication");
        mStackSupervisor.mActivityMetricsLogger.notifyBindApplication(app);
        if (app.instr != null) {
            thread.bindApplication(processName, appInfo, providers, app.instr.mClass, profilerInfo, app.instr.mArguments, app.instr.mWatcher, app.instr.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        } else {
            thread.bindApplication(processName, appInfo, providers, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(getGlobalConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial);
        }
        checkTime(startTime, "attachApplicationLocked: immediately after bindApplication");
        updateLruProcessLocked(app, false, null);
        checkTime(startTime, "attachApplicationLocked: after updateLruProcessLocked");
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
            checkTime(startTime, "attachApplicationLocked: after mServices.attachApplicationLocked");
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
            checkTime(startTime, "attachApplicationLocked: after sendPendingBroadcastsLocked");
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.app == app) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
        checkTime(startTime, "attachApplicationLocked: after updateOomAdjLocked");
    }
    return true;
}
#end_block

#method_before
private Intent makeIntent(int defUser) throws URISyntaxException {
    mStartFlags = 0;
    mWaitOption = false;
    mStopOption = false;
    mRepeat = 0;
    mProfileFile = null;
    mSamplingInterval = 0;
    mAutoStop = false;
    mStreaming = false;
    mUserId = defUser;
    mDisplayId = INVALID_DISPLAY;
    mStackId = INVALID_STACK_ID;
    mTaskId = INVALID_TASK_ID;
    mIsTaskOverlay = false;
    return Intent.parseCommandArgs(this, new Intent.CommandOptionHandler() {

        @Override
        public boolean handleOption(String opt, ShellCommand cmd) {
            if (opt.equals("-D")) {
                mStartFlags |= ActivityManager.START_FLAG_DEBUG;
            } else if (opt.equals("-N")) {
                mStartFlags |= ActivityManager.START_FLAG_NATIVE_DEBUGGING;
            } else if (opt.equals("-W")) {
                mWaitOption = true;
            } else if (opt.equals("-P")) {
                mProfileFile = getNextArgRequired();
                mAutoStop = true;
            } else if (opt.equals("--start-profiler")) {
                mProfileFile = getNextArgRequired();
                mAutoStop = false;
            } else if (opt.equals("--sampling")) {
                mSamplingInterval = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--streaming")) {
                mStreaming = true;
            } else if (opt.equals("--attach-agent")) {
                mAgent = getNextArgRequired();
                mBindTimeAttachAgent = false;
            } else if (opt.equals("--attach-agent-bind")) {
                mAgent = getNextArgRequired();
                mBindTimeAttachAgent = true;
            } else if (opt.equals("-R")) {
                mRepeat = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("-S")) {
                mStopOption = true;
            } else if (opt.equals("--track-allocation")) {
                mStartFlags |= ActivityManager.START_FLAG_TRACK_ALLOCATION;
            } else if (opt.equals("--user")) {
                mUserId = UserHandle.parseUserArg(getNextArgRequired());
            } else if (opt.equals("--receiver-permission")) {
                mReceiverPermission = getNextArgRequired();
            } else if (opt.equals("--display")) {
                mDisplayId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--stack")) {
                mStackId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--task")) {
                mTaskId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--task-overlay")) {
                mIsTaskOverlay = true;
            } else {
                return false;
            }
            return true;
        }
    });
}
#method_after
private Intent makeIntent(int defUser) throws URISyntaxException {
    mStartFlags = 0;
    mWaitOption = false;
    mStopOption = false;
    mRepeat = 0;
    mProfileFile = null;
    mSamplingInterval = 0;
    mAutoStop = false;
    mStreaming = false;
    mUserId = defUser;
    mDisplayId = INVALID_DISPLAY;
    mStackId = INVALID_STACK_ID;
    mTaskId = INVALID_TASK_ID;
    mIsTaskOverlay = false;
    return Intent.parseCommandArgs(this, new Intent.CommandOptionHandler() {

        @Override
        public boolean handleOption(String opt, ShellCommand cmd) {
            if (opt.equals("-D")) {
                mStartFlags |= ActivityManager.START_FLAG_DEBUG;
            } else if (opt.equals("-N")) {
                mStartFlags |= ActivityManager.START_FLAG_NATIVE_DEBUGGING;
            } else if (opt.equals("-W")) {
                mWaitOption = true;
            } else if (opt.equals("-P")) {
                mProfileFile = getNextArgRequired();
                mAutoStop = true;
            } else if (opt.equals("--start-profiler")) {
                mProfileFile = getNextArgRequired();
                mAutoStop = false;
            } else if (opt.equals("--sampling")) {
                mSamplingInterval = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--streaming")) {
                mStreaming = true;
            } else if (opt.equals("--attach-agent")) {
                if (mAgent != null) {
                    cmd.getErrPrintWriter().println("Multiple --attach-agent(-bind) not supported");
                    return false;
                }
                mAgent = getNextArgRequired();
                mAttachAgentDuringBind = false;
            } else if (opt.equals("--attach-agent-bind")) {
                if (mAgent != null) {
                    cmd.getErrPrintWriter().println("Multiple --attach-agent(-bind) not supported");
                    return false;
                }
                mAgent = getNextArgRequired();
                mAttachAgentDuringBind = true;
            } else if (opt.equals("-R")) {
                mRepeat = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("-S")) {
                mStopOption = true;
            } else if (opt.equals("--track-allocation")) {
                mStartFlags |= ActivityManager.START_FLAG_TRACK_ALLOCATION;
            } else if (opt.equals("--user")) {
                mUserId = UserHandle.parseUserArg(getNextArgRequired());
            } else if (opt.equals("--receiver-permission")) {
                mReceiverPermission = getNextArgRequired();
            } else if (opt.equals("--display")) {
                mDisplayId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--stack")) {
                mStackId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--task")) {
                mTaskId = Integer.parseInt(getNextArgRequired());
            } else if (opt.equals("--task-overlay")) {
                mIsTaskOverlay = true;
            } else {
                return false;
            }
            return true;
        }
    });
}
#end_block

#method_before
int runStartActivity(PrintWriter pw) throws RemoteException {
    Intent intent;
    try {
        intent = makeIntent(UserHandle.USER_CURRENT);
    } catch (URISyntaxException e) {
        throw new RuntimeException(e.getMessage(), e);
    }
    if (mUserId == UserHandle.USER_ALL) {
        getErrPrintWriter().println("Error: Can't start service with user 'all'");
        return 1;
    }
    String mimeType = intent.getType();
    if (mimeType == null && intent.getData() != null && "content".equals(intent.getData().getScheme())) {
        mimeType = mInterface.getProviderMimeType(intent.getData(), mUserId);
    }
    do {
        if (mStopOption) {
            String packageName;
            if (intent.getComponent() != null) {
                packageName = intent.getComponent().getPackageName();
            } else {
                List<ResolveInfo> activities = mPm.queryIntentActivities(intent, mimeType, 0, mUserId).getList();
                if (activities == null || activities.size() <= 0) {
                    getErrPrintWriter().println("Error: Intent does not match any activities: " + intent);
                    return 1;
                } else if (activities.size() > 1) {
                    getErrPrintWriter().println("Error: Intent matches multiple activities; can't stop: " + intent);
                    return 1;
                }
                packageName = activities.get(0).activityInfo.packageName;
            }
            pw.println("Stopping: " + packageName);
            pw.flush();
            mInterface.forceStopPackage(packageName, mUserId);
            try {
                Thread.sleep(250);
            } catch (InterruptedException e) {
            }
        }
        ProfilerInfo profilerInfo = null;
        if (mProfileFile != null || mAgent != null) {
            ParcelFileDescriptor fd = null;
            if (mProfileFile != null) {
                fd = openOutputFileForSystem(mProfileFile);
                if (fd == null) {
                    return 1;
                }
            }
            profilerInfo = new ProfilerInfo(mProfileFile, fd, mSamplingInterval, mAutoStop, mStreaming, mAgent, mBindTimeAttachAgent);
        }
        pw.println("Starting: " + intent);
        pw.flush();
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        WaitResult result = null;
        int res;
        final long startTime = SystemClock.uptimeMillis();
        ActivityOptions options = null;
        if (mDisplayId != INVALID_DISPLAY) {
            options = ActivityOptions.makeBasic();
            options.setLaunchDisplayId(mDisplayId);
        }
        if (mStackId != INVALID_STACK_ID) {
            options = ActivityOptions.makeBasic();
            options.setLaunchStackId(mStackId);
        }
        if (mTaskId != INVALID_TASK_ID) {
            options = ActivityOptions.makeBasic();
            options.setLaunchTaskId(mTaskId);
            if (mIsTaskOverlay) {
                options.setTaskOverlay(true, true);
            }
        }
        if (mWaitOption) {
            result = mInterface.startActivityAndWait(null, null, intent, mimeType, null, null, 0, mStartFlags, profilerInfo, options != null ? options.toBundle() : null, mUserId);
            res = result.result;
        } else {
            res = mInterface.startActivityAsUser(null, null, intent, mimeType, null, null, 0, mStartFlags, profilerInfo, options != null ? options.toBundle() : null, mUserId);
        }
        final long endTime = SystemClock.uptimeMillis();
        PrintWriter out = mWaitOption ? pw : getErrPrintWriter();
        boolean launched = false;
        switch(res) {
            case ActivityManager.START_SUCCESS:
                launched = true;
                break;
            case ActivityManager.START_SWITCHES_CANCELED:
                launched = true;
                out.println("Warning: Activity not started because the " + " current activity is being kept for the user.");
                break;
            case ActivityManager.START_DELIVERED_TO_TOP:
                launched = true;
                out.println("Warning: Activity not started, intent has " + "been delivered to currently running " + "top-most instance.");
                break;
            case ActivityManager.START_RETURN_INTENT_TO_CALLER:
                launched = true;
                out.println("Warning: Activity not started because intent " + "should be handled by the caller");
                break;
            case ActivityManager.START_TASK_TO_FRONT:
                launched = true;
                out.println("Warning: Activity not started, its current " + "task has been brought to the front");
                break;
            case ActivityManager.START_INTENT_NOT_RESOLVED:
                out.println("Error: Activity not started, unable to " + "resolve " + intent.toString());
                break;
            case ActivityManager.START_CLASS_NOT_FOUND:
                out.println(NO_CLASS_ERROR_CODE);
                out.println("Error: Activity class " + intent.getComponent().toShortString() + " does not exist.");
                break;
            case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
                out.println("Error: Activity not started, you requested to " + "both forward and receive its result");
                break;
            case ActivityManager.START_PERMISSION_DENIED:
                out.println("Error: Activity not started, you do not " + "have permission to access it.");
                break;
            case ActivityManager.START_NOT_VOICE_COMPATIBLE:
                out.println("Error: Activity not started, voice control not allowed for: " + intent);
                break;
            case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:
                out.println("Error: Not allowed to start background user activity" + " that shouldn't be displayed for all users.");
                break;
            default:
                out.println("Error: Activity not started, unknown error code " + res);
                break;
        }
        out.flush();
        if (mWaitOption && launched) {
            if (result == null) {
                result = new WaitResult();
                result.who = intent.getComponent();
            }
            pw.println("Status: " + (result.timeout ? "timeout" : "ok"));
            if (result.who != null) {
                pw.println("Activity: " + result.who.flattenToShortString());
            }
            if (result.thisTime >= 0) {
                pw.println("ThisTime: " + result.thisTime);
            }
            if (result.totalTime >= 0) {
                pw.println("TotalTime: " + result.totalTime);
            }
            pw.println("WaitTime: " + (endTime - startTime));
            pw.println("Complete");
            pw.flush();
        }
        mRepeat--;
        if (mRepeat > 0) {
            mInterface.unhandledBack();
        }
    } while (mRepeat > 0);
    return 0;
}
#method_after
int runStartActivity(PrintWriter pw) throws RemoteException {
    Intent intent;
    try {
        intent = makeIntent(UserHandle.USER_CURRENT);
    } catch (URISyntaxException e) {
        throw new RuntimeException(e.getMessage(), e);
    }
    if (mUserId == UserHandle.USER_ALL) {
        getErrPrintWriter().println("Error: Can't start service with user 'all'");
        return 1;
    }
    String mimeType = intent.getType();
    if (mimeType == null && intent.getData() != null && "content".equals(intent.getData().getScheme())) {
        mimeType = mInterface.getProviderMimeType(intent.getData(), mUserId);
    }
    do {
        if (mStopOption) {
            String packageName;
            if (intent.getComponent() != null) {
                packageName = intent.getComponent().getPackageName();
            } else {
                List<ResolveInfo> activities = mPm.queryIntentActivities(intent, mimeType, 0, mUserId).getList();
                if (activities == null || activities.size() <= 0) {
                    getErrPrintWriter().println("Error: Intent does not match any activities: " + intent);
                    return 1;
                } else if (activities.size() > 1) {
                    getErrPrintWriter().println("Error: Intent matches multiple activities; can't stop: " + intent);
                    return 1;
                }
                packageName = activities.get(0).activityInfo.packageName;
            }
            pw.println("Stopping: " + packageName);
            pw.flush();
            mInterface.forceStopPackage(packageName, mUserId);
            try {
                Thread.sleep(250);
            } catch (InterruptedException e) {
            }
        }
        ProfilerInfo profilerInfo = null;
        if (mProfileFile != null || mAgent != null) {
            ParcelFileDescriptor fd = null;
            if (mProfileFile != null) {
                fd = openOutputFileForSystem(mProfileFile);
                if (fd == null) {
                    return 1;
                }
            }
            profilerInfo = new ProfilerInfo(mProfileFile, fd, mSamplingInterval, mAutoStop, mStreaming, mAgent, mAttachAgentDuringBind);
        }
        pw.println("Starting: " + intent);
        pw.flush();
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        WaitResult result = null;
        int res;
        final long startTime = SystemClock.uptimeMillis();
        ActivityOptions options = null;
        if (mDisplayId != INVALID_DISPLAY) {
            options = ActivityOptions.makeBasic();
            options.setLaunchDisplayId(mDisplayId);
        }
        if (mStackId != INVALID_STACK_ID) {
            options = ActivityOptions.makeBasic();
            options.setLaunchStackId(mStackId);
        }
        if (mTaskId != INVALID_TASK_ID) {
            options = ActivityOptions.makeBasic();
            options.setLaunchTaskId(mTaskId);
            if (mIsTaskOverlay) {
                options.setTaskOverlay(true, true);
            }
        }
        if (mWaitOption) {
            result = mInterface.startActivityAndWait(null, null, intent, mimeType, null, null, 0, mStartFlags, profilerInfo, options != null ? options.toBundle() : null, mUserId);
            res = result.result;
        } else {
            res = mInterface.startActivityAsUser(null, null, intent, mimeType, null, null, 0, mStartFlags, profilerInfo, options != null ? options.toBundle() : null, mUserId);
        }
        final long endTime = SystemClock.uptimeMillis();
        PrintWriter out = mWaitOption ? pw : getErrPrintWriter();
        boolean launched = false;
        switch(res) {
            case ActivityManager.START_SUCCESS:
                launched = true;
                break;
            case ActivityManager.START_SWITCHES_CANCELED:
                launched = true;
                out.println("Warning: Activity not started because the " + " current activity is being kept for the user.");
                break;
            case ActivityManager.START_DELIVERED_TO_TOP:
                launched = true;
                out.println("Warning: Activity not started, intent has " + "been delivered to currently running " + "top-most instance.");
                break;
            case ActivityManager.START_RETURN_INTENT_TO_CALLER:
                launched = true;
                out.println("Warning: Activity not started because intent " + "should be handled by the caller");
                break;
            case ActivityManager.START_TASK_TO_FRONT:
                launched = true;
                out.println("Warning: Activity not started, its current " + "task has been brought to the front");
                break;
            case ActivityManager.START_INTENT_NOT_RESOLVED:
                out.println("Error: Activity not started, unable to " + "resolve " + intent.toString());
                break;
            case ActivityManager.START_CLASS_NOT_FOUND:
                out.println(NO_CLASS_ERROR_CODE);
                out.println("Error: Activity class " + intent.getComponent().toShortString() + " does not exist.");
                break;
            case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
                out.println("Error: Activity not started, you requested to " + "both forward and receive its result");
                break;
            case ActivityManager.START_PERMISSION_DENIED:
                out.println("Error: Activity not started, you do not " + "have permission to access it.");
                break;
            case ActivityManager.START_NOT_VOICE_COMPATIBLE:
                out.println("Error: Activity not started, voice control not allowed for: " + intent);
                break;
            case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:
                out.println("Error: Not allowed to start background user activity" + " that shouldn't be displayed for all users.");
                break;
            default:
                out.println("Error: Activity not started, unknown error code " + res);
                break;
        }
        out.flush();
        if (mWaitOption && launched) {
            if (result == null) {
                result = new WaitResult();
                result.who = intent.getComponent();
            }
            pw.println("Status: " + (result.timeout ? "timeout" : "ok"));
            if (result.who != null) {
                pw.println("Activity: " + result.who.flattenToShortString());
            }
            if (result.thisTime >= 0) {
                pw.println("ThisTime: " + result.thisTime);
            }
            if (result.totalTime >= 0) {
                pw.println("TotalTime: " + result.totalTime);
            }
            pw.println("WaitTime: " + (endTime - startTime));
            pw.println("Complete");
            pw.flush();
        }
        mRepeat--;
        if (mRepeat > 0) {
            mInterface.unhandledBack();
        }
    } while (mRepeat > 0);
    return 0;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeString(profileFile);
    if (profileFd != null) {
        out.writeInt(1);
        profileFd.writeToParcel(out, flags);
    } else {
        out.writeInt(0);
    }
    out.writeInt(samplingInterval);
    out.writeInt(autoStopProfiler ? 1 : 0);
    out.writeInt(streamingOutput ? 1 : 0);
    out.writeString(agent);
    out.writeBoolean(bindTimeAgentAttach);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeString(profileFile);
    if (profileFd != null) {
        out.writeInt(1);
        profileFd.writeToParcel(out, flags);
    } else {
        out.writeInt(0);
    }
    out.writeInt(samplingInterval);
    out.writeInt(autoStopProfiler ? 1 : 0);
    out.writeInt(streamingOutput ? 1 : 0);
    out.writeString(agent);
    out.writeBoolean(attachAgentDuringBind);
}
#end_block

#method_before
public TimeZone lookupByOffsetWithBias(int offsetSeconds, boolean isDst, long whenMillis, TimeZone bias) {
    if (timeZoneIds == null || timeZoneIds.isEmpty()) {
        return null;
    }
    List<TimeZone> candidates = getIcuTimeZones();
    TimeZone firstMatch = null;
    for (TimeZone match : candidates) {
        if (!offsetMatchesAtTime(match, offsetSeconds, isDst, whenMillis)) {
            continue;
        }
        if (firstMatch == null) {
            if (bias == null) {
                // No bias, so we can stop at the first match.
                return match;
            }
            // We have to carry on checking in case the bias matches. We want to return the
            // first if it doesn't, though.
            firstMatch = match;
        }
        // already.
        if (match.getID().equals(bias.getID())) {
            return match;
        }
    }
    // Return firstMatch, which can be null if there was no match.
    return firstMatch;
}
#method_after
public TimeZone lookupByOffsetWithBias(int offsetMillis, boolean isDst, long whenMillis, TimeZone bias) {
    if (timeZoneIds == null || timeZoneIds.isEmpty()) {
        return null;
    }
    List<TimeZone> candidates = getIcuTimeZones();
    TimeZone firstMatch = null;
    for (TimeZone match : candidates) {
        if (!offsetMatchesAtTime(match, offsetMillis, isDst, whenMillis)) {
            continue;
        }
        if (firstMatch == null) {
            if (bias == null) {
                // No bias, so we can stop at the first match.
                return match;
            }
            // We have to carry on checking in case the bias matches. We want to return the
            // first if it doesn't, though.
            firstMatch = match;
        }
        // already.
        if (match.getID().equals(bias.getID())) {
            return match;
        }
    }
    // Return firstMatch, which can be null if there was no match.
    return firstMatch;
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    testCluster1();
}
#method_after
public static void main(String[] args) throws Exception {
    try {
        testCluster1();
    } catch (Exception e) {
        Map<Thread, StackTraceElement[]> stacks = Thread.getAllStackTraces();
        for (Map.Entry<Thread, StackTraceElement[]> entry : stacks.entrySet()) {
            System.out.println(entry.getKey());
            System.out.println(Arrays.toString(entry.getValue()));
        }
        throw e;
    }
}
#end_block

#method_before
private static void testCluster1() throws Exception {
    // Test setup (at deadlock):
    // 
    // Thread 1:
    // #0 step: synchornized(o3) { synchronized(o2) }
    // #1 step: synchronized(o1)
    // 
    // Thread 2:
    // #0 step: synchronized(o1)
    // #1 step: synchronized(o4) { synchronized(o2) }
    // 
    LinkedList<Object> l1 = new LinkedList<>();
    LinkedList<CyclicBarrier> b1 = new LinkedList<>();
    LinkedList<Object> l2 = new LinkedList<>();
    LinkedList<CyclicBarrier> b2 = new LinkedList<>();
    Object o1 = new Object();
    Object o2 = new Object();
    Object o3 = new Object();
    Object o4 = new Object();
    l1.add(o1);
    l1.add(o3);
    l1.add(o2);
    l2.add(o4);
    l2.add(o2);
    l2.add(o1);
    CyclicBarrier c1 = new CyclicBarrier(3);
    CyclicBarrier c2 = new CyclicBarrier(2);
    b1.add(c1);
    b1.add(null);
    b1.add(c2);
    b2.add(null);
    b2.add(c1);
    b2.add(c2);
    Thread t1 = new Thread(new Runner(l1, b1));
    t1.setDaemon(true);
    t1.start();
    Thread t2 = new Thread(new Runner(l2, b2));
    t2.setDaemon(true);
    t2.start();
    c1.await();
    waitNotRunnable(t1);
    waitNotRunnable(t2);
    // Thread 1.
    {
        Object[][] stack1 = getAnnotatedStack(t1);
        assertLength(stack1[0], 3);
        // Blocked on o2.
        assertEquals(stack1[0][2], o2);
        // Locked o3.
        assertLocks(stack1[0][1], o3);
        assertStackTraceElementStep(stack1[0][0]);
        assertLength(stack1[1], 2);
        // Locked o1.
        assertLocks(stack1[1][1], o1);
        assertStackTraceElementStep(stack1[1][0]);
    }
    // Thread 2.
    {
        Object[][] stack2 = getAnnotatedStack(t2);
        assertLength(stack2[0], 3);
        // Blocked on o1.
        assertEquals(stack2[0][2], o1);
        // Nothing locked.
        assertLocks(stack2[0][1]);
        assertStackTraceElementStep(stack2[0][0]);
        assertLength(stack2[1], 2);
        // Locked o4, o2.
        assertLocks(stack2[1][1], o4, o2);
        assertStackTraceElementStep(stack2[1][0]);
    }
}
#method_after
private static void testCluster1() throws Exception {
    // Test setup (at deadlock):
    // 
    // Thread 1:
    // #0 step: synchornized(o3) { synchronized(o2) }
    // #1 step: synchronized(o1)
    // 
    // Thread 2:
    // #0 step: synchronized(o1)
    // #1 step: synchronized(o4) { synchronized(o2) }
    // 
    LinkedList<Object> l1 = new LinkedList<>();
    LinkedList<CyclicBarrier> b1 = new LinkedList<>();
    LinkedList<Object> l2 = new LinkedList<>();
    LinkedList<CyclicBarrier> b2 = new LinkedList<>();
    Object o1 = new Object();
    Object o2 = new Object();
    Object o3 = new Object();
    Object o4 = new Object();
    l1.add(o1);
    l1.add(o3);
    l1.add(o2);
    l2.add(o4);
    l2.add(o2);
    l2.add(o1);
    CyclicBarrier c1 = new CyclicBarrier(3);
    CyclicBarrier c2 = new CyclicBarrier(2);
    b1.add(c1);
    b1.add(null);
    b1.add(c2);
    b2.add(null);
    b2.add(c1);
    b2.add(c2);
    Thread t1 = new Thread(new Runner(l1, b1));
    t1.setDaemon(true);
    t1.start();
    Thread t2 = new Thread(new Runner(l2, b2));
    t2.setDaemon(true);
    t2.start();
    c1.await();
    waitNotRunnable(t1);
    waitNotRunnable(t2);
    // Unfortunately this seems necessary. :-(
    Thread.sleep(250);
    // Thread 1.
    {
        Object[] stack1 = getAnnotatedStack(t1);
        // Blocked on o2.
        assertBlockedOn(stack1[0], o2);
        // Locked o3.
        assertLocks(stack1[0], o3);
        assertStackTraceElementStep(stack1[0]);
        // Frame can't be blocked.
        assertBlockedOn(stack1[1], null);
        // Locked o1.
        assertLocks(stack1[1], o1);
        assertStackTraceElementStep(stack1[1]);
    }
    // Thread 2.
    {
        Object[] stack2 = getAnnotatedStack(t2);
        // Blocked on o1.
        assertBlockedOn(stack2[0], o1);
        // Nothing locked.
        assertLocks(stack2[0]);
        assertStackTraceElementStep(stack2[0]);
        // Frame can't be blocked.
        assertBlockedOn(stack2[1], null);
        // Locked o4, o2.
        assertLocks(stack2[1], o4, o2);
        assertStackTraceElementStep(stack2[1]);
    }
}
#end_block

#method_before
private static Object[][] getAnnotatedStack(Thread t) throws Exception {
    Class<?> vmStack = Class.forName("dalvik.system.VMStack");
    Method m = vmStack.getDeclaredMethod("getAnnotatedThreadStackTrace", Thread.class);
    return (Object[][]) m.invoke(null, t);
}
#method_after
private static Object[] getAnnotatedStack(Thread t) throws Exception {
    Class<?> vmStack = Class.forName("dalvik.system.VMStack");
    Method m = vmStack.getDeclaredMethod("getAnnotatedThreadStackTrace", Thread.class);
    return (Object[]) m.invoke(null, t);
}
#end_block

#method_before
private static void assertLocks(Object fromTrace, Object... locks) {
    assertEquals((Object[]) fromTrace, (locks == null) ? null : (locks.length == 0 ? null : locks));
}
#method_after
private static void assertLocks(Object fromTrace, Object... locks) throws Exception {
    Object fieldValue = fromTrace.getClass().getDeclaredMethod("getHeldLocks").invoke(fromTrace);
    assertEquals((Object[]) fieldValue, (locks == null) ? null : (locks.length == 0 ? null : locks));
}
#end_block

#method_before
private static void assertStackTraceElementStep(Object o) {
    if (o instanceof StackTraceElement) {
        StackTraceElement elem = (StackTraceElement) o;
        if (!elem.getMethodName().equals("step")) {
            throw new RuntimeException("Expected step method");
        }
        return;
    }
    throw new RuntimeException("Expected StackTraceElement " + o);
}
#method_after
private static void assertStackTraceElementStep(Object o) throws Exception {
    Object fieldValue = o.getClass().getDeclaredMethod("getStackTraceElement").invoke(o);
    if (fieldValue instanceof StackTraceElement) {
        StackTraceElement elem = (StackTraceElement) fieldValue;
        if (!elem.getMethodName().equals("step")) {
            throw new RuntimeException("Expected step method");
        }
        return;
    }
    throw new RuntimeException("Expected StackTraceElement " + fieldValue + " / " + o);
}
#end_block

#method_before
@Override
public void removeNetwork(int netId) {
    mContext.enforceCallingOrSelfPermission(CONNECTIVITY_INTERNAL, TAG);
    try {
        mNetdService.networkDestroy(netId);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e.rethrowAsRuntimeException();
    }
}
#method_after
@Override
public void removeNetwork(int netId) {
    mContext.enforceCallingOrSelfPermission(NETWORK_STACK, TAG);
    try {
        mNetdService.networkDestroy(netId);
    } catch (ServiceSpecificException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e;
    } catch (RemoteException e) {
        Log.w(TAG, "removeNetwork(" + netId + "): ", e);
        throw e.rethrowAsRuntimeException();
    }
}
#end_block

#method_before
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            Record r;
            find_and_add: {
                IBinder b = callback.asBinder();
                final int N = mRecords.size();
                for (int i = 0; i < N; i++) {
                    r = mRecords.get(i);
                    if (b == r.binder) {
                        break find_and_add;
                    }
                }
                r = new Record();
                r.binder = b;
                mRecords.add(r);
                if (DBG)
                    log("listen: add new record");
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onVoiceActivationStateChanged(mVoiceActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onDataActivationStateChanged(mDataActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CELLULAR_DATA_STATE) != 0) {
                    try {
                        r.callback.onCellularDataStateChanged(mCellularDataState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#method_after
private void listen(String callingPackage, IPhoneStateListener callback, int events, boolean notifyNow, int subId) {
    int callerUserId = UserHandle.getCallingUserId();
    if (VDBG) {
        log("listen: E pkg=" + callingPackage + " events=0x" + Integer.toHexString(events) + " notifyNow=" + notifyNow + " subId=" + subId + " myUserId=" + UserHandle.myUserId() + " callerUserId=" + callerUserId);
    }
    if (events != PhoneStateListener.LISTEN_NONE) {
        /* Checks permission and throws Security exception */
        checkListenerPermission(events);
        if ((events & ENFORCE_PHONE_STATE_PERMISSION_MASK) != 0) {
            try {
                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE, null);
            // SKIP checking for run-time permission since caller or self has PRIVILEGED
            // permission
            } catch (SecurityException e) {
                if (mAppOps.noteOp(AppOpsManager.OP_READ_PHONE_STATE, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
                    return;
                }
            }
        }
        synchronized (mRecords) {
            // register
            Record r;
            find_and_add: {
                IBinder b = callback.asBinder();
                final int N = mRecords.size();
                for (int i = 0; i < N; i++) {
                    r = mRecords.get(i);
                    if (b == r.binder) {
                        break find_and_add;
                    }
                }
                r = new Record();
                r.binder = b;
                mRecords.add(r);
                if (DBG)
                    log("listen: add new record");
            }
            r.callback = callback;
            r.callingPackage = callingPackage;
            r.callerUserId = callerUserId;
            boolean isPhoneStateEvent = (events & (CHECK_PHONE_STATE_PERMISSION_MASK | ENFORCE_PHONE_STATE_PERMISSION_MASK)) != 0;
            r.canReadPhoneState = isPhoneStateEvent && canReadPhoneState(callingPackage);
            // force all illegal subId to SubscriptionManager.DEFAULT_SUB_ID
            if (!SubscriptionManager.isValidSubscriptionId(subId)) {
                r.subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
            } else {
                // APP specify subID
                r.subId = subId;
            }
            r.phoneId = SubscriptionManager.getPhoneId(r.subId);
            int phoneId = r.phoneId;
            r.events = events;
            if (DBG) {
                log("listen:  Register r=" + r + " r.subId=" + r.subId + " phoneId=" + phoneId);
            }
            if (notifyNow && validatePhoneId(phoneId)) {
                if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                    try {
                        if (VDBG)
                            log("listen: call onSSC state=" + mServiceState[phoneId]);
                        r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
                    try {
                        int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
                        r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
                    try {
                        r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
                    try {
                        r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellLocation = " + mCellLocation[phoneId]);
                        r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
                    try {
                        r.callback.onCallStateChanged(mCallState[phoneId], getCallIncomingNumber(r, phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
                    try {
                        r.callback.onDataActivity(mDataActivity[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
                    try {
                        r.callback.onSignalStrengthsChanged(mSignalStrength[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
                    try {
                        r.callback.onOtaspChanged(mOtaspMode);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
                    try {
                        if (DBG_LOC)
                            log("listen: mCellInfo[" + phoneId + "] = " + mCellInfo.get(phoneId));
                        r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_CALL_STATE) != 0) {
                    try {
                        r.callback.onPreciseCallStateChanged(mPreciseCallState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE) != 0) {
                    try {
                        r.callback.onPreciseDataConnectionStateChanged(mPreciseDataConnectionState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_CARRIER_NETWORK_CHANGE) != 0) {
                    try {
                        r.callback.onCarrierNetworkChange(mCarrierNetworkChangeState);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onVoiceActivationStateChanged(mVoiceActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_DATA_ACTIVATION_STATE) != 0) {
                    try {
                        r.callback.onDataActivationStateChanged(mDataActivationState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
                if ((events & PhoneStateListener.LISTEN_USER_MOBILE_DATA_STATE) != 0) {
                    try {
                        r.callback.onUserMobileDataStateChanged(mUserMobileDataState[phoneId]);
                    } catch (RemoteException ex) {
                        remove(r.binder);
                    }
                }
            }
        }
    } else {
        if (DBG)
            log("listen: Unregister");
        remove(callback.asBinder());
    }
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        pw.println("last known state:");
        pw.increaseIndent();
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            pw.println("Phone Id=" + i);
            pw.increaseIndent();
            pw.println("mCallState=" + mCallState[i]);
            pw.println("mCallIncomingNumber=" + mCallIncomingNumber[i]);
            pw.println("mServiceState=" + mServiceState[i]);
            pw.println("mVoiceActivationState= " + mVoiceActivationState[i]);
            pw.println("mDataActivationState= " + mDataActivationState[i]);
            pw.println("mCellularDataState= " + mCellularDataState[i]);
            pw.println("mSignalStrength=" + mSignalStrength[i]);
            pw.println("mMessageWaiting=" + mMessageWaiting[i]);
            pw.println("mCallForwarding=" + mCallForwarding[i]);
            pw.println("mDataActivity=" + mDataActivity[i]);
            pw.println("mDataConnectionState=" + mDataConnectionState[i]);
            pw.println("mDataConnectionLinkProperties=" + mDataConnectionLinkProperties[i]);
            pw.println("mDataConnectionNetworkCapabilities=" + mDataConnectionNetworkCapabilities[i]);
            pw.println("mCellLocation=" + mCellLocation[i]);
            pw.println("mCellInfo=" + mCellInfo.get(i));
            pw.decreaseIndent();
        }
        pw.println("mConnectedApns=" + Arrays.toString(mConnectedApns));
        pw.println("mPreciseDataConnectionState=" + mPreciseDataConnectionState);
        pw.println("mPreciseCallState=" + mPreciseCallState);
        pw.println("mCarrierNetworkChangeState=" + mCarrierNetworkChangeState);
        pw.println("mRingingCallState=" + mRingingCallState);
        pw.println("mForegroundCallState=" + mForegroundCallState);
        pw.println("mBackgroundCallState=" + mBackgroundCallState);
        pw.println("mVoLteServiceState=" + mVoLteServiceState);
        pw.decreaseIndent();
        pw.println("local logs:");
        pw.increaseIndent();
        mLocalLog.dump(fd, pw, args);
        pw.decreaseIndent();
        pw.println("registrations: count=" + recordCount);
        pw.increaseIndent();
        for (Record r : mRecords) {
            pw.println(r);
        }
        pw.decreaseIndent();
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    synchronized (mRecords) {
        final int recordCount = mRecords.size();
        pw.println("last known state:");
        pw.increaseIndent();
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            pw.println("Phone Id=" + i);
            pw.increaseIndent();
            pw.println("mCallState=" + mCallState[i]);
            pw.println("mCallIncomingNumber=" + mCallIncomingNumber[i]);
            pw.println("mServiceState=" + mServiceState[i]);
            pw.println("mVoiceActivationState= " + mVoiceActivationState[i]);
            pw.println("mDataActivationState= " + mDataActivationState[i]);
            pw.println("mUserMobileDataState= " + mUserMobileDataState[i]);
            pw.println("mSignalStrength=" + mSignalStrength[i]);
            pw.println("mMessageWaiting=" + mMessageWaiting[i]);
            pw.println("mCallForwarding=" + mCallForwarding[i]);
            pw.println("mDataActivity=" + mDataActivity[i]);
            pw.println("mDataConnectionState=" + mDataConnectionState[i]);
            pw.println("mDataConnectionLinkProperties=" + mDataConnectionLinkProperties[i]);
            pw.println("mDataConnectionNetworkCapabilities=" + mDataConnectionNetworkCapabilities[i]);
            pw.println("mCellLocation=" + mCellLocation[i]);
            pw.println("mCellInfo=" + mCellInfo.get(i));
            pw.decreaseIndent();
        }
        pw.println("mConnectedApns=" + Arrays.toString(mConnectedApns));
        pw.println("mPreciseDataConnectionState=" + mPreciseDataConnectionState);
        pw.println("mPreciseCallState=" + mPreciseCallState);
        pw.println("mCarrierNetworkChangeState=" + mCarrierNetworkChangeState);
        pw.println("mRingingCallState=" + mRingingCallState);
        pw.println("mForegroundCallState=" + mForegroundCallState);
        pw.println("mBackgroundCallState=" + mBackgroundCallState);
        pw.println("mVoLteServiceState=" + mVoLteServiceState);
        pw.decreaseIndent();
        pw.println("local logs:");
        pw.increaseIndent();
        mLocalLog.dump(fd, pw, args);
        pw.decreaseIndent();
        pw.println("registrations: count=" + recordCount);
        pw.increaseIndent();
        for (Record r : mRecords) {
            pw.println(r);
        }
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private void checkPossibleMissNotify(Record r, int phoneId) {
    int events = r.events;
    if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
        try {
            if (VDBG)
                log("checkPossibleMissNotify: onServiceStateChanged state=" + mServiceState[phoneId]);
            r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
        try {
            SignalStrength signalStrength = mSignalStrength[phoneId];
            if (DBG) {
                log("checkPossibleMissNotify: onSignalStrengthsChanged SS=" + signalStrength);
            }
            r.callback.onSignalStrengthsChanged(new SignalStrength(signalStrength));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
        try {
            int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
            if (DBG) {
                log("checkPossibleMissNotify: onSignalStrengthChanged SS=" + gsmSignalStrength);
            }
            r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
        try {
            if (DBG_LOC) {
                log("checkPossibleMissNotify: onCellInfoChanged[" + phoneId + "] = " + mCellInfo.get(phoneId));
            }
            r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_CELLULAR_DATA_STATE) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onCellularDataStateChanged phoneId=" + phoneId + " cdi=" + mCellularDataState[phoneId]);
            }
            r.callback.onCellularDataStateChanged(mCellularDataState[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onMessageWaitingIndicatorChanged phoneId=" + phoneId + " mwi=" + mMessageWaiting[phoneId]);
            }
            r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onCallForwardingIndicatorChanged phoneId=" + phoneId + " cfi=" + mCallForwarding[phoneId]);
            }
            r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
        try {
            if (DBG_LOC)
                log("checkPossibleMissNotify: onCellLocationChanged mCellLocation = " + mCellLocation[phoneId]);
            r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
        try {
            if (DBG) {
                log("checkPossibleMissNotify: onDataConnectionStateChanged(mDataConnectionState" + "=" + mDataConnectionState[phoneId] + ", mDataConnectionNetworkType=" + mDataConnectionNetworkType[phoneId] + ")");
            }
            r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
}
#method_after
private void checkPossibleMissNotify(Record r, int phoneId) {
    int events = r.events;
    if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
        try {
            if (VDBG)
                log("checkPossibleMissNotify: onServiceStateChanged state=" + mServiceState[phoneId]);
            r.callback.onServiceStateChanged(new ServiceState(mServiceState[phoneId]));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
        try {
            SignalStrength signalStrength = mSignalStrength[phoneId];
            if (DBG) {
                log("checkPossibleMissNotify: onSignalStrengthsChanged SS=" + signalStrength);
            }
            r.callback.onSignalStrengthsChanged(new SignalStrength(signalStrength));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
        try {
            int gsmSignalStrength = mSignalStrength[phoneId].getGsmSignalStrength();
            if (DBG) {
                log("checkPossibleMissNotify: onSignalStrengthChanged SS=" + gsmSignalStrength);
            }
            r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1 : gsmSignalStrength));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_INFO)) {
        try {
            if (DBG_LOC) {
                log("checkPossibleMissNotify: onCellInfoChanged[" + phoneId + "] = " + mCellInfo.get(phoneId));
            }
            r.callback.onCellInfoChanged(mCellInfo.get(phoneId));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_USER_MOBILE_DATA_STATE) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onUserMobileDataStateChanged phoneId=" + phoneId + " umds=" + mUserMobileDataState[phoneId]);
            }
            r.callback.onUserMobileDataStateChanged(mUserMobileDataState[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onMessageWaitingIndicatorChanged phoneId=" + phoneId + " mwi=" + mMessageWaiting[phoneId]);
            }
            r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
        try {
            if (VDBG) {
                log("checkPossibleMissNotify: onCallForwardingIndicatorChanged phoneId=" + phoneId + " cfi=" + mCallForwarding[phoneId]);
            }
            r.callback.onCallForwardingIndicatorChanged(mCallForwarding[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if (validateEventsAndUserLocked(r, PhoneStateListener.LISTEN_CELL_LOCATION)) {
        try {
            if (DBG_LOC)
                log("checkPossibleMissNotify: onCellLocationChanged mCellLocation = " + mCellLocation[phoneId]);
            r.callback.onCellLocationChanged(new Bundle(mCellLocation[phoneId]));
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
    if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
        try {
            if (DBG) {
                log("checkPossibleMissNotify: onDataConnectionStateChanged(mDataConnectionState" + "=" + mDataConnectionState[phoneId] + ", mDataConnectionNetworkType=" + mDataConnectionNetworkType[phoneId] + ")");
            }
            r.callback.onDataConnectionStateChanged(mDataConnectionState[phoneId], mDataConnectionNetworkType[phoneId]);
        } catch (RemoteException ex) {
            mRemoveList.add(r.binder);
        }
    }
}
#end_block

#method_before
private void onSetUserDataEnabled(boolean enabled) {
    synchronized (mDataEnabledSettings) {
        if (mDataEnabledSettings.isUserDataEnabled() != enabled) {
            mDataEnabledSettings.setUserDataEnabled(enabled);
            // For single SIM phones, this is a per phone property.
            if (TelephonyManager.getDefault().getSimCount() == 1) {
                Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA, enabled ? 1 : 0);
            } else {
                int phoneSubId = mPhone.getSubId();
                Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId, enabled ? 1 : 0);
            }
            if (!getDataRoamingEnabled() && mPhone.getServiceState().getDataRoaming()) {
                if (enabled) {
                    notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
                } else {
                    notifyOffApnsOfAvailability(Phone.REASON_DATA_DISABLED);
                }
            }
            mPhone.notifyCellularDataStateChanged(enabled);
            // handle the rest from there.
            if (enabled) {
                reevaluateDataConnections();
                onTrySetupData(Phone.REASON_DATA_ENABLED);
            } else {
                onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
            }
        }
    }
}
#method_after
private void onSetUserDataEnabled(boolean enabled) {
    synchronized (mDataEnabledSettings) {
        if (mDataEnabledSettings.isUserDataEnabled() != enabled) {
            mDataEnabledSettings.setUserDataEnabled(enabled);
            if (!getDataRoamingEnabled() && mPhone.getServiceState().getDataRoaming()) {
                if (enabled) {
                    notifyOffApnsOfAvailability(Phone.REASON_ROAMING_ON);
                } else {
                    notifyOffApnsOfAvailability(Phone.REASON_DATA_DISABLED);
                }
            }
            mPhone.notifyUserMobileDataStateChanged(enabled);
            // handle the rest from there.
            if (enabled) {
                reevaluateDataConnections();
                onTrySetupData(Phone.REASON_DATA_ENABLED);
            } else {
                onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
            }
        }
    }
}
#end_block

#method_before
private void onDeviceProvisionedChange() {
    if (getDataEnabled()) {
        mDataEnabledSettings.setUserDataEnabled(true);
        reevaluateDataConnections();
        onTrySetupData(Phone.REASON_DATA_ENABLED);
    } else {
        mDataEnabledSettings.setUserDataEnabled(false);
        onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
    }
}
#method_after
private void onDeviceProvisionedChange() {
    if (isDataEnabled()) {
        reevaluateDataConnections();
        onTrySetupData(Phone.REASON_DATA_ENABLED);
    } else {
        onCleanUpAllConnections(Phone.REASON_DATA_SPECIFIC_DISABLED);
    }
}
#end_block

#method_before
/**
 * Return current {@link android.provider.Settings.Global#MOBILE_DATA} value.
 */
public boolean getDataEnabled() {
    final int device_provisioned = Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONED, 0);
    boolean retVal = "true".equalsIgnoreCase(SystemProperties.get("ro.com.android.mobiledata", "true"));
    if (TelephonyManager.getDefault().getSimCount() == 1) {
        retVal = Settings.Global.getInt(mResolver, Settings.Global.MOBILE_DATA, retVal ? 1 : 0) != 0;
    } else {
        int phoneSubId = mPhone.getSubId();
        try {
            retVal = TelephonyManager.getIntWithSubId(mResolver, Settings.Global.MOBILE_DATA, phoneSubId) != 0;
        } catch (SettingNotFoundException e) {
        // use existing retVal
        }
    }
    if (VDBG)
        log("getDataEnabled: retVal=" + retVal);
    if (device_provisioned == 0) {
        // device is still getting provisioned - use whatever setting they
        // want during this process
        // 
        // use the normal data_enabled setting (retVal, determined above)
        // as the default if nothing else is set
        final String prov_property = SystemProperties.get("ro.com.android.prov_mobiledata", retVal ? "true" : "false");
        retVal = "true".equalsIgnoreCase(prov_property);
        final int prov_mobile_data = Settings.Global.getInt(mResolver, Settings.Global.DEVICE_PROVISIONING_MOBILE_DATA_ENABLED, retVal ? 1 : 0);
        retVal = prov_mobile_data != 0;
        log("getDataEnabled during provisioning retVal=" + retVal + " - (" + prov_property + ", " + prov_mobile_data + ")");
    }
    return retVal;
}
#method_after
public boolean getDataEnabled() {
    if (mDataEnabledSettings.isProvisioning()) {
        return mDataEnabledSettings.isProvisioningDataEnabled();
    } else {
        return mDataEnabledSettings.isUserDataEnabled();
    }
}
#end_block

#method_before
public boolean getDataRoamingEnabled() {
    boolean isDataRoamingEnabled;
    final int phoneSubId = mPhone.getSubId();
    try {
        // For single SIM phones, this is a per phone property.
        if (TelephonyManager.getDefault().getSimCount() == 1) {
            isDataRoamingEnabled = Settings.Global.getInt(mResolver, Settings.Global.DATA_ROAMING, getDefaultDataRoamingEnabled() ? 1 : 0) != 0;
        } else {
            isDataRoamingEnabled = TelephonyManager.getIntWithSubId(mResolver, Settings.Global.DATA_ROAMING, phoneSubId) != 0;
        }
    } catch (SettingNotFoundException snfe) {
        if (DBG)
            log("getDataRoamingEnabled: SettingNofFoundException snfe=" + snfe);
        isDataRoamingEnabled = getDefaultDataRoamingEnabled();
    }
    if (VDBG) {
        log("getDataRoamingEnabled: phoneSubId=" + phoneSubId + " isDataRoamingEnabled=" + isDataRoamingEnabled);
    }
    return isDataRoamingEnabled;
}
#method_after
public boolean getDataRoamingEnabled() {
    boolean isDataRoamingEnabled;
    final int phoneSubId = mPhone.getSubId();
    // For single SIM phones, this is a per phone property.
    if (TelephonyManager.getDefault().getSimCount() == 1) {
        isDataRoamingEnabled = Settings.Global.getInt(mResolver, Settings.Global.DATA_ROAMING, getDefaultDataRoamingEnabled() ? 1 : 0) != 0;
    } else {
        isDataRoamingEnabled = Settings.Global.getInt(mResolver, Settings.Global.DATA_ROAMING + phoneSubId, getDefaultDataRoamingEnabled() ? 1 : 0) != 0;
    }
    if (VDBG) {
        log("getDataRoamingEnabled: phoneSubId=" + phoneSubId + " isDataRoamingEnabled=" + isDataRoamingEnabled);
    }
    return isDataRoamingEnabled;
}
#end_block

#method_before
public void update() {
    log("update sub = " + mPhone.getSubId());
    log("update(): Active DDS, register for all events now!");
    onUpdateIcc();
    mDataEnabledSettings.setUserDataEnabled(getDataEnabled());
    mAutoAttachOnCreation.set(false);
    ((GsmCdmaPhone) mPhone).updateCurrentCarrierInProvider();
}
#method_after
public void update() {
    log("update sub = " + mPhone.getSubId());
    log("update(): Active DDS, register for all events now!");
    onUpdateIcc();
    mAutoAttachOnCreation.set(false);
    ((GsmCdmaPhone) mPhone).updateCurrentCarrierInProvider();
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("DcTracker:");
    pw.println(" RADIO_TESTS=" + RADIO_TESTS);
    pw.println(" mDataEnabledSettings=" + mDataEnabledSettings);
    pw.println(" isDataAllowed=" + isDataAllowed(null));
    pw.flush();
    pw.println(" mRequestedApnType=" + mRequestedApnType);
    pw.println(" mPhone=" + mPhone.getPhoneName());
    pw.println(" mActivity=" + mActivity);
    pw.println(" mState=" + mState);
    pw.println(" mTxPkts=" + mTxPkts);
    pw.println(" mRxPkts=" + mRxPkts);
    pw.println(" mNetStatPollPeriod=" + mNetStatPollPeriod);
    pw.println(" mNetStatPollEnabled=" + mNetStatPollEnabled);
    pw.println(" mDataStallTxRxSum=" + mDataStallTxRxSum);
    pw.println(" mDataStallAlarmTag=" + mDataStallAlarmTag);
    pw.println(" mDataStallDetectionEnabled=" + mDataStallDetectionEnabled);
    pw.println(" mSentSinceLastRecv=" + mSentSinceLastRecv);
    pw.println(" mNoRecvPollCount=" + mNoRecvPollCount);
    pw.println(" mResolver=" + mResolver);
    pw.println(" mIsWifiConnected=" + mIsWifiConnected);
    pw.println(" mReconnectIntent=" + mReconnectIntent);
    pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation.get());
    pw.println(" mIsScreenOn=" + mIsScreenOn);
    pw.println(" mUniqueIdGenerator=" + mUniqueIdGenerator);
    pw.println(" mDataRoamingLeakageLog= ");
    mDataRoamingLeakageLog.dump(fd, pw, args);
    pw.flush();
    pw.println(" ***************************************");
    DcController dcc = mDcc;
    if (dcc != null) {
        dcc.dump(fd, pw, args);
    } else {
        pw.println(" mDcc=null");
    }
    pw.println(" ***************************************");
    HashMap<Integer, DataConnection> dcs = mDataConnections;
    if (dcs != null) {
        Set<Entry<Integer, DataConnection>> mDcSet = mDataConnections.entrySet();
        pw.println(" mDataConnections: count=" + mDcSet.size());
        for (Entry<Integer, DataConnection> entry : mDcSet) {
            pw.printf(" *** mDataConnection[%d] \n", entry.getKey());
            entry.getValue().dump(fd, pw, args);
        }
    } else {
        pw.println("mDataConnections=null");
    }
    pw.println(" ***************************************");
    pw.flush();
    HashMap<String, Integer> apnToDcId = mApnToDataConnectionId;
    if (apnToDcId != null) {
        Set<Entry<String, Integer>> apnToDcIdSet = apnToDcId.entrySet();
        pw.println(" mApnToDataConnectonId size=" + apnToDcIdSet.size());
        for (Entry<String, Integer> entry : apnToDcIdSet) {
            pw.printf(" mApnToDataConnectonId[%s]=%d\n", entry.getKey(), entry.getValue());
        }
    } else {
        pw.println("mApnToDataConnectionId=null");
    }
    pw.println(" ***************************************");
    pw.flush();
    ConcurrentHashMap<String, ApnContext> apnCtxs = mApnContexts;
    if (apnCtxs != null) {
        Set<Entry<String, ApnContext>> apnCtxsSet = apnCtxs.entrySet();
        pw.println(" mApnContexts size=" + apnCtxsSet.size());
        for (Entry<String, ApnContext> entry : apnCtxsSet) {
            entry.getValue().dump(fd, pw, args);
        }
        pw.println(" ***************************************");
    } else {
        pw.println(" mApnContexts=null");
    }
    pw.flush();
    ArrayList<ApnSetting> apnSettings = mAllApnSettings;
    if (apnSettings != null) {
        pw.println(" mAllApnSettings size=" + apnSettings.size());
        for (int i = 0; i < apnSettings.size(); i++) {
            pw.printf(" mAllApnSettings[%d]: %s\n", i, apnSettings.get(i));
        }
        pw.flush();
    } else {
        pw.println(" mAllApnSettings=null");
    }
    pw.println(" mPreferredApn=" + mPreferredApn);
    pw.println(" mIsPsRestricted=" + mIsPsRestricted);
    pw.println(" mIsDisposed=" + mIsDisposed);
    pw.println(" mIntentReceiver=" + mIntentReceiver);
    pw.println(" mReregisterOnReconnectFailure=" + mReregisterOnReconnectFailure);
    pw.println(" canSetPreferApn=" + mCanSetPreferApn);
    pw.println(" mApnObserver=" + mApnObserver);
    pw.println(" getOverallState=" + getOverallState());
    pw.println(" mDataConnectionAsyncChannels=%s\n" + mDataConnectionAcHashMap);
    pw.println(" mAttached=" + mAttached.get());
    pw.flush();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("DcTracker:");
    pw.println(" RADIO_TESTS=" + RADIO_TESTS);
    pw.println(" mDataEnabledSettings=" + mDataEnabledSettings);
    pw.println(" isDataAllowed=" + isDataAllowed(null));
    pw.flush();
    pw.println(" mRequestedApnType=" + mRequestedApnType);
    pw.println(" mPhone=" + mPhone.getPhoneName());
    pw.println(" mActivity=" + mActivity);
    pw.println(" mState=" + mState);
    pw.println(" mTxPkts=" + mTxPkts);
    pw.println(" mRxPkts=" + mRxPkts);
    pw.println(" mNetStatPollPeriod=" + mNetStatPollPeriod);
    pw.println(" mNetStatPollEnabled=" + mNetStatPollEnabled);
    pw.println(" mDataStallTxRxSum=" + mDataStallTxRxSum);
    pw.println(" mDataStallAlarmTag=" + mDataStallAlarmTag);
    pw.println(" mDataStallDetectionEnabled=" + mDataStallDetectionEnabled);
    pw.println(" mSentSinceLastRecv=" + mSentSinceLastRecv);
    pw.println(" mNoRecvPollCount=" + mNoRecvPollCount);
    pw.println(" mResolver=" + mResolver);
    pw.println(" mIsWifiConnected=" + mIsWifiConnected);
    pw.println(" mReconnectIntent=" + mReconnectIntent);
    pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation.get());
    pw.println(" mIsScreenOn=" + mIsScreenOn);
    pw.println(" mUniqueIdGenerator=" + mUniqueIdGenerator);
    pw.println(" mDataRoamingLeakageLog= ");
    mDataRoamingLeakageLog.dump(fd, pw, args);
    pw.flush();
    pw.println(" ***************************************");
    DcController dcc = mDcc;
    if (dcc != null) {
        dcc.dump(fd, pw, args);
    } else {
        pw.println(" mDcc=null");
    }
    pw.println(" ***************************************");
    HashMap<Integer, DataConnection> dcs = mDataConnections;
    if (dcs != null) {
        Set<Entry<Integer, DataConnection>> mDcSet = mDataConnections.entrySet();
        pw.println(" mDataConnections: count=" + mDcSet.size());
        for (Entry<Integer, DataConnection> entry : mDcSet) {
            pw.printf(" *** mDataConnection[%d] \n", entry.getKey());
            entry.getValue().dump(fd, pw, args);
        }
    } else {
        pw.println("mDataConnections=null");
    }
    pw.println(" ***************************************");
    pw.flush();
    HashMap<String, Integer> apnToDcId = mApnToDataConnectionId;
    if (apnToDcId != null) {
        Set<Entry<String, Integer>> apnToDcIdSet = apnToDcId.entrySet();
        pw.println(" mApnToDataConnectonId size=" + apnToDcIdSet.size());
        for (Entry<String, Integer> entry : apnToDcIdSet) {
            pw.printf(" mApnToDataConnectonId[%s]=%d\n", entry.getKey(), entry.getValue());
        }
    } else {
        pw.println("mApnToDataConnectionId=null");
    }
    pw.println(" ***************************************");
    pw.flush();
    ConcurrentHashMap<String, ApnContext> apnCtxs = mApnContexts;
    if (apnCtxs != null) {
        Set<Entry<String, ApnContext>> apnCtxsSet = apnCtxs.entrySet();
        pw.println(" mApnContexts size=" + apnCtxsSet.size());
        for (Entry<String, ApnContext> entry : apnCtxsSet) {
            entry.getValue().dump(fd, pw, args);
        }
        pw.println(" ***************************************");
    } else {
        pw.println(" mApnContexts=null");
    }
    pw.flush();
    ArrayList<ApnSetting> apnSettings = mAllApnSettings;
    if (apnSettings != null) {
        pw.println(" mAllApnSettings size=" + apnSettings.size());
        for (int i = 0; i < apnSettings.size(); i++) {
            pw.printf(" mAllApnSettings[%d]: %s\n", i, apnSettings.get(i));
        }
        pw.flush();
    } else {
        pw.println(" mAllApnSettings=null");
    }
    pw.println(" mPreferredApn=" + mPreferredApn);
    pw.println(" mIsPsRestricted=" + mIsPsRestricted);
    pw.println(" mIsDisposed=" + mIsDisposed);
    pw.println(" mIntentReceiver=" + mIntentReceiver);
    pw.println(" mReregisterOnReconnectFailure=" + mReregisterOnReconnectFailure);
    pw.println(" canSetPreferApn=" + mCanSetPreferApn);
    pw.println(" mApnObserver=" + mApnObserver);
    pw.println(" getOverallState=" + getOverallState());
    pw.println(" mDataConnectionAsyncChannels=%s\n" + mDataConnectionAcHashMap);
    pw.println(" mAttached=" + mAttached.get());
    mDataEnabledSettings.dump(fd, pw, args);
    pw.flush();
}
#end_block

#method_before
public void testModifiers001() {
    String thisTestName = "testModifiers001";
    logWriter.println("==> " + thisTestName + " for " + thisCommandName + ": START...");
    String failMessage = "";
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    long refTypeID = getClassIDBySignature(debuggeeSignature);
    logWriter.println("=> Debuggee class = " + getDebuggeeClassName());
    logWriter.println("=> referenceTypeID for Debuggee class = " + refTypeID);
    logWriter.println("=> CHECK1: send " + thisCommandName + " and check reply...");
    CommandPacket modifiersCommand = new CommandPacket(JDWPCommands.ReferenceTypeCommandSet.CommandSetID, JDWPCommands.ReferenceTypeCommandSet.ModifiersCommand);
    modifiersCommand.setNextValueAsReferenceTypeID(refTypeID);
    ReplyPacket modifiersReply = debuggeeWrapper.vmMirror.performCommand(modifiersCommand);
    modifiersCommand = null;
    checkReplyPacket(modifiersReply, thisCommandName);
    int returnedModifiers = modifiersReply.getNextValueAsInt();
    /*
 * The value of the access_flags item is a mask of modifiers used with class and
 * interface declarations. The access_flags modifiers are:
 * Flag Name      Value   Meaning                                               Used By
 * ACC_PUBLIC     0x0001  Is public; may be accessed from outside its package.  Class, interface
 * ACC_FINAL      0x0010  Is final; no subclasses allowed.                      Class
 * ACC_SUPER      0x0020  Treat superclass methods specially in invokespecial.  Class, interface
 * ACC_INTERFACE  0x0200  Is an interface.                                      Interface
 * ACC_ABSTRACT   0x0400  Is abstract; may not be instantiated.                 Class, interface
 */
    logWriter.println("=> Returned modifiers = 0x" + Integer.toHexString(returnedModifiers));
    // expected
    int publicFlag = 0x0001;
    // unexpected
    int finalFlag = 0x0010;
    // (do not care)
    int superFlag = 0x0020;
    // unexpected
    int interfaceFlag = 0x0200;
    // unexpected
    int abstractFlag = 0x0400;
    if ((returnedModifiers & publicFlag) == 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers do NOT contain expected ACC_PUBLIC flag(0x0001)");
        failMessage = failMessage + "Returned modifiers do NOT contain expected ACC_PUBLIC flag(0x0001);\n";
    }
    if ((returnedModifiers & finalFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_FINAL flag(0x0010)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_FINAL flag(0x0010);\n";
    }
    if ((returnedModifiers & interfaceFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_INTERFACE flag(0x0200)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_INTERFACE flag(0x0200);\n";
    }
    if ((returnedModifiers & abstractFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_ABSTRACT flag(0x0400)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_ABSTRACT flag(0x0400);\n";
    }
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("==> " + thisTestName + " for " + thisCommandName + ": FINISH");
    if (failMessage.length() > 0) {
        fail(failMessage);
    } else {
        logWriter.println("=> CHECK1: PASSED: expected modifiers are returned: ACC_PUBLIC flag(0x0001), ACC_SUPER flag(0x0020)");
    }
    assertAllDataRead(modifiersReply);
}
#method_after
public void testModifiers001() {
    String thisTestName = "testModifiers001";
    logWriter.println("==> " + thisTestName + " for " + thisCommandName + ": START...");
    String failMessage = "";
    synchronizer.receiveMessage(JPDADebuggeeSynchronizer.SGNL_READY);
    long refTypeID = getClassIDBySignature(debuggeeSignature);
    logWriter.println("=> Debuggee class = " + getDebuggeeClassName());
    logWriter.println("=> referenceTypeID for Debuggee class = " + refTypeID);
    logWriter.println("=> CHECK1: send " + thisCommandName + " and check reply...");
    CommandPacket modifiersCommand = new CommandPacket(JDWPCommands.ReferenceTypeCommandSet.CommandSetID, JDWPCommands.ReferenceTypeCommandSet.ModifiersCommand);
    modifiersCommand.setNextValueAsReferenceTypeID(refTypeID);
    ReplyPacket modifiersReply = debuggeeWrapper.vmMirror.performCommand(modifiersCommand);
    modifiersCommand = null;
    checkReplyPacket(modifiersReply, thisCommandName);
    int returnedModifiers = modifiersReply.getNextValueAsInt();
    /*
 * The value of the access_flags item is a mask of modifiers used with class and
 * interface declarations. The access_flags modifiers are:
 * Flag Name      Value   Meaning                                               Used By
 * ACC_PUBLIC     0x0001  Is public; may be accessed from outside its package.  Class, interface
 * ACC_FINAL      0x0010  Is final; no subclasses allowed.                      Class
 * ACC_SUPER      0x0020  Treat superclass methods specially in invokespecial.  Class, interface
 * ACC_INTERFACE  0x0200  Is an interface.                                      Interface
 * ACC_ABSTRACT   0x0400  Is abstract; may not be instantiated.                 Class, interface
 */
    logWriter.println("=> Returned modifiers = 0x" + Integer.toHexString(returnedModifiers));
    // expected
    int publicFlag = 0x0001;
    // unexpected
    int finalFlag = 0x0010;
    // int superFlag = 0x0020; // (do not care)
    // unexpected
    int interfaceFlag = 0x0200;
    // unexpected
    int abstractFlag = 0x0400;
    if ((returnedModifiers & publicFlag) == 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers do NOT contain expected ACC_PUBLIC flag(0x0001)");
        failMessage = failMessage + "Returned modifiers do NOT contain expected ACC_PUBLIC flag(0x0001);\n";
    }
    if ((returnedModifiers & finalFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_FINAL flag(0x0010)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_FINAL flag(0x0010);\n";
    }
    if ((returnedModifiers & interfaceFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_INTERFACE flag(0x0200)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_INTERFACE flag(0x0200);\n";
    }
    if ((returnedModifiers & abstractFlag) != 0) {
        logWriter.println("## CHECK1: FAILURE: Returned modifiers contain unexpected ACC_ABSTRACT flag(0x0400)");
        failMessage = failMessage + "Returned modifiers contain unexpected ACC_ABSTRACT flag(0x0400);\n";
    }
    synchronizer.sendMessage(JPDADebuggeeSynchronizer.SGNL_CONTINUE);
    logWriter.println("==> " + thisTestName + " for " + thisCommandName + ": FINISH");
    if (failMessage.length() > 0) {
        fail(failMessage);
    } else {
        logWriter.println("=> CHECK1: PASSED: expected modifiers are returned: ACC_PUBLIC flag(0x0001), ACC_SUPER flag(0x0020)");
    }
    assertAllDataRead(modifiersReply);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    mContext = getInstrumentation().getTargetContext();
    mOldVrListener = Settings.Secure.getString(mContext.getContentResolver(), ENABLED_VR_LISTENERS);
    mIsVrHeadset = "1".equals(SystemProperties.get(VR_STANDALONE_PROPERTY, "0")) ? true : false;
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    mContext = getInstrumentation().getTargetContext();
    mOldVrListener = Settings.Secure.getString(mContext.getContentResolver(), ENABLED_VR_LISTENERS);
    String result = SystemUtil.runShellCommand(getInstrumentation(), DUMP_VRMANAGER);
    mDumpLines.clear();
    Collections.addAll(mDumpLines, result.split("\\n"));
    if ("enabled".equals(parseVrManagerDumpsys(mDumpLines))) {
        mPersistentVrModeEnabled = true;
    }
}
#end_block

#method_before
public void testSetVrThreadAPISuccess() throws Throwable {
    // This API is not meant for persistent vr mode which is default on a vr headset.
    if (mIsVrHeadset) {
        return;
    }
    setIntent(1, 1, 0, 0);
    ComponentName requestedComponent = new ComponentName(mContext, MockVrListenerService.class);
    Settings.Secure.putString(mContext.getContentResolver(), ENABLED_VR_LISTENERS, requestedComponent.flattenToString());
    mActivity = getActivity();
    assertTrue(mActivity.waitForFrameDrawn());
    if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {
        int vr_thread = 0, policy = 0;
        mActivity.setVrModeEnabled(true, requestedComponent);
        vr_thread = Process.myTid();
        mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
        mActivityManager.setVrThread(vr_thread);
        policy = (int) Process.getThreadScheduler(vr_thread);
        Log.e(TAG, "scheduling policy: " + policy);
        assertEquals((SCHED_FIFO | SCHED_RESET_ON_FORK), policy);
    }
}
#method_after
public void testSetVrThreadAPISuccess() throws Throwable {
    // This API is not meant for persistent vr mode.
    if (mPersistentVrModeEnabled) {
        return;
    }
    setIntent(1, 1, 0, 0);
    ComponentName requestedComponent = new ComponentName(mContext, MockVrListenerService.class);
    Settings.Secure.putString(mContext.getContentResolver(), ENABLED_VR_LISTENERS, requestedComponent.flattenToString());
    mActivity = getActivity();
    assertTrue(mActivity.waitForFrameDrawn());
    if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {
        int vr_thread = 0, policy = 0;
        mActivity.setVrModeEnabled(true, requestedComponent);
        vr_thread = Process.myTid();
        mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
        mActivityManager.setVrThread(vr_thread);
        policy = (int) Process.getThreadScheduler(vr_thread);
        Log.e(TAG, "scheduling policy: " + policy);
        assertEquals((SCHED_FIFO | SCHED_RESET_ON_FORK), policy);
    }
}
#end_block

#method_before
public void testSetVrThreadAPIFailure() throws Throwable {
    // This API is not meant for persistent vr mode which is default on a vr headset.
    if (mIsVrHeadset) {
        return;
    }
    setIntent(1, 1, 0, 0);
    ComponentName requestedComponent = new ComponentName(mContext, MockVrListenerService.class);
    Settings.Secure.putString(mContext.getContentResolver(), ENABLED_VR_LISTENERS, requestedComponent.flattenToString());
    mActivity = getActivity();
    assertTrue(mActivity.waitForFrameDrawn());
    if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {
        int vr_thread = 0, policy = 0;
        mActivity.setVrModeEnabled(false, requestedComponent);
        vr_thread = Process.myTid();
        mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
        mActivityManager.setVrThread(vr_thread);
        policy = (int) Process.getThreadScheduler(vr_thread);
        Log.e(TAG, "scheduling policy: " + policy);
        assertEquals(SCHED_OTHER, policy);
    }
}
#method_after
public void testSetVrThreadAPIFailure() throws Throwable {
    // This API is not meant for persistent vr mode.
    if (mPersistentVrModeEnabled) {
        return;
    }
    setIntent(1, 1, 0, 0);
    ComponentName requestedComponent = new ComponentName(mContext, MockVrListenerService.class);
    Settings.Secure.putString(mContext.getContentResolver(), ENABLED_VR_LISTENERS, requestedComponent.flattenToString());
    mActivity = getActivity();
    assertTrue(mActivity.waitForFrameDrawn());
    if (mActivity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE)) {
        int vr_thread = 0, policy = 0;
        mActivity.setVrModeEnabled(false, requestedComponent);
        vr_thread = Process.myTid();
        mActivityManager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
        mActivityManager.setVrThread(vr_thread);
        policy = (int) Process.getThreadScheduler(vr_thread);
        Log.e(TAG, "scheduling policy: " + policy);
        assertEquals(SCHED_OTHER, policy);
    }
}
#end_block

#method_before
static String byteBufferToString(ByteBuffer buf, int start, int len) {
    int oldPosition = buf.position();
    buf.position(start);
    // {}
    int strlen = 2;
    boolean ellipsis = len < buf.limit();
    if (ellipsis) {
        // ...
        strlen += 3;
    } else {
        len = buf.limit();
    }
    // XX,XX
    strlen += 3 * len - (len > 0 ? 1 : 0);
    char[] res = new char[strlen];
    res[0] = '{';
    res[strlen - 1] = '}';
    if (ellipsis) {
        res[strlen - 2] = res[strlen - 3] = res[strlen - 4] = '.';
    }
    for (int i = 1; i < len; i++) {
        res[i * 3] = ',';
    }
    for (int i = 0; i < len; i++) {
        byte b = buf.get();
        int d = (b >> 4) & 15;
        res[i * 3 + 1] = (char) (d + (d > 9 ? 'a' - 10 : '0'));
        d = (b & 15);
        res[i * 3 + 2] = (char) (d + (d > 9 ? 'a' - 10 : '0'));
    }
    buf.position(oldPosition);
    return new String(res);
}
#method_after
/* ====================================================================== */
/*                              UTILITY FUNCTIONS                         */
static String byteBufferToString(ByteBuffer buf, int start, int len) {
    int oldPosition = buf.position();
    buf.position(start);
    // {}
    int strlen = 2;
    boolean ellipsis = len < buf.limit();
    if (ellipsis) {
        // ...
        strlen += 3;
    } else {
        len = buf.limit();
    }
    // XX,XX
    strlen += 3 * len - (len > 0 ? 1 : 0);
    char[] res = new char[strlen];
    res[0] = '{';
    res[strlen - 1] = '}';
    if (ellipsis) {
        res[strlen - 2] = res[strlen - 3] = res[strlen - 4] = '.';
    }
    for (int i = 1; i < len; i++) {
        res[i * 3] = ',';
    }
    for (int i = 0; i < len; i++) {
        byte b = buf.get();
        int d = (b >> 4) & 15;
        res[i * 3 + 1] = (char) (d + (d > 9 ? 'a' - 10 : '0'));
        d = (b & 15);
        res[i * 3 + 2] = (char) (d + (d > 9 ? 'a' - 10 : '0'));
    }
    buf.position(oldPosition);
    return new String(res);
}
#end_block

#method_before
public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
    final long NSECS_IN_1SEC = 1000000000;
    if (!mRenderedTimeStamps.remove(presentationTimeUs)) {
        warn("invalid timestamp " + presentationTimeUs + ", queued " + collectionString(mRenderedTimeStamps));
    }
    assert nanoTime > mLastRenderNanoTime;
    mLastRenderNanoTime = nanoTime;
    ++mFramesNotifiedRendered;
    assert nanoTime > System.nanoTime() - NSECS_IN_1SEC;
}
#method_after
public void onFrameRendered(MediaCodec codec, long presentationTimeUs, long nanoTime) {
    final long NSECS_IN_1SEC = 1000000000;
    if (!mRenderedTimeStamps.remove(presentationTimeUs)) {
        warn("invalid timestamp " + presentationTimeUs + ", queued " + mRenderedTimeStamps);
    }
    assert nanoTime > mLastRenderNanoTime;
    mLastRenderNanoTime = nanoTime;
    ++mFramesNotifiedRendered;
    assert nanoTime > System.nanoTime() - NSECS_IN_1SEC;
}
#end_block

#method_before
public String dequeueAndReleaseOutputBuffer(MediaCodec.BufferInfo info) {
    int ix = mCodec.dequeueOutputBuffer(info, kTimeOutUs);
    if (ix == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
        mOutputBuffers = mCodec.getOutputBuffers();
        Log.d(TAG, "output buffers have changed.");
        return null;
    } else if (ix == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
        MediaFormat format = mCodec.getOutputFormat();
        Log.d(TAG, "output format has changed to " + format);
        int colorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT);
        mDoChecksum = isRecognizedFormat(colorFormat);
        return null;
    } else if (ix < 0) {
        Log.v(TAG, "no output");
        return null;
    }
    /* create checksum */
    long sum = 0;
    Log.v(TAG, "dequeue #" + ix + " => { [" + info.size + "] flags=" + info.flags + " @" + info.presentationTimeUs + "}");
    // we get a nonzero size for valid decoded frames
    boolean doRender = (info.size != 0);
    if (mSurface.getSurface() == null) {
        if (mDoChecksum) {
            sum = checksum(mOutputBuffers[ix], info.size, mCRC);
        }
        mCodec.releaseOutputBuffer(ix, doRender);
    } else if (doRender) {
        // If using SurfaceTexture, as soon as we call releaseOutputBuffer, the
        // buffer will be forwarded to SurfaceTexture to convert to a texture.
        // The API doesn't guarantee that the texture will be available before
        // the call returns, so we need to wait for the onFrameAvailable callback
        // to fire.  If we don't wait, we risk dropping frames.
        mSurface.prepare();
        mCodec.releaseOutputBuffer(ix, doRender);
        mSurface.waitForDraw();
        if (mDoChecksum) {
            sum = mSurface.checksum();
        }
    } else {
        mCodec.releaseOutputBuffer(ix, doRender);
    }
    if (doRender) {
        mRenderedTimeStamps.add(info.presentationTimeUs);
        if (!mTimeStamps.remove(info.presentationTimeUs)) {
            warn("invalid timestamp " + info.presentationTimeUs + ", queued " + collectionString(mTimeStamps));
        }
    }
    return String.format(Locale.US, "{pts=%d, flags=%x, data=0x%x}", info.presentationTimeUs, info.flags, sum);
}
#method_after
public String dequeueAndReleaseOutputBuffer(MediaCodec.BufferInfo info) {
    int ix = mCodec.dequeueOutputBuffer(info, kTimeOutUs);
    if (ix == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
        mOutputBuffers = mCodec.getOutputBuffers();
        Log.d(TAG, "output buffers have changed.");
        return null;
    } else if (ix == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
        MediaFormat format = mCodec.getOutputFormat();
        Log.d(TAG, "output format has changed to " + format);
        int colorFormat = format.getInteger(MediaFormat.KEY_COLOR_FORMAT);
        mDoChecksum = isRecognizedFormat(colorFormat);
        return null;
    } else if (ix < 0) {
        Log.v(TAG, "no output");
        return null;
    }
    /* create checksum */
    long sum = 0;
    Log.v(TAG, "dequeue #" + ix + " => { [" + info.size + "] flags=" + info.flags + " @" + info.presentationTimeUs + "}");
    // we get a nonzero size for valid decoded frames
    boolean doRender = (info.size != 0);
    if (mSurface.getSurface() == null) {
        if (mDoChecksum) {
            sum = checksum(mOutputBuffers[ix], info.size, mCRC);
        }
        mCodec.releaseOutputBuffer(ix, doRender);
    } else if (doRender) {
        // If using SurfaceTexture, as soon as we call releaseOutputBuffer, the
        // buffer will be forwarded to SurfaceTexture to convert to a texture.
        // The API doesn't guarantee that the texture will be available before
        // the call returns, so we need to wait for the onFrameAvailable callback
        // to fire.  If we don't wait, we risk dropping frames.
        mSurface.prepare();
        mCodec.releaseOutputBuffer(ix, doRender);
        mSurface.waitForDraw();
        if (mDoChecksum) {
            sum = mSurface.checksum();
        }
    } else {
        mCodec.releaseOutputBuffer(ix, doRender);
    }
    if (doRender) {
        mRenderedTimeStamps.add(info.presentationTimeUs);
        if (!mTimeStamps.remove(info.presentationTimeUs)) {
            warn("invalid timestamp " + info.presentationTimeUs + ", queued " + mTimeStamps);
        }
    }
    return String.format(Locale.US, "{pts=%d, flags=%x, data=0x%x}", info.presentationTimeUs, info.flags, sum);
}
#end_block

#method_before
private void loadFromDisk() {
    synchronized (mLock) {
        if (mLoaded) {
            return;
        }
        if (mBackupFile.exists()) {
            mFile.delete();
            mBackupFile.renameTo(mFile);
        }
    }
    // Debugging
    if (mFile.exists() && !mFile.canRead()) {
        Log.w(TAG, "Attempt to read preferences file " + mFile + " without permission");
    }
    Map<String, Object> map = null;
    StructStat stat = null;
    Throwable thrown = null;
    try {
        try {
            stat = Os.stat(mFile.getPath());
            if (mFile.canRead()) {
                BufferedInputStream str = null;
                try {
                    str = new BufferedInputStream(new FileInputStream(mFile), 16 * 1024);
                    map = (Map<String, Object>) XmlUtils.readMapXml(str);
                } catch (Exception e) {
                    Log.w(TAG, "Cannot read " + mFile.getAbsolutePath(), e);
                } finally {
                    IoUtils.closeQuietly(str);
                }
            }
        } catch (ErrnoException e) {
        /* ignore */
        }
    } catch (Throwable t) {
        thrown = t;
    } finally {
        synchronized (mLock) {
            mLoaded = true;
            mThrowable = thrown;
            if (thrown == null) {
                if (map != null) {
                    mMap = map;
                    mStatTimestamp = stat.st_mtim;
                    mStatSize = stat.st_size;
                } else {
                    mMap = new HashMap<>();
                }
            }
            mLock.notifyAll();
        }
    }
}
#method_after
private void loadFromDisk() {
    synchronized (mLock) {
        if (mLoaded) {
            return;
        }
        if (mBackupFile.exists()) {
            mFile.delete();
            mBackupFile.renameTo(mFile);
        }
    }
    // Debugging
    if (mFile.exists() && !mFile.canRead()) {
        Log.w(TAG, "Attempt to read preferences file " + mFile + " without permission");
    }
    Map<String, Object> map = null;
    StructStat stat = null;
    Throwable thrown = null;
    try {
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) {
            BufferedInputStream str = null;
            try {
                str = new BufferedInputStream(new FileInputStream(mFile), 16 * 1024);
                map = (Map<String, Object>) XmlUtils.readMapXml(str);
            } catch (Exception e) {
                Log.w(TAG, "Cannot read " + mFile.getAbsolutePath(), e);
            } finally {
                IoUtils.closeQuietly(str);
            }
        }
    } catch (ErrnoException e) {
    // An errno exception means the stat failed. Treat as empty/non-existing by
    // ignoring.
    } catch (Throwable t) {
        thrown = t;
    }
    synchronized (mLock) {
        mLoaded = true;
        mThrowable = thrown;
        // better safe than sorry.
        try {
            if (thrown == null) {
                if (map != null) {
                    mMap = map;
                    mStatTimestamp = stat.st_mtim;
                    mStatSize = stat.st_size;
                } else {
                    mMap = new HashMap<>();
                }
            }
        // In case of a thrown exception, we retain the old map. That allows
        // any open editors to commit and store updates.
        } catch (Throwable t) {
            mThrowable = t;
        } finally {
            mLock.notifyAll();
        }
    }
}
#end_block

#method_before
// Interrupts the live scan and caches nsri in mPendingRequestInfo. Once the live scan is
// stopped, a new scan will automatically start with nsri.
// The new scan can interrupt the live scan only when all the below requirements are met:
// 1. There is 1 live scan and no other pending scan
// 2. The new scan is requested by system process
private synchronized boolean interruptLiveScan(NetworkScanRequestInfo nsri) {
    if (mLiveRequestInfo != null && mPendingRequestInfo == null && nsri.mUid == Process.PHONE_UID && mLiveRequestInfo.mUid != Process.PHONE_UID) {
        doInterruptScan(mLiveRequestInfo.mScanId);
        mPendingRequestInfo = nsri;
        notifyMessenger(mLiveRequestInfo, TelephonyScanManager.CALLBACK_SCAN_ERROR, NetworkScan.ERROR_INTERRUPTED, null);
        return true;
    }
    return false;
}
#method_after
// Interrupts the live scan and caches nsri in mPendingRequestInfo. Once the live scan is
// stopped, a new scan will automatically start with nsri.
// The new scan can interrupt the live scan only when all the below requirements are met:
// 1. There is 1 live scan and no other pending scan
// 2. The new scan is requested by mobile network setting menu (owned by PHONE process)
private synchronized boolean interruptLiveScan(NetworkScanRequestInfo nsri) {
    if (mLiveRequestInfo != null && mPendingRequestInfo == null && nsri.mUid == Process.PHONE_UID && mLiveRequestInfo.mUid != Process.PHONE_UID) {
        doInterruptScan(mLiveRequestInfo.mScanId);
        mPendingRequestInfo = nsri;
        notifyMessenger(mLiveRequestInfo, TelephonyScanManager.CALLBACK_SCAN_ERROR, NetworkScan.ERROR_INTERRUPTED, null);
        return true;
    }
    return false;
}
#end_block

