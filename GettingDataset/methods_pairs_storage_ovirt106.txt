911
#method_before
private void freezeVm() {
    if (!isLiveSnapshotApplicable() || !isCinderDisksExist()) {
        return;
    }
    VDSReturnValue returnValue;
    try {
        returnValue = runVdsCommand(VDSCommandType.Freeze, new VdsAndVmIDVDSParametersBase(getVds().getId(), getVmId()));
    } catch (EngineException e) {
        handleFreezeVmFailure(e);
        return;
    }
    if (!returnValue.getSucceeded()) {
        handleFreezeVmFailure(new EngineException(EngineError.freezeErr));
    }
}
#method_after
private void freezeVm() {
    if (!shouldFreezeOrThawVm()) {
        return;
    }
    VDSReturnValue returnValue;
    try {
        auditLogDirector.log(this, AuditLogType.FREEZE_VM_INITIATED);
        returnValue = runVdsCommand(VDSCommandType.Freeze, new VdsAndVmIDVDSParametersBase(getVds().getId(), getVmId()));
    } catch (EngineException e) {
        handleFreezeVmFailure(e);
        return;
    }
    if (returnValue.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.FREEZE_VM_SUCCESS);
    } else {
        handleFreezeVmFailure(new EngineException(EngineError.freezeErr));
    }
}
#end_block

#method_before
private void thawVm() {
    if (!isLiveSnapshotApplicable() || !isCinderDisksExist()) {
        return;
    }
    VDSReturnValue returnValue;
    try {
        returnValue = runVdsCommand(VDSCommandType.Thaw, new VdsAndVmIDVDSParametersBase(getVds().getId(), getVmId()));
    } catch (EngineException e) {
        handleThawVmFailure(e);
        return;
    }
    if (!returnValue.getSucceeded()) {
        handleThawVmFailure(new EngineException(EngineError.thawErr));
    }
}
#method_after
private void thawVm() {
    if (!shouldFreezeOrThawVm()) {
        return;
    }
    VDSReturnValue returnValue;
    try {
        returnValue = runVdsCommand(VDSCommandType.Thaw, new VdsAndVmIDVDSParametersBase(getVds().getId(), getVmId()));
    } catch (EngineException e) {
        handleThawVmFailure(e);
        return;
    }
    if (!returnValue.getSucceeded()) {
        handleThawVmFailure(new EngineException(EngineError.thawErr));
    }
}
#end_block

#method_before
private boolean isCinderDisksExist() {
    return CollectionUtils.exists(getDisksList(), new Predicate() {

        @Override
        public boolean evaluate(Object o) {
            Disk disk = (Disk) o;
            return disk.getDiskStorageType() == DiskStorageType.CINDER;
        }
    });
}
#method_after
private boolean isCinderDisksExist() {
    return !ImagesHandler.filterDisksBasedOnCinder(getDisksList()).isEmpty();
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(EngineException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}", e.getMessage());
    log.debug("Exception", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    auditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(EngineException e) {
    handleVmFailure(e, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, "Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}");
}
#end_block

#method_before
private void assertGeneratesCorrect(int maxNameLengt, int poolNameLength, int expectedMaxNumOfVms) {
    // $NON-NLS-1$
    ExistingPoolNameLengthValidation validation = new ExistingPoolNameLengthValidation("", 0, OsRepository.DEFAULT_X86_OS);
    int res = validation.doGenerateMaxNumOfVms(maxNameLengt, poolNameLength);
    assertThat(res, is(equalTo(expectedMaxNumOfVms)));
}
#method_after
private void assertGeneratesCorrect(int maxNameLength, int poolNameLength, int expectedMaxNumOfVms) {
    // $NON-NLS-1$
    ExistingPoolNameLengthValidation validation = new ExistingPoolNameLengthValidation("", 0, OsRepository.DEFAULT_X86_OS);
    int res = validation.doGenerateMaxNumOfVms(maxNameLength, poolNameLength);
    assertThat(res, is(equalTo(expectedMaxNumOfVms)));
}
#end_block

#method_before
private int generateMaxNumOfVmsWithQuestionMark() {
    int numberOfDigits = getMaxNameLength() - (getPoolName().length() - getQuestionMarksCount());
    return getMaxNumberInNDigits(numberOfDigits);
}
#method_after
private int generateMaxNumOfVmsWithQuestionMark() {
    return doGenerateMaxNumOfVmsWithQuestionMark(getMaxNameLength(), getPoolName().length(), getQuestionMarksCount());
}
#end_block

#method_before
protected void initPriority(int priority) {
    priorityUtil.initPriority(priority);
}
#method_after
protected void initPriority(int priority) {
    priorityUtil.initPriority(priority, new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            if (getInstanceTypeManager() != null) {
                getInstanceTypeManager().deactivate();
            }
        }

        @Override
        public void afterUpdates() {
            if (getInstanceTypeManager() != null) {
                getInstanceTypeManager().activate();
            }
        }
    });
}
#end_block

#method_before
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null && vdsmVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString((vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES)));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#method_after
private void proceedGuaranteedMemoryCheck() {
    if (dbVm != null && vdsmVm != null) {
        VmStatistics vmStatistics = vdsmVm.getVmStatistics();
        if (vmStatistics != null && vmStatistics.getVmBalloonInfo() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() != null && vmStatistics.getVmBalloonInfo().getCurrentMemory() > 0 && dbVm.getMinAllocatedMem() > vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.addCustomValue("VmName", dbVm.getName());
            auditLogable.addCustomValue("VdsName", this.getVdsManager().getVdsName());
            auditLogable.addCustomValue("MemGuaranteed", String.valueOf(dbVm.getMinAllocatedMem()));
            auditLogable.addCustomValue("MemActual", Long.toString((vmStatistics.getVmBalloonInfo().getCurrentMemory() / TO_MEGA_BYTES)));
            auditLog(auditLogable, AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE);
        }
    }
}
#end_block

#method_before
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().RemoveVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#method_after
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().RemoveVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#end_block

#method_before
private boolean updateVmRunTimeInfo() {
    boolean returnValue = false;
    if (dbVm == null) {
        dbVm = getDbFacade().getVmDao().get(vdsmVm.getVmDynamic().getId());
        // if vm exists in db update info
        if (dbVm != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            dbVm.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(dbVm.getId()));
            if (vdsmVm.getVmDynamic().getStatus() == VMStatus.Up) {
                succeededToRun = true;
            }
        }
    }
    if (dbVm != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(dbVm.getDynamicData(), vdsmVm.getVmDynamic());
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vdsmVm.getVmDynamic().getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vdsmVm.getVmDynamic().setAppList(dbVm.getAppList());
        }
        // if anything else changed
        if (!props.isEmpty()) {
            dbVm.updateRunTimeDynamicData(vdsmVm.getVmDynamic(), getVdsManager().getVdsId(), getVdsManager().getVdsName());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo() {
    boolean returnValue = false;
    if (dbVm == null) {
        dbVm = getDbFacade().getVmDao().get(vdsmVm.getVmDynamic().getId());
        // if vm exists in db update info
        if (dbVm != null) {
            // TODO: This is done to keep consistency with VmDao.getById(Guid).
            // It should probably be removed, but some research is required.
            dbVm.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(dbVm.getId()));
            if (vdsmVm.getVmDynamic().getStatus() == VMStatus.Up) {
                succeededToRun = true;
            }
        }
    }
    if (dbVm != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(dbVm.getDynamicData(), vdsmVm.getVmDynamic());
        // remove all fields that should not be checked:
        props.removeAll(UNCHANGEABLE_FIELDS_BY_VDSM);
        if (vdsmVm.getVmDynamic().getStatus() != VMStatus.Up) {
            props.remove(VmDynamic.APPLICATIONS_LIST_FIELD_NAME);
            vdsmVm.getVmDynamic().setAppList(dbVm.getAppList());
        }
        // if anything else changed
        if (!props.isEmpty()) {
            dbVm.updateRunTimeDynamicData(vdsmVm.getVmDynamic(), getVdsManager().getVdsId(), getVdsManager().getVdsName());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (getVdsManager().getRefreshStatistics()) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        for (DiskImageDynamic diskImageDynamic : vdsmVm.getVmDynamic().getDisks()) {
            vmsMonitoring.addDiskImageDynamicToSave(new Pair<>(dbVm.getId(), diskImageDynamic));
        }
    }
}
#method_after
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (vmsMonitoring.isTimeToUpdateVmStatistics()) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        for (DiskImageDynamic diskImageDynamic : vdsmVm.getVmDynamic().getDisks()) {
            vmsMonitoring.addDiskImageDynamicToSave(new Pair<>(dbVm.getId(), diskImageDynamic));
        }
    }
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vmDynamicDynamic = vdsmVm.getVmDynamic();
        if (vmDynamicDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamicDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(vdsmVm.getVmDynamic());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        if (vdsmVmDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(dbVm.getDynamicData());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDAO().getAllVdsNumaNodeByVdsId(dbVm.getRunOnVds());
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(dbVm.getId());
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if ((!pinnedNodes.contains(pair.getSecond().getSecond())) && (runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond()))) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#method_after
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> runOnVdsAllNumaNodesMap = new HashMap<>();
    List<VdsNumaNode> runOnVdsAllNumaNodes = getDbFacade().getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(dbVm.getRunOnVds());
    for (VdsNumaNode vdsNumaNode : runOnVdsAllNumaNodes) {
        runOnVdsAllNumaNodesMap.put(vdsNumaNode.getIndex(), vdsNumaNode);
    }
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = new HashMap<>();
    List<VmNumaNode> vmAllNumaNodes = getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(dbVm.getId());
    for (VmNumaNode vmNumaNode : vmAllNumaNodes) {
        vmAllNumaNodesMap.put(vmNumaNode.getIndex(), vmNumaNode);
    }
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if ((!pinnedNodes.contains(pair.getSecond().getSecond())) && (runOnVdsAllNumaNodesMap.containsKey(pair.getSecond().getSecond()))) {
                    pair.setFirst(runOnVdsAllNumaNodesMap.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#end_block

#method_before
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
}
#method_after
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
    vmsMonitoring.addVmGuestAgentNics(dbVm.getId(), vmGuestAgentInterfaces);
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb((int) xmlRpcStruct.get(VdsProperties.mem_size_mb));
    vmStatic.setNumOfSockets((int) xmlRpcStruct.get(VdsProperties.num_of_cpus));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            vmStatic.getInterfaces().add(buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap));
        }
    }
    return vmStatic;
}
#method_after
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb((int) xmlRpcStruct.get(VdsProperties.mem_size_mb));
    vmStatic.setNumOfSockets((int) xmlRpcStruct.get(VdsProperties.num_of_cpus));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            vmStatic.getInterfaces().add(buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap));
        }
    }
    return vmStatic;
}
#end_block

#method_before
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#end_block

#method_before
private static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.error("Illegal Vm status: '{}'.", statusName);
        }
    }
    return status;
}
#method_after
public static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.error("Illegal Vm status: '{}'.", statusName);
        }
    }
    return status;
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setActiveNic(AssignStringValue(xmlRpcStruct, VdsProperties.NETWORK_LAST_CLIENT_INTERFACE));
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(host.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, host, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, host, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPoolManagerStrategy macPool) {
    boolean returnValue = true;
    if (macPool.getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#method_after
public static boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPoolManagerStrategy macPool) {
    boolean returnValue = true;
    if (macPool.getAvailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.isVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
private static void checkStatusBeforeLock(VMStatus status) {
    if (status == VMStatus.ImageLocked) {
        log.error("VM status cannot change to image locked, since it is already locked");
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
}
#method_after
private static void checkStatusBeforeLock(VMStatus status) {
    if (status == VMStatus.ImageLocked) {
        log.error("VM status cannot change to image locked, since it is already locked");
        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
    }
}
#end_block

#method_before
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (vm.getVmInit() != null) {
        if (secure) {
            vm.getVmInit().setPasswordAlreadyStored(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
            vm.getVmInit().setRootPassword(null);
        } else {
            vm.getVmInit().setPasswordAlreadyStored(false);
        }
    }
}
#method_after
public static void updateVmInitFromDB(VmBase vm, boolean secure) {
    VmInitDao db = DbFacade.getInstance().getVmInitDao();
    vm.setVmInit(db.get(vm.getId()));
    if (vm.getVmInit() != null) {
        if (secure) {
            vm.getVmInit().setPasswordAlreadyStored(!StringUtils.isEmpty(vm.getVmInit().getRootPassword()));
            vm.getVmInit().setRootPassword(null);
        } else {
            vm.getVmInit().setPasswordAlreadyStored(false);
        }
    }
}
#end_block

#method_before
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDAO db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#method_after
public static void addVmInitToDB(VmBase vm) {
    if (vm.getVmInit() != null) {
        vm.getVmInit().setId(vm.getId());
        VmInitDao db = DbFacade.getInstance().getVmInitDao();
        VmInit oldVmInit = db.get(vm.getId());
        if (oldVmInit == null) {
            db.save(vm.getVmInit());
        } else {
            if (vm.getVmInit().isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vm.getVmInit().setRootPassword(oldVmInit.getRootPassword());
            }
            db.update(vm.getVmInit());
        }
    }
}
#end_block

#method_before
public static void removeVmInitFromDB(VmBase vm) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    db.remove(vm.getId());
}
#method_after
public static void removeVmInitFromDB(VmBase vm) {
    VmInitDao db = DbFacade.getInstance().getVmInitDao();
    db.remove(vm.getId());
}
#end_block

#method_before
// if secure is true we don't return the stored password, only
public static List<VmInit> getVmInitByIds(List<Guid> ids, boolean secure) {
    VmInitDAO db = DbFacade.getInstance().getVmInitDao();
    List<VmInit> all = db.getVmInitByIds(ids);
    for (VmInit vmInit : all) {
        if (secure) {
            vmInit.setPasswordAlreadyStored(!StringUtils.isEmpty(vmInit.getRootPassword()));
            vmInit.setRootPassword(null);
        } else {
            vmInit.setPasswordAlreadyStored(false);
        }
    }
    return all;
}
#method_after
// if secure is true we don't return the stored password, only
public static List<VmInit> getVmInitByIds(List<Guid> ids, boolean secure) {
    VmInitDao db = DbFacade.getInstance().getVmInitDao();
    List<VmInit> all = db.getVmInitByIds(ids);
    for (VmInit vmInit : all) {
        if (secure) {
            vmInit.setPasswordAlreadyStored(!StringUtils.isEmpty(vmInit.getRootPassword()));
            vmInit.setRootPassword(null);
        } else {
            vmInit.setPasswordAlreadyStored(false);
        }
    }
    return all;
}
#end_block

#method_before
public static boolean isOsTypeSupported(int osId, ArchitectureType architectureType, List<String> reasons) {
    boolean result = VmValidationUtils.isOsTypeSupported(osId, architectureType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_NOT_SUPPORTED_BY_ARCHITECTURE_TYPE.toString());
    }
    return result;
}
#method_after
public static boolean isOsTypeSupported(int osId, ArchitectureType architectureType, List<String> reasons) {
    boolean result = VmValidationUtils.isOsTypeSupported(osId, architectureType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_NOT_SUPPORTED_BY_ARCHITECTURE_TYPE.toString());
    }
    return result;
}
#end_block

#method_before
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#method_after
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#end_block

#method_before
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, DiskInterface.VirtIO_SCSI);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI.name());
    }
    return result;
}
#method_after
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, DiskInterface.VirtIO_SCSI);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI.name());
    }
    return result;
}
#end_block

#method_before
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNic iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNic iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
public static boolean isNumOfMonitorsLegal(Collection<GraphicsType> graphicsTypes, int numOfMonitors, List<String> reasons) {
    boolean legal = false;
    if (graphicsTypes.contains(GraphicsType.VNC)) {
        legal = (numOfMonitors <= 1);
    } else if (graphicsTypes.contains(GraphicsType.SPICE)) {
        // contains spice and doesn't contain vnc
        legal = (numOfMonitors <= getMaxNumberOfMonitors());
    }
    if (!legal) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS.toString());
    }
    return legal;
}
#method_after
public static boolean isNumOfMonitorsLegal(Collection<GraphicsType> graphicsTypes, int numOfMonitors, List<String> reasons) {
    boolean legal = false;
    if (graphicsTypes.contains(GraphicsType.VNC)) {
        legal = (numOfMonitors <= 1);
    } else if (graphicsTypes.contains(GraphicsType.SPICE)) {
        // contains spice and doesn't contain vnc
        legal = (numOfMonitors <= getMaxNumberOfMonitors());
    }
    if (!legal) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS.toString());
    }
    return legal;
}
#end_block

#method_before
public static boolean isSingleQxlDeviceLegal(DisplayType displayType, int osId, List<String> reasons, Version compatibilityVersion) {
    if (!FeatureSupported.singleQxlPci(compatibilityVersion)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_INCOMPATIBLE_VERSION.toString());
        return false;
    }
    if (displayType != DisplayType.qxl) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_DISPLAY_TYPE.toString());
        return false;
    }
    if (!osRepository.isSingleQxlDeviceEnabled(osId)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_OS_TYPE.toString());
        return false;
    }
    return true;
}
#method_after
public static boolean isSingleQxlDeviceLegal(DisplayType displayType, int osId, List<String> reasons, Version compatibilityVersion) {
    if (!FeatureSupported.singleQxlPci(compatibilityVersion)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_INCOMPATIBLE_VERSION.toString());
        return false;
    }
    if (displayType != DisplayType.qxl) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_DISPLAY_TYPE.toString());
        return false;
    }
    if (!osRepository.isSingleQxlDeviceEnabled(osId)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_SINGLE_DEVICE_OS_TYPE.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
public static boolean isUsbPolicyLegal(UsbPolicy usbPolicy, int osId, VDSGroup vdsGroup, List<String> messages) {
    boolean retVal = true;
    if (UsbPolicy.ENABLED_NATIVE.equals(usbPolicy)) {
        if (!Config.<Boolean>getValue(ConfigValues.NativeUSBEnabled, vdsGroup.getCompatibilityVersion().getValue())) {
            messages.add(VdcBllMessages.USB_NATIVE_SUPPORT_ONLY_AVAILABLE_ON_CLUSTER_LEVEL.toString());
            retVal = false;
        }
    } else if (UsbPolicy.ENABLED_LEGACY.equals(usbPolicy)) {
        if (osRepository.isLinux(osId)) {
            messages.add(VdcBllMessages.USB_LEGACY_NOT_SUPPORTED_ON_LINUX_VMS.toString());
            retVal = false;
        }
    }
    return retVal;
}
#method_after
public static boolean isUsbPolicyLegal(UsbPolicy usbPolicy, int osId, VDSGroup vdsGroup, List<String> messages) {
    boolean retVal = true;
    if (UsbPolicy.ENABLED_NATIVE.equals(usbPolicy)) {
        if (!Config.<Boolean>getValue(ConfigValues.NativeUSBEnabled, vdsGroup.getCompatibilityVersion().getValue())) {
            messages.add(EngineMessage.USB_NATIVE_SUPPORT_ONLY_AVAILABLE_ON_CLUSTER_LEVEL.toString());
            retVal = false;
        }
    } else if (UsbPolicy.ENABLED_LEGACY.equals(usbPolicy)) {
        if (osRepository.isLinux(osId)) {
            messages.add(EngineMessage.USB_LEGACY_NOT_SUPPORTED_ON_LINUX_VMS.toString());
            retVal = false;
        }
    }
    return retVal;
}
#end_block

#method_before
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if ((vm.isHostedEngine() && !COMMANDS_ALLOWED_ON_HOSTED_ENGINE.contains(actionType)) || (vm.isExternalVm() && !COMMANDS_ALLOWED_ON_EXTERNAL_VMS.contains(actionType))) {
        validationResult = new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#method_after
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if ((vm.isHostedEngine() && !COMMANDS_ALLOWED_ON_HOSTED_ENGINE.contains(actionType)) || (vm.isExternalVm() && !COMMANDS_ALLOWED_ON_EXTERNAL_VMS.contains(actionType))) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#end_block

#method_before
private static VdsDynamicDAO getVdsDynamicDao() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#method_after
private static VdsDynamicDao getVdsDynamicDao() {
    return DbFacade.getInstance().getVdsDynamicDao();
}
#end_block

#method_before
public static boolean isCpuSupported(int osId, Version version, String cpuName, ArrayList<String> canDoActionMessages) {
    if (osRepository.isCpuSupported(osId, version, CpuFlagsManagerHandler.getCpuId(cpuName, version))) {
        return true;
    }
    String unsupportedCpus = osRepository.getUnsupportedCpus(osId, version).toString();
    canDoActionMessages.add(VdcBllMessages.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS.name());
    canDoActionMessages.add("$unsupportedCpus " + StringUtils.strip(unsupportedCpus.toString(), "[]"));
    return false;
}
#method_after
public static boolean isCpuSupported(int osId, Version version, String cpuName, ArrayList<String> canDoActionMessages) {
    if (osRepository.isCpuSupported(osId, version, CpuFlagsManagerHandler.getCpuId(cpuName, version))) {
        return true;
    }
    String unsupportedCpus = osRepository.getUnsupportedCpus(osId, version).toString();
    canDoActionMessages.add(EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS.name());
    canDoActionMessages.add("$unsupportedCpus " + StringUtils.strip(unsupportedCpus.toString(), "[]"));
    return false;
}
#end_block

#method_before
public static ValidationResult checkVmNumaNodesIntegrity(VM paramsVm, VM actualVm, boolean isNumaChanged) {
    /* calculate the actual NUMA nodes */
    List<VmNumaNode> paramVmNumaNodes = paramsVm.getvNumaNodeList();
    boolean emptyParamVmNumaNodes = (paramVmNumaNodes == null) || (paramVmNumaNodes.isEmpty());
    /* origVmNumaNodes = NUMA nodes list prior to update. */
    List<VmNumaNode> origVmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(actualVm.getId());
    boolean emptyOrigVmNumaNodes = (origVmNumaNodes == null) || (origVmNumaNodes.isEmpty());
    int NUMAnodesCount = 0;
    /* return valid if no NUMA nodes */
    if (emptyParamVmNumaNodes && emptyOrigVmNumaNodes) {
        return ValidationResult.VALID;
    }
    /* if no NUMA nodes in parameters, but there are NUMA nodes in previous vm */
    if (emptyParamVmNumaNodes && !emptyOrigVmNumaNodes) {
        /* REST-api always provide emptyParamVmNumaNodes */
        /* REST-api modifies NUMA nodes via: addVmNumaNodeCommand/updateVmNumaNodeCommand */
        /* count NUMA nodes in previous vm, by default */
        NUMAnodesCount = origVmNumaNodes.size();
        /* if GUI update to reset NUMA nodes */
        if (isNumaChanged == true)
            // no NUMA nodes.
            return ValidationResult.VALID;
    }
    if (!emptyParamVmNumaNodes) {
        // An update to NUMA nodes
        NUMAnodesCount = paramVmNumaNodes.size();
    }
    // REST-api assigns cpuCount to parameters.
    int cpuCount = paramsVm.getNumOfCpus();
    if (cpuCount < NUMAnodesCount) {
        return new ValidationResult(VdcBllMessages.VM_NUMA_NODE_MORE_NODES_THAN_CPUS, String.format("$numaNodes %d", NUMAnodesCount), String.format("$cpus %d", cpuCount));
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult checkVmNumaNodesIntegrity(VM paramsVm, VM actualVm, boolean isNumaChanged) {
    /* calculate the actual NUMA nodes */
    List<VmNumaNode> paramVmNumaNodes = paramsVm.getvNumaNodeList();
    boolean emptyParamVmNumaNodes = (paramVmNumaNodes == null) || (paramVmNumaNodes.isEmpty());
    /* origVmNumaNodes = NUMA nodes list prior to update. */
    List<VmNumaNode> origVmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(actualVm.getId());
    boolean emptyOrigVmNumaNodes = (origVmNumaNodes == null) || (origVmNumaNodes.isEmpty());
    int NUMAnodesCount = 0;
    /* return valid if no NUMA nodes */
    if (emptyParamVmNumaNodes && emptyOrigVmNumaNodes) {
        return ValidationResult.VALID;
    }
    /* if no NUMA nodes in parameters, but there are NUMA nodes in previous vm */
    if (emptyParamVmNumaNodes && !emptyOrigVmNumaNodes) {
        /* REST-api always provide emptyParamVmNumaNodes */
        /* REST-api modifies NUMA nodes via: addVmNumaNodeCommand/updateVmNumaNodeCommand */
        /* count NUMA nodes in previous vm, by default */
        NUMAnodesCount = origVmNumaNodes.size();
        /* if GUI update to reset NUMA nodes */
        if (isNumaChanged == true)
            // no NUMA nodes.
            return ValidationResult.VALID;
    }
    if (!emptyParamVmNumaNodes) {
        // An update to NUMA nodes
        NUMAnodesCount = paramVmNumaNodes.size();
    }
    // REST-api assigns cpuCount to parameters.
    int cpuCount = paramsVm.getNumOfCpus();
    if (cpuCount < NUMAnodesCount) {
        return new ValidationResult(EngineMessage.VM_NUMA_NODE_MORE_NODES_THAN_CPUS, String.format("$numaNodes %d", NUMAnodesCount), String.format("$cpus %d", cpuCount));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public static ValidationResult checkNumaPreferredTuneMode(NumaTuneMode numaTuneMode, List<VmNumaNode> vmNumaNodes, Guid vmId) {
    // check tune mode
    if (numaTuneMode != NumaTuneMode.PREFERRED) {
        return ValidationResult.VALID;
    }
    if (vmNumaNodes == null && vmId != null) {
        vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(vmId);
    }
    // check single node pinned
    if (vmNumaNodes != null && vmNumaNodes.size() == 1) {
        List<Pair<Guid, Pair<Boolean, Integer>>> vdsNumaNodeList = vmNumaNodes.get(0).getVdsNumaNodeList();
        boolean pinnedToSingleNode = vdsNumaNodeList != null && vdsNumaNodeList.size() == 1 && vdsNumaNodeList.get(0).getSecond() != null && vdsNumaNodeList.get(0).getSecond().getFirst();
        if (pinnedToSingleNode) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.VM_NUMA_NODE_PREFERRED_NOT_PINNED_TO_SINGLE_NODE);
}
#method_after
public static ValidationResult checkNumaPreferredTuneMode(NumaTuneMode numaTuneMode, List<VmNumaNode> vmNumaNodes, Guid vmId) {
    // check tune mode
    if (numaTuneMode != NumaTuneMode.PREFERRED) {
        return ValidationResult.VALID;
    }
    if (vmNumaNodes == null && vmId != null) {
        vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDao().getAllVmNumaNodeByVmId(vmId);
    }
    // check single node pinned
    if (vmNumaNodes != null && vmNumaNodes.size() == 1) {
        List<Pair<Guid, Pair<Boolean, Integer>>> vdsNumaNodeList = vmNumaNodes.get(0).getVdsNumaNodeList();
        boolean pinnedToSingleNode = vdsNumaNodeList != null && vdsNumaNodeList.size() == 1 && vdsNumaNodeList.get(0).getSecond() != null && vdsNumaNodeList.get(0).getSecond().getFirst();
        if (pinnedToSingleNode) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.VM_NUMA_NODE_PREFERRED_NOT_PINNED_TO_SINGLE_NODE);
}
#end_block

#method_before
public static boolean validateDedicatedVdsExistOnSameCluster(VmBase vm, ArrayList<String> canDoActionMessages) {
    boolean result = true;
    if (vm.getDedicatedVmForVds() != null) {
        // get dedicated host id
        Guid vdsId = vm.getDedicatedVmForVds();
        // get dedicated host, checks if exists and compare its cluster to the VM cluster
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            if (canDoActionMessages != null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_DEDICATED_VDS_DOES_NOT_EXIST.toString());
            }
            result = false;
        } else if (!Objects.equals(vm.getVdsGroupId(), vds.getVdsGroupId())) {
            if (canDoActionMessages != null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_DEDICATED_VDS_NOT_IN_SAME_CLUSTER.toString());
            }
            result = false;
        }
    }
    return result;
}
#method_after
public static boolean validateDedicatedVdsExistOnSameCluster(VmBase vm, ArrayList<String> canDoActionMessages) {
    boolean result = true;
    for (Guid vdsId : vm.getDedicatedVmForVdsList()) {
        // get dedicated host, checks if exists and compare its cluster to the VM cluster
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            if (canDoActionMessages != null) {
                canDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_DEDICATED_VDS_DOES_NOT_EXIST.toString());
            }
            result = false;
        } else if (!Objects.equals(vm.getVdsGroupId(), vds.getVdsGroupId())) {
            if (canDoActionMessages != null) {
                canDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_DEDICATED_VDS_NOT_IN_SAME_CLUSTER.toString());
            }
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            LockManagerFactory.getLockManager().acquireLockWait(lock);
            clearDomainCache(vds);
            StoragePool storage_pool = DbFacade.getInstance().getStoragePoolDao().get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                Backend.getInstance().runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(lock);
        }
    }
}
#method_after
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            LockManagerFactory.getLockManager().acquireLockWait(lock);
            clearDomainCache(vds);
            StoragePool storage_pool = DbFacade.getInstance().getStoragePoolDao().get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                backend.getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                backend.runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(lock);
        }
    }
}
#end_block

#method_before
@Override
public EventResult storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase(storageDomainId, storagePoolId);
    parameters.setIsInternal(true);
    parameters.setInactive(true);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.DeactivateStorageDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.DOMAINNOTOPERATIONAL);
}
#method_after
@Override
public EventResult storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase(storageDomainId, storagePoolId);
    parameters.setIsInternal(true);
    parameters.setInactive(true);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.DeactivateStorageDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.DOMAINNOTOPERATIONAL);
}
#end_block

#method_before
@Override
public EventResult masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId, boolean isReconstructToInactiveDomains, boolean canReconstructToCurrentMaster) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true, isReconstructToInactiveDomains, canReconstructToCurrentMaster);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.RECONSTRUCT);
}
#method_after
@Override
public EventResult masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId, boolean isReconstructToInactiveDomains, boolean canReconstructToCurrentMaster) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true, isReconstructToInactiveDomains, canReconstructToCurrentMaster);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.RECONSTRUCT);
}
#end_block

#method_before
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(vmId, true));
            }
            HostDeviceManager hostDeviceManager = Injector.get(HostDeviceManager.class);
            hostDeviceManager.refreshHostIfAnyVmHasHostDevices(vmIds, hostId);
        }
    });
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    processOnVmStop(vmIds, hostId, true);
}
#end_block

#method_before
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId) {
    if (vmIds.isEmpty()) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            for (Guid vmId : vmIds) {
                Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(vmId, true));
            }
            HostDeviceManager hostDeviceManager = Injector.get(HostDeviceManager.class);
            hostDeviceManager.refreshHostIfAnyVmHasHostDevices(vmIds, hostId);
        }
    });
}
#method_after
@Override
public void processOnVmStop(final Collection<Guid> vmIds, final Guid hostId, boolean useSeparateThread) {
    if (vmIds.isEmpty()) {
        return;
    }
    if (useSeparateThread) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                processOnVmStopInternal(vmIds, hostId);
            }
        });
    } else {
        processOnVmStopInternal(vmIds, hostId);
    }
}
#end_block

#method_before
@Override
public void syncLunsInfoForBlockStorageDomain(final Guid storageDomainId, final Guid vdsId) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomainId);
            parameters.setVdsId(vdsId);
            Backend.getInstance().runInternalAction(VdcActionType.SyncLunsInfoForBlockStorageDomain, parameters);
        }
    });
}
#method_after
@Override
public void syncLunsInfoForBlockStorageDomain(final Guid storageDomainId, final Guid vdsId) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomainId);
            parameters.setVdsId(vdsId);
            backend.runInternalAction(VdcActionType.SyncLunsInfoForBlockStorageDomain, parameters);
        }
    });
}
#end_block

#method_before
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId, Map<String, String> customLogValues) {
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintenanceVds, false);
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, reason, customLogValues);
    tempVar.setStorageDomainId(domainId);
    tempVar.setShouldBeLogged(logCommand);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void vdsNonOperational(Guid vdsId, NonOperationalReason reason, boolean logCommand, Guid domainId, Map<String, String> customLogValues) {
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintenanceVds, false);
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, reason, customLogValues);
    tempVar.setStorageDomainId(domainId);
    tempVar.setShouldBeLogged(logCommand);
    backend.runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
public void vdsNotResponding(final VDS vds) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.info("ResourceManager::vdsNotResponding entered for Host '{}', '{}'", vds.getId(), vds.getHostName());
            FenceVdsActionParameters params = new FenceVdsActionParameters(vds.getId());
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, params, ExecutionHandler.createInternalJobContext());
            moveBricksToUnknown(vds);
        }
    });
}
#method_after
@Override
public void vdsNotResponding(final VDS vds) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.info("ResourceManager::vdsNotResponding entered for Host '{}', '{}'", vds.getId(), vds.getHostName());
            FenceVdsActionParameters params = new FenceVdsActionParameters(vds.getId());
            backend.runInternalAction(VdcActionType.VdsNotRespondingTreatment, params, ExecutionHandler.createInternalJobContext());
            moveBricksToUnknown(vds);
        }
    });
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        CommandContext ctx = new CommandContext(new EngineContext());
                        ctx.getExecutionContext().setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                    }
                } catch (RuntimeException e) {
                    log.error("Failed to initialize Vds on up: {}", e.getMessage());
                    log.error("Exception", e);
                }
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (!vmsToMigrate.isEmpty()) {
                        CommandContext ctx = new CommandContext(new EngineContext());
                        ctx.getExecutionContext().setMonitored(true);
                        backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                    }
                } catch (RuntimeException e) {
                    log.error("Failed to initialize Vds on up: {}", e.getMessage());
                    log.error("Exception", e);
                }
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(vds, false);
    return Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#method_after
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(vds, false);
    return backend.runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#end_block

#method_before
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
}
#method_after
@Override
public void processOnCpuFlagsChange(Guid vdsId) {
    backend.runInternalAction(VdcActionType.HandleVdsCpuFlagsOrClusterChanged, new VdsActionParameters(vdsId));
}
#end_block

#method_before
@Override
public void handleVdsVersion(Guid vdsId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleVdsVersion, new VdsActionParameters(vdsId));
}
#method_after
@Override
public void handleVdsVersion(Guid vdsId) {
    backend.runInternalAction(VdcActionType.HandleVdsVersion, new VdsActionParameters(vdsId));
}
#end_block

#method_before
@Override
public void processOnVmPoweringUp(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.onPowerringUp();
    }
}
#method_after
@Override
public void processOnVmPoweringUp(Guid vmId) {
    IVdsAsyncCommand command = backend.getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.onPowerringUp();
    }
}
#end_block

#method_before
@Override
public void storagePoolStatusChange(Guid storagePoolId, StoragePoolStatus status, AuditLogType auditLogType, VdcBllErrors error, TransactionScopeOption transactionScopeOption) {
    SetStoragePoolStatusParameters tempVar = new SetStoragePoolStatusParameters(storagePoolId, status, auditLogType);
    tempVar.setError(error);
    if (transactionScopeOption != null) {
        tempVar.setTransactionScopeOption(transactionScopeOption);
    }
    Backend.getInstance().runInternalAction(VdcActionType.SetStoragePoolStatus, tempVar);
}
#method_after
@Override
public void storagePoolStatusChange(Guid storagePoolId, StoragePoolStatus status, AuditLogType auditLogType, EngineError error) {
    storagePoolStatusChange(storagePoolId, status, auditLogType, error, null);
}
#end_block

#method_before
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmParameters params = new AddVmParameters(currVm);
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debug("Failed adding Externally managed VM '{}'", currVm.getName());
        }
    }
}
#method_after
@Override
public void addExternallyManagedVms(List<VmStatic> externalVmList) {
    for (VmStatic currVm : externalVmList) {
        AddVmParameters params = new AddVmParameters(currVm);
        VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.AddVmFromScratch, params, ExecutionHandler.createInternalJobContext());
        if (!returnValue.getSucceeded()) {
            log.debug("Failed adding Externally managed VM '{}'", currVm.getName());
        }
    }
}
#end_block

#method_before
@Override
public void handleVdsMaintenanceTimeout(Guid vdsId) {
    // try to put the host to Maintenance again.
    Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsId), true));
}
#method_after
@Override
public void handleVdsMaintenanceTimeout(Guid vdsId) {
    // try to put the host to Maintenance again.
    backend.runInternalAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsId), true));
}
#end_block

#method_before
@Override
public void rerun(Guid vmId) {
    final IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        // The command will be invoked in a different VDS in its rerun method, so we're calling
        // its rerun method from a new thread so that it won't be executed within our current VDSM lock
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                command.rerun();
            }
        });
    }
}
#method_after
@Override
public void rerun(Guid vmId) {
    final IVdsAsyncCommand command = backend.getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        // The command will be invoked in a different VDS in its rerun method, so we're calling
        // its rerun method from a new thread so that it won't be executed within our current VDSM lock
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                command.rerun();
            }
        });
    }
}
#end_block

#method_before
@Override
public void runningSucceded(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.runningSucceded();
    }
}
#method_after
@Override
public void runningSucceded(Guid vmId) {
    IVdsAsyncCommand command = backend.getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.runningSucceded();
    }
}
#end_block

#method_before
@Override
public void removeAsyncRunningCommand(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(vmId);
    if (command != null) {
        command.reportCompleted();
    }
}
#method_after
@Override
public void removeAsyncRunningCommand(Guid vmId) {
    IVdsAsyncCommand command = backend.getResourceManager().RemoveAsyncRunningCommand(vmId);
    if (command != null) {
        command.reportCompleted();
    }
}
#end_block

#method_before
@Override
public void importHostedEngineVm(final VM vm, final Guid vdsGroupId) {
    ThreadPoolUtil.execute(new Runnable() {

        public void run() {
            // get the special sd of hosted engine
            StorageDomain sd = (StorageDomain) ((ArrayList) backend.runInternalQuery(VdcQueryType.Search, new SearchParameters("Storage: name=" + Config.<String>getValue(ConfigValues.HostedEngineStorageDomainName), SearchType.StorageDomain)).getReturnValue()).get(0);
            // no point in trying this without the SD
            if (sd != null && sd.getStatus() == StorageDomainStatus.Active) {
                // first remove the vm(status up valid in this case, for removal) and then import it
                boolean removedUnmanagedHEVM = backend.runInternalAction(VdcActionType.RemoveVm, new RemoveVmParameters(vm.getId(), true)).getSucceeded();
                if (removedUnmanagedHEVM) {
                    // now import the VM with its disks
                    ImportVmParameters parameters = new ImportVmParameters(vm, sd.getId(), sd.getId(), sd.getStoragePoolId(), vdsGroupId);
                    // assumption is that there's only 1 profile for hosted engine domain. its an unmanged domain.
                    Guid sdProfileId = diskProfileDao.getAllForStorageDomain(sd.getId()).get(0).getId();
                    for (DiskImage image : vm.getImages()) {
                        image.setDiskProfileId(sdProfileId);
                        image.setStorageIds(new ArrayList(Arrays.asList(sd.getId())));
                        image.setVmSnapshotId(Guid.newGuid());
                    }
                    // disks are there already(the vm is running)
                    parameters.setImagesExistOnTargetStorageDomain(true);
                    // distinguish from "regular" he vm.
                    vm.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
                    // architecture is a missing attribute from vdsm structure. relying on the cluster is perfectly reliable.
                    vm.setClusterArch(vdsGroupDAO.get(vdsGroupId).getArchitecture());
                    backend.runInternalAction(VdcActionType.ImportVm, parameters);
                }
            }
        }
    });
}
#method_after
@Override
public void importHostedEngineVm(final VM vm) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            hostedEngineImporterProvider.get().doImport(vm);
        }
    });
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            // store the locked managers to finally release them at the end of the cycle
            vmManagers.put(vmId, vmManager);
            return true;
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (!vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId())) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
                vmManager.unlock();
            } else if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.unlock();
    }
}
#method_after
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.updateVmDataChangedTime();
        vmManager.unlock();
    }
}
#end_block

#method_before
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> pair : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(pair)) {
            VmAnalyzer vmAnalyzer = new VmAnalyzer(pair.getFirst(), pair.getSecond(), this, auditLogDirector);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#method_after
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmUpdater : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmUpdater.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmUpdater.getDbVm().getId(), vdsManager.getVdsName());
            ResourceManager.getInstance().RerunFailedCommand(vmUpdater.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmUpdater.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmUpdater.getDbVm().getId());
            succeededToRunVms.add(vmUpdater.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmUpdater.isAutoVmToRun() && !vmUpdater.isRerun()) {
            autoVmsToRun.add(vmUpdater.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmUpdater.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmUpdater.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmUpdater.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmUpdater.getVdsmVm().getVmDynamic().getId());
        }
        if (vmUpdater.isMovedToDown()) {
            movedToDownVms.add(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isRemoveFromAsync()) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isHostedEngineUnmanaged()) {
            Map vmStruct = getVmInfo(Collections.singletonList(vmUpdater.getVdsmVm().getVmDynamic().getId().toString()))[0];
            VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
            vm.setImages(VdsBrokerObjectsBuilder.BuildDiskImagesFromDevices(vmStruct));
            vm.setInterfaces(VdsBrokerObjectsBuilder.BuildVmNetworkInterfacesFromDevices(vmStruct));
            for (DiskImage diskImage : vm.getImages()) {
                vm.getDiskMap().put(Guid.newGuid(), diskImage);
            }
            getVdsEventListener().importHostedEngineVm(vm, getVdsManager().getVdsGroupId());
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#method_after
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmUpdater : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmUpdater.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmUpdater.getDbVm().getId(), vdsManager.getVdsName());
            ResourceManager.getInstance().RerunFailedCommand(vmUpdater.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmUpdater.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmUpdater.getDbVm().getId());
            succeededToRunVms.add(vmUpdater.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmUpdater.isAutoVmToRun() && !vmUpdater.isRerun()) {
            autoVmsToRun.add(vmUpdater.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmUpdater.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmUpdater.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmUpdater.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmUpdater.getVdsmVm().getVmDynamic().getId());
        }
        if (vmUpdater.isMovedToDown()) {
            movedToDownVms.add(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isRemoveFromAsync()) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isHostedEngineUnmanaged()) {
            // @since 3.6 - we take existing HE VM and reimport it
            importHostedEngineVM(getVmInfo(Collections.singletonList(vmUpdater.getVdsmVm().getVmDynamic().getId().toString()))[0]);
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                if (vmDynamicToSave.containsKey(pair.getFirst().getId())) {
                    vmDynamicToSave.get(pair.getFirst().getId()).setHash(pair.getSecond().getVmDynamic().getHash());
                } else {
                    addVmDynamicToList(pair.getSecond().getVmDynamic());
                }
                vmsToUpdate.add(pair.getSecond().getVmDynamic().getId().toString());
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // this ensure the vmManager lock is taken
                if (vmDynamicToSave.containsKey(vmId)) {
                    vmDynamicToSave.get(vmId).setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                // its a hosted engine VM -> import it and skip the external VM phase
                importHostedEngineVM(vmInfo);
                continue;
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#method_after
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    if (vmsToUpdate.isEmpty()) {
        return;
    }
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#end_block

#method_before
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    return (Map[]) (getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate)).getReturnValue());
}
#method_after
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map[] result = {};
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#end_block

#method_before
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            vmStatic.getInterfaces().add(buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap));
        }
    }
    return vmStatic;
}
#method_after
private static VmStatic buildVmStaticDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    if (!xmlRpcStruct.containsKey(VdsProperties.vm_guid) || !xmlRpcStruct.containsKey(VdsProperties.vm_name) || !xmlRpcStruct.containsKey(VdsProperties.mem_size_mb) || !xmlRpcStruct.containsKey(VdsProperties.num_of_cpus)) {
        return null;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(Guid.createGuidFromString((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    vmStatic.setName((String) xmlRpcStruct.get(VdsProperties.vm_name));
    vmStatic.setMemSizeMb(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.mem_size_mb)));
    vmStatic.setNumOfSockets(parseIntVdsProperty(xmlRpcStruct.get(VdsProperties.num_of_cpus)));
    vmStatic.setCustomCpuName((String) xmlRpcStruct.get(VdsProperties.cpu_model));
    vmStatic.setCustomEmulatedMachine((String) xmlRpcStruct.get(VdsProperties.emulatedMachine));
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        for (Object disk : (Object[]) xmlRpcStruct.get(VdsProperties.vm_disks)) {
            Map<String, Object> diskMap = (Map<String, Object>) disk;
            if (VdsProperties.Disk.equals(diskMap.get(VdsProperties.type))) {
                DiskImage image = buildDiskImageFromExternalProvider(diskMap);
                vmStatic.getImages().add(image);
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NETWORKS)) {
        for (Object networkMap : (Object[]) xmlRpcStruct.get(VdsProperties.NETWORKS)) {
            vmStatic.getInterfaces().add(buildNetworkInterfaceFromExternalProvider((Map<String, Object>) networkMap));
        }
    }
    return vmStatic;
}
#end_block

#method_before
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#method_after
private static void UpdatePackagesVersions(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setVersionName(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setSoftwareVersion(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setBuildName(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.containsKey(VdsProperties.host_os)) {
        vds.setHostOs(GetPackageVersionFormated((Map<String, Object>) xmlRpcStruct.get(VdsProperties.host_os), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.get(VdsProperties.packages)) {
            Map<String, Object> hostPackage = (Map<String, Object>) hostPackageMap;
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setKvmVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setSpiceVersion(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setKernelVersion(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.packages2)) {
        Map<String, Object> packages = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map<String, Object> vdsm = (Map<String, Object>) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map<String, Object> kvm = (Map<String, Object>) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setKvmVersion(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map<String, Object> libvirt = (Map<String, Object>) packages.get(VdsProperties.libvirtPackageName);
            vds.setLibvirtVersion(getPackageRpmVersion("libvirt", libvirt));
        }
        if (packages.containsKey(VdsProperties.librbdPackageName)) {
            Map<String, Object> librbd1 = (Map<String, Object>) packages.get(VdsProperties.librbdPackageName);
            vds.setLibrbdVersion(getPackageRpmVersion(VdsProperties.librbdPackageName, librbd1));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map<String, Object> spice = (Map<String, Object>) packages.get(VdsProperties.spiceServerPackageName);
            vds.setSpiceVersion(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map<String, Object> kernel = (Map<String, Object>) packages.get(VdsProperties.kernelPackageName);
            vds.setKernelVersion(getPackageVersionFormated2(kernel));
        }
        if (packages.containsKey(VdsProperties.GLUSTER_PACKAGE_NAME)) {
            Map<String, Object> gluster = (Map<String, Object>) packages.get(VdsProperties.GLUSTER_PACKAGE_NAME);
            vds.setGlusterVersion(getPackageRpmVersion("glusterfs", gluster));
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isPartOfBond()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
    updateV2VJobs(vds, xmlRpcStruct);
}
#end_block

#method_before
private static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.error("Illegal Vm status: '{}'.", statusName);
        }
    }
    return status;
}
#method_after
public static VMStatus convertToVmStatus(String statusName) {
    VMStatus status = VMStatus.Unassigned;
    // EnumUtils as other states below.
    if ("Running".equals(statusName) || "Unknown".equals(statusName)) {
        status = VMStatus.Up;
    } else if ("Migration Source".equals(statusName)) {
        status = VMStatus.MigratingFrom;
    } else if ("Migration Destination".equals(statusName)) {
        status = VMStatus.MigratingTo;
    } else {
        try {
            statusName = statusName.replace(" ", "");
            status = EnumUtils.valueOf(VMStatus.class, statusName, true);
        } catch (Exception e) {
            log.error("Illegal Vm status: '{}'.", statusName);
        }
    }
    return status;
}
#end_block

#method_before
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setActiveNic(AssignStringValue(xmlRpcStruct, VdsProperties.NETWORK_LAST_CLIENT_INTERFACE));
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#method_after
public static void updateNetworkData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNetworkInterface> oldInterfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(vds.getId());
    vds.getInterfaces().clear();
    addHostNetworkInterfaces(vds, xmlRpcStruct);
    addHostVlanDevices(vds, xmlRpcStruct);
    addHostBondDevices(vds, xmlRpcStruct);
    addHostNetworksAndUpdateInterfaces(vds, xmlRpcStruct);
    // set bonding options
    setBondingOptions(vds, oldInterfaces);
    // This information was added in 3.1, so don't use it if it's not there.
    if (xmlRpcStruct.containsKey(VdsProperties.netConfigDirty)) {
        vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS host, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    final String hostActiveNicName = findActiveNicName(host, bridges);
    host.setActiveNic(hostActiveNicName);
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(host.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(host.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        host.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, host, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, host, iface);
                    }
                }
                host.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, host);
            }
        }
    }
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            // store the locked managers to finally release them at the end of the cycle
            vmManagers.put(vmId, vmManager);
            return true;
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (!vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId())) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
                vmManager.unlock();
            } else if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.unlock();
    }
}
#method_after
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.updateVmDataChangedTime();
        vmManager.unlock();
    }
}
#end_block

#method_before
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> pair : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(pair)) {
            VmAnalyzer vmAnalyzer = new VmAnalyzer(pair.getFirst(), pair.getSecond(), this, auditLogDirector);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#method_after
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#end_block

#method_before
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmUpdater : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmUpdater.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmUpdater.getDbVm().getId(), vdsManager.getVdsName());
            ResourceManager.getInstance().RerunFailedCommand(vmUpdater.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmUpdater.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmUpdater.getDbVm().getId());
            succeededToRunVms.add(vmUpdater.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmUpdater.isAutoVmToRun() && !vmUpdater.isRerun()) {
            autoVmsToRun.add(vmUpdater.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmUpdater.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmUpdater.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmUpdater.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmUpdater.getVdsmVm().getVmDynamic().getId());
        }
        if (vmUpdater.isMovedToDown()) {
            movedToDownVms.add(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isRemoveFromAsync()) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isHostedEngineUnmanaged()) {
            Map vmStruct = getVmInfo(Collections.singletonList(vmUpdater.getVdsmVm().getVmDynamic().getId().toString()))[0];
            VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(vmStruct);
            vm.setImages(VdsBrokerObjectsBuilder.BuildDiskImagesFromDevices(vmStruct));
            vm.setInterfaces(VdsBrokerObjectsBuilder.BuildVmNetworkInterfacesFromDevices(vmStruct));
            for (DiskImage diskImage : vm.getImages()) {
                vm.getDiskMap().put(Guid.newGuid(), diskImage);
            }
            getVdsEventListener().importHostedEngineVm(vm, getVdsManager().getVdsGroupId());
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#method_after
private void afterVMsRefreshTreatment() {
    Collection<Guid> movedToDownVms = new ArrayList<>();
    List<Guid> succeededToRunVms = new ArrayList<>();
    // now loop over the result and act
    for (VmAnalyzer vmUpdater : vmAnalyzers) {
        // rerun all vms from rerun list
        if (vmUpdater.isRerun()) {
            log.error("Rerun VM '{}'. Called from VDS '{}'", vmUpdater.getDbVm().getId(), vdsManager.getVdsName());
            ResourceManager.getInstance().RerunFailedCommand(vmUpdater.getDbVm().getId(), vdsManager.getVdsId());
        }
        if (vmUpdater.isSuccededToRun()) {
            vdsManager.succeededToRunVm(vmUpdater.getDbVm().getId());
            succeededToRunVms.add(vmUpdater.getDbVm().getId());
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        if (vmUpdater.isAutoVmToRun() && !vmUpdater.isRerun()) {
            autoVmsToRun.add(vmUpdater.getDbVm().getId());
        }
        // process all vms that their ip changed.
        if (vmUpdater.isClientIpChanged()) {
            final VmDynamic vmDynamic = vmUpdater.getVdsmVm().getVmDynamic();
            getVdsEventListener().processOnClientIpChange(vmDynamic.getId(), vmDynamic.getClientIp());
        }
        // process all vms that powering up.
        if (vmUpdater.isPoweringUp()) {
            getVdsEventListener().processOnVmPoweringUp(vmUpdater.getVdsmVm().getVmDynamic().getId());
        }
        if (vmUpdater.isMovedToDown()) {
            movedToDownVms.add(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isRemoveFromAsync()) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vmUpdater.getDbVm().getId());
        }
        if (vmUpdater.isHostedEngineUnmanaged()) {
            // @since 3.6 - we take existing HE VM and reimport it
            importHostedEngineVM(getVmInfo(Collections.singletonList(vmUpdater.getVdsmVm().getVmDynamic().getId().toString()))[0]);
        }
    }
    getVdsEventListener().updateSlaPolicies(succeededToRunVms, vdsManager.getVdsId());
    // run all vms that crashed that marked with auto startup
    getVdsEventListener().runFailedAutoStartVMs(autoVmsToRun);
    // process all vms that went down
    getVdsEventListener().processOnVmStop(movedToDownVms, vdsManager.getVdsId());
    getVdsEventListener().refreshHostIfAnyVmHasHostDevices(succeededToRunVms, vdsManager.getVdsId());
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                if (vmDynamicToSave.containsKey(pair.getFirst().getId())) {
                    vmDynamicToSave.get(pair.getFirst().getId()).setHash(pair.getSecond().getVmDynamic().getHash());
                } else {
                    addVmDynamicToList(pair.getSecond().getVmDynamic());
                }
                vmsToUpdate.add(pair.getSecond().getVmDynamic().getId().toString());
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // this ensure the vmManager lock is taken
                if (vmDynamicToSave.containsKey(vmId)) {
                    vmDynamicToSave.get(vmId).setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                // its a hosted engine VM -> import it and skip the external VM phase
                importHostedEngineVM(vmInfo);
                continue;
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#method_after
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    if (vmsToUpdate.isEmpty()) {
        return;
    }
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#end_block

#method_before
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    return (Map[]) (getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate)).getReturnValue());
}
#method_after
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map[] result = {};
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    final List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values(), false);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                for (LunDisk lunDisk : lunDisks) {
                    ImagesHandler.removeLunDisk(lunDisk);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return getVm().isHostedEngine() || failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return (getVm().isHostedEngine() && isInternalExecution()) || failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__REMOVE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
private boolean canRemoveVmWithDetachDisks() {
    if (!Guid.Empty.equals(getVm().getVmtGuid())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_WITH_DETACH_DISKS_BASED_ON_TEMPLATE);
    }
    for (Disk disk : getVm().getDiskList()) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
        if (diskImageList.size() > 1) {
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_WITH_DETACH_DISKS_SNAPSHOTS_EXIST);
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmWithDetachDisks() {
    if (!Guid.Empty.equals(getVm().getVmtGuid())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_WITH_DETACH_DISKS_BASED_ON_TEMPLATE);
    }
    for (Disk disk : getVm().getDiskList()) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
        if (diskImageList.size() > 1) {
            return failCanDoAction(EngineMessage.VM_CANNOT_REMOVE_WITH_DETACH_DISKS_SNAPSHOTS_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
protected void removeVmFromDb() {
    removeLunDisks();
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
    removeIcons();
}
#method_after
protected void removeVmFromDb() {
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
    removeIcons();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVmPool().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, getVmPoolIsBeingCreatedMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVmPool().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL_NAME, getVmPoolIsBeingCreatedMessage()));
}
#end_block

#method_before
private VmPoolType getVmPoolType() {
    if (getVm().getVmPoolId() == null) {
        return null;
    }
    VmPool pool = getVmPoolDao().get(getVm().getVmPoolId());
    if (pool == null) {
        return null;
    } else {
        return pool.getVmPoolType();
    }
}
#method_after
private VmPoolType getVmPoolType() {
    VmPool pool = getVmPoolCached();
    return (pool != null) ? pool.getVmPoolType() : null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    applyNextRunConfiguration();
    boolean removedStatelessSnapshot = detachUsers();
    if (!removedStatelessSnapshot && !templateVersionChanged) {
        // If template version didn't change, and we are dealing with a prestarted Vm
        // or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand \ updateVmVersionCommand->RemoveVmCommand
        removeVmStatelessImages();
    }
    getQuotaManager().rollbackQuotaByVmId(getVmId());
    removeStatelessVmUnmanagedDevices();
    boolean vmHasDirectPassthroughDevices = releaseUsedHostDevices();
    Guid hostId = cleanupVfs();
    // Only single dedicated host allowed for host devices, verified on canDoActions
    Guid alternativeHostsList = vmHasDirectPassthroughDevices ? getVm().getDedicatedVmForVdsList().get(0) : null;
    refreshHostIfNeeded(hostId == null ? alternativeHostsList : hostId);
}
#method_after
@Override
protected void executeCommand() {
    boolean removingVmPool = isRemovingVmPool();
    if (!removingVmPool) {
        applyNextRunConfiguration();
        boolean removedStatelessSnapshot = detachUsers();
        if (!removedStatelessSnapshot && !templateVersionChanged) {
            // If template version didn't change, and we are dealing with a prestarted Vm
            // or a regular Vm - clean stateless images
            // Otherwise this was already done in DetachUserFromVmFromPoolCommand \ updateVmVersionCommand->RemoveVmCommand
            removeVmStatelessImages();
        }
    }
    getQuotaManager().rollbackQuotaByVmId(getVmId());
    if (!removingVmPool) {
        removeStatelessVmUnmanagedDevices();
        boolean vmHasDirectPassthroughDevices = releaseUsedHostDevices();
        Guid hostId = cleanupVfs();
        // Only single dedicated host allowed for host devices, verified on canDoActions
        Guid alternativeHostsList = vmHasDirectPassthroughDevices ? getVm().getDedicatedVmForVdsList().get(0) : null;
        refreshHostIfNeeded(hostId == null ? alternativeHostsList : hostId);
    }
}
#end_block

#method_before
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDao().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        // if not, check if new version or need to restore stateless
        if (!templateVersionChanged) {
            // if template version was changed, no need to restore
            runInternalActionWithTasksContext(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), getLock());
        }
        return true;
    }
    if (VmPoolType.Automatic.equals(getVmPoolType())) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId(), !templateVersionChanged), getLock());
        }
        return true;
    }
    return false;
}
#method_after
private boolean detachUsers() {
    // check if this is a VM from a VM pool
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    List<DbUser> users = getDbUserDao().getAllForVm(getVmId());
    // check if this VM is attached to a user
    if (users == null || users.isEmpty()) {
        // if not, check if new version or need to restore stateless
        if (!templateVersionChanged) {
            // if template version was changed, no need to restore
            runInternalActionWithTasksContext(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), getLock());
        }
        return true;
    }
    if (getVmPoolType() == VmPoolType.Automatic) {
        // should be only one user in the collection
        for (DbUser dbUser : users) {
            runInternalActionWithTasksContext(VdcActionType.DetachUserFromVmFromPool, new DetachUserFromVmFromPoolParameters(getVm().getVmPoolId(), dbUser.getId(), getVmId(), !templateVersionChanged), getLock());
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private void removeVmStatelessImages() {
    if (getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS) && !VmPoolType.Manual.equals(getVmPoolType())) {
        log.info("Deleting snapshot for stateless vm '{}'", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#method_after
private void removeVmStatelessImages() {
    if (getSnapshotDao().exists(getVmId(), SnapshotType.STATELESS) && getVmPoolType() != VmPoolType.Manual) {
        log.info("Deleting snapshot for stateless vm '{}'", getVmId());
        runInternalAction(VdcActionType.RestoreStatelessVm, new VmOperationParameterBase(getVmId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    }
}
#end_block

#method_before
@Before
public void setUp() {
    parameters = new StorageDomainManagementParameter(getStorageDomain());
    parameters.setVdsId(Guid.newGuid());
    parameters.setStoragePoolId(Guid.newGuid());
    command = spy(new AddExistingFileStorageDomainCommand<>(parameters));
    command.setStoragePool(getStoragePool());
    CommandMocks.mockDbFacade(command, dbFacade);
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDAO();
    doReturn(false).when(command).isStorageWithSameNameExists();
    doNothing().when(command).addStorageDomainInDb();
    doNothing().when(command).updateStorageDomainDynamicFromIrs();
    when(command.getVdsDAO().getAllForStoragePoolAndStatus(any(Guid.class), eq(VDSStatus.Up))).thenReturn(getHosts());
    when(command.getStoragePoolDAO().get(any(Guid.class))).thenReturn(getStoragePool());
}
#method_after
@Before
public void setUp() {
    parameters = new StorageDomainManagementParameter(getStorageDomain());
    parameters.setVdsId(Guid.newGuid());
    parameters.setStoragePoolId(Guid.newGuid());
    command = spy(new AddExistingFileStorageDomainCommand<>(parameters));
    command.setStoragePool(getStoragePool());
    CommandMocks.mockDbFacade(command, dbFacade);
    doReturn(vdsDao).when(command).getVdsDao();
    doReturn(storagePoolDao).when(command).getStoragePoolDao();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doReturn(false).when(command).isStorageWithSameNameExists();
    doNothing().when(command).addStorageDomainInDb();
    doNothing().when(command).updateStorageDomainDynamicFromIrs();
    when(command.getVdsDao().getAllForStoragePoolAndStatus(any(Guid.class), eq(VDSStatus.Up))).thenReturn(getHosts());
    when(command.getStoragePoolDao().get(any(Guid.class))).thenReturn(getStoragePool());
}
#end_block

#method_before
@Test
public void testAddExistingSuccessfully() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(null);
    StorageDomainStatic sdStatic = command.getStorageDomain().getStorageStaticData();
    doReturn(new Pair<>(sdStatic, sdStatic.getId())).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
}
#method_after
@Test
public void testAddExistingSuccessfully() {
    when(command.getStorageDomainStaticDao().get(any(Guid.class))).thenReturn(null);
    StorageDomainStatic sdStatic = command.getStorageDomain().getStorageStaticData();
    doReturn(new Pair<>(sdStatic, sdStatic.getId())).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
}
#end_block

#method_before
@Test
public void testAlreadyExistStorageDomain() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(parameters.getStorageDomain());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
}
#method_after
@Test
public void testAlreadyExistStorageDomain() {
    when(command.getStorageDomainStaticDao().get(any(Guid.class))).thenReturn(parameters.getStorageDomain());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
}
#end_block

#method_before
@Test
public void testNonExistingStorageDomain() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(null);
    doReturn(null).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#method_after
@Test
public void testNonExistingStorageDomain() {
    when(command.getStorageDomainStaticDao().get(any(Guid.class))).thenReturn(null);
    doReturn(null).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testSwitchStorageDomainType() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(null);
    StorageDomainStatic sdStatic = command.getStorageDomain().getStorageStaticData();
    doReturn(new Pair<>(sdStatic, sdStatic.getId())).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testSwitchStorageDomainType() {
    when(command.getStorageDomainStaticDao().get(any(Guid.class))).thenReturn(null);
    StorageDomainStatic sdStatic = command.getStorageDomain().getStorageStaticData();
    doReturn(new Pair<>(sdStatic, sdStatic.getId())).when(command).executeHSMGetStorageDomainInfo(any(HSMGetStorageDomainInfoVDSCommandParameters.class));
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (lunsOnStorage.isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_PROBLEM_WITH_CANDIDATE_INFO);
    }
    if (CollectionUtils.containsAny(Entities.getIds(lunsOnStorage), Entities.getIds(getAllLuns()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    if (getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    List<LUNs> lunsOnStorage = getLUNsFromVgInfo(getStorageDomain().getStorage());
    if (lunsOnStorage.isEmpty()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROBLEM_WITH_CANDIDATE_INFO);
    }
    if (CollectionUtils.containsAny(Entities.getIds(lunsOnStorage), Entities.getIds(getAllLuns()))) {
        log.info("There are existing luns in the system which are part of VG id '{}'", getStorageDomain().getStorage());
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMPORT_STORAGE_DOMAIN_EXTERNAL_LUN_DISK_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getStorageDomainId() != null) {
        return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getStorageDomainId() != null) {
        return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
@Before
public void setUp() {
    parameters = new StorageDomainManagementParameter(getStorageDomain());
    parameters.setVdsId(Guid.newGuid());
    command = spy(new AddExistingBlockStorageDomainCommand<>(parameters));
    doReturn(dbFacade).when(command).getDbFacade();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDAO();
    doNothing().when(command).addStorageDomainInDb();
    doNothing().when(command).updateStorageDomainDynamicFromIrs();
    doNothing().when(command).saveLUNsInDB(anyList());
}
#method_after
@Before
public void setUp() {
    parameters = new StorageDomainManagementParameter(getStorageDomain());
    parameters.setVdsId(Guid.newGuid());
    command = spy(new AddExistingBlockStorageDomainCommand<>(parameters));
    doReturn(dbFacade).when(command).getDbFacade();
    doReturn(storageDomainStaticDao).when(command).getStorageDomainStaticDao();
    doNothing().when(command).addStorageDomainInDb();
    doNothing().when(command).updateStorageDomainDynamicFromIrs();
    doNothing().when(command).saveLUNsInDB(anyListOf(LUNs.class));
}
#end_block

#method_before
@Test
public void testAddExistingBlockDomainSuccessfully() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(null);
    when(command.getLUNsFromVgInfo(parameters.getStorageDomain().getStorage())).thenReturn(getLUNs());
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
}
#method_after
@Test
public void testAddExistingBlockDomainSuccessfully() {
    doReturn(getLUNs()).when(command).getLUNsFromVgInfo(parameters.getStorageDomain().getStorage());
    command.executeCommand();
    assertTrue(command.getReturnValue().getSucceeded());
}
#end_block

#method_before
@Test
public void testAddExistingBlockDomainWhenVgInfoReturnsEmptyLunList() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(null);
    List<LUNs> luns = new ArrayList<>();
    when(command.getLUNsFromVgInfo(parameters.getStorageDomain().getStorage())).thenReturn(luns);
    assertFalse("Could not connect to Storage Domain", command.canAddDomain());
    assertTrue("Import block Storage Domain should have failed due to empty Lun list returned from VGInfo ", command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_PROBLEM_WITH_CANDIDATE_INFO.toString()));
}
#method_after
@Test
public void testAddExistingBlockDomainWhenVgInfoReturnsEmptyLunList() {
    doReturn(Collections.emptyList()).when(command).getLUNsFromVgInfo(parameters.getStorageDomain().getStorage());
    assertFalse("Could not connect to Storage Domain", command.canAddDomain());
    assertTrue("Import block Storage Domain should have failed due to empty Lun list returned from VGInfo ", command.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_PROBLEM_WITH_CANDIDATE_INFO.toString()));
}
#end_block

#method_before
@Test
public void testAlreadyExistStorageDomain() {
    when(command.getStorageDomainStaticDAO().get(any(Guid.class))).thenReturn(getStorageDomain());
    assertFalse("Storage Domain already exists", command.canAddDomain());
    assertTrue("Import block Storage Domain should have failed due to already existing Storage Domain", command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST.toString()));
}
#method_after
@Test
public void testAlreadyExistStorageDomain() {
    when(command.getStorageDomainStaticDao().get(any(Guid.class))).thenReturn(getStorageDomain());
    assertFalse("Storage Domain already exists", command.canAddDomain());
    assertTrue("Import block Storage Domain should have failed due to already existing Storage Domain", command.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST.toString()));
}
#end_block

#method_before
private static List<LUNs> getLUNs() {
    List<LUNs> luns = new ArrayList<>();
    LUNs lun = new LUNs();
    lun.setId(Guid.newGuid().toString());
    luns.add(lun);
    return luns;
}
#method_after
private static List<LUNs> getLUNs() {
    LUNs lun = new LUNs();
    lun.setId(Guid.newGuid().toString());
    return Collections.singletonList(lun);
}
#end_block

#method_before
protected boolean checkExistingStorageDomain() {
    if (getStorageDomainStaticDAO().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId()));
    if (domainFromIrs == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    StorageDomain storageDomainFromIrs = new StorageDomain();
    storageDomainFromIrs.setStorageStaticData(domainFromIrs.getFirst());
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#method_after
protected boolean checkExistingStorageDomain() {
    if (getStorageDomainStaticDao().get(getStorageDomain().getId()) != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_EXIST);
    }
    Pair<StorageDomainStatic, Guid> domainFromIrs = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getStorageDomain().getId()));
    if (domainFromIrs == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    StorageDomain storageDomainFromIrs = new StorageDomain();
    storageDomainFromIrs.setStorageStaticData(domainFromIrs.getFirst());
    return concreteCheckExistingStorageDomain(domainFromIrs);
}
#end_block

#method_before
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, Guid> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = (StringUtils.equals(domainFromIrs.getConnection().getconnection(), getStorageDomain().getStorageStaticData().getConnection().getconnection()));
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#method_after
protected boolean concreteCheckExistingStorageDomain(Pair<StorageDomainStatic, Guid> domain) {
    boolean returnValue = false;
    StorageDomainStatic domainFromIrs = domain.getFirst();
    if (StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && StringUtils.isEmpty(domainFromIrs.getStorage()) && domainFromIrs.getConnection() != null && getStorageDomain().getStorageStaticData().getConnection() != null) {
        returnValue = (StringUtils.equals(domainFromIrs.getConnection().getconnection(), getStorageDomain().getStorageStaticData().getConnection().getconnection()));
    } else if (!StringUtils.isEmpty(getStorageDomain().getStorageStaticData().getStorage()) && !StringUtils.isEmpty(domainFromIrs.getStorage())) {
        returnValue = (StringUtils.equals(domainFromIrs.getStorage(), getStorageDomain().getStorageStaticData().getStorage()));
    }
    if (!returnValue) {
        addCanDoActionMessage(EngineMessage.ERROR_CANNOT_ADD_EXISTING_STORAGE_DOMAIN_CONNECTION_DATA_ILLEGAL);
    }
    return returnValue;
}
#end_block

#method_before
// SPM tasks report their final status to the spawning command's parent (in this case, us)
// rather than the spawning command (ie DestroyImageCommand); therefore, we must redirect
private void handleAnyChildSPMTaskCompletion(boolean succeeded) {
    if (getParameters().getCommandStep() != RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        return;
    }
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    if (!Guid.isNullOrEmpty(currentChildId)) {
        CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
        if (command != null && cmdEntity != null && !cmdEntity.isCallbackNotified()) {
            if (!succeeded) {
                command.getParameters().setTaskGroupSuccess(false);
            }
            Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
            if (succeeded && CommandCoordinatorUtil.getCommandEntity(currentChildId) != null) {
                CommandCoordinatorUtil.getCommandEntity(currentChildId).setCallbackNotified(true);
            }
        }
    }
}
#method_after
// SPM tasks report their final status to the spawning command's parent (in this case, us)
// rather than the spawning command (ie DestroyImageCommand); therefore, we must redirect
private void handleAnyChildSPMTaskCompletion(boolean succeeded) {
    if (getParameters().getCommandStep() != RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        return;
    }
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    if (!Guid.isNullOrEmpty(currentChildId)) {
        CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
        if (command != null && cmdEntity != null && !cmdEntity.isCallbackNotified()) {
            if (!succeeded) {
                command.getParameters().setTaskGroupSuccess(false);
            }
            Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
            if (succeeded && cmdEntity != null) {
                cmdEntity.setCallbackNotified(true);
            }
        }
    }
}
#end_block

#method_before
private void handleAnyChildSPMTaskCompletion(boolean succeeded) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.isEmpty()) {
        return;
    }
    Guid currentChildId = childCommandIds.get(0);
    log.info("Handling child command {} completion", currentChildId);
    if (!Guid.isNullOrEmpty(currentChildId)) {
        CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
        if (command != null && cmdEntity != null && !cmdEntity.isCallbackNotified()) {
            if (!succeeded) {
                command.getParameters().setTaskGroupSuccess(false);
            }
            Backend.getInstance().endAction(VdcActionType.ExtendImageSize, command.getParameters(), cloneContextAndDetachFromParent());
            if (succeeded && CommandCoordinatorUtil.getCommandEntity(currentChildId) != null) {
                CommandCoordinatorUtil.getCommandEntity(currentChildId).setCallbackNotified(true);
            }
        }
    }
}
#method_after
private void handleAnyChildSPMTaskCompletion(boolean succeeded) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.isEmpty()) {
        return;
    }
    Guid currentChildId = childCommandIds.get(0);
    log.info("Handling child command {} completion", currentChildId);
    if (!Guid.isNullOrEmpty(currentChildId)) {
        CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
        if (command != null && cmdEntity != null && !cmdEntity.isCallbackNotified()) {
            if (!succeeded) {
                command.getParameters().setTaskGroupSuccess(false);
            }
            Backend.getInstance().endAction(VdcActionType.ExtendImageSize, command.getParameters(), cloneContextAndDetachFromParent());
            if (succeeded && cmdEntity != null) {
                cmdEntity.setCallbackNotified(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VdcQueryReturnValue res = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getDev().getVmId()));
    if (res.getSucceeded()) {
        List<GraphicsDevice> devices = res.getReturnValue();
        for (GraphicsDevice device : devices) {
            if (device.getGraphicsType().equals(getParameters().getDev().getGraphicsType())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONLY_ONE_DEVICE_WITH_THIS_GRAPHICS_ALLOWED);
            }
        }
        return true;
    }
    return false;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VdcQueryReturnValue res = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getDev().getVmId()));
    if (res.getSucceeded()) {
        List<GraphicsDevice> devices = res.getReturnValue();
        for (GraphicsDevice device : devices) {
            if (device.getGraphicsType().equals(getParameters().getDev().getGraphicsType())) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ONLY_ONE_DEVICE_WITH_THIS_GRAPHICS_ALLOWED);
            }
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                if (vmDynamicToSave.containsKey(pair.getFirst().getId())) {
                    vmDynamicToSave.get(pair.getFirst().getId()).setHash(pair.getSecond().getVmDynamic().getHash());
                } else {
                    addVmDynamicToList(pair.getSecond().getVmDynamic());
                }
                vmsToUpdate.add(pair.getSecond().getVmDynamic().getId().toString());
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // this ensure the vmManager lock is taken
                if (vmDynamicToSave.containsKey(vmId)) {
                    vmDynamicToSave.get(vmId).setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#method_after
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    if (vmsToUpdate.isEmpty()) {
        return;
    }
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#end_block

#method_before
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    return (Map[]) (new FullListVdsCommand<FullListVDSCommandParameters>(new FullListVDSCommandParameters(vds, vmsToUpdate)).executeWithReturnValue());
}
#method_after
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map[] result = {};
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        if (vdsmVmDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(dbVm.getDynamicData());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                    vmsMonitoring.addVmGuestAgentNics(dbVm.getId(), vdsmVm.getVmGuestAgentInterfaces());
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        if (vdsmVmDynamic != null) {
            if (dbVm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vdsmVm.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vdsmVmDynamic.getGuestAgentNicsHash()) {
                    if (vmDynamicToSave == null) {
                        saveDynamic(dbVm.getDynamicData());
                    }
                    updateGuestAgentInterfacesChanges(vmDynamicToSave, vmGuestAgentInterfaces, guestAgentNicHash);
                }
            }
        }
    }
}
#end_block

#method_before
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
}
#method_after
/**
 * * Helpers and sub-methods ***
 */
private void updateGuestAgentInterfacesChanges(VmDynamic vmDynamic, List<VmGuestAgentInterface> vmGuestAgentInterfaces, int guestAgentNicHash) {
    vmDynamic.setGuestAgentNicsHash(guestAgentNicHash);
    vmDynamic.setVmIp(extractVmIpsFromGuestAgentInterfaces(vmGuestAgentInterfaces));
    vmsMonitoring.addVmGuestAgentNics(dbVm.getId(), vmGuestAgentInterfaces);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    return validate(validator.isUp());
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    return validate(validator.isUp());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__SYNC);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__STORAGE_DEVICE);
    addCanDoActionMessageVariable("VdsName", getVds().getName());
}
#method_after
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(EngineMessage.VAR__ACTION__SYNC);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__STORAGE_DEVICE);
    addCanDoActionMessageVariable("VdsName", getVds().getName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (VdcBLLException e) {
        log.error("Could not {} {} Hosted Engine HA maintenance mode on host '{}'", params.getIsEnabled() ? "enable" : "disable", params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#method_after
@Override
protected void executeCommand() {
    boolean succeeded = false;
    SetHaMaintenanceParameters params = getParameters();
    try {
        succeeded = runVdsCommand(VDSCommandType.SetHaMaintenanceMode, new SetHaMaintenanceModeVDSCommandParameters(getVds(), params.getMode(), params.getIsEnabled())).getSucceeded();
    } catch (EngineException e) {
        log.error("Could not {} {} Hosted Engine HA maintenance mode on host '{}'", params.getIsEnabled() ? "enable" : "disable", params.getMode().name().toLowerCase(), getVdsName());
    }
    getReturnValue().setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    HostValidator hostValidator = new HostValidator(getVds());
    if (!validate(hostValidator.exists()) || !validate(hostValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (!getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    HostValidator hostValidator = new HostValidator(getVds());
    if (!validate(hostValidator.hostExists()) || !validate(hostValidator.isUp())) {
        return false;
    }
    if (getVds().getVdsGroupCompatibilityVersion().compareTo(Version.v3_4) < 0) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_HA_MAINT_NOT_SUPPORTED);
    }
    if (!getVds().getHighlyAvailableIsConfigured()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_HA_NOT_CONFIGURED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM__CLUSTER);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        succeeded = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(getVds(), getVdsGroup().isEnableBallooning(), getVdsGroup().isEnableKsm(), getVdsGroup().isKsmMergeAcrossNumaNodes())).getSucceeded();
    } catch (VdcBLLException e) {
        log.error("Could not update MoM policy on host '{}': {}", getVdsName(), e.getMessage());
        log.debug("Exception", e);
    }
    getReturnValue().setSucceeded(succeeded);
}
#method_after
@Override
protected void executeCommand() {
    boolean succeeded = false;
    try {
        succeeded = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(getVds(), getVdsGroup().isEnableBallooning(), getVdsGroup().isEnableKsm(), getVdsGroup().isKsmMergeAcrossNumaNodes())).getSucceeded();
    } catch (EngineException e) {
        log.error("Could not update MoM policy on host '{}': {}", getVdsName(), e.getMessage());
        log.debug("Exception", e);
    }
    getReturnValue().setSucceeded(succeeded);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    HostValidator hostValidator = new HostValidator(getVds());
    return validate(hostValidator.exists()) && validate(hostValidator.isUp()) && validate(validateMinimumVersionSupport());
}
#method_after
@Override
protected boolean canDoAction() {
    HostValidator hostValidator = new HostValidator(getVds());
    return validate(hostValidator.hostExists()) && validate(hostValidator.isUp()) && validate(validateMinimumVersionSupport());
}
#end_block

#method_before
private ValidationResult validateMinimumVersionSupport() {
    return FeatureSupported.momPolicyOnHost(getVdsGroup().getCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MOM_UPDATE_VDS_VERSION);
}
#method_after
private ValidationResult validateMinimumVersionSupport() {
    return FeatureSupported.momPolicyOnHost(getVdsGroup().getCompatibilityVersion()) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_MOM_UPDATE_VDS_VERSION);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST);
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
}
#end_block

#method_before
public ValidationResult validateStatus(VDSStatus vdsStatus, VdcBllMessages hostStatus) {
    return vdsStatus == host.getStatus() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, hostStatus.toString());
}
#method_after
private ValidationResult validateStatus(VDSStatus hostStatus) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL).unless(hostStatus == host.getStatus());
}
#end_block

#method_before
public ValidationResult hostExists() {
    return ValidationResult.failWith(VdcBllMessages.VDS_INVALID_SERVER_ID).when(getHost() == null);
}
#method_after
public ValidationResult hostExists() {
    return ValidationResult.failWith(EngineMessage.VDS_INVALID_SERVER_ID).when(getHost() == null);
}
#end_block

#method_before
public ValidationResult nameNotEmpty() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY).when(StringUtils.isEmpty(host.getName()));
}
#method_after
public ValidationResult nameNotEmpty() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY).when(StringUtils.isEmpty(host.getName()));
}
#end_block

#method_before
public ValidationResult nameLengthIsLegal() {
    int maxHostNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG).when(host.getName().length() > maxHostNameLength);
}
#method_after
public ValidationResult nameLengthIsLegal() {
    int maxHostNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG).when(host.getName().length() > maxHostNameLength);
}
#end_block

#method_before
public ValidationResult hostNameIsValid() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME).unless(ValidationUtils.validHostname(host.getHostName()));
}
#method_after
public ValidationResult hostNameIsValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME).unless(ValidationUtils.validHostname(host.getHostName()));
}
#end_block

#method_before
public ValidationResult nameNotUsed() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED).when(hostDao.getByName(host.getName()) != null);
}
#method_after
public ValidationResult nameNotUsed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED).when(hostDao.getByName(host.getName()) != null);
}
#end_block

#method_before
public ValidationResult hostNameNotUsed() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST).unless(hostDao.getAllForHostname(host.getHostName()).isEmpty());
}
#method_after
public ValidationResult hostNameNotUsed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST).unless(hostDao.getAllForHostname(host.getHostName()).isEmpty());
}
#end_block

#method_before
public ValidationResult portIsValid() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT).unless(ValidationUtils.validatePort(host.getSshPort()));
}
#method_after
public ValidationResult portIsValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT).unless(ValidationUtils.validatePort(host.getSshPort()));
}
#end_block

#method_before
public ValidationResult sshUserNameNotEmpty() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME).when(StringUtils.isBlank(host.getSshUsername()));
}
#method_after
public ValidationResult sshUserNameNotEmpty() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME).when(StringUtils.isBlank(host.getSshUsername()));
}
#end_block

#method_before
public ValidationResult validateSingleHostAttachedToLocalStorage() {
    StoragePool storagePool = storagePoolDao.getForVdsGroup(host.getVdsGroupId());
    if (storagePool == null || !storagePool.isLocal()) {
        return ValidationResult.VALID;
    }
    return ValidationResult.failWith(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE).unless(hostStaticDao.getAllForVdsGroup(host.getVdsGroupId()).isEmpty());
}
#method_after
public ValidationResult validateSingleHostAttachedToLocalStorage() {
    StoragePool storagePool = storagePoolDao.getForVdsGroup(host.getVdsGroupId());
    if (storagePool == null || !storagePool.isLocal()) {
        return ValidationResult.VALID;
    }
    return ValidationResult.failWith(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE).unless(hostStaticDao.getAllForVdsGroup(host.getVdsGroupId()).isEmpty());
}
#end_block

#method_before
public ValidationResult securityKeysExists() {
    return ValidationResult.failWith(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND).when(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !haveSecurityKey());
}
#method_after
public ValidationResult securityKeysExists() {
    return ValidationResult.failWith(EngineMessage.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND).when(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !haveSecurityKey());
}
#end_block

#method_before
public ValidationResult passwordNotEmpty(boolean addPending, AuthenticationMethod authMethod, String password) {
    return ValidationResult.failWith(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD).when(!addPending && authMethod == AuthenticationMethod.Password && StringUtils.isEmpty(password));
}
#method_after
public ValidationResult passwordNotEmpty(boolean addPending, AuthenticationMethod authMethod, String password) {
    return ValidationResult.failWith(EngineMessage.VDS_CANNOT_INSTALL_EMPTY_PASSWORD).when(!addPending && authMethod == AuthenticationMethod.Password && StringUtils.isEmpty(password));
}
#end_block

#method_before
public ValidationResult validateStatusForActivation() {
    ValidationResult existsValidation = exists();
    if (!existsValidation.isValid()) {
        return existsValidation;
    }
    if (VDSStatus.Up == host.getStatus()) {
        return new ValidationResult(VdcBllMessages.VDS_ALREADY_UP);
    }
    if (VDSStatus.NonResponsive == host.getStatus()) {
        return new ValidationResult(VdcBllMessages.VDS_NON_RESPONSIVE);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateStatusForActivation() {
    ValidationResult existsValidation = hostExists();
    if (!existsValidation.isValid()) {
        return existsValidation;
    }
    if (VDSStatus.Up == host.getStatus()) {
        return new ValidationResult(EngineMessage.VDS_ALREADY_UP);
    }
    if (VDSStatus.NonResponsive == host.getStatus()) {
        return new ValidationResult(EngineMessage.VDS_NON_RESPONSIVE);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateUniqueId() {
    if (StringUtils.isBlank(host.getUniqueId()) && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        return new ValidationResult(VdcBllMessages.VDS_NO_UUID);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateUniqueId() {
    return ValidationResult.failWith(EngineMessage.VDS_NO_UUID).when(StringUtils.isBlank(host.getUniqueId()) && Config.<Boolean>getValue(ConfigValues.InstallVds));
}
#end_block

#method_before
public ValidationResult isUp() {
    return validateStatus(VDSStatus.Up, VdcBllMessages.VAR__HOST_STATUS__UP);
}
#method_after
public ValidationResult isUp() {
    return validateStatus(VDSStatus.Up);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDAO().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDao().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    HostValidator validator = new HostValidator(getVds());
    return validate(validator.exists()) && validate(validator.validateStatusForActivation()) && validate(validator.validateUniqueId());
}
#method_after
@Override
protected boolean canDoAction() {
    HostValidator validator = new HostValidator(getVds());
    return validate(validator.hostExists()) && validate(validator.validateStatusForActivation()) && validate(validator.validateUniqueId());
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getVdsId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VDS, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ACTIVATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ACTIVATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_BRICK);
    addCanDoActionMessageVariable("brickName", getParameters().getLvName());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__CREATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__GLUSTER_BRICK);
    addCanDoActionMessageVariable("brickName", getParameters().getLvName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!ObjectUtils.objectsEqual(deviceType, device.getDevType())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addCanDoActionMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    HostValidator validator = new HostValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!ObjectUtils.objectsEqual(deviceType, device.getDevType())) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addCanDoActionMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locksMap = new HashMap<>();
    for (StorageDevice disk : getParameters().getDisks()) {
        locksMap.put(disk.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.HOST_STORAGE_DEVICES, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DEVICE_LOCKED));
    }
    return locksMap;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> locksMap = new HashMap<>();
    for (StorageDevice disk : getParameters().getDisks()) {
        locksMap.put(disk.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.HOST_STORAGE_DEVICES, EngineMessage.ACTION_TYPE_FAILED_STORAGE_DEVICE_LOCKED));
    }
    return locksMap;
}
#end_block

#method_before
private void updatePanelsVisibility(ImportVmsModel model) {
    exportPanel.setVisible(model.getImportSources().getSelectedItem() == ImportSource.EXPORT_DOMAIN);
    vmwarePanel.setVisible(model.getImportSources().getSelectedItem() == ImportSource.VMWARE);
    providersEditor.setVisible(model.getImportSources().getSelectedItem() == ImportSource.VMWARE);
}
#method_after
private void updatePanelsVisibility(ImportVmsModel model) {
    exportPanel.setVisible(model.getImportSources().getSelectedItem() == ImportSource.EXPORT_DOMAIN);
    vmwarePanel.setVisible(model.getImportSources().getSelectedItem() == ImportSource.VMWARE);
    vmwareProvidersEditor.setVisible(model.getImportSources().getSelectedItem() == ImportSource.VMWARE);
}
#end_block

#method_before
private void vmwareProviderChanged() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = (VmwareVmProviderProperties) provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    getVmwareDatacenter().setEntity(properties.getDataCenter());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#method_after
private void vmwareProviderChanged() {
    Provider<VmwareVmProviderProperties> provider = getVmwareProviders().getSelectedItem();
    if (provider == null) {
        provider = new Provider<>();
        provider.setAdditionalProperties(new VmwareVmProviderProperties());
    }
    getUsername().setEntity(provider.getUsername());
    getPassword().setEntity(provider.getPassword());
    VmwareVmProviderProperties properties = (VmwareVmProviderProperties) provider.getAdditionalProperties();
    getvCenter().setEntity(properties.getvCenter());
    getEsx().setEntity(properties.getEsx());
    getVmwareDatacenter().setEntity(properties.getDataCenter());
    getVerify().setEntity(properties.isVerifySSL());
    if (properties.getProxyHostId() == null) {
        getProxyHosts().setSelectedItem(null);
    } else {
        for (VDS host : getProxyHosts().getItems()) {
            if (host != null && host.getId().equals(properties.getProxyHostId())) {
                getProxyHosts().setSelectedItem(host);
                break;
            }
        }
    }
}
#end_block

#method_before
private void loadProviders() {
    ProviderType providerType = getProviderType();
    if (providerType == null) {
        return;
    }
    AsyncDataProvider.getInstance().getAllProvidersByType(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Provider<?>> providers = new ArrayList<Provider<?>>();
            for (Provider provider : (List<Provider>) returnValue) {
                VmwareVmProviderProperties properties = (VmwareVmProviderProperties) provider.getAdditionalProperties();
                if (getDataCenters().getSelectedItem().getId().equals(properties.getStoragePoolId())) {
                    providers.add(provider);
                }
            }
            providers.add(0, null);
            getProviders().setItems(providers);
        }
    }), providerType);
}
#method_after
private void loadProviders() {
    switch(importSources.getSelectedItem()) {
        case VMWARE:
            loadVmwareProviders();
            break;
        default:
    }
}
#end_block

#method_before
private boolean validateVmwareConfiguration() {
    getvCenter().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getEsx().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getVmwareDatacenter().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    return getvCenter().getIsValid() && getEsx().getIsValid() && getVmwareDatacenter().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#method_after
private boolean validateVmwareConfiguration() {
    getvCenter().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getEsx().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getVmwareDatacenter().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation(), new NameAndOptionalDomainValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    return getvCenter().getIsValid() && getEsx().getIsValid() && getVmwareDatacenter().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#end_block

#method_before
public static String getVmwareUrl(String username, String vcenter, String dataCenter, String esx, boolean verify) {
    return // $NON-NLS-1$
    "vpx://" + // $NON-NLS-1$ //$NON-NLS-2$
    (StringUtils.isEmpty(username) ? "" : username + "@") + vcenter + // $NON-NLS-1$
    "/" + dataCenter + // $NON-NLS-1$
    "/" + esx + // $NON-NLS-1$ //$NON-NLS-2$
    (verify ? "" : "?no_verify=1");
}
#method_after
public static String getVmwareUrl(String username, String vcenter, String dataCenter, String esx, boolean verify) {
    if (username != null) {
        // $NON-NLS-1$ //$NON-NLS-2$
        username = username.replace("@", "%40");
    }
    return // $NON-NLS-1$
    "vpx://" + // $NON-NLS-1$ //$NON-NLS-2$
    (StringUtils.isEmpty(username) ? "" : username + "@") + vcenter + // $NON-NLS-1$
    "/" + dataCenter + // $NON-NLS-1$
    "/" + esx + // $NON-NLS-1$ //$NON-NLS-2$
    (verify ? "" : "?no_verify=1");
}
#end_block

#method_before
protected void localize() {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    detachableInstanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isIoThreadsEnabled.setLabel(constants.ioThreadsEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    consoleDisconnectActionEditor.setLabel(constants.consoleDisconnectActionVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // priority
    priorityEditor.setLabel(constants.priority());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    numOfIoThreadsEditor.setLabel(constants.numOfIoThreadsVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
    // Icon tab
    iconTab.setLabel(constants.iconTabVmPopup());
}
#method_after
protected void localize() {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    detachableInstanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isIoThreadsEnabled.setLabel(constants.ioThreadsEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    consoleDisconnectActionEditor.setLabel(constants.consoleDisconnectActionVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // priority
    priorityEditor.setLabel(constants.priorityVm());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    numOfIoThreadsEditor.setLabel(constants.numOfIoThreadsVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
    // Icon tab
    iconTab.setLabel(constants.iconTabVmPopup());
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException)
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    else
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateSharedLockMessage()));
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        locks.put(image.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, getDiskSharedLockMessage()));
    }
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    locks.put(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateSharedLockMessage()));
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        locks.put(image.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, getDiskSharedLockMessage()));
    }
    if (getParameters().getPoolId() != null) {
        locks.put(getParameters().getPoolId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_POOL, getPoolSharedLockMessage()));
    }
    return locks;
}
#end_block

#method_before
private String getTemplateSharedLockMessage() {
    return new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
}
#method_after
private String getTemplateSharedLockMessage() {
    return new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
}
#end_block

#method_before
protected String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#method_after
protected String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean hostToRunExist() {
    List<Guid> dedicatedHostsList = getParameters().getVmStaticData().getDedicatedVmForVdsList();
    if (dedicatedHostsList.isEmpty()) {
        return true;
    }
    for (Guid candidateHostGuid : dedicatedHostsList) {
        if (DbFacade.getInstance().getVdsDao().get(candidateHostGuid) == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean hostToRunExist() {
    List<Guid> dedicatedHostsList = getParameters().getVmStaticData().getDedicatedVmForVdsList();
    if (dedicatedHostsList.isEmpty()) {
        return true;
    }
    for (Guid candidateHostGuid : dedicatedHostsList) {
        if (DbFacade.getInstance().getVdsDao().get(candidateHostGuid) == null) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#method_after
protected boolean buildAndCheckDestStorageDomains() {
    boolean retValue = true;
    if (diskInfoDestinationMap.isEmpty()) {
        retValue = fillDestMap();
    } else {
        retValue = validateProvidedDestinations();
    }
    if (retValue && getImagesToCheckDestinationStorageDomains().size() != diskInfoDestinationMap.size()) {
        log.error("Can not find any default active domain for one of the disks of template with id '{}'", vmDisksSource.getId());
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        retValue = false;
    }
    return retValue && validateIsImagesOnDomains();
}
#end_block

#method_before
protected boolean validateIsImagesOnDomains() {
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        if (!image.getStorageIds().containsAll(diskInfoDestinationMap.get(image.getId()).getStorageIds())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validateIsImagesOnDomains() {
    for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
        if (!image.getStorageIds().containsAll(diskInfoDestinationMap.get(image.getId()).getStorageIds())) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name, storagePoolId)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected static boolean isLegalClusterId(Guid clusterId, List<String> reasons) {
    // check given cluster id
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(clusterId);
    boolean legalClusterId = (vdsGroup != null);
    if (!legalClusterId) {
        reasons.add(VdcBllErrors.VM_INVALID_SERVER_CLUSTER_ID.toString());
    }
    return legalClusterId;
}
#method_after
protected static boolean isLegalClusterId(Guid clusterId, List<String> reasons) {
    // check given cluster id
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(clusterId);
    boolean legalClusterId = (vdsGroup != null);
    if (!legalClusterId) {
        reasons.add(EngineError.VM_INVALID_SERVER_CLUSTER_ID.toString());
    }
    return legalClusterId;
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(ImagesHandler.filterDisksBasedOnCinder(templateDisks));
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new EngineException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(ImagesHandler.filterDisksBasedOnCinder(templateDisks));
    }
    return true;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GraphicsDevice dev = getParameters().getDev();
    if (dev.getDeviceId() == null || dev.getVmId() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_REMOVE_GRAPHICS_DEV_INVALID_PARAMS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GraphicsDevice dev = getParameters().getDev();
    if (dev.getDeviceId() == null || dev.getVmId() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_REMOVE_GRAPHICS_DEV_INVALID_PARAMS);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getVdsGroup().getStoragePoolId())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getVdsGroup().getStoragePoolId())) {
                    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM_TEMPLATE);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.hasMemoryBalloon(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVdsGroup().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(EngineMessage.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemlateWithSameNameExist(getVmTemplateName(), getVdsGroup().getStoragePoolId())) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(EngineMessage.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected boolean isDisksAliasNotEmpty() {
    // Check that all the template's allocated disk's aliases are not an empty string.
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (StringUtils.isEmpty(diskImage.getDiskAlias())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_CANNOT_BE_CREATED_WITH_EMPTY_DISK_ALIAS);
        }
    }
    return true;
}
#method_after
protected boolean isDisksAliasNotEmpty() {
    // Check that all the template's allocated disk's aliases are not an empty string.
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        if (StringUtils.isEmpty(diskImage.getDiskAlias())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_CANNOT_BE_CREATED_WITH_EMPTY_DISK_ALIAS);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#method_after
protected void addVmTemplateImage(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, DiskImage diskImage) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!retValue.getSucceeded()) {
        throw new EngineException(retValue.getFault().getError(), retValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
    DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM_TEMPLATE);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isTemplateVersion()) {
        return Collections.singletonMap(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return super.getSharedLocks();
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isTemplateVersion()) {
        return Collections.singletonMap(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return super.getSharedLocks();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GraphicsDevice dev = getParameters().getDev();
    if (dev == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DEVICE_MUST_BE_SPECIFIED);
    }
    if (getParameters().isVm() && getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!getParameters().isVm() && getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (dev.getGraphicsType() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GRAPHIC_TYPE_MUST_BE_SPECIFIED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GraphicsDevice dev = getParameters().getDev();
    if (dev == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DEVICE_MUST_BE_SPECIFIED);
    }
    if (getParameters().isVm() && getVm() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!getParameters().isVm() && getVmTemplate() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (dev.getGraphicsType() == null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_GRAPHIC_TYPE_MUST_BE_SPECIFIED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
    }
    return null;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_VM_IS_BEING_UPDATED));
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork hostNetwork : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (hostNetwork.isBonding()) {
            attributes.put("bonding", hostNetwork.getNicName());
        } else {
            attributes.put("nic", hostNetwork.getNicName());
        }
        if (hostNetwork.isVlan()) {
            attributes.put("vlan", hostNetwork.getVlan().toString());
        }
        if (hostNetwork.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu().toString());
        } else {
            attributes.put(VdsProperties.MTU, String.valueOf(hostNetwork.getMtu()));
        }
        attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
        if (hostNetwork.isVmNetwork()) {
            attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
        }
        if (hostNetwork.getBootProtocol() != null) {
            addBootProtocol(attributes, hostNetwork);
        }
        if (hostNetwork.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (hostNetwork.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported() && hostNetwork.isQosConfiguredOnInterface()) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
            qosMapper.serialize(hostNetwork.getQos());
        }
        networks.put(hostNetwork.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork attachment : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (attachment.isBonding()) {
            attributes.put("bonding", attachment.getNicName());
        } else {
            attributes.put("nic", attachment.getNicName());
        }
        if (attachment.isVlan()) {
            attributes.put("vlan", attachment.getVlan().toString());
        }
        if (attachment.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu().toString());
        } else {
            attributes.put(VdsProperties.MTU, String.valueOf(attachment.getMtu()));
        }
        attributes.put("bridged", Boolean.toString(attachment.isVmNetwork()));
        if (attachment.isVmNetwork()) {
            attributes.put(VdsProperties.STP, attachment.isStp() ? "yes" : "no");
        }
        if (attachment.getBootProtocol() != null) {
            addBootProtocol(attributes, attachment);
        }
        if (attachment.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (attachment.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, attachment.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported()) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(attributes, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(new NetworkQoS());
        }
        networks.put(attachment.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(new HostSetupNetworksParameters(host.getId()), Collections.singletonList(existingNic), Collections.<NetworkAttachment>emptyList(), new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(new HostSetupNetworksParameters(host.getId()), Collections.singletonList(existingNic), Collections.<NetworkAttachment>emptyList(), new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    Guid idOfInexistingInterface = Guid.newGuid();
    params.setRemovedBonds(Collections.singleton(idOfInexistingInterface));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).build();
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), // TODO MM: fix variable replacements in translations patch.
    failsWith(VdcBllMessages.NETWORK_BOND_NOT_EXISTS));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    Guid idOfInexistingInterface = Guid.newGuid();
    params.setRemovedBonds(Collections.singleton(idOfInexistingInterface));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).build();
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), // TODO MM: fix variable replacements in translations patch.
    failsWith(EngineMessage.NETWORK_BOND_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenBondIsUnnamed() throws Exception {
    doTestValidModifiedBonds(new Bond(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenBondIsUnnamed() throws Exception {
    doTestValidModifiedBonds(new Bond(), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    // this was added just because of DI issues with 'Backend.getInstance().getErrorsTranslator()' is 'spyed' method
    // noinspection unchecked
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#method_after
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    // this was added just because of DI issues with 'Backend.getInstance().getErrorsTranslator()' is 'spyed' method
    // noinspection unchecked
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#end_block

#method_before
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    bond.setSlaves(Arrays.asList(nicA.getName(), nicB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    params.setBonds(Collections.singletonList(bond));
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setExistingAttachments(Collections.<NetworkAttachment>emptyList()).setParams(params).setExistingInterfaces(Arrays.asList(nicA, nicB)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).setHost(host).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, CoreMatchers.not(isValid()));
    assertThat(validate, failsWith(VdcBllMessages.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME_ENTITY, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#method_after
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    bond.setSlaves(Arrays.asList(nicA.getName(), nicB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    params.setBonds(Collections.singletonList(bond));
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setExistingAttachments(Collections.<NetworkAttachment>emptyList()).setParams(params).setExistingInterfaces(Arrays.asList(nicA, nicB)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).setHost(host).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, CoreMatchers.not(isValid()));
    assertThat(validate, failsWith(EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME, ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME_ENTITY, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#method_after
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(VdcBllMessages.NETWORK_BOND_NAME_BAD_FORMAT, bondName);
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, bondName);
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName = new MapNetworkAttachments(removedNetworkAttachments).byNicName();
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        boolean noNetworkOnInterfaceOrItsVlan = interfaceOrItsVlanDoesNotHaveNetworkOrOneIsAboutToBeRemovedFromIt(removedNetworkAttachmentsByNicName, potentialSlave);
        if (!noNetworkOnInterfaceOrItsVlan) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
        }
        ValidationResult networkCannotBeAttachedToSlaveValidationResult = networkBeingAttachedToInterfaceBecomingSlave(potentialSlave);
        if (!networkCannotBeAttachedToSlaveValidationResult.isValid()) {
            return networkCannotBeAttachedToSlaveValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName = new MapNetworkAttachments(removedNetworkAttachments).byNicName();
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        boolean noNetworkOnInterfaceOrItsVlan = interfaceOrItsVlanDoesNotHaveNetworkOrOneIsAboutToBeRemovedFromIt(removedNetworkAttachmentsByNicName, potentialSlave);
        if (!noNetworkOnInterfaceOrItsVlan) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
        }
        ValidationResult networkCannotBeAttachedToSlaveValidationResult = networkBeingAttachedToInterfaceBecomingSlave(potentialSlave);
        if (!networkCannotBeAttachedToSlaveValidationResult.isValid()) {
            return networkCannotBeAttachedToSlaveValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult networkBeingAttachedToInterfaceBecomingSlave(VdsNetworkInterface potentialSlave) {
    for (NetworkAttachment networkAttachment : this.params.getNetworkAttachments()) {
        Guid networkAttachmentsNicId = networkAttachment.getNicId();
        String networkAttachmentsNicName = networkAttachment.getNicName();
        if (networkAttachmentsNicId != null && networkAttachmentsNicId.equals(potentialSlave.getId()) || networkAttachmentsNicName != null && networkAttachmentsNicName.equals(potentialSlave.getName())) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME, ReplacementUtils.createSetVariableString(NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME_ENTITY, potentialSlave.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult networkBeingAttachedToInterfaceBecomingSlave(VdsNetworkInterface potentialSlave) {
    for (NetworkAttachment networkAttachment : this.params.getNetworkAttachments()) {
        Guid networkAttachmentsNicId = networkAttachment.getNicId();
        String networkAttachmentsNicName = networkAttachment.getNicName();
        if (networkAttachmentsNicId != null && networkAttachmentsNicId.equals(potentialSlave.getId()) || networkAttachmentsNicName != null && networkAttachmentsNicName.equals(potentialSlave.getName())) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME, ReplacementUtils.createSetVariableString(NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME_ENTITY, potentialSlave.getName()), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, networkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private boolean interfaceDoesNotHaveNetworkOrOneIsAboutToBeRemovedFromIt(Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName, VdsNetworkInterface potentialSlave) {
    String slaveNetworkName = potentialSlave.getNetworkName();
    boolean slaveHadNetworkAttached = slaveNetworkName != null;
    if (slaveHadNetworkAttached) {
        boolean attachmentBoundToNicBecomingSlaveRemoved = removedNetworkAttachmentsByNicName.containsKey(potentialSlave.getName());
        Guid slaveNetworkId = networkBusinessEntityMap.get(slaveNetworkName).getId();
        NetworkAttachment attachmentRelevantToSlaveNetwork = networkAttachmentsByNetworkId.get(slaveNetworkId);
        boolean networkBoundToNicBecomingSlaveMovedToAnotherNic = attachmentRelevantToSlaveNetwork != null && (!Objects.equals(attachmentRelevantToSlaveNetwork.getNicId(), potentialSlave.getId()) && !Objects.equals(attachmentRelevantToSlaveNetwork.getNicName(), potentialSlave.getName()));
        boolean slaveStillHasNetworkAttached = !(attachmentBoundToNicBecomingSlaveRemoved || networkBoundToNicBecomingSlaveMovedToAnotherNic);
        if (slaveStillHasNetworkAttached) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean interfaceDoesNotHaveNetworkOrOneIsAboutToBeRemovedFromIt(Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName, VdsNetworkInterface potentialSlave) {
    String slaveNetworkName = potentialSlave.getNetworkName();
    boolean slaveHadNetworkAttached = slaveNetworkName != null;
    if (slaveHadNetworkAttached) {
        boolean attachmentBoundToNicBecomingSlaveRemoved = removedNetworkAttachmentsByNicName.containsKey(potentialSlave.getName());
        if (!attachmentBoundToNicBecomingSlaveRemoved) {
            return false;
        }
        Guid slaveNetworkId = networkBusinessEntityMap.get(slaveNetworkName).getId();
        NetworkAttachment attachmentRelevantToSlaveNetwork = networkAttachmentsByNetworkId.get(slaveNetworkId);
        boolean networkBoundToNicBecomingSlaveMovedToAnotherNic = attachmentRelevantToSlaveNetwork != null && (!Objects.equals(attachmentRelevantToSlaveNetwork.getNicId(), potentialSlave.getId()) && !Objects.equals(attachmentRelevantToSlaveNetwork.getNicName(), potentialSlave.getName()));
        if (!networkBoundToNicBecomingSlaveMovedToAnotherNic) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = attachment.getId() != null;
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
        }
    }
    return vr;
}
#method_after
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = attachment.getId() != null;
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId, networkId, networkName, VdcBllMessages.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#method_after
private ValidationResult validateCoherentNetworkIdentification(NetworkAttachment attachment) {
    Guid networkId = attachment.getNetworkId();
    String networkName = attachment.getNetworkName();
    Guid violatingEntityId = attachment.getId();
    return validateCoherentIdentification(violatingEntityId, networkId, networkName, EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NETWORK_INCOHERENTLY, networkBusinessEntityMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId(), attachment.getNicId(), attachment.getNicName(), VdcBllMessages.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentIdentification(attachment.getId(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    VdcBllMessages message = VdcBllMessages.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentIdentification(bond.getId(), nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentIdentification(bond.getId(), nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private <T extends BusinessEntity<Guid> & Nameable> ValidationResult validateCoherentIdentification(Guid violatingEntityId, Guid nicId, String nicName, VdcBllMessages message, BusinessEntityMap<T> map) {
    boolean bothIdentificationSet = nicId != null && nicName != null;
    String[] replacements = createIncoherentIdentificationErrorReplacements(violatingEntityId, nicId, nicName);
    return ValidationResult.failWith(message, replacements).when(bothIdentificationSet && isNicNameAndNicIdIncoherent(nicId, nicName, map));
}
#method_after
private <T extends BusinessEntity<Guid> & Nameable> ValidationResult validateCoherentIdentification(Guid violatingEntityId, Guid referringId, String referringName, EngineMessage message, BusinessEntityMap<T> map) {
    boolean bothIdentificationSet = referringId != null && referringName != null;
    String[] replacements = createIncoherentIdentificationErrorReplacements(violatingEntityId, referringId, referringName);
    return ValidationResult.failWith(message, replacements).when(bothIdentificationSet && isNameAndIdIncoherent(referringId, referringName, map));
}
#end_block

#method_before
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String targetNicName = attachment.getNicName();
    boolean attachmentReferencesExistingNic = existingInterfacesMap.get(attachment.getNicId(), targetNicName) != null;
    if (attachmentReferencesExistingNic) {
        return ValidationResult.VALID;
    }
    boolean attachmentReferencesNewlyCreatedBond = targetNicName != null && bondsMap.get(targetNicName) != null;
    if (attachmentReferencesNewlyCreatedBond) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String targetNicName = attachment.getNicName();
    boolean attachmentReferencesExistingNic = existingInterfacesMap.get(attachment.getNicId(), targetNicName) != null;
    if (attachmentReferencesExistingNic) {
        return ValidationResult.VALID;
    }
    boolean attachmentReferencesNewlyCreatedBond = targetNicName != null && bondsMap.get(targetNicName) != null;
    if (attachmentReferencesNewlyCreatedBond) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    /*
        When attachment is related to labeled network and bond being removed, it's considered to be valid,
        because with disappearance of bond its label also disappears, so technically we cannot detach such network,
        since it shouldn't be present there anyways.
        * */
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    /*
        When attachment is related to labeled network and bond being removed, it's considered to be valid,
        because with disappearance of bond its label also disappears, so technically we cannot detach such network,
        since it shouldn't be present there anyways.
        * */
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter completer = new NicNameNicIdCompleter(getExistingNics());
    completer.completeNetworkAttachments(getParameters().getNetworkAttachments());
    completer.completeBonds(getParameters().getBonds());
    completer.completeNetworkAttachments(getExistingAttachments());
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    if (host == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    if (!hostStatusLegalForSetupNetworks(host)) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        return false;
    }
    NicNameNicIdCompleter completer = new NicNameNicIdCompleter(getExistingNics());
    completer.completeNetworkAttachments(getParameters().getNetworkAttachments());
    completer.completeNetworkAttachments(getParameters().getRemovedNetworkAttachments());
    completer.completeBonds(getParameters().getBonds());
    completer.completeBonds(getParameters().getRemovedBonds());
    completer.completeNetworkAttachments(getExistingAttachments());
    validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap());
    FailingValidationResults<String> validationResults = validator.validate();
    if (!validationResults.isValid()) {
        List<String> validationMessages = validationResults.translateToListOfViolationMessagesWithCausesString();
        for (String msg : validationMessages) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    if (!checkForOutOfSyncNetworks()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    BusinessEntityMap<VdsNetworkInterface> existingNicsBusinessEntityMap = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = existingNicsBusinessEntityMap.get(existingNetworkAttachment.getNicId());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            boolean networkMoved = networkMoved(networkAttachment, existingNetworkAttachment);
            VdcBllMessages message = networkMoved ? VdcBllMessages.MOVING_NETWORKS_MAKES_IT_OUT_OF_SYNC : VdcBllMessages.NETWORKS_NOT_IN_SYNC;
            return new ValidationResult(message, "NETWORK_NOT_IN_SYNC", network.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
private boolean checkForOutOfSyncNetworks() {
    BusinessEntityMap<VdsNetworkInterface> existingNicsBusinessEntityMap = getExistingNicsBusinessEntityMap();
    boolean success = true;
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = existingNicsBusinessEntityMap.get(existingNetworkAttachment.getNicId());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            boolean networkMoved = networkMoved(networkAttachment, existingNetworkAttachment);
            addCanDoActionMessage(networkMoved ? VdcBllMessages.MOVING_NETWORKS_MAKES_IT_OUT_OF_SYNC : VdcBllMessages.NETWORKS_NOT_IN_SYNC);
            addCanDoActionMessageVariable("NETWORK_NOT_IN_SYNC", network.getName());
            success = false;
        }
    }
    return success;
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworks(), getAllNetworksToRemove(), getParameters().getBonds(), getRemovedBonds());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#end_block

#method_before
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getVdsGroupId()) && ipConfiguration != null && (ipConfiguration.getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#method_after
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return NetworkUtils.isManagementNetwork(network) && ipConfiguration != null && (ipConfiguration.getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getGateway()));
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty() && getRemovedUnmanagedNetworks().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getNetworks().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBonds().isEmpty() && getRemovedUnmanagedNetworks().isEmpty();
}
#end_block

#method_before
private List<VdsNetworkInterface> getRemovedBonds() {
    if (removedBonds == null) {
        Set<Guid> removedBondIds = getParameters().getRemovedBonds();
        removedBonds = Entities.filterEntitiesByRequiredIds(removedBondIds, getExistingNics());
    }
    return removedBonds;
}
#method_after
private Set<String> getRemovedBonds() {
    if (removedBonds == null) {
        removedBonds = new HashSet<>(getParameters().getRemovedBonds().size());
        for (Bond bond : getParameters().getRemovedBonds()) {
            removedBonds.add(bond.getName());
        }
    }
    return removedBonds;
}
#end_block

#method_before
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        List<NetworkAttachment> removedNetworkAttachments = Entities.filterEntitiesByRequiredIds(getParameters().getRemovedNetworkAttachments(), existingAttachments);
        removedNetworks = new HashSet<>(removedNetworkAttachments.size());
        for (NetworkAttachment attachment : removedNetworkAttachments) {
            removedNetworks.add(existingNetworkRelatedToAttachment(attachment).getName());
        }
    }
    return removedNetworks;
}
#method_after
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        removedNetworks = new HashSet<>(getParameters().getRemovedNetworkAttachments().size());
        for (NetworkAttachment attachment : getParameters().getRemovedNetworkAttachments()) {
            removedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()).getName());
        }
    }
    return removedNetworks;
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> userConfiguredNics = new ArrayList<>();
    userConfiguredNics.addAll(getParameters().getBonds());
    for (VdsNetworkInterface existingBondToRemove : getRemovedBonds()) {
        existingBondToRemove.setLabels(null);
        userConfiguredNics.add(existingBondToRemove);
    }
    return userConfiguredNics;
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> userConfiguredNics = new ArrayList<>();
    userConfiguredNics.addAll(getParameters().getBonds());
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(getExistingNics());
    for (VdsNetworkInterface removedBond : getParameters().getRemovedBonds()) {
        VdsNetworkInterface existingBondToRemove = existingNics.get(removedBond.getName());
        existingBondToRemove.setLabels(null);
        userConfiguredNics.add(existingBondToRemove);
    }
    return userConfiguredNics;
}
#end_block

#method_before
private List<Network> getModifiedNetworks() {
    if (modifiedNetworks == null) {
        List<NetworkAttachment> networkAttachments = getParameters().getNetworkAttachments();
        modifiedNetworks = new ArrayList<>(networkAttachments.size());
        for (NetworkAttachment attachment : networkAttachments) {
            modifiedNetworks.add(existingNetworkRelatedToAttachment(attachment));
        }
    }
    return modifiedNetworks;
}
#method_after
private List<Network> getModifiedNetworks() {
    List<Network> modifiedNetworks = new ArrayList<>(getParameters().getNetworkAttachments().size());
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        modifiedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()));
    }
    return modifiedNetworks;
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
            // save the new network topology to DB
            hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getModifiedNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
            // save the new network topology to DB
            HostNetworkTopologyPersisterImpl.getInstance().persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getModifiedNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#end_block

#method_before
private BusinessEntityMap<Network> getNetworkBusinessEntityMap() {
    if (networkBusinessEntityMap == null) {
        List<Network> networks = getNetworkDao().getAllForCluster(getVdsGroupId());
        networkBusinessEntityMap = new BusinessEntityMap<>(networks);
    }
    return networkBusinessEntityMap;
}
#method_after
private BusinessEntityMap<Network> getNetworkBusinessEntityMap() {
    if (networkBusinessEntityMap == null) {
        List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroupId());
        networkBusinessEntityMap = new BusinessEntityMap<>(networks);
    }
    return networkBusinessEntityMap;
}
#end_block

#method_before
public Set<Guid> getRemovedNetworkAttachments() {
    return removedNetworkAttachments;
}
#method_after
public List<NetworkAttachment> getRemovedNetworkAttachments() {
    return removedNetworkAttachments;
}
#end_block

#method_before
public void setRemovedNetworkAttachments(Set<Guid> removedNetworkAttachments) {
    this.removedNetworkAttachments = removedNetworkAttachments;
}
#method_after
public void setRemovedNetworkAttachments(List<NetworkAttachment> removedNetworkAttachments) {
    this.removedNetworkAttachments = removedNetworkAttachments;
}
#end_block

#method_before
public Set<Guid> getRemovedBonds() {
    return removedBonds;
}
#method_after
public List<Bond> getRemovedBonds() {
    return removedBonds;
}
#end_block

#method_before
public void setRemovedBonds(Set<Guid> removedBonds) {
    this.removedBonds = removedBonds;
}
#method_after
public void setRemovedBonds(List<Bond> removedBonds) {
    this.removedBonds = removedBonds;
}
#end_block

#method_before
private Map<String, Object> assertBondWasSent(VdsNetworkInterface bond, List<VdsNetworkInterface> slaves) {
    Map bondingStruct = bondingCaptor.getValue();
    Map<String, Object> bondMap = (Map<String, Object>) bondingStruct.get(bond.getName());
    assertNotNull("Bond " + bond.getName() + " should've been sent but wasn't.", bondMap);
    List<String> nicsInStruct = (List<String>) bondMap.get(SetupNetworksVDSCommand.SLAVES);
    for (VdsNetworkInterface slave : slaves) {
        assertThat("Slave " + slave.getName() + " should've been sent but wasn't.", nicsInStruct, hasItem(slave.getName()));
    }
    return bondMap;
}
#method_after
private Map<String, Object> assertBondWasSent(VdsNetworkInterface bond, List<VdsNetworkInterface> slaves) {
    Map bondingStruct = bondingCaptor.getValue();
    Map<String, Object> bondMap = (Map<String, Object>) bondingStruct.get(bond.getName());
    assertNotNull("Bond " + bond.getName() + " should've been sent but wasn't.", bondMap);
    List<String> nicsInStruct = (List<String>) bondMap.get(SetupNetworksVDSCommand.SLAVES);
    for (VdsNetworkInterface slave : slaves) {
        assertTrue("Slave " + slave.getName() + " should've been sent but wasn't.", nicsInStruct.contains(slave.getName()));
    }
    return bondMap;
}
#end_block

#method_before
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDao vdsStaticDao = mock(VdsStaticDao.class);
    final VdsDao vdsDao = mock(VdsDao.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getVdsDao()).thenReturn(vdsDao);
    when(dbFacade.getHostNetworkQosDao()).thenReturn(qosDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
}
#method_after
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDAO vdsStaticDao = mock(VdsStaticDAO.class);
    final VdsDAO vdsDao = mock(VdsDAO.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getVdsDao()).thenReturn(vdsDao);
    when(dbFacade.getHostNetworkQosDao()).thenReturn(qosDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
}
#end_block

#method_before
public static Map<String, Network> networksByName(List<Network> networks) {
    if (!networks.isEmpty()) {
        Map<String, Network> byName = new HashMap<>();
        for (Network net : networks) {
            byName.put(net.getName(), net);
        }
        return byName;
    } else {
        return Collections.emptyMap();
    }
}
#method_after
public static Map<String, Network> networksByName(List<Network> networks) {
    if (!networks.isEmpty()) {
        Map<String, Network> byName = new HashMap<String, Network>();
        for (Network net : networks) {
            byName.put(net.getName(), net);
        }
        return byName;
    } else {
        return Collections.emptyMap();
    }
}
#end_block

#method_before
public static List<String> filterNonVmNetworkNames(List<Network> networks, Set<String> networkNames) {
    List<String> list = new ArrayList<>();
    for (Network net : networks) {
        if (!net.isVmNetwork() && networkNames.contains(net.getName())) {
            list.add(net.getName());
        }
    }
    return list;
}
#method_after
public static List<String> filterNonVmNetworkNames(List<Network> networks, Set<String> networkNames) {
    List<String> list = new ArrayList<String>();
    for (Network net : networks) {
        if (!net.isVmNetwork() && networkNames.contains(net.getName())) {
            list.add(net.getName());
        }
    }
    return list;
}
#end_block

#method_before
public static boolean qosConfiguredOnInterface(VdsNetworkInterface iface, Network network) {
    if (iface.isQosOverridden()) {
        return iface.getQos() != null && !iface.getQos().isEmpty();
    } else {
        return network != null && network.getQosId() != null;
    }
}
#method_after
public static boolean qosConfiguredOnInterface(VdsNetworkInterface iface, Network network) {
    if (iface.isQosOverridden()) {
        return iface.getQos() != null;
    } else {
        return network != null && network.getQosId() != null;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return appendAttributes(ToStringBuilder.forInstance(this)).build();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", baseInterface=").append(getBaseInterface()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append(" qosOverridden=").append(isQosOverridden()).append(", labels=").append(getLabels()).append(", customProperties=").append(getCustomProperties()).append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("inSync", isInSync()).append("managed", isManaged()).build();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("{inSync=").append(isInSync()).append(", managed=").append(isManaged()).append("}");
    return builder.toString();
}
#end_block

#method_before
public ValidationResult networkExists() {
    return getNetworkValidator().networkIsSet();
}
#method_after
public ValidationResult networkExists() {
    return createNetworkValidator().networkIsSet();
}
#end_block

#method_before
public ValidationResult notRemovingManagementNetwork() {
    return getNetworkValidator().notRemovingManagementNetwork();
}
#method_after
public ValidationResult notRemovingManagementNetwork() {
    return createNetworkValidator().notRemovingManagementNetwork();
}
#end_block

#method_before
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && unsetAddress(ipConfiguration);
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#method_after
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && (ipConfiguration.getAddress() == null || ipConfiguration.getNetmask() == null);
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#end_block

#method_before
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getPrimaryAddress().getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(BusinessEntityMap<VdsNetworkInterface> existingInterfaces) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = existingInterfaces.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()) && !managementNetworkUtil.isManagementNetwork(getNetwork().getId()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#method_after
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && StringUtils.isNotEmpty(ipConfiguration.getGateway()) && !NetworkUtils.isManagementNetwork(getNetwork()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#end_block

#method_before
private boolean networkAttachedToHost() {
    List<VDS> hostsAttachedToNetwork = vdsDao.getAllForNetwork(attachment.getNetworkId());
    for (VDS hostAttachedToNetwork : hostsAttachedToNetwork) {
        if (hostAttachedToNetwork.getId().equals(host.getId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkAttachedToHost() {
    List<VDS> hostsAttachedToNetwork = getDbFacade().getVdsDao().getAllForNetwork(attachment.getNetworkId());
    for (VDS hostAttachedToNetwork : hostsAttachedToNetwork) {
        if (hostAttachedToNetwork.getId().equals(host.getId())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected Network getNetwork() {
    if (network == null) {
        network = networkDao.get(attachment.getNetworkId());
    }
    return network;
}
#method_after
protected Network getNetwork() {
    if (network == null) {
        network = getDbFacade().getNetworkDao().get(attachment.getNetworkId());
    }
    return network;
}
#end_block

#method_before
private NetworkCluster getNetworkCluster() {
    if (networkCluster == null) {
        NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
        networkCluster = networkClusterDao.get(networkClusterId);
    }
    return networkCluster;
}
#method_after
private NetworkCluster getNetworkCluster() {
    if (networkCluster == null) {
        NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), getNetwork().getId());
        networkCluster = getDbFacade().getNetworkClusterDao().get(networkClusterId);
    }
    return networkCluster;
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(createNetworkAttachmentValidator(null).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, new VDS()).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(createNetworkAttachmentValidator(new NetworkAttachment()).networkAttachmentIsSet(), isValid());
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).networkAttachmentIsSet(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    when(networkValidatorMock.networkIsSet()).thenReturn(ValidationResult.VALID);
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), isValid());
}
#method_after
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).networkIsSet();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS, "a"));
}
#end_block

#method_before
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setId(Guid.newGuid());
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(eq(externalNetwork.getId()))).thenReturn(externalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(externalNetwork.getId());
    assertThat(createNetworkAttachmentValidator(attachment).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#method_after
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(any(Guid.class))).thenReturn(externalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#end_block

#method_before
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setId(Guid.newGuid());
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(eq(notExternalNetwork.getId()))).thenReturn(notExternalNetwork);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(notExternalNetwork.getId());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    assertThat(validator.notExternalNetwork(), isValid());
}
#method_after
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(notExternalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(createNetworkAttachmentValidator(new NetworkAttachment()));
    doReturn(networkValidatorMock).when(networkAttachmentValidatorSpy).getNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    when(networkValidatorMock.notRemovingManagementNetwork()).thenReturn(propagatedResult);
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#method_after
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).notRemovingManagementNetwork();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), isValid());
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), network.getId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(null);
    when(networkDaoMock.get(eq(network.getId()))).thenReturn(network);
    assertThat(createNetworkAttachmentValidator(attachment).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    when(networkClusterDaoMock.get(any(NetworkClusterId.class))).thenReturn(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, new VDS());
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    doTestIpConfiguredForStaticBootProtocol(null, "255.255.255.0");
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    doTestIpConfiguredForStaticBootProtocol("192.168.1.1", null);
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    doTestIpConfiguredForStaticBootProtocol("192.168.1.1", "255.255.255.0", isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol bootProtocol, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    IPv4Address primaryAddress = new IPv4Address();
    primaryAddress.setAddress(address);
    primaryAddress.setNetmask(netmask);
    ipConfiguration.getIPv4Addresses().add(primaryAddress);
    ipConfiguration.setBootProtocol(bootProtocol);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#method_after
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol staticIp, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setAddress(address);
    ipConfiguration.setNetmask(netmask);
    ipConfiguration.setBootProtocol(staticIp);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() {
    doTestBootProtocolSetForDisplayNetworkWhenNullValuedIpConfigurationAndWhenNetworkClusterDisplay(true, failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    doTestBootProtocolSetForDisplayNetworkWhenNullValuedIpConfigurationAndWhenNetworkClusterDisplay(true, failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL), network, attachment);
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(createNetworkAttachmentValidator(attachment).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(createNetworkAttachmentValidator(attachment).nicExists(), isValid());
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(createNetworkAttachmentValidator(attachment).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, null);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.singletonList(existingInterface));
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    VDS host = new VDS();
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host);
    BusinessEntityMap<VdsNetworkInterface> nics = new BusinessEntityMap<>(Collections.singletonList(existingInterface));
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(createNetworkAttachmentValidator(null).networkNotChanged(null), isValid());
}
#method_after
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, null).networkNotChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#method_after
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#end_block

#method_before
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotChanged(oldAttachment), isValid());
}
#method_after
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), isValid());
}
#end_block

#method_before
@Test
public void testValidateGateway() throws Exception {
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    doTestValidateGateway("someGateway", false, failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#method_after
@Test
public void testValidateGateway() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.getIpConfiguration().setGateway("someGateway");
    Network network = new Network();
    network.setName("networkName");
    IConfigUtilsInterface iConfigUtilsInterfaceMock = mock(IConfigUtilsInterface.class);
    Config.setConfigUtils(iConfigUtilsInterfaceMock);
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.ManagementNetwork), anyString())).thenReturn("managementNetworkName");
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.MultipleGatewaysSupported), anyString())).thenReturn(false);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.getLast());
    assertThat(new NetworkAttachmentValidator(attachment, host).validateGateway(), failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    Guid networkId = Guid.newGuid();
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(eq(networkId))).thenReturn(Collections.<VDS>emptyList());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), isValid());
}
#method_after
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.<VDS>emptyList());
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), null).networkNotAttachedToHost(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    Guid networkId = Guid.newGuid();
    when(vdsDaoMock.getAllForNetwork(eq(networkId))).thenReturn(Collections.singletonList(host));
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(createNetworkAttachmentValidator(attachment).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#method_after
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.singletonList(host));
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), host).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#end_block

#method_before
@Override
public Guid getId() {
    return id;
}
#method_after
public Guid getId() {
    return id;
}
#end_block

#method_before
@Override
public void setId(Guid id) {
    this.id = id;
}
#method_after
public void setId(Guid id) {
    this.id = id;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getNetworkId(), getNicId());
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((ipConfiguration == null) ? 0 : ipConfiguration.hashCode());
    result = prime * result + ((networkId == null) ? 0 : networkId.hashCode());
    result = prime * result + ((nicId == null) ? 0 : nicId.hashCode());
    result = prime * result + ((nicName == null) ? 0 : nicName.hashCode());
    result = prime * result + ((properties == null) ? 0 : properties.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (!(o instanceof NetworkAttachment))
        return false;
    NetworkAttachment that = (NetworkAttachment) o;
    return Objects.equals(getNetworkId(), that.getNetworkId()) && Objects.equals(getNicId(), that.getNicId());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    NetworkAttachment other = (NetworkAttachment) obj;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (ipConfiguration == null) {
        if (other.ipConfiguration != null)
            return false;
    } else if (!ipConfiguration.equals(other.ipConfiguration))
        return false;
    if (networkId == null) {
        if (other.networkId != null)
            return false;
    } else if (!networkId.equals(other.networkId))
        return false;
    if (nicId == null) {
        if (other.nicId != null)
            return false;
    } else if (!nicId.equals(other.nicId))
        return false;
    if (nicName == null) {
        if (other.nicName != null)
            return false;
    } else if (!nicName.equals(other.nicName))
        return false;
    if (properties == null) {
        if (other.properties != null)
            return false;
    } else if (!properties.equals(other.properties))
        return false;
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("networkId", getNetworkId()).append("nicId", getNicId()).append("nicName", getNicName()).append("ipConfiguration", getIpConfiguration()).append("properties", getProperties()).append("overrideConfiguration", isOverrideConfiguration()).build();
}
#method_after
@Override
public String toString() {
    return "NetworkAttachment [id=" + id + ", networkId=" + networkId + ", nicId=" + nicId + ", nicName=" + nicName + ", ipConfiguration=" + ipConfiguration + ", properties=" + properties + "]";
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#method_after
public FailingValidationResults<String> validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    if (validNewOrModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validNewOrModifiedBonds() && validRemovedBonds(attachmentsToConfigure) && validateNotRemovingUsedNetworkByVms()) {
        boolean valid = networksUniquelyConfiguredOnHost(attachmentsToConfigure) && !violations.addViolation(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && !violations.addViolations(new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure)) && validateCustomProperties();
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return violations;
}
#end_block

#method_before
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    NetworkAttachmentsValidator validator = new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap);
    return validator.validateNetworkExclusiveOnNics();
}
#method_after
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    return new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap).validateNetworkExclusiveOnNics();
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
            violations.addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName());
            passed = false;
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return passed;
}
#end_block

#method_before
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#method_after
boolean validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : params.getRemovedNetworkAttachments()) {
        removedNetworks.add(networkBusinessEntityMap.get(removedAttachment.getNetworkId()).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    for (String vmName : vmNames) {
        violations.addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
    }
    return vmNames.isEmpty();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    boolean passed = true;
    for (Bond removedBond : params.getRemovedBonds()) {
        String bondName = removedBond.getName();
        if (bondName == null) {
            violations.addViolation(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST, null);
            passed = false;
            continue;
        }
        VdsNetworkInterface existingBond = existingInterfaces.get(bondName);
        if (violations.addViolation(createHostInterfaceValidator(existingBond).interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            violations.addViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
            passed = false;
            continue;
        }
    }
    return passed;
}
#end_block

#method_before
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
            continue;
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(this.removedNetworkAttachments);
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#method_after
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(params.getRemovedNetworkAttachments());
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(VdcBllMessages.NETWORK_BOND_NAME_BAD_FORMAT, bondName);
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validNewOrModifiedBonds() {
    boolean passed = true;
    for (Bond modifiedOrNewBond : params.getBonds()) {
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        if (violations.addViolation(createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists())) {
            passed = false;
            continue;
        }
        String bondName = modifiedOrNewBond.getName();
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            violations.addViolation(VdcBllMessages.NETWORK_BOND_NAME_BAD_FORMAT, bondName);
            passed = false;
        }
        HostInterfaceValidator validator = createHostInterfaceValidator(existingInterfaces.get(bondName));
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        if (violations.addViolation(validator.interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            violations.addViolation(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
            passed = false;
            continue;
        }
        passed &= validateModifiedBondSlaves(modifiedOrNewBond);
    }
    return passed;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    Map<String, NetworkAttachment> removedNetworkAttachmentsByNicName = new MapNetworkAttachments(removedNetworkAttachments).byNicName();
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        boolean noNetworkOnInterfaceOrItsVlan = interfaceOrItsVlanDoesNotHaveNetworkOrOneIsAboutToBeRemovedFromIt(removedNetworkAttachmentsByNicName, potentialSlave);
        if (!noNetworkOnInterfaceOrItsVlan) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    boolean passed = true;
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface slave = existingInterfaces.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(slave);
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceExists(), slaveName)) {
            passed = false;
            continue;
        }
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceIsValidSlave(), slaveName)) {
            passed = false;
            continue;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
            another bond. This is ok only when this bond will be removed as a part of this request. */
        String slaveBondName = slave.getBondName();
        if (slave.isBondSlave() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                    to a different bond. */
        !slaveBondName.equals(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !bondIsBeingRemoved(slaveBondName)) {
            violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
            passed = false;
            continue;
        }
        String slaveNetworkName = slave.getNetworkName();
        boolean slaveHadNetworkAttached = slaveNetworkName != null;
        if (slaveHadNetworkAttached) {
            boolean attachmentBoundToNicBecomingSlaveRemoved = removedNetworkAttachmentsByNicName.containsKey(slave.getName());
            Guid slaveNetworkId = networkBusinessEntityMap.get(slaveNetworkName).getId();
            NetworkAttachment attachmentRelevantToSlaveNetwork = networkAttachmentsByNetworkId.get(slaveNetworkId);
            boolean networkBoundToNicBecomingSlaveMovedToAnotherNic = attachmentRelevantToSlaveNetwork != null && (!Objects.equals(attachmentRelevantToSlaveNetwork.getNicId(), slave.getId()) && !Objects.equals(attachmentRelevantToSlaveNetwork.getNicName(), slave.getName()));
            boolean slaveStillHasNetworkAttached = !(attachmentBoundToNicBecomingSlaveRemoved || networkBoundToNicBecomingSlaveMovedToAnotherNic);
            if (slaveStillHasNetworkAttached) {
                violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, slave.getName());
                passed = false;
                continue;
            }
        }
    }
    return passed;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = attachment.getId() != null;
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
        }
    }
    return vr;
}
#method_after
private boolean validNewOrModifiedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host);
        String networkId = attachment.getNetworkId() == null ? "" : attachment.getNetworkId().toString();
        if (violations.addViolation(validator.networkAttachmentIsSet()) || // this is not network exist, but only network is set.
        violations.addViolation(validator.networkExists(), networkId) || violations.addViolation(networkActuallyExists(attachment.getNetworkId()), networkId) || violations.addViolation(validator.notExternalNetwork(), networkId) || violations.addViolation(validator.networkAttachedToCluster(), networkId) || violations.addViolation(validator.ipConfiguredForStaticBootProtocol(), networkId) || violations.addViolation(validator.bootProtocolSetForDisplayNetwork(), networkId) || // this is not nic exist, but only nic is set.
        violations.addViolation(validator.nicExists(), networkId) || violations.addViolation(nicActuallyExistsOrReferencesNewBond(attachment), networkId) || violations.addViolation(validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfaces)) || violations.addViolation(validator.networkNotChanged(attachmentsById.get(attachment.getId()))) || violations.addViolation(validator.validateGateway())) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String targetNicName = attachment.getNicName();
    boolean attachmentReferencesExistingNic = existingInterfacesMap.get(attachment.getNicId(), targetNicName) != null;
    if (attachmentReferencesExistingNic) {
        return ValidationResult.VALID;
    }
    boolean attachmentReferencesNewlyCreatedBond = targetNicName != null && bondsMap.get(targetNicName) != null;
    if (attachmentReferencesNewlyCreatedBond) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String targetNicName = attachment.getNicName();
    boolean attachmentReferencesExistingNic = existingInterfaces.get(attachment.getNicId(), targetNicName) != null;
    if (attachmentReferencesExistingNic) {
        return ValidationResult.VALID;
    }
    boolean attachmentReferencesNewlyCreatedBond = targetNicName != null && bondsMap.get(targetNicName) != null;
    if (attachmentReferencesNewlyCreatedBond) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getRemovedNetworkAttachments()) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host);
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(validator.notExternalNetwork()) || violations.addViolation(validator.notRemovingManagementNetwork()) || !notRemovingLabeledNetworks(attachment)) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    VdsNetworkInterface nic = existingInterfacesMap.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = networkBusinessEntityMap.get(attachment.getNetworkId());
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return true;
    }
    VdsNetworkInterface nic = existingInterfaces.get(attachment.getNicName());
    if (nic != null && !removedBonds.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private boolean validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
                passed = false;
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
                passed = false;
            }
        }
    }
    return passed;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    managementNetworkUtil = Mockito.mock(ManagementNetworkUtil.class);
    bond = new Bond();
    bond.setId(Guid.newGuid());
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
}
#end_block

#method_before
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(unlabeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), isValid());
}
#method_after
@Test
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(unlabeledNetwork), Collections.<VdsNetworkInterface>emptyList());
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(true));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), isValid());
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    List<VdsNetworkInterface> existingNics = Collections.singletonList(existingNic);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(labeledNetwork), existingNics);
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(true));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingInterfaces(Collections.singletonList(existingNic)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(labeledNetwork))).build();
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    List<VdsNetworkInterface> existingNics = Collections.singletonList(existingNic);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(labeledNetwork), existingNics);
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), is(false));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Guid>emptySet());
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#method_after
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Bond>emptyList());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    String nicName = "nicName";
    VdsNetworkInterface notABond = new VdsNetworkInterface();
    notABond.setName(nicName);
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.asList(notABond), null, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.<VdsNetworkInterface>asList(removedBond), null, null);
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Arrays.asList(requiredNetworkAttachment)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.<VdsNetworkInterface>asList(removedBond), null, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Collections.singleton(networkAttachmentA.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Arrays.asList(networkAttachmentA));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS), is(true));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.<Network>emptyList())));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), isValid());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, null));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), isValid());
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    Network networkB = new Network();
    networkB.setId(id);
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES), is(true));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond();
    bond.setName("bond0");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, true, true);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, null, null, null));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, VdcBllMessages expectedViolation, boolean expectedValidationResult, boolean slavesValidationOk) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap(Collections.<Network>emptyList())));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBond()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationOk).when(validator).validateModifiedBondSlaves(any(Bond.class));
    assertThat(validator.validNewOrModifiedBonds(), is(expectedValidationResult));
    if (expectedViolation != null) {
        assertThat(validator.containsViolation(expectedViolation), is(true));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBond();
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, Collections.<VdsNetworkInterface>emptyList(), new BusinessEntityMap<>(Collections.<Network>emptyList()), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, false, VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, Collections.<VdsNetworkInterface>emptyList(), new BusinessEntityMap(Collections.<Network>emptyList()), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), false, VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Bond differentBond = new Bond();
    differentBond.setName("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, differentBond, slaveA, slaveB), new BusinessEntityMap<>(Collections.<Network>emptyList()), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(differentBond.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Bond differentBond = new Bond();
    differentBond.setName("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(differentBond));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, new BusinessEntityMap<>(Collections.<Network>emptyList()), Arrays.asList(bond, differentBond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Network assignedNetwork = new Network();
    assignedNetwork.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(assignedNetwork.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, slaveA, slaveB), new BusinessEntityMap<Network>(Collections.singletonList(assignedNetwork)), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singleton(removedNetworkAttachment.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.singletonList(removedNetworkAttachment), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singletonList(removedNetworkAttachment));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, new BusinessEntityMap<>(Collections.singletonList(networkBeingRemoved)), Arrays.asList(bond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingInterfaces, List<NetworkAttachment> existingAttachments, Collection<Network> networks, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, ValidationResult expectedValidationResult) {
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks)));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage()));
    }
}
#method_after
private void doTestValidateModifiedBondSlaves(Bond bond, List<VdsNetworkInterface> existingInterfaces, BusinessEntityMap<Network> networkBusinessEntityMap, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, boolean expectedValidationResult, VdcBllMessages expectedViolation) {
    doTestValidateModifiedBondSlaves(bond, new HostSetupNetworksParameters(host.getId()), networkBusinessEntityMap, existingInterfaces, interfaceExistValidationResult, interfaceIsValidSlaveValidationResult, expectedValidationResult, expectedViolation);
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA))));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Arrays.asList(networkA))));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT), is(true));
}
#end_block

#method_before
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(true);
    return slave;
}
#method_after
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slaveA = new VdsNetworkInterface();
    slaveA.setName(slaveName);
    slaveA.setBondName(bond.getName());
    slaveA.setBonded(true);
    return slaveA;
}
#end_block

#method_before
private HostSetupNetworksValidator createHostSetupNetworksValidator(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingIfaces, List<NetworkAttachment> existingAttachments, BusinessEntityMap<Network> networkBusinessEntityMap) {
    return new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setExistingInterfaces(existingIfaces).setExistingAttachments(existingAttachments).setNetworkBusinessEntityMap(networkBusinessEntityMap).build();
}
#method_after
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks, List<VdsNetworkInterface> existingInterfaces) {
    return new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), existingInterfaces, null, new BusinessEntityMap<>(networks));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    final ValidationResult hostValidatorResult = new HostValidator(host, isInternalExecution()).validate();
    if (!hostValidatorResult.isValid()) {
        return validate(hostValidatorResult);
    }
    NicNameNicIdCompleter completer = new NicNameNicIdCompleter(getExistingNics());
    completer.completeNetworkAttachments(getParameters().getNetworkAttachments());
    completer.completeBonds(getParameters().getBonds());
    completer.completeNetworkAttachments(getExistingAttachments());
    ValidationResult hostSetupNetworkValidatorResult = validateWithHostSetupNetworksValidator(host);
    if (!hostSetupNetworkValidatorResult.isValid()) {
        return validate(hostSetupNetworkValidatorResult);
    }
    return validate(checkForOutOfSyncNetworks());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    if (host == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        return false;
    }
    if (!hostStatusLegalForSetupNetworks(host)) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
        return false;
    }
    NicNameNicIdCompleter completer = new NicNameNicIdCompleter(getExistingNics());
    completer.completeNetworkAttachments(getParameters().getNetworkAttachments());
    completer.completeNetworkAttachments(getParameters().getRemovedNetworkAttachments());
    completer.completeBonds(getParameters().getBonds());
    completer.completeBonds(getParameters().getRemovedBonds());
    completer.completeNetworkAttachments(getExistingAttachments());
    validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap());
    FailingValidationResults<String> validationResults = validator.validate();
    if (!validationResults.isValid()) {
        List<String> validationMessages = validationResults.translateToListOfViolationMessagesWithCausesString();
        for (String msg : validationMessages) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    if (!checkForOutOfSyncNetworks()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new VdcBLLException(VdcBllErrors.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    BusinessEntityMap<VdsNetworkInterface> existingNicsBusinessEntityMap = getExistingNicsBusinessEntityMap();
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = existingNicsBusinessEntityMap.get(existingNetworkAttachment.getNicId());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            boolean networkMoved = networkMoved(networkAttachment, existingNetworkAttachment);
            VdcBllMessages message = networkMoved ? VdcBllMessages.MOVING_NETWORKS_MAKES_IT_OUT_OF_SYNC : VdcBllMessages.NETWORKS_NOT_IN_SYNC;
            return new ValidationResult(message, "NETWORK_NOT_IN_SYNC", network.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
private boolean checkForOutOfSyncNetworks() {
    BusinessEntityMap<VdsNetworkInterface> existingNicsBusinessEntityMap = getExistingNicsBusinessEntityMap();
    boolean success = true;
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface vdsNetworkInterface = existingNicsBusinessEntityMap.get(existingNetworkAttachment.getNicId());
        Network network = getNetworkBusinessEntityMap().get(existingNetworkAttachment.getNetworkId());
        HostNetworkQos qos = qosDaoCache.get(network.getQosId());
        boolean networkInSync = NetworkUtils.isNetworkInSync(vdsNetworkInterface, network, qos);
        if (!networkInSync) {
            boolean networkMoved = networkMoved(networkAttachment, existingNetworkAttachment);
            addCanDoActionMessage(networkMoved ? VdcBllMessages.MOVING_NETWORKS_MAKES_IT_OUT_OF_SYNC : VdcBllMessages.NETWORKS_NOT_IN_SYNC);
            addCanDoActionMessageVariable("NETWORK_NOT_IN_SYNC", network.getName());
            success = false;
        }
    }
    return success;
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getRemovedNetworks(), getParameters().getBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworks(), getRemovedNetworks(), getParameters().getBonds(), getRemovedBonds());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#end_block

#method_before
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getVdsGroupId()) && ipConfiguration != null && (ipConfiguration.getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#method_after
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return NetworkUtils.isManagementNetwork(network) && ipConfiguration != null && (ipConfiguration.getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getGateway()));
}
#end_block

#method_before
private boolean noChangesDetected() {
    return getNetworksToConfigure().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBondNames().isEmpty();
}
#method_after
private boolean noChangesDetected() {
    return getNetworks().isEmpty() && getRemovedNetworks().isEmpty() && getParameters().getBonds().isEmpty() && getRemovedBonds().isEmpty();
}
#end_block

#method_before
private List<VdsNetworkInterface> getRemovedBonds() {
    if (removedBonds == null) {
        Set<Guid> removedBondIds = getParameters().getRemovedBonds();
        removedBonds = Entities.filterEntitiesByRequiredIds(removedBondIds, getExistingNics());
    }
    return removedBonds;
}
#method_after
private Set<String> getRemovedBonds() {
    if (removedBonds == null) {
        removedBonds = new HashSet<>(getParameters().getRemovedBonds().size());
        for (Bond bond : getParameters().getRemovedBonds()) {
            removedBonds.add(bond.getName());
        }
    }
    return removedBonds;
}
#end_block

#method_before
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        List<NetworkAttachment> removedNetworkAttachments = Entities.filterEntitiesByRequiredIds(getParameters().getRemovedNetworkAttachments(), existingAttachments);
        removedNetworks = new HashSet<>(removedNetworkAttachments.size());
        for (NetworkAttachment attachment : removedNetworkAttachments) {
            removedNetworks.add(existingNetworkRelatedToAttachment(attachment).getName());
        }
    }
    return removedNetworks;
}
#method_after
private Set<String> getRemovedNetworks() {
    if (removedNetworks == null) {
        removedNetworks = new HashSet<>(getParameters().getRemovedNetworkAttachments().size());
        for (NetworkAttachment attachment : getParameters().getRemovedNetworkAttachments()) {
            removedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()).getName());
        }
    }
    return removedNetworks;
}
#end_block

#method_before
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> userConfiguredNics = new ArrayList<>();
    userConfiguredNics.addAll(getParameters().getBonds());
    for (VdsNetworkInterface existingBondToRemove : getRemovedBonds()) {
        existingBondToRemove.setLabels(null);
        userConfiguredNics.add(existingBondToRemove);
    }
    return userConfiguredNics;
}
#method_after
private List<VdsNetworkInterface> applyUserConfiguredNics() {
    List<VdsNetworkInterface> userConfiguredNics = new ArrayList<>();
    userConfiguredNics.addAll(getParameters().getBonds());
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(getExistingNics());
    for (VdsNetworkInterface removedBond : getParameters().getRemovedBonds()) {
        VdsNetworkInterface existingBondToRemove = existingNics.get(removedBond.getName());
        existingBondToRemove.setLabels(null);
        userConfiguredNics.add(existingBondToRemove);
    }
    return userConfiguredNics;
}
#end_block

#method_before
private List<Network> getModifiedNetworks() {
    if (modifiedNetworks == null) {
        List<NetworkAttachment> networkAttachments = getParameters().getNetworkAttachments();
        modifiedNetworks = new ArrayList<>(networkAttachments.size());
        for (NetworkAttachment attachment : networkAttachments) {
            modifiedNetworks.add(existingNetworkRelatedToAttachment(attachment));
        }
    }
    return modifiedNetworks;
}
#method_after
private List<Network> getModifiedNetworks() {
    List<Network> modifiedNetworks = new ArrayList<>(getParameters().getNetworkAttachments().size());
    for (NetworkAttachment attachment : getParameters().getNetworkAttachments()) {
        modifiedNetworks.add(getNetworkBusinessEntityMap().get(attachment.getNetworkId()));
    }
    return modifiedNetworks;
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
            // save the new network topology to DB
            hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getModifiedNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
            // save the new network topology to DB
            HostNetworkTopologyPersisterImpl.getInstance().persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getModifiedNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    return vr;
}
#method_after
public FailingValidationResults<String> validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    if (validModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validModifiedBonds() && validRemovedBonds(attachmentsToConfigure) && validateNotRemovingUsedNetworkByVms()) {
        boolean valid = networksUniquelyConfiguredOnHost(attachmentsToConfigure) && !violations.addViolation(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && !violations.addViolations(new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure)) && validateCustomProperties();
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return violations;
}
#end_block

#method_before
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    NetworkAttachmentsValidator validator = new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap);
    return validator.validateNetworkExclusiveOnNics();
}
#method_after
private ValidationResult validateNetworkExclusiveOnNics(Collection<NetworkAttachment> attachmentsToConfigure) {
    return new NetworkAttachmentsValidator(attachmentsToConfigure, networkBusinessEntityMap).validateNetworkExclusiveOnNics();
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
            violations.addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName());
            passed = false;
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return passed;
}
#end_block

#method_before
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#method_after
boolean validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : params.getRemovedNetworkAttachments()) {
        removedNetworks.add(networkBusinessEntityMap.get(removedAttachment.getNetworkId()).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    for (String vmName : vmNames) {
        violations.addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
    }
    return vmNames.isEmpty();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingIfacesById);
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfaces.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    boolean passed = true;
    for (Bond removedBond : params.getRemovedBonds()) {
        String bondName = removedBond.getName();
        if (bondName == null) {
            violations.addViolation(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST, null);
            passed = false;
            continue;
        }
        VdsNetworkInterface existingBond = existingInterfaces.get(bondName);
        if (violations.addViolation(createHostInterfaceValidator(existingBond).interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            violations.addViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
            passed = false;
            continue;
        }
    }
    return passed;
}
#end_block

#method_before
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
            continue;
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(this.removedNetworkAttachments);
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#method_after
Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> networkAttachmentsMap = new HashMap<>(existingAttachments.size() + params.getNetworkAttachments().size());
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
        } else {
            networkAttachmentsMap.put(attachment.getId(), attachment);
        }
    }
    Map<Guid, NetworkAttachment> removedNetworkAttachments = Entities.businessEntitiesById(params.getRemovedNetworkAttachments());
    for (NetworkAttachment existingAttachment : existingAttachments) {
        Guid existingAttachmentId = existingAttachment.getId();
        if (!networkAttachmentsMap.containsKey(existingAttachmentId) && !removedNetworkAttachments.containsKey(existingAttachmentId)) {
            networkAttachmentsMap.put(existingAttachmentId, existingAttachment);
        }
    }
    List<NetworkAttachment> result = new ArrayList<>(networkAttachmentsMap.values());
    result.addAll(newAttachments);
    return result;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfaces.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        /* slave has network assigned and there isn't request for unassigning it;
                so this check, that nic is part of newly crated bond, and any previously attached network has
                to be unattached. */
        if (potentialSlave.getNetworkName() != null && !isNetworkAttachmentRemoved(potentialSlave)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, potentialSlave.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    boolean passed = true;
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface slave = existingInterfaces.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(slave);
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceExists(), slaveName)) {
            passed = false;
            continue;
        }
        if (violations.addViolation(slaveHostInterfaceValidator.interfaceIsValidSlave(), slaveName)) {
            passed = false;
            continue;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
            another bond. This is ok only when this bond will be removed as a part of this request. */
        String slaveBondName = slave.getBondName();
        if (slave.isBondSlave() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                    to a different bond. */
        !slaveBondName.equals(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !bondIsBeingRemoved(slaveBondName)) {
            violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
            passed = false;
            continue;
        }
        /* slave has network assigned and there isn't request for unassigning it;
            so this probably check, that nic is part of newly crated bond, and any previously attached network has
            to be unattached. */
        if (slave.getNetworkName() != null && !networkAttachmentIsBeingRemoved(slave.getName())) {
            violations.addViolation(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, slave.getName());
            passed = false;
            continue;
        }
    }
    return passed;
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment, existingInterfaces);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getRemovedNetworkAttachments()) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host, managementNetworkUtil);
        if (violations.addViolation(validator.networkAttachmentIsSet()) || violations.addViolation(validator.notExternalNetwork()) || violations.addViolation(validator.notRemovingManagementNetwork()) || !notRemovingLabeledNetworks(attachment, existingInterfaces)) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = networkBusinessEntityMap.get(attachment.getNetworkId());
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return true;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    if (nic != null && !removedBonds.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private boolean validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
boolean validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
                passed = false;
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
                passed = false;
            }
        }
    }
    return passed;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    managementNetworkUtil = Mockito.mock(ManagementNetworkUtil.class);
    bond = new Bond();
    bond.setId(Guid.newGuid());
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    managementNetworkUtil = Mockito.mock(ManagementNetworkUtil.class);
}
#end_block

#method_before
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(unlabeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, null), isValid());
}
#method_after
@Test
public void testNotRemovingLabeledNetworksReferencingUnlabeledNetworkRemovalIsOk() throws Exception {
    Network unlabeledNetwork = new Network();
    unlabeledNetwork.setId(Guid.newGuid());
    NetworkAttachment networkAttachment = createNetworkAttachment(unlabeledNetwork);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(unlabeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, null), is(true));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), isValid());
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenNicNameDoesNotReferenceExistingNicItsOkToRemove() throws Exception {
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel("label");
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName("noLongerExistingNicName");
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setName("existingNicName");
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), is(true));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingInterfaces(Collections.singletonList(existingNic)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(labeledNetwork))).build();
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(labeledNetwork));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), is(false));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Guid>emptySet());
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, null);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#method_after
@Test
public void testValidRemovedBondsWhenNotRemovingAnyBond() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.<Bond>emptyList());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, null, null, null, managementNetworkUtil);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    String nicName = "nicName";
    VdsNetworkInterface notABond = new VdsNetworkInterface();
    notABond.setName(nicName);
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.asList(notABond), null, null, managementNetworkUtil);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.<VdsNetworkInterface>asList(removedBond), null, null, managementNetworkUtil);
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Arrays.asList(requiredNetworkAttachment)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS), is(true));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), isValid());
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsNotRequired() throws Exception {
    String nicName = "nicName";
    Bond removedBond = new Bond();
    removedBond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(removedBond));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Arrays.<VdsNetworkInterface>asList(removedBond), null, null, managementNetworkUtil);
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testGetAttachmentsToConfigureWhenNoChangesWereSent() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setExistingAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB)).build();
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenUpdatingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Collections.singleton(networkAttachmentA.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenRemovingNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentB));
    params.setRemovedNetworkAttachments(Arrays.asList(networkAttachmentA));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Arrays.asList(networkAttachmentA, networkAttachmentB), null, managementNetworkUtil);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(1));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(false));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#method_after
@Test
public void testGetAttachmentsToConfigureWhenAddingNewNetworkAttachments() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA, null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB, null);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, Collections.<VdsNetworkInterface>emptyList(), Collections.<NetworkAttachment>emptyList(), null, managementNetworkUtil);
    Collection<NetworkAttachment> attachmentsToConfigure = validator.getAttachmentsToConfigure();
    assertThat(attachmentsToConfigure.size(), is(2));
    assertThat(attachmentsToConfigure.contains(networkAttachmentA), is(true));
    assertThat(attachmentsToConfigure.contains(networkAttachmentB), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS), is(true));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>emptyList(), null, new BusinessEntityMap<>(Collections.<Network>emptyList())));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), isValid());
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenNotUsedByVms() throws Exception {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, null, null, null, managementNetworkUtil));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Collections.<String>emptyList());
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), isValid());
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenUniquelyConfigured() throws Exception {
    Network networkA = new Network();
    networkA.setId(Guid.newGuid());
    Network networkB = new Network();
    networkB.setId(Guid.newGuid());
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil);
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    Network networkB = new Network();
    networkB.setId(id);
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil);
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachmentA, networkAttachmentB)), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES), is(true));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = new Bond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = new Bond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, false, false);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, null, true, true);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, null, null, null));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, VdcBllMessages expectedViolation, boolean expectedValidationResult, boolean slavesValidationOk) {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, null, null, null, managementNetworkUtil));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBond()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationOk).when(validator).validateModifiedBondSlaves(any(Bond.class));
    assertThat(validator.validModifiedBonds(), is(expectedValidationResult));
    if (expectedViolation != null) {
        assertThat(validator.containsViolation(expectedViolation), is(true));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBond();
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, null, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, false, VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = new Bond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidateModifiedBondSlaves(bond, null, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), false, VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Bond differentBond = new Bond();
    differentBond.setName("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, differentBond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(differentBond.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Bond differentBond = new Bond();
    differentBond.setName("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singletonList(differentBond));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, Arrays.asList(bond, differentBond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, Arrays.asList(bond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, false, VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE);
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singleton(removedNetworkAttachment.getId()));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.singletonList(removedNetworkAttachment), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = new Bond();
    bond.setName("bondName");
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setNicName(slaveA.getName());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(Collections.singletonList(removedNetworkAttachment));
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    doTestValidateModifiedBondSlaves(bond, params, Arrays.asList(bond, slaveA, slaveB), ValidationResult.VALID, ValidationResult.VALID, true, null);
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingInterfaces, List<NetworkAttachment> existingAttachments, Collection<Network> networks, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, ValidationResult expectedValidationResult) {
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks)));
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage()));
    }
}
#method_after
private void doTestValidateModifiedBondSlaves(Bond bond, List<VdsNetworkInterface> existingInterfaces, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, boolean expectedValidationResult, VdcBllMessages expectedViolation) {
    doTestValidateModifiedBondSlaves(bond, new HostSetupNetworksParameters(host.getId()), existingInterfaces, interfaceExistValidationResult, interfaceIsValidSlaveValidationResult, expectedValidationResult, expectedViolation);
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA, networkB)), managementNetworkUtil);
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA)), managementNetworkUtil));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED), is(true));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidator(host, params, null, null, new BusinessEntityMap<>(Arrays.asList(networkA)), managementNetworkUtil));
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), is(false));
    assertThat(validator.containsViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT), is(true));
}
#end_block

#method_before
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(true);
    return slave;
}
#method_after
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slaveA = new VdsNetworkInterface();
    slaveA.setName(slaveName);
    slaveA.setBondName(bond.getName());
    slaveA.setBonded(true);
    return slaveA;
}
#end_block

#method_before
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks) {
    return new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setNetworkBusinessEntityMap(new BusinessEntityMap<>(networks)).build();
}
#method_after
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks) {
    return new HostSetupNetworksValidator(host, new HostSetupNetworksParameters(host.getId()), null, null, new BusinessEntityMap<>(networks), managementNetworkUtil);
}
#end_block

#method_before
@Test
public void testNetworksOnNicMatchMtuWhenNoNetworksAreProvided() throws Exception {
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", Collections.<Network>emptyList());
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(Collections.<Network>emptyList()));
    assertThat(networkMtuValidator.validateMtu(networksOnNics), isValid());
}
#method_after
@Test
public void testNetworksOnNicMatchMtuWhenNoNetworksAreProvided() throws Exception {
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", Collections.<Network>emptyList());
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(Collections.<Network>emptyList()));
    assertThat(networkMtuValidator.validateMtu(networksOnNics).isValid(), is(true));
}
#end_block

#method_before
@Test
public void testNetworksOnNicMatchMtu() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(1, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    assertThat(networkMtuValidator.validateMtu(networksOnNics), isValid());
}
#method_after
@Test
public void testNetworksOnNicMatchMtu() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(1, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    assertThat(networkMtuValidator.validateMtu(networksOnNics).isValid(), is(true));
}
#end_block

#method_before
@Test
public void testNetworksOnNicMatchMtuNetworkMtuDoesNotMatch() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(2, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    assertThat(networkMtuValidator.validateMtu(networksOnNics), failsWith(VdcBllMessages.NETWORK_MTU_DIFFERENCES));
}
#method_after
@Test
public void testNetworksOnNicMatchMtuNetworkMtuDoesNotMatch() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(2, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    FailingValidationResults<String> validationResults = networkMtuValidator.validateMtu(networksOnNics);
    assertThat(validationResults.isValid(), is(false));
    assertThat((validationResults).contains(VdcBllMessages.NETWORK_MTU_DIFFERENCES), is(true));
}
#end_block

#method_before
@Test
public void testNetworksOnNicMatchMtuIgnoreMtuDifferenceWhenBothNetworksAreVmNetworks() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, true), createNetwork(2, true));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    assertThat(networkMtuValidator.validateMtu(networksOnNics), isValid());
}
#method_after
@Test
public void testNetworksOnNicMatchMtuIgnoreMtuDifferenceWhenBothNetworksAreVmNetworks() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, true), createNetwork(2, true));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    NetworkMtuValidator networkMtuValidator = new NetworkMtuValidator(new BusinessEntityMap<>(networks));
    assertThat(networkMtuValidator.validateMtu(networksOnNics).isValid(), is(true));
}
#end_block

#method_before
public ValidationResult validateMtu(Collection<NetworkAttachment> attachmentsToConfigure) {
    return validateMtu(getNetworksOnNics(attachmentsToConfigure));
}
#method_after
public FailingValidationResults<String> validateMtu(Collection<NetworkAttachment> attachmentsToConfigure) {
    return validateMtu(getNetworksOnNics(attachmentsToConfigure));
}
#end_block

#method_before
public ValidationResult validateMtu(Map<String, List<Network>> nicsToNetworks) {
    for (List<Network> networksOnNic : nicsToNetworks.values()) {
        if (!networksOnNicMatchMtu(networksOnNic)) {
            ValidationResult validationResult = reportMtuDifferences(networksOnNic);
            if (!validationResult.isValid()) {
                return validationResult;
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public FailingValidationResults<String> validateMtu(Map<String, List<Network>> nicsToNetworks) {
    for (List<Network> networksOnNic : nicsToNetworks.values()) {
        if (!networksOnNicMatchMtu(networksOnNic)) {
            reportMtuDifferences(networksOnNic);
        }
    }
    return violations;
}
#end_block

#method_before
private ValidationResult reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    String replacements = String.format("[%s]", commaSeparated(mtuDiffNetworks));
    return new ValidationResult(VdcBllMessages.NETWORK_MTU_DIFFERENCES, replacements);
}
#method_after
private void reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    violations.addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES);
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#method_after
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, commaSeparated(vmNames));
    }
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingIfacesById);
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfaces.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingIfacesById);
    if (!invalidBondIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_BOND_NOT_EXISTS, commaSeparated(invalidBondIds));
    }
    Set<String> requiredInterfaceNames = getNetworkAttachmentInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfaces.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = requiredInterfaceNames.contains(bondName);
        if (cantRemoveRequiredInterface) {
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfaces.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfaces.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName);
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfaces.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        /* slave has network assigned and there isn't request for unassigning it;
                so this check, that nic is part of newly crated bond, and any previously attached network has
                to be unattached. */
        if (potentialSlave.getNetworkName() != null && !isNetworkAttachmentRemoved(potentialSlave)) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, potentialSlave.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(Bond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfaces.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // …but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && // … or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND, slaveName);
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        /* slave has network assigned and there isn't request for unassigning it;
                so this check, that nic is part of newly crated bond, and any previously attached network has
                to be unattached. */
        if (potentialSlave.getNetworkName() != null && !isNetworkAttachmentRemoved(potentialSlave)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE, potentialSlave.getName());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfaces);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = attachment.getId() != null;
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
        }
    }
    return vr;
}
#method_after
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        // TODO MM: complain about unset network id.
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForDisplayNetwork();
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfaces);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = attachment.getId() != null;
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentNicIdentification(attachment.getId(), attachment.getNicId(), attachment.getNicName(), VdcBllMessages.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY);
}
#method_after
private ValidationResult validateCoherentNicIdentification(NetworkAttachment attachment) {
    return validateCoherentNicIdentification(attachment.getId(), attachment.getNicId(), attachment.getNicName(), EngineMessage.NETWORK_ATTACHMENT_REFERENCES_NICS_INCOHERENTLY);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    VdcBllMessages message = VdcBllMessages.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentNicIdentification(bond.getId(), nicId, nicName, message);
}
#method_after
private ValidationResult validateCoherentNicIdentification(Bond bond) {
    Guid nicId = bond.getId();
    String nicName = bond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return validateCoherentNicIdentification(bond.getId(), nicId, nicName, message);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(Guid violatingEntityId, Guid nicId, String nicName, VdcBllMessages message) {
    boolean bothIdentificationSet = nicId != null && nicName != null;
    String[] replacements = createIncoherentNicIdentificationErrorReplacements(violatingEntityId, nicId, nicName);
    return ValidationResult.failWith(message, replacements).when(bothIdentificationSet && isNicNameAndNicIdIncoherent(nicId, nicName));
}
#method_after
private ValidationResult validateCoherentNicIdentification(Guid violatingEntityId, Guid nicId, String nicName, EngineMessage message) {
    boolean bothIdentificationSet = nicId != null && nicName != null;
    String[] replacements = createIncoherentNicIdentificationErrorReplacements(violatingEntityId, nicId, nicName);
    return ValidationResult.failWith(message, replacements).when(bothIdentificationSet && isNicNameAndNicIdIncoherent(nicId, nicName));
}
#end_block

#method_before
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult modifiedAttachmentExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#end_block

#method_before
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment, existingInterfaces);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#method_after
private ValidationResult validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingAttachments);
    if (!invalidIds.isEmpty()) {
        return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS, commaSeparated(invalidIds));
    }
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = removedNetworkAttachments.iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachmentToValidate);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.notRemovingManagementNetwork();
        vr = skipValidation(vr) ? vr : notRemovingLabeledNetworks(attachment, existingInterfaces);
        vr = skipValidation(vr) ? vr : validateNotRemovingUsedNetworkByVms();
    }
    return vr;
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        // TODO MM: why is this correct?? Why when it's related to removed bond I can remove labeled network?
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    /*
            When attachment is related to labeled network and bond being removed, it's considered to be valid,
            because with disappearance of bond its label also disappears, so technically we cannot detach such network,
            since it shouldn't be present there anyways.
        * */
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    String replacements = String.format("[%s]", commaSeparated(mtuDiffNetworks));
    return new ValidationResult(VdcBllMessages.NETWORK_MTU_DIFFERENCES, replacements);
}
#method_after
private ValidationResult reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    String replacements = String.format("[%s]", commaSeparated(mtuDiffNetworks));
    return new ValidationResult(EngineMessage.NETWORK_MTU_DIFFERENCES, replacements);
}
#end_block

#method_before
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateCustomProperties(SimpleCustomPropertiesUtil util, Map<String, String> validPropertiesForVm, Map<String, String> validPropertiesForNonVm) {
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validPropertiesForVm : validPropertiesForNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                handleCustomPropertiesError(util, errors);
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void testNetworksOnNicMatchMtuNetworkMtuDoesNotMatch() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(2, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    HostSetupNetworksValidator hostSetupNetworksValidator = createHostSetupNetworksValidator();
    assertThat(hostSetupNetworksValidator.validateMtu(networksOnNics), failsWith(VdcBllMessages.NETWORK_MTU_DIFFERENCES));
}
#method_after
@Test
public void testNetworksOnNicMatchMtuNetworkMtuDoesNotMatch() throws Exception {
    List<Network> networks = Arrays.asList(createNetwork(1, false), createNetwork(2, false));
    Map<String, List<Network>> networksOnNics = Collections.singletonMap("nicName", networks);
    HostSetupNetworksValidator hostSetupNetworksValidator = createHostSetupNetworksValidator();
    assertThat(hostSetupNetworksValidator.validateMtu(networksOnNics), failsWith(EngineMessage.NETWORK_MTU_DIFFERENCES));
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setExistingInterfaces(Collections.singletonList(existingNic)).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(labeledNetwork))).build();
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    Map<String, VdsNetworkInterface> existingNics = Entities.entitiesByName(Collections.singletonList(existingNic));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(new HostSetupNetworksParameters(host.getId()), Collections.singletonList(existingNic), Collections.<NetworkAttachment>emptyList(), new BusinessEntityMap<>(Collections.singletonList(labeledNetwork)));
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment, existingNics), failsWith(EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceIsNotBond() throws Exception {
    VdsNetworkInterface notABond = createNic("nicName");
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(notABond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.singletonList(notABond));
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedBonds(Collections.singleton(bond.getId()));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(params, Collections.<VdsNetworkInterface>singletonList(bond));
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateNotRemovingUsedNetworkByVmsWhenUsedByVms() throws Exception {
    String nameOfNetworkA = "networkA";
    String nameOfNetworkB = "networkB";
    Network networkA = createNetworkWithName(nameOfNetworkA);
    Network networkB = createNetworkWithName(nameOfNetworkB);
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setNicId(nicA.getId());
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setNicId(nicB.getId());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setRemovedNetworkAttachments(new HashSet<>(Arrays.asList(networkAttachmentA.getId(), networkAttachmentB.getId())));
    HostSetupNetworksValidator validator = spy(createHostSetupNetworksValidator(params, Arrays.asList(nicA, nicB), Arrays.asList(networkAttachmentA, networkAttachmentB), new BusinessEntityMap<>(Arrays.asList(networkA, networkB))));
    VmInterfaceManager vmInterfaceManagerMock = mock(VmInterfaceManager.class);
    doReturn(vmInterfaceManagerMock).when(validator).getVmInterfaceManager();
    when(vmInterfaceManagerMock.findActiveVmsUsingNetworks(any(Guid.class), any(Collection.class))).thenReturn(Arrays.asList(nameOfNetworkA, nameOfNetworkB));
    assertThat(validator.validateNotRemovingUsedNetworkByVms(), failsWith(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS));
    ArgumentCaptor<Collection> collectionArgumentCaptor = ArgumentCaptor.forClass(Collection.class);
    verify(vmInterfaceManagerMock).findActiveVmsUsingNetworks(eq(host.getId()), collectionArgumentCaptor.capture());
    assertThat(collectionArgumentCaptor.getValue().size(), is(2));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkA), is(true));
    assertThat(collectionArgumentCaptor.getValue().contains(nameOfNetworkB), is(true));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    Network networkA = new Network();
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Collections.singletonList(networkA));
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenBondIsUnnamed() throws Exception {
    doTestValidModifiedBonds(new Bond(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenBondIsUnnamed() throws Exception {
    doTestValidModifiedBonds(new Bond(), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IS_NOT_BOND), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND), new ValidationResult(EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_BONDS_INVALID_SLAVE_COUNT), /*false*/
    ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE), new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, null, Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE), new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, differentBond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.<Network>emptyList(), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    bond.setSlaves(Arrays.asList(slaveA.getName(), slaveB.getName()));
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setBonds(Collections.singletonList(bond));
    doTestValidateModifiedBondSlaves(params, Arrays.asList(bond, slaveA, slaveB), Collections.<NetworkAttachment>emptyList(), Collections.singletonList(networkBeingRemoved), ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE));
}
#end_block

#method_before
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachmentA));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#method_after
@Test
public void testValidateCustomPropertiesWhenAttachmentDoesNotHaveCustomProperties() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    Network networkB = createNetworkWithName("networkB");
    NetworkAttachment networkAttachmentA = createNetworkAttachment(networkA);
    networkAttachmentA.setProperties(null);
    NetworkAttachment networkAttachmentB = createNetworkAttachment(networkB);
    networkAttachmentB.setProperties(new HashMap<String, String>());
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Arrays.asList(networkAttachmentA, networkAttachmentB));
    HostSetupNetworksValidator validator = createHostSetupNetworksValidator(Arrays.asList(networkA, networkB), params);
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), isValid());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    SimpleCustomPropertiesUtil simpleCustomPropertiesUtil = spy(SimpleCustomPropertiesUtil.getInstance());
    doReturn(Collections.emptyList()).when(simpleCustomPropertiesUtil).validateProperties(any(Map.class), any(Map.class));
    assertThat(validator.validateCustomProperties(simpleCustomPropertiesUtil, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#method_after
@Test
public void testValidateCustomPropertiesWhenCustomPropertyValidationFailed() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(Collections.singletonList(networkA))).build());
    // this was added just because of DI issues with 'Backend.getInstance().getErrorsTranslator()' is 'spyed' method
    // noinspection unchecked
    doReturn(Collections.emptyList()).when(validator).translateErrorMessages(any(List.class));
    assertThat(validator.validateCustomProperties(SimpleCustomPropertiesUtil.getInstance(), Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT));
}
#end_block

#method_before
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(true);
    return slave;
}
#method_after
private VdsNetworkInterface createBondSlave(Bond bond, String slaveName) {
    VdsNetworkInterface slave = new VdsNetworkInterface();
    slave.setId(Guid.newGuid());
    slave.setName(slaveName);
    slave.setBondName(bond.getName());
    slave.setBonded(false);
    return slave;
}
#end_block

#method_before
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks) {
    return new HostSetupNetworksValidatorBuilder().setHost(host).setParams(new HostSetupNetworksParameters(host.getId())).setNetworkBusinessEntityMap(new BusinessEntityMap<>(networks)).build();
}
#method_after
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks) {
    return createHostSetupNetworksValidator(networks, new HostSetupNetworksParameters(host.getId()));
}
#end_block

#method_before
private HostSetupNetworksValidator createHostSetupNetworksValidator(HostSetupNetworksParameters params, List<VdsNetworkInterface> existingIfaces, List<NetworkAttachment> existingAttachments, BusinessEntityMap<Network> networkBusinessEntityMap) {
    return new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setExistingInterfaces(existingIfaces).setExistingAttachments(existingAttachments).setNetworkBusinessEntityMap(networkBusinessEntityMap).build();
}
#method_after
private HostSetupNetworksValidator createHostSetupNetworksValidator(List<Network> networks, HostSetupNetworksParameters params) {
    return new HostSetupNetworksValidatorBuilder().setHost(host).setParams(params).setNetworkBusinessEntityMap(new BusinessEntityMap<>(networks)).build();
}
#end_block

#method_before
private boolean validateVmwareConfiguration() {
    getvCenter().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getEsx().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getVmwareDatacenter().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    return getvCenter().getIsValid() && getEsx().getIsValid() && getVmwareDatacenter().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#method_after
private boolean validateVmwareConfiguration() {
    getvCenter().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getEsx().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    getVmwareDatacenter().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation(), new NameAndOptionalDomainValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    return getvCenter().getIsValid() && getEsx().getIsValid() && getVmwareDatacenter().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid();
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            // store the locked managers to finally release them at the end of the cycle
            vmManagers.put(vmId, vmManager);
            return true;
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (!vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId())) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
                vmManager.unlock();
            } else if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.unlock();
    }
}
#method_after
private void unlockVmsManager() {
    for (VmManager vmManager : vmManagers.values()) {
        vmManager.updateVmDataChangedTime();
        vmManager.unlock();
    }
}
#end_block

#method_before
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> pair : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(pair)) {
            VmAnalyzer vmAnalyzer = new VmAnalyzer(pair.getFirst(), pair.getSecond(), this, auditLogDirector);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#method_after
private void refreshVmStats() {
    for (Pair<VM, VmInternalData> monitoredVm : monitoredVms) {
        // TODO filter out migratingTo VMs if no action is taken on them
        if (tryLockVmForUpdate(monitoredVm)) {
            VmAnalyzer vmAnalyzer = getVmAnalyzer(monitoredVm);
            vmAnalyzers.add(vmAnalyzer);
            vmAnalyzer.analyze();
            if (vmAnalyzer.isExternalVm()) {
                externalVms.add(new Pair<>(vmAnalyzer.getDbVm(), vmAnalyzer.getVdsmVm()));
            }
        }
    }
    processExternallyManagedVms();
    processVmsWithDevicesChange();
    saveVmsToDb();
}
#end_block

#method_before
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                if (vmDynamicToSave.containsKey(pair.getFirst().getId())) {
                    vmDynamicToSave.get(pair.getFirst().getId()).setHash(pair.getSecond().getVmDynamic().getHash());
                } else {
                    addVmDynamicToList(pair.getSecond().getVmDynamic());
                }
                vmsToUpdate.add(pair.getSecond().getVmDynamic().getId().toString());
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#method_after
private void processVmsWithDevicesChange() {
    // Handle VM devices were changed (for 3.1 cluster and above)
    if (!VmDeviceCommonUtils.isOldClusterVersion(vdsManager.getGroupCompatibilityVersion())) {
        // get the new info from VDSM in one call, and then update them all
        if (!vmsWithChangedDevices.isEmpty()) {
            ArrayList<String> vmsToUpdate = new ArrayList<>(vmsWithChangedDevices.size());
            for (Pair<VM, VmInternalData> pair : vmsWithChangedDevices) {
                Guid vmId = pair.getFirst().getId();
                // this ensure the vmManager lock is taken
                if (vmDynamicToSave.containsKey(vmId)) {
                    vmDynamicToSave.get(vmId).setHash(pair.getSecond().getVmDynamic().getHash());
                    vmsToUpdate.add(vmId.toString());
                } else {
                    log.warn("VM '{}' not in changed list, skipping devices update.", vmId);
                }
            }
            updateVmDevices(vmsToUpdate);
        }
    }
}
#end_block

#method_before
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#method_after
// ***** Helpers and sub-methods *****
protected void updateVmDevices(List<String> vmsToUpdate) {
    if (vmsToUpdate.isEmpty()) {
        return;
    }
    Map[] vms = getVmInfo(vmsToUpdate);
    if (vms != null) {
        for (Map vm : vms) {
            processVmDevices(vm);
        }
    }
}
#end_block

#method_before
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    return (Map[]) (getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate)).getReturnValue());
}
#method_after
protected Map[] getVmInfo(List<String> vmsToUpdate) {
    // TODO refactor commands to use vdsId only - the whole vds object here is useless
    VDS vds = new VDS();
    vds.setId(vdsManager.getVdsId());
    Map[] result = {};
    VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmsToUpdate));
    if (vdsReturnValue.getSucceeded()) {
        result = (Map[]) (vdsReturnValue.getReturnValue());
    }
    return result;
}
#end_block

#method_before
public void attemptResolution() {
    Set<Guid> images;
    if (getVmDAO().get(getParameters().getVmId()).isDown()) {
        StoragePool pool = getStoragePoolDAO().get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null) {
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // Direction: base exists => backwards merge (commit); else (top exists) => forward merge (rebase)
    VmBlockJobType jobType = (images.contains(getParameters().getBaseImage().getImageId())) ? VmBlockJobType.COMMIT : VmBlockJobType.PULL;
    log.info("Volume merge type '{}'", jobType.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(jobType, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
public void attemptResolution() {
    Set<Guid> images;
    if (getVmDao().get(getParameters().getVmId()).isDown()) {
        StoragePool pool = getStoragePoolDao().get(getParameters().getStoragePoolId());
        if (pool.getSpmVdsId() == null || pool.getStatus() != StoragePoolStatus.Up) {
            log.info("VM down, waiting on SPM election to resolve Live Merge");
            setSucceeded(true);
            return;
        } else {
            log.error("VM is not running, proceeding with Live Merge recovery");
            images = getVolumeChainFromRecovery();
        }
    } else {
        images = getVolumeChain();
    }
    if (images == null) {
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Set<Guid> imagesToRemove = getImagesToRemove();
    images.retainAll(imagesToRemove);
    if (images.size() != 1) {
        log.error("Failed to live merge, still in volume chain: {}", images);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    imagesToRemove.removeAll(images);
    log.info("Successfully removed volume(s): {}", imagesToRemove);
    // Direction: base exists => backwards merge (commit); else (top exists) => forward merge (rebase)
    VmBlockJobType jobType = (images.contains(getParameters().getBaseImage().getImageId())) ? VmBlockJobType.COMMIT : VmBlockJobType.PULL;
    log.info("Volume merge type '{}'", jobType.name());
    MergeStatusReturnValue returnValue = new MergeStatusReturnValue(jobType, imagesToRemove);
    getReturnValue().setActionReturnValue(returnValue);
    setSucceeded(true);
    persistCommand(getParameters().getParentCommand(), true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
private Set<Guid> getVolumeChain() {
    List<String> vmIds = new ArrayList<>();
    vmIds.add(getParameters().getVmId().toString());
    VDS vds = getVdsDAO().get(getParameters().getVdsId());
    Map[] vms = (Map[]) (new FullListVDSCommand<>(new FullListVDSCommandParameters(vds, vmIds)).executeWithReturnValue());
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = (Map) vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#method_after
private Set<Guid> getVolumeChain() {
    List<String> vmIds = new ArrayList<>();
    vmIds.add(getParameters().getVmId().toString());
    VDS vds = getVdsDao().get(getParameters().getVdsId());
    Map[] vms = (Map[]) runVdsCommand(VDSCommandType.FullList, new FullListVDSCommandParameters(vds, vmIds)).getReturnValue();
    if (vms == null || vms.length == 0) {
        log.error("Failed to retrieve VM information");
        return null;
    }
    Map vm = (Map) vms[0];
    if (vm == null || vm.get(VdsProperties.vm_guid) == null) {
        log.error("Received incomplete VM information");
        return null;
    }
    Guid vmId = new Guid((String) vm.get(VdsProperties.vm_guid));
    if (!vmId.equals(getParameters().getVmId())) {
        log.error("Invalid VM returned when querying status: expected '{}', got '{}'", getParameters().getVmId(), vmId);
        return null;
    }
    Set<Guid> images = new HashSet<>();
    DiskImage activeDiskImage = getParameters().getActiveImage();
    for (Object o : (Object[]) vm.get(VdsProperties.Devices)) {
        Map device = (Map<String, Object>) o;
        if (VdsProperties.Disk.equals(device.get(VdsProperties.Type)) && activeDiskImage.getId().equals(Guid.createGuidFromString((String) device.get(VdsProperties.ImageId)))) {
            Object[] volumeChain = (Object[]) device.get("volumeChain");
            for (Object v : volumeChain) {
                Map<String, Object> volume = (Map<String, Object>) v;
                images.add(Guid.createGuidFromString((String) volume.get(VdsProperties.VolumeId)));
            }
            break;
        }
    }
    return images;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    handleAnyChildSPMTaskCompletion(true);
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    // endAction so that upon SPM task completion the status is propagated to the proper command.
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        syncChildCommandList();
        Guid currentChildId = getCurrentChildId();
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
                CommandCoordinatorUtil.getCommandEntity(currentChildId).setCallbackNotified(true);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    handleAnyChildSPMTaskCompletion(false);
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // See comment in endSuccessfully() for an explanation of this redirection
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        syncChildCommandList();
        Guid currentChildId = getCurrentChildId();
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                command.getParameters().setTaskGroupSuccess(false);
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
public void executeCommand() {
    if (getParameters().getTopImage().getSize() == getParameters().getBaseImage().getSize()) {
        log.debug("No image size update required");
        setSucceeded(true);
        setCommandStatus(CommandStatus.SUCCEEDED);
        return;
    }
    // only need their size updated in the database.
    if (isBaseRawBlock()) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        VDSReturnValue vdsReturnValue = extendImageSize();
        if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
            getParameters().setVdsmTaskIds(new ArrayList<Guid>());
            Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
            getReturnValue().getInternalVdsmTaskIdList().add(result);
            getReturnValue().getVdsmTaskIdList().add(result);
            getParameters().getVdsmTaskIds().add(result);
            setSucceeded(vdsReturnValue.getSucceeded());
            persistCommand(getParameters().getParentCommand(), true);
            log.info("Successfully started task to extend base image size in preparation for live merge");
        } else {
            log.error("Failed to extend base image for live merge");
            setSucceeded(false);
            setCommandStatus(CommandStatus.FAILED);
        }
    } else {
        // If the async task above is started, endAction() will be called for the size
        // update.  In other cases, callbacks are disabled so we update the size here.
        updateSizeInDb();
        setSucceeded(true);
        setCommandStatus(CommandStatus.SUCCEEDED);
    }
}
#method_after
public void executeCommand() {
    if (getParameters().getTopImage().getSize() == getParameters().getBaseImage().getSize()) {
        log.debug("No image size update required");
        setSucceeded(true);
        setCommandStatus(CommandStatus.SUCCEEDED);
        return;
    }
    // only need their size updated in the database.
    if (isBaseRawBlock()) {
        extendImageSize();
    } else {
        updateSizeInDb();
        setCommandStatus(CommandStatus.SUCCEEDED);
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean isBaseRawBlock() {
    if (getParameters().getBaseImage().getVolumeFormat() == VolumeFormat.RAW) {
        List<ImageStorageDomainMap> maps = getDbFacade().getImageStorageDomainMapDao().getAllByImageId(getParameters().getBaseImage().getImageId());
        if (!maps.isEmpty() && getStorageDomainDAO().get(maps.get(0).getstorage_domain_id()).getStorageType().isBlockDomain()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isBaseRawBlock() {
    if (getParameters().getBaseImage().getVolumeFormat() == VolumeFormat.RAW) {
        List<ImageStorageDomainMap> maps = getDbFacade().getImageStorageDomainMapDao().getAllByImageId(getParameters().getBaseImage().getImageId());
        if (!maps.isEmpty() && getStorageDomainDao().get(maps.get(0).getstorage_domain_id()).getStorageType().isBlockDomain()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private VDSReturnValue extendImageSize() {
    DiskImage diskImage = getParameters().getBaseImage();
    long sizeInBytes = getParameters().getTopImage().getSize();
    ExtendImageSizeVDSCommandParameters params = new ExtendImageSizeVDSCommandParameters(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId(), sizeInBytes);
    log.info("Extending size of base volume {} to {} bytes", diskImage.getImageId(), sizeInBytes);
    return runVdsCommand(VDSCommandType.ExtendImageSize, params);
}
#method_after
private void extendImageSize() {
    Guid diskImageId = getParameters().getBaseImage().getImageId();
    long sizeInBytes = getParameters().getTopImage().getSize();
    ExtendImageSizeParameters parameters = new ExtendImageSizeParameters(diskImageId, sizeInBytes, true);
    parameters.setStoragePoolId(getParameters().getBaseImage().getStoragePoolId());
    parameters.setStorageDomainId(getParameters().getBaseImage().getStorageIds().get(0));
    parameters.setImageGroupID(getParameters().getBaseImage().getId());
    parameters.setParentCommand(VdcActionType.MergeExtend);
    parameters.setParentParameters(getParameters());
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.ExtendImageSize, parameters, cloneContextAndDetachFromParent());
    log.info("Extending size of base volume {} to {} bytes", diskImageId, sizeInBytes);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    updateSizeInDb();
}
#method_after
@Override
protected void endSuccessfully() {
    handleAnyChildSPMTaskCompletion(true);
    setSucceeded(true);
}
#end_block

#method_before
public static void main(String[] args) {
    ExtMap context = new ExtMap();
    try {
        // init context
        context.mput(ContextKeys.TAIL, new LinkedList<>(Arrays.asList(args)));
        context.put(Schema.InvokeKeys.SETTINGS_RESULT, new ExtMap());
        context.put(ContextKeys.THROWABLES, new ArrayList<>());
        context.put(ContextKeys.ERR_MESSAGES, new ArrayList<>());
        context.put(ContextKeys.OUT_MESSAGES, new ArrayList<>());
        // Invoke commands
        commands.get("root").invoke(context);
        for (String msg : (List<String>) context.get(ContextKeys.ERR_MESSAGES, List.class)) {
            System.err.print(newLine(msg));
        }
        for (String msg : (List<String>) context.get(ContextKeys.OUT_MESSAGES, List.class)) {
            System.out.print(newLine(msg));
        }
        for (Object thr : context.get(ContextKeys.THROWABLES, List.class)) {
            LOG.debug("Exception", thr);
        }
        System.exit(context.get(ContextKeys.EXIT_STATUS, Integer.class, SUCCESS));
    } catch (Throwable t) {
        if (context.get(ContextKeys.LOGGING_STARTED, Boolean.class, false)) {
            LOG.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
            LOG.debug("exception", t);
        } else {
            t.printStackTrace();
        }
        System.exit(GENERAL_ERROR);
    }
}
#method_after
public static void main(String[] args) {
    ExtMap context = new ExtMap();
    try {
        // init context
        context.mput(ContextKeys.TAIL, new LinkedList<>(Arrays.asList(args)));
        context.put(Schema.InvokeKeys.SETTINGS_RESULT, new ExtMap());
        context.put(ContextKeys.THROWABLES, new ArrayList<>());
        context.put(ContextKeys.ERR_MESSAGES, new ArrayList<>());
        context.put(ContextKeys.OUT_MESSAGES, new ArrayList<>());
        // Invoke commands
        commands.get("root").invoke(context);
        for (String msg : (List<String>) context.get(ContextKeys.ERR_MESSAGES, List.class)) {
            System.err.print(newLine(msg));
        }
        for (String msg : (List<String>) context.get(ContextKeys.OUT_MESSAGES, List.class)) {
            System.out.print(newLine(msg));
        }
        for (Object thr : context.get(ContextKeys.THROWABLES, List.class)) {
            LOG.debug("Exception", thr);
        }
        System.exit(context.get(ContextKeys.EXIT_STATUS, Integer.class, SUCCESS));
    } catch (Throwable t) {
        if (context.get(ContextKeys.LOGGING_STARTED, Boolean.class, false)) {
            LOG.error("Unexpected Exception invoking Cli: {}", t.getMessage());
            LOG.debug("exception", t);
        } else {
            t.printStackTrace();
        }
        System.exit(GENERAL_ERROR);
    }
}
#end_block

#method_before
@Test
public void nameIsNull() {
    assertThat(validator.nameNotEmpty(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY));
}
#method_after
@Test
public void nameIsNull() {
    assertThat(validator.nameNotEmpty(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY));
}
#end_block

#method_before
@Test
public void nameIsEmpty() {
    when(host.getName()).thenReturn("");
    assertThat(validator.nameNotEmpty(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY));
}
#method_after
@Test
public void nameIsEmpty() {
    when(host.getName()).thenReturn("");
    assertThat(validator.nameNotEmpty(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY));
}
#end_block

#method_before
@Test
public void NameLengthIsTooLong() {
    when(host.getName()).thenReturn(RandomUtils.instance().nextString(HOST_NAME_SIZE * 2));
    assertThat(validator.nameLengthIsLegal(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG));
}
#method_after
@Test
public void NameLengthIsTooLong() {
    when(host.getName()).thenReturn(RandomUtils.instance().nextString(HOST_NAME_SIZE * 2));
    assertThat(validator.nameLengthIsLegal(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG));
}
#end_block

#method_before
@Test
public void hostNameIsInvalid() {
    assertThat(validator.hostNameIsValid(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME));
}
#method_after
@Test
public void hostNameIsInvalid() {
    assertThat(validator.hostNameIsValid(), failsWith(EngineMessage.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME));
}
#end_block

#method_before
@Test
public void nameIsUsed() {
    when(hostDao.getByName(any(String.class))).thenReturn(mock(VDS.class));
    when(dbFacade.getVdsDao()).thenReturn(hostDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.nameNotUsed(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
}
#method_after
@Test
public void nameIsUsed() {
    when(hostDao.getByName(any(String.class))).thenReturn(mock(VDS.class));
    when(dbFacade.getVdsDao()).thenReturn(hostDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.nameNotUsed(), failsWith(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
}
#end_block

#method_before
@Test
public void hostNameIsUsed() {
    when(hostDao.getAllForHostname(any(String.class))).thenReturn(Collections.singletonList(mock(VDS.class)));
    when(dbFacade.getVdsDao()).thenReturn(hostDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.hostNameNotUsed(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST));
}
#method_after
@Test
public void hostNameIsUsed() {
    when(hostDao.getAllForHostname(any(String.class))).thenReturn(Collections.singletonList(mock(VDS.class)));
    when(dbFacade.getVdsDao()).thenReturn(hostDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.hostNameNotUsed(), failsWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST));
}
#end_block

#method_before
@Test
public void portIsInvalid() {
    assertThat(validator.portIsValid(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT));
}
#method_after
@Test
public void portIsInvalid() {
    assertThat(validator.portIsValid(), failsWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT));
}
#end_block

#method_before
@Test
public void sshUserNameIsEmpty() {
    assertThat(validator.sshUserNameNotEmpty(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME));
}
#method_after
@Test
public void sshUserNameIsEmpty() {
    assertThat(validator.sshUserNameNotEmpty(), failsWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME));
}
#end_block

#method_before
@Test
public void validateSingleHostAttachedToFewStorages() {
    StoragePool dataCenter = mock(StoragePool.class);
    when(dataCenter.isLocal()).thenReturn(true);
    when(storagePoolDao.getForVdsGroup(any(Guid.class))).thenReturn(dataCenter);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDao);
    when(hostStaticDao.getAllForVdsGroup(any(Guid.class))).thenReturn(Collections.<VdsStatic>singletonList(mock(VdsStatic.class)));
    when(dbFacade.getVdsStaticDao()).thenReturn(hostStaticDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.validateSingleHostAttachedToLocalStorage(), failsWith(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE));
}
#method_after
@Test
public void validateSingleHostAttachedToFewStorages() {
    StoragePool dataCenter = mock(StoragePool.class);
    when(dataCenter.isLocal()).thenReturn(true);
    when(storagePoolDao.getForVdsGroup(any(Guid.class))).thenReturn(dataCenter);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDao);
    when(hostStaticDao.getAllForVdsGroup(any(Guid.class))).thenReturn(Collections.<VdsStatic>singletonList(mock(VdsStatic.class)));
    when(dbFacade.getVdsStaticDao()).thenReturn(hostStaticDao);
    validator = new HostValidator(dbFacade, host);
    assertThat(validator.validateSingleHostAttachedToLocalStorage(), failsWith(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE));
}
#end_block

#method_before
@Test
public void securityKeysDoesNotExist() {
    validator = spy(new HostValidator(dbFacade, host));
    doReturn(false).when(validator).haveSecurityKey();
    assertThat(validator.securityKeysExists(), failsWith(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND));
}
#method_after
@Test
public void securityKeysDoesNotExist() {
    validator = spy(new HostValidator(dbFacade, host));
    doReturn(false).when(validator).haveSecurityKey();
    assertThat(validator.securityKeysExists(), failsWith(EngineMessage.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND));
}
#end_block

#method_before
@Test
public void passwordIsEmpty() {
    assertThat(validator.passwordNotEmpty(false, AuthenticationMethod.Password, null), failsWith(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD));
}
#method_after
@Test
public void passwordIsEmpty() {
    assertThat(validator.passwordNotEmpty(false, AuthenticationMethod.Password, null), failsWith(EngineMessage.VDS_CANNOT_INSTALL_EMPTY_PASSWORD));
}
#end_block

#method_before
@Test
public void provisioningComputeResourceEmpty() {
    assertThat(validator.provisioningComputeResourceValid(true, null), failsWith(VdcBllMessages.VDS_PROVIDER_PROVISION_MISSING_COMPUTERESOURCE));
}
#method_after
@Test
public void provisioningComputeResourceEmpty() {
    assertThat(validator.provisioningComputeResourceValid(true, null), failsWith(EngineMessage.VDS_PROVIDER_PROVISION_MISSING_COMPUTERESOURCE));
}
#end_block

#method_before
@Test
public void provisioningHostGroupEmpty() {
    assertThat(validator.provisioningHostGroupValid(true, null), failsWith(VdcBllMessages.VDS_PROVIDER_PROVISION_MISSING_HOSTGROUP));
}
#method_after
@Test
public void provisioningHostGroupEmpty() {
    assertThat(validator.provisioningHostGroupValid(true, null), failsWith(EngineMessage.VDS_PROVIDER_PROVISION_MISSING_HOSTGROUP));
}
#end_block

#method_before
public ValidationResult hostExists() {
    return ValidationResult.failWith(VdcBllMessages.VDS_INVALID_SERVER_ID).when(getHost() == null);
}
#method_after
public ValidationResult hostExists() {
    return ValidationResult.failWith(EngineMessage.VDS_INVALID_SERVER_ID).when(getHost() == null);
}
#end_block

#method_before
public ValidationResult nameNotEmpty() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY).when(StringUtils.isEmpty(host.getName()));
}
#method_after
public ValidationResult nameNotEmpty() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY).when(StringUtils.isEmpty(host.getName()));
}
#end_block

#method_before
public ValidationResult nameLengthIsLegal() {
    int maxHostNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG).when(host.getName().length() > maxHostNameLength);
}
#method_after
public ValidationResult nameLengthIsLegal() {
    int maxHostNameLength = Config.<Integer>getValue(ConfigValues.MaxVdsNameLength);
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG).when(host.getName().length() > maxHostNameLength);
}
#end_block

#method_before
public ValidationResult hostNameIsValid() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME).unless(ValidationUtils.validHostname(host.getHostName()));
}
#method_after
public ValidationResult hostNameIsValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME).unless(ValidationUtils.validHostname(host.getHostName()));
}
#end_block

#method_before
public ValidationResult nameNotUsed() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED).when(hostDao.getByName(host.getName()) != null);
}
#method_after
public ValidationResult nameNotUsed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED).when(hostDao.getByName(host.getName()) != null);
}
#end_block

#method_before
public ValidationResult hostNameNotUsed() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST).unless(hostDao.getAllForHostname(host.getHostName()).isEmpty());
}
#method_after
public ValidationResult hostNameNotUsed() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_HOST_EXIST).unless(hostDao.getAllForHostname(host.getHostName()).isEmpty());
}
#end_block

#method_before
public ValidationResult portIsValid() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT).unless(ValidationUtils.validatePort(host.getSshPort()));
}
#method_after
public ValidationResult portIsValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_PORT).unless(ValidationUtils.validatePort(host.getSshPort()));
}
#end_block

#method_before
public ValidationResult sshUserNameNotEmpty() {
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME).when(StringUtils.isBlank(host.getSshUsername()));
}
#method_after
public ValidationResult sshUserNameNotEmpty() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_INVALID_SSH_USERNAME).when(StringUtils.isBlank(host.getSshUsername()));
}
#end_block

#method_before
public ValidationResult validateSingleHostAttachedToLocalStorage() {
    StoragePool storagePool = storagePoolDao.getForVdsGroup(host.getVdsGroupId());
    if (storagePool == null || !storagePool.isLocal()) {
        return ValidationResult.VALID;
    }
    return ValidationResult.failWith(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE).unless(hostStaticDao.getAllForVdsGroup(host.getVdsGroupId()).isEmpty());
}
#method_after
public ValidationResult validateSingleHostAttachedToLocalStorage() {
    StoragePool storagePool = storagePoolDao.getForVdsGroup(host.getVdsGroupId());
    if (storagePool == null || !storagePool.isLocal()) {
        return ValidationResult.VALID;
    }
    return ValidationResult.failWith(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE).unless(hostStaticDao.getAllForVdsGroup(host.getVdsGroupId()).isEmpty());
}
#end_block

#method_before
public ValidationResult securityKeysExists() {
    return ValidationResult.failWith(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND).when(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !haveSecurityKey());
}
#method_after
public ValidationResult securityKeysExists() {
    return ValidationResult.failWith(EngineMessage.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND).when(Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !haveSecurityKey());
}
#end_block

#method_before
public ValidationResult provisioningComputeResourceValid(boolean provisioned, ExternalComputeResource computeResource) {
    return ValidationResult.failWith(VdcBllMessages.VDS_PROVIDER_PROVISION_MISSING_COMPUTERESOURCE).when(provisioned == true && computeResource == null);
}
#method_after
public ValidationResult provisioningComputeResourceValid(boolean provisioned, ExternalComputeResource computeResource) {
    return ValidationResult.failWith(EngineMessage.VDS_PROVIDER_PROVISION_MISSING_COMPUTERESOURCE).when(provisioned && computeResource == null);
}
#end_block

#method_before
public ValidationResult provisioningHostGroupValid(boolean provisioned, ExternalHostGroup hostGroup) {
    return ValidationResult.failWith(VdcBllMessages.VDS_PROVIDER_PROVISION_MISSING_HOSTGROUP).when(provisioned == true && hostGroup == null);
}
#method_after
public ValidationResult provisioningHostGroupValid(boolean provisioned, ExternalHostGroup hostGroup) {
    return ValidationResult.failWith(EngineMessage.VDS_PROVIDER_PROVISION_MISSING_HOSTGROUP).when(provisioned && hostGroup == null);
}
#end_block

#method_before
public ValidationResult passwordNotEmpty(boolean addPending, AuthenticationMethod authMethod, String password) {
    return ValidationResult.failWith(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD).when(!addPending && authMethod == AuthenticationMethod.Password && StringUtils.isEmpty(password));
}
#method_after
public ValidationResult passwordNotEmpty(boolean addPending, AuthenticationMethod authMethod, String password) {
    return ValidationResult.failWith(EngineMessage.VDS_CANNOT_INSTALL_EMPTY_PASSWORD).when(!addPending && authMethod == AuthenticationMethod.Password && StringUtils.isEmpty(password));
}
#end_block

#method_before
private void setupCommonMock(boolean glusterEnabled) throws Exception {
    mockHostValidator();
    when(commandMock.canDoAction()).thenCallRealMethod();
    when(commandMock.canConnect(any(VDS.class))).thenCallRealMethod();
    when(commandMock.getParameters()).thenReturn(parameters);
    when(commandMock.isGlusterSupportEnabled()).thenReturn(glusterEnabled);
    when(commandMock.getVdsGroupDAO()).thenReturn(groupDAOMock);
    when(commandMock.getClusterUtils()).thenReturn(clusterUtils);
    when(vdsDaoMock.get(vdsId)).thenReturn(null);
    when(commandMock.getVdsDAO()).thenReturn(vdsDaoMock);
    when(commandMock.validateVdsGroup()).thenReturn(true);
    when(commandMock.isPowerManagementLegal(any(Boolean.class), anyListOf(FenceAgent.class), any(String.class))).thenReturn(true);
    when(commandMock.getSSHClient()).thenReturn(sshClient);
    Version version = new Version("1.2.3");
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setCompatibilityVersion(version);
    when(commandMock.getVdsGroup()).thenReturn(vdsGroup);
    when(commandMock.isPowerManagementLegal(parameters.getVdsStaticData().isPmEnabled(), parameters.getFenceAgents(), new Version("1.2.3").toString())).thenReturn(true);
    doNothing().when(sshClient).connect();
    doNothing().when(sshClient).authenticate();
}
#method_after
private void setupCommonMock(boolean glusterEnabled) throws Exception {
    mockHostValidator();
    when(commandMock.canDoAction()).thenCallRealMethod();
    when(commandMock.canConnect(any(VDS.class))).thenCallRealMethod();
    when(commandMock.getParameters()).thenReturn(parameters);
    when(commandMock.isGlusterSupportEnabled()).thenReturn(glusterEnabled);
    when(commandMock.getVdsGroupDao()).thenReturn(groupDaoMock);
    when(commandMock.getClusterUtils()).thenReturn(clusterUtils);
    when(vdsDaoMock.get(vdsId)).thenReturn(null);
    when(commandMock.getVdsDao()).thenReturn(vdsDaoMock);
    when(commandMock.validateVdsGroup()).thenReturn(true);
    when(commandMock.isPowerManagementLegal(any(Boolean.class), anyListOf(FenceAgent.class), any(String.class))).thenReturn(true);
    when(commandMock.getSSHClient()).thenReturn(sshClient);
    Version version = new Version("1.2.3");
    VDSGroup vdsGroup = new VDSGroup();
    vdsGroup.setCompatibilityVersion(version);
    when(commandMock.getVdsGroup()).thenReturn(vdsGroup);
    when(commandMock.isPowerManagementLegal(parameters.getVdsStaticData().isPmEnabled(), parameters.getFenceAgents(), new Version("1.2.3").toString())).thenReturn(true);
    doNothing().when(sshClient).connect();
    doNothing().when(sshClient).authenticate();
}
#end_block

#method_before
private void setupGlusterMock(boolean clusterHasServers, VDS upServer, boolean hasPeers) throws Exception {
    setupCommonMock(true);
    when(commandMock.createReturnValue()).thenCallRealMethod();
    when(commandMock.getReturnValue()).thenCallRealMethod();
    doCallRealMethod().when(commandMock).addCanDoActionMessage(any(VdcBllMessages.class));
    when(commandMock.getGlusterUtil()).thenReturn(glusterUtil);
    when(glusterUtil.getPeers(any(EngineSSHClient.class))).thenReturn(hasPeers ? Collections.singleton(PEER_1) : Collections.<String>emptySet());
    when(commandMock.getGlusterDBUtils()).thenReturn(glusterDBUtils);
    when(clusterUtils.hasServers(any(Guid.class))).thenReturn(clusterHasServers);
    when(vdsDaoMock.getAllForVdsGroup(any(Guid.class))).thenReturn(mockVdsInDb(clusterHasServers ? VDSStatus.Maintenance : VDSStatus.Initializing));
    when(clusterUtils.getUpServer(any(Guid.class))).thenReturn(upServer);
// commandMock.log = log;
}
#method_after
private void setupGlusterMock(boolean clusterHasServers, VDS upServer, boolean hasPeers) throws Exception {
    setupCommonMock(true);
    when(commandMock.createReturnValue()).thenCallRealMethod();
    when(commandMock.getReturnValue()).thenCallRealMethod();
    doCallRealMethod().when(commandMock).addCanDoActionMessage(any(EngineMessage.class));
    when(commandMock.getGlusterUtil()).thenReturn(glusterUtil);
    when(glusterUtil.getPeers(any(EngineSSHClient.class))).thenReturn(hasPeers ? Collections.singleton(PEER_1) : Collections.<String>emptySet());
    when(commandMock.getGlusterDBUtils()).thenReturn(glusterDBUtils);
    when(clusterUtils.hasServers(any(Guid.class))).thenReturn(clusterHasServers);
    when(vdsDaoMock.getAllForVdsGroup(any(Guid.class))).thenReturn(mockVdsInDb(clusterHasServers ? VDSStatus.Maintenance : VDSStatus.Initializing));
    when(clusterUtils.getUpServer(any(Guid.class))).thenReturn(upServer);
// commandMock.log = log;
}
#end_block

#method_before
@Test
public void canDoActionFailsWhenGlusterServerHasPeers() throws Exception {
    setupGlusterMock(true, new VDS(), true);
    when(glusterDBUtils.serverExists(any(Guid.class), eq(PEER_1))).thenReturn(false);
    assertFalse(commandMock.canDoAction());
    assertTrue(commandMock.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER.toString()));
}
#method_after
@Test
public void canDoActionFailsWhenGlusterServerHasPeers() throws Exception {
    setupGlusterMock(true, new VDS(), true);
    when(glusterDBUtils.serverExists(any(Guid.class), eq(PEER_1))).thenReturn(false);
    assertFalse(commandMock.canDoAction());
    assertTrue(commandMock.getReturnValue().getCanDoActionMessages().contains(EngineMessage.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER.toString()));
}
#end_block

#method_before
@Test
public void canDoActionFailsForGlusterServerWhenNoUpServer() throws Exception {
    setupGlusterMock(true, null, false);
    assertFalse(commandMock.canDoAction());
    assertTrue(commandMock.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE.toString()));
}
#method_after
@Test
public void canDoActionFailsForGlusterServerWhenNoUpServer() throws Exception {
    setupGlusterMock(true, null, false);
    assertFalse(commandMock.canDoAction());
    assertTrue(commandMock.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE.toString()));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    addCanDoActionMessageVariable("server", getParameters().getvds().getHostName());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__ADD);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__HOST);
    addCanDoActionMessageVariable("server", getParameters().getvds().getHostName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.error("Failed to remove duplicated oVirt entry with id '{}'. Abort adding oVirt Host type", oVirtId);
            throw new EngineException(EngineError.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getParameters().isProvisioned()) {
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(getHostProvider()));
        proxy.provisionHost(getParameters().getvds(), getParameters().getHostGroup(), getParameters().getComputeResource(), getParameters().getHostMac(), getParameters().getDiscoverName(), getParameters().getPassword(), getParameters().getDiscoverIp());
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVds(getParameters().getvds());
        logable.addCustomValue("HostGroupName", getParameters().getHostGroup().getName());
        auditLogDirector.log(logable, AuditLogType.VDS_PROVISION);
    }
    // set vds spm id
    if (getVdsGroup().getStoragePoolId() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, tempVar, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            initializeVds(true);
            alertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            testVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process or automatically after provision
    if (Config.<Boolean>getValue(ConfigValues.InstallVds) && !getParameters().isPending() && !getParameters().isProvisioned()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        installVdsParameters.setAuthMethod(getParameters().getAuthMethod());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setActivateHost(getParameters().getActivateHost());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        installVdsParameters.setNetworkProviderId(getParameters().getNetworkProviderId());
        installVdsParameters.setNetworkMappings(getParameters().getNetworkMappings());
        installVdsParameters.setEnableSerialConsole(getParameters().getEnableSerialConsole());
        Map<String, String> values = new HashMap<>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getName());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                runInternalAction(VdcActionType.InstallVdsInternal, installVdsParameters, cloneContextAndDetachFromParent().withExecutionContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
protected boolean validateVdsGroup() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    return true;
}
#method_after
protected boolean validateVdsGroup() {
    if (getVdsGroup() == null) {
        return failCanDoAction(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    T params = getParameters();
    setVdsGroupId(params.getVdsStaticData().getVdsGroupId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getVdsGroup().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getNetworkProviderId() != null && !validateNetworkProviderProperties(params.getNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (upServer == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    T params = getParameters();
    setVdsGroupId(params.getVdsStaticData().getVdsGroupId());
    params.setVdsForUniqueId(null);
    // Check if this is a valid cluster
    boolean returnValue = validateVdsGroup();
    if (returnValue) {
        HostValidator validator = getHostValidator();
        returnValue = validate(validator.nameNotEmpty()) && validate(validator.nameLengthIsLegal()) && validate(validator.hostNameIsValid()) && validate(validator.nameNotUsed()) && validate(validator.hostNameNotUsed()) && validate(validator.portIsValid()) && validate(validator.sshUserNameNotEmpty()) && validate(validator.validateSingleHostAttachedToLocalStorage()) && validate(validator.securityKeysExists()) && validate(validator.provisioningComputeResourceValid(params.isProvisioned(), params.getComputeResource())) && validate(validator.provisioningHostGroupValid(params.isProvisioned(), params.getHostGroup())) && validate(validator.passwordNotEmpty(params.isPending(), params.getAuthMethod(), params.getPassword()));
    }
    if (!(returnValue && isPowerManagementLegal(params.getVdsStaticData().isPmEnabled(), params.getFenceAgents(), getVdsGroup().getCompatibilityVersion().toString()) && canConnect(params.getvds()))) {
        return false;
    }
    if (params.getNetworkProviderId() != null && !validateNetworkProviderProperties(params.getNetworkProviderId(), params.getNetworkMappings())) {
        return false;
    }
    if (isGlusterSupportEnabled() && clusterHasNonInitializingServers()) {
        // allow simultaneous installation of hosts, but if a host has completed install, only
        // allow addition of another host if it can be peer probed to cluster.
        VDS upServer = getClusterUtils().getUpServer(getVdsGroupId());
        if (upServer == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
        }
    }
    return true;
}
#end_block

#method_before
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDAO().getAllForVdsGroup(getVdsGroupId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.InstallFailed)
            return true;
    }
    return false;
}
#method_after
private boolean clusterHasNonInitializingServers() {
    for (VDS vds : getVdsDao().getAllForVdsGroup(getVdsGroupId())) {
        if (vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.InstallingOS && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.Initializing && vds.getStatus() != VDSStatus.InstallFailed)
            return true;
    }
    return false;
}
#end_block

#method_before
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().isPending() && !getParameters().isProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDAO().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.error("Failed to authenticate session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.error("Failed to connect to host '{}', fingerprint '{}': {}", vds.getName(), vds.getSshKeyFingerprint(), e.getMessage());
            log.debug("Exception", e);
            addCanDoActionMessage(VdcBllMessages.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessageVariable("ErrorMessage", e.getMessage());
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.error("Failed to establish session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#method_after
protected boolean canConnect(VDS vds) {
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (!getParameters().isPending() && !getParameters().isProvisioned() && Config.<Boolean>getValue(ConfigValues.InstallVds)) {
        try (final EngineSSHClient sshclient = getSSHClient()) {
            sshclient.connect();
            sshclient.authenticate();
            String hostUUID = getInstalledVdsIdIfExists(sshclient);
            if (hostUUID != null && getVdsDao().getAllWithUniqueId(hostUUID).size() != 0) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VDS_WITH_SAME_UUID_EXIST);
            }
            return isValidGlusterPeer(sshclient, vds.getVdsGroupId());
        } catch (AuthenticationException e) {
            log.error("Failed to authenticate session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (SecurityException e) {
            log.error("Failed to connect to host '{}', fingerprint '{}': {}", vds.getName(), vds.getSshKeyFingerprint(), e.getMessage());
            log.debug("Exception", e);
            addCanDoActionMessage(EngineMessage.VDS_SECURITY_CONNECTION_ERROR);
            addCanDoActionMessageVariable("ErrorMessage", e.getMessage());
            return failCanDoAction(EngineMessage.VDS_CANNOT_AUTHENTICATE_TO_SERVER);
        } catch (Exception e) {
            log.error("Failed to establish session with host '{}': {}", vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return failCanDoAction(EngineMessage.VDS_CANNOT_CONNECT_TO_SERVER);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isValidGlusterPeer(SSHClient sshclient, Guid clusterId) {
    if (isGlusterSupportEnabled() && clusterHasServers()) {
        try {
            // Must not allow adding a server that already is part of another gluster cluster
            Set<String> peers = getGlusterUtil().getPeers(sshclient);
            if (peers.size() > 0) {
                for (String peer : peers) {
                    if (getGlusterDBUtils().serverExists(clusterId, peer)) {
                        // peer present in cluster. so server being added is valid.
                        return true;
                    }
                }
                // none of the peers present in the cluster. fail with appropriate error.
                return failCanDoAction(VdcBllMessages.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER);
            }
        } catch (Exception e) {
            // This can happen if glusterd is not running on the server. Ignore it and let the server get added.
            // Peer probe will anyway fail later and the server will then go to non-operational status.
            log.debug("Could not check if server '{}' is already part of another gluster cluster. Will" + " allow adding it.", sshclient.getHost());
            log.debug("Exception", e);
        }
    }
    return true;
}
#method_after
private boolean isValidGlusterPeer(SSHClient sshclient, Guid clusterId) {
    if (isGlusterSupportEnabled() && clusterHasServers()) {
        try {
            // Must not allow adding a server that already is part of another gluster cluster
            Set<String> peers = getGlusterUtil().getPeers(sshclient);
            if (peers.size() > 0) {
                for (String peer : peers) {
                    if (getGlusterDBUtils().serverExists(clusterId, peer)) {
                        // peer present in cluster. so server being added is valid.
                        return true;
                    }
                }
                // none of the peers present in the cluster. fail with appropriate error.
                return failCanDoAction(EngineMessage.SERVER_ALREADY_PART_OF_ANOTHER_CLUSTER);
            }
        } catch (Exception e) {
            // This can happen if glusterd is not running on the server. Ignore it and let the server get added.
            // Peer probe will anyway fail later and the server will then go to non-operational status.
            log.debug("Could not check if server '{}' is already part of another gluster cluster. Will" + " allow adding it.", sshclient.getHost());
            log.debug("Exception", e);
        }
    }
    return true;
}
#end_block

#method_before
protected void addCanDoActionMessage(VdcBllMessages message) {
    super.addCanDoActionMessage(message);
}
#method_after
protected void addCanDoActionMessage(EngineMessage message) {
    super.addCanDoActionMessage(message);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String engineSessionId = (String) request.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
    if (engineSessionId == null) {
        HttpSession session = req.getSession(false);
        if (session != null) {
            engineSessionId = (String) session.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
            if (engineSessionId != null) {
                request.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            }
        }
    }
    if (engineSessionId == null) {
        throw new ServletException("No engine session");
    }
    int prefer = FiltersHelper.getPrefer(req);
    if ((prefer & FiltersHelper.PREFER_PERSISTENCE_AUTH) != 0) {
        HttpSession session = req.getSession(true);
        session.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
        try {
            int ttlValue = Integer.parseInt(req.getHeader("Session-TTL")) * SECONDS_IN_MINUTE;
            if (ttlValue >= MINIMAL_SESSION_TTL) {
                session.setMaxInactiveInterval(ttlValue);
                // this session in the Engine.
                if ((boolean) req.getAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE)) {
                    setEngineSessionSoftLimit(engineSessionId, ttlValue);
                }
            }
        } catch (NumberFormatException ex) {
        // ignore error
        } catch (NamingException ex) {
            log.error("Error in API session management", ex);
            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
    }
    chain.doFilter(request, response);
    try {
        if (FiltersHelper.isAuthenticated(req)) {
            if ((prefer & FiltersHelper.PREFER_PERSISTENCE_AUTH) != 0) {
                HttpSession session = req.getSession(false);
                if (session != null) {
                    ((HttpServletResponse) response).addHeader(FiltersHelper.Constants.HEADER_JSESSIONID_COOKIE, session.getId());
                }
            } else {
                InitialContext ctx = new InitialContext();
                try {
                    FiltersHelper.getBackend(ctx).runAction(VdcActionType.LogoutSession, new VdcActionParametersBase(engineSessionId));
                    HttpSession session = req.getSession(false);
                    if (session != null) {
                        session.invalidate();
                    }
                } finally {
                    ctx.close();
                }
            }
        }
    } catch (Exception ex) {
        log.error("Error in REST-API session management. ", ex);
        throw new ServletException(ex);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    try {
        HttpServletRequest req = (HttpServletRequest) request;
        String engineSessionId = (String) request.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (engineSessionId == null) {
            HttpSession session = req.getSession(false);
            if (session != null) {
                engineSessionId = (String) session.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
                if (engineSessionId != null) {
                    request.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
                }
            }
        }
        if (engineSessionId == null) {
            throw new ServletException("No engine session");
        }
        int prefer = FiltersHelper.getPrefer(req);
        if ((prefer & FiltersHelper.PREFER_PERSISTENCE_AUTH) != 0) {
            HttpSession session = req.getSession(true);
            session.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            try {
                int ttlMinutes = Integer.parseInt(req.getHeader("Session-TTL"));
                if (ttlMinutes >= MINIMAL_SESSION_TTL) {
                    // Save Session-TTL on the HTTP session (in seconds).
                    // TODO: Once UI plugins stop manipulating sessions using the 'Session-TTL' header
                    // (https://bugzilla.redhat.com/1236976) - do this only for new sessions, i.e,
                    // move it into the next 'if' block.
                    session.setMaxInactiveInterval((int) TimeUnit.MINUTES.toSeconds(ttlMinutes));
                    // For new sessions:
                    if (isNewSession(req)) {
                        // Save Session-TTL in the Engine.
                        setEngineSessionSoftLimit(engineSessionId, ttlMinutes);
                    }
                }
            } catch (NumberFormatException ex) {
            // ignore error
            }
        }
        chain.doFilter(request, response);
        if (FiltersHelper.isAuthenticated(req)) {
            if ((prefer & FiltersHelper.PREFER_PERSISTENCE_AUTH) != 0) {
                HttpSession session = req.getSession(false);
                if (session != null) {
                    ((HttpServletResponse) response).addHeader(FiltersHelper.Constants.HEADER_JSESSIONID_COOKIE, session.getId());
                }
            } else {
                InitialContext ctx = new InitialContext();
                try {
                    FiltersHelper.getBackend(ctx).runAction(VdcActionType.LogoutSession, new VdcActionParametersBase(engineSessionId));
                    HttpSession session = req.getSession(false);
                    if (session != null) {
                        try {
                            session.invalidate();
                        } catch (IllegalStateException e) {
                        // ignore
                        }
                    }
                } finally {
                    ctx.close();
                }
            }
        }
    } catch (Exception ex) {
        log.error("Error in REST-API session management. ", ex);
        throw new ServletException(ex);
    }
}
#end_block

#method_before
private void setEngineSessionSoftLimit(String engineSessionId, int ttlValue) throws IOException, NamingException {
    SetDataOnSessionParameters params = new SetDataOnSessionParameters(SOFT_LIMIT_INTERVAL_PARAMETER_NAME, ttlValue);
    params.setSessionId(engineSessionId);
    InitialContext context = null;
    try {
        context = new InitialContext();
        FiltersHelper.getBackend(context).runAction(VdcActionType.SetDataOnSession, params);
    } finally {
        context.close();
    }
}
#method_after
private void setEngineSessionSoftLimit(String engineSessionId, int ttlValue) throws IOException, NamingException {
    InitialContext context = null;
    try {
        context = new InitialContext();
        FiltersHelper.getBackend(context).runAction(VdcActionType.SetSesssionSoftLimit, new SetSesssionSoftLimitCommandParameters(engineSessionId, ttlValue));
    } finally {
        try {
            context.close();
        } catch (NamingException e) {
            log.error("Error in REST-API session management. 'Context' object could not be manually closed. " + "This is a cleanup error only; it does not disturb application flow", e);
        }
    }
}
#end_block

#method_before
public final Object getData(String sessionId, String key, boolean refresh) {
    if (sessionId == null) {
        return null;
    }
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    Object value = null;
    if (sessionInfo != null) {
        if (refresh) {
            refresh(sessionInfo);
        }
        value = sessionInfo.contentOfSession.get(key);
    }
    return value;
}
#method_after
protected final Object getData(String sessionId, String key, boolean refresh) {
    if (sessionId == null) {
        return null;
    }
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    Object value = null;
    if (sessionInfo != null) {
        if (refresh) {
            refresh(sessionInfo);
        }
        value = sessionInfo.contentOfSession.get(key);
    }
    return value;
}
#end_block

#method_before
public final void setData(String sessionId, String key, Object value) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo == null) {
        sessionInfo = new SessionInfo();
        sessionInfo.contentOfSession.put(ENGINE_SESSION_ID, sessionId);
        SessionInfo oldSessionInfo = sessionInfoMap.putIfAbsent(sessionId, sessionInfo);
        if (oldSessionInfo != null) {
            sessionInfo = oldSessionInfo;
        }
    }
    sessionInfo.contentOfSession.put(key, value);
}
#method_after
protected final void setData(String sessionId, String key, Object value) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo == null) {
        sessionInfo = new SessionInfo();
        sessionInfo.contentOfSession.put(ENGINE_SESSION_ID, sessionId);
        // Add default soft-limit interval for new sessions
        sessionInfo.contentOfSession.put(SOFT_LIMIT_INTERVAL_PARAMETER_NAME, Config.<Integer>getValue(ConfigValues.UserSessionTimeOutInterval));
        SessionInfo oldSessionInfo = sessionInfoMap.putIfAbsent(sessionId, sessionInfo);
        if (oldSessionInfo != null) {
            sessionInfo = oldSessionInfo;
        }
    }
    sessionInfo.contentOfSession.put(key, value);
}
#end_block

#method_before
private void refresh(SessionInfo sessionInfo) {
    int softLimitValue = getSoftLimit(sessionInfo);
    if (softLimitValue > 0) {
        sessionInfo.contentOfSession.put(SOFT_LIMIT_PARAMETER_NAME, DateUtils.addMinutes(new Date(), softLimitValue));
    }
}
#method_after
private void refresh(SessionInfo sessionInfo) {
    int softLimitValue = (Integer) (sessionInfo.contentOfSession.get(SOFT_LIMIT_INTERVAL_PARAMETER_NAME));
    if (softLimitValue > 0) {
        sessionInfo.contentOfSession.put(SOFT_LIMIT_PARAMETER_NAME, DateUtils.addMinutes(new Date(), softLimitValue));
    }
}
#end_block

#method_before
public void setDbFacade(DbFacade dbFacade) {
    this.dbFacade = dbFacade;
}
#method_after
// these are public for *TEST* only due to limitation of java.
public void setDbFacade(DbFacade dbFacade) {
    this.dbFacade = dbFacade;
}
#end_block

#method_before
private List<Map<String, String>> availablePublicKeys(String keyFingerPrint, String keyType, String keyContent) {
    List<Map<String, String>> jsonUsers = new ArrayList<>();
    VdcQueryParametersBase userProfileParams = new VdcQueryParametersBase();
    VdcQueryReturnValue v = backend.runInternalQuery(VdcQueryType.GetAllUserProfiles, userProfileParams);
    if (v != null) {
        List<UserProfile> profiles = v.getReturnValue();
        for (UserProfile profile : profiles) {
            if (StringUtils.isNotEmpty(profile.getSshPublicKey())) {
                Map<String, String> jsonUser = new HashMap<String, String>();
                jsonUser.put("entityid", profile.getUserId().toString());
                jsonUser.put("entity", "user-id");
                jsonUser.put("username", profile.getLoginName());
                jsonUser.put("key", profile.getSshPublicKey());
                jsonUsers.add(jsonUser);
            }
        }
    }
    return jsonUsers;
}
#method_after
private List<Map<String, String>> availablePublicKeys(String keyFingerPrint, String keyType, String keyContent) {
    List<Map<String, String>> jsonUsers = new ArrayList<>();
    VdcQueryParametersBase userProfileParams = new VdcQueryParametersBase();
    VdcQueryReturnValue v = backend.runInternalQuery(VdcQueryType.GetAllUserProfiles, userProfileParams);
    if (v != null) {
        List<UserProfile> profiles = v.getReturnValue();
        for (UserProfile profile : profiles) {
            if (StringUtils.isNotEmpty(profile.getSshPublicKey())) {
                IdQueryParameters userparams = new IdQueryParameters(profile.getUserId());
                Map<String, String> jsonUser = new HashMap<String, String>();
                jsonUser.put("entityid", profile.getUserId().toString());
                jsonUser.put("entity", "user-id");
                jsonUser.put("username", profile.getLoginName());
                jsonUser.put("key", profile.getSshPublicKey());
                jsonUsers.add(jsonUser);
            }
        }
    }
    return jsonUsers;
}
#end_block

#method_before
@Override
public VDSReturnValue get(long timeout, TimeUnit unit) throws TimeoutException {
    try {
        status = new StatusOnlyReturnForXmlRpc(httpTask.get(timeout, unit));
        proceedProxyReturnValue();
    } catch (TimeoutException e) {
        httpTask.cancel(true);
        VDSNetworkException ex = new VDSNetworkException("Timeout during xml-rpc call");
        ex.setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, "Timeout during xml-rpc call"));
        setVdsRuntimeError(ex);
        log.error("Timeout waiting for VDSM response: {}", e.getMessage());
        log.debug("Exception", e);
        throw e;
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        if (VDSErrorException.class.isInstance(e) && !"Policy reset".equals(((VDSExceptionBase) e).getVdsError().getMessage())) {
            log.error("Exception", e);
        }
        setVdsRuntimeError(e instanceof RuntimeException ? (RuntimeException) e : new RuntimeException(e));
    }
    return getVDSReturnValue();
}
#method_after
@Override
public VDSReturnValue get(long timeout, TimeUnit unit) throws TimeoutException {
    try {
        status = new StatusOnlyReturnForXmlRpc(httpTask.get(timeout, unit));
        proceedProxyReturnValue();
    } catch (TimeoutException e) {
        httpTask.cancel(true);
        VDSNetworkException ex = new VDSNetworkException("Timeout during xml-rpc call");
        ex.setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, "Timeout during xml-rpc call"));
        setVdsRuntimeError(ex);
        log.error("Timeout waiting for VDSM response: {}", e.getMessage());
        log.debug("Exception", e);
        throw e;
    } catch (VDSNetworkException e) {
        setVdsRuntimeError(e);
        log.error("Error: {}", e.getMessage());
        if (!"Policy reset".equals(e.getVdsError().getMessage())) {
            log.error("Exception", e);
        }
    } catch (Exception e) {
        log.error("Error: {}", e.getMessage());
        log.error("Exception", e);
        setVdsRuntimeError(e instanceof RuntimeException ? (RuntimeException) e : new RuntimeException(e));
    }
    return getVDSReturnValue();
}
#end_block

#method_before
public void filterUnSelectableModels() {
    // Filter UnSelectable models from AvailableStorageItems list
    ArrayList<IStorageModel> filterredItems = new ArrayList<IStorageModel>();
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getItems());
    Set<StorageDomainType> storageDomainTypeItems = new LinkedHashSet<StorageDomainType>();
    Set<StorageType> storageTypeItems = new LinkedHashSet<StorageType>();
    for (IStorageModel model : items) {
        if (((Model) model).getIsSelectable()) {
            filterredItems.add(model);
            storageDomainTypeItems.add(model.getRole());
            storageTypeItems.add(model.getType());
        }
    }
    getModel().getAvailableStorageItems().setItems(filterredItems);
    getModel().getAvailableStorageDomainTypeItems().setItems(storageDomainTypeItems);
    getModel().getAvailableStorageTypeItems().setItems(storageTypeItems);
}
#method_after
public void filterUnSelectableModels() {
    // Filter UnSelectable models from AvailableStorageItems list
    ArrayList<IStorageModel> items = Linq.<IStorageModel>cast(getModel().getItems());
    Set<StorageDomainType> storageDomainTypeItems = new LinkedHashSet<StorageDomainType>();
    Set<StorageType> storageTypeItems = new LinkedHashSet<StorageType>();
    // This is needed as long the AvailableStorageItems List is in use. Other code parts rely on this information. See ImportStorageModelBehavior.
    ArrayList<IStorageModel> filterredItems = new ArrayList<IStorageModel>();
    for (IStorageModel model : items) {
        if (((Model) model).getIsSelectable()) {
            filterredItems.add(model);
            storageDomainTypeItems.add(model.getRole());
            storageTypeItems.add(model.getType());
        }
    }
    getModel().getAvailableStorageItems().setItems(filterredItems);
    getModel().getAvailableStorageDomainTypeItems().setItems(storageDomainTypeItems);
    getModel().getAvailableStorageTypeItems().setItems(storageTypeItems);
}
#end_block

#method_before
private void setNonOperational(NonOperationalReason reason, VDS vds) {
    vds.setNonOperationalReason(reason);
    vds.setStatus(VDSStatus.NonOperational);
    vdsDynamicDao.update(vds.getDynamicData());
}
#method_after
private void setNonOperational(NonOperationalReason reason) {
    runInternalAction(VdcActionType.SetNonOperationalVds, new SetNonOperationalVdsParameters(getVds().getId(), reason), ExecutionHandler.createInternalJobContext(getContext()));
}
#end_block

#method_before
private boolean isLibrbdAvailable() {
    if (!CINDERStorageHelper.isLibrbdAvailable(getVds())) {
        log.error("Couldn't found librbd1 package on vds {} (needed for Cinder storage domains).", getVds().getName());
        setNonOperational(NonOperationalReason.LIBRBD_PACKAGE_NOT_AVAILABLE, getVds());
        return false;
    }
    return true;
}
#method_after
private boolean isLibrbdAvailable() {
    if (!CINDERStorageHelper.isLibrbdAvailable(getVds())) {
        log.error("Couldn't found librbd1 package on vds {} (needed for Cinder storage domains).", getVds().getName());
        setNonOperational(NonOperationalReason.LIBRBD_PACKAGE_NOT_AVAILABLE);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean registerLibvirtSecrets() {
    List<LibvirtSecret> libvirtSecrets = libvirtSecretDao.getAllByStoragePoolIdFilteredByActiveStorageDomains(getStoragePoolId());
    if (!libvirtSecrets.isEmpty() && !registerLibvirtSecrets(libvirtSecrets, false)) {
        setNonOperational(NonOperationalReason.LIBVIRT_SECRETS_REGISTRATION_FAILURE, getVds());
        return false;
    }
    return true;
}
#method_after
private boolean registerLibvirtSecrets() {
    List<LibvirtSecret> libvirtSecrets = libvirtSecretDao.getAllByStoragePoolIdFilteredByActiveStorageDomains(getStoragePoolId());
    if (!libvirtSecrets.isEmpty() && !registerLibvirtSecrets(libvirtSecrets, false)) {
        setNonOperational(NonOperationalReason.LIBVIRT_SECRETS_REGISTRATION_FAILURE);
        return false;
    }
    return true;
}
#end_block

#method_before
private void setNonOperational(NonOperationalReason reason, VDS vds) {
    vds.setNonOperationalReason(reason);
    vds.setStatus(VDSStatus.NonOperational);
    vdsDynamicDao.update(vds.getDynamicData());
}
#method_after
private void setNonOperational(NonOperationalReason reason) {
    runInternalAction(VdcActionType.SetNonOperationalVds, new SetNonOperationalVdsParameters(getVds().getId(), reason), ExecutionHandler.createInternalJobContext(getContext()));
}
#end_block

#method_before
private boolean isLibrbdAvailable() {
    if (!CINDERStorageHelper.isLibrbdAvailable(getVds())) {
        log.error("Couldn't found librbd1 package on vds {} (needed for Cinder storage domains).", getVds().getName());
        setNonOperational(NonOperationalReason.LIBRBD_PACKAGE_NOT_AVAILABLE, getVds());
        return false;
    }
    return true;
}
#method_after
private boolean isLibrbdAvailable() {
    if (!CINDERStorageHelper.isLibrbdAvailable(getVds())) {
        log.error("Couldn't found librbd1 package on vds {} (needed for Cinder storage domains).", getVds().getName());
        setNonOperational(NonOperationalReason.LIBRBD_PACKAGE_NOT_AVAILABLE);
        return false;
    }
    return true;
}
#end_block

#method_before
public void attachCinderDomainToPool(final Guid storageDomainId, final Guid storagePoolId) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            StoragePoolIsoMap storagePoolIsoMap = new StoragePoolIsoMap(storageDomainId, storagePoolId, StorageDomainStatus.Maintenance);
            getStoragePoolIsoMapDAO().save(storagePoolIsoMap);
            return null;
        }
    });
}
#method_after
public void attachCinderDomainToPool(final Guid storageDomainId, final Guid storagePoolId) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            StoragePoolIsoMap storagePoolIsoMap = new StoragePoolIsoMap(storageDomainId, storagePoolId, StorageDomainStatus.Maintenance);
            getStoragePoolIsoMapDao().save(storagePoolIsoMap);
            return null;
        }
    });
}
#end_block

#method_before
public void detachCinderDomainFromPool(final StoragePoolIsoMap mapToRemove) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            getStoragePoolIsoMapDAO().remove(new StoragePoolIsoMapId(mapToRemove.getstorage_id(), mapToRemove.getstorage_pool_id()));
            return null;
        }
    });
}
#method_after
public void detachCinderDomainFromPool(final StoragePoolIsoMap mapToRemove) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(mapToRemove.getstorage_id(), mapToRemove.getstorage_pool_id()));
            return null;
        }
    });
}
#end_block

#method_before
private void updateCinderDomainStatus(final Guid storageDomainId, final Guid storagePoolId, final StorageDomainStatus storageDomainStatus) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(storageDomainId, storagePoolId));
            map.setStatus(storageDomainStatus);
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            return null;
        }
    });
}
#method_after
private void updateCinderDomainStatus(final Guid storageDomainId, final Guid storagePoolId, final StorageDomainStatus storageDomainStatus) {
    execute(new Callable<Object>() {

        @Override
        public Object call() {
            StoragePoolIsoMap map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(storageDomainId, storagePoolId));
            map.setStatus(storageDomainStatus);
            getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            return null;
        }
    });
}
#end_block

#method_before
private VdsDAO getVdsDao() {
    return getDbFacade().getVdsDao();
}
#method_after
private VdsDao getVdsDao() {
    return getDbFacade().getVdsDao();
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    VM vm = performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        if (incoming.isSetPlacementPolicy()) {
            parent.validateAndUpdateHostsInPlacementPolicy(incoming.getPlacementPolicy());
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    VM vm = performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#end_block

#method_before
@Override
public Response start(Action action) {
    RunVmParams params;
    VdcActionType actionType;
    if (action.isSetVm()) {
        VM vm = action.getVm();
        validateEnums(VM.class, vm);
        actionType = VdcActionType.RunVmOnce;
        params = createRunVmOnceParams(vm);
    } else {
        actionType = VdcActionType.RunVm;
        params = new RunVmParams(guid);
    }
    if (action.isSetPause() && action.isPause()) {
        params.setRunAndPause(true);
    }
    if (Boolean.TRUE.equals(action.isUseSysprep())) {
        params.setInitializationType(InitializationType.Sysprep);
    } else if (Boolean.TRUE.equals(action.isUseCloudInit())) {
        params.setInitializationType(InitializationType.CloudInit);
    } else {
        params.setInitializationType(InitializationType.None);
    }
    return doAction(actionType, params, action);
}
#method_after
@Override
public Response start(Action action) {
    RunVmParams params;
    VdcActionType actionType;
    if (action.isSetVm()) {
        VM vm = action.getVm();
        validateEnums(VM.class, vm);
        actionType = VdcActionType.RunVmOnce;
        params = createRunVmOnceParams(vm);
    } else {
        actionType = VdcActionType.RunVm;
        params = new RunVmParams(guid);
    }
    if (action.isSetPause() && action.isPause()) {
        params.setRunAndPause(true);
    }
    boolean useSysprep = action.isSetUseSysprep() && action.isUseSysprep();
    boolean useCloudInit = action.isSetUseCloudInit() && action.isUseCloudInit();
    if (useSysprep && useCloudInit) {
        Fault fault = new Fault();
        fault.setReason(localize(Messages.CANT_USE_SYSPREP_AND_CLOUD_INIT_SIMULTANEOUSLY));
        return Response.status(Response.Status.CONFLICT).entity(fault).build();
    }
    if (useSysprep) {
        params.setInitializationType(InitializationType.Sysprep);
    } else if (useCloudInit) {
        params.setInitializationType(InitializationType.CloudInit);
    } else {
        params.setInitializationType(InitializationType.None);
    }
    return doAction(actionType, params, action);
}
#end_block

#method_before
private RunVmOnceParams createRunVmOnceParams(VM vm) {
    RunVmOnceParams params = map(vm, map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid)));
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        validateParameters(vm.getPlacementPolicy(), "host.id|name");
        params.setDestinationVdsId(getHostId(vm.getPlacementPolicy().getHost()));
    }
    if (vm.isSetInitialization() && vm.getInitialization().isSetCloudInit()) {
        CloudInit cloudInit = vm.getInitialization().getCloudInit();
        // currently only 'root' user is supported, alert the user if other user sent
        if (cloudInit.isSetAuthorizedKeys()) {
            for (AuthorizedKey authKey : cloudInit.getAuthorizedKeys().getAuthorizedKeys()) {
                if (!"root".equals(authKey.getUser().getUserName())) {
                    throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Currently only the user 'root' is supported for authorized keys").build());
                }
            }
        }
        params.setInitializationType(InitializationType.CloudInit);
        params.setVmInit(getMapper(CloudInit.class, VmInit.class).map(cloudInit, null));
    }
    return params;
}
#method_after
private RunVmOnceParams createRunVmOnceParams(VM vm) {
    RunVmOnceParams params = map(vm, map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid)));
    if (vm.isSetPlacementPolicy()) {
        Set<Guid> hostsGuidsSet = parent.validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
        if (hostsGuidsSet.size() > 0) {
            // take the arbitrary first host for run destination
            params.setDestinationVdsId(hostsGuidsSet.iterator().next());
        }
    }
    if (vm.isSetInitialization() && vm.getInitialization().isSetCloudInit()) {
        CloudInit cloudInit = vm.getInitialization().getCloudInit();
        // currently only 'root' user is supported, alert the user if other user sent
        if (cloudInit.isSetAuthorizedKeys()) {
            for (AuthorizedKey authKey : cloudInit.getAuthorizedKeys().getAuthorizedKeys()) {
                if (!"root".equals(authKey.getUser().getUserName())) {
                    throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("Currently only the user 'root' is supported for authorized keys").build());
                }
            }
        }
        params.setInitializationType(InitializationType.CloudInit);
        params.setVmInit(getMapper(CloudInit.class, VmInit.class).map(cloudInit, null));
    }
    return params;
}
#end_block

#method_before
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
protected BackendInternal getBackend() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    DefaultCompensationContext defaultContext = new DefaultCompensationContext();
    defaultContext.setCommandId(commandId);
    defaultContext.setCommandType(getClass().getName());
    defaultContext.setBusinessEntitySnapshotDAO(getBusinessEntitySnapshotDAO());
    defaultContext.setSnapshotSerializer(SerializationFactory.getSerializer());
    return defaultContext;
}
#method_after
private CompensationContext createCompensationContext(TransactionScopeOption transactionScopeOption, boolean forceCompensation) {
    if (transactionScopeOption == TransactionScopeOption.Suppress && !forceCompensation) {
        return NoOpCompensationContext.getInstance();
    }
    return createDefaultCompensationContext(commandId);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
            clearChildAsyncTasksWithOutVdsmId();
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDao().getAllForCommandId(commandId);
            log.debug("Command [id={}]: {} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.info("Command [id={}]: Compensating {} of {}; snapshot: {}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.DELETED_OR_UPDATED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case DELETED_OR_UPDATED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case UPDATED_ONLY_ENTITY:
                        daoForEntity.update((BusinessEntity<Serializable>) snapshotData);
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDAO().removeAllForCommandId(commandId);
    }
}
#method_after
private void cleanUpCompensationData() {
    if (!(getCompensationContext() instanceof NoOpCompensationContext)) {
        getBusinessEntitySnapshotDao().removeAllForCommandId(commandId);
    }
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        startFinalizingStep();
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("endAction: Transaction was aborted in {}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            setCommandStatus(CommandStatus.SUCCEEDED);
            internalEndSuccessfully();
        } else {
            setCommandStatus(CommandStatus.FAILED);
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            internalEndSuccessfully();
        } else {
            if (getCallback() == null) {
                setCommandStatus(CommandStatus.FAILED);
            }
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    AuditLogDirector.log(logable, logType);
}
#method_after
void auditLog(AuditLogableBase logable, AuditLogType logType) {
    auditLogDirector.log(logable, logType);
}
#end_block

#method_before
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = TransactionSupport.suspend();
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed. Reasons: {}", getActionType(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            TransactionSupport.resume(transaction);
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#method_after
private boolean internalCanDoAction() {
    boolean returnValue = false;
    try {
        Transaction transaction = null;
        if (!isCanDoActionSupportsTransaction()) {
            transaction = TransactionSupport.suspend();
        }
        try {
            returnValue = isUserAuthorizedToRunAction() && isBackwardsCompatible() && validateInputs() && acquireLock() && canDoAction() && internalValidateAndSetQuota();
            if (!returnValue && getReturnValue().getCanDoActionMessages().size() > 0) {
                log.warn("CanDoAction of action '{}' failed for user {}. Reasons: {}", getActionType(), getUserName(), StringUtils.join(getReturnValue().getCanDoActionMessages(), ','));
            }
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    } catch (DataAccessException dataAccessEx) {
        log.error("Data access error during CanDoActionFailure.", dataAccessEx);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_DATABASE_CONNECTION_FAILURE);
    } catch (RuntimeException ex) {
        log.error("Error during CanDoActionFailure.", ex);
        addCanDoActionMessage(VdcBllMessages.CAN_DO_ACTION_GENERAL_FAILURE);
    } finally {
        if (!returnValue) {
            freeLock();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isBackwardsCompatible() {
    boolean result = true;
    ActionVersionMap actionVersionMap = DbFacade.getInstance().getActionGroupDao().getActionVersionMapByActionType(getActionType());
    // cluster level ok check storage_pool level
    if (actionVersionMap != null && ((getVdsGroup() != null && getVdsGroup().getcompatibility_version().compareTo(new Version(actionVersionMap.getcluster_minimal_version())) < 0) || (!"*".equals(actionVersionMap.getstorage_pool_minimal_version()) && getStoragePool() != null && getStoragePool().getcompatibility_version().compareTo(new Version(actionVersionMap.getstorage_pool_minimal_version())) < 0))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return result;
}
#method_after
protected boolean isBackwardsCompatible() {
    boolean result = true;
    ActionVersionMap actionVersionMap = DbFacade.getInstance().getActionGroupDao().getActionVersionMapByActionType(getActionType());
    // cluster level ok check storage_pool level
    if (actionVersionMap != null && ((getVdsGroup() != null && getVdsGroup().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getcluster_minimal_version())) < 0) || (!"*".equals(actionVersionMap.getstorage_pool_minimal_version()) && getStoragePool() != null && getStoragePool().getCompatibilityVersion().compareTo(new Version(actionVersionMap.getstorage_pool_minimal_version())) < 0))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    return result;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, Collection<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debug("Checking whether user '{}' or groups '{}' have action group '{}' on object type '{}'", userId, groupIds, actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDAO().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, Collection<Guid> groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    if (log.isDebugEnabled()) {
        log.debug("Checking whether user '{}' or groups '{}' have action group '{}' on object type '{}'", userId, groupIds, actionGroup, object, type.name());
    }
    final Guid permId = getPermissionDao().getEntityPermissionsForUserAndGroups(userId, StringUtils.join(groupIds, ","), actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debug("Found permission '{}' for user when running '{}', on '{}' with id '{}'", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debug("No permission found for user when running action '{}', on object '{}' for action group '{}' with id '{}'.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
final public boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debug("The object to check is null for action '{}'.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debug("No action group is defined for action '{}'.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            clearChildAsyncTasksWithOutVdsmId();
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallBack() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (_returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            // set the status to SUCCEEDED if the status is ACTIVE
            if (getTaskType() == AsyncTaskType.notSupported && getReturnValue().getVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.SUCCEEDED);
            }
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    if (getCallBack() != null) {
        persistCommand(getParameters().getParentCommand(), true);
    }
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (getCallback() != null || parentHasCallback()) {
        persistCommand(getParameters().getParentCommand(), getCallback() != null);
    }
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.info("Transaction was aborted in '{}'", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logCommand();
            }
            if (getSucceeded()) {
                if (getCommandShouldBeLogged()) {
                    logRenamedEntity();
                }
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (noAsyncOperations() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTask task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.error("Error during persistAsyncTaskPlaceHolder for command '{}': {}", getClass().getName(), ex.getMessage());
        log.error("Exception", ex);
    }
    return taskId;
}
#end_block

#method_before
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || (!hasTasks() && !(this instanceof IVdsAsyncCommand))) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || (noAsyncOperations() && !(this instanceof IVdsAsyncCommand))) {
        freeLock();
    }
}
#end_block

#method_before
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
        // free other locks here to guarantee they will be freed only once
        freeCustomLocks();
    }
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            addCanDoActionMessage(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
/**
 * Adds one ore more messages to the {@link CommandBase#canDoAction()}'s return value. This return value will be
 * sent to the client for the detailed information of why the action can't be performed.
 *
 * @param message
 *            The message to add.
 */
protected void addCanDoActionMessages(VdcBllMessages... messages) {
    for (VdcBllMessages msg : messages) {
        addCanDoActionMessage(msg);
    }
}
#method_after
/**
 * Adds one or more messages to the {@link CommandBase#canDoAction()}'s return value. This return value will be sent
 * to the client for the detailed information of why the action can't be performed.
 *
 * @param messages
 *            The messages to add.
 */
protected final void addCanDoActionMessages(VdcBllMessages... messages) {
    for (VdcBllMessages msg : messages) {
        addCanDoActionMessage(msg);
    }
}
#end_block

#method_before
protected QuotaManager getQuotaManager() {
    return QuotaManager.getInstance();
}
#method_after
protected QuotaManager getQuotaManager() {
    return quotaManager;
}
#end_block

#method_before
protected void propagateFailure(VdcReturnValueBase internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().addAll(internalReturnValue.getExecuteFailedMessages());
    getReturnValue().setFault(internalReturnValue.getFault());
    getReturnValue().getCanDoActionMessages().addAll(internalReturnValue.getCanDoActionMessages());
    getReturnValue().setCanDoAction(internalReturnValue.getCanDoAction());
}
#method_after
protected void propagateFailure(VdcQueryReturnValue internalReturnValue) {
    getReturnValue().getExecuteFailedMessages().add(internalReturnValue.getExceptionString());
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallBack) {
    persistCommand(parentCommand, getContext(), enableCallBack);
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallback) {
    persistCommand(parentCommand, getContext(), enableCallback);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandCoordinatorUtil.persistCommand(buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallBack), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallback) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity commandEntity = buildCommandEntity(getParentParameters(parentCommand).getCommandId(), enableCallback);
        CommandCoordinatorUtil.persistCommand(commandEntity, cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private CommandEntity buildCommandEntity(Guid parentCommandId, boolean callBackEnabled) {
    return CommandEntity.buildCommandEntity(getCommandId(), parentCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, callBackEnabled, getReturnValue());
}
#method_after
private CommandEntity buildCommandEntity(Guid parentCommandId, boolean enableCallback) {
    return CommandEntity.buildCommandEntity(getUserId(), getCommandId(), parentCommandId, getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallback, getReturnValue());
}
#end_block

#method_before
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallBackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandExecuted() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(getCommandId());
        if (cmdEntity != null) {
            CommandCoordinatorUtil.persistCommand(buildCommandEntity(cmdEntity.getRootCommandId(), cmdEntity.isCallbackEnabled()), getContext());
            CommandCoordinatorUtil.updateCommandExecuted(getCommandId());
        }
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmSessionsModel vmSessionsModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmSessionsModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmGuestInfoModel vmGuestInfoModel, final VmHostDeviceListModel vmHostDeviceListModel, final VmDevicesListModel vmDevicesListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmDevicesListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmGuestInfoModel);
    list.add(vmHostDeviceListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    List<UICommand> commands = new ArrayList<>();
    // $NON-NLS-1$
    commands.add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    commands.add(UICommand.createCancelUiCommand("Cancel", this));
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior(), this);
    setupNewVmModel(model, VmType.Server, getSystemTreeSelectedItem(), commands);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm), this);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnSave", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangable(isChangable);
}
#method_after
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangeable(isChangable);
}
#end_block

#method_before
private void newTemplate() {
    VM vm = getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#method_after
private void newTemplate() {
    VM vm = getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm), this);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    model.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(getSystemTreeSelectedItem());
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnNewTemplate", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel<Void> vmListModel = (VmListModel<Void>) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setBalloonEnabled(balloonEnabled(model));
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
private void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = getSelectedItem();
    VM newVm = buildVmOnNewTemplate(model, vm);
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToAddVmTemplateParametersBuilder());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder(), new MigrationOptionsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new VmBaseToVmBaseForTemplateCompositeBaseBuilder());
    return resultVm;
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), vm.getCurrentCd())) {
        cancel();
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setValidTab(TabName.GENERAL_TAB, true);
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("OnSave_Phase2", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    onSave();
                }
            }
        }
    }), name);
}
#method_after
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    String selectedCpu = model.getCustomCpu().getSelectedItem();
    if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
        // $NON-NLS-1$
        confirmCustomCpu("PreSavePhase2");
    } else {
        preSavePhase2();
    }
}
#end_block

#method_before
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#method_after
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), getSelectedItem()), updateVmParams, new VmIconUnitAndVmToParameterBuilder());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#end_block

#method_before
public void cancel() {
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionAvailability();
}
#method_after
@Override
public void cancel() {
    cancelConfirmation();
    setGuideContext(null);
    setWindow(null);
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionsAvailability();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnSave_Phase2".equals(command.getName())) {
        onSave();
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "PreSavePhase2".equals(command.getName())) {
        preSavePhase2();
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportFromExportDomainModel(new UICommand(CMD_RESTORE_FROM_EXPORT_DOMAIN, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            onRestoreFromExportDomain();
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#method_after
private void importVms() {
    if (getWindow() != null) {
        return;
    }
    final ImportVmsModel model = importVmsModelProvider.get();
    model.init();
    setWindow(model);
    model.getCommands().add(new UICommand(CMD_CONFIGURE_VMS_TO_IMPORT, this).setIsExecutionAllowed(false).setTitle(ConstantsManager.getInstance().getConstants().next()).setIsDefault(true));
    model.getCommands().add(new UICommand(CMD_CANCEL, this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
    model.initImportModels(new UICommand(CMD_IMPORT, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            model.onRestoreVms(new IFrontendMultipleActionAsyncCallback() {

                @Override
                public void executed(FrontendMultipleActionAsyncResult result) {
                    setWindow(null);
                }
            });
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true), new UICommand(CMD_BACK, new BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            // remove current window first
            setWindow(null);
            setWindow(model);
        }
    }).setTitle(ConstantsManager.getInstance().getConstants().back()), new UICommand(CMD_CANCEL, this).setIsCancel(true).setTitle(ConstantsManager.getInstance().getConstants().cancel()));
}
#end_block

#method_before
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    ImportVmFromExportDomainModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#method_after
private void onConfigureVmsToImport() {
    final ImportVmsModel importVmsModel = (ImportVmsModel) getWindow();
    if (importVmsModel == null) {
        return;
    }
    final ImportVmModel model = importVmsModel.getSpecificImportModel();
    // remove import-vms window first
    setWindow(null);
    setWindow(model);
}
#end_block

#method_before
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(TabName.HOST_TAB, this.hostTab);
    getTabNameMapping().put(TabName.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(TabName.POOL_TAB, this.poolTab);
    getTabNameMapping().put(TabName.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(TabName.SYSTEM_TAB, this.systemTab);
}
#method_after
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(TabName.HOST_TAB, this.hostTab);
    getTabNameMapping().put(TabName.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(TabName.POOL_TAB, this.poolTab);
    getTabNameMapping().put(TabName.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(TabName.SYSTEM_TAB, this.systemTab);
    getTabNameMapping().put(TabName.ICON_TAB, this.iconTab);
}
#end_block

#method_before
private void initDetachableFields() {
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    StringEntityModelLabel rnglabel = new StringEntityModelLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#method_after
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    StringEntityModelLabel rnglabel = new StringEntityModelLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#end_block

#method_before
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    // $NON-NLS-1$
    label.addStyleName("numCPUs_pfly_fix");
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#method_after
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    // $NON-NLS-1$
    label.addStyleName("numCPUs_pfly_fix");
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(templates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#end_block

#method_before
public void setSpiceProxyOverrideExplanation(String explanation) {
    spiceProxyEnabledCheckboxWithInfoIcon.setExplanation(applicationTemplates.italicText(explanation));
}
#method_after
public void setSpiceProxyOverrideExplanation(String explanation) {
    spiceProxyEnabledCheckboxWithInfoIcon.setExplanation(templates.italicText(explanation));
}
#end_block

#method_before
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // $NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""), resources);
}
#method_after
protected void initPoolSpecificWidgets() {
    createNumOfDesktopEditors();
    newPoolPrestartedVmsIcon = new InfoIcon(templates.italicText(messages.prestartedHelp()));
    editPoolPrestartedVmsIcon = new InfoIcon(templates.italicText(messages.prestartedHelp()));
    poolNameIcon = new InfoIcon(templates.italicText(messages.poolNameHelp()));
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(templates.italicText(messages.maxAssignedVmsPerUserHelp()));
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(templates.italicText(messages.maxAssignedVmsPerUserHelp()));
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // $NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = emulatedMachine.getNullReplacementString();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = customCpu.getNullReplacementString();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<CpuProfile>(new NullSafeRenderer<CpuProfile>() {

        @Override
        protected String renderNullSafe(CpuProfile object) {
            return object.getName();
        }
    });
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<NumaTuneMode>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public SortedMap<String, List<DataCenterWithCluster>> getGroupedList(List<DataCenterWithCluster> acceptableValues) {
            SortedMap<String, List<DataCenterWithCluster>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterWithClusterComparator());
            String currentDataCenter = null;
            List<DataCenterWithCluster> currentClusterWithDcList = null;
            for (DataCenterWithCluster clusterWithDc : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(clusterWithDc.getDataCenter().getName())) {
                    currentClusterWithDcList = new ArrayList<>();
                    currentDataCenter = clusterWithDc.getDataCenter().getName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterWithDcList);
                    }
                }
                if (currentClusterWithDcList != null) {
                    currentClusterWithDcList.add(clusterWithDc);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<ConsoleDisconnectAction>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<NumaTuneMode>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return applicationTemplates.typeAheadNameDescription(name != null ? name : "", description != null ? description : "").asString();
}
#method_after
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return templates.typeAheadNameDescription(name != null ? name : "", description != null ? description : "").asString();
}
#end_block

#method_before
private String typeAheadNameTemplateNullSafe(String name) {
    if (name != null && !name.trim().isEmpty()) {
        return applicationTemplates.typeAheadName(name).asString();
    } else {
        return applicationTemplates.typeAheadEmptyContent().asString();
    }
}
#method_after
private String typeAheadNameTemplateNullSafe(String name) {
    if (name != null && !name.trim().isEmpty()) {
        return templates.typeAheadName(name).asString();
    } else {
        return templates.typeAheadEmptyContent().asString();
    }
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
}
#method_after
protected void localize() {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    detachableInstanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isIoThreadsEnabled.setLabel(constants.ioThreadsEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    consoleDisconnectActionEditor.setLabel(constants.consoleDisconnectActionVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    numOfIoThreadsEditor.setLabel(constants.numOfIoThreadsVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
    // Icon tab
    iconTab.setLabel(constants.iconTabVmPopup());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#end_block

#method_before
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(applicationTemplates.italicText(message));
}
#method_after
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(templates.italicText(message));
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            DataCenterWithCluster dataCenterWithCluster = object.getDataCenterWithClustersList().getSelectedItem();
            String newClusterEmulatedMachine;
            String newClusterCpuModel;
            if (dataCenterWithCluster == null) {
                // $NON-NLS-1$
                newClusterEmulatedMachine = "";
                // $NON-NLS-1$
                newClusterCpuModel = "";
            } else {
                // $NON-NLS-1$
                newClusterEmulatedMachine = (dataCenterWithCluster.getCluster().getEmulatedMachine() == null) ? "" : dataCenterWithCluster.getCluster().getEmulatedMachine();
                // $NON-NLS-1$
                newClusterCpuModel = (dataCenterWithCluster.getCluster().getCpuName() == null) ? "" : dataCenterWithCluster.getCluster().getCpuName();
            }
            // $NON-NLS-1$ //$NON-NLS-2$
            emulatedMachine.setNullReplacementString(constants.clusterDefaultOption() + "(" + newClusterEmulatedMachine + ")");
            // $NON-NLS-1$ //$NON-NLS-2$
            customCpu.setNullReplacementString(constants.clusterDefaultOption() + "(" + newClusterCpuModel + ")");
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(instanceImagesEditor, hiddenField());
}
#end_block

#method_before
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#method_after
protected List<Widget> consoleTabWidgets() {
    return Arrays.<Widget>asList(displayTypeEditor, graphicsTypeEditor, usbSupportEditor, consoleDisconnectActionEditor, isSmartcardEnabledEditor, nativeUsbWarningMessage, expander, numOfMonitorsEditor, vncKeyboardLayoutEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent);
}
#end_block

#method_before
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab);
}
#method_after
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab, iconTab);
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
private List<DialogTab> allDialogTabs() {
    return Arrays.asList(generalTab, poolTab, initialRunTab, consoleTab, hostTab, highAvailabilityTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, systemTab, rngDeviceTab);
}
#method_after
private List<DialogTab> allDialogTabs() {
    return Arrays.asList(generalTab, poolTab, initialRunTab, consoleTab, hostTab, highAvailabilityTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, systemTab, rngDeviceTab, iconTab);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrDefault(dataCenters, new DataCenterPredicate(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.setKsmPolicyForNuma(cluster.isKsmMergeAcrossNumaNodes());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getGroupHostsAndVms().getHosts() == 0);
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    List<GlusterVolumeEntity> volumes = (List<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    ServerCpu vdsCpu = getVdsGroupServerCpu(model, getSelectedItem());
    if (vdsCpu != null && model.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(model);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ClusterModel clusterModel = (ClusterModel) model;
                final Map<String, String> highCpuVms = (Map<String, String>) result;
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(clusterModel);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        Integer activeVms = (Integer) result;
                        StringBuilder message = new StringBuilder();
                        if (!highCpuVms.isEmpty()) {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelCustomVmCpusMessage());
                            for (Map.Entry<String, String> highCpu : highCpuVms.entrySet()) {
                                // $NON-NLS-1$
                                message.append("* \"");
                                // $NON-NLS-1$
                                message.append(highCpu.getKey());
                                // $NON-NLS-1$
                                message.append("\" - ");
                                message.append(highCpu.getValue());
                                // $NON-NLS-1$
                                message.append(" CPU\n");
                            }
                        }
                        if (activeVms > 0) {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelWhileRunningMessage());
                        }
                        if (message.length() == 0) {
                            onSaveInternal();
                        } else {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelWarningMessage());
                            cpuLevelConfirmationWindow(message.toString());
                        }
                    }
                };
                AsyncDataProvider.getInstance().getNumberOfActiveVmsInCluster(_asyncQuery, getSelectedItem().getId());
            }
        };
        AsyncDataProvider.getInstance().verifyClusterSupportsVmCpu(_asyncQuery, getSelectedItem().getId(), model.getCPU().getSelectedItem().getCpuName());
    } else {
        onSaveInternal();
    }
}
#method_after
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    ServerCpu vdsCpu = getVdsGroupServerCpu(model, getSelectedItem());
    if (vdsCpu != null && model.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
        getWindow().startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(model);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ClusterModel clusterModel = (ClusterModel) model;
                final Map<String, String> highCpuVms = (Map<String, String>) result;
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(clusterModel);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        Integer activeVms = (Integer) result;
                        StringBuilder message = new StringBuilder();
                        if (!highCpuVms.isEmpty()) {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelCustomVmCpusMessage());
                            for (Map.Entry<String, String> highCpu : highCpuVms.entrySet()) {
                                // $NON-NLS-1$ // no format strings in GWT
                                message.append("* \"");
                                // $NON-NLS-1$
                                message.append(highCpu.getKey());
                                // $NON-NLS-1$
                                message.append("\" - ");
                                message.append(highCpu.getValue());
                                // $NON-NLS-1$
                                message.append(" CPU\n");
                            }
                        }
                        if (activeVms > 0) {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelWhileRunningMessage());
                        }
                        getWindow().stopProgress();
                        if (message.length() == 0) {
                            onSaveInternal();
                        } else {
                            message.append(ConstantsManager.getInstance().getConstants().changeCpuLevelWarningMessage());
                            cpuLevelConfirmationWindow(message.toString());
                        }
                    }
                };
                AsyncDataProvider.getInstance().getNumberOfActiveVmsInCluster(_asyncQuery, getSelectedItem().getId());
            }
        };
        AsyncDataProvider.getInstance().getClusterUnsupportedVmsCpus(_asyncQuery, getSelectedItem().getId(), model.getCPU().getSelectedItem().getCpuName());
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, model.getIsNew() ? new AddClusterOperationParameters(cluster) : new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setKsmMergeAcrossNumaNodes(model.getKsmPolicyForNuma());
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    getResetEmulatedMachineCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getResetEmulatedMachineCommand()) {
        resetEmulatedMachine();
    } else if ("OnResetClusterEmulatedMachine".equals(command.getName())) {
        // $NON-NLS-1$
        onResetClusterEmulatedMachine();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(getSelectedItem().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> model = (ClusterListModel<Void>) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#method_after
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(getSelectedItem().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> model = (ClusterListModel<Void>) target;
            List<VDS> hosts = null;
            if (returnValue instanceof List) {
                hosts = (List<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof List) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#end_block

#method_before
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmSessionsModel.setIsAvailable(true);
    List<HasEntity<?>> /* extends VmOrPool */
    list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmSessionsModel);
    setDetailModels((List) list);
}
#method_after
private void setDetailList() {
    vmGeneralModel.setIsAvailable(false);
    vmSnapshotListModel.setIsAvailable(false);
    vmMonitorModel.setIsAvailable(false);
    vmDiskListModel.setIsAvailable(false);
    vmInterfaceListModel.setIsAvailable(false);
    poolGeneralModel.setIsAvailable(false);
    poolDiskListModel.setIsAvailable(false);
    poolInterfaceListModel.setIsAvailable(false);
    permissionListModel.setIsAvailable(true);
    vmEventListModel.setIsAvailable(true);
    vmAppListModel.setIsAvailable(true);
    vmGuestInfoModel.setIsAvailable(true);
    List<HasEntity<?>> /* extends VmOrPool */
    list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(poolGeneralModel);
    list.add(vmInterfaceListModel);
    list.add(poolInterfaceListModel);
    list.add(vmDiskListModel);
    list.add(poolDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(permissionListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmMonitorModel);
    list.add(vmGuestInfoModel);
    setDetailModels((List) list);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        stopProgress(UserPortalListModel.this);
        setConfirmWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(UserPortalListModel.this, model.getApplyCpuLater().getEntity());
        setConfirmWindow(null);
    } else if ("postVmNameUniqueCheck".equals(command.getName())) {
        // $NON-NLS-1$
        postVmNameUniqueCheck();
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnSetConsoleKey".equals(command.getName())) {
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        stopProgress(UserPortalListModel.this);
        setConfirmWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(UserPortalListModel.this, model.getApplyCpuLater().getEntity());
        setConfirmWindow(null);
    } else if ("postVmNameUniqueCheck".equals(command.getName())) {
        // $NON-NLS-1$
        postVmNameUniqueCheck();
        setConfirmWindow(null);
    }
}
#end_block

#method_before
private void newTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm));
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#method_after
private void newTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    UnitVmModel windowModel = new UnitVmModel(new UserPortalNewTemplateVmModelBehavior(vm), this);
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    windowModel.setHelpTag(HelpTag.new_template);
    // $NON-NLS-1$
    windowModel.setHashName("new_template");
    windowModel.setIsNew(true);
    windowModel.getVmType().setSelectedItem(vm.getVmType());
    windowModel.initialize(null);
    windowModel.getIsTemplatePublic().setEntity(false);
    windowModel.getCommands().add(// $NON-NLS-1$)
    UICommand.createDefaultOkUiCommand("OnNewTemplate", this));
    // $NON-NLS-1$
    windowModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    windowModel.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate(false)) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    }
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder<VmStatic>());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder(), new CpuSharesVmBaseToVmBaseBuilder());
    return tempVar;
}
#end_block

#method_before
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior(), this);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm), this);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setValidTab(TabName.GENERAL_TAB, false);
                stopProgress(target);
            } else {
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postVmNameUniqueCheck", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    userPortalListModel.postVmNameUniqueCheck();
                }
            }
        }
    }), model.getName().getEntity(), model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) (getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) (getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        // currentl only hot plug memory is supported here (no hot unplug)
                        confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < gettempVm().getMemSizeMb());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm((UserPortalListModel) thisModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(this, false);
        }
    }
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVmLargeIcon(model.getIcon().getEntity().getIcon());
    setRngDeviceToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#end_block

#method_before
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#method_after
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), gettempVm()), params, new VmIconUnitAndVmToParameterBuilder());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#end_block

#method_before
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangable(vm.getStatus() == VMStatus.Down);
}
#method_after
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangeable(vm.getStatus() == VMStatus.Down);
}
#end_block

#method_before
private void vmModel_DefaultHost_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        VDS host = null;
        for (VDS item : model.getDefaultHost().getItems()) {
            if (item.getId().equals(((vm.getDedicatedVmForVds() != null) ? vm.getDedicatedVmForVds() : Guid.Empty))) {
                host = item;
                break;
            }
        }
        if (host == null) {
            model.getIsAutoAssign().setEntity(true);
        } else {
            model.getDefaultHost().setSelectedItem(host);
            model.getIsAutoAssign().setEntity(false);
        }
    }
}
#method_after
private void vmModel_DefaultHost_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        VM vm = (VM) selectedItem.getEntity();
        VDS host = null;
        for (VDS item : model.getDefaultHost().getItems()) {
            if (vm.getDedicatedVmForVdsList().contains(item.getId())) {
                host = item;
                break;
            }
        }
        if (host == null) {
            model.getIsAutoAssign().setEntity(true);
        } else {
            model.getDefaultHost().setSelectedItem(host);
            model.getIsAutoAssign().setEntity(false);
        }
    }
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        if (filteredPools.isEmpty()) {
            finishSearch(all);
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    finishSearch(all);
                }
            });
        }
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        final ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        final List<Object> vms = Collections.<Object>unmodifiableList(getvms());
        final List<Pair<Object, VM>> vmPairs = Linq.wrapAsFirst(vms, VM.class);
        if (filteredPools.isEmpty()) {
            IconUtils.prefetchIcons(getvms(), true, false, new IconCache.IconsCallback() {

                @Override
                public void onSuccess(Map<Guid, String> idToIconMap) {
                    finishSearch(vmPairs);
                }
            });
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    final List<Pair<Object, VM>> poolsPairs = Linq.zip(Collections.<Object>unmodifiableList(filteredPools), poolRepresentants);
                    final List<Pair<Object, VM>> all = Linq.concat(vmPairs, poolsPairs);
                    final List<VM> vmsAndPoolRepresentants = Linq.concat(getvms(), poolRepresentants);
                    IconUtils.prefetchIcons(vmsAndPoolRepresentants, true, false, new IconCache.IconsCallback() {

                        @Override
                        public void onSuccess(Map<Guid, String> idToIconMap) {
                            finishSearch(all);
                        }
                    });
                }
            });
        }
    }
}
#end_block

#method_before
private void finishSearch(List vmsAndFilteredPools) {
    consoleModelsCache.updateVmCache(getvms());
    Collections.sort(vmsAndFilteredPools, new NameableComparator());
    ArrayList<Model> items = new ArrayList<Model>();
    for (Object item : vmsAndFilteredPools) {
        VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
        UserPortalItemModel model = new UserPortalItemModel(item, consoles);
        model.setEntity(item);
        items.add(model);
    }
    setItems(items);
    setvms(null);
    setpools(null);
    getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
}
#method_after
private void finishSearch(List<Pair<Object, VM>> vmOrPoolAndPoolRepresentants) {
    consoleModelsCache.updateVmCache(getvms());
    Collections.sort((List) vmOrPoolAndPoolRepresentants, IconUtils.getFirstComponentNameableComparator());
    ArrayList<Model> items = new ArrayList<Model>();
    for (Pair<Object, VM> item : vmOrPoolAndPoolRepresentants) {
        VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item.getFirst());
        UserPortalItemModel model = new UserPortalItemModel(item.getFirst(), consoles, item.getSecond());
        model.setEntity(item.getFirst());
        items.add(model);
    }
    setItems(items);
    setvms(null);
    setpools(null);
    getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(PoolListModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(PoolVmListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VmPool>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<PoolListModel, PoolGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<PoolListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, PoolListModel, PermissionListModel<VmPool>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VmPool, PoolListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(PoolListModel.class).in(Singleton.class);
    bind(PoolGeneralModel.class).in(Singleton.class);
    bind(PoolVmListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VmPool>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<PoolListModel, PoolGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<PoolListModel, PoolGeneralModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, PoolListModel, PermissionListModel<VmPool>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VmPool, PoolListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
public void edit() {
    final VmPool pool = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modell, Object result) {
            final VM vm = ((VdcQueryReturnValue) result).getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener<EventArgs>() {

                @Override
                public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (EntityModel<VmPoolType> item : model.getPoolType().getItems()) {
                        if (item.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(item);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getVdsGroupId())));
                        model.getTemplateWithVersion().setIsChangable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems()));
                    }
                    model.getDataCenterWithClustersList().setIsChangable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangable(false);
                    model.getStorageDomain().setIsChangable(false);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            model.startProgress("");
            // $NON-NLS-1$
            model.setIsAdvancedModeLocalStorageKey("wa_pool_dialog");
            setWindow(model);
            VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
            switchModeCommand.init(model);
            model.getCommands().add(switchModeCommand);
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("OnSave", poolListModel);
            model.getCommands().add(command);
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", poolListModel));
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.setHelpTag(HelpTag.edit_pool);
            // $NON-NLS-1$
            model.setHashName("edit_pool");
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#method_after
public void edit() {
    final VmPool pool = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final PoolListModel poolListModel = this;
    Frontend.getInstance().runQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(pool.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object modell, Object result) {
            final VM vm = ((VdcQueryReturnValue) result).getReturnValue();
            final ExistingPoolModelBehavior behavior = new ExistingPoolModelBehavior(vm);
            behavior.getPoolModelBehaviorInitializedEvent().addListener(new IEventListener<EventArgs>() {

                @Override
                public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                    final PoolModel model = behavior.getModel();
                    for (EntityModel<VmPoolType> item : model.getPoolType().getItems()) {
                        if (item.getEntity() == pool.getVmPoolType()) {
                            model.getPoolType().setSelectedItem(item);
                            break;
                        }
                    }
                    String cdImage = null;
                    if (vm != null) {
                        model.getDataCenterWithClustersList().setSelectedItem(null);
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems(), new Linq.DataCenterWithClusterPredicate(vm.getStoragePoolId(), vm.getVdsGroupId())));
                        model.getTemplateWithVersion().setIsChangeable(false);
                        cdImage = vm.getIsoPath();
                        model.getVmType().setSelectedItem(vm.getVmType());
                    } else {
                        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(model.getDataCenterWithClustersList().getItems()));
                    }
                    model.getDataCenterWithClustersList().setIsChangeable(vm == null);
                    boolean hasCd = !StringHelper.isNullOrEmpty(cdImage);
                    model.getCdImage().setIsChangeable(hasCd);
                    model.getCdAttached().setEntity(hasCd);
                    if (hasCd) {
                        model.getCdImage().setSelectedItem(cdImage);
                    }
                    model.getProvisioning().setIsChangeable(false);
                    model.getStorageDomain().setIsChangeable(false);
                }
            });
            PoolModel model = new PoolModel(behavior);
            model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
            model.startProgress("");
            // $NON-NLS-1$
            model.setIsAdvancedModeLocalStorageKey("wa_pool_dialog");
            setWindow(model);
            VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
            switchModeCommand.init(model);
            model.getCommands().add(switchModeCommand);
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("OnSave", poolListModel);
            model.getCommands().add(command);
            // $NON-NLS-1$
            model.getCommands().add(UICommand.createCancelUiCommand("Cancel", poolListModel));
            model.setTitle(ConstantsManager.getInstance().getConstants().editPoolTitle());
            model.setHelpTag(HelpTag.edit_pool);
            // $NON-NLS-1$
            model.setHashName("edit_pool");
            model.initialize(getSystemTreeSelectedItem());
            model.getName().setEntity(pool.getName());
            model.getDescription().setEntity(pool.getVmPoolDescription());
            model.getComment().setEntity(pool.getComment());
            model.getAssignedVms().setEntity(pool.getAssignedVmsCount());
            model.getPrestartedVms().setEntity(pool.getPrestartedVms());
            // $NON-NLS-1$
            model.setPrestartedVmsHint("0-" + pool.getAssignedVmsCount());
            model.getMaxAssignedVmsPerUser().setEntity(pool.getMaxAssignedVmsPerUser());
        }
    }));
}
#end_block

#method_before
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    VmPool pool = getCurrentPool();
    // Save changes.
    pool.setName(model.getName().getEntity());
    pool.setVmPoolDescription(model.getDescription().getEntity());
    pool.setVdsGroupId(model.getSelectedCluster().getId());
    pool.setComment(model.getComment().getEntity());
    pool.setPrestartedVms(model.getPrestartedVms().getEntity());
    pool.setMaxAssignedVmsPerUser(model.getMaxAssignedVmsPerUser().getEntity());
    EntityModel<VmPoolType> poolTypeSelectedItem = model.getPoolType().getSelectedItem();
    pool.setVmPoolType(poolTypeSelectedItem.getEntity());
    if (model.getSpiceProxyEnabled().getEntity()) {
        pool.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    VM vm = buildVmOnSave(model);
    vm.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    vm.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    vm.setStateless(false);
    vm.setInstanceTypeId(model.getInstanceTypes().getSelectedItem().getId());
    AddVmPoolWithVmsParameters param = new AddVmPoolWithVmsParameters(pool, vm, model.getNumOfDesktops().getEntity(), 0);
    param.setStorageDomainId(Guid.Empty);
    param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    param.setBalloonEnabled(model.getMemoryBalloonDeviceEnabled().getEntity());
    BuilderExecutor.build(model, param, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getQuota().getSelectedItem() != null) {
        vm.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    model.startProgress(null);
    if (model.getIsNew()) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AddVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    } else {
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVmPoolWithVms, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { param })), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                cancel();
                stopProgress();
            }
        }, this);
    }
}
#method_after
public void onSave() {
    final PoolModel model = (PoolModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsNew() && getSelectedItem() == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setCurrentPool(model.getIsNew() ? new VmPool() : (VmPool) Cloner.clone(getSelectedItem()));
    final String name = model.getName().getEntity();
    // Check name unicitate.
    AsyncDataProvider.getInstance().isPoolNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isUnique = (Boolean) returnValue;
            if ((model.getIsNew() && !isUnique) || (!model.getIsNew() && !isUnique && name.compareToIgnoreCase(getCurrentPool().getName()) != 0)) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setValidTab(TabName.GENERAL_TAB, false);
                return;
            }
            String selectedCpu = model.getCustomCpu().getSelectedItem();
            if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                ConfirmationModel confirmModel = new ConfirmationModel();
                confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                // $NON-NLS-1$
                confirmModel.setHashName("edit_unsupported_cpu");
                confirmModel.getCommands().add(// $NON-NLS-1$
                new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                confirmModel.getCommands().add(// $NON-NLS-1$
                UICommand.createCancelUiCommand(// $NON-NLS-1$
                "CancelConfirmation", PoolListModel.this));
                setConfirmWindow(confirmModel);
            } else {
                savePoolPostValidation();
            }
        }
    }), name);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    }
    if (command == getEditCommand()) {
        edit();
    }
    if (command == getRemoveCommand()) {
        remove();
    }
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    }
    if (// $NON-NLS-1$
    "OnSave_Phase2".equals(command.getName())) {
        onSave();
        setConfirmWindow(null);
    }
    if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    }
    if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    }
    if (command == getEditCommand()) {
        edit();
    }
    if (command == getRemoveCommand()) {
        remove();
    }
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    }
    if (// $NON-NLS-1$
    "OnSave_Phase2".equals(command.getName())) {
        savePoolPostValidation();
        setConfirmWindow(null);
    }
    if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    }
    if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#end_block

#method_before
protected String getNullReplacementString() {
    return nullReplacementText;
}
#method_after
private String getNullReplacementString() {
    return nullReplacementText;
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VmTemplate, TemplateListModel> getTemplateListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<TemplateEditPresenterWidget> popupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<TemplateListModel> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VmTemplate, TemplateListModel> result = new MainTabModelProvider<VmTemplate, TemplateListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(TemplateListModel source, UICommand lastExecutedCommand, Model windowModel) {
            TemplateListModel model = getModel();
            if (lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(TemplateListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VmTemplate, TemplateListModel> getTemplateListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<TemplateEditPresenterWidget> popupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmPopupPresenterWidget> createVmPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<TemplateListModel> modelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VmTemplate, TemplateListModel> result = new MainTabModelProvider<VmTemplate, TemplateListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(TemplateListModel source, UICommand lastExecutedCommand, Model windowModel) {
            TemplateListModel model = getModel();
            if (lastExecutedCommand == model.getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateVmFromTemplateCommand()) {
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return createVmPopupProvider.get();
                }
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(TemplateListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(TemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateDiskListModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(TemplateStorageListModel.class).in(Singleton.class);
    bind(TemplateVmListModel.class).in(Singleton.class);
    bind(TemplateEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<TemplateListModel, TemplateGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<TemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, TemplateListModel, TemplateVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, TemplateListModel, TemplateVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, TemplateListModel, PermissionListModel<VmTemplate>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VmTemplate, TemplateListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(TemplateListModel.class).in(Singleton.class);
    bind(TemplateGeneralModel.class).in(Singleton.class);
    bind(TemplateDiskListModel.class).in(Singleton.class);
    bind(TemplateInterfaceListModel.class).in(Singleton.class);
    bind(TemplateStorageListModel.class).in(Singleton.class);
    bind(TemplateVmListModel.class).in(Singleton.class);
    bind(TemplateEventListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VmTemplate>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<TemplateListModel, TemplateGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<TemplateListModel, TemplateGeneralModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, TemplateListModel, TemplateVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, TemplateListModel, TemplateVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, TemplateListModel, PermissionListModel<VmTemplate>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VmTemplate, TemplateListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand onSaveCommand = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(onSaveCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = createModel(createBehavior(template));
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand onSaveCommand = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(onSaveCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
protected TemplateVmModelBehavior createBehavior(VmTemplate template) {
    return new TemplateVmModelBehavior(template);
}
#method_after
protected VmModelBehaviorBase createBehavior(VmTemplate template) {
    if (!template.isBlank()) {
        return new TemplateVmModelBehavior(template);
    }
    return new ExistingBlankTemplateModelBehavior(template);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    final String name = model.getName().getEntity();
    if (((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate().isBaseTemplate()) {
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                boolean isNameUnique = (Boolean) returnValue;
                VmTemplate selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
                if (!isNameUnique && name.compareToIgnoreCase(selectedItem.getName()) != 0) {
                    model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    model.getName().setIsValid(false);
                    model.setValidTab(TabName.GENERAL_TAB, false);
                    return;
                }
            }
        }), name);
    }
    String selectedCpu = model.getCustomCpu().getSelectedItem();
    if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
        confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
        // $NON-NLS-1$
        confirmModel.setHashName("edit_unsupported_cpu");
        confirmModel.getCommands().add(// $NON-NLS-1$
        new UICommand("postNameUniqueCheck", TemplateListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        // $NON-NLS-1$
        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", TemplateListModel.this));
        setConfirmWindow(confirmModel);
    } else {
        postNameUniqueCheck();
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        return;
    }
    final String name = model.getName().getEntity();
    boolean isBaseTemplate = false;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        isBaseTemplate = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate().isBaseTemplate();
    } else if (model.getBehavior().isBlankTemplateBehavior()) {
        isBaseTemplate = true;
    }
    if (isBaseTemplate) {
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                boolean isNameUnique = (Boolean) returnValue;
                if (model.getBehavior().isExistingTemplateBehavior()) {
                    selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
                } else {
                    selectedItem = ((ExistingBlankTemplateModelBehavior) model.getBehavior()).getVmTemplate();
                }
                if (!isNameUnique && name.compareToIgnoreCase(selectedItem.getName()) != 0) {
                    model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    model.getName().setIsValid(false);
                    model.setValidTab(TabName.GENERAL_TAB, false);
                    return;
                }
                String selectedCpu = model.getCustomCpu().getSelectedItem();
                if (selectedCpu != null && !selectedCpu.isEmpty() && !model.getCustomCpu().getItems().contains(selectedCpu)) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuTitle());
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().vmUnsupportedCpuMessage());
                    confirmModel.setHelpTag(HelpTag.edit_unsupported_cpu);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_unsupported_cpu");
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("postNameUniqueCheck", TemplateListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    UICommand.createCancelUiCommand("CancelConfirmation", TemplateListModel.this));
                    setConfirmWindow(confirmModel);
                }
            }
        }), name, model.getSelectedDataCenter() == null ? null : model.getSelectedDataCenter().getId());
    } else {
        postNameUniqueCheck();
    }
}
#end_block

#method_before
public void postNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    // Save changes.
    buildTemplateOnSave(model, template);
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    model.startProgress(null);
    template.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    setVmRngDeviceToParams(model, parameters);
    Frontend.getInstance().runAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem;
    if (model.getBehavior().isExistingTemplateBehavior()) {
        selectedItem = ((TemplateVmModelBehavior) model.getBehavior()).getVmTemplate();
    } else {
        selectedItem = ((ExistingBlankTemplateModelBehavior) model.getBehavior()).getVmTemplate();
    }
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    final String iconForParameters = IconCache.getInstance().getIcon(selectedItem.getLargeIconId()).equals(model.getIcon().getEntity().getIcon()) ? null : IconUtils.filterPredefinedIcons(model.getIcon().getEntity().getIcon());
    // Save changes.
    buildTemplateOnSave(model, template);
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    model.startProgress(null);
    template.setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setVmLargeIcon(iconForParameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    setVmRngDeviceToParams(model, parameters);
    parameters.setBalloonEnabled(balloonEnabled(model));
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
private void cancel() {
    cancelConfirmation();
    setWindow(null);
    updateActionAvailability();
}
#method_after
@Override
protected void cancel() {
    cancelConfirmation();
    setWindow(null);
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void selectedItemsChanged() {
    super.selectedItemsChanged();
    updateActionsAvailability();
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionsAvailability();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if ("postNameUniqueCheck".equals(command.getName())) {
        // $NON-NLS-1$
        postNameUniqueCheck();
        setConfirmWindow(null);
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        doExport();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateVmFromTemplateCommand()) {
        createVMFromTemplate();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnSaveVm".equals(command.getName())) {
        onSaveVm();
    } else if ("postNameUniqueCheck".equals(command.getName())) {
        // $NON-NLS-1$
        postNameUniqueCheck();
        setConfirmWindow(null);
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        doExport();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#end_block

#method_before
@Override
public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UserPortalListModel source, UICommand lastExecutedCommand, Model windowModel) {
    if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
        return makeTemplatePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
        return runOncePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
        return changeCDPopupProvider.get();
    } else if (lastExecutedCommand == getModel().getNewVmCommand()) {
        return newVmPopupProvider.get();
    } else if (lastExecutedCommand == getModel().getEditCommand()) {
        return newVmPopupProvider.get();
    } else if (windowModel instanceof VncInfoModel) {
        return vncInfoPopupProvider.get();
    } else if (windowModel instanceof SpiceToGuestWithNonRespAgentModel) {
        return spiceToGuestWithNonRespAgentPopupProvider.get();
    } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
        return consolePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
        return cloneVmProvider.get();
    } else {
        return super.getModelPopup(source, lastExecutedCommand, windowModel);
    }
}
#method_after
@Override
public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UserPortalListModel source, UICommand lastExecutedCommand, Model windowModel) {
    if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
        return makeTemplatePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
        return runOncePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
        return changeCDPopupProvider.get();
    } else if (lastExecutedCommand == getModel().getNewVmCommand() || lastExecutedCommand == getModel().getEditCommand()) {
        if (windowModel instanceof AttachDiskModel) {
            return attachDiskPopupProvider.get();
        } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
            return newDiskPopupProvider.get();
        } else {
            return newVmPopupProvider.get();
        }
    } else if (lastExecutedCommand == getModel().getSetConsoleKeyCommand()) {
        return publicKeyPopupProvider.get();
    } else if (windowModel instanceof VncInfoModel) {
        return vncInfoPopupProvider.get();
    } else if (windowModel instanceof SpiceToGuestWithNonRespAgentModel) {
        return spiceToGuestWithNonRespAgentPopupProvider.get();
    } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
        return consolePopupProvider.get();
    } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
        return cloneVmProvider.get();
    } else {
        return super.getModelPopup(source, lastExecutedCommand, windowModel);
    }
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<ImportCloneDialogPresenterWidget> importClonePopupProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewVmCommand()) {
                return newVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return newVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ImportCloneModel) {
                return importClonePopupProvider.get();
            } else if (source.getConfirmWindow() instanceof VmNextRunConfigurationModel) {
                return nextRunProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<PublicKeyPopupPresenterWidget> publicKeyPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<ImportVmFromExternalProviderPopupPresenterWidget> importVmFromExternalProviderProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getSetConsoleKeyCommand()) {
                return publicKeyPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else if (windowModel instanceof ImportVmFromExternalProviderModel) {
                return importVmFromExternalProviderProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof VmNextRunConfigurationModel) {
                return nextRunProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return defaultConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> cloneTemplatePopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider, final Provider<VmListModel<Void>> mainModelProvider, final Provider<VmSnapshotListModel> modelProvider) {
    SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel> result = new SearchableDetailTabModelProvider<Snapshot, VmListModel<Void>, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneTemplateCommand()) {
                return cloneTemplatePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmSessionsModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmImportGeneralModel.class).in(Singleton.class);
    bind(VmGuestInfoModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmHostDeviceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGuestInfoModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    ImageFileType imageFileType = ImageFileType.ISO;
    getIrsImageList(aQuery, storagePoolId, forceRefresh, imageFileType);
}
#end_block

#method_before
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#method_after
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false, ImageFileType.Floppy);
}
#end_block

#method_before
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh, ImageFileType imageFileType) {
    getIrsImageList(aQuery, storagePoolId, forceRefresh, imageFileType, new RepoImageToImageFileNameAsyncConverter());
}
#end_block

#method_before
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WanDisableEffects>();
            }
            List<WanDisableEffects> res = new ArrayList<WanDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permission>) source : new ArrayList<Permission>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery aQuery, String templateName, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    NameQueryParameters params = new NameQueryParameters(templateName);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery aQuery, String name, Guid datacenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    NameQueryParameters params = new NameQueryParameters(name);
    params.setDatacenterId(datacenterId);
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, params, aQuery);
}
#end_block

#method_before
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id).withoutRefresh(), aQuery);
}
#end_block

#method_before
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#end_block

#method_before
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#end_block

#method_before
// @Test
// public void testUsersAllRoles() {
// testValidSql("Users: role = * ",
// "SELECT * FROM (SELECT * FROM vdc_users WHERE ( user_id IN (SELECT distinct vdc_users_with_tags.user_id FROM  vdc_users_with_tags   WHERE  vdc_users_with_tags.mla_role LIKE % ))  ORDER BY name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
// }
@Test
public void testGroup() {
    testValidSql("Group:", "SELECT * FROM ((SELECT distinct ad_groups.* FROM  ad_groups  )  ORDER BY name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Group: name=group1", "SELECT * FROM ((SELECT distinct ad_groups.* FROM  ad_groups   WHERE  ad_groups.name LIKE group1 )  ORDER BY name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#method_after
@Test
public void testGroup() {
    testValidSql("Group:", "SELECT * FROM ((SELECT distinct ad_groups.* FROM  ad_groups  )  ORDER BY name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
    testValidSql("Group: name=group1", "SELECT * FROM ((SELECT distinct ad_groups.* FROM  ad_groups   WHERE  ad_groups.name LIKE group1 )  ORDER BY name ASC ) as T1 OFFSET (1 -1) LIMIT 0");
}
#end_block

#method_before
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
    } catch (OpenStackResponseException e) {
        StringBuilder builder = new StringBuilder();
        builder.append(e.getMessage()).append("(").append(e.getStatus()).append(")");
        log.error(builder.toString(), e);
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, ApiRootResponse.class));
    } catch (OpenStackResponseException e) {
        log.error("{} (OpenStack response error code: {})", e.getMessage(), e.getStatus());
        log.debug("Exception", e);
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, null));
    } catch (OpenStackResponseException e) {
        StringBuilder builder = new StringBuilder();
        builder.append(e.getMessage()).append("(").append(e.getStatus()).append(")");
        log.error(builder.toString(), e);
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public void testConnection() {
    try {
        getClient().execute(new OpenStackRequest<>(getClient(), HttpMethod.GET, "", null, null));
    } catch (OpenStackResponseException e) {
        log.error("{} (OpenStack response error code: {})", e.getMessage(), e.getStatus());
        log.debug("Exception", e);
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
public ValidationResult vmNetworkSetCorrectly() {
    return ValidationResult.failWith(VdcBllMessages.NON_VM_NETWORK_NOT_SUPPORTED_FOR_POOL_LEVEL).unless(network.isVmNetwork() || FeatureSupported.nonVmNetwork(getDataCenter().getCompatibilityVersion()));
}
#method_after
public ValidationResult vmNetworkSetCorrectly() {
    return ValidationResult.failWith(VdcBllMessages.NON_VM_NETWORK_NOT_SUPPORTED_FOR_POOL_LEVEL).unless(network.isVmNetwork() || FeatureSupported.nonVmNetwork(getDataCenter().getcompatibility_version()));
}
#end_block

#method_before
public ValidationResult mtuValid() {
    return ValidationResult.failWith(VdcBllMessages.NETWORK_MTU_OVERRIDE_NOT_SUPPORTED).unless(network.getMtu() == 0 || FeatureSupported.mtuSpecification(getDataCenter().getCompatibilityVersion()));
}
#method_after
public ValidationResult mtuValid() {
    return ValidationResult.failWith(VdcBllMessages.NETWORK_MTU_OVERRIDE_NOT_SUPPORTED).unless(network.getMtu() == 0 || FeatureSupported.mtuSpecification(getDataCenter().getcompatibility_version()));
}
#end_block

#method_before
public ValidationResult notRemovingManagementNetwork() {
    return isManagementNetwork() ? new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, getNetworkNameReplacement()) : ValidationResult.VALID;
}
#method_after
public ValidationResult notRemovingManagementNetwork() {
    return NetworkUtils.isManagementNetwork(network) ? new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, getNetworkNameReplacement()) : ValidationResult.VALID;
}
#end_block

#method_before
protected String getNetworkNameReplacement() {
    return String.format("$NetworkName %s", network.getName());
}
#method_after
private String getNetworkNameReplacement() {
    return String.format("$NetworkName %s", network.getName());
}
#end_block

#method_before
protected ValidationResult networkNotUsed(List<? extends Nameable> entities, VdcBllMessages entitiesReplacementPlural, VdcBllMessages entitiesReplacementSingular) {
    if (entities.isEmpty()) {
        return ValidationResult.VALID;
    }
    Collection<String> replacements = ReplacementUtils.replaceWithNameable("ENTITIES_USING_NETWORK", entities);
    VdcBllMessages replacementMessageToUse = entities.size() == 1 ? entitiesReplacementSingular : entitiesReplacementPlural;
    replacements.add(replacementMessageToUse.name());
    return new ValidationResult(new PluralVdcBllMessages().getNetworkInUse(entities.size()), replacements);
}
#method_after
protected ValidationResult networkNotUsed(List<? extends Nameable> entities, VdcBllMessages entitiesReplacement) {
    if (entities.isEmpty()) {
        return ValidationResult.VALID;
    }
    Collection<String> replacements = ReplacementUtils.replaceWithNameable("ENTITIES_USING_NETWORK", entities);
    replacements.add(entitiesReplacement.name());
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_IN_USE, replacements);
}
#end_block

#method_before
public ValidationResult networkNotUsedByVms() {
    return networkNotUsed(getVms(), VdcBllMessages.VAR__ENTITIES__VMS, VdcBllMessages.VAR__ENTITIES__VM);
}
#method_after
public ValidationResult networkNotUsedByVms() {
    return networkNotUsed(getVms(), VdcBllMessages.VAR__ENTITIES__VMS);
}
#end_block

#method_before
public ValidationResult networkNotUsedByHosts() {
    return networkNotUsed(getDbFacade().getVdsDao().getAllForNetwork(network.getId()), VdcBllMessages.VAR__ENTITIES__HOSTS, VdcBllMessages.VAR__ENTITIES__HOST);
}
#method_after
public ValidationResult networkNotUsedByHosts() {
    return networkNotUsed(getDbFacade().getVdsDao().getAllForNetwork(network.getId()), VdcBllMessages.VAR__ENTITIES__HOSTS);
}
#end_block

#method_before
public ValidationResult networkNotUsedByTemplates() {
    return networkNotUsed(getTemplates(), VdcBllMessages.VAR__ENTITIES__VM_TEMPLATES, VdcBllMessages.VAR__ENTITIES__VM_TEMPLATE);
}
#method_after
public ValidationResult networkNotUsedByTemplates() {
    return networkNotUsed(getTemplates(), VdcBllMessages.VAR__ENTITIES__VM_TEMPLATES);
}
#end_block

#method_before
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && (!ipConfiguration.hasPrimaryAddressSet() || StringUtils.isEmpty(ipConfiguration.getPrimaryAddress().getAddress()) || StringUtils.isEmpty(ipConfiguration.getPrimaryAddress().getNetmask()));
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#method_after
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && (ipConfiguration.getAddress() == null || ipConfiguration.getNetmask() == null);
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#end_block

#method_before
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(Map<String, VdsNetworkInterface> nics) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = nics.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getPrimaryAddress().getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(Map<String, VdsNetworkInterface> nics) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = nics.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()) && !managementNetworkUtil.isManagementNetwork(getNetwork().getId()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#method_after
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && StringUtils.isNotEmpty(ipConfiguration.getGateway()) && !NetworkUtils.isManagementNetwork(getNetwork()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    networkDaoMock = mock(NetworkDao.class);
    networkClusterDaoMock = mock(NetworkClusterDao.class);
    vdsDaoMock = mock(VdsDAO.class);
    managementNetworkUtil = mock(ManagementNetworkUtil.class);
    when(DbFacade.getInstance().getNetworkDao()).thenReturn(networkDaoMock);
    when(DbFacade.getInstance().getNetworkClusterDao()).thenReturn(networkClusterDaoMock);
    when(DbFacade.getInstance().getVdsDao()).thenReturn(vdsDaoMock);
}
#method_after
@Before
public void setUp() throws Exception {
    dbFacadeMock = mock(DbFacade.class);
    DbFacadeLocator.setDbFacade(dbFacadeMock);
    networkDaoMock = mock(NetworkDao.class);
    networkClusterDaoMock = mock(NetworkClusterDao.class);
    vdsDaoMock = mock(VdsDAO.class);
    when(dbFacadeMock.getNetworkDao()).thenReturn(networkDaoMock);
    when(dbFacadeMock.getNetworkClusterDao()).thenReturn(networkClusterDaoMock);
    when(dbFacadeMock.getVdsDao()).thenReturn(vdsDaoMock);
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, new VDS(), managementNetworkUtil).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, new VDS()).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).networkAttachmentIsSet(), isValid());
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).networkAttachmentIsSet(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).networkIsSet();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS, "a"));
}
#method_after
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).networkIsSet();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS, "a"));
}
#end_block

#method_before
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(any(Guid.class))).thenReturn(externalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#method_after
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(any(Guid.class))).thenReturn(externalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#end_block

#method_before
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(notExternalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).notExternalNetwork(), isValid());
}
#method_after
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(notExternalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).notRemovingManagementNetwork();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#method_after
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).notRemovingManagementNetwork();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).networkAttachedToCluster(), isValid());
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    when(networkClusterDaoMock.get(any(NetworkClusterId.class))).thenReturn(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    when(networkClusterDaoMock.get(any(NetworkClusterId.class))).thenReturn(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil);
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, new VDS());
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsNotStatic() throws Exception {
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.DHCP, null, null), new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null), new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsNotStatic() throws Exception {
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.DHCP, null, null), new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null), new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "192.168.1.1", "255.255.255.0");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol staticIp, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    IPv4Address primaryAddress = new IPv4Address();
    primaryAddress.setAddress(address);
    primaryAddress.setNetmask(netmask);
    ipConfiguration.getIPv4Addresses().add(primaryAddress);
    ipConfiguration.setBootProtocol(staticIp);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#method_after
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol staticIp, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setAddress(address);
    ipConfiguration.setNetmask(netmask);
    ipConfiguration.setBootProtocol(staticIp);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationWhenNetworkClusterDisplayIsFalse() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(false);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), isValid());
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationWhenNetworkClusterDisplayIsFalse() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(false);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).nicExists(), isValid());
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNotStatic() throws Exception {
    for (NetworkBootProtocol networkBootProtocol : NetworkBootProtocol.values()) {
        if (networkBootProtocol == NetworkBootProtocol.STATIC_IP) {
            continue;
        }
        NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(networkBootProtocol, null, null);
        assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
    }
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNotStatic() throws Exception {
    for (NetworkBootProtocol networkBootProtocol : NetworkBootProtocol.values()) {
        if (networkBootProtocol == NetworkBootProtocol.STATIC_IP) {
            continue;
        }
        NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(networkBootProtocol, null, null);
        assertThat(new NetworkAttachmentValidator(attachment, null).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
    }
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, null, managementNetworkUtil);
    Map<String, VdsNetworkInterface> nics = Collections.emptyMap();
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, null);
    Map<String, VdsNetworkInterface> nics = Collections.emptyMap();
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    VDS host = new VDS();
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host, managementNetworkUtil);
    Map<String, VdsNetworkInterface> nics = Collections.singletonMap(existingInterface.getName(), existingInterface);
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    VDS host = new VDS();
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host);
    Map<String, VdsNetworkInterface> nics = Collections.singletonMap(existingInterface.getName(), existingInterface);
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, null, managementNetworkUtil).networkNotChanged(null), isValid());
}
#method_after
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, null).networkNotChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#method_after
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#end_block

#method_before
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkNotChanged(oldAttachment), isValid());
}
#method_after
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), isValid());
}
#end_block

#method_before
@Test
public void testValidateGateway() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.getIpConfiguration().getPrimaryAddress().setGateway("someGateway");
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("networkName");
    IConfigUtilsInterface iConfigUtilsInterfaceMock = mock(IConfigUtilsInterface.class);
    Config.setConfigUtils(iConfigUtilsInterfaceMock);
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.MultipleGatewaysSupported), anyString())).thenReturn(false);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    when(managementNetworkUtil.isManagementNetwork(network.getId())).thenReturn(false);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.getLast());
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).validateGateway(), failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#method_after
@Test
public void testValidateGateway() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.getIpConfiguration().setGateway("someGateway");
    Network network = new Network();
    network.setName("networkName");
    IConfigUtilsInterface iConfigUtilsInterfaceMock = mock(IConfigUtilsInterface.class);
    Config.setConfigUtils(iConfigUtilsInterfaceMock);
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.ManagementNetwork), anyString())).thenReturn("managementNetworkName");
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.MultipleGatewaysSupported), anyString())).thenReturn(false);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.getLast());
    assertThat(new NetworkAttachmentValidator(attachment, host).validateGateway(), failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.<VDS>emptyList());
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), null, managementNetworkUtil).networkNotAttachedToHost(), isValid());
}
#method_after
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.<VDS>emptyList());
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), null).networkNotAttachedToHost(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.singletonList(host));
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), host, managementNetworkUtil).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#method_after
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.singletonList(host));
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), host).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            removeFromClusters();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDAO().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork(), getStoragePool().getCompatibilityVersion())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    setStoragePoolId(getNetwork().getDataCenterId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVnicProfiles();
            removeFromClusters();
            getCompensationContext().snapshotEntity(getNetwork());
            getNetworkDAO().remove(getNetwork().getId());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getNetwork().isExternal()) {
        if (getParameters().isRemoveFromNetworkProvider()) {
            removeExternalNetwork();
        }
    }
    if (NetworkHelper.shouldRemoveNetworkFromHostUponNetworkRemoval(getNetwork(), getStoragePool().getcompatibility_version())) {
        removeNetworkFromHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
public FailingValidationResults<String> validate() {
    if (validNewOrModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validNewOrModifiedBonds() && validRemovedBonds() && validateNotRemovingUsedNetworkByVms()) {
        Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
        boolean valid = networksUniquelyConfiguredOnHost(attachmentsToConfigure) && !violations.addViolations(new HostValidator(host, internalExecution).validate()) && violations.addViolation(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && validateMtu(attachmentsToConfigure) && validateCustomProperties();
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return violations;
}
#method_after
public List<String> validate() {
    if (validModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validModifiedBonds() && validRemovedBonds() && validateNotRemovingUsedNetworkByVms()) {
        Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
        if (networksUniquelyConfiguredOnHost(attachmentsToConfigure) && validate(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && validateMtu(attachmentsToConfigure) && validateCustomProperties()) {
            return Collections.emptyList();
        }
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return translateViolations();
}
#end_block

#method_before
private boolean networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Set<Guid> networkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (networkIds.contains(attachment.getNetworkId())) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            violations.addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName());
            passed = false;
        } else {
            networkIds.add(attachment.getNetworkId());
        }
    }
    return passed;
}
#method_after
private boolean networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Set<Guid> networkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (networkIds.contains(attachment.getNetworkId())) {
            Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
            addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName());
            passed = false;
        } else {
            networkIds.add(attachment.getNetworkId());
        }
    }
    return passed;
}
#end_block

#method_before
private boolean validateNotRemovingUsedNetworkByVms() {
    boolean passed = true;
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : this.removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    for (String vmName : vmNames) {
        violations.addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
        passed = false;
    }
    return passed;
}
#method_after
private boolean validateNotRemovingUsedNetworkByVms() {
    boolean passed = true;
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : params.getRemovedNetworkAttachments()) {
        removedNetworks.add(networkBusinessEntityMap.get(removedAttachment.getNetworkId()).getName());
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    for (String vmName : vmNames) {
        addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
        passed = false;
    }
    return passed;
}
#end_block

#method_before
private boolean validRemovedBonds() {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingIfacesById);
    if (!invalidBondIds.isEmpty()) {
        for (Guid problematicId : invalidBondIds) {
            violations.addViolation(VdcBllMessages.NETWORK_BOND_NOT_EXISTS, problematicId.toString());
        }
        return false;
    }
    Set<String> requiredNicsNames = getRemovedBondsUsedByNetworks();
    boolean passed = true;
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingIfaces.get(bondName);
        if (violations.addViolation(new HostInterfaceValidator(existingBond).interfaceIsBondOrNull(), bondName)) {
            passed = false;
            continue;
        }
        if (requiredNicsNames.contains(bondName)) {
            violations.addViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
            passed = false;
            continue;
        }
    }
    return passed;
}
#method_after
private boolean validRemovedBonds() {
    Set<String> requiredNicsNames = getRemovedBondsUsedByNetworks();
    boolean passed = true;
    for (Bond removedBond : params.getRemovedBonds()) {
        String bondName = removedBond.getName();
        if (bondName == null) {
            addViolation(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST, null);
            passed = false;
            continue;
        }
        VdsNetworkInterface existingBond = existingIfaces.get(bondName);
        if (!validateAndAddViolation(new HostInterfaceValidator(existingBond).interfaceIsBond(), bondName)) {
            passed = false;
            continue;
        }
        if (requiredNicsNames.contains(bondName)) {
            addViolation(VdcBllMessages.BOND_USED_BY_NETWORK_ATTACHMENTS, bondName);
            passed = false;
            continue;
        }
    }
    return passed;
}
#end_block

#method_before
private Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> attachmentsToConfigure = new HashMap<>(Entities.businessEntitiesById(existingAttachments));
    // ignore removed attachments
    for (NetworkAttachment removedAttachment : this.removedNetworkAttachments) {
        attachmentsToConfigure.remove(removedAttachment.getId());
    }
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    // add attachments which planned to be configured on removed bonds and ignore those which aren't
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        // new attachment to add
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
            continue;
        }
        if (removedBondVdsNetworkInterfaceMap.containsKey(attachment.getNicName())) {
            attachmentsToConfigure.put(attachment.getId(), attachment);
        } else {
            attachmentsToConfigure.remove(attachment.getId());
        }
    }
    Collection<NetworkAttachment> candidateAttachments = new ArrayList<>(attachmentsToConfigure.values());
    candidateAttachments.addAll(newAttachments);
    return candidateAttachments;
}
#method_after
private Collection<NetworkAttachment> getAttachmentsToConfigure() {
    Map<Guid, NetworkAttachment> attachmentsToConfigure = new HashMap<>(Entities.businessEntitiesById(existingAttachments));
    // ignore removed attachments
    for (NetworkAttachment removedAttachment : params.getRemovedNetworkAttachments()) {
        attachmentsToConfigure.remove(removedAttachment.getId());
    }
    List<NetworkAttachment> newAttachments = new ArrayList<>();
    // add attachments which planned to be configured on removed bonds and ignore those which aren't
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        // new attachment to add
        if (attachment.getId() == null) {
            newAttachments.add(attachment);
            continue;
        }
        if (removedBonds.containsKey(attachment.getNicName())) {
            attachmentsToConfigure.put(attachment.getId(), attachment);
        } else {
            attachmentsToConfigure.remove(attachment.getId());
        }
    }
    Collection<NetworkAttachment> candidateAttachments = new ArrayList<>(attachmentsToConfigure.values());
    candidateAttachments.addAll(newAttachments);
    return candidateAttachments;
}
#end_block

#method_before
private boolean validRemovedNetworkAttachments() {
    List<Guid> invalidIds = Entities.idsNotReferencingExistingRecords(params.getRemovedNetworkAttachments(), existingIfacesById);
    if (!invalidIds.isEmpty()) {
        for (Guid problematicId : invalidIds) {
            violations.addViolation(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS, problematicId.toString());
        }
        return false;
    }
    boolean passed = true;
    for (NetworkAttachment attachment : removedNetworkAttachments) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host, managementNetworkUtil);
        if (!(violations.addViolation(validator.networkAttachmentIsSet(), attachment.getId().toString()) && violations.addViolation(validator.notExternalNetwork()) && violations.addViolation(validator.notRemovingManagementNetwork()) && notRemovingLabeledNetworks(attachment, getExistingIfaces()))) {
            passed = false;
        }
    }
    return passed;
}
#method_after
private boolean validRemovedNetworkAttachments() {
    boolean passed = true;
    for (NetworkAttachment attachment : params.getRemovedNetworkAttachments()) {
        NetworkAttachment attachmentToValidate = attachmentsById.get(attachment.getId());
        NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachmentToValidate, host);
        if (!(validate(validator.networkAttachmentIsSet()) && validate(validator.notExternalNetwork()) && validate(validator.notRemovingManagementNetwork()) && notRemovingLabeledNetworks(attachment, getExistingIfaces()))) {
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
private boolean notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return true;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    if (nic != null && !removedBondVdsNetworkInterfaceMap.containsKey(nic.getName())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
            return false;
        }
    }
    return true;
}
#method_after
private boolean notRemovingLabeledNetworks(NetworkAttachment attachment, Map<String, VdsNetworkInterface> existingNics) {
    Network removedNetwork = networkBusinessEntityMap.get(attachment.getNetworkId());
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return true;
    }
    VdsNetworkInterface nic = existingNics.get(attachment.getNicName());
    if (nic != null && !removedBonds.containsKey(nic.getName())) {
        if (NetworkUtils.isLabeled(nic) && nic.getLabels().contains(removedNetwork.getLabel())) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, removedNetwork.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean validateMtu(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Map<String, List<Network>> nicsToNetworks = getNicNameToNetworksMap(attachmentsToConfigure);
    for (Entry<String, List<Network>> nicToNetworks : nicsToNetworks.entrySet()) {
        List<Network> networksOnNic = nicToNetworks.getValue();
        if (!networksOnNicMatchMtu(networksOnNic)) {
            reportMtuDifferences(networksOnNic);
            passed = false;
        }
    }
    return passed;
}
#method_after
private boolean validateMtu(Collection<NetworkAttachment> attachmentsToConfigure) {
    boolean passed = true;
    Map<String, List<Network>> nicsToNetworks = getNetworksOnNics(attachmentsToConfigure);
    for (Entry<String, List<Network>> nicToNetwork : nicsToNetworks.entrySet()) {
        List<Network> networksOnNic = nicToNetwork.getValue();
        if (!networksOnNicMatchMtu(networksOnNic)) {
            reportMtuDifferences(networksOnNic);
            passed = false;
        }
    }
    return passed;
}
#end_block

#method_before
private void reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    violations.addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#method_after
private void reportMtuDifferences(List<Network> ifaceNetworks) {
    List<String> mtuDiffNetworks = new ArrayList<>();
    for (Network net : ifaceNetworks) {
        mtuDiffNetworks.add(String.format("%s(%s)", net.getName(), net.getMtu() == 0 ? "default" : String.valueOf(net.getMtu())));
    }
    addViolation(VdcBllMessages.NETWORK_MTU_DIFFERENCES, String.format("[%s]", StringUtils.join(mtuDiffNetworks, ", ")));
}
#end_block

#method_before
private boolean validateCustomProperties() {
    boolean passed = true;
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = existingNetworkRelatedToAttachment(attachment);
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
                passed = false;
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validProperties : validPropertiesNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                violations.addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
                passed = false;
            }
        }
    }
    return passed;
}
#method_after
private boolean validateCustomProperties() {
    boolean passed = true;
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (NetworkAttachment attachment : params.getNetworkAttachments()) {
        Network network = networkBusinessEntityMap.get(attachment.getNetworkId());
        if (attachment.hasProperties()) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
                passed = false;
            }
            List<ValidationError> errors = util.validateProperties(network.isVmNetwork() ? validProperties : validPropertiesNonVm, attachment.getProperties());
            if (!errors.isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, network.getName());
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
                passed = false;
            }
        }
    }
    return passed;
}
#end_block

#method_before
public FailingValidationResults<String> validate() {
    if (validNewOrModifiedNetworkAttachments() && validRemovedNetworkAttachments() && validNewOrModifiedBonds() && validRemovedBonds() && validateNotRemovingUsedNetworkByVms()) {
        Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
        boolean valid = networksUniquelyConfiguredOnHost(attachmentsToConfigure) && !violations.addViolations(new HostValidator(host, internalExecution).validate()) && violations.addViolation(validateNetworkExclusiveOnNics(attachmentsToConfigure)) && validateMtu(attachmentsToConfigure) && validateCustomProperties();
    // TODO: Cover qos change not supported and network sync. see SetupNetworkHelper.validateNetworkQos()
    // Violation - VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED
    // Violation - VdcBllMessages.NETWORKS_NOT_IN_SYNC
    }
    return violations;
}
#method_after
private boolean validate(ValidationResult validationResult, String violatingEntity) {
    if (!validationResult.isValid()) {
        addViolation(validationResult.getMessage(), violatingEntity);
    }
    return validationResult.isValid();
}
#end_block

#method_before
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && (!ipConfiguration.hasPrimaryAddressSet() || StringUtils.isEmpty(ipConfiguration.getPrimaryAddress().getAddress()) || StringUtils.isEmpty(ipConfiguration.getPrimaryAddress().getNetmask()));
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#method_after
public ValidationResult ipConfiguredForStaticBootProtocol() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    boolean failWhen = ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP && (ipConfiguration.getAddress() == null || ipConfiguration.getNetmask() == null);
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP).when(failWhen);
}
#end_block

#method_before
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(Map<String, VdsNetworkInterface> nics) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = nics.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getPrimaryAddress().getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult networkIpAddressWasSameAsHostnameAndChanged(Map<String, VdsNetworkInterface> nics) {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    if (ipConfiguration != null && ipConfiguration.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
        VdsNetworkInterface existingIface = nics.get(attachment.getNicName());
        if (existingIface != null) {
            String oldAddress = existingIface.getAddress();
            return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED).when(StringUtils.equals(oldAddress, host.getHostName()) && !StringUtils.equals(oldAddress, ipConfiguration.getAddress()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()) && !managementNetworkUtil.isManagementNetwork(getNetwork().getId()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#method_after
public ValidationResult validateGateway() {
    IpConfiguration ipConfiguration = attachment.getIpConfiguration();
    return ValidationResult.failWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY).when(ipConfiguration != null && StringUtils.isNotEmpty(ipConfiguration.getGateway()) && !NetworkUtils.isManagementNetwork(getNetwork()) && !FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    networkDaoMock = mock(NetworkDao.class);
    networkClusterDaoMock = mock(NetworkClusterDao.class);
    vdsDaoMock = mock(VdsDAO.class);
    managementNetworkUtil = mock(ManagementNetworkUtil.class);
    when(DbFacade.getInstance().getNetworkDao()).thenReturn(networkDaoMock);
    when(DbFacade.getInstance().getNetworkClusterDao()).thenReturn(networkClusterDaoMock);
    when(DbFacade.getInstance().getVdsDao()).thenReturn(vdsDaoMock);
}
#method_after
@Before
public void setUp() throws Exception {
    dbFacadeMock = mock(DbFacade.class);
    DbFacadeLocator.setDbFacade(dbFacadeMock);
    networkDaoMock = mock(NetworkDao.class);
    networkClusterDaoMock = mock(NetworkClusterDao.class);
    vdsDaoMock = mock(VdsDAO.class);
    when(dbFacadeMock.getNetworkDao()).thenReturn(networkDaoMock);
    when(dbFacadeMock.getNetworkClusterDao()).thenReturn(networkClusterDaoMock);
    when(dbFacadeMock.getVdsDao()).thenReturn(vdsDaoMock);
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, new VDS(), managementNetworkUtil).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, new VDS()).networkAttachmentIsSet(), failsWith(VdcBllMessages.NETWORK_ATTACHMENT_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).networkAttachmentIsSet(), isValid());
}
#method_after
@Test
public void testNetworkAttachmentIsSetWhenAttachmentIsNotNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).networkAttachmentIsSet(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).networkIsSet();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS, "a"));
}
#method_after
@Test
public void testNetworkExists() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).networkIsSet();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.networkExists(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS, "a"));
}
#end_block

#method_before
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(any(Guid.class))).thenReturn(externalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#method_after
@Test
public void testNotExternalNetworkWhenExternalNetworkIsProvided() throws Exception {
    Network externalNetwork = new Network();
    externalNetwork.setProvidedBy(new ProviderNetwork(Guid.newGuid(), ""));
    when(networkDaoMock.get(any(Guid.class))).thenReturn(externalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), failsWith(VdcBllMessages.EXTERNAL_NETWORK_CANNOT_BE_PROVISIONED));
}
#end_block

#method_before
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(notExternalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil).notExternalNetwork(), isValid());
}
#method_after
@Test
public void testNotExternalNetwork() throws Exception {
    Network notExternalNetwork = new Network();
    notExternalNetwork.setProvidedBy(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(notExternalNetwork);
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()).notExternalNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS(), managementNetworkUtil));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).notManagementNetwork();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#method_after
@Test
public void testNotRemovingManagementNetwork() throws Exception {
    NetworkAttachmentValidator networkAttachmentValidatorSpy = Mockito.spy(new NetworkAttachmentValidator(new NetworkAttachment(), new VDS()));
    NetworkValidator networkValidatorSpy = Mockito.spy(new NetworkValidator(new Network()));
    doReturn(networkValidatorSpy).when(networkAttachmentValidatorSpy).createNetworkValidator();
    ValidationResult propagatedResult = new ValidationResult(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a");
    doReturn(propagatedResult).when(networkValidatorSpy).notManagementNetwork();
    assertThat("ValidationResult is not correctly propagated", networkAttachmentValidatorSpy.notRemovingManagementNetwork(), failsWith(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK, "a"));
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).networkAttachedToCluster(), isValid());
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(new NetworkCluster());
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    when(networkClusterDaoMock.get(any(NetworkClusterId.class))).thenReturn(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#method_after
@Test
public void testNetworkAttachedToClusterWhenNotAttached() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(network.getId());
    when(networkClusterDaoMock.get(any(NetworkClusterId.class))).thenReturn(null);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).networkAttachedToCluster(), failsWith(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil);
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, new VDS());
    assertThat(validator.ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsNotStatic() throws Exception {
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.DHCP, null, null), new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null), new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsNotStatic() throws Exception {
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.DHCP, null, null), new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
    assertThat(new NetworkAttachmentValidator(createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null), new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndNetmaskIsNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), failsWith(VdcBllMessages.NETWORK_ADDR_MANDATORY_IN_STATIC_IP));
}
#end_block

#method_before
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "192.168.1.1", "255.255.255.0");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).ipConfiguredForStaticBootProtocol(), isValid());
}
#method_after
@Test
public void testIpConfiguredForStaticBootProtocolWhenIpConfigurationIsNotNullAndBootProtocolIsStaticAndAddressAndNetmaskIsNotNull() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, "", "");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).ipConfiguredForStaticBootProtocol(), isValid());
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol staticIp, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    IPv4Address primaryAddress = new IPv4Address();
    primaryAddress.setAddress(address);
    primaryAddress.setNetmask(netmask);
    ipConfiguration.getIPv4Addresses().add(primaryAddress);
    ipConfiguration.setBootProtocol(staticIp);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#method_after
private NetworkAttachment createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol staticIp, String address, String netmask) {
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setAddress(address);
    ipConfiguration.setNetmask(netmask);
    ipConfiguration.setBootProtocol(staticIp);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(ipConfiguration);
    return attachment;
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationWhenNetworkClusterDisplayIsFalse() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(false);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), isValid());
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationWhenNetworkClusterDisplayIsFalse() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(false);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), isValid());
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenIpConfigurationIsNull() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#method_after
@Test
public void testBootProtocolSetForDisplayNetworkWhenBootProtocolIsNone() throws Exception {
    Network network = new Network();
    network.setId(Guid.newGuid());
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.setNetworkId(network.getId());
    VDS host = new VDS();
    host.setVdsGroupId(Guid.newGuid());
    NetworkCluster networkCluster = new NetworkCluster();
    networkCluster.setDisplay(true);
    NetworkClusterId networkClusterId = new NetworkClusterId(host.getVdsGroupId(), attachment.getNetworkId());
    when(networkClusterDaoMock.get(eq(networkClusterId))).thenReturn(networkCluster);
    when(networkDaoMock.get(Mockito.eq(network.getId()))).thenReturn(network);
    assertThat(new NetworkAttachmentValidator(attachment, host).bootProtocolSetForDisplayNetwork(), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicName(null);
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), failsWith(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS(), managementNetworkUtil).nicExists(), isValid());
}
#method_after
@Test
public void testNicExistsWhenNicNameIsNotNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNicId(null);
    attachment.setNicName("whatever");
    assertThat(new NetworkAttachmentValidator(attachment, new VDS()).nicExists(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNull() throws Exception {
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setIpConfiguration(null);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNotStatic() throws Exception {
    for (NetworkBootProtocol networkBootProtocol : NetworkBootProtocol.values()) {
        if (networkBootProtocol == NetworkBootProtocol.STATIC_IP) {
            continue;
        }
        NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(networkBootProtocol, null, null);
        assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
    }
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIpConfigurationIsNotStatic() throws Exception {
    for (NetworkBootProtocol networkBootProtocol : NetworkBootProtocol.values()) {
        if (networkBootProtocol == NetworkBootProtocol.STATIC_IP) {
            continue;
        }
        NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(networkBootProtocol, null, null);
        assertThat(new NetworkAttachmentValidator(attachment, null).networkIpAddressWasSameAsHostnameAndChanged(null), isValid());
    }
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, null, managementNetworkUtil);
    Map<String, VdsNetworkInterface> nics = Collections.emptyMap();
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChangedWhenIfaceDoesNotExist() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName("nicName");
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, null);
    Map<String, VdsNetworkInterface> nics = Collections.emptyMap();
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), isValid());
}
#end_block

#method_before
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    VDS host = new VDS();
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host, managementNetworkUtil);
    Map<String, VdsNetworkInterface> nics = Collections.singletonMap(existingInterface.getName(), existingInterface);
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#method_after
@Test
public void testNetworkIpAddressWasSameAsHostnameAndChanged() throws Exception {
    VdsNetworkInterface existingInterface = new VdsNetworkInterface();
    existingInterface.setName("nicName");
    existingInterface.setAddress("anyAddress");
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.STATIC_IP, null, null);
    attachment.setNicName(existingInterface.getName());
    VDS host = new VDS();
    host.setHostName(existingInterface.getAddress());
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(attachment, host);
    Map<String, VdsNetworkInterface> nics = Collections.singletonMap(existingInterface.getName(), existingInterface);
    assertThat(validator.networkIpAddressWasSameAsHostnameAndChanged(nics), failsWith(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED));
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, null, managementNetworkUtil).networkNotChanged(null), isValid());
}
#method_after
@Test
public void testNetworkNotChangedWhenOldAttachmentIsNull() throws Exception {
    assertThat(new NetworkAttachmentValidator(null, null).networkNotChanged(null), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#method_after
@Test
public void testNetworkNotChangedWhenDifferentNetworkIds() throws Exception {
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(Guid.newGuid());
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(Guid.newGuid());
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), failsWith(VdcBllMessages.CANNOT_CHANGE_ATTACHED_NETWORK));
}
#end_block

#method_before
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(new NetworkAttachmentValidator(attachment, null, managementNetworkUtil).networkNotChanged(oldAttachment), isValid());
}
#method_after
@Test
public void testNetworkNotChanged() throws Exception {
    Guid networkId = Guid.newGuid();
    NetworkAttachment oldAttachment = new NetworkAttachment();
    oldAttachment.setNetworkId(networkId);
    NetworkAttachment attachment = new NetworkAttachment();
    attachment.setNetworkId(networkId);
    assertThat(new NetworkAttachmentValidator(attachment, null).networkNotChanged(oldAttachment), isValid());
}
#end_block

#method_before
@Test
public void testValidateGateway() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.getIpConfiguration().getPrimaryAddress().setGateway("someGateway");
    Network network = new Network();
    network.setId(Guid.newGuid());
    network.setName("networkName");
    IConfigUtilsInterface iConfigUtilsInterfaceMock = mock(IConfigUtilsInterface.class);
    Config.setConfigUtils(iConfigUtilsInterfaceMock);
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.MultipleGatewaysSupported), anyString())).thenReturn(false);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    when(managementNetworkUtil.isManagementNetwork(network.getId())).thenReturn(false);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.getLast());
    assertThat(new NetworkAttachmentValidator(attachment, host, managementNetworkUtil).validateGateway(), failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#method_after
@Test
public void testValidateGateway() throws Exception {
    NetworkAttachment attachment = createNetworkAttachmentWithIpConfiguration(NetworkBootProtocol.NONE, null, null);
    attachment.getIpConfiguration().setGateway("someGateway");
    Network network = new Network();
    network.setName("networkName");
    IConfigUtilsInterface iConfigUtilsInterfaceMock = mock(IConfigUtilsInterface.class);
    Config.setConfigUtils(iConfigUtilsInterfaceMock);
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.ManagementNetwork), anyString())).thenReturn("managementNetworkName");
    when(iConfigUtilsInterfaceMock.getValue(eq(ConfigValues.MultipleGatewaysSupported), anyString())).thenReturn(false);
    when(networkDaoMock.get(any(Guid.class))).thenReturn(network);
    VDS host = new VDS();
    host.setVdsGroupCompatibilityVersion(Version.getLast());
    assertThat(new NetworkAttachmentValidator(attachment, host).validateGateway(), failsWith(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY));
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.<VDS>emptyList());
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), null, managementNetworkUtil).networkNotAttachedToHost(), isValid());
}
#method_after
@Test
public void testNetworkNotAttachedToHost() throws Exception {
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.<VDS>emptyList());
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), null).networkNotAttachedToHost(), isValid());
}
#end_block

#method_before
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.singletonList(host));
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), host, managementNetworkUtil).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#method_after
@Test
public void testNetworkNotAttachedToHostWhenAttached() throws Exception {
    VDS host = new VDS();
    host.setId(Guid.newGuid());
    // no vds for network id.
    when(vdsDaoMock.getAllForNetwork(any(Guid.class))).thenReturn(Collections.singletonList(host));
    assertThat(new NetworkAttachmentValidator(new NetworkAttachment(), host).networkNotAttachedToHost(), failsWith(VdcBllMessages.NETWORK_ALREADY_ATTACHED_TO_HOST));
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (spm.getStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity, pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = new HostDevicePassthrough();
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    model.setDevicePassthrough(devicePassthrough);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostProtocol protocol = map(entity.getProtocol(), null);
    model.setProtocol(protocol != null ? protocol.value() : null);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (entity.getExternalStatus() != null) {
        EntityExternalStatus entityExternalStatus = ExternalStatusMapper.map(entity.getExternalStatus(), null);
        Status hostStatus = new Status();
        hostStatus.setState(entityExternalStatus.value());
        model.setExternalStatus(hostStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.getStatus().setDetail(entity.getMaintenanceReason());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    SPM spm = new SPM();
    spm.setPriority(entity.getVdsSpmPriority());
    if (spm.getStatus() != null) {
        spm.setStatus(StatusUtils.create(map(entity.getSpmStatus(), null)));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    PowerManagement pm = map(entity, (PowerManagement) null);
    model.setPowerManagement(DeprecatedPowerManagementMapper.map(entity, pm));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSelinux(map(entity, (SELinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    model.setLiveSnapshotSupport(entity.getLiveSnapshotSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    return model;
}
#end_block

#method_before
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(managementNetwork.getId());
    managementAttachment.setNicId(nic.getId());
    IpConfiguration ipConfiguration = new IpConfiguration();
    if (ipConfiguration.hasPrimaryAddressSet()) {
        ipConfiguration.getPrimaryAddress().setAddress(nic.getAddress());
        ipConfiguration.getPrimaryAddress().setNetmask(nic.getSubnet());
        ipConfiguration.getPrimaryAddress().setGateway(nic.getGateway());
    }
    ipConfiguration.setBootProtocol(nic.getBootProtocol());
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#method_after
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(managementNetwork.getId());
    managementAttachment.setNicId(nic.getId());
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.getIPv4Addresses().add(createIPv4Address(nic));
    ipConfiguration.setBootProtocol(nic.getBootProtocol());
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#end_block

#method_before
@Override
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = getVmDisksFromDB();
    if (diskImages.isEmpty()) {
        return;
    }
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
            DiskImage snapshotImageInDb = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (snapshotImageInDb == null) {
                // If the snapshot diskImage is null, it means the disk was probably
                // erased after the snapshot was created.
                // Create a disk to reflect the fact the disk existed during snapshot
                saveIllegalDisk(diskImage);
            }
        } else {
            if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
                CinderDisk cinder = (CinderDisk) diskImage;
                cinderDisks.add(cinder);
                continue;
            }
            addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
        }
    }
    if (!getReturnValue().getVdsmTaskIdList().isEmpty() || !cinderDisks.isEmpty()) {
        lockSnapshot();
    }
    if (!cinderDisks.isEmpty()) {
        addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping);
    }
}
#method_after
@Override
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = getVmDisksFromDB();
    if (diskImages.isEmpty()) {
        return;
    }
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getImageStatus() == ImageStatus.ILLEGAL) {
            DiskImage snapshotImageInDb = getDiskImageDao().getSnapshotById(diskImage.getImageId());
            if (snapshotImageInDb == null) {
                // If the snapshot diskImage is null, it means the disk was probably
                // erased after the snapshot was created.
                // Create a disk to reflect the fact the disk existed during snapshot
                saveIllegalDisk(diskImage);
            }
        } else {
            if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisks.add((CinderDisk) diskImage);
                continue;
            }
            addVmTemplateImage(srcDeviceIdToTargetDeviceIdMapping, diskImage);
        }
    }
    if (!getReturnValue().getVdsmTaskIdList().isEmpty() || !cinderDisks.isEmpty()) {
        lockSnapshot();
    }
    if (!cinderDisks.isEmpty()) {
        addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImage();
    CinderDisk cinderDisk = getDisk();
    cinderDisk.setDiskAlias(getParameters().getDiskAlias());
    String volumeId = getNewVolumeCinderDisk(cinderDisk);
    cinderDisk.setId(Guid.createGuidFromString(volumeId));
    cinderDisk.setImageId(Guid.createGuidFromString(volumeId));
    cinderDisk.setImageStatus(ImageStatus.LOCKED);
    cinderDisk.setVolumeType(VolumeType.Sparse);
    addCinderDiskTemplateToDB(cinderDisk);
    getReturnValue().setActionReturnValue(cinderDisk.getId());
    getParameters().setDestinationImageId(Guid.createGuidFromString(volumeId));
    getParameters().setContainerId(Guid.createGuidFromString(volumeId));
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    lockImage();
    CinderDisk cinderDisk = getDisk();
    cinderDisk.setDiskAlias(getParameters().getDiskAlias());
    String volumeId = getNewVolumeCinderDisk(cinderDisk);
    cinderDisk.setId(Guid.createGuidFromString(volumeId));
    cinderDisk.setImageId(Guid.createGuidFromString(volumeId));
    cinderDisk.setImageStatus(ImageStatus.LOCKED);
    cinderDisk.setVolumeType(VolumeType.Sparse);
    cinderDisk.setVmSnapshotId(getParameters().getVmSnapshotId());
    // If we clone a disk from snapshot, update the volume with the appropriate parameters.
    if (!cinderDisk.getActive()) {
        cinderDisk.setActive(true);
        cinderDisk.setParentId(Guid.Empty);
    }
    addCinderDiskTemplateToDB(cinderDisk);
    getReturnValue().setActionReturnValue(cinderDisk.getId());
    getParameters().setDestinationImageId(Guid.createGuidFromString(volumeId));
    getParameters().setContainerId(Guid.createGuidFromString(volumeId));
    persistCommand(getParameters().getParentCommand(), true);
    setSucceeded(true);
}
#end_block

#method_before
private String getNewVolumeCinderDisk(CinderDisk cinderDisk) {
    String volumeId;
    if (cinderDisk.getActive()) {
        volumeId = getCinderBroker().cloneDisk(cinderDisk);
    } else {
        volumeId = getCinderBroker().cloneVolumeFromSnapshot(cinderDisk, cinderDisk.getImageId());
        cinderDisk.setActive(true);
        cinderDisk.setParentId(Guid.Empty);
        cinderDisk.setVmSnapshotId(getParameters().getVmSnapshotId());
    }
    return volumeId;
}
#method_after
private String getNewVolumeCinderDisk(CinderDisk cinderDisk) {
    String volumeId;
    if (cinderDisk.getActive()) {
        volumeId = getCinderBroker().cloneDisk(cinderDisk);
    } else {
        volumeId = getCinderBroker().cloneVolumeFromSnapshot(cinderDisk, cinderDisk.getImageId());
    }
    return volumeId;
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(CinderDisk cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    DiskImage templateDisk = getParameters().getDisksMap().get(cinderDisk.getId());
    createParams.setDiskAlias(templateDisk.getDiskAlias());
    createParams.setStorageDomainId(templateDisk.getStorageIds().get(0));
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    createParams.setVmSnapshotId(cinderDisk.getVmSnapshotId());
    return createParams;
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(CinderDisk cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    DiskImage templateDisk = getParameters().getDisksMap().get(cinderDisk.getId());
    createParams.setDiskAlias(templateDisk.getDiskAlias());
    createParams.setStorageDomainId(templateDisk.getStorageIds().get(0));
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    createParams.setVmSnapshotId(getParameters().getVmSnapshotId());
    return createParams;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    oldVmId = getParameters().getVmId();
    setVmName(getParameters().getNewName());
    // init the parameters only at first instantiation (not subsequent for end action)
    if (Guid.isNullOrEmpty(getParameters().getNewVmGuid())) {
        setupParameters();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    oldVmId = getParameters().getVmId();
    setVmName(getParameters().getNewName());
    // init the parameters only at first instantiation (not subsequent for end action)
    if (Guid.isNullOrEmpty(getParameters().getNewVmGuid())) {
        setupParameters();
    } else {
        // the VM id has to be the new VM id - same as the getVm is always the new VM
        setVmId(getParameters().getNewVmGuid());
    }
}
#end_block

#method_before
public void createManagementNetworkIfRequired() {
    if (host == null) {
        return;
    }
    final String managementNetworkName = managementNetwork.getName();
    if (managementNetworkName.equals(host.getActiveNic())) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetworkName, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        configureManagementNetwork(createSetupNetworkParams(nic));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
public void createManagementNetworkIfRequired() {
    final String managementNetworkName = getManagementNetwork().getName();
    if (host == null) {
        return;
    }
    if (managementNetworkName.equals(host.getActiveNic())) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetworkName, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        configureManagementNetwork(createSetupNetworkParams(nic));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(managementNetwork.getId());
    managementAttachment.setNicId(nic.getId());
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setAddress(nic.getAddress());
    ipConfiguration.setNetmask(nic.getSubnet());
    ipConfiguration.setGateway(nic.getGateway());
    ipConfiguration.setBootProtocol(nic.getBootProtocol());
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#method_after
public HostSetupNetworksParameters createSetupNetworkParams(VdsNetworkInterface nic) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(host.getId());
    NetworkAttachment managementAttachment = new NetworkAttachment();
    managementAttachment.setNetworkId(getManagementNetwork().getId());
    managementAttachment.setNicId(nic.getId());
    IpConfiguration ipConfiguration = new IpConfiguration();
    ipConfiguration.setAddress(nic.getAddress());
    ipConfiguration.setNetmask(nic.getSubnet());
    ipConfiguration.setGateway(nic.getGateway());
    ipConfiguration.setBootProtocol(nic.getBootProtocol());
    managementAttachment.setIpConfiguration(ipConfiguration);
    parameters.getNetworkAttachments().add(managementAttachment);
    return parameters;
}
#end_block

#method_before
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    if (StringUtils.isEmpty(host.getActiveNic())) {
        log.warn("No interface was reported as lastClientInterface by host '{}' capabilities. " + "There will be no attempt to create the management network on the host.", host.getName());
        return null;
    }
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("The lastClientInterface '{}' of host '{}' is not a valid interface for the management network." + " If the interface is a bridge, it should be torn-down manually.", host.getActiveNic(), host.getName());
        throw new NetworkConfiguratorException(String.format("lastClientIface %s is not a valid interface for management network", host.getActiveNic()));
    }
    if (managementNetwork.getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(managementNetwork, nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(managementNetwork.getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#method_after
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    if (StringUtils.isEmpty(host.getActiveNic())) {
        log.warn("No interface was reported as lastClientInterface by host '{}' capabilities. " + "There will be no attempt to create the management network on the host.", host.getName());
        return null;
    }
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("The lastClientInterface '{}' of host '{}' is not a valid interface for the management network." + " If the interface is a bridge, it should be torn-down manually.", host.getActiveNic(), host.getName());
        throw new NetworkConfiguratorException(String.format("lastClientIface %s is not a valid interface for management network", host.getActiveNic()));
    }
    if (getManagementNetwork().getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(getManagementNetwork(), nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(getManagementNetwork().getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#end_block

#method_before
public List<VdsNetworkInterface> filterBondsWithoutSlaves(List<VdsNetworkInterface> interfaces) {
    List<VdsNetworkInterface> filteredList = new ArrayList<>();
    Map<String, Integer> bonds = new HashMap<>();
    for (VdsNetworkInterface iface : interfaces) {
        if (Boolean.TRUE.equals(iface.getBonded())) {
            bonds.put(iface.getName(), 0);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (bonds.containsKey(iface.getBondName())) {
            bonds.put(iface.getBondName(), bonds.get(iface.getBondName()) + 1);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (!bonds.containsKey(iface.getName()) || bonds.get(iface.getName()) >= 2) {
            filteredList.add(iface);
        }
    }
    return filteredList;
}
#method_after
public List<VdsNetworkInterface> filterBondsWithoutSlaves(List<VdsNetworkInterface> interfaces) {
    List<VdsNetworkInterface> filteredList = new ArrayList<VdsNetworkInterface>();
    Map<String, Integer> bonds = new HashMap<String, Integer>();
    for (VdsNetworkInterface iface : interfaces) {
        if (Boolean.TRUE.equals(iface.getBonded())) {
            bonds.put(iface.getName(), 0);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (bonds.containsKey(iface.getBondName())) {
            bonds.put(iface.getBondName(), bonds.get(iface.getBondName()) + 1);
        }
    }
    for (VdsNetworkInterface iface : interfaces) {
        if (!bonds.containsKey(iface.getName()) || bonds.get(iface.getName()) >= 2) {
            filteredList.add(iface);
        }
    }
    return filteredList;
}
#end_block

#method_before
private void configureManagementNetwork(HostSetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.HostSetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            auditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        auditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
private void configureManagementNetwork(HostSetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.HostSetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            AuditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        AuditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
private boolean validateNetworkAttachment() {
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(getParameters().getNetworkAttachment(), getVds(), managementNetworkUtil);
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkExists()) && validate(validator.notExternalNetwork()) && validate(validator.networkAttachedToCluster()) && validate(validator.networkNotAttachedToHost()) && validate(validator.ipConfiguredForStaticBootProtocol()) && validate(validator.bootProtocolSetForDisplayNetwork()) && validate(validator.nicExists()) && validate(validator.validateGateway());
}
#method_after
private boolean validateNetworkAttachment() {
    NetworkAttachmentValidator validator = new NetworkAttachmentValidator(getParameters().getNetworkAttachment(), getVds());
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkExists()) && validate(validator.notExternalNetwork()) && validate(validator.networkAttachedToCluster()) && validate(validator.networkNotAttachedToHost()) && validate(validator.ipConfiguredForStaticBootProtocol()) && validate(validator.bootProtocolSetForDisplayNetwork()) && validate(validator.nicExists()) && validate(validator.validateGateway());
}
#end_block

#method_before
private boolean validateAttachment() {
    ModifiedNetworkAttachmentValidator validator = new ModifiedNetworkAttachmentValidator(getParameters().getNetworkAttachment(), getVds(), managementNetworkUtil);
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkAttachmentExists()) && validate(validator.networkExists()) && validate(validator.notExternalNetwork()) && validate(validator.notRemovingManagementNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkAttachedToCluster()) && validate(validator.ipConfiguredForStaticBootProtocol()) && validate(validator.bootProtocolSetForDisplayNetwork()) && validate(validator.nicExists()) && validate(validator.validateGateway());
}
#method_after
private boolean validateAttachment() {
    ModifiedNetworkAttachmentValidator validator = new ModifiedNetworkAttachmentValidator(getParameters().getNetworkAttachment(), getVds());
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkAttachmentExists()) && validate(validator.networkExists()) && validate(validator.notExternalNetwork()) && validate(validator.notRemovingManagementNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkAttachedToCluster()) && validate(validator.ipConfiguredForStaticBootProtocol()) && validate(validator.bootProtocolSetForDisplayNetwork()) && validate(validator.nicExists()) && validate(validator.validateGateway());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    if (host == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (!HostSetupNetworksCommand.SUPPORTED_HOST_STATUSES.contains(host.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    ModifiedNetworkAttachmentValidator validator = new ModifiedNetworkAttachmentValidator(getParameters().getNetworkAttachment(), host, managementNetworkUtil);
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkAttachmentExists()) && validate(validator.notRemovingManagementNetwork()) && validate(validator.networkNotUsedByVms());
}
#method_after
@Override
protected boolean canDoAction() {
    VDS host = getVds();
    if (host == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (!HostSetupNetworksCommand.SUPPORTED_HOST_STATUSES.contains(host.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP_MAINTENANCE_OR_NON_OPERATIONAL);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    ModifiedNetworkAttachmentValidator validator = new ModifiedNetworkAttachmentValidator(getParameters().getNetworkAttachment(), host);
    return validate(validator.networkAttachmentIsSet()) && validate(validator.networkAttachmentExists()) && validate(validator.notRemovingManagementNetwork()) && validate(validator.networkNotUsedByVms());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(getParameters().getVdsId());
    NetworkAttachment networkAttachmentForRemove = getDbFacade().getNetworkAttachmentDao().get(getParameters().getNetworkAttachment().getId());
    params.getRemovedNetworkAttachments().add(networkAttachmentForRemove.getId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HostSetupNetworks, params);
    propagateFailure(returnValue);
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(getParameters().getVdsId());
    NetworkAttachment networkAttachmentForRemove = getDbFacade().getNetworkAttachmentDao().get(getParameters().getNetworkAttachment().getId());
    params.getRemovedNetworkAttachments().add(networkAttachmentForRemove);
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HostSetupNetworks, params);
    propagateFailure(returnValue);
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME).replace("@MODULE_LIST@", getModules(moduleServices)));
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            logger.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            logger.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        loadExtensions(moduleService, argMap);
        moduleService.run();
    } catch (ExitException e) {
        logger.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        String message = t.getMessage() != null ? t.getMessage() : t.getClass().getName();
        logger.error(message);
        logger.debug("Exception:", t);
    }
    logger.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#method_after
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        final Map<String, String> substitutions = new HashMap<>();
        substitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        substitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        substitutions.put("@MODULE_LIST@", getModules(moduleServices));
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("Usage: %s", parser.getUsage());
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            logger.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            logger.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        loadExtensions(moduleService, argMap);
        moduleService.run();
    } catch (ExitException e) {
        logger.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        String message = t.getMessage() != null ? t.getMessage() : t.getClass().getName();
        logger.error(message);
        logger.debug("Exception:", t);
    }
    logger.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#end_block

#method_before
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    Map<String, ExtensionProxy> proxies = moduleService.getContext().get(ModuleService.EXTENSIONS_MAP);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")).replace("@ENGINE_ETC@", ENGINE_ETC), "properties");
    }
    for (File f : files) {
        logger.debug("Loading extension file '{}'", f.getName());
        try {
            proxies.put(extensionsManager.load(f), null);
        } catch (Exception ex) {
            logger.error(ex.getMessage());
            logger.debug("Exception:", ex);
        }
    }
    for (Map.Entry<String, ExtensionProxy> entry : proxies.entrySet()) {
        extensionsManager.initialize(entry.getKey());
        entry.setValue(extensionsManager.getExtensionByName(entry.getKey()));
        logger.debug("Extension '{}' initilized", entry.getKey());
    }
}
#method_after
private static void loadExtensions(ModuleService moduleService, Map<String, Object> argMap) {
    ExtensionsManager extensionsManager = new ExtensionsManager();
    moduleService.getContext().put(ModuleService.EXTENSION_MANAGER, extensionsManager);
    Map<String, ExtensionProxy> proxies = moduleService.getContext().get(ModuleService.EXTENSIONS_MAP);
    List<File> files = (List<File>) argMap.get("extension-file");
    if (files == null) {
        files = listFiles(((String) argMap.get("extensions-dir")), "properties");
    }
    for (File f : files) {
        logger.debug("Loading extension file '{}'", f.getName());
        try {
            proxies.put(extensionsManager.load(f), null);
        } catch (Exception ex) {
            logger.error("Can't load extension '{}', ignoring.", f.getName());
            logger.debug("Exception:", ex);
        }
    }
    for (Map.Entry<String, ExtensionProxy> entry : proxies.entrySet()) {
        extensionsManager.initialize(entry.getKey());
        entry.setValue(extensionsManager.getExtensionByName(entry.getKey()));
        logger.debug("Extension '{}' initialized", entry.getKey());
    }
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<VDSGroup>(new NameRenderer<VDSGroup>()) {

        @Override
        public SortedMap<String, List<VDSGroup>> getGroupedList(List<VDSGroup> acceptableValues) {
            SortedMap<String, List<VDSGroup>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<VDSGroup> currentClusterList = null;
            for (VDSGroup cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                    if (currentDataCenter != null) {
                        result.put(currentDataCenter, currentClusterList);
                    }
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(VDSGroup model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(VDSGroup model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        public Comparator<VDSGroup> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<VDSGroup> {

            @Override
            public int compare(VDSGroup cluster1, VDSGroup cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<VDSGroup>(new NameRenderer<VDSGroup>()) {

        @Override
        public SortedMap<String, List<VDSGroup>> getGroupedList(List<VDSGroup> acceptableValues) {
            SortedMap<String, List<VDSGroup>> result = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
            Collections.sort(acceptableValues, new DataCenterClusterComparator());
            String currentDataCenter = null;
            List<VDSGroup> currentClusterList = null;
            for (VDSGroup cluster : acceptableValues) {
                if (currentDataCenter == null || !currentDataCenter.equals(cluster.getStoragePoolName())) {
                    currentClusterList = new ArrayList<>();
                    currentDataCenter = cluster.getStoragePoolName();
                    result.put(currentDataCenter, currentClusterList);
                }
                if (currentClusterList != null) {
                    currentClusterList.add(cluster);
                }
            }
            return result;
        }

        @Override
        public String getModelLabel(VDSGroup model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(VDSGroup model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<VDSGroup> {

            @Override
            public int compare(VDSGroup cluster1, VDSGroup cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    protocolEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> hostIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        hostIds.add(vds.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> prmsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        prmsToAttach.add(new AttachEntityToTagParameters(tag_id, hostIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVdsToTag, prmsToAttach);
    ArrayList<VdcActionParametersBase> prmsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        prmsToDetach.add(new AttachEntityToTagParameters(tag_id, hostIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVdsFromTag, prmsToDetach);
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> hostIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        hostIds.add(vds.getId());
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && model.getItems().size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> prmsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        prmsToAttach.add(new AttachVdsToTagParameters(tag_id, hostIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachVdsToTag, prmsToAttach);
    ArrayList<VdcActionParametersBase> prmsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        prmsToDetach.add(new AttachVdsToTagParameters(tag_id, hostIds));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.DetachVdsFromTag, prmsToDetach);
    cancel();
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus status = VMStatus.Unassigned;
        if (dbVm != null) {
            status = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended, vdsmVm.getVmDynamic().getStatusUpdatedTime());
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason(), vdsmVm.getVmDynamic().getStatusUpdatedTime());
        }
        VmStatistics vmStatistics = vmsMonitoring.getDbFacade().getVmStatisticsDao().get(vdsmVm.getVmDynamic().getId());
        if (vmStatistics != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic(), vmStatistics);
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus status = VMStatus.Unassigned;
        if (dbVm != null) {
            status = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        }
        VmStatistics vmStatistics = vmsMonitoring.getDbFacade().getVmStatisticsDao().get(vdsmVm.getVmDynamic().getId());
        if (vmStatistics != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic(), vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason, Double statusUpdatedTime) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason, statusUpdatedTime);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#method_after
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason(), vdsmVm.getVmDynamic().getStatusUpdatedTime());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().RemoveVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#method_after
private void updateRepository() {
    if (vdsmVm != null) {
        VmDynamic vdsmVmDynamic = vdsmVm.getVmDynamic();
        // if not migrating here and not down
        if (!inMigrationTo(vdsmVmDynamic, dbVm) && vdsmVmDynamic.getStatus() != VMStatus.Down) {
            if (dbVm != null) {
                if (!StringUtils.equals(vdsmVmDynamic.getClientIp(), dbVm.getClientIp())) {
                    clientIpChanged = true;
                }
            }
            if (dbVm != null) {
                logVmStatusTransition();
                if (dbVm.getStatus() != VMStatus.Up && vdsmVmDynamic.getStatus() == VMStatus.Up || dbVm.getStatus() != VMStatus.PoweringUp && vdsmVmDynamic.getStatus() == VMStatus.PoweringUp) {
                    poweringUp = true;
                }
                // "Up" as this means that the power down operation failed:
                if (dbVm.getStatus() == VMStatus.PoweringDown && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (dbVm.getStatus() != VMStatus.Up && dbVm.getStatus() != VMStatus.MigratingFrom && vdsmVmDynamic.getStatus() == VMStatus.Up) {
                    // Vm moved to Up status - remove its record from Async
                    // reportedAndUnchangedVms handling
                    log.debug("removing VM '{}' from successful run VMs list", dbVm.getId());
                    succeededToRun = true;
                }
                afterMigrationFrom(vdsmVmDynamic, dbVm);
                if (dbVm.getStatus() != VMStatus.NotResponding && vdsmVmDynamic.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (vdsmVmDynamic.getStatus() == VMStatus.Paused) {
                    removeFromAsync = true;
                    if (dbVm.getStatus() != VMStatus.Paused) {
                        AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                        auditLog(logable, AuditLogType.VM_PAUSED);
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(vdsmVmDynamic.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (dbVm != null || vdsmVmDynamic.getStatus() != VMStatus.MigratingFrom) {
                if (updateVmRunTimeInfo()) {
                    saveDynamic(dbVm.getDynamicData());
                }
            }
            if (dbVm != null) {
                updateVmStatistics();
                stable = true;
                if (!getVdsManager().isInitialized()) {
                    vmsMonitoring.getResourceManager().RemoveVmFromDownVms(getVdsManager().getVdsId(), vdsmVmDynamic.getId());
                }
            }
        } else {
            if (vdsmVmDynamic.getStatus() == VMStatus.MigratingTo) {
                stable = true;
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(vdsmVmDynamic.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                saveDynamic(null);
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache();
}
#end_block

#method_before
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError, dbVm.getStatusUpdatedTime());
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#method_after
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    VdsManager manager = getVdsManager();
    manager.resetStatusUpdateTime(vmToRemove.getId());
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().InternalSetVmStatus(vmToRemove, newVmStatus, vmToRemove.getStatusUpdatedTime());
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        VdsManager manager = getVdsManager();
        manager.resetStatusUpdateTime(vmToUpdate.getId());
        rerun = true;
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        saveStatistics();
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        rerun = true;
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        saveStatistics();
    }
}
#end_block

#method_before
public boolean parse(List<String> args) {
    parsedArgs = new HashMap<>();
    errors = new ArrayList<>();
    while (!args.isEmpty()) {
        String arg = args.get(0);
        if (!arg.startsWith(LONG_PREFIX)) {
            break;
        }
        arg = args.remove(0);
        if (arg.equals(LONG_PREFIX)) {
            break;
        }
        String[] argVal = parseArgument(arg.substring(2));
        String key = argVal[0];
        String value = argVal[1];
        Argument argument = arguments.get(key);
        if (argument == null) {
            errors.add(new IllegalArgumentException(String.format("Invalid argument '%1$s'", arg)));
        } else {
            if (value == null && (argument.getType() == Argument.Type.OPTIONAL_ARGUMENT || argument.getType() == Argument.Type.HAS_ARGUMENT)) {
                if (args.size() > 0) {
                    value = args.get(0);
                    if (value.startsWith(LONG_PREFIX)) {
                        value = null;
                    } else {
                        args.remove(0);
                    }
                }
            }
            if (argument.getType() == Argument.Type.HAS_ARGUMENT && value == null) {
                errors.add(new IllegalArgumentException(String.format("Value is required, but missing for argument '%1$s'", key)));
            }
            if (value == null) {
                value = argument.getValue();
            }
            Object convertedValue = null;
            if (value != null) {
                Matcher m = argument.getMatcher().matcher(value);
                if (!m.matches()) {
                    errors.add(new IllegalArgumentException(String.format("Pattern for argument '%1$s' does not match, pattern is '%2$s', value is '%3$s", key, m.pattern(), value)));
                }
                convertedValue = StringValueConverter.getObjectValueByString(argument.getValueType(), value);
            }
            putValue(parsedArgs, argument, convertedValue);
        }
    }
    fillDefaults(parsedArgs);
    List<String> mandatoryCopy = new ArrayList<String>(mandatory);
    mandatoryCopy.removeAll(parsedArgs.keySet());
    if (!mandatoryCopy.isEmpty()) {
        errors.add(new IllegalArgumentException(String.format("Argument(s) '%1$s' required", StringUtils.join(mandatoryCopy, ", "))));
    }
    return errors.isEmpty();
}
#method_after
public boolean parse(List<String> args) {
    parsedArgs = new HashMap<>();
    errors = new ArrayList<>();
    while (!args.isEmpty()) {
        String arg = args.get(0);
        if (!arg.startsWith(LONG_PREFIX)) {
            break;
        }
        arg = args.remove(0);
        if (arg.equals(LONG_PREFIX)) {
            break;
        }
        String[] argVal = parseArgument(arg.substring(2));
        String key = argVal[0];
        String value = argVal[1];
        Argument argument = arguments.get(key);
        if (argument == null) {
            errors.add(new IllegalArgumentException(String.format("Invalid argument '%1$s'", arg)));
        } else {
            if (value == null && (argument.getType() == Argument.Type.OPTIONAL_ARGUMENT || argument.getType() == Argument.Type.REQUIRED_ARGUMENT)) {
                if (args.size() > 0) {
                    value = args.get(0);
                    if (value.startsWith(LONG_PREFIX)) {
                        value = null;
                    } else {
                        args.remove(0);
                    }
                }
            }
            if (argument.getType() == Argument.Type.REQUIRED_ARGUMENT && value == null) {
                errors.add(new IllegalArgumentException(String.format("Value is required, but missing for argument '%1$s'", key)));
            }
            if (value == null) {
                value = argument.getValue();
            }
            Object convertedValue = null;
            if (value != null) {
                Matcher m = argument.getMatcher().matcher(value);
                if (!m.matches()) {
                    errors.add(new IllegalArgumentException(String.format("Pattern for argument '%1$s' does not match, pattern is '%2$s', value is '%3$s", key, m.pattern(), value)));
                }
                convertedValue = StringValueConverter.getObjectValueByString(argument.getValueType(), value);
            }
            putValue(parsedArgs, argument, convertedValue);
        }
    }
    fillDefaults(parsedArgs);
    List<String> mandatoryCopy = new ArrayList<String>(mandatory);
    mandatoryCopy.removeAll(parsedArgs.keySet());
    if (!mandatoryCopy.isEmpty()) {
        errors.add(new IllegalArgumentException(String.format("Argument(s) '%1$s' required", StringUtils.join(mandatoryCopy, ", "))));
    }
    return errors.isEmpty();
}
#end_block

#method_before
public String getUsage() {
    StringBuilder help = new StringBuilder(String.format("Options:%n"));
    for (String arg : getPrefixArguments()) {
        Argument argument = this.arguments.get(arg);
        help.append(String.format("  --%s%n" + "    %s%n" + "%n", arg + (argument.getType() != Argument.Type.NO_ARGUMENT ? "=[" + argument.getMetavar() + "]" : ""), argument.getHelp().replace("@DEFAULT@", argument.getDefaultValue() == null ? "" : argument.getDefaultValue()).replace("@PATTERN@", argument.getMatcher().pattern())));
    }
    return String.format("%1$s%n%2$s%n%n%3$s%4$s%n", properties.getProperty(prefix + ".help.usage", (String) defaultProperties.get("help.usage")), properties.getProperty(prefix + ".help.header", (String) defaultProperties.get("help.header")), help.toString(), properties.getProperty(prefix + ".help.footer", (String) defaultProperties.get("help.footer")));
}
#method_after
public String getUsage() {
    StringBuilder help = new StringBuilder(String.format("Options:%n"));
    for (String arg : getPrefixArguments()) {
        Argument argument = this.arguments.get(arg);
        help.append(String.format("  --%s%n" + "    %s%n" + "%n", arg + (argument.getType() != Argument.Type.NO_ARGUMENT ? "=[" + argument.getMetavar() + "]" : ""), argument.getHelp().replace("@CLI_PRM_DEFAULT@", StringUtils.defaultString(argument.getDefaultValue())).replace("@CLI_PRM_PATTERN@", argument.getMatcher().pattern())));
    }
    return doSubstitutions(String.format("%1$s%n%2$s%n%n%3$s%4$s%n", properties.getProperty(prefix + ".help.usage", (String) defaultProperties.get("help.usage")), properties.getProperty(prefix + ".help.header", (String) defaultProperties.get("help.header")), help.toString(), properties.getProperty(prefix + ".help.footer", (String) defaultProperties.get("help.footer"))));
}
#end_block

#method_before
private void fillDefaults(Map<String, Object> argMap) {
    for (Argument arg : arguments.values()) {
        if (!argMap.containsKey(arg.getName()) && arg.getDefaultValue() != null) {
            putValue(argMap, arg, StringValueConverter.getObjectValueByString(arg.getValueType(), arg.getDefaultValue()));
        }
    }
}
#method_after
private void fillDefaults(Map<String, Object> argMap) {
    for (Argument arg : arguments.values()) {
        if (!argMap.containsKey(arg.getName()) && arg.getDefaultValue() != null) {
            putValue(argMap, arg, StringValueConverter.getObjectValueByString(arg.getValueType(), doSubstitutions(arg.getDefaultValue())));
        }
    }
}
#end_block

#method_before
@Override
public void store(IFrontendActionAsyncCallback callback) {
    if (getProgress() != null || !validate()) {
        return;
    }
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = callback != null ? callback : new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
        }
    };
    List<EntityModel<DiskModel>> disksToAttach = getSelectedDisks();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = disksToAttach.get(i).getEntity();
        boolean activate = false;
        if (getIsPlugged().getEntity()) {
            if (disk.getDisk().getDiskInterface() == DiskInterface.IDE) {
                activate = getVm().getStatus() == VMStatus.Down;
            } else {
                activate = true;
            }
        }
        // Disk is attached to VM as read only or not, null is applicable only for floating disks
        // but this is not a case here.
        AttachDetachVmDiskParameters parameters = new AttachDetachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), activate, Boolean.TRUE.equals(disk.getDisk().getReadOnly()));
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#method_after
@Override
public void store(IFrontendActionAsyncCallback callback) {
    if (getProgress() != null || !validate()) {
        return;
    }
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> paramerterList = new ArrayList<VdcActionParametersBase>();
    ArrayList<IFrontendActionAsyncCallback> callbacks = new ArrayList<IFrontendActionAsyncCallback>();
    IFrontendActionAsyncCallback onFinishCallback = callback != null ? callback : new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            NewDiskModel diskModel = (NewDiskModel) result.getState();
            diskModel.stopProgress();
            diskModel.cancel();
        }
    };
    List<EntityModel<DiskModel>> disksToAttach = getSelectedDisks();
    for (int i = 0; i < disksToAttach.size(); i++) {
        DiskModel disk = disksToAttach.get(i).getEntity();
        /*
            IDE disks can be activated only when the VM is down.
            Other disks can be hot plugged.
             */
        boolean activate = false;
        if (getIsPlugged().getEntity()) {
            activate = disk.getDisk().getDiskInterface() == DiskInterface.IDE ? getVm().getStatus() == VMStatus.Down : true;
        }
        // Disk is attached to VM as read only or not, null is applicable only for floating disks
        // but this is not a case here.
        AttachDetachVmDiskParameters parameters = new AttachDetachVmDiskParameters(getVm().getId(), disk.getDisk().getId(), activate, Boolean.TRUE.equals(disk.getDisk().getReadOnly()));
        actionTypes.add(VdcActionType.AttachDiskToVm);
        paramerterList.add(parameters);
        callbacks.add(i == disksToAttach.size() - 1 ? onFinishCallback : null);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleActions(actionTypes, paramerterList, callbacks, null, this);
}
#end_block

#method_before
private void updateConfig() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    List<IFrontendActionAsyncCallback> callbacks;
    final GlusterVolumeGeoReplicationSessionConfigModel geoRepConfigModel = (GlusterVolumeGeoReplicationSessionConfigModel) getWindow();
    LinkedHashMap<String, String> oldConfigs = geoRepConfigModel.getConfigs();
    geoRepConfigModel.startProgress(null);
    for (EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> newConfigEntity : geoRepConfigModel.getConfigsModel().getItems()) {
        Pair<Boolean, GlusterGeoRepSessionConfiguration> newConfigPair = newConfigEntity.getEntity();
        GlusterGeoRepSessionConfiguration newConfig = newConfigPair.getSecond();
        boolean isOldConfigNonNull = oldConfigs.get(newConfig.getKey()) != null;
        boolean isNewConfigNonNull = newConfig != null && newConfig.getValue() != null;
        if (isNewConfigNonNull && !newConfig.getValue().isEmpty()) {
            if (!isOldConfigNonNull || !newConfig.getValue().equals(oldConfigs.get(newConfig.getKey()))) {
                actionTypes.add(VdcActionType.SetGeoRepConfig);
                parameters.add(geoRepConfigModel.formGeoRepConfigParameters(newConfig));
            }
        }
        if (newConfigPair.getFirst()) {
            actionTypes.add(VdcActionType.ResetDefaultGeoRepConfig);
            parameters.add(geoRepConfigModel.formGeoRepConfigParameters(newConfig));
        }
    }
    int numberOfConfigUpdates = parameters.size();
    if (numberOfConfigUpdates == 0) {
        geoRepConfigModel.stopProgress();
        closeWindow();
        return;
    }
    callbacks = new ArrayList<IFrontendActionAsyncCallback>(Collections.nCopies(numberOfConfigUpdates, (IFrontendActionAsyncCallback) null));
    callbacks.set(numberOfConfigUpdates - 1, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            geoRepConfigModel.stopProgress();
            closeWindow();
        }
    });
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, callbacks, new IFrontendActionAsyncCallback() {

        // Failure call back. Update the config list just to reflect any new changes and default error msg
        // dialog is thrown.
        @Override
        public void executed(FrontendActionAsyncResult result) {
            fetchConfigForSession(geoRepConfigModel.getGeoRepSession());
        }
    }, this);
}
#method_after
private void updateConfig() {
    ArrayList<VdcActionType> actionTypes = new ArrayList<VdcActionType>();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    List<IFrontendActionAsyncCallback> callbacks;
    final GlusterVolumeGeoReplicationSessionConfigModel geoRepConfigModel = (GlusterVolumeGeoReplicationSessionConfigModel) getWindow();
    LinkedHashMap<String, String> oldConfigs = geoRepConfigModel.getConfigs();
    geoRepConfigModel.startProgress(null);
    for (EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> newConfigEntity : geoRepConfigModel.getConfigsModel().getItems()) {
        Pair<Boolean, GlusterGeoRepSessionConfiguration> newConfigPair = newConfigEntity.getEntity();
        GlusterGeoRepSessionConfiguration newConfig = newConfigPair.getSecond();
        boolean isOldConfigNull = newConfig == null ? true : oldConfigs.get(newConfig.getKey()) == null;
        boolean isNewConfigNull = newConfig == null || newConfig.getValue() == null;
        if ((!isNewConfigNull && !newConfig.getValue().isEmpty()) && (isOldConfigNull || !newConfig.getValue().equals(oldConfigs.get(newConfig.getKey())))) {
            actionTypes.add(VdcActionType.SetGeoRepConfig);
            parameters.add(geoRepConfigModel.formGeoRepConfigParameters(newConfig));
        }
        if (newConfigPair.getFirst()) {
            actionTypes.add(VdcActionType.ResetDefaultGeoRepConfig);
            parameters.add(geoRepConfigModel.formGeoRepConfigParameters(newConfig));
        }
    }
    int numberOfConfigUpdates = parameters.size();
    if (numberOfConfigUpdates == 0) {
        geoRepConfigModel.stopProgress();
        closeWindow();
        return;
    }
    callbacks = new ArrayList<IFrontendActionAsyncCallback>(Collections.nCopies(numberOfConfigUpdates, (IFrontendActionAsyncCallback) null));
    callbacks.set(numberOfConfigUpdates - 1, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            geoRepConfigModel.stopProgress();
            closeWindow();
        }
    });
    Frontend.getInstance().runMultipleActions(actionTypes, parameters, callbacks, new IFrontendActionAsyncCallback() {

        // Failure call back. Update the config list just to reflect any new changes and default error msg
        // dialog is thrown.
        @Override
        public void executed(FrontendActionAsyncResult result) {
            fetchConfigForSession(geoRepConfigModel.getGeoRepSession());
        }
    }, this);
}
#end_block

#method_before
protected void updateDiscoveredSessionConfig(VDSGroup cluster, GlusterGeoRepSession session) {
    List<GlusterGeoRepSessionConfiguration> sessionConfigList = getSessionConfigFromCLI(cluster, session);
    if (sessionConfigList == null) {
        log.info("No configuration information returned from VDS for session '{}'", session.getSessionKey());
        return;
    }
    List<GlusterGeoRepSessionConfiguration> existingSessionConfigs = getGeoRepDao().getGeoRepSessionConfig(session.getId());
    Map<String, GlusterGeoRepSessionConfiguration> existingKeyConfigMap = prepareMapOfExistingConfigs(existingSessionConfigs);
    for (GlusterGeoRepSessionConfiguration sessionConfig : sessionConfigList) {
        // update sessionId for fetched object.
        sessionConfig.setId(session.getId());
        // check if session config not same as in db
        if (!existingSessionConfigs.contains(sessionConfig)) {
            // confirm that it exists in db, which means config has been updated
            if (existingKeyConfigMap.containsKey(sessionConfig.getKey())) {
                getGeoRepDao().updateConfig(sessionConfig);
                String oldValue = existingKeyConfigMap.get(sessionConfig.getKey()).getValue();
                logGeoRepMessage(AuditLogType.GEOREP_OPTION_CHANGED_FROM_CLI, cluster.getId(), getOptionChangedCustomVars(session, sessionConfig.getKey(), sessionConfig.getValue(), oldValue));
            } else {
                getGeoRepDao().saveConfig(sessionConfig);
                logGeoRepMessage(AuditLogType.GEOREP_OPTION_SET_FROM_CLI, cluster.getId(), getOptionChangedCustomVars(session, sessionConfig.getKey(), sessionConfig.getValue(), null));
            }
        }
    }
}
#method_after
protected void updateDiscoveredSessionConfig(VDSGroup cluster, GlusterGeoRepSession session) {
    List<GlusterGeoRepSessionConfiguration> sessionConfigList = getSessionConfigFromCLI(cluster, session);
    if (sessionConfigList == null) {
        log.info("No configuration information returned from VDS for session '{}'", session.getSessionKey());
        return;
    }
    List<GlusterGeoRepSessionConfiguration> existingSessionConfigs = getGeoRepDao().getGeoRepSessionConfig(session.getId());
    Map<String, GlusterGeoRepSessionConfiguration> existingKeyConfigMap = prepareMapOfGeoRepSessionConfigs(existingSessionConfigs);
    for (GlusterGeoRepSessionConfiguration sessionConfig : sessionConfigList) {
        // update sessionId for fetched object.
        sessionConfig.setId(session.getId());
        // check if session config not same as in db
        if (!existingSessionConfigs.contains(sessionConfig)) {
            // confirm that it exists in db, which means config has been updated
            if (existingKeyConfigMap.containsKey(sessionConfig.getKey())) {
                getGeoRepDao().updateConfig(sessionConfig);
                String oldValue = existingKeyConfigMap.get(sessionConfig.getKey()).getValue();
                logGeoRepMessage(AuditLogType.GEOREP_OPTION_CHANGED_FROM_CLI, cluster.getId(), getOptionChangedCustomVars(session, sessionConfig.getKey(), sessionConfig.getValue(), oldValue));
            } else {
                getGeoRepDao().saveConfig(sessionConfig);
                logGeoRepMessage(AuditLogType.GEOREP_OPTION_SET_FROM_CLI, cluster.getId(), getOptionChangedCustomVars(session, sessionConfig.getKey(), sessionConfig.getValue(), null));
            }
        }
    }
    // If configs are reset some of them will disappear from config list
    Map<String, GlusterGeoRepSessionConfiguration> sessionKeyConfigMap = prepareMapOfGeoRepSessionConfigs(sessionConfigList);
    existingKeyConfigMap.keySet().removeAll(sessionKeyConfigMap.keySet());
    Iterator<Map.Entry<String, GlusterGeoRepSessionConfiguration>> mapIterator = existingKeyConfigMap.entrySet().iterator();
    while (mapIterator.hasNext()) {
        GlusterGeoRepSessionConfiguration config = new GlusterGeoRepSessionConfiguration();
        config.setId(session.getId());
        config.setKey(mapIterator.next().getKey());
        getGeoRepDao().updateConfig(config);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterGeoRepSession session = getGeoRepSession();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetGlusterVolumeGeoRepConfigDefault, new GlusterVolumeGeoRepConfigVdsParameters(upServer.getId(), session.getMasterVolumeName(), session.getSlaveHostName(), session.getSlaveVolumeName(), getParameters().getConfigKey(), null, session.getUserName()));
    GlusterGeoRepSyncJob.getInstance().updateDiscoveredSessionConfig(getVdsGroupDAO().get(getGlusterVolume().getClusterId()), session);
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_GEOREP_CONFIG_SET_DEFAULT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    GlusterGeoRepSession session = getGeoRepSession();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.SetGlusterVolumeGeoRepConfigDefault, new GlusterVolumeGeoRepConfigVdsParameters(upServer.getId(), session.getMasterVolumeName(), session.getSlaveHostName(), session.getSlaveVolumeName(), getParameters().getConfigKey(), null, session.getUserName()));
    GlusterGeoRepSyncJob.getInstance().updateDiscoveredSessionConfig(getVdsGroup(), session);
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_GEOREP_CONFIG_SET_DEFAULT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
private void initConfigTable() {
    geoReplicationConfigTable = new EntityModelCellTable<>(false, true);
    geoReplicationConfigTable.setSelectionModel(new NoSelectionModel());
    geoReplicationConfigTable.addColumn(new AbstractEntityModelTextColumn<Pair<Boolean, GlusterGeoRepSessionConfiguration>>() {

        @Override
        protected String getText(Pair<Boolean, GlusterGeoRepSessionConfiguration> entity) {
            return entity.getSecond().getKey();
        }
    }, constants.optionKeyVolumeParameter());
    geoReplicationConfigTable.addColumn(new AbstractTextColumn<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>>(80) {

        @Override
        public String getValue(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return object.getEntity().getSecond().getDescription() == null ? constants.notAvailableLabel() : object.getEntity().getSecond().getDescription();
        }
    }, constants.descriptionVolumeParameter(), // $NON-NLS-1$
    "175px");
    geoReplicationConfigTable.addColumn(new GlusterConfigAwareColumn(), constants.optionValueVolumeParameter(), // $NON-NLS-1$
    "100px");
    geoReplicationConfigTable.addColumn(new AbstractCheckboxColumn<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>>(true, new FieldUpdater<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>, Boolean>() {

        @Override
        public void update(int index, EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object, Boolean value) {
            object.getEntity().setFirst(value);
        }
    }) {

        @Override
        protected boolean canEdit(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return true;
        }

        @Override
        public Boolean getValue(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return object.getEntity().getFirst();
        }
    }, constants.resetGeoRepSessionConfig());
}
#method_after
private void initConfigTable() {
    geoReplicationConfigTable = new EntityModelCellTable<>(false, true);
    geoReplicationConfigTable.setSelectionModel(new NoSelectionModel());
    geoReplicationConfigTable.addColumn(new AbstractEntityModelTextColumn<Pair<Boolean, GlusterGeoRepSessionConfiguration>>() {

        @Override
        protected String getText(Pair<Boolean, GlusterGeoRepSessionConfiguration> entity) {
            return entity.getSecond().getKey();
        }
    }, constants.optionKeyVolumeParameter(), // $NON-NLS-1$
    "150px");
    geoReplicationConfigTable.addColumn(new AbstractScrollableTextColumn<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>>() {

        @Override
        public String getValue(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return object.getEntity().getSecond().getDescription() == null ? constants.notAvailableLabel() : object.getEntity().getSecond().getDescription();
        }
    }, constants.descriptionVolumeParameter(), // $NON-NLS-1$
    "300px");
    geoReplicationConfigTable.addColumn(new GlusterConfigAwareColumn(), constants.optionValueVolumeParameter(), // $NON-NLS-1$
    "200px");
    geoReplicationConfigTable.addColumn(new AbstractCheckboxColumn<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>>(true, new FieldUpdater<EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>>, Boolean>() {

        @Override
        public void update(int index, EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object, Boolean value) {
            object.getEntity().setFirst(value);
        }
    }) {

        @Override
        protected boolean canEdit(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return true;
        }

        @Override
        public Boolean getValue(EntityModel<Pair<Boolean, GlusterGeoRepSessionConfiguration>> object) {
            return object.getEntity().getFirst();
        }
    }, constants.resetGeoRepSessionConfig());
}
#end_block

#method_before
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus status = VMStatus.Unassigned;
        if (dbVm != null) {
            status = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended, vdsmVm.getVmDynamic().getStatusUpdatedTime());
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason(), vdsmVm.getVmDynamic().getStatusUpdatedTime());
        }
        VmStatistics vmStatistics = vmsMonitoring.getDbFacade().getVmStatisticsDao().get(vdsmVm.getVmDynamic().getId());
        if (vmStatistics != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic(), vmStatistics);
            }
        }
    }
}
#method_after
void proceedDownVms() {
    if (vdsmVm != null && vdsmVm.getVmDynamic().getStatus() == VMStatus.Down) {
        VMStatus status = VMStatus.Unassigned;
        if (dbVm != null) {
            status = dbVm.getStatus();
            proceedVmBeforeDeletion();
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Suspended);
            }
            clearVm(vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
        }
        VmStatistics vmStatistics = vmsMonitoring.getDbFacade().getVmStatisticsDao().get(vdsmVm.getVmDynamic().getId());
        if (vmStatistics != null) {
            vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.Destroy, new DestroyVmVDSCommandParameters(getVdsManager().getVdsId(), vdsmVm.getVmDynamic().getId(), false, false, 0));
            if (dbVm != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vdsmVm.getVmDynamic());
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(dbVm, vdsmVm.getVmDynamic(), vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason, Double statusUpdatedTime) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason, statusUpdatedTime);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#method_after
private void clearVm(VmExitStatus exitStatus, String exitMessage, VmExitReason vmExistReason) {
    if (dbVm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to vmDynamicToSave though because it might been removed from it in #updateRepository
        if (dbVm.getStatus() != VMStatus.Suspended && dbVm.getStatus() != VMStatus.Down) {
            vmsMonitoring.getResourceManager().InternalSetVmStatus(dbVm, VMStatus.Down, exitStatus, exitMessage, vmExistReason);
        }
        saveDynamic(dbVm.getDynamicData());
        saveStatistics();
        saveVmInterfaces();
        if (!vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            movedToDown = true;
        }
    }
}
#end_block

#method_before
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason(), vdsmVm.getVmDynamic().getStatusUpdatedTime());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
// TODO Method with Side-Effect - move to VmsMonitoring
private void proceedVmBeforeDeletion() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(getVdsManager().getVdsId(), dbVm.getId());
    switch(dbVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vdsmVm.getVmDynamic() != null && vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal) {
                    if (dbVm.getMigratingToVds() != null) {
                        VDSReturnValue destoryReturnValue = vmsMonitoring.getResourceManager().runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(dbVm.getMigratingToVds().toString()), dbVm.getId(), true, false, 0));
                        if (destoryReturnValue.getSucceeded()) {
                            log.info("Stopped migrating VM: '{}' on VDS: '{}'", dbVm.getName(), dbVm.getMigratingToVds());
                        } else {
                            log.info("Could not stop migrating VM: '{}' on VDS: '{}', Error: '{}'", dbVm.getName(), dbVm.getMigratingToVds(), destoryReturnValue.getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(dbVm, VMStatus.Down, vdsmVm.getVmDynamic().getExitStatus(), vdsmVm.getVmDynamic().getExitMessage(), vdsmVm.getVmDynamic().getExitReason());
                    saveDynamic(dbVm.getDynamicData());
                    saveStatistics();
                    saveVmInterfaces();
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vdsmVm.getVmDynamic().getExitMessage());
                    vmsMonitoring.getResourceManager().RemoveAsyncRunningVm(vdsmVm.getVmDynamic().getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError, dbVm.getStatusUpdatedTime());
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#method_after
private void removeVmsFromCache() {
    if (dbVm != null && !stable) {
        proceedVmBeforeDeletion();
        boolean migrating = dbVm.getStatus() == VMStatus.MigratingFrom;
        if (migrating) {
            handOverVM(dbVm);
        } else {
            clearVm(VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", dbVm.getName()), VmExitReason.GenericError);
        }
        log.info("VM '{}({}) is running in db and not running in VDS '{}'", dbVm.getId(), dbVm.getName(), getVdsManager().getVdsName());
        if (!migrating && !rerun && vmsMonitoring.getResourceManager().IsVmInAsyncRunningList(dbVm.getId())) {
            rerun = true;
            log.info("add VM '{}' to rerun treatment", dbVm.getName());
        } else // or reported from vdsm with error code
        if (dbVm.isAutoStartup() && !autoVmToRun && (vdsmVm == null || vdsmVm.getVmDynamic().getExitStatus() != VmExitStatus.Normal)) {
            autoVmToRun = true;
            log.info("add VM '{}' to HA rerun treatment", dbVm.getName());
        }
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    VdsManager manager = getVdsManager();
    manager.resetStatusUpdateTime(vmToRemove.getId());
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().InternalSetVmStatus(vmToRemove, newVmStatus, vmToRemove.getStatusUpdatedTime());
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.info("Handing over VM '{}'({}) to Host '{}'. Setting VM to status '{}'", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    vmsMonitoring.getResourceManager().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    saveDynamic(vmToRemove.getDynamicData());
    saveStatistics();
    saveVmInterfaces();
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        VdsManager manager = getVdsManager();
        manager.resetStatusUpdateTime(vmToUpdate.getId());
        rerun = true;
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        saveStatistics();
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getStatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        rerun = true;
        log.info("Adding VM '{}' to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
        vmToUpdate.setMigrationProgressPercent(0);
        saveStatistics();
    }
}
#end_block

#method_before
public static ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, Version version, DbUser user) {
    if (map == null || !FeatureSupported.storageQoS(version)) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    // caching disk profile ids that was already checked.
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskStorageType() != DiskStorageType.IMAGE) {
            continue;
        }
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = getDiskProfileDao().getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = getDiskProfileDao().get(diskImage.getDiskProfileId());
            ValidationResult result = new DiskProfileValidator(diskProfile).isParentEntityValid(storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult setAndValidateDiskProfiles(Map<DiskImage, Guid> map, Version version, DbUser user) {
    if (map == null || !FeatureSupported.storageQoS(version)) {
        return ValidationResult.VALID;
    }
    Map<Guid, List<DiskProfile>> storageDiskProfilesMap = new HashMap<>();
    // caching disk profile ids that was already checked.
    Set<Guid> permittedDiskProfilesIds = new HashSet<>();
    for (Entry<DiskImage, Guid> entry : map.entrySet()) {
        DiskImage diskImage = entry.getKey();
        Guid storageDomainId = entry.getValue();
        if (diskImage.getDiskStorageType() != DiskStorageType.IMAGE) {
            log.info("Disk profiles is not supported for storage type '{}' (Disk '{}')", diskImage.getDiskStorageType(), diskImage.getDiskAlias());
            continue;
        }
        if (diskImage.getDiskProfileId() == null && storageDomainId != null) {
            List<DiskProfile> diskProfilesList = storageDiskProfilesMap.get(storageDomainId);
            if (diskProfilesList == null) {
                diskProfilesList = getDiskProfileDao().getAllForStorageDomain(storageDomainId);
                storageDiskProfilesMap.put(storageDomainId, diskProfilesList);
            }
            // Set Disk Profile according to permissions
            if (!updateDiskProfileForBackwardCompatibility(diskImage, diskProfilesList, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        } else {
            DiskProfile diskProfile = getDiskProfileDao().get(diskImage.getDiskProfileId());
            ValidationResult result = new DiskProfileValidator(diskProfile).isParentEntityValid(storageDomainId);
            if (result != ValidationResult.VALID) {
                return result;
            }
            if (!isDiskProfilePermitted(diskProfile, permittedDiskProfilesIds, user)) {
                return new ValidationResult(VdcBllMessages.USER_NOT_AUTHORIZED_TO_ATTACH_DISK_PROFILE);
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected void updateQuota(DiskImage diskImage) {
    if (isDiskImage() || isCinderDisk()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getQuotaId(), diskImage.getQuotaId())) {
            getImageStorageDomainMapDao().updateQuotaForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId());
        }
    }
}
#method_after
protected void updateQuota(DiskImage diskImage) {
    if (isInternalManagedDisk()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getQuotaId(), diskImage.getQuotaId())) {
            getImageStorageDomainMapDao().updateQuotaForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId());
        }
    }
}
#end_block

#method_before
protected Guid getQuotaId() {
    if (getNewDisk() != null && (isDiskImage() || isCinderDisk())) {
        return ((DiskImage) getNewDisk()).getQuotaId();
    }
    return null;
}
#method_after
protected Guid getQuotaId() {
    if (getNewDisk() != null && isInternalManagedDisk()) {
        return ((DiskImage) getNewDisk()).getQuotaId();
    }
    return null;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isDiskImage() || isCinderDisk()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        long diskExtendingDiff = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        if (emptyOldQuota || differentNewQuota) {
            list.add(generateQuotaConsumeParameters(newDiskImage, newDiskImage.getSizeInGigabytes()));
        } else if (diskExtendingDiff > 0L) {
            list.add(generateQuotaConsumeParameters(newDiskImage, diskExtendingDiff));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isInternalManagedDisk()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        long diskExtendingDiff = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        if (emptyOldQuota || differentNewQuota) {
            list.add(generateQuotaConsumeParameters(newDiskImage, newDiskImage.getSizeInGigabytes()));
        } else if (diskExtendingDiff > 0L) {
            list.add(generateQuotaConsumeParameters(newDiskImage, diskExtendingDiff));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshot().getSnapshotName());
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
    addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, getParameters().getSnapshot().getSnapshotName());
    super.setActionMessageParameters();
}
#end_block

#method_before
private boolean pauseAndCreateSnapshotForGeoRepSessions() {
    if (georepSessions != null && georepSessions.size() > 0) {
        for (GlusterGeoRepSession session : georepSessions) {
            final GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
            if (slaveVolume == null) {
                // Continue to other geo-rep sessions and pause them for snapshot purpose
                continue;
            }
            VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
            if (slaveUpServer == null) {
                handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, "No up server found in slave cluster of geo-rep session");
                setSucceeded(false);
                return false;
            }
            // Pause the geo-rep session if required
            if (!(session.getStatus() == GeoRepSessionStatus.CREATED || session.getStatus() == GeoRepSessionStatus.PAUSED || session.getStatus() == GeoRepSessionStatus.STOPPED)) {
                VdcReturnValueBase sessionPauseRetVal = null;
                try (EngineLock lock = acquireEngineLock(slaveVolume.getId(), LockingGroup.GLUSTER_SNAPSHOT)) {
                    sessionPauseRetVal = runInternalAction(VdcActionType.PauseGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
                }
                if (sessionPauseRetVal != null && !sessionPauseRetVal.getSucceeded()) {
                    handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_PAUSE_FAILED, sessionPauseRetVal.getExecuteFailedMessages());
                    setSucceeded(false);
                    return false;
                }
            }
            // Create snapshot for slave volume
            VDSReturnValue snapCreationRetVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(slaveUpServer.getId(), session.getSlaveVolumeName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
            if (!snapCreationRetVal.getSucceeded()) {
                handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, snapCreationRetVal.getVdsError().getMessage());
                setSucceeded(false);
                return false;
            } else {
                // Persist the snapshot details
                GlusterVolumeSnapshotEntity slaveVolumeSnapshot = (GlusterVolumeSnapshotEntity) snapCreationRetVal.getReturnValue();
                slaveVolumeSnapshot.setClusterId(slaveVolume.getClusterId());
                slaveVolumeSnapshot.setVolumeId(slaveVolume.getId());
                slaveVolumeSnapshot.setDescription(snapshot.getDescription());
                slaveVolumeSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
                getDbFacade().getGlusterVolumeSnapshotDao().save(slaveVolumeSnapshot);
                // check if the snapshot soft limit reached now for the volume and alert
                getGlusterUtil().alertVolumeSnapshotSoftLimitReached(slaveVolume);
            }
        }
    }
    return true;
}
#method_after
private boolean pauseAndCreateSnapshotForGeoRepSessions() {
    if (georepSessions != null && georepSessions.size() > 0) {
        for (GlusterGeoRepSession session : georepSessions) {
            final GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
            if (slaveVolume == null) {
                // Continue to other geo-rep sessions and pause them for snapshot purpose
                continue;
            }
            VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
            if (slaveUpServer == null) {
                handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, "No up server found in slave cluster of geo-rep session");
                setSucceeded(false);
                return false;
            }
            // Pause the geo-rep session if required
            if (!(session.getStatus() == GeoRepSessionStatus.CREATED || session.getStatus() == GeoRepSessionStatus.PAUSED || session.getStatus() == GeoRepSessionStatus.STOPPED)) {
                VdcReturnValueBase sessionPauseRetVal = null;
                try (EngineLock lock = acquireEngineLock(slaveVolume.getId(), LockingGroup.GLUSTER_SNAPSHOT)) {
                    sessionPauseRetVal = runInternalAction(VdcActionType.PauseGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
                }
                if (sessionPauseRetVal != null && !sessionPauseRetVal.getSucceeded()) {
                    handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_PAUSE_FAILED, sessionPauseRetVal.getExecuteFailedMessages());
                    setSucceeded(false);
                    return false;
                }
                session.setStatus(GeoRepSessionStatus.PAUSED);
                enginePausedSessions.add(session);
            }
            // Create snapshot for slave volume
            VDSReturnValue snapCreationRetVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(slaveUpServer.getId(), session.getSlaveVolumeName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
            if (!snapCreationRetVal.getSucceeded()) {
                handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, snapCreationRetVal.getVdsError().getMessage());
                setSucceeded(false);
                return false;
            } else {
                // Persist the snapshot details
                GlusterVolumeSnapshotEntity slaveVolumeSnapshot = (GlusterVolumeSnapshotEntity) snapCreationRetVal.getReturnValue();
                slaveVolumeSnapshot.setClusterId(slaveVolume.getClusterId());
                slaveVolumeSnapshot.setVolumeId(slaveVolume.getId());
                slaveVolumeSnapshot.setDescription(snapshot.getDescription());
                slaveVolumeSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
                getDbFacade().getGlusterVolumeSnapshotDao().save(slaveVolumeSnapshot);
                // check if the snapshot soft limit reached now for the volume and alert
                getGlusterUtil().alertVolumeSnapshotLimitsReached(slaveVolume);
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    // Pause geo-rep sessions and create snapshot for slave volumes
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            return pauseAndCreateSnapshotForGeoRepSessions();
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Create snapshot for the master volume
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(upServer.getId(), volume.getName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
    setSucceeded(retVal.getSucceeded());
    if (!retVal.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, retVal.getVdsError().getMessage());
    } else {
        GlusterVolumeSnapshotEntity createdSnapshot = (GlusterVolumeSnapshotEntity) retVal.getReturnValue();
        createdSnapshot.setClusterId(snapshot.getClusterId());
        createdSnapshot.setVolumeId(snapshot.getVolumeId());
        createdSnapshot.setDescription(snapshot.getDescription());
        createdSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
        getDbFacade().getGlusterVolumeSnapshotDao().save(createdSnapshot);
        addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, createdSnapshot.getSnapshotName());
        // check if the snapshot soft limit reached now for the volume and alert
        getGlusterUtil().alertVolumeSnapshotSoftLimitReached(getGlusterVolume());
    }
    // Resume the snapshot sessions
    List<GlusterGeoRepSession> updatedGeoRepSessions = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (updatedGeoRepSessions != null && updatedGeoRepSessions.size() > 0) {
        for (GlusterGeoRepSession session : updatedGeoRepSessions) {
            if (session.getStatus() == GeoRepSessionStatus.PAUSED) {
                try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
                    VdcReturnValueBase sessionResumeRetVal = runInternalAction(VdcActionType.ResumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(volume.getId(), session.getId()));
                    if (!sessionResumeRetVal.getSucceeded()) {
                        handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_RESUME_FAILED, sessionResumeRetVal.getExecuteFailedMessages());
                        setSucceeded(false);
                        return;
                    }
                }
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    // Pause geo-rep sessions and create snapshot for slave volumes
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            return pauseAndCreateSnapshotForGeoRepSessions();
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Create snapshot for the master volume
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(upServer.getId(), volume.getName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
    setSucceeded(retVal.getSucceeded());
    if (!retVal.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, retVal.getVdsError().getMessage());
    } else {
        GlusterVolumeSnapshotEntity createdSnapshot = (GlusterVolumeSnapshotEntity) retVal.getReturnValue();
        createdSnapshot.setClusterId(snapshot.getClusterId());
        createdSnapshot.setVolumeId(snapshot.getVolumeId());
        createdSnapshot.setDescription(snapshot.getDescription());
        createdSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
        getDbFacade().getGlusterVolumeSnapshotDao().save(createdSnapshot);
        addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, createdSnapshot.getSnapshotName());
        // check if the snapshot soft limit reached now for the volume and alert
        getGlusterUtil().alertVolumeSnapshotLimitsReached(getGlusterVolume());
    }
    // Resume the snapshot paused sessions by engine
    for (GlusterGeoRepSession session : enginePausedSessions) {
        if (session.getStatus() == GeoRepSessionStatus.PAUSED) {
            try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
                VdcReturnValueBase sessionResumeRetVal = runInternalAction(VdcActionType.ResumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(volume.getId(), session.getId()));
                if (!sessionResumeRetVal.getSucceeded()) {
                    handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_RESUME_FAILED, sessionResumeRetVal.getExecuteFailedMessages());
                    setSucceeded(false);
                    return;
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_OPERATION_IN_PROGRESS);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK) && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RESTORE);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__RESTORE);
    super.setActionMessageParameters();
}
#end_block

#method_before
private boolean stopGeoReplicationSessions(List<GlusterGeoRepSession> geoRepSessions) {
    for (GlusterGeoRepSession session : geoRepSessions) {
        try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
            VdcReturnValueBase retVal = runInternalAction(VdcActionType.StopGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
            if (!retVal.getSucceeded()) {
                handleVdsError(AuditLogType.GEOREP_SESSION_STOP_FAILED, retVal.getExecuteFailedMessages().toString());
                setSucceeded(false);
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean stopGeoReplicationSessions(List<GlusterGeoRepSession> geoRepSessions) {
    for (GlusterGeoRepSession session : geoRepSessions) {
        if (!(session.getStatus() == GeoRepSessionStatus.STOPPED || session.getStatus() == GeoRepSessionStatus.CREATED)) {
            try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
                VdcReturnValueBase retVal = runInternalAction(VdcActionType.StopGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
                if (!retVal.getSucceeded()) {
                    handleVdsError(AuditLogType.GEOREP_SESSION_STOP_FAILED, retVal.getExecuteFailedMessages().toString());
                    setSucceeded(false);
                    return false;
                }
                session.setStatus(GeoRepSessionStatus.STOPPED);
                engineStoppedSessions.add(session);
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void executeCommand() {
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            if (georepSessions != null) {
                // Stop the geo-replication session
                if (!stopGeoReplicationSessions(georepSessions)) {
                    return false;
                }
                // Stop the slave volumes
                if (!stopSlaveVolumes(georepSessions)) {
                    return false;
                }
                // Restore the slave volumes to said the snapshot
                if (!restoreSlaveVolumesToSnapshot(georepSessions, getParameters().getSnapshotName())) {
                    return false;
                }
            }
            return true;
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Stop the master volume
    if (!stopVolume(getGlusterVolume())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_STOP_FAILED_DURING_SNAPSHOT_RESTORE, VdcBllErrors.FailedToStopMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Restore the master volume to the said snapshot
    if (!restoreVolumeToSnapshot(upServer.getId(), getGlusterVolume(), getParameters().getSnapshotName())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_SNAPSHOT_RESTORE_FAILED, VdcBllErrors.FailedToRestoreMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    List<GlusterGeoRepSession> updatedGeoRepSessions = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(getGlusterVolumeId());
    // Start the slave volumes
    if (updatedGeoRepSessions != null && !startSlaveVolumes(updatedGeoRepSessions)) {
        return;
    }
    // Start the master volume
    if (!startVolume(getGlusterVolume().getClusterId(), getGlusterVolumeId())) {
        return;
    }
    if (updatedGeoRepSessions != null) {
        // Start the geo-replication sessions
        if (!startGeoRepSessions(updatedGeoRepSessions)) {
            return;
        }
        // Resume the geo-replication sessions
        if (!resumeGeoRepSessions(updatedGeoRepSessions)) {
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
public void executeCommand() {
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            if (georepSessions != null) {
                // Stop the geo-replication session
                if (!stopGeoReplicationSessions(georepSessions)) {
                    return false;
                }
                // Stop the slave volumes
                if (!stopSlaveVolumes(georepSessions)) {
                    return false;
                }
                // Restore the slave volumes to said the snapshot
                if (!restoreSlaveVolumesToSnapshot(georepSessions, getParameters().getSnapshotName())) {
                    return false;
                }
            }
            return true;
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Stop the master volume
    if (!stopVolume(getGlusterVolume())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_STOP_FAILED_DURING_SNAPSHOT_RESTORE, VdcBllErrors.FailedToStopMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Restore the master volume to the said snapshot
    if (!restoreVolumeToSnapshot(upServer.getId(), getGlusterVolume(), getParameters().getSnapshotName())) {
        if (!georepSessions.isEmpty()) {
            handleVdsError(AuditLogType.GLUSTER_MASTER_VOLUME_SNAPSHOT_RESTORE_FAILED, VdcBllErrors.FailedToRestoreMasterVolumeDuringVolumeSnapshotRestore.name());
        }
        return;
    }
    // Start the slave volumes
    if (engineStoppedSessions != null && !startSlaveVolumes(engineStoppedSessions)) {
        return;
    }
    // Start the master volume
    if (!startVolume(getGlusterVolume().getClusterId(), getGlusterVolumeId())) {
        return;
    }
    if (engineStoppedSessions != null) {
        // Start the geo-replication sessions
        if (!startGeoRepSessions(engineStoppedSessions)) {
            return;
        }
        // Resume the geo-replication sessions
        if (!resumeGeoRepSessions(engineStoppedSessions)) {
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_OPERATION_IN_PROGRESS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveVolumeId() == null || session.getSlaveNodeUuid() == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getAsyncTask() != null && (volume.getAsyncTask().getType() == GlusterTaskType.REBALANCE || volume.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK) && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED) {
        addCanDoActionMessageVariable("asyncTask", volume.getAsyncTask().getType().name().toLowerCase());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_ASYNC_OPERATION_IN_PROGRESS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveVolumeId() == null || session.getSlaveNodeUuid() == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final List<GlusterBrickEntity> bricksList = getParameters().getBricks();
    GlusterVolumeEntity volumeBeforeBrickAdd = getGlusterVolume();
    // Add bricks in a single transaction
    if (bricksList != null && bricksList.size() > 0) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addGlusterVolumeBricks(bricksList, getParameters().getReplicaCount(), getParameters().getStripeCount(), getParameters().isForce());
                return null;
            }
        });
    }
    freeLock();
    if (getGlusterVolume().getIsGeoRepMaster() || getGlusterVolume().getIsGeoRepSlave()) {
        postAddBrickHandleGeoRepCase(bricksList, volumeBeforeBrickAdd);
    }
}
#method_after
@Override
protected void executeCommand() {
    final List<GlusterBrickEntity> bricksList = getParameters().getBricks();
    GlusterVolumeEntity volumeBeforeBrickAdd = getGlusterVolume();
    // Add bricks in a single transaction
    if (bricksList != null && bricksList.size() > 0) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addGlusterVolumeBricks(bricksList, getParameters().getReplicaCount(), getParameters().getStripeCount(), getParameters().isForce());
                return null;
            }
        });
    }
    if (getGlusterVolume().getIsGeoRepMaster() || getGlusterVolume().getIsGeoRepSlave()) {
        Set<Guid> newServerIds = findNewServers(bricksList, volumeBeforeBrickAdd);
        if (!newServerIds.isEmpty()) {
            postAddBrickHandleGeoRepCase(bricksList, newServerIds);
        }
    }
}
#end_block

#method_before
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final GlusterVolumeEntity volumeBeforeBrickAdd) {
    final GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get all sessions for which the volume is a slave
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionsForSlaveVolume(volume.getId());
    if (geoRepSessionsForVolumeAsSlave != null && !geoRepSessionsForVolumeAsSlave.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsSlave);
    }
    if (sessions.isEmpty()) {
        return;
    }
    final CreateGlusterVolumeGeoRepSessionCommand command = new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters());
    List<Callable<Boolean>> onNewNodeSessionCallables = new ArrayList<Callable<Boolean>>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        onNewNodeSessionCallables.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                Set<Guid> newServerIds = new HashSet<>();
                boolean succeeded = true;
                if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                    // set newServerIds to set of all slave nodes
                    newServerIds = getSlaveNodesSet(currentSession);
                } else {
                    // if its a slave volume of current session, newServerIds is just set of new server ids
                    newServerIds = findNewServers(bricksList, volumeBeforeBrickAdd);
                    if (newServerIds.isEmpty()) {
                        return true;
                    }
                    // if its slave and non-root session, do partial mount broker setup as we
                    if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                        succeeded = evaluateReturnValues(AuditLogType.GLUSTER_GEOREP_SETUP_MOUNT_BROKER_FAILED, command.setUpPartialMountBrokerOnSlaves(newServerIds));
                    }
                }
                if (succeeded) {
                    succeeded = command.setUpPasswordlessSSH(getClusterUtils().getRandomUpServer(getGlusterVolumeDao().getById(currentSession.getMasterVolumeId()).getClusterId()).getId(), newServerIds, currentSession.getUserName());
                }
                if (succeeded) {
                    command.createGeoRepSession(getClusterUtils().getRandomUpServer(volume.getClusterId()).getId(), volume.getName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true, false);
                }
                evaluateReturnValues(AuditLogType.GLUSTER_VOLUME_GEO_REP_START_FAILED_EXCEPTION, Collections.singletonList(runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true))));
                return succeeded;
            }
        });
    }
    ThreadPoolUtil.invokeAll(onNewNodeSessionCallables);
}
#method_after
private void postAddBrickHandleGeoRepCase(final List<GlusterBrickEntity> bricksList, final Set<Guid> newServerIds) {
    // newServerIds is the set of ids of the servers that were not part of the volume before this attempt of brick
    // addition.
    final GlusterVolumeEntity volume = getGlusterVolume();
    List<GlusterGeoRepSession> sessions = new ArrayList<>();
    // Get all sessions for which the volume is a master
    List<GlusterGeoRepSession> geoRepSessionsForVolumeAsMaster = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (geoRepSessionsForVolumeAsMaster != null && !geoRepSessionsForVolumeAsMaster.isEmpty()) {
        sessions.addAll(geoRepSessionsForVolumeAsMaster);
    }
    // Get session for which the volume is a slave
    GlusterGeoRepSession geoRepSessionForVolumeAsSlave = getDbFacade().getGlusterGeoRepDao().getGeoRepSessionBySlaveVolume(volume.getId());
    if (geoRepSessionForVolumeAsSlave != null) {
        sessions.add(geoRepSessionForVolumeAsSlave);
    }
    // If this volume is empty, nothing to do.
    if (sessions.isEmpty()) {
        return;
    }
    List<Callable<Boolean>> perSessionCallables = new ArrayList<Callable<Boolean>>();
    for (final GlusterGeoRepSession currentSession : sessions) {
        perSessionCallables.add(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                // Ids of servers on which steps like mount broker setup and/or passwordless ssh need to be done.
                Set<Guid> serverIdsToPrep = new HashSet<Guid>(newServerIds);
                // Assume current volume as master volume of current session
                GlusterVolumeEntity masterVolume = volume;
                boolean succeeded = true;
                addCustomValue(GlusterConstants.VOLUME_NAME, currentSession.getMasterVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, currentSession.getSlaveVolumeName());
                addCustomValue(GlusterConstants.GEO_REP_USER, currentSession.getUserName());
                if (currentSession.getMasterVolumeId().equals(volume.getId())) {
                    /*
                         * If the volume is master, and there are any new servers, serverIdsToPrep is a set of all slave
                         * servers. This is bcoz the new server's keys also need to be updated to all slave servers.
                         */
                    serverIdsToPrep = getSlaveNodesSet(currentSession);
                } else {
                    // If its slave and non-root session, do partial mount broker setup
                    if (!currentSession.getUserName().equalsIgnoreCase("root")) {
                        succeeded = evaluateReturnValue(errorType, getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(volume.getClusterId(), serverIdsToPrep, volume.getName(), currentSession.getUserName())));
                        if (succeeded) {
                            auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                        }
                    }
                    /*
                         * If the assumption that current volume is master, is invalid, which will be known here, update
                         * master volume correctly.
                         */
                    masterVolume = getGlusterVolumeDao().getById(currentSession.getMasterVolumeId());
                }
                if (succeeded) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(masterVolume.getClusterId(), serverIdsToPrep, currentSession.getUserName())));
                }
                if (succeeded) {
                    auditLogDirector.log(AddBricksToGlusterVolumeCommand.this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
                    succeeded = evaluateReturnValue(errorType, runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(getClusterUtils().getRandomUpServer(masterVolume.getClusterId()).getId(), currentSession.getMasterVolumeName(), currentSession.getSlaveHostName(), currentSession.getSlaveVolumeName(), currentSession.getUserName(), true)));
                }
                if (currentSession.getStatus() == GeoRepSessionStatus.ACTIVE || currentSession.getStatus() == GeoRepSessionStatus.INITIALIZING) {
                    succeeded = evaluateReturnValue(errorType, runInternalAction(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(currentSession.getMasterVolumeId(), currentSession.getId(), true)));
                }
                return succeeded;
            }
        });
    }
    ThreadPoolUtil.invokeAll(perSessionCallables);
}
#end_block

#method_before
private Set<Guid> findNewServers(final List<GlusterBrickEntity> bricksList, GlusterVolumeEntity volumeBeforeBrickAdd) {
    final Set<Guid> newServerIds = new HashSet<Guid>();
    for (GlusterBrickEntity currentBrick : bricksList) {
        if (isNewServer(currentBrick.getServerName(), volumeBeforeBrickAdd)) {
            newServerIds.add(currentBrick.getServerId());
        }
    }
    return newServerIds;
}
#method_after
private Set<Guid> findNewServers(final List<GlusterBrickEntity> bricksList, GlusterVolumeEntity volumeBeforeBrickAdd) {
    final Set<Guid> newServerIds = new HashSet<Guid>();
    for (GlusterBrickEntity currentBrick : bricksList) {
        if (isNewServer(currentBrick.getServerId(), volumeBeforeBrickAdd)) {
            newServerIds.add(currentBrick.getServerId());
        }
    }
    return newServerIds;
}
#end_block

#method_before
private boolean isNewServer(String serverName, GlusterVolumeEntity volumeBeforeBrickAdd) {
    List<GlusterBrickEntity> bricks = volumeBeforeBrickAdd.getBricks();
    for (GlusterBrickEntity currentBrick : bricks) {
        if (currentBrick.getServerName().equals(serverName)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isNewServer(Guid serverId, GlusterVolumeEntity volumeBeforeBrickAdd) {
    List<GlusterBrickEntity> bricks = volumeBeforeBrickAdd.getBricks();
    for (GlusterBrickEntity currentBrick : bricks) {
        if (currentBrick.getServerId().equals(serverId)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Map<String, String> getCustomValues() {
    addCustomValue(GlusterConstants.VOLUME_NAME, getGlusterVolumeName());
    addCustomValue(GlusterConstants.GEO_REP_USER, getParameters().getUserName());
    addCustomValue(GlusterConstants.GEO_REP_USER_GROUP, getParameters().getUserGroup());
    addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, getParameters().getSlaveVolumeName());
    addCustomValue(GlusterConstants.SERVICE_TYPE, ServiceType.GLUSTER.name());
    return super.getCustomValues();
}
#method_after
@Override
public Map<String, String> getCustomValues() {
    addCustomValue(GlusterConstants.VOLUME_NAME, getGlusterVolumeName());
    addCustomValue(GlusterConstants.GEO_REP_USER, getParameters().getUserName());
    addCustomValue(GlusterConstants.GEO_REP_SLAVE_VOLUME_NAME, getParameters().getSlaveVolumeName());
    addCustomValue(GlusterConstants.SERVICE_TYPE, ServiceType.GLUSTER.name());
    return super.getCustomValues();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean rootSession = getParameters().getUserName().equalsIgnoreCase("root");
    boolean succeeded = true;
    Set<Guid> remoteServerIds = getServerIds(remoteServersSet);
    Guid slaveHostId = getParameters().getSlaveHostId();
    if (!rootSession) {
        VdcReturnValueBase mountBrokerOnSlaveReturnValue = setUpMountBrokerOnSlave();
        succeeded = evaluateReturnValues(AuditLogType.GLUSTER_GEOREP_SETUP_MOUNT_BROKER_FAILED, Collections.singletonList(mountBrokerOnSlaveReturnValue));
        remoteServerIds.remove(slaveHostId);
        if (succeeded && !remoteServerIds.isEmpty()) {
            succeeded = evaluateReturnValues(AuditLogType.GLUSTER_GEOREP_SETUP_MOUNT_BROKER_FAILED, setUpPartialMountBrokerOnSlaves(remoteServerIds));
        }
    }
    if (succeeded) {
        remoteServerIds.add(slaveHostId);
        succeeded = setUpPasswordlessSSH(upServer.getId(), remoteServerIds, getParameters().getUserName());
        if (succeeded) {
            succeeded = createGeoRepSession(upServer.getId(), getGlusterVolumeName(), getVdsDAO().get(slaveHostId).getHostName(), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().isForce(), true);
            if (succeeded) {
                GlusterGeoRepSyncJob.getInstance().refreshGeoRepDataForVolume(getGlusterVolume());
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean rootSession = getParameters().getUserName().equalsIgnoreCase("root");
    boolean succeeded = true;
    Set<Guid> remoteServerIds = getServerIds(remoteServersSet);
    Guid slaveHostId = getParameters().getSlaveHostId();
    if (!rootSession) {
        VdcReturnValueBase completeMountBrokerSetupOnSlaveInternalAction = getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(getVdsDAO().get(slaveHostId).getVdsGroupId(), new HashSet<Guid>(Collections.singletonList(getParameters().getSlaveHostId())), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().getUserGroup()));
        succeeded = evaluateReturnValue(AuditLogType.GLUSTER_GEOREP_SETUP_MOUNT_BROKER_FAILED, completeMountBrokerSetupOnSlaveInternalAction);
        remoteServerIds.remove(slaveHostId);
        if (succeeded) {
            auditLogDirector.log(this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
            if (!remoteServerIds.isEmpty()) {
                VdcReturnValueBase mountBrokerPartialSetupInternalAction = getBackend().runInternalAction(VdcActionType.SetupGlusterGeoRepMountBrokerInternal, new SetUpMountBrokerParameters(getVdsDAO().get(slaveHostId).getVdsGroupId(), remoteServerIds, getParameters().getSlaveVolumeName(), getParameters().getUserName()));
                succeeded = evaluateReturnValue(AuditLogType.GLUSTER_GEOREP_SETUP_MOUNT_BROKER_FAILED, mountBrokerPartialSetupInternalAction);
                if (succeeded) {
                    auditLogDirector.log(this, AuditLogType.GLUSTER_SETUP_GEOREP_MOUNT_BROKER);
                }
            }
        }
    }
    if (succeeded) {
        remoteServerIds.add(slaveHostId);
        VdcReturnValueBase setUpPasswordLessSSHinternalAction = runInternalAction(VdcActionType.SetUpPasswordLessSSHInternal, new SetUpPasswordLessSSHParameters(upServer.getVdsGroupId(), remoteServerIds, getParameters().getUserName()));
        succeeded = evaluateReturnValue(errorType, setUpPasswordLessSSHinternalAction);
        if (succeeded) {
            auditLogDirector.log(this, AuditLogType.SET_UP_PASSWORDLESS_SSH);
            VDSReturnValue createVdsReturnValue = runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGlusterVolumeName(), getVdsDAO().get(slaveHostId).getHostName(), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().isForce()));
            succeeded = evaluateReturnValue(AuditLogType.GLUSTER_GEOREP_SESSION_CREATE_FAILED, createVdsReturnValue);
            if (succeeded) {
                GlusterGeoRepSyncJob.getInstance().refreshGeoRepDataForVolume(getGlusterVolume());
            }
        }
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
@Override
public void clearAllAlerts() {
    getCallsHandler().executeModification("ClearAllAuditLogAlerts", getCustomMapSqlParameterSource().addValue("severity", AuditLogSeverity.ALERT));
}
#method_after
@Override
public void clearAllAlerts() {
    getCallsHandler().executeModification("SetAllAuditLogAlerts", getCustomMapSqlParameterSource().addValue("severity", AuditLogSeverity.ALERT).addValue("value", true));
}
#end_block

#method_before
@Override
public void displayAllAlerts() {
    getCallsHandler().executeModification("DisplayAllAuditLogAlerts", getCustomMapSqlParameterSource().addValue("severity", AuditLogSeverity.ALERT));
}
#method_after
@Override
public void displayAllAlerts() {
    getCallsHandler().executeModification("SetAllAuditLogAlerts", getCustomMapSqlParameterSource().addValue("severity", AuditLogSeverity.ALERT).addValue("value", false));
}
#end_block

#method_before
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#method_after
private void setNonOperational(VDS server) {
    SetNonOperationalVdsParameters nonOpParams = new SetNonOperationalVdsParameters(server.getId(), NonOperationalReason.GLUSTER_COMMAND_FAILED, Collections.singletonMap(GlusterConstants.COMMAND, "gluster peer status"));
    backend.runInternalAction(VdcActionType.SetNonOperationalVds, nonOpParams, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    VDSGroup cluster = getClusterDao().get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
            // If meta volume then set the CLI based snapshot scheduling flag accordingly
            if (getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), clusterId) && cluster.isGlusterCliBasedSchedulingOn() && (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)).equalsIgnoreCase(volume.getName())) {
                VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
                if (!returnValue.getSucceeded()) {
                    log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
                } else {
                    logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
                }
            }
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
private void updateExistingAndNewVolumes(Guid clusterId, Map<Guid, GlusterVolumeEntity> volumesMap) {
    VDSGroup cluster = getClusterDao().get(clusterId);
    for (Entry<Guid, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debug("Analyzing volume '{}'", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getById(entry.getKey());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.error("Could not save volume {} in database: {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
            // If meta volume then set the CLI based snapshot scheduling flag accordingly
            if (getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), clusterId) && cluster.isGlusterCliBasedSchedulingOn() && (Config.<String>getValue(ConfigValues.GlusterMetaVolumeName)).equalsIgnoreCase(volume.getName())) {
                VdcReturnValueBase returnValue = backend.runInternalAction(VdcActionType.DisableGlusterCliSnapshotScheduleInternal, new GlusterVolumeActionParameters(volume.getId(), false), ExecutionHandler.createInternalJobContext());
                if (!returnValue.getSucceeded()) {
                    log.warn("Unbale to set volume snapshot scheduling flag to gluster CLI scheduler on cluster {}", cluster.getName());
                } else {
                    logUtil.logVolumeMessage(volume, AuditLogType.GLUSTER_CLI_SNAPSHOT_SCHEDULE_DISABLED);
                }
            }
        } else {
            try {
                log.debug("Volume '{}' exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.error("Error while updating volume '{}': {}", volume.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(Guid.class), any(String.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(mockVdcReturn()).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class));
    doReturn(backend).when(glusterManager).getBackend();
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#method_after
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(Guid.class), any(String.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(mockVdcReturn()).when(backend).runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#end_block

#method_before
public ImageStatus getImageStatusByClassificationType(CinderDisk cinderDisk) {
    VolumeClassification cinderVolumeType = cinderDisk.getVolumeClassification();
    if (cinderVolumeType == VolumeClassification.Volume) {
        return getDiskStatus(cinderDisk.getImageId());
    } else if (cinderVolumeType == VolumeClassification.Snapshot) {
        return getSnapshotStatus(cinderDisk.getImageId());
    } else {
        log.error("Error, could not determine Cinder entity {} with id {} from Cinder provider.", cinderDisk.getDiskAlias(), cinderDisk.getImageId());
    }
    return ImageStatus.ILLEGAL;
}
#method_after
public ImageStatus getImageStatusByClassificationType(CinderDisk cinderDisk) {
    VolumeClassification cinderVolumeType = cinderDisk.getVolumeClassification();
    if (cinderVolumeType == VolumeClassification.Volume) {
        return getDiskStatus(cinderDisk.getImageId());
    } else if (cinderVolumeType == VolumeClassification.Snapshot) {
        return getSnapshotStatus(cinderDisk.getImageId());
    }
    log.error("Error, could not determine Cinder entity {} with id {} from Cinder provider.", cinderDisk.getDiskAlias(), cinderDisk.getImageId());
    return ImageStatus.ILLEGAL;
}
#end_block

#method_before
private void deleteVolumeFromCinder(CinderDisk lastCinderVolume) {
    try {
        getCinderBroker().deleteVolumeByClassificationType(lastCinderVolume);
    } catch (Exception e) {
        if (!getParameters().isFaultTolerant()) {
            throw e;
        } else {
            log.error("Failed to remove volume from Cinder provider. continue to delete the disk from the DB since the fault tollerant flag is true.");
        }
    }
}
#method_after
private void deleteVolumeFromCinder(CinderDisk lastCinderVolume) {
    try {
        getCinderBroker().deleteVolumeByClassificationType(lastCinderVolume);
    } catch (Exception e) {
        if (!getParameters().isFaultTolerant()) {
            throw e;
        } else {
            log.error("Failed to remove volume from Cinder provider. continue to delete the disk.");
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initConnectionList(true);
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
        disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
    }
    if (FeatureSupported.cinderProviderSupported(getStoragePool().getCompatibilityVersion())) {
        // Unregister all libvirt secrets if needed
        unregisterLibvirtSecrets();
    }
}
#method_after
@Override
protected void executeCommand() {
    initConnectionList(true);
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
        disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
    }
    unregisterLibvirtSecrets();
}
#end_block

#method_before
public static void main(String... args) throws IOException {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        Properties props = new Properties();
        try (InputStream in = Main.class.getResourceAsStream("arguments.properties");
            Reader reader = new InputStreamReader(in)) {
            props.load(reader);
        }
        ArgumentsParser parser = new ArgumentsParser(props, "core");
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        if ((Boolean) argMap.get("help")) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                System.err.format("FATAL: %s%n", t.getMessage());
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            System.err.println("Action not provided");
            throw new ExitException("Action not provided", 1);
        }
        Action action = Action.valueOf(cmdArgs.get(0).toUpperCase().replace("-", "_"));
        if (action == null) {
            System.err.println("Invalid action");
            throw new ExitException("Invalid action", 1);
        }
        action.execute(props, cmdArgs);
        exitStatus = 0;
    } catch (ExitException e) {
        exitStatus = e.getExitCode();
    } catch (Exception e) {
        System.err.format("FATAL: %s%n", e.getMessage());
        e.printStackTrace(System.err);
    }
    System.exit(exitStatus);
}
#method_after
public static void main(String... args) throws IOException {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        Properties props = new Properties();
        try (InputStream in = Main.class.getResourceAsStream("arguments.properties");
            Reader reader = new InputStreamReader(in)) {
            props.load(reader);
        }
        ArgumentsParser parser = new ArgumentsParser(props, "core");
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        if ((Boolean) argMap.get("help")) {
            System.out.format("Usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                System.err.format("FATAL: %s%n", t.getMessage());
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            System.err.println("Action not provided");
            throw new ExitException("Action not provided", 1);
        }
        Action action;
        try {
            action = Action.valueOf(cmdArgs.get(0).toUpperCase().replace("-", "_"));
        } catch (IllegalArgumentException e) {
            System.err.printf("Invalid action '%s'%n", cmdArgs.get(0));
            throw new ExitException("Invalid action", 1);
        }
        action.execute(props, cmdArgs);
        exitStatus = 0;
    } catch (ExitException e) {
        exitStatus = e.getExitCode();
    } catch (Exception e) {
        System.err.format("FATAL: %s%n", e.getMessage());
        e.printStackTrace(System.err);
    }
    System.exit(exitStatus);
}
#end_block

#method_before
public Map list() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        Map vmMap = map();
        // Up
        vmMap.put("status", vm.getStatus().toString());
        // 4c36aca1-577f-4533-987d-a8288faab149
        vmMap.put("vmId", vm.getId());
        statusList.add(vmMap);
    }
    resultMap.put("vmList", statusList);
    return resultMap;
}
#method_after
public Map list() {
    final Host host = getActiveHost();
    final Map resultMap = getDoneStatus();
    final List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        Map vmMap = map();
        // Up
        vmMap.put("status", vm.getStatus().toString());
        // 4c36aca1-577f-4533-987d-a8288faab149
        vmMap.put("vmId", vm.getId());
        statusList.add(vmMap);
    }
    resultMap.put("vmList", statusList);
    return resultMap;
}
#end_block

#method_before
public Map migrate(Map request) {
    // String method = (String) request.get("method"); // online
    // 10.34.63.178:54321
    String dst = (String) request.get("dst");
    // String src = (String)request.get("src"); // 10.34.63.177
    // 79567083-9889-4bcc-90e3-291885b0da7f
    String vmId = (String) request.get("vmId");
    boolean success = true;
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    // bind clone of VM to the target host
    VM targetVM = vm.clone();
    vm.setStatus(VM.VMStatus.MigratingFrom);
    targetVM.setStatus(VM.VMStatus.MigratingTo);
    String targetServerName = dst;
    // get target server
    int idx = dst.indexOf(':');
    if (idx != -1) {
        targetServerName = dst.substring(0, idx);
    }
    final Host targetHost = getHostByName(targetServerName);
    if (targetHost == null) {
        log.info("Target host not found: " + dst);
        throw new RuntimeException("Target host not found: " + dst + ", name: " + targetServerName);
    }
    targetVM.setHost(targetHost);
    targetHost.getRunningVMs().put(targetVM.getId(), targetVM);
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM, 10000l, vm));
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_TO_VM, 10000l, targetVM));
    // plan next status task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM_REMOVE_FROM_HOST, 20000l, vm));
    log.info("Migrating VM {} from host: {} to: {}", new Object[] { vm.getId(), vm.getHost().getName(), targetHost.getName() });
    return success ? ResultCodes.MIGRATION_STARTING.map() : ResultCodes.VM_NOT_FOUND.map();
}
#method_after
public Map migrate(Map request) {
    // String method = (String) request.get("method"); // online
    // 10.34.63.178:54321
    String dst = (String) request.get("dst");
    // String src = (String)request.get("src"); // 10.34.63.177
    // 79567083-9889-4bcc-90e3-291885b0da7f
    String vmId = (String) request.get("vmId");
    boolean success = true;
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    // bind clone of VM to the target host
    VM targetVM = vm.clone();
    vm.setStatus(VM.VMStatus.MigratingFrom);
    targetVM.setStatus(VM.VMStatus.MigratingTo);
    String targetServerName = dst;
    // get target server
    int idx = dst.indexOf(':');
    if (idx != -1) {
        targetServerName = dst.substring(0, idx);
    }
    final Host targetHost = getHostByName(targetServerName);
    if (targetHost == null) {
        log.info("Target host not found: " + dst);
        throw new RuntimeException("Target host not found: " + dst + ", name: " + targetServerName);
    }
    targetVM.setHost(targetHost);
    targetHost.getRunningVMs().put(targetVM.getId(), targetVM);
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM, 10000l, vm));
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_TO_VM, 10000l, targetVM));
    // plan next status task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM_REMOVE_FROM_HOST, 20000l, vm));
    Map<String, Object> resultMap = map();
    Map statusMap = map();
    statusMap.put("message", success ? "Migration process starting" : "VM not found");
    statusMap.put("code", (success ? "0" : "100"));
    resultMap.put("status", statusMap);
    log.info("Migrating VM {} from host: {} to: {}", new Object[] { vm.getId(), vm.getHost().getName(), targetHost.getName() });
    return resultMap;
}
#end_block

#method_before
public Map getVmStats(String uuid) {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    List statusList = new ArrayList();
    VM vm = host.getRunningVMs().get(uuid);
    if (vm != null) {
        Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
        vmStatMap.put("status", vm.getStatus().toString());
        vmStatMap.put("network", getNetworkStatsMap(vm));
        vmStatMap.put("vmId", vm.getId());
        vmStatMap.put("displayType", vm.getDisplayType());
        vmStatMap.put("disks", getVMDisksMap(vm));
        vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
        statusList.add(vmStatMap);
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#method_after
public Map getVmStats(String uuid) {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    List statusList = new ArrayList();
    VM vm = host.getRunningVMs().get(uuid);
    if (vm != null) {
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    Utils.getLatency();
    return resultMap;
}
#end_block

#method_before
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        Map netStats = map();
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        // 00:1a:4a:16:01:51
        netStats.put("macAddr", device.getMacAddr());
        netStats.put("name", "vnet0");
        netStats.put("txDropped", "0");
        netStats.put("txRate", "0.0");
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "0.0");
        netStats.put("rxDropped", "0");
        resultMap.put("vnet" + Integer.valueOf(count), netStats);
        ++count;
    }
    return resultMap;
}
#method_after
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        log.debug("no mac address for vm {}", vm.getId());
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        Map netStats = map();
        String dName = "vnet" + Integer.valueOf(count);
        // TODO: change hardcoded fileds.
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        // 00:1a:4a:16:01:51
        netStats.put("macAddr", vm.getMacAddress());
        netStats.put("name", dName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", "7.0");
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "7.0");
        netStats.put("rxDropped", "0");
        netStats.put("speed", "999");
        resultMap.put(dName, netStats);
        ++count;
    }
    return resultMap;
}
#end_block

#method_before
private Map fillVmStatsMap(VM vm) {
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    vmStatMap.put("vmId", vm.getId());
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    return vmStatMap;
}
#method_after
private Map fillVmStatsMap(VM vm) {
    AppConfig appConfig = AppConfig.getInstance();
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    // ip validation if no exist set ip, for vms which already registered in the setup
    if (vm.getIp() == null || vm.getIp().equals("0.0.0.0") || vm.getIp().isEmpty() || vm.getIp().equals("?")) {
        vm.setIp(Utils.ipGenerator());
    }
    // missing data
    Map dis = map();
    ArrayList display = new ArrayList();
    dis.put("tlsPort", "5900");
    dis.put("ipAddress", vm.getIp());
    dis.put("type", "spice");
    dis.put("port", "-1");
    display.add(dis);
    vmStatMap.put("displayInfo", display);
    vmStatMap.put("pid", "1111");
    vmStatMap.put("session", "Unknown");
    vmStatMap.put("timeOffset", "0");
    vmStatMap.put("pauseCode", "NOERR");
    Map ballon = map();
    // TODO: compute 10% from the actual mem for ballooning.
    ballon.put("balloon_max", "2048");
    ballon.put("balloon_min", "1024");
    ballon.put("balloon_target", "2048");
    ballon.put("balloon_cur", "512");
    vmStatMap.put("balloonInfo", ballon);
    vmStatMap.put("guestIPs", vm.getIp());
    vmStatMap.put("guestName", "localhost.localdomain");
    vmStatMap.put("guestFQDN", "localhost.localdomain");
    vmStatMap.put("guestOs", " 2.6.32-504.1.3.el6.x86_64");
    vmStatMap.put("guestCPUCount", "-1");
    // cpu
    vmStatMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    // memory
    vmStatMap.put("memUsage", Utils.rangeParsser(appConfig.getMemLoadValues()));
    // network
    vmStatMap.put("netIfaces", getNetworkInterfaces(vm));
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    vmStatMap.put("vcpuCount", "1");
    vmStatMap.put("clientIp", "");
    vmStatMap.put("hash", Integer.toString(vm.hashCode()));
    vmStatMap.put("vmType", "kvm");
    vmStatMap.put("vmId", vm.getId());
    vmStatMap.put("displayIp", vm.getIp());
    vmStatMap.put("vcpuPeriod", 100000);
    vmStatMap.put("displayPort", "-1");
    vmStatMap.put("vcpuQuota", "-1");
    vmStatMap.put("kvmEnable", "true");
    vmStatMap.put("monitorResponse", "0");
    vmStatMap.put("statsAge", "2.46");
    vmStatMap.put("username", "None");
    vmStatMap.put("lastLogin", 1426169218.410367);
    ArrayList emptylist = new ArrayList();
    vmStatMap.put("ioTune", emptylist);
    vmStatMap.put("displaySecurePort", "5900");
    vmStatMap.put("vmJobs", map());
    Map memstats = map();
    if (!vmStatMap.get("memUsage").toString().isEmpty()) {
        memstats.put("swap_out", "0");
        memstats.put("majflt", "0");
        memstats.put("swap_usage", "0");
        memstats.put("swap_total", "0");
        memstats.put("swap_in", "0");
        memstats.put("mem_free", Integer.toString(vm.getMemSize() - Integer.valueOf(vmStatMap.get("memUsage").toString())));
        memstats.put("pageflt", "131");
        memstats.put("mem_total", Integer.toString(vm.getMemSize()));
        memstats.put("mem_unused", memstats.get("mem_free"));
        vmStatMap.put("memoryStats", memstats);
    }
    // adding app list
    ArrayList applist = new ArrayList();
    applist.add("kernel-2.6.32-431.el6");
    applist.add("rhevm-guest-agent-common-1.0.9-1.el6ev");
    vmStatMap.put("appsList", applist);
    vmStatMap.put("displayType", "qxl");
    return vmStatMap;
}
#end_block

#method_before
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#method_after
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        VdsmManager vdsmManager = VdsmManager.getInstance();
        if (!vdsmManager.allRunningVms.contains(vm.getId())) {
            vdsmManager.allRunningVms.add(vm.getId());
        }
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#end_block

#method_before
public Map destroy(String vmId) {
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    vm.setStatus(VM.VMStatus.PoweringDown);
    // add async task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.SHUTDOWN_VM, 5000l, vm));
    return ResultCodes.MACHINE_DESTROYED.map();
}
#method_after
public Map destroy(String vmId) {
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    vm.setStatus(VM.VMStatus.PoweringDown);
    Map resultMap = map();
    // add async task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.SHUTDOWN_VM, 5000l, vm));
    Map statusMap = map();
    statusMap.put("message", "Machine destroyed");
    statusMap.put("code", "0");
    resultMap.put("status", statusMap);
    return resultMap;
}
#end_block

#method_before
public Map shutdown(String vmId, String timeout, String message) {
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm != null) {
        vm.setStatus(VM.VMStatus.PoweringDown);
    }
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.SHUTDOWN_VM, 5000l, vm));
    return ResultCodes.MACHINE_SHUTDOWN.map();
}
#method_after
public Map shutdown(String vmId, String timeout, String message) {
    final Map resultMap = getStatusMap("Machine shut down", 0);
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm != null) {
        vm.setStatus(VM.VMStatus.PoweringDown);
    }
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.SHUTDOWN_VM, 5000l, vm));
    return resultMap;
}
#end_block

#method_before
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        // add asynch tasks
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM, 2000l, vm));
        // plan next status task
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM_AS_UP, 10000l, vm));
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.info("VM {} created on host {}", vmId, host.getName());
        return resultMap;
    } catch (Exception e) {
        log.error(ERROR, e);
        throw new RuntimeException(ERROR, e);
    }
}
#method_after
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        vm.setIp(Utils.ipGenerator());
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        // add asynch tasks
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM, 2000l, vm));
        // plan next status task
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM_AS_UP, 10000l, vm));
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.debug("VM {} created on host {}", vmId, host.getName());
        return resultMap;
    } catch (Exception e) {
        log.error(ERROR, e);
        throw new RuntimeException(ERROR, e);
    }
}
#end_block

#method_before
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("packages2", getPackages2Map());
        infoMap.put("cpuModel", "Intel(R) Xeon(R) CPU E5606 @ 2.13GHz");
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("cpuFlags", "fpu,vme,de,pse,tsc,msr,pae,mce,cx8,apic,sep,mtrr,pge,mca,cmov,pat,pse36,clflush,dts,acpi,mmx,fxsr,sse,sse2,ss,ht,tm,pbe,syscall,nx,pdpe1gb,rdtscp,lm,constant_tsc,arch_perfmon,pebs,bts,rep_good,nopl,xtopology,nonstop_tsc,aperfmperf,pni,pclmulqdq,dtes64,monitor,ds_cpl,vmx,smx,est,tm2,ssse3,cx16,xtpr,pdcm,pcid,dca,sse4_1,sse4_2,popcnt,aes,lahf_lm,arat,dtherm,tpr_shadow,vnmi,flexpriority,ept,vpid,model_Nehalem,model_Conroe,model_coreduo,model_core2duo,model_Penryn,model_Westmere,model_n270");
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", "7976");
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getVdsCapabilities() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("HBAInventory", getHBAInventoryMap());
        infoMap.put("packages2", getPackages2Map());
        infoMap.put("cpuModel", "Intel(R) Xeon(R) CPU E5606 @ 2.13GHz");
        infoMap.put("hooks", map());
        infoMap.put("cpuSockets", "1");
        infoMap.put("vmTypes", getVmTypesList());
        infoMap.put("supportedProtocols", getSupportedProtocolsList());
        infoMap.put("networks", getNetworksMap(host));
        infoMap.put("bridges", getBridgesMap(host));
        // 018CE76D-8EFE-D511-B30D-80C16E727330_80:c1:6e:6c:51:54
        infoMap.put("uuid", host.getUuid() + "_80:" + host.getMacAddress());
        infoMap.put("lastClientIface", AppConfig.getInstance().getNetworkBridgeName());
        infoMap.put("nics", getNicsMap(host));
        infoMap.put("software_revision", "0.141");
        infoMap.put("clusterLevels", getClusterLevelsList());
        infoMap.put("cpuFlags", "fpu,vme,de,pse,tsc,msr,pae,mce,cx8,apic,sep,mtrr,pge,mca,cmov,pat,pse36,clflush,dts,acpi,mmx,fxsr,sse,sse2,ss,ht,tm,pbe,syscall,nx,pdpe1gb,rdtscp,lm,constant_tsc,arch_perfmon,pebs,bts,rep_good,nopl,xtopology,nonstop_tsc,aperfmperf,pni,pclmulqdq,dtes64,monitor,ds_cpl,vmx,smx,est,tm2,ssse3,cx16,xtpr,pdcm,pcid,dca,sse4_1,sse4_2,popcnt,aes,lahf_lm,arat,dtherm,tpr_shadow,vnmi,flexpriority,ept,vpid,model_Nehalem,model_Conroe,model_coreduo,model_core2duo,model_Penryn,model_Westmere,model_n270");
        infoMap.put("ISCSIInitiatorName", "iqn.1994-05.com.example:ef52ec17bb0");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("supportedENGINEs", getSupportedENGINEsList());
        infoMap.put("reservedMem", "321");
        infoMap.put("bondings", getBondingsMap());
        infoMap.put("software_version", "4.10");
        infoMap.put("memSize", "7976");
        infoMap.put("cpuSpeed", "1200.000");
        infoMap.put("version_name", "Snow Man");
        infoMap.put("vlans", map());
        infoMap.put("cpuCores", "4");
        infoMap.put("kvmEnabled", "true");
        infoMap.put("guestOverhead", "65");
        // null
        infoMap.put("management_ip", "");
        infoMap.put("cpuThreads", "4");
        infoMap.put("emulatedMachines", getEmulatedMachinesList());
        infoMap.put("operatingSystem", getOperatingSystemMap());
        infoMap.put("lastClient", "10.36.6.76");
        infoMap.put("rngSources", Arrays.asList(new String[] { "RANDOM" }));
        infoMap.put("selinux", getSELinux());
        infoMap.put("kdumpStatus", "1");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
Map getNetworksMap(Host host) {
    Map resultMap = map();
    Map ovirtmgmtMap = map();
    resultMap.put(getNetworkBridgeName(), ovirtmgmtMap);
    ovirtmgmtMap.put("iface", getNetworkBridgeName());
    // 10.34.63.177
    ovirtmgmtMap.put("addr", host.getIpAddress());
    Map cfgMap = map();
    cfgMap.put("DEVICE", getNetworkBridgeName());
    cfgMap.put("DELAY", "0");
    cfgMap.put("BOOTPROTO", "dhcp");
    cfgMap.put("TYPE", "Ethernet");
    cfgMap.put("ONBOOT", "yes");
    ovirtmgmtMap.put("cfg", cfgMap);
    ovirtmgmtMap.put("mtu", "1500");
    ovirtmgmtMap.put("netmask", "255.255.252.0");
    ovirtmgmtMap.put("stp", "off");
    // boolean..1
    ovirtmgmtMap.put("bridged", Boolean.TRUE);
    ovirtmgmtMap.put("gateway", "10.34.63.254");
    List portsList = lst();
    portsList.add("em1");
    ovirtmgmtMap.put("ports", portsList);
    return resultMap;
}
#method_after
Map getNetworksMap(Host host) {
    Map resultMap = map();
    Map ovirtmgmtMap = map();
    resultMap.put(AppConfig.getInstance().getNetworkBridgeName(), ovirtmgmtMap);
    ovirtmgmtMap.put("iface", AppConfig.getInstance().getNetworkBridgeName());
    // 10.34.63.177
    ovirtmgmtMap.put("addr", host.getIpAddress());
    Map cfgMap = map();
    cfgMap.put("DEVICE", AppConfig.getInstance().getNetworkBridgeName());
    cfgMap.put("DELAY", "0");
    cfgMap.put("BOOTPROTO", "dhcp");
    cfgMap.put("TYPE", "Ethernet");
    cfgMap.put("ONBOOT", "yes");
    ovirtmgmtMap.put("cfg", cfgMap);
    ovirtmgmtMap.put("mtu", "1500");
    ovirtmgmtMap.put("netmask", "255.255.252.0");
    ovirtmgmtMap.put("stp", "off");
    // boolean..1
    ovirtmgmtMap.put("bridged", Boolean.TRUE);
    ovirtmgmtMap.put("gateway", "10.34.63.254");
    List portsList = lst();
    portsList.add("em1");
    ovirtmgmtMap.put("ports", portsList);
    return resultMap;
}
#end_block

#method_before
Map getBridgesMap(Host host) {
    Map resultMap = map();
    Map ovirtmgmtMap = map();
    resultMap.put(getNetworkBridgeName(), ovirtmgmtMap);
    // 10.34.63.177
    ovirtmgmtMap.put("addr", host.getIpAddress());
    ovirtmgmtMap.put("mtu", "1500");
    ovirtmgmtMap.put("netmask", "255.255.252.0");
    ovirtmgmtMap.put("stp", "off");
    // 10.34.63.254
    ovirtmgmtMap.put("gateway", host.getIpAddress("GATEWAY"));
    Map cfgMap = map();
    cfgMap.put("DEVICE", getNetworkBridgeName());
    cfgMap.put("DELAY", "0");
    cfgMap.put("BOOTPROTO", "dhcp");
    cfgMap.put("TYPE", "Ethernet");
    cfgMap.put("ONBOOT", "yes");
    ovirtmgmtMap.put("cfg", cfgMap);
    List portsList = lst();
    portsList.add("em1");
    ovirtmgmtMap.put("ports", portsList);
    return resultMap;
}
#method_after
Map getBridgesMap(Host host) {
    Map resultMap = map();
    Map ovirtmgmtMap = map();
    resultMap.put(AppConfig.getInstance().getNetworkBridgeName(), ovirtmgmtMap);
    // 10.34.63.177
    ovirtmgmtMap.put("addr", host.getIpAddress());
    ovirtmgmtMap.put("mtu", "1500");
    ovirtmgmtMap.put("netmask", "255.255.252.0");
    ovirtmgmtMap.put("stp", "off");
    // 10.34.63.254
    ovirtmgmtMap.put("gateway", host.getIpAddress("GATEWAY"));
    Map cfgMap = map();
    cfgMap.put("DEVICE", AppConfig.getInstance().getNetworkBridgeName());
    cfgMap.put("DELAY", "0");
    cfgMap.put("BOOTPROTO", "dhcp");
    cfgMap.put("TYPE", "Ethernet");
    cfgMap.put("ONBOOT", "yes");
    ovirtmgmtMap.put("cfg", cfgMap);
    List portsList = lst();
    portsList.add("em1");
    ovirtmgmtMap.put("ports", portsList);
    return resultMap;
}
#end_block

#method_before
Map getNicsMap(Host host) {
    Map resultMap = map();
    Map em1Map = map();
    Map em2Map = map();
    resultMap.put("em1", em1Map);
    resultMap.put("em2", em2Map);
    Map cfg1Map = map();
    cfg1Map.put("BRIDGE", getNetworkBridgeName());
    cfg1Map.put("DEVICE", "em1");
    // 1c7b3a5a-500f-41ec-ae03-bb619aeb4081
    cfg1Map.put("UUID", host.getUuid("EM1"));
    cfg1Map.put("NETBOOT", "yes");
    cfg1Map.put("NM_CONTROLLED", "yes");
    cfg1Map.put("BOOTPROTO", "dhcp");
    // 80:c1:6e:6c:51:54
    cfg1Map.put("HWADDR", host.getMacAddress("EM1"));
    cfg1Map.put("TYPE", "Ethernet");
    cfg1Map.put("ONBOOT", "yes");
    cfg1Map.put("NAME", "Boot Disk");
    em1Map.put("cfg", cfg1Map);
    // null
    em1Map.put("addr", "");
    em1Map.put("mtu", "1500");
    // null
    em1Map.put("netmask", "");
    // 80:c1:6e:6c:51:54
    em1Map.put("hwaddr", host.getMacAddress("EM1"));
    em1Map.put("speed", Integer.valueOf(1000));
    Map cfg2Map = map();
    cfg2Map.put("BRIDGE", getNetworkBridgeName());
    cfg2Map.put("DEVICE", "em2");
    // 011c667a-5c74-4882-9b62-35da3021cf8
    cfg2Map.put("UUID", host.getUuid("EM2"));
    cfg2Map.put("NETBOOT", "yes");
    cfg2Map.put("NM_CONTROLLED", "yes");
    cfg2Map.put("BOOTPROTO", "dhcp");
    // 80:C1:6E:6C:51:55
    cfg2Map.put("HWADDR", host.getMacAddress("EM2"));
    cfg2Map.put("TYPE", "Ethernet");
    cfg2Map.put("ONBOOT", "no");
    em2Map.put("cfg", cfg2Map);
    // null
    em2Map.put("addr", "");
    em2Map.put("mtu", "1500");
    // null
    em2Map.put("netmask", "");
    // 80:C1:6E:6C:51:55
    em2Map.put("hwaddr", host.getMacAddress("EM2"));
    em2Map.put("speed", Integer.valueOf(1000));
    return resultMap;
}
#method_after
Map getNicsMap(Host host) {
    Map resultMap = map();
    Map em1Map = map();
    Map em2Map = map();
    resultMap.put("em1", em1Map);
    resultMap.put("em2", em2Map);
    Map cfg1Map = map();
    cfg1Map.put("BRIDGE", AppConfig.getInstance().getNetworkBridgeName());
    cfg1Map.put("DEVICE", "em1");
    // 1c7b3a5a-500f-41ec-ae03-bb619aeb4081
    cfg1Map.put("UUID", host.getUuid("EM1"));
    cfg1Map.put("NETBOOT", "yes");
    cfg1Map.put("NM_CONTROLLED", "yes");
    cfg1Map.put("BOOTPROTO", "dhcp");
    // 80:c1:6e:6c:51:54
    cfg1Map.put("HWADDR", host.getMacAddress("EM1"));
    cfg1Map.put("TYPE", "Ethernet");
    cfg1Map.put("ONBOOT", "yes");
    cfg1Map.put("NAME", "Boot Disk");
    em1Map.put("cfg", cfg1Map);
    // null
    em1Map.put("addr", "");
    em1Map.put("mtu", "1500");
    // null
    em1Map.put("netmask", "");
    // 80:c1:6e:6c:51:54
    em1Map.put("hwaddr", host.getMacAddress("EM1"));
    em1Map.put("speed", Integer.valueOf(1000));
    Map cfg2Map = map();
    cfg2Map.put("BRIDGE", AppConfig.getInstance().getNetworkBridgeName());
    cfg2Map.put("DEVICE", "em2");
    // 011c667a-5c74-4882-9b62-35da3021cf8
    cfg2Map.put("UUID", host.getUuid("EM2"));
    cfg2Map.put("NETBOOT", "yes");
    cfg2Map.put("NM_CONTROLLED", "yes");
    cfg2Map.put("BOOTPROTO", "dhcp");
    // 80:C1:6E:6C:51:55
    cfg2Map.put("HWADDR", host.getMacAddress("EM2"));
    cfg2Map.put("TYPE", "Ethernet");
    cfg2Map.put("ONBOOT", "no");
    em2Map.put("cfg", cfg2Map);
    // null
    em2Map.put("addr", "");
    em2Map.put("mtu", "1500");
    // null
    em2Map.put("netmask", "");
    // 80:C1:6E:6C:51:55
    em2Map.put("hwaddr", host.getMacAddress("EM2"));
    em2Map.put("speed", Integer.valueOf(1000));
    return resultMap;
}
#end_block

#method_before
public Map getVdsStats() {
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("memShared", Integer.valueOf(0));
        infoMap.put("thpState", "always");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("rxRate", "0.00");
        int nTotal = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (!vm.isForDelete()) {
                nTotal++;
            }
        }
        infoMap.put("vmCount", nTotal);
        infoMap.put("memUsed", getRandomNumWithHighValue(2, 20));
        infoMap.put("storageDomains", getStorageDomainsStatsMap());
        infoMap.put("network", getNetworkStatMap());
        infoMap.put("txDropped", "0");
        infoMap.put("cpuUser", getRandomNumWithHighValue(2, 20));
        infoMap.put("ksmPages", Integer.valueOf(100));
        infoMap.put("elapsedTime", host.getElapsedTimeInSeconds() + "");
        infoMap.put("cpuLoad", getRandomNumWithHighValue(2, 20));
        infoMap.put("cpuSys", getRandomNumWithHighValue(10, 20));
        infoMap.put("diskStats", getDiskStatsMap());
        infoMap.put("memCommitted", Integer.valueOf(0));
        // boolean..0
        infoMap.put("ksmState", Boolean.FALSE);
        int nMigrating = 0;
        for (VM vm : host.getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.MigratingFrom || vm.getStatus() == VM.VMStatus.MigratingTo) {
                nMigrating++;
            }
        }
        infoMap.put("vmMigrating", nMigrating);
        infoMap.put("ksmCpu", Integer.valueOf(0));
        infoMap.put("memAvailable", Integer.valueOf(6435));
        infoMap.put("txRate", "");
        infoMap.put("cpuUserVdsmd", "0.50");
        infoMap.put("momStatus", "active");
        // 28f88125-6e5e-4804-8c5d-b4620f80bc9c
        infoMap.put("generationID", host.getUuid("GENERATION_ID"));
        infoMap.put("rxDropped", "14965");
        infoMap.put("swapTotal", Integer.valueOf(20031));
        infoMap.put("swapFree", Integer.valueOf(20031));
        infoMap.put("statsAge", "0.43");
        // 2013-02-10T19:09:11 GMT
        infoMap.put("dateTime", host.getDateTimeGMT());
        infoMap.put("anonHugePages", "662");
        infoMap.put("cpuIdle", getRandomNumWithHighValue(75, 80));
        int nActive = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.Up) {
                nActive++;
            }
        }
        infoMap.put("vmActive", nActive);
        infoMap.put("cpuSysVdsmd", "0.25");
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getVdsStats() {
    AppConfig appConfig = AppConfig.getInstance();
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("memShared", Integer.valueOf(0));
        infoMap.put("thpState", "always");
        infoMap.put("netConfigDirty", "False");
        infoMap.put("rxRate", "0.00");
        int nTotal = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (!vm.isForDelete()) {
                nTotal++;
            }
        }
        infoMap.put("vmCount", nTotal);
        infoMap.put("memUsed", Utils.rangeParsser(appConfig.getMemLoadValues()));
        infoMap.put("storageDomains", getStorageDomainsStatsMap());
        infoMap.put("network", getNetworkStatMap(host.getMacAddress()));
        infoMap.put("txDropped", "0");
        infoMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("ksmPages", Integer.valueOf(100));
        infoMap.put("elapsedTime", host.getElapsedTimeInSeconds() + "");
        infoMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
        infoMap.put("diskStats", getDiskStatsMap());
        infoMap.put("memCommitted", Integer.valueOf(0));
        // boolean..0
        infoMap.put("ksmState", Boolean.FALSE);
        int nMigrating = 0;
        for (VM vm : host.getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.MigratingFrom || vm.getStatus() == VM.VMStatus.MigratingTo) {
                nMigrating++;
            }
        }
        infoMap.put("vmMigrating", nMigrating);
        infoMap.put("ksmCpu", Integer.valueOf(0));
        infoMap.put("memAvailable", Integer.valueOf(6435));
        infoMap.put("txRate", "");
        infoMap.put("cpuUserVdsmd", "0.50");
        infoMap.put("momStatus", "active");
        // 28f88125-6e5e-4804-8c5d-b4620f80bc9c
        infoMap.put("generationID", host.getUuid("GENERATION_ID"));
        infoMap.put("rxDropped", "14965");
        infoMap.put("swapTotal", Integer.valueOf(20031));
        infoMap.put("swapFree", Integer.valueOf(20031));
        infoMap.put("statsAge", "0.43");
        // 2013-02-10T19:09:11 GMT
        infoMap.put("dateTime", host.getDateTimeGMT());
        infoMap.put("anonHugePages", "662");
        infoMap.put("cpuIdle", Utils.getCpuIdle(infoMap.get("cpuUser").toString()));
        int nActive = 0;
        for (VM vm : getActiveHost().getRunningVMs().values()) {
            if (vm.getStatus() == VM.VMStatus.Up) {
                nActive++;
            }
        }
        infoMap.put("vmActive", nActive);
        infoMap.put("cpuSysVdsmd", "0.25");
        resultMap.put("info", infoMap);
        Utils.getLatency();
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
Map getNetworkStatMap() {
    Map resultMap = map();
    String[] nets = new String[] { "bond0", "bond1", "bond2", "bond3", "bond3", "bond4", "em1", "em2" };
    for (String netName : nets) {
        Map netStats = map();
        netStats.put("txErrors", "0");
        netStats.put("state", "up");
        // null
        netStats.put("macAddr", "");
        netStats.put("name", netName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", "0.0");
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "0.0");
        netStats.put("rxDropped", "14965");
        resultMap.put(netName, netStats);
    }
    return resultMap;
}
#method_after
Map getNetworkStatMap(String hostMacAdd) {
    AppConfig appConfig = AppConfig.getInstance();
    if (hostMacAdd == null) {
        hostMacAdd = "";
    }
    Map resultMap = map();
    String[] nets = new String[] { "bond0", "bond1", "bond2", "bond3", "bond3", "bond4", "em1", "em2" };
    for (String netName : nets) {
        Map netStats = map();
        netStats.put("txErrors", "0");
        netStats.put("state", "up");
        // null
        netStats.put("macAddr", hostMacAdd);
        netStats.put("name", netName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", Utils.rangeParsser(appConfig.getNetworkLoadValues()));
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "0.0");
        netStats.put("rxRate", Utils.rangeParsser(appConfig.getNetworkLoadValues()));
        netStats.put("rxDropped", "14965");
        resultMap.put(netName, netStats);
    }
    return resultMap;
}
#end_block

#method_before
public Map migrate(Map request) {
    // String method = (String) request.get("method"); // online
    // 10.34.63.178:54321
    String dst = (String) request.get("dst");
    // String src = (String)request.get("src"); // 10.34.63.177
    // 79567083-9889-4bcc-90e3-291885b0da7f
    String vmId = (String) request.get("vmId");
    boolean success = true;
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    // bind clone of VM to the target host
    VM targetVM = vm.clone();
    vm.setStatus(VM.VMStatus.MigratingFrom);
    targetVM.setStatus(VM.VMStatus.MigratingTo);
    String targetServerName = dst;
    // get target server
    int idx = dst.indexOf(':');
    if (idx != -1) {
        targetServerName = dst.substring(0, idx);
    }
    final Host targetHost = getHostByName(targetServerName);
    if (targetHost == null) {
        log.info("Target host not found: " + dst);
        throw new RuntimeException("Target host not found: " + dst + ", name: " + targetServerName);
    }
    targetVM.setHost(targetHost);
    targetHost.getRunningVMs().put(targetVM.getId(), targetVM);
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM, 10000l, vm));
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_TO_VM, 10000l, targetVM));
    // plan next status task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM_REMOVE_FROM_HOST, 20000l, vm));
    Map resultMap = map();
    Map statusMap = map();
    statusMap.put("message", success ? "Migration process starting" : "VM not found");
    statusMap.put("code", (success ? "0" : "100"));
    resultMap.put("status", statusMap);
    log.info("Migrating VM {} from host: {} to: {}", new Object[] { vm.getId(), vm.getHost().getName(), targetHost.getName() });
    return resultMap;
}
#method_after
public Map migrate(Map request) {
    // String method = (String) request.get("method"); // online
    // 10.34.63.178:54321
    String dst = (String) request.get("dst");
    // String src = (String)request.get("src"); // 10.34.63.177
    // 79567083-9889-4bcc-90e3-291885b0da7f
    String vmId = (String) request.get("vmId");
    boolean success = true;
    final VM vm = getActiveHost().getRunningVMs().get(vmId);
    if (vm == null) {
        log.info("VM not found: " + vmId);
        throw new RuntimeException("VM not found: " + vmId);
    }
    // bind clone of VM to the target host
    VM targetVM = vm.clone();
    vm.setStatus(VM.VMStatus.MigratingFrom);
    targetVM.setStatus(VM.VMStatus.MigratingTo);
    String targetServerName = dst;
    // get target server
    int idx = dst.indexOf(':');
    if (idx != -1) {
        targetServerName = dst.substring(0, idx);
    }
    final Host targetHost = getHostByName(targetServerName);
    if (targetHost == null) {
        log.info("Target host not found: " + dst);
        throw new RuntimeException("Target host not found: " + dst + ", name: " + targetServerName);
    }
    targetVM.setHost(targetHost);
    targetHost.getRunningVMs().put(targetVM.getId(), targetVM);
    // add asynch task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM, 10000l, vm));
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_TO_VM, 10000l, targetVM));
    // plan next status task
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_MIGRATED_FROM_VM_REMOVE_FROM_HOST, 20000l, vm));
    Map<String, Object> resultMap = map();
    Map statusMap = map();
    statusMap.put("message", success ? "Migration process starting" : "VM not found");
    statusMap.put("code", (success ? "0" : "100"));
    resultMap.put("status", statusMap);
    log.info("Migrating VM {} from host: {} to: {}", new Object[] { vm.getId(), vm.getHost().getName(), targetHost.getName() });
    return resultMap;
}
#end_block

#method_before
public Map getVmStats(String uuid) {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    List statusList = new ArrayList();
    VM vm = host.getRunningVMs().get(uuid);
    if (vm != null) {
        Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
        vmStatMap.put("status", vm.getStatus().toString());
        vmStatMap.put("network", getNetworkStatsMap(vm));
        vmStatMap.put("vmId", vm.getId());
        vmStatMap.put("displayType", vm.getDisplayType());
        vmStatMap.put("disks", getVMDisksMap(vm));
        vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
        statusList.add(vmStatMap);
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#method_after
public Map getVmStats(String uuid) {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    List statusList = new ArrayList();
    VM vm = host.getRunningVMs().get(uuid);
    if (vm != null) {
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    Utils.getLatency();
    return resultMap;
}
#end_block

#method_before
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        Map netStats = map();
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        // 00:1a:4a:16:01:51
        netStats.put("macAddr", device.getMacAddr());
        netStats.put("name", "vnet0");
        netStats.put("txDropped", "0");
        netStats.put("txRate", "0.0");
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "0.0");
        netStats.put("rxDropped", "0");
        resultMap.put("vnet" + Integer.valueOf(count), netStats);
        ++count;
    }
    return resultMap;
}
#method_after
Map getNetworkStatsMap(VM vm) {
    List<Device> nicDevices = vm.getDevicesByType(Device.DeviceType.NIC);
    String macAddress = vm.getMacAddress();
    if (macAddress.equals(VM.NONE_STRING)) {
        log.debug("no mac address for vm {}", vm.getId());
        return map();
    }
    Map resultMap = map();
    int count = 0;
    for (Device device : nicDevices) {
        Map netStats = map();
        String dName = "vnet" + Integer.valueOf(count);
        // TODO: change hardcoded fileds.
        netStats.put("txErrors", "0");
        netStats.put("state", "unknown");
        // 00:1a:4a:16:01:51
        netStats.put("macAddr", vm.getMacAddress());
        netStats.put("name", dName);
        netStats.put("txDropped", "0");
        netStats.put("txRate", "7.0");
        netStats.put("rxErrors", "0");
        netStats.put("rxRate", "7.0");
        netStats.put("rxDropped", "0");
        netStats.put("speed", "999");
        resultMap.put(dName, netStats);
        ++count;
    }
    return resultMap;
}
#end_block

#method_before
private Map fillVmStatsMap(VM vm) {
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    // ip validation if no exist set ip, for vms which already registered in the setup
    if (vm.getIp() == null || vm.getIp().equals("0.0.0.0") || vm.getIp().isEmpty() || vm.getIp().equals("?")) {
        vm.setIp(generateIp());
    }
    vmStatMap.put("guestIPs", vm.getIp());
    // cpu
    vmStatMap.put("cpuSys", getRandomNumWithHighValue(5, 20));
    vmStatMap.put("cpuLoad", getRandomNumWithHighValue(5, 20));
    vmStatMap.put("cpuUser", getRandomNumWithHighValue(5, 20));
    // memory
    vmStatMap.put("memUsage", getRandomNumWithHighValue(20, 60));
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    vmStatMap.put("vmId", vm.getId());
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    log.debug("fill vm {} vm proprties {}", vm.getName(), vmStatMap.toString());
    return vmStatMap;
}
#method_after
private Map fillVmStatsMap(VM vm) {
    AppConfig appConfig = AppConfig.getInstance();
    Map vmStatMap = VMInfoService.getInstance().getFromKeys(vm, VmStatsKeys);
    vmStatMap.put("status", vm.getStatus().toString());
    // ip validation if no exist set ip, for vms which already registered in the setup
    if (vm.getIp() == null || vm.getIp().equals("0.0.0.0") || vm.getIp().isEmpty() || vm.getIp().equals("?")) {
        vm.setIp(Utils.ipGenerator());
    }
    // missing data
    Map dis = map();
    ArrayList display = new ArrayList();
    dis.put("tlsPort", "5900");
    dis.put("ipAddress", vm.getIp());
    dis.put("type", "spice");
    dis.put("port", "-1");
    display.add(dis);
    vmStatMap.put("displayInfo", display);
    vmStatMap.put("pid", "1111");
    vmStatMap.put("session", "Unknown");
    vmStatMap.put("timeOffset", "0");
    vmStatMap.put("pauseCode", "NOERR");
    Map ballon = map();
    // TODO: compute 10% from the actual mem for ballooning.
    ballon.put("balloon_max", "2048");
    ballon.put("balloon_min", "1024");
    ballon.put("balloon_target", "2048");
    ballon.put("balloon_cur", "512");
    vmStatMap.put("balloonInfo", ballon);
    vmStatMap.put("guestIPs", vm.getIp());
    vmStatMap.put("guestName", "localhost.localdomain");
    vmStatMap.put("guestFQDN", "localhost.localdomain");
    vmStatMap.put("guestOs", " 2.6.32-504.1.3.el6.x86_64");
    vmStatMap.put("guestCPUCount", "-1");
    // cpu
    vmStatMap.put("cpuSys", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuLoad", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    vmStatMap.put("cpuUser", Utils.rangeParsser(appConfig.getCpuLoadValues()));
    // memory
    vmStatMap.put("memUsage", Utils.rangeParsser(appConfig.getMemLoadValues()));
    // network
    vmStatMap.put("netIfaces", getNetworkInterfaces(vm));
    Map network = getNetworkStatsMap(vm);
    if (!network.isEmpty()) {
        vmStatMap.put("network", network);
    }
    Map disks = getVMDisksMap(vm);
    if (!disks.isEmpty()) {
        vmStatMap.put("disks", disks);
    }
    vmStatMap.put("elapsedTime", vm.getElapsedTimeInSeconds());
    vmStatMap.put("vcpuCount", "1");
    vmStatMap.put("clientIp", "");
    vmStatMap.put("hash", Integer.toString(vm.hashCode()));
    vmStatMap.put("vmType", "kvm");
    vmStatMap.put("vmId", vm.getId());
    vmStatMap.put("displayIp", vm.getIp());
    vmStatMap.put("vcpuPeriod", 100000);
    vmStatMap.put("displayPort", "-1");
    vmStatMap.put("vcpuQuota", "-1");
    vmStatMap.put("kvmEnable", "true");
    vmStatMap.put("monitorResponse", "0");
    vmStatMap.put("statsAge", "2.46");
    vmStatMap.put("username", "None");
    vmStatMap.put("lastLogin", 1426169218.410367);
    ArrayList emptylist = new ArrayList();
    vmStatMap.put("ioTune", emptylist);
    vmStatMap.put("displaySecurePort", "5900");
    vmStatMap.put("vmJobs", map());
    Map memstats = map();
    if (!vmStatMap.get("memUsage").toString().isEmpty()) {
        memstats.put("swap_out", "0");
        memstats.put("majflt", "0");
        memstats.put("swap_usage", "0");
        memstats.put("swap_total", "0");
        memstats.put("swap_in", "0");
        memstats.put("mem_free", Integer.toString(vm.getMemSize() - Integer.valueOf(vmStatMap.get("memUsage").toString())));
        memstats.put("pageflt", "131");
        memstats.put("mem_total", Integer.toString(vm.getMemSize()));
        memstats.put("mem_unused", memstats.get("mem_free"));
        vmStatMap.put("memoryStats", memstats);
    }
    // adding app list
    ArrayList applist = new ArrayList();
    applist.add("kernel-2.6.32-431.el6");
    applist.add("rhevm-guest-agent-common-1.0.9-1.el6ev");
    vmStatMap.put("appsList", applist);
    vmStatMap.put("displayType", "qxl");
    return vmStatMap;
}
#end_block

#method_before
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#method_after
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        VdsmManager vdsmManager = VdsmManager.getInstance();
        if (!vdsmManager.allRunningVms.contains(vm.getId())) {
            vdsmManager.allRunningVms.add(vm.getId());
        }
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#end_block

#method_before
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        vm.setIp(generateIp());
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        // add asynch tasks
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM, 2000l, vm));
        // plan next status task
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM_AS_UP, 10000l, vm));
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.debug("VM {} created on host {}", vmId, host.getName());
        return resultMap;
    } catch (Exception e) {
        log.error(ERROR, e);
        throw new RuntimeException(ERROR, e);
    }
}
#method_after
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        vm.setIp(Utils.ipGenerator());
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        // add asynch tasks
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM, 2000l, vm));
        // plan next status task
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.START_VM_AS_UP, 10000l, vm));
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.debug("VM {} created on host {}", vmId, host.getName());
        return resultMap;
    } catch (Exception e) {
        log.error(ERROR, e);
        throw new RuntimeException(ERROR, e);
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    try {
        final String method = ((HttpServletRequest) request).getMethod();
        final String pathInfo = ((HttpServletRequest) request).getPathInfo();
        final String newline = "\n";
        final String tabnewline = "\n\n\n\n";
        if ("GET".equals(method)) {
            StringBuilder output = new StringBuilder();
            output.append("Hello, this is VDSM Fake!" + tabnewline);
            output.append(" ==== Statistics ======" + newline);
            // TODO: report statistics e.g: #hosts #vms #eps
            try {
                Integer vms = vmservice.getVmlist();
                if (vms > 0) {
                    output.append("running vms: " + Integer.toString(vms) + newline);
                } else {
                    output.append("vms not running" + newline);
                }
            } catch (Exception o) {
                log.error("bad usgae - Cannot filter request" + o.toString());
                output.append("failed to get statistics" + newline);
            }
            // print output
            response.setContentType("text/plain");
            response.getWriter().write(output.toString());
            return;
        }
        if (!"POST".equals(method)) {
            response.setContentType("text/plain");
            response.getWriter().write("Unsupported method: " + method);
            return;
        }
        ContextHolder.init();
        ContextHolder.setServerName(request.getServerName());
        final AppConfig conf = AppConfig.getInstance();
        final CustomHttpServletRequestWrapper wrapper = new CustomHttpServletRequestWrapper((HttpServletRequest) request);
        final CustomHttpServletResponseWrapper responseWrapper = new CustomHttpServletResponseWrapper((HttpServletResponse) response);
        // fix method call name - add namespace of method (required by Apache XMLRPC)
        final Document doc = XMLUtils.parseDocument(wrapper.getInputStream());
        final XPath xp = XPath.newInstance("/methodCall/methodName");
        final Element el = (Element) xp.selectSingleNode(doc);
        final String methodName = el.getText();
        final long tm = System.currentTimeMillis();
        // append namespace
        if (!conf.isProxyActive()) {
            el.setText(METHOD_CALL_NS + "." + el.getText());
        }
        // write back the new XML data
        wrapper.setInputStreamData(XMLUtils.serializeDocument(doc));
        log.info("[{}] {} starting...", new Object[] { request.getServerName(), methodName });
        chain.doFilter(wrapper, responseWrapper);
        // write communication into files
        if (conf.isLogDirSet() && conf.isMethodLoggingEnabled(methodName)) {
            int fIndex = logCounter.incrementAndGet();
            if (communicationLog.isDebugEnabled()) {
                communicationLog.info((getPrefix(fIndex) + "_req_" + methodName), wrapper.getInputStreamData());
                communicationLog.info((getPrefix(fIndex) + "_res_" + methodName), responseWrapper.getOutputStreamData());
            }
        }
        // write response
        responseWrapper.writeDataToStream();
        // log request info
        log.info("[{}] {} done. ({} ms, {} bytes)", new Object[] { request.getServerName(), methodName, Long.valueOf(System.currentTimeMillis() - tm), responseWrapper.getOutputStreamData().length });
    } catch (Exception e) {
        log.error("Cannot filter request", e);
        throw new ServletException("Error during request processing", e);
    } finally {
        ContextHolder.clear();
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    try {
        final String method = ((HttpServletRequest) request).getMethod();
        final String pathInfo = ((HttpServletRequest) request).getPathInfo();
        final String newline = "\n";
        final String tabnewline = "\n\n\n\n";
        if ("GET".equals(method)) {
            StringBuilder output = new StringBuilder();
            output.append("Hello, this is VDSM Fake!").append(tabnewline);
            output.append(" ==== Statistics ======").append(newline);
            VdsmManager vdsmManager = VdsmManager.getInstance();
            output.append("running hosts: ").append(vdsmManager.getHostMap().size()).append(newline);
            output.append("running vms: ").append(vdsmManager.allRunningVms.size()).append(newline);
            // print output
            response.setContentType("text/plain");
            response.getWriter().write(output.toString());
            return;
        }
        if (!"POST".equals(method)) {
            response.setContentType("text/plain");
            response.getWriter().write("Unsupported method: " + method);
            return;
        }
        ContextHolder.init();
        ContextHolder.setServerName(request.getServerName());
        final AppConfig conf = AppConfig.getInstance();
        final CustomHttpServletRequestWrapper wrapper = new CustomHttpServletRequestWrapper((HttpServletRequest) request);
        final CustomHttpServletResponseWrapper responseWrapper = new CustomHttpServletResponseWrapper((HttpServletResponse) response);
        // fix method call name - add namespace of method (required by Apache XMLRPC)
        final Document doc = XMLUtils.parseDocument(wrapper.getInputStream());
        final XPath xp = XPath.newInstance("/methodCall/methodName");
        final Element el = (Element) xp.selectSingleNode(doc);
        final String methodName = el.getText();
        final long tm = System.currentTimeMillis();
        // append namespace
        if (!conf.isProxyActive()) {
            el.setText(METHOD_CALL_NS + "." + el.getText());
        }
        // write back the new XML data
        wrapper.setInputStreamData(XMLUtils.serializeDocument(doc));
        log.info("[{}] {} starting...", new Object[] { request.getServerName(), methodName });
        chain.doFilter(wrapper, responseWrapper);
        // write communication into files
        if (conf.isLogDirSet() && conf.isMethodLoggingEnabled(methodName)) {
            int fIndex = logCounter.incrementAndGet();
            if (communicationLog.isDebugEnabled()) {
                communicationLog.info((getPrefix(fIndex) + "_req_" + methodName), wrapper.getInputStreamData());
                communicationLog.info((getPrefix(fIndex) + "_res_" + methodName), responseWrapper.getOutputStreamData());
            }
        }
        // write response
        responseWrapper.writeDataToStream();
        // log request info
        log.info("[{}] {} done. ({} ms, {} bytes)", new Object[] { request.getServerName(), methodName, Long.valueOf(System.currentTimeMillis() - tm), responseWrapper.getOutputStreamData().length });
    } catch (Exception e) {
        log.error("Cannot filter request", e);
        throw new ServletException("Error during request processing", e);
    } finally {
        ContextHolder.clear();
    }
}
#end_block

#method_before
public static boolean check(String current, String password) throws GeneralSecurityException {
    String[] comps = current.split("\\|");
    if (comps.length != 5 || !"1".equals(comps[0])) {
        throw new IllegalArgumentException("Invalid current password");
    }
    byte[] salt = new Base64(0).decode(comps[2]);
    return Arrays.equals(new Base64(0).decode(comps[4]), SecretKeyFactory.getInstance(comps[1]).generateSecret(new PBEKeySpec(password.toCharArray(), salt, Integer.parseInt(comps[3]), salt.length * 8)).getEncoded());
}
#method_after
public static boolean check(String blob, String password) throws IOException, GeneralSecurityException {
    final Map<String, String> map = new ObjectMapper().readValue(Base64.decodeBase64(blob), TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, String.class));
    if (!ARTIFACT.equals(map.get(ARTIFACT_KEY))) {
        throw new IllegalArgumentException(String.format("Invalid artifact '%s'", map.get(ARTIFACT_KEY)));
    }
    if (!VERSION.equals(map.get(VERSION_KEY))) {
        throw new IllegalArgumentException(String.format("Invalid version '%s'", map.get(VERSION_KEY)));
    }
    byte[] salt = Base64.decodeBase64(map.get(SALT_KEY));
    return Arrays.equals(Base64.decodeBase64(map.get(SECRET_KEY)), SecretKeyFactory.getInstance(map.get(ALGORITHM_KEY)).generateSecret(new PBEKeySpec(password.toCharArray(), salt, Integer.parseInt(map.get(ITERATIONS_KEY)), salt.length * 8)).getEncoded());
}
#end_block

#method_before
public static String encode(String algorithm, int length, int iterations, String randomProvider, String password) throws GeneralSecurityException {
    byte[] salt = new byte[length / 8];
    SecureRandom.getInstance(randomProvider == null ? "SHA1PRNG" : randomProvider).nextBytes(salt);
    return String.format("1|%s|%s|%s|%s", algorithm, new Base64(0).encodeToString(salt), iterations, new Base64(0).encodeToString(SecretKeyFactory.getInstance(algorithm).generateSecret(new PBEKeySpec(password.toCharArray(), salt, iterations, salt.length * 8)).getEncoded()));
}
#method_after
public static String encode(String algorithm, int keySize, int iterations, String randomProvider, String password) throws IOException, GeneralSecurityException {
    final Base64 base64 = new Base64(0);
    final Map<String, String> map = new HashMap<String, String>();
    byte[] salt = new byte[keySize / 8];
    SecureRandom.getInstance(randomProvider == null ? "SHA1PRNG" : randomProvider).nextBytes(salt);
    map.put(ARTIFACT_KEY, ARTIFACT);
    map.put(VERSION_KEY, VERSION);
    map.put(ALGORITHM_KEY, algorithm);
    map.put(SALT_KEY, base64.encodeToString(salt));
    map.put(ITERATIONS_KEY, Integer.toString(iterations));
    map.put(SECRET_KEY, base64.encodeToString(SecretKeyFactory.getInstance(algorithm).generateSecret(new PBEKeySpec(password.toCharArray(), salt, iterations, salt.length * 8)).getEncoded()));
    return base64.encodeToString(new ObjectMapper().writeValueAsString(map).getBytes(Charset.forName("UTF-8")));
}
#end_block

#method_before
@Test
public void test2() throws Exception {
    String encoded = "1|PBKDF2WithHmacSHA1|6cV98d+EG02X6qDHLQVYSZ5ga8lvrejjSCOWDH9hdLI=|4000|hVtO6LfblQoVZ9E23C9bNG1laq790zE6VWHhC53k7yM=";
    assertTrue(EnvelopePBE.check(encoded, "password"));
    assertFalse(EnvelopePBE.check(encoded, "bad"));
}
#method_after
@Test
public void test2() throws Exception {
    String encoded = "eyJhcnRpZmFjdCI6IkVudmVsb3BlUEJFIiwiaXRlcmF0aW9ucyI6IjQwMDAiLCJzZWNyZXQiOiJNWE5nZVlwNUxSWFNRZmRMYzNDOHRVNWRINFZOODExb0czNjlrU0FLOHAwPSIsInNhbHQiOiJudXFaa2M3dlMrNUNkRzVQaEMvWE5ycDMzd0luTnNnZGZIVXlQRE5RS05rPSIsImFsZ29yaXRobSI6IlBCS0RGMldpdGhIbWFjU0hBMSIsInZlcnNpb24iOiIxIn0=";
    assertTrue(EnvelopePBE.check(encoded, "password"));
    assertFalse(EnvelopePBE.check(encoded, "bad"));
}
#end_block

#method_before
public long getVmDataChangedTime() {
    return vmDataChangedTime;
}
#method_after
public Long getVmDataChangedTime() {
    return vmDataChangedTime;
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId()) && vmManager.trylock()) {
            if (fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vmManager.trylock()) {
            if (!vmManager.isLatestData(pair.getSecond(), vdsManager.getVdsId())) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - newer VM data was already processed", vmId);
                vmManager.unlock();
            } else if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, IrsBrokerCommand.reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    boolean poolStatusDeterminedByHostsStatus = FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion());
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, IrsBrokerCommand.reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                        // TODO: need to check if it's fine to skip the update when the status is already NonResponsive (as domains status maybe be not updated.
                        if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.NonResponsive) {
                            updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NON_RESPONSIVE_NO_REPORTING_HOSTS, VdcBllErrors.ENGINE);
                        }
                    } else if (poolStatusDeterminedByHostsStatus && storagePool.getStatus() != StoragePoolStatus.Up) {
                        updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.Up, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_UP_REPORTING_HOSTS, null);
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        if (!poolStatusDeterminedByHostsStatus) {
                            proceedStoragePoolStats(storagePool);
                        } else {
                            List<StorageDomain> storageDomains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(storagePool.getId());
                            domainsInMaintenanceCheck(storageDomains);
                        }
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    for (final StorageDomain domainInDb : domainsInDb) {
        if (domainInDb.getStatus() == StorageDomainStatus.PreparingForMaintenance) {
            queueDomainMaintenanceCheck(domainInDb);
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                updateStoragePoolStatus(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warn("failed getting spm status for pool '{}' ({}), attempt number: {}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getMasterDomainVersion();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainInDb.getStorageType().isCinderDomain() && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
    domainsInMaintenanceCheck(domainsInDb);
}
#end_block

#method_before
private void movePoolToProblematicInDB(StoragePool storagePool) {
    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    storagePool.setSpmVdsId(null);
    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
}
#method_after
private void movePoolToProblematicInDB(StoragePool storagePool) {
    updateStoragePoolStatus(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    storagePool.setSpmVdsId(null);
    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
}
#end_block

#method_before
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            // Unknown domains in pool
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, storagePool, false);
                    if (domainMonitoringResult.invalidAndActual()) {
                        domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
                    } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && analyzeDomainReport(tempData, storagePool, false).validAndActual()) {
                    log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                    // For block domains, synchronize LUN details comprising the storage domain with the DB
                    StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(tempData.getDomainId());
                    if (storageDomain.getStorageType().isBlockDomain()) {
                        ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(storageDomain.getId(), vdsId);
                    }
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#method_after
public void updateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInMaintenance = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            Map<Guid, DomainMonitoringResult> domainsProblematicReportInfo = new HashMap<>();
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> activeDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            Set<Guid> unknownDomainsInPool = new HashSet<>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Inactive));
            // build a list of all the domains in
            // pool (activeDomainsInPool and unknownDomainsInPool) that are not
            // visible by the host.
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : activeDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            for (Guid tempDomainId : unknownDomainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsProblematicReportInfo.put(tempDomainId, DomainMonitoringResult.NOT_REPORTED);
                }
            }
            // Unknown domains in pool
            for (VDSDomainsData tempData : data) {
                if (activeDomainsInPool.contains(tempData.getDomainId()) || unknownDomainsInPool.contains(tempData.getDomainId())) {
                    DomainMonitoringResult domainMonitoringResult = analyzeDomainReport(tempData, storagePool, false);
                    if (domainMonitoringResult.invalidAndActual()) {
                        domainsProblematicReportInfo.put(tempData.getDomainId(), domainMonitoringResult);
                    } else if (domainMonitoringResult.actual() && tempData.getDelay() > Config.<Double>getValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if ((inActiveDomainsInPool.contains(tempData.getDomainId()) || // in data centers with spm, unknown domains are moving to Active status according to the pool metadata.
                (FeatureSupported.dataCenterWithoutSpm(storagePool.getCompatibilityVersion()) && unknownDomainsInPool.contains(tempData.getDomainId()))) && analyzeDomainReport(tempData, storagePool, false).validAndActual()) {
                    log.warn("Storage Domain '{}' was reported by Host '{}' as Active in Pool '{}', moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                    // For block domains, synchronize LUN details comprising the storage domain with the DB
                    StorageDomain storageDomain = DbFacade.getInstance().getStorageDomainDao().get(tempData.getDomainId());
                    if (storageDomain.getStorageType().isBlockDomain()) {
                        ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(storageDomain.getId(), vdsId);
                    }
                }
            }
            Set<Guid> maintInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Maintenance));
            maintInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.PreparingForMaintenance));
            domainsInMaintenance = new HashSet<Guid>();
            for (Guid tempDomainId : maintInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInMaintenance.add(tempDomainId);
                }
            }
            updateDomainInProblem(vdsId, vdsName, domainsProblematicReportInfo, domainsInMaintenance);
        } catch (RuntimeException ex) {
            log.error("error in updateVdsDomainsData: {}", ex.getMessage());
            log.debug("Exception", ex);
        }
    }
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    // Note - this method is used as it returns only hosts from VIRT supported clusters
    // (we use the domain monitoring results only from those clusters hosts).
    // every change to it should be inspected carefully.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, null);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warn("vds '{}' reported domain '{}' - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warn("vds '{}' reported domain '{}' as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    final Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", storageDomain.getName());
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId, customLogValues);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warn("vds '{}' reported domain '{}' as in problem, vds is in status '{}', no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warn("Storage domain '{}' is not visible to one or more hosts. " + "Since the domain's type is '{}', hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.error("Domain '{}' was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warn("Domain '{}' was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public static IIrsServer createIrsServer(VdsProtocol vdsProtocol, Version version, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IIrsServer irsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        String eventQueue = null;
        if (FeatureSupported.vmStatsEvents(version)) {
            eventQueue = Config.<String>getValue(ConfigValues.EventQueueName);
        }
        irsServer = new JsonRpcIIrsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication), Config.<String>getValue(ConfigValues.VdsmSSLProtocol), Config.<Integer>getValue(ConfigValues.EventProcessingPoolSize), Config.<String>getValue(ConfigValues.IrsRequestQueueName), Config.<String>getValue(ConfigValues.IrsResponseQueueName), eventQueue));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, Config.<Integer>getValue(ConfigValues.IrsMaxConnectionsPerHost), Config.<Integer>getValue(ConfigValues.MaxTotalConnections), IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        irsServer = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return irsServer;
}
#method_after
public static IIrsServer createIrsServer(VdsProtocol vdsProtocol, Version version, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IIrsServer irsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        String eventQueue = getEventsQueue(version);
        irsServer = new JsonRpcIIrsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication), Config.<String>getValue(ConfigValues.VdsmSSLProtocol), Config.<Integer>getValue(ConfigValues.EventProcessingPoolSize), Config.<String>getValue(ConfigValues.IrsRequestQueueName), Config.<String>getValue(ConfigValues.IrsResponseQueueName), eventQueue));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, Config.<Integer>getValue(ConfigValues.IrsMaxConnectionsPerHost), Config.<Integer>getValue(ConfigValues.MaxTotalConnections), IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        irsServer = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return irsServer;
}
#end_block

#method_before
public static IVdsServer createVdsServer(VdsProtocol vdsProtocol, Version version, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IVdsServer vdsServer = null;
    Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, Config.<Integer>getValue(ConfigValues.VdsMaxConnectionsPerHost), Config.<Integer>getValue(ConfigValues.MaxTotalConnections), VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    if (VdsProtocol.STOMP == vdsProtocol) {
        String eventQueue = null;
        if (FeatureSupported.vmStatsEvents(version)) {
            eventQueue = Config.<String>getValue(ConfigValues.EventQueueName);
        }
        vdsServer = new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication), Config.<String>getValue(ConfigValues.VdsmSSLProtocol), Config.<Integer>getValue(ConfigValues.EventProcessingPoolSize), Config.<String>getValue(ConfigValues.VdsRequestQueueName), Config.<String>getValue(ConfigValues.VdsResponseQueueName), eventQueue), returnValue.getSecond());
    } else if (VdsProtocol.XML == vdsProtocol) {
        vdsServer = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return vdsServer;
}
#method_after
public static IVdsServer createVdsServer(VdsProtocol vdsProtocol, Version version, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IVdsServer vdsServer = null;
    Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, Config.<Integer>getValue(ConfigValues.VdsMaxConnectionsPerHost), Config.<Integer>getValue(ConfigValues.MaxTotalConnections), VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
    if (VdsProtocol.STOMP == vdsProtocol) {
        String eventQueue = getEventsQueue(version);
        vdsServer = new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication), Config.<String>getValue(ConfigValues.VdsmSSLProtocol), Config.<Integer>getValue(ConfigValues.EventProcessingPoolSize), Config.<String>getValue(ConfigValues.VdsRequestQueueName), Config.<String>getValue(ConfigValues.VdsResponseQueueName), eventQueue), returnValue.getSecond());
    } else if (VdsProtocol.XML == vdsProtocol) {
        vdsServer = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return vdsServer;
}
#end_block

#method_before
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], rateInMinutes, rateInMinutes, TimeUnit.MINUTES));
    this.vmsRefresher = RefresherFactory.create(this, this.auditLogDirector, this.getSchedulUtil());
    this.vmsRefresher.startMonitoring();
}
#method_after
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    // start with refresh statistics
    refreshIteration = numberRefreshesBeforeSave - 1;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "vmsMonitoring", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], rateInMinutes, rateInMinutes, TimeUnit.MINUTES));
}
#end_block

#method_before
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getVdsGroupCompatibilityVersion(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
    // need to check whether single thread is enough
    monitoring = new MonitoringManager();
    new Thread(monitoring).start();
}
#method_after
private void initVdsBroker() {
    log.info("Initialize vdsBroker '{}:{}'", cachedVds.getHostName(), cachedVds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    vdsProxy = TransportFactory.createVdsServer(cachedVds.getProtocol(), cachedVds.getVdsGroupCompatibilityVersion(), cachedVds.getHostName(), cachedVds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    this.vmsRefresher.updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    if (refreshIteration == numberRefreshesBeforeSave) {
                        refreshIteration = 1;
                    } else {
                        refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        mUnrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", e.getMessage());
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", cachedVds.getName());
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            dbFacade.getVdsDynamicDao().updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
    if (updateAvailable) {
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLogDirector.log(auditLog, AuditLogType.HOST_UPDATES_ARE_AVAILABLE);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED)) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with disabled SELinux.", vds.getName());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getVdsGroupSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            dbFacade.getVdsDynamicDao().updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    this.vmsRefresher.stopMonitoring();
    vdsProxy.close();
    monitoring.close();
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    vdsProxy.close();
}
#end_block

#method_before
public boolean getRefreshStatistics() {
    if (this.vmsRefresher == null) {
        return false;
    }
    return this.vmsRefresher.getRefreshStatistics();
}
#method_after
public boolean getRefreshStatistics() {
    return (refreshIteration == numberRefreshesBeforeSave);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        loadService(PmHealthCheckManager.class);
        loadService(EngineBackupAwarenessManager.class);
        CommandCoordinatorUtil.initAsyncTaskManager();
        loadService(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        loadService(HostDeviceManager.class);
        loadService(DwhHeartBeat.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        pmHealthCheckManager.initialize();
        // recover from engine failure
        pmHealthCheckManager.recover(hosts);
        // Initialize backup awareness manager
        engineBackupAwarenessManager.initialize();
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        hostDeviceManager.init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                convertEvent(changedVms, devicesChangedVms, map);
                if (!changedVms.isEmpty() || !devicesChangedVms.isEmpty()) {
                    new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector, System.nanoTime()).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.getNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid((String) entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                if (dbVm == null) {
                    log.error("failed to fetch VM '{}' from db. Status remain unchanged", vmid);
                    return;
                }
                VmInternalData vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                // and process once the migration is done
                if (dbVm.getRunOnVds() == null || dbVm.getRunOnVds().equals(manager.getVdsId()) || (!dbVm.getRunOnVds().equals(manager.getVdsId()) && vdsmVm.getVmDynamic().getStatus() == VMStatus.Up)) {
                    if (vdsmVm != null) {
                        changedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                    if (isDevicesChanged(dbVm, vdsmVm)) {
                        devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                }
            }
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            return new VmInternalData(VdsBrokerObjectsBuilder.buildVmDynamicFromEvent(dbVm.getDynamicData(), xmlRpcStruct), dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#method_after
@Override
public void startMonitoring() {
    super.startMonitoring();
    this.resourceManager.subscribe(new EventSubscriber(manager.getVdsHostname() + "|*|VM_status|*") {

        @Override
        public void onSubscribe(Subscription sub) {
            subscription = sub;
            subscription.request(1);
        }

        @Override
        public void onNext(Map<String, Object> map) {
            try {
                List<Pair<VM, VmInternalData>> changedVms = new ArrayList<>();
                List<Pair<VM, VmInternalData>> devicesChangedVms = new ArrayList<>();
                convertEvent(changedVms, devicesChangedVms, map);
                if (!changedVms.isEmpty() || !devicesChangedVms.isEmpty()) {
                    new VmsMonitoring(manager, changedVms, devicesChangedVms, auditLogDirector, System.nanoTime()).perform();
                }
            } finally {
                subscription.request(1);
            }
        }

        @SuppressWarnings("unchecked")
        private void convertEvent(List<Pair<VM, VmInternalData>> changedVms, List<Pair<VM, VmInternalData>> devicesChangedVms, Map<String, Object> map) {
            Double notifyTime = VdsBrokerObjectsBuilder.removeNotifyTimeFromVmStatusEvent(map);
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                Guid vmid = new Guid((String) entry.getKey());
                VM dbVm = dbFacade.getVmDao().get(vmid);
                if (dbVm == null) {
                    log.error("failed to fetch VM '{}' from db. Status remain unchanged", vmid);
                    return;
                }
                VmInternalData vdsmVm = createVmInternalData(dbVm, (Map<String, Object>) map.get(vmid.toString()), notifyTime);
                // and process once the migration is done
                if (dbVm.getRunOnVds() == null || dbVm.getRunOnVds().equals(manager.getVdsId()) || (!dbVm.getRunOnVds().equals(manager.getVdsId()) && vdsmVm.getVmDynamic().getStatus() == VMStatus.Up)) {
                    if (vdsmVm != null) {
                        changedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                    if (isDevicesChanged(dbVm, vdsmVm)) {
                        devicesChangedVms.add(new Pair<>(dbVm, vdsmVm));
                    }
                }
            }
        }

        private VmInternalData createVmInternalData(VM dbVm, Map<String, Object> xmlRpcStruct, Double notifyTime) {
            return new VmInternalData(VdsBrokerObjectsBuilder.buildVmDynamicFromEvent(dbVm.getDynamicData(), xmlRpcStruct), dbVm.getStatisticsData(), notifyTime);
        }

        @Override
        public void onError(Throwable t) {
        }

        @Override
        public void onComplete() {
        }
    });
}
#end_block

#method_before
public static VmDynamic buildVmDynamicFromEvent(VmDynamic vmDynamic, Map<String, Object> xmlRpcStruct) {
    VmDynamic clonedVmDynamic = new VmDynamic(vmDynamic);
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        clonedVmDynamic.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        clonedVmDynamic.setHash((String) xmlRpcStruct.get(VdsProperties.hash));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        clonedVmDynamic.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        clonedVmDynamic.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        clonedVmDynamic.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    return clonedVmDynamic;
}
#method_after
public static VmDynamic buildVmDynamicFromEvent(VmDynamic baseVmDynamic, Map<String, Object> xmlRpcStruct) {
    VmDynamic clonedVmDynamic = new VmDynamic(baseVmDynamic);
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        clonedVmDynamic.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        clonedVmDynamic.setHash((String) xmlRpcStruct.get(VdsProperties.hash));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        clonedVmDynamic.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        clonedVmDynamic.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        clonedVmDynamic.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    return clonedVmDynamic;
}
#end_block

#method_before
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vdsManager.shouldUpdateVmStatus(pair.getSecond()) && vmManager.trylock()) {
            if (fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#method_after
private boolean tryLockVmForUpdate(Pair<VM, VmInternalData> pair) {
    Guid vmId = getVmId(pair);
    if (vmId != null) {
        VmManager vmManager = getResourceManager().getVmManager(vmId);
        if (vdsManager.shouldUpdateVmStatus(pair.getSecond()) && vmManager.trylock()) {
            if (vmManager.getVmDataChangedTime() != null && fetchTime - vmManager.getVmDataChangedTime() <= 0) {
                log.warn("skipping VM '{}' from this monitoring cycle" + " - the VM data has changed since fetching the data", vmId);
                vmManager.unlock();
            } else {
                // store the locked managers to finally release them at the end of the cycle
                vmManagers.put(vmId, vmManager);
                return true;
            }
        } else {
            log.debug("skipping VM '{}' from this monitoring cycle" + " - the VM is locked by its VmManager ", getVmId(pair));
        }
    }
    return false;
}
#end_block

#method_before
protected VmInternalData createVmInternalData(Map<String, Object> xmlRpcStruct) {
    VmDynamic vmDynamic = new VmDynamic();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vmDynamic, xmlRpcStruct);
    adjustDisplayIp(vmDynamic.getGraphicsInfos());
    return new VmInternalData(vmDynamic, VdsBrokerObjectsBuilder.buildVMStatisticsData(xmlRpcStruct), VdsBrokerObjectsBuilder.buildVmGuestAgentInterfacesData(vmDynamic.getId(), xmlRpcStruct), VdsBrokerObjectsBuilder.buildVmLunDisksData(xmlRpcStruct), VdsBrokerObjectsBuilder.getVdsmTimestamp(xmlRpcStruct));
}
#method_after
protected VmInternalData createVmInternalData(Map<String, Object> xmlRpcStruct) {
    VmDynamic vmDynamic = new VmDynamic();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vmDynamic, xmlRpcStruct);
    adjustDisplayIp(vmDynamic.getGraphicsInfos());
    return new VmInternalData(vmDynamic, VdsBrokerObjectsBuilder.buildVMStatisticsData(xmlRpcStruct), VdsBrokerObjectsBuilder.buildVmGuestAgentInterfacesData(vmDynamic.getId(), xmlRpcStruct), VdsBrokerObjectsBuilder.buildVmLunDisksData(xmlRpcStruct), VdsBrokerObjectsBuilder.getVdsmCallTimestamp(xmlRpcStruct));
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    mVmListReturn = getBroker().list();
    proceedProxyReturnValue();
    Map<Guid, VmInternalData> returnVMs = new HashMap<Guid, VmInternalData>();
    for (int idx = 0; idx < mVmListReturn.mVmList.length; ++idx) {
        Map<String, Object> vm = mVmListReturn.mVmList[idx];
        VmDynamic dynamicData = VdsBrokerObjectsBuilder.buildVMDynamicDataFromList(vm);
        VmInternalData vmData = new VmInternalData(dynamicData, VdsBrokerObjectsBuilder.getVdsmTimestamp(vm));
        returnVMs.put(dynamicData.getId(), vmData);
    }
    setReturnValue(returnVMs);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    mVmListReturn = getBroker().list();
    proceedProxyReturnValue();
    Map<Guid, VmInternalData> returnVMs = new HashMap<Guid, VmInternalData>();
    for (int idx = 0; idx < mVmListReturn.mVmList.length; ++idx) {
        Map<String, Object> vm = mVmListReturn.mVmList[idx];
        VmDynamic dynamicData = VdsBrokerObjectsBuilder.buildVMDynamicDataFromList(vm);
        VmInternalData vmData = new VmInternalData(dynamicData, VdsBrokerObjectsBuilder.getVdsmCallTimestamp(vm));
        returnVMs.put(dynamicData.getId(), vmData);
    }
    setReturnValue(returnVMs);
}
#end_block

#method_before
private static Object doHibernateClean(Object dirty, Map<Object, Object> processed) {
    if (dirty instanceof PersistentList) {
        PersistentList dirtyList = (PersistentList) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentBag) {
        PersistentBag dirtyList = (PersistentBag) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentIdentifierBag) {
        PersistentIdentifierBag dirtyList = (PersistentIdentifierBag) dirty;
        List<Object> cleanList = new ArrayList<Object>();
        processed.put(dirtyList, cleanList);
        if (dirtyList.wasInitialized()) {
            for (Object value : dirtyList) {
                cleanList.add(doClean(value, processed));
            }
        }
        return cleanList;
    }
    if (dirty instanceof PersistentSortedSet) {
        PersistentSortedSet dirtySet = (PersistentSortedSet) dirty;
        Set<Object> cleanSet = new TreeSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentSet) {
        PersistentSet dirtySet = (PersistentSet) dirty;
        Set<Object> cleanSet = new HashSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentMap) {
        PersistentMap dirtyMap = (PersistentMap) dirty;
        Map<Object, Object> cleanMap = new LinkedHashMap<Object, Object>();
        processed.put(dirtyMap, cleanMap);
        if (dirtyMap.wasInitialized()) {
            for (Object entryObject : dirtyMap.entrySet()) {
                // Cast the entry object to the right type since the hibernate library doesn't know how to do
                // generics properly.
                @SuppressWarnings("unchecked")
                Entry<Object, Object> entry = (Entry<Object, Object>) entryObject;
                cleanMap.put(doClean(entry.getKey(), processed), doClean(entry.getValue(), processed));
            }
        }
        return cleanMap;
    }
    return null;
}
#method_after
private static Object doHibernateClean(Object dirty, Map<Object, Object> processed) {
    if (dirty instanceof PersistentSortedSet) {
        PersistentSortedSet dirtySet = (PersistentSortedSet) dirty;
        Set<Object> cleanSet = new TreeSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentSet) {
        PersistentSet dirtySet = (PersistentSet) dirty;
        Set<Object> cleanSet = new HashSet<Object>();
        processed.put(dirtySet, cleanSet);
        if (dirtySet.wasInitialized()) {
            for (Object value : dirtySet) {
                cleanSet.add(doClean(value, processed));
            }
        }
        return cleanSet;
    }
    if (dirty instanceof PersistentMap) {
        PersistentMap dirtyMap = (PersistentMap) dirty;
        Map<Object, Object> cleanMap = new LinkedHashMap<Object, Object>();
        processed.put(dirtyMap, cleanMap);
        if (dirtyMap.wasInitialized()) {
            for (Object entryObject : dirtyMap.entrySet()) {
                // Cast the entry object to the right type since the hibernate library doesn't know how to do
                // generics properly.
                @SuppressWarnings("unchecked")
                Entry<Object, Object> entry = (Entry<Object, Object>) entryObject;
                cleanMap.put(doClean(entry.getKey(), processed), doClean(entry.getValue(), processed));
            }
        }
        return cleanMap;
    }
    if (dirty instanceof List && dirty instanceof PersistentCollection) {
        return cleanPersistedList(processed, dirty);
    }
    return null;
}
#end_block

#method_before
private void addErrataForHostsFeature(Features features) {
    Feature feature = new Feature();
    feature.setName("Katello Errata");
    feature.setDescription("View available Katello Errata for hosts and system.");
    features.getFeature().add(feature);
}
#method_after
private void addErrataForHostsFeature(Features features) {
    Feature feature = new Feature();
    feature.setName("Katello Errata");
    feature.setDescription("View available Katello Errata for vms, hosts and system.");
    features.getFeature().add(feature);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateStatus(String vmId) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrateStatus(vmId);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.migrateStatus(vmId);
        return new MigrateStatusReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getDeviceList(storageType);
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    try {
        Map<String, Object> xmlRpcReturnValue = null;
        if (devicesList != null) {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType, devicesList);
        } else {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType);
        }
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(remoteUserName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(userName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(remoteUserName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName, partial);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, remoteUserName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<Guid>(VdcQueryType.GetStorageDomainById, IdQueryParameters.class);
    org.ovirt.engine.core.common.businessentities.StorageDomain entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getStorageType();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                refreshLunSize(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#method_after
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<Guid>(VdcQueryType.GetStorageDomainById, IdQueryParameters.class);
    org.ovirt.engine.core.common.businessentities.StorageDomain entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getStorageType();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#end_block

#method_before
public static synchronized String[] getLinksToExclude(StorageDomain storageDomain) {
    return isIsoDomain(storageDomain) ? new String[] { "templates", "vms", "disks", "images" } : isExportDomain(storageDomain) ? new String[] { "files", "images" } : isImageDomain(storageDomain) ? new String[] { "templates", "vms", "files", "disks", "storageconnections" } : new String[] { "templates", "vms", "files", "images" };
}
#method_after
public static synchronized String[] getLinksToExclude(StorageDomain storageDomain) {
    return isIsoDomain(storageDomain) ? new String[] { "templates", "vms", "disks", "images" } : isExportDomain(storageDomain) ? new String[] { "files", "images" } : isImageDomain(storageDomain) ? new String[] { "templates", "vms", "files", "disks", "storageconnections" } : new String[] { "files", "images" };
}
#end_block

#method_before
private void refreshLunSize(StorageDomain incoming, StorageDomain storageDomain, StorageType storageType) {
    if (incoming.getStorage() == null) {
        // LUNs info was not supplied in the request so no need to check whether to refresh the size
        return;
    }
    List<LogicalUnit> incomingLuns = getIncomingLuns(incoming.getStorage());
    if (!incomingLuns.isEmpty()) {
        List<LogicalUnit> lunsToResize = new ArrayList<>();
        for (LogicalUnit logicalUnit : incomingLuns) {
            if (logicalUnit.isSetRefreshSize() && logicalUnit.isRefreshSize()) {
                lunsToResize.add(logicalUnit);
            }
        }
        if (!lunsToResize.isEmpty()) {
            ExtendSANStorageDomainParameters params = createParameters(guid, lunsToResize, false);
            performAction(VdcActionType.RefreshLunsSize, params);
        }
    }
}
#method_after
private void refreshLunSize(Action action) {
    List<LogicalUnit> incomingLuns = action.getLogicalUnits().getLogicalUnits();
    if (!incomingLuns.isEmpty()) {
        ExtendSANStorageDomainParameters params = createParameters(guid, incomingLuns, false);
        performAction(VdcActionType.RefreshLunsSize, params);
    }
}
#end_block

#method_before
@Override
public RemovableStorageDomainContentsResource<Templates, Template> getStorageDomainTemplatesResource() {
    return inject(new BackendStorageDomainTemplatesResource(guid));
}
#method_after
@Override
public StorageDomainContentsResource<Templates, Template> getStorageDomainTemplatesResource() {
    return inject(new BackendStorageDomainTemplatesResource(guid));
}
#end_block

#method_before
@Override
public RemovableStorageDomainContentsResource<VMs, VM> getStorageDomainVmsResource() {
    return inject(new BackendStorageDomainVmsResource(guid));
}
#method_after
@Override
public StorageDomainContentsResource<VMs, VM> getStorageDomainVmsResource() {
    return inject(new BackendStorageDomainVmsResource(guid));
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final ClientPolicy policy = client.getClientRetryPolicy();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(policy.clone(), false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(policy, true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isHeartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setIncomingHeartbeat(isHeartbeat);
    policy.setOutgoingHeartbeat(isHeartbeat);
    client.setClientRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(ClientPolicy policy, boolean isHeartbeat) {
    policy.setIncomingHeartbeat(isHeartbeat);
    policy.setOutgoingHeartbeat(isHeartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType) {
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    // forceRemove not used in gluster API
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStart").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("brickName", lvName).withParameter("mountPoint", mountPoint).withParameter("devices", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!FeatureSupported.isRefreshLunsSupported(getStoragePool().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REFRESH_LUNS_UNSUPPORTED_ACTION);
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if ((getStorageDomain().getStorageType() == StorageType.NFS || getStorageDomain().getStorageType() == StorageType.UNKNOWN)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        return false;
    }
    if (!checkStorageDomainStatusNotEqual(StorageDomainStatus.Locked)) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (!FeatureSupported.refreshLunSupported(getStoragePool().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REFRESH_LUNS_UNSUPPORTED_ACTION);
    }
    if (!(checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getStorageDomain().getStorageType().isBlockDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!checkLunsInStorageDomain(getParameters().getLunIds(), getStorageDomain())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_NOT_PART_OF_STORAGE_DOMAIN);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    executeInNewTransaction(new TransactionMethod<Void>() {

        public Void runInTransaction() {
            setStorageDomainStatus(StorageDomainStatus.Locked, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // Call Refresh Device on all Hosts
    Map<String, Map<Long, List<VDS>>> lunToSize = refreshLunSizeAllVds(getParameters().getLunIds());
    List<String> succeededRefreshLuns = new ArrayList<>();
    for (Map.Entry<String, Map<Long, List<VDS>>> entry : lunToSize.entrySet()) {
        if (entry.getValue().size() != 1) {
            log.error("Failed to refresh device " + entry.getKey() + " Not all VDS are seeing the same size");
        } else {
            String lunId = entry.getKey();
            // Call PV resize on SPM
            Long pvSize = resizePV(lunId);
            succeededRefreshLuns.add(lunId);
            log.error("PV size  " + entry.getKey() + " :" + pvSize);
        }
    }
    // Update storage domain size
    updateStorageDomainData();
    // Call PV refresh on all Hosts
    refreshPVAllVds(succeededRefreshLuns);
    executeInNewTransaction(new TransactionMethod<Void>() {

        public Void runInTransaction() {
            setStorageDomainStatus(StorageDomainStatus.Active, null);
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Locked);
    // Call GetDeviceList on specific LUNs on all Hosts
    List<String> lunsToRefresh = getParameters().getLunIds();
    Map<String, List<Pair<VDS, Integer>>> lunToVds = getDeviceListAllVds(lunsToRefresh);
    // Check if all hosts are seeing the same LUNs size.
    Map<String, List<VDS>> lunToFailedVDS = getFailedLuns(lunToVds);
    if (!lunToFailedVDS.isEmpty()) {
        deviceSizeVisibilityError = true;
        List<String> failedVds = new ArrayList<>();
        for (Map.Entry<String, List<VDS>> entry : lunToFailedVDS.entrySet()) {
            String lunId = entry.getKey();
            List<VDS> vdsList = entry.getValue();
            log.error("Failed to refresh device " + lunId + " Not all VDS are seeing the same size " + "VDS :" + vdsList);
            String vdsListString = StringUtils.join(Entities.objectNames(vdsList), ", ");
            failedVds.add("LUN : " + lunId + "VDS: " + vdsListString);
        }
        throw new VdcBLLException(VdcBllErrors.REFRESH_LUN_ERROR, "Failed to refresh LUNs. Not all VDS are seeing the same size: " + failedVds);
    }
    // Call PVs resize on SPM
    resizePVs(lunsToRefresh);
    // Update storage domain size
    updateStorageDomainData();
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Active);
    setSucceeded(true);
}
#end_block

#method_before
private void updateStorageDomainData() {
    VDSReturnValue returnValueUpdatedStorageDomain = getStatsForDomain();
    if (returnValueUpdatedStorageDomain.getSucceeded()) {
        StorageDomain updatedStorageDomain = (StorageDomain) returnValueUpdatedStorageDomain.getReturnValue();
        updateStorageDomain(updatedStorageDomain);
    }
}
#method_after
private void updateStorageDomainData() {
    VDSReturnValue returnValueUpdatedStorageDomain = getStatsForDomain();
    StorageDomain updatedStorageDomain = (StorageDomain) returnValueUpdatedStorageDomain.getReturnValue();
    updateStorageDomain(updatedStorageDomain);
}
#end_block

#method_before
protected VDSReturnValue getStatsForDomain() {
    VDS spmVds = LinqUtils.first(LinqUtils.filter(getAllRunningVdssInPool(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            return vds.getSpmStatus() == VdsSpmStatus.SPM;
        }
    }));
    return runVdsCommand(VDSCommandType.GetStorageDomainStats, new GetStorageDomainStatsVDSCommandParameters(spmVds.getId(), getParameters().getStorageDomainId()));
}
#method_after
protected VDSReturnValue getStatsForDomain() {
    VDS vds = LinqUtils.first(getAllRunningVdssInPool());
    return runVdsCommand(VDSCommandType.GetStorageDomainStats, new GetStorageDomainStatsVDSCommandParameters(vds.getId(), getParameters().getStorageDomainId()));
}
#end_block

#method_before
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageDomain> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final StorageEventListModel storageEventListModel, final PermissionListModel<StorageDomain> permissionListModel) {
    generalModel.setIsAvailable(false);
    dcListModel.setIsAvailable(false);
    this.vmBackupModel.setIsAvailable(false);
    this.templateBackupModel.setIsAvailable(false);
    vmRegisterListModel.setIsAvailable(false);
    templateRegisterListModel.setIsAvailable(false);
    vmListModel.setIsAvailable(false);
    templateListModel.setIsAvailable(false);
    isoListModel.setIsAvailable(false);
    diskListModel.setIsAvailable(false);
    registerDiskListModel.setIsAvailable(false);
    snapshotListModel.setIsAvailable(false);
    this.diskProfileListModel.setIsAvailable(false);
    List<HasEntity<StorageDomain>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(dcListModel);
    list.add(vmBackupModel);
    list.add(templateBackupModel);
    list.add(vmRegisterListModel);
    list.add(templateRegisterListModel);
    list.add(vmListModel);
    list.add(templateListModel);
    list.add(isoListModel);
    list.add(diskListModel);
    list.add(registerDiskListModel);
    list.add(snapshotListModel);
    list.add(this.diskProfileListModel);
    list.add(storageEventListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStoragePropertiesEditable = model.isStorageNotLocked() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageNameEditable);
    model.getDescription().setIsChangable(isStoragePropertiesEditable);
    model.getComment().setIsChangable(isStoragePropertiesEditable);
    model.getWipeAfterDelete().setIsChangable(isStoragePropertiesEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageNameEditable || isStoragePropertiesEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageNameEditable = isStorageNameEditable || isPathEditable;
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageNameEditable || isStoragePropertiesEditable) {
        // $NON-NLS-1$
        command = UICommand.createDefaultOkUiCommand("OnSave", this);
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    model.setHelpTag(HelpTag.edit_domain);
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangeable(false);
    model.getFormat().setIsChangeable(false);
    boolean isStorageNameEditable = model.isStorageActive() || model.isNewStorage();
    boolean isStoragePropertiesEditable = model.isStorageNotLocked() || model.isNewStorage();
    model.getHost().setIsChangeable(false);
    model.getName().setIsChangeable(isStorageNameEditable);
    model.getDescription().setIsChangeable(isStoragePropertiesEditable);
    model.getComment().setIsChangeable(isStoragePropertiesEditable);
    model.getWipeAfterDelete().setIsChangeable(isStoragePropertiesEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangeable(false);
    model.setIsChangeable(isStorageNameEditable || isStoragePropertiesEditable);
    model.getWarningLowSpaceIndicator().setEntity(storage.getWarningLowSpaceIndicator());
    model.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(storage.getWarningLowSpaceSize()));
    model.getWarningLowSpaceSize().setIsAvailable(true);
    model.getCriticalSpaceActionBlocker().setEntity(storage.getCriticalSpaceActionBlocker());
    boolean isPathEditable = isPathEditable(storage);
    isStorageNameEditable = isStorageNameEditable || isPathEditable;
    IStorageModel item = prepareStorageForEdit(storage, model);
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangeable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageNameEditable || isStoragePropertiesEditable) {
        // $NON-NLS-1$
        command = UICommand.createDefaultOkUiCommand("OnSave", this);
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    model.setHelpTag(HelpTag.destroy_storage_domain);
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(getSelectedItem().getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangable(true);
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnDestroy", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void destroy() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().destroyStorageDomainTitle());
    model.setHelpTag(HelpTag.destroy_storage_domain);
    // $NON-NLS-1$
    model.setHashName("destroy_storage_domain");
    ArrayList<String> items = new ArrayList<String>();
    items.add(getSelectedItem().getStorageName());
    model.setItems(items);
    model.getLatch().setIsAvailable(true);
    model.getLatch().setIsChangeable(true);
    UICommand command;
    // $NON-NLS-1$
    command = UICommand.createDefaultOkUiCommand("OnDestroy", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage);
        snapshotListModel.setIsAvailable(isDataStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        StorageDomain storage = getSelectedItem();
        boolean isBackupStorage = storage.getStorageDomainType() == StorageDomainType.ImportExport;
        boolean isDataStorage = storage.getStorageDomainType().isDataDomain();
        boolean isImageStorage = storage.getStorageDomainType() == StorageDomainType.Image || storage.getStorageDomainType() == StorageDomainType.ISO;
        boolean isDataCenterAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isGeneralAvailable = storage.getStorageType() != StorageType.GLANCE;
        boolean isCinderStorage = storage.getStorageType().isCinderDomain();
        boolean isRegsiterEntityListModelSelected = getActiveDetailModel() == vmRegisterListModel || getActiveDetailModel() == templateRegisterListModel;
        boolean isRegisterSubtabsAvailable = isDataStorage && (storage.isContainsUnregisteredEntities() || isRegsiterEntityListModelSelected);
        generalModel.setIsAvailable(isGeneralAvailable);
        dcListModel.setIsAvailable(isDataCenterAvailable);
        vmBackupModel.setIsAvailable(isBackupStorage);
        templateBackupModel.setIsAvailable(isBackupStorage);
        vmListModel.setIsAvailable(isDataStorage);
        templateListModel.setIsAvailable(isDataStorage);
        vmRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        templateRegisterListModel.setIsAvailable(isRegisterSubtabsAvailable);
        diskListModel.setIsAvailable(isDataStorage || isCinderStorage);
        registerDiskListModel.setIsAvailable(isCinderStorage);
        snapshotListModel.setIsAvailable(isDataStorage);
        diskProfileListModel.setIsAvailable(isDataStorage);
        isoListModel.setIsAvailable(isImageStorage);
    }
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    storageDomain.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewPosixStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    storageDomain.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewNfsStorage();
                }
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    storageDomain.setStorageType(isNew ? storageModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? storageModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getSelectedItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                StorageListModel storageListModel = (StorageListModel) target;
                ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
                if (storages != null && storages.size() > 0) {
                    handleDomainAlreadyExists(storageListModel, storages);
                } else {
                    storageListModel.saveNewLocalStorage();
                }
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setStorageName(model.getName().getEntity());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    storageDomain.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
                boolean force = sanStorageModel.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                ArrayList<String> lunIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunIds, force), null, this);
                }
                ArrayList<String> lunToRefreshIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#method_after
private void saveSanStorage(TaskContext context) {
    this.context = context;
    StorageModel model = (StorageModel) getWindow();
    SanStorageModel sanModel = (SanStorageModel) model.getSelectedItem();
    StorageDomain storage = getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(storage.getStorageStaticData());
    storageDomain.setStorageType(isNew ? sanModel.getType() : storageDomain.getStorageType());
    storageDomain.setStorageDomainType(isNew ? sanModel.getRole() : storageDomain.getStorageDomainType());
    storageDomain.setStorageFormat(isNew ? sanModel.getContainer().getFormat().getSelectedItem() : storageDomain.getStorageFormat());
    storageDomain.setDescription(model.getDescription().getEntity());
    storageDomain.setComment(model.getComment().getEntity());
    saveCommonStorageProperties(model);
    if (isNew) {
        saveNewSanStorage();
    } else {
        Frontend.getInstance().runAction(VdcActionType.UpdateStorageDomain, new StorageDomainManagementParameter(storageDomain), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                StorageListModel storageListModel = (StorageListModel) result.getState();
                StorageModel storageModel = (StorageModel) getWindow();
                SanStorageModel sanStorageModel = (SanStorageModel) storageModel.getSelectedItem();
                boolean force = sanStorageModel.isForce();
                StorageDomain storageDomain1 = storageListModel.getSelectedItem();
                ArrayList<String> lunIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getAddedLuns()) {
                    lunIds.add(lun.getLunId());
                }
                if (lunIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.ExtendSANStorageDomain, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunIds, force), null, this);
                }
                ArrayList<String> lunToRefreshIds = new ArrayList<String>();
                for (LunModel lun : sanStorageModel.getLunsToRefresh()) {
                    lunToRefreshIds.add(lun.getLunId());
                }
                if (lunToRefreshIds.size() > 0) {
                    Frontend.getInstance().runAction(VdcActionType.RefreshLunsSize, new ExtendSANStorageDomainParameters(storageDomain1.getId(), lunToRefreshIds, false), null, this);
                }
                storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
            }
        }, this);
    }
}
#end_block

#method_before
private void onImportSanDomainApprove() {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    hostId = (Guid) data.get(1);
    ImportSanStorageModel importSanStorageModel = (ImportSanStorageModel) storageModel;
    final List<StorageDomain> storageDomains = importSanStorageModel.getStorageDomains().getSelectedItems();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    List<IFrontendActionAsyncCallback> callbacks = new LinkedList<IFrontendActionAsyncCallback>();
    for (final StorageDomain storageDomain : storageDomains) {
        storageDomain.setWipeAfterDelete(((StorageModel) getWindow()).getWipeAfterDelete().getEntity());
        StorageDomainManagementParameter parameters = new StorageDomainManagementParameter(storageDomain.getStorageStaticData());
        parameters.setVdsId(hostId);
        parametersList.add(parameters);
        callbacks.add(new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                boolean success = returnValue != null && returnValue.getSucceeded();
                if (success) {
                    StorageModel model = (StorageModel) getWindow();
                    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                    if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                        attachStorageToDataCenter(storageDomain.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    }
                    boolean isLastDomain = storageDomain == storageDomains.get(storageDomains.size() - 1);
                    if (isLastDomain) {
                        onFinish(context, true, storageModel);
                    }
                } else {
                    onFinish(context, false, storageModel);
                }
            }
        });
    }
    Frontend.getInstance().runMultipleActions(VdcActionType.AddExistingBlockStorageDomain, parametersList, callbacks);
}
#method_after
private void onImportSanDomainApprove() {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    hostId = (Guid) data.get(1);
    ImportSanStorageModel importSanStorageModel = (ImportSanStorageModel) storageModel;
    final List<StorageDomain> storageDomains = importSanStorageModel.getStorageDomains().getSelectedItems();
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    List<IFrontendActionAsyncCallback> callbacks = new LinkedList<IFrontendActionAsyncCallback>();
    for (final StorageDomain storageDomain : storageDomains) {
        StorageDomainStatic staticData = storageDomain.getStorageStaticData();
        saveDefaultedStorageProperties((StorageModel) getWindow(), staticData);
        StorageDomainManagementParameter parameters = new StorageDomainManagementParameter(staticData);
        parameters.setVdsId(hostId);
        parametersList.add(parameters);
        callbacks.add(new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                VdcReturnValueBase returnValue = result.getReturnValue();
                boolean success = returnValue != null && returnValue.getSucceeded();
                if (success) {
                    StorageModel model = (StorageModel) getWindow();
                    StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                    if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                        attachStorageToDataCenter(storageDomain.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    }
                    boolean isLastDomain = storageDomain == storageDomains.get(storageDomains.size() - 1);
                    if (isLastDomain) {
                        onFinish(context, true, storageModel);
                    }
                } else {
                    onFinish(context, false, storageModel);
                }
            }
        });
    }
    Frontend.getInstance().runMultipleActions(VdcActionType.AddExistingBlockStorageDomain, parametersList, callbacks);
}
#end_block

#method_before
public void importFileStoragePostInit() {
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setconnection(storageListModel.path);
                tempVar.setstorage_type(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (nfsModel.getOverride().getEntity()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), null, path);
}
#method_after
public void importFileStoragePostInit() {
    Guid storagePoolId = null;
    StoragePool dataCenter = storageModel.getContainer().getDataCenter().getSelectedItem();
    if (dataCenter != null && !dataCenter.getId().equals(Guid.Empty)) {
        storagePoolId = dataCenter.getId();
    }
    // Check storage domain existence
    AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageListModel storageListModel = (StorageListModel) target;
            ArrayList<StorageDomain> storages = (ArrayList<StorageDomain>) returnValue;
            if (storages != null && storages.size() > 0) {
                String storageName = storages.get(0).getStorageName();
                onFinish(storageListModel.context, false, storageListModel.storageModel, ConstantsManager.getInstance().getMessages().importFailedDomainAlreadyExistStorageMsg(storageName));
            } else {
                StorageServerConnections tempVar = new StorageServerConnections();
                storageModel = storageListModel.storageModel;
                tempVar.setconnection(storageListModel.path);
                tempVar.setstorage_type(storageListModel.storageType);
                if (storageModel instanceof NfsStorageModel) {
                    NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
                    if (nfsModel.getOverride().getEntity()) {
                        tempVar.setNfsVersion((NfsVersion) ((EntityModel) nfsModel.getVersion().getSelectedItem()).getEntity());
                        tempVar.setNfsRetrans(nfsModel.getRetransmissions().asConvertible().nullableShort());
                        tempVar.setNfsTimeo(nfsModel.getTimeout().asConvertible().nullableShort());
                    }
                }
                if (storageModel instanceof PosixStorageModel) {
                    PosixStorageModel posixModel = (PosixStorageModel) storageModel;
                    tempVar.setVfsType(posixModel.getVfsType().getEntity());
                    tempVar.setMountOptions(posixModel.getMountOptions().getEntity());
                }
                storageListModel.fileConnection = tempVar;
                importFileStorageConnect();
            }
        }
    }), storagePoolId, path);
}
#end_block

#method_before
public void addExistingFileStorageDomain() {
    StorageDomain sdToAdd = Linq.firstOrDefault(storageDomainsToAdd);
    sdToAdd.setWipeAfterDelete(((StorageModel) getWindow()).getWipeAfterDelete().getEntity());
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
                cleanConnection(fileConnection, hostId);
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void addExistingFileStorageDomain() {
    StorageDomain sdToAdd = Linq.firstOrDefault(storageDomainsToAdd);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    saveDefaultedStorageProperties((StorageModel) getWindow(), sdsToAdd);
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.getInstance().runAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId(), model.getActivateDomain().getEntity());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
                cleanConnection(fileConnection, hostId);
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
private int getAdditionalAvailableSize(LUNs lun) {
    int additionalAvailableSize = lun.getDeviceSize() - lun.getPvSize() - 1;
    if (additionalAvailableSize < 0) {
        additionalAvailableSize = 0;
    }
    return additionalAvailableSize;
}
#method_after
private int getAdditionalAvailableSize(LUNs lun) {
    // The PV size is always smaller by 1 GB from the device due to LVM metadata
    int additionalAvailableSize = lun.getDeviceSize() - lun.getPvSize() - 1;
    if (additionalAvailableSize < 0) {
        additionalAvailableSize = 0;
    }
    return additionalAvailableSize;
}
#end_block

#method_before
public ArrayList<LunModel> getLunsToRefresh() {
    ArrayList<LunModel> luns = new ArrayList<LunModel>();
    if (!getIsGrouppedByTarget()) {
        List<LunModel> items = (List<LunModel>) getItems();
        for (LunModel lun : items) {
            if (lun.getIsIncluded() && lun.isAdditionalAvailableSizeSelected() && Linq.firstOrDefault(luns, new Linq.LunPredicate(lun)) == null) {
                luns.add(lun);
            }
        }
    }
    return luns;
}
#method_after
public ArrayList<LunModel> getLunsToRefresh() {
    ArrayList<LunModel> luns = new ArrayList<LunModel>();
    if (!getIsGrouppedByTarget()) {
        List<LunModel> items = (List<LunModel>) getItems();
        for (LunModel lun : items) {
            if (lun.getIsIncluded()) {
                if (lun.isAdditionalAvailableSizeSelected() && Linq.firstOrDefault(luns, new Linq.LunPredicate(lun)) == null) {
                    luns.add(lun);
                }
            }
        }
    }
    return luns;
}
#end_block

#method_before
protected boolean unregisterLibvirtSecrets(StorageDomain storageDomain, Guid vdsId) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vdsId, libvirtSecretsUuids));
        } catch (RuntimeException e) {
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean unregisterLibvirtSecrets(StorageDomain storageDomain, Guid vdsId) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vdsId, libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static Map<String, String> createStructFromLibvirtSecret(LibvirtSecret libvirtSecret) {
    HashMap<String, String> con = new HashMap<>();
    con.put("uuid", libvirtSecret.getId().toString());
    con.put("password", libvirtSecret.getValue());
    con.put("description", libvirtSecret.getDescription());
    con.put("usageType", libvirtSecret.getUsageType().name());
    con.put("usageID", String.format("ovirt/%s/%s", libvirtSecret.getProviderId(), libvirtSecret.getId()));
    return con;
}
#method_after
public static Map<String, String> createStructFromLibvirtSecret(LibvirtSecret libvirtSecret) {
    HashMap<String, String> con = new HashMap<>();
    con.put("uuid", libvirtSecret.getId().toString());
    con.put("password", libvirtSecret.getValue());
    con.put("description", libvirtSecret.getDescription() != null ? libvirtSecret.getDescription() : StringUtils.EMPTY);
    con.put("usageType", libvirtSecret.getUsageType().name().toLowerCase());
    con.put("usageID", String.format("%s/%s/%s", VdsProperties.Ovirt, libvirtSecret.getProviderId(), libvirtSecret.getId()));
    return con;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName, partial);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
protected boolean unregisterLibvirtSecrets(StorageDomain storageDomain, Guid vdsId) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vdsId, libvirtSecretsUuids));
        } catch (RuntimeException e) {
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
protected boolean unregisterLibvirtSecrets(StorageDomain storageDomain, Guid vdsId) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vdsId, libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(LibvirtSecret entity) {
    return createIdParameterMapper(entity.getId()).addValue("secret_value", DbFacadeUtils.encryptPassword(entity.getValue())).addValue("secret_usage_type", entity.getUsageType()).addValue("secret_description", entity.getDescription()).addValue("provider_id", entity.getProviderId()).addValue("creation_date", entity.getCreationDate());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(LibvirtSecret entity) {
    return createIdParameterMapper(entity.getId()).addValue("secret_value", DbFacadeUtils.encryptPassword(entity.getValue())).addValue("secret_usage_type", entity.getUsageType()).addValue("secret_description", entity.getDescription()).addValue("provider_id", entity.getProviderId()).addValue("_create_date", entity.getCreationDate());
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid uuid) {
    return getCustomMapSqlParameterSource().addValue("secret_uuid", uuid);
}
#method_after
@Override
protected MapSqlParameterSource createIdParameterMapper(Guid uuid) {
    return getCustomMapSqlParameterSource().addValue("secret_id", uuid);
}
#end_block

#method_before
@Override
public LibvirtSecret mapRow(ResultSet rs, int rowNum) throws SQLException {
    LibvirtSecret entity = new LibvirtSecret();
    entity.setId(getGuid(rs, "secret_uuid"));
    entity.setValue(DbFacadeUtils.decryptPassword(rs.getString("secret_value")));
    entity.setUsageType(LibvirtSecretUsageType.forValue(rs.getInt(("secret_usage_type"))));
    entity.setDescription(rs.getString("secret_description"));
    entity.setProviderId(getGuid(rs, "provider_id"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    return entity;
}
#method_after
@Override
public LibvirtSecret mapRow(ResultSet rs, int rowNum) throws SQLException {
    LibvirtSecret entity = new LibvirtSecret();
    entity.setId(getGuid(rs, "secret_id"));
    entity.setValue(DbFacadeUtils.decryptPassword(rs.getString("secret_value")));
    entity.setUsageType(LibvirtSecretUsageType.forValue(rs.getInt(("secret_usage_type"))));
    entity.setDescription(rs.getString("secret_description"));
    entity.setProviderId(getGuid(rs, "provider_id"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("_create_date")));
    return entity;
}
#end_block

#method_before
@Override
public List<LibvirtSecret> getAllByStoragePoolIdFilteredByActiveStorageDomains(Guid storagePoolId) {
    return getCallsHandler().executeReadList("GetAllLibvirtSecretsAllByStoragePoolIdFilteredByActiveDomains", LibvirtSecretRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId));
}
#method_after
@Override
public List<LibvirtSecret> getAllByStoragePoolIdFilteredByActiveStorageDomains(Guid storagePoolId) {
    return getCallsHandler().executeReadList("GetLibvirtSecretsByPoolIdOnActiveDomains", LibvirtSecretRowMapper.instance, getCustomMapSqlParameterSource().addValue("storage_pool_id", storagePoolId));
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName, partial);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets, clearUnusedSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.registerSecrets(libvirtSecrets, clearUnusedSecrets);
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#method_after
public static boolean unregisterLibvirtSecrets(StorageDomain storageDomain, VDS vds, List<LibvirtSecret> libvirtSecrets) {
    List<Guid> libvirtSecretsUuids = Entities.getIds(libvirtSecrets);
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue;
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UnregisterLibvirtSecrets, new UnregisterLibvirtSecretsVDSParameters(vds.getId(), libvirtSecretsUuids));
        } catch (RuntimeException e) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return false;
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_UNREGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to unregister libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
protected Pair<Boolean, VdcFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    if (!libvirtSecrets.isEmpty()) {
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vdsId, libvirtSecrets));
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            VdcFault vdcFault = new VdcFault();
            vdcFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, vdcFault);
        }
    }
    return new Pair<>(true, null);
}
#method_after
@Override
protected Pair<Boolean, VdcFault> runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type) {
    Provider provider = getProviderDao().get(Guid.createGuidFromString(storageDomain.getStorage()));
    VDS vds = getVdsDao().get(vdsId);
    List<LibvirtSecret> libvirtSecrets = getLibvirtSecretDao().getAllByProviderId(provider.getId());
    VDSReturnValue returnValue;
    if (!libvirtSecrets.isEmpty()) {
        try {
            returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RegisterLibvirtSecrets, new RegisterLibvirtSecretsVDSParameters(vdsId, libvirtSecrets));
        } catch (RuntimeException e) {
            log.error("Failed to register libvirt secret for storage domain {} on vds {}. Error: {}", storageDomain.getName(), vds.getName(), e.getMessage());
            log.debug("Exception", e);
            return new Pair<>(false, null);
        }
        if (!returnValue.getSucceeded()) {
            addMessageToAuditLog(AuditLogType.FAILED_TO_REGISTER_LIBVIRT_SECRET, storageDomain.getName(), vds.getName());
            log.error("Failed to register libvirt secret for storage domain {} on vds {}.", storageDomain.getName(), vds.getName());
            VdcFault vdcFault = new VdcFault();
            vdcFault.setError(returnValue.getVdsError().getCode());
            return new Pair<>(false, vdcFault);
        }
    }
    return new Pair<>(true, null);
}
#end_block

#method_before
@Override
public void edit(StorageModel object) {
    driver.edit(object);
    final StorageModel storageModel = object;
    storageModel.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // Reveal the appropriate storage view according to the selected storage type
            revealStorageView(storageModel);
        }
    });
    storageModel.getDataCenterAlert().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            datacenterAlertIcon.setVisible(storageModel.getDataCenterAlert().getIsAvailable());
            datacenterAlertIcon.setTitle(storageModel.getDataCenterAlert().getEntity());
        }
    });
    warningLowSpaceIndicatorEditor.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            storageModel.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(getWarningLowSpaceSize(storageModel)));
        }
    });
}
#method_after
@Override
public void edit(StorageModel object) {
    driver.edit(object);
    final StorageModel storageModel = object;
    storageModel.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // Reveal the appropriate storage view according to the selected storage type
            revealStorageView(storageModel);
        }
    });
    storageModel.getDataCenterAlert().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            datacenterAlertIcon.setVisible(storageModel.getDataCenterAlert().getIsAvailable());
            datacenterAlertIcon.setTitle(storageModel.getDataCenterAlert().getEntity());
        }
    });
    warningLowSpaceIndicatorEditor.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            if (!storageModel.isNewStorage()) {
                storageModel.getWarningLowSpaceSize().setEntity(ConstantsManager.getInstance().getMessages().bracketsWithGB(getWarningLowSpaceSize(storageModel)));
            }
        }
    });
}
#end_block

#method_before
private Integer getWarningLowSpaceSize(StorageModel storageModel) {
    if (!storageModel.isNewStorage()) {
        Integer percentageValue = warningLowSpaceIndicatorEditor.asValueBox().getValue();
        return percentageValue == null ? 0 : storageModel.getStorage().getTotalDiskSize() * percentageValue / 100;
    }
    // This is mot visible, hence meaningless.
    return 0;
}
#method_after
private Integer getWarningLowSpaceSize(StorageModel storageModel) {
    Integer percentageValue = warningLowSpaceIndicatorEditor.asValueBox().getValue();
    return percentageValue == null ? 0 : storageModel.getStorage().getTotalDiskSize() * percentageValue / 100;
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<LibvirtSecretModel> secrets = getSelectedItems() != null ? Linq.<LibvirtSecretModel>cast(getSelectedItems()) : new ArrayList<LibvirtSecretModel>();
    getEditCommand().setIsExecutionAllowed(secrets.size() > 0);
    getRemoveCommand().setIsExecutionAllowed(secrets.size() > 0);
}
#method_after
private void updateActionAvailability() {
    ArrayList<LibvirtSecretModel> secrets = getSelectedItems() != null ? Linq.<LibvirtSecretModel>cast(getSelectedItems()) : new ArrayList<LibvirtSecretModel>();
    getEditCommand().setIsExecutionAllowed(secrets.size() == 1);
    getRemoveCommand().setIsExecutionAllowed(secrets.size() > 0);
}
#end_block

#method_before
@Mapping(from = OpenstackVolumeAuthenticationKey.class, to = LibvirtSecret.class)
public static LibvirtSecret map(OpenstackVolumeAuthenticationKey model, LibvirtSecret template) {
    LibvirtSecret entity = template != null ? template : new LibvirtSecret();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetUuid()) {
        entity.setId(GuidUtils.asGuid(model.getUuid()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetValue()) {
        entity.setValue(model.getValue());
    }
    if (model.isSetUsageType()) {
        OpenstackVolumeAuthenticationKeyUsageType usageType = OpenstackVolumeAuthenticationKeyUsageType.fromValue(model.getUsageType());
        if (usageType != null) {
            entity.setUsageType(map(usageType, null));
        }
    }
    if (model.isSetOpenstackVolumeProvider()) {
        entity.setProviderId(GuidUtils.asGuid(model.getOpenstackVolumeProvider().getId()));
    }
    return entity;
}
#method_after
@Mapping(from = OpenstackVolumeAuthenticationKey.class, to = LibvirtSecret.class)
public static LibvirtSecret map(OpenstackVolumeAuthenticationKey model, LibvirtSecret template) {
    LibvirtSecret entity = template != null ? template : new LibvirtSecret();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetUuid()) {
        entity.setId(GuidUtils.asGuid(model.getUuid()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetValue()) {
        entity.setValue(model.getValue());
    }
    if (model.isSetUsageType()) {
        OpenstackVolumeAuthenticationKeyUsageType usageType = OpenstackVolumeAuthenticationKeyUsageType.fromValue(model.getUsageType());
        if (usageType != null) {
            entity.setUsageType(map(usageType, null));
        }
    }
    if (model.isSetOpenstackVolumeProvider() && model.getOpenstackVolumeProvider().isSetId()) {
        entity.setProviderId(GuidUtils.asGuid(model.getOpenstackVolumeProvider().getId()));
    }
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (removeImages()) {
        if (getParameters().getSnapshot().getType() != SnapshotType.REGULAR) {
            getImage().setActive(true);
            getImageDao().update(getImage().getImage());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    setStorageDomainId(getParameters().getStorageDomainId());
    if (isRemoveEntireDisk()) {
        removeEntireDisk();
    } else {
        removeCinderVolume();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    for (CinderDisk cinderDisk : getParameters().getCinderDisks()) {
        ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(cinderDisk.getImageId(), getParameters().getVmId(), getParameters().getSnapshot(), getParameters().getRemovedSnapshotId());
        params.setParentCommand(getActionType());
        params.setStorageDomainId(cinderDisk.getStorageIds().get(0));
        params.setParentParameters(getParameters());
        if (getParameters().getSnapshot().getType() != Snapshot.SnapshotType.REGULAR) {
            cinderDisk.setActive(true);
            getImageDao().update(cinderDisk.getImage());
        }
        restoreCinderDisk(cinderDisk, params);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    for (CinderDisk cinderDisk : getParameters().getCinderDisks()) {
        ImagesContainterParametersBase params = getRestoreFromSnapshotParams(cinderDisk);
        restoreCinderDisk(cinderDisk, params);
        // In case we want to undo the previewed snapshot.
        if (getParameters().getSnapshot().getType() != Snapshot.SnapshotType.REGULAR) {
            cinderDisk.setActive(true);
            getImageDao().update(cinderDisk.getImage());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private VdcReturnValueBase restoreCinderDisk(CinderDisk cinderDisk, ImagesContainterParametersBase params) {
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RestoreFromCinderSnapshot, params, cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, cinderDisk.getStorageIds().get(0)));
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
private VdcReturnValueBase restoreCinderDisk(CinderDisk cinderDisk, ImagesContainterParametersBase params) {
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RestoreFromCinderSnapshot, params, cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, cinderDisk.getStorageIds().get(0)));
    try {
        return future.get();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
        log.error("Error restoring snapshot");
    }
    return null;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = true;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisks.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    if (!cinderDisks.isEmpty() && !restoreAllCinderDisks(cinderDisks, removedSnapshotId)) {
        log.error("Error deleting unused Cinder volumes to restore snapshots");
    }
    removeSnapshotsFromDB();
    removeUnusedImages();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = true;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisks.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    if (!restoreCinder(cinderDisks, removedSnapshotId)) {
        log.error("Error to restore Cinder volumes snapshots");
    }
    removeSnapshotsFromDB();
    removeUnusedImages();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    Set<Guid> deletedDisksIds = new HashSet<>();
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisks.add((CinderDisk) image);
                noImagesRemovedYet = false;
                continue;
            }
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
    if (!cinderDisks.isEmpty() && !restoreAllCinderDisks(cinderDisks, null)) {
        log.error("Error deleting orphaned Cinder volumes to restore snapshots");
    }
}
#method_after
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    Set<Guid> deletedDisksIds = new HashSet<>();
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisks.add((CinderDisk) image);
                noImagesRemovedYet = false;
                continue;
            }
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
    if (!restoreCinder(cinderDisks, null)) {
        log.error("Error deleting orphaned Cinder volumes to restore snapshots");
    }
}
#end_block

#method_before
private void removeUnusedImages() {
    Set<Guid> imageIdsUsedByActiveSnapshot = new HashSet<>();
    for (DiskImage diskImage : getImagesList()) {
        imageIdsUsedByActiveSnapshot.add(diskImage.getId());
    }
    List<DiskImage> imagesToRemove = new ArrayList<>();
    for (Guid snapshotToRemove : snapshotsToRemove) {
        List<DiskImage> snapshotDiskImages = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotToRemove);
        imagesToRemove.addAll(snapshotDiskImages);
    }
    Set<Guid> removeInProcessImageIds = new HashSet<>();
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage diskImage : imagesToRemove) {
        if (imageIdsUsedByActiveSnapshot.contains(diskImage.getId()) || removeInProcessImageIds.contains(diskImage.getId())) {
            continue;
        }
        if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) diskImage);
            continue;
        }
        VdcReturnValueBase retValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(diskImage.getImageId()));
        if (retValue.getSucceeded()) {
            removeInProcessImageIds.add(diskImage.getImageId());
        } else {
            log.error("Failed to remove image '{}'", diskImage.getImageId());
        }
    }
    if (!cinderDisks.isEmpty() && !restoreAllCinderDisks(cinderDisks, null)) {
        log.error("Error deleting unused Cinder volumes to restore snapshots");
    }
}
#method_after
private void removeUnusedImages() {
    Set<Guid> imageIdsUsedByActiveSnapshot = new HashSet<>();
    for (DiskImage diskImage : getImagesList()) {
        imageIdsUsedByActiveSnapshot.add(diskImage.getId());
    }
    List<DiskImage> imagesToRemove = new ArrayList<>();
    for (Guid snapshotToRemove : snapshotsToRemove) {
        List<DiskImage> snapshotDiskImages = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotToRemove);
        imagesToRemove.addAll(snapshotDiskImages);
    }
    Set<Guid> removeInProcessImageIds = new HashSet<>();
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (DiskImage diskImage : imagesToRemove) {
        if (imageIdsUsedByActiveSnapshot.contains(diskImage.getId()) || removeInProcessImageIds.contains(diskImage.getId())) {
            continue;
        }
        if (diskImage.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) diskImage);
            continue;
        }
        VdcReturnValueBase retValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(diskImage.getImageId()));
        if (retValue.getSucceeded()) {
            removeInProcessImageIds.add(diskImage.getImageId());
        } else {
            log.error("Failed to remove image '{}'", diskImage.getImageId());
        }
    }
    if (!restoreCinder(cinderDisks, null)) {
        log.error("Error to restore Cinder volumes snapshots");
    }
}
#end_block

