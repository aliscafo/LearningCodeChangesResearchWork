609
#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
        reDetectDefaultsForDeprecatedCPUs();
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationUtils.updateEntity(getParameters().getCluster(), oldCluster, clusterDao, getCompensationContext());
        addOrUpdateAddtionalClusterFeatures();
        getCompensationContext().stateChanged();
        return null;
    });
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            parameters.setCompensationEnabled(true);
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextWithNoCleanupCompensation());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        TransactionSupport.executeInNewTransaction(() -> {
            final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
            CompensationUtils.saveEntity(managementNetworkCluster, networkClusterDao, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        });
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    // Executing the rest of the command in one transaction.
    // This avoids using compensation context inside functions
    // called here, which would be tricky.
    // 
    // If anything fails, this transaction is not committed and
    // changes committed before this block are reverted using compensation.
    TransactionSupport.executeInNewTransaction(() -> {
        updateDefaultNetworkProvider();
        if (getCluster().getFirewallType() != oldCluster.getFirewallType() || getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
            markHostsForReinstall();
        }
        if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
            // update gluster parameters on all hosts
            updateGlusterHosts();
        }
        alertIfFencingDisabled();
        boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
        if (isKsmPolicyChanged) {
            momPolicyUpdatedEvent.fire(getCluster());
        }
        if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
            vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
        }
        return null;
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setVmInitToVms();
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
        reDetectDefaultsForDeprecatedCPUs();
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationUtils.updateEntity(getParameters().getCluster(), oldCluster, clusterDao, getCompensationContext());
        addOrUpdateAddtionalClusterFeatures();
        getCompensationContext().stateChanged();
        return null;
    });
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            parameters.setCompensationEnabled(true);
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextWithNoCleanupCompensation());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        TransactionSupport.executeInNewTransaction(() -> {
            final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
            CompensationUtils.saveEntity(managementNetworkCluster, networkClusterDao, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        });
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    // Executing the rest of the command in one transaction.
    // This avoids using compensation context inside functions
    // called here, which would be tricky.
    // 
    // If anything fails, this transaction is not committed and
    // changes committed before this block are reverted using compensation.
    TransactionSupport.executeInNewTransaction(() -> {
        updateDefaultNetworkProvider();
        if (getCluster().getFirewallType() != oldCluster.getFirewallType() || getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
            markHostsForReinstall();
        }
        if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
            // update gluster parameters on all hosts
            updateGlusterHosts();
        }
        alertIfFencingDisabled();
        boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
        if (isKsmPolicyChanged) {
            momPolicyUpdatedEvent.fire(getCluster());
        }
        if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
            vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
        }
        return null;
    });
    setSucceeded(true);
}
#end_block

#method_before
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        vm.setVmInit(vmInitDao.get(vm.getId()));
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateParams.setCompensationEnabled(true);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#method_after
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateParams.setCompensationEnabled(true);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        boolean vmNonMigratable = vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST || (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && getParameters().getIsInternal());
                        // other non-migratable VMs are reported
                        if (vmNonMigratable && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    List<AsyncTask> asyncTasks = null;
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && ((asyncTasks = asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()))).size() > 0) {
                        String runningTasks = asyncTasks.stream().map(AsyncTask::toString).collect(Collectors.joining("\n"));
                        log.warn("There are running tasks on the SPM: '{}'", runningTasks);
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!validateNoActiveImageTransfers(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms, clusters.get(vds.getClusterId()).getCompatibilityVersion());
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    ActionReturnValue returnValue = getReturnValue();
    if (returnValue != null) {
        if (!returnValue.getValidationMessages().isEmpty()) {
            addMaintenanceFailedReason(returnValue.getValidationMessages());
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        boolean vmNonMigratable = vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST || (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && getParameters().getIsInternal());
                        // other non-migratable VMs are reported
                        if (vmNonMigratable && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    List<AsyncTask> asyncTasks = null;
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && ((asyncTasks = asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()))).size() > 0) {
                        String runningTasks = asyncTasks.stream().map(AsyncTask::toString).collect(Collectors.joining("\n"));
                        log.warn("There are running tasks on the SPM: '{}'", runningTasks);
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!validateNoRunningJobs(vds)) {
                        result = false;
                    } else if (!validateNoActiveImageTransfers(vds)) {
                        result = false;
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms, clusters.get(vds.getClusterId()).getCompatibilityVersion());
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    if (!result) {
        addMaintenanceFailedReason();
    }
    return result;
}
#end_block

#method_before
private void addMaintenanceFailedReason(ArrayList<String> failedMessages) {
    Guid rootCommandGuid = commandsRepository.getCommandEntity(getCommandId()).getRootCommandId();
    CommandBase<T> rootCommand = commandCoordinatorUtil.retrieveCommand(rootCommandGuid);
    rootCommand.getReturnValue().setExecuteFailedMessages(failedMessages);
}
#method_after
private void addMaintenanceFailedReason() {
    addCustomValue("Message", String.join(",", backend.getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages())));
    auditLogDirector.log(this, AuditLogType.GENERIC_ERROR_MESSAGE);
}
#end_block

#method_before
@Override
protected boolean validate() {
    Guid vdsId = getVdsId();
    VDS vds = vdsDao.get(vdsId);
    // we can get here when vds status was set already to Maintenance
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.NonResponsive && vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Error && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Down && vds.getStatus() != VDSStatus.InstallFailed) {
        return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
    }
    orderListOfRunningVmsOnVds(vdsId);
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // Check if there are available Hosted Engine hosts for that VM
            if (!HostedEngineHelper.haveHostsAvailableforHE(vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up), Collections.singletonList(vdsId))) {
                return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        if ((getParameters().isInternal() && vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE) || vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            return failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM);
        }
    }
    ActionReturnValue returnValue = getReturnValue();
    if (returnValue != null) {
        if (!returnValue.getValidationMessages().isEmpty()) {
            addMaintenanceFailedReason(returnValue.getValidationMessages());
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    boolean result = executeValidation();
    if (!result) {
        executeValidationFailure();
    }
    return result;
}
#end_block

#method_before
private void addMaintenanceFailedReason(ArrayList<String> failedMessages) {
    Guid rootCommandGuid = commandsRepository.getCommandEntity(getParameters().getParentParameters().getCommandId()).getRootCommandId();
    CommandBase<T> rootCommand = commandCoordinatorUtil.retrieveCommand(rootCommandGuid);
    rootCommand.getReturnValue().setExecuteFailedMessages(failedMessages);
}
#method_after
private void addMaintenanceFailedReason() {
    String messageToDisplay = String.join(",", backend.getErrorsTranslator().translateErrorText(getReturnValue().getValidationMessages()));
    addCustomValue("Message", messageToDisplay);
    auditLogDirector.log(this, AuditLogType.GENERIC_ERROR_MESSAGE);
}
#end_block

#method_before
@Test
public void testGetVmBootActiveSharedDisk() {
    Disk bootDiskVm1 = dao.getVmBootActiveDisk(FixturesTool.VM_VM1_SHARED_BOOTABLE_DISK);
    Disk bootDiskVm2 = dao.getVmBootActiveDisk(FixturesTool.VM_VM2_SHARED_NONBOOTABLE_DISK);
    assertNull(bootDiskVm2, "VM2 should not have a boot disk attached");
    assertNotNull(bootDiskVm1, "VM1 should have a boot disk attached");
    assertEquals(FixturesTool.BOOTABLE_SHARED_DISK_ID, bootDiskVm1.getId(), "Wrong boot disk for VM");
}
#method_after
@Test
public void testGetVmBootActiveSharedDisk() {
    Disk bootDiskVm1 = dao.getVmBootActiveDisk(FixturesTool.VM_VM1_SHARED_BOOTABLE_DISK);
    Disk bootDiskVm2 = dao.getVmBootActiveDisk(FixturesTool.VM_VM2_SHARED_NONBOOTABLE_DISK);
    assertNull(bootDiskVm2, "VM2 should not have a bootable disk attached");
    assertNotNull(bootDiskVm1, "VM1 should have a bootable disk attached");
    assertEquals(FixturesTool.BOOTABLE_SHARED_DISK_ID, bootDiskVm1.getId(), "Wrong boot disk for VM");
}
#end_block

#method_before
private void removeAutogeneratedSnapshot(CommandContext commandContext, ActionType actionType, LiveMigrateDiskParameters parameters) {
    RemoveSnapshotParameters removeSnapshotParameters = new RemoveSnapshotParameters(getParameters().getAutoGeneratedSnapshotId(), getVmId());
    removeSnapshotParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    removeSnapshotParameters.setParentCommand(actionType);
    removeSnapshotParameters.setParentParameters(parameters);
    removeSnapshotParameters.setNeedsLocking(false);
    runInternalAction(ActionType.RemoveSnapshot, removeSnapshotParameters, commandContext);
}
#method_after
private void removeAutogeneratedSnapshot(CommandContext commandContext, ActionType actionType, LiveMigrateDiskParameters parameters) {
    RemoveSnapshotParameters removeSnapshotParameters = new RemoveSnapshotParameters(getParameters().getAutoGeneratedSnapshotId(), getVmId());
    removeSnapshotParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (actionType != null) {
        removeSnapshotParameters.setParentCommand(actionType);
    }
    removeSnapshotParameters.setParentParameters(parameters);
    removeSnapshotParameters.setNeedsLocking(false);
    runInternalAction(ActionType.RemoveSnapshot, removeSnapshotParameters, commandContext);
}
#end_block

#method_before
@Test
public void testSingleMsg() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getCreationTime()).thenReturn(LocalTime.now());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|*|uuid");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    publisher.process(event);
    verify(subscriber, timeout(500).times(0)).onNext(map);
    subscription.request(1);
    verify(subscriber, timeout(500).times(1)).onNext(map);
    subscription.cancel();
    verify(subscriber, timeout(500).times(1)).onComplete();
}
#method_after
@Test
public void testSingleMsg() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getArrivalTime()).thenReturn(System.nanoTime());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|*|uuid");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    publisher.process(event);
    verify(subscriber, timeout(500).times(0)).onNext(map);
    subscription.request(1);
    verify(subscriber, timeout(500).times(1)).onNext(map);
    subscription.cancel();
    verify(subscriber, timeout(500).times(1)).onComplete();
}
#end_block

#method_before
@Test
public void testMultipleMsg() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getCreationTime()).thenReturn(LocalTime.now());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|test|*");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    subscription.request(10);
    for (int i = 0; i < 15; i++) {
        publisher.process(event);
    }
    verify(subscriber, timeout(1000).times(10)).onNext(map);
}
#method_after
@Test
public void testMultipleMsg() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getArrivalTime()).thenReturn(System.nanoTime());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|test|*");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    subscription.request(10);
    for (int i = 0; i < 15; i++) {
        publisher.process(event);
    }
    verify(subscriber, timeout(1000).times(10)).onNext(map);
}
#end_block

#method_before
@Test
public void testCancelledSubscription() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getCreationTime()).thenReturn(LocalTime.now());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|test|*");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    subscription.cancel();
    publisher.process(event);
    verify(subscriber, never()).onNext(map);
    verify(subscriber, times(1)).onComplete();
}
#method_after
@Test
public void testCancelledSubscription() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
    EventPublisher publisher = createPublisher();
    JsonRpcEvent event = mock(JsonRpcEvent.class);
    when(event.getMethod()).thenReturn("local|testcase|test|uuid");
    when(event.getArrivalTime()).thenReturn(System.nanoTime());
    EventDecomposer decomposer = mock(EventDecomposer.class);
    Map<String, Object> map = new HashMap<>();
    when(decomposer.decompose(event)).thenReturn(map);
    setField(publisher, "decomposer", decomposer);
    EventSubscriber subscriber = mock(EventSubscriber.class);
    when(subscriber.getSubscriptionId()).thenReturn("*|*|test|*");
    ArgumentCaptor<Subscription> captor = ArgumentCaptor.forClass(Subscription.class);
    publisher.subscribe(subscriber);
    verify(subscriber).onSubscribe(captor.capture());
    Subscription subscription = captor.getValue();
    subscription.cancel();
    publisher.process(event);
    verify(subscriber, never()).onNext(map);
    verify(subscriber, times(1)).onComplete();
}
#end_block

#method_before
public void putEvent(JsonRpcEvent event) {
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        event.setCreationTime(LocalTime.now().minusMinutes(1));
        this.events.addFirst(event);
        purgeOldEventsIfNotConsumed();
    }
}
#method_after
public void putEvent(JsonRpcEvent event) {
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        event.setArrivalTime(System.nanoTime());
        this.events.addFirst(event);
    }
}
#end_block

#method_before
private void purgeOldEventsIfNotConsumed() {
    LocalTime threshold = LocalTime.now().minusHours(3);
    // remove the last element if the element was created before threshold
    while (!this.events.isEmpty() && this.events.peekLast().getCreationTime().isBefore(threshold)) {
        // if the event is older than PURGE_TIME we remove the event
        this.events.removeLast();
    }
}
#method_after
public void purgeOldEventsIfNotConsumed(int eventTimeoutInHours) {
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        long threshold = System.nanoTime() - TimeUnit.HOURS.toNanos(eventTimeoutInHours);
        // remove the last element if the element was created before threshold
        while (!this.events.isEmpty() && this.events.peekLast().getArrivalTime() < threshold) {
            // if the event is older than PURGE_TIME we remove the event
            this.events.removeLast();
        }
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    boolean lockAcquired = false;
    try {
        if (canVdsBeReached()) {
            lockAcquired = lockManager.acquireLock(retrieveVdsExecutionLock()).getFirst();
            if (!lockAcquired) {
                getVDSReturnValue().setVdsError(new VDSError(EngineError.ENGINE, "Failed to acquire vds execution lock - related operation is under execution"));
                getVDSReturnValue().setSucceeded(false);
                return;
            }
            boolean performSpmStop = true;
            Map<Guid, AsyncTaskStatus> unclearedTasks = null;
            try {
                VDSReturnValue vdsReturnValue = resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(getVds().getId()));
                if (isNotSPM(vdsReturnValue)) {
                    return;
                }
                getVDSReturnValue().setSucceeded(vdsReturnValue.getSucceeded());
                getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
                if (vdsReturnValue.getReturnValue() != null) {
                    unclearedTasks = (HashMap<Guid, AsyncTaskStatus>) vdsReturnValue.getReturnValue();
                    performSpmStop = unclearedTasks.isEmpty();
                }
            } catch (Exception e) {
                performSpmStop = false;
                log.info("SpmStopVDSCommand::Could not get tasks on vds '{}': {}", getVds().getName(), e.getMessage());
                log.debug("Exception", e);
            }
            if (performSpmStop) {
                log.info("SpmStopVDSCommand::Stopping SPM on vds '{}', pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                status = getBroker().spmStop(getParameters().getStoragePoolId().toString());
                proceedProxyReturnValue();
            } else {
                getVDSReturnValue().setSucceeded(false);
                if (getVDSReturnValue().getVdsError() == null) {
                    String unclearedTasksDetails = unclearedTasks.entrySet().stream().map(entry -> String.format("Task '%s', status '%s'", entry.getKey(), entry.getValue().getStatus())).collect(Collectors.joining("\n"));
                    log.error("SpmStopVDSCommand::Not stopping SPM on vds '{}', pool id '{}' as there are uncleared tasks '{}'", getVds().getName(), getParameters().getStoragePoolId(), unclearedTasksDetails);
                    VDSError error = new VDSError(EngineError.TaskInProgress, unclearedTasksDetails);
                    getVDSReturnValue().setVdsError(error);
                    AuditLogable event = new AuditLogableImpl();
                    event.addCustomValue("vdsName", getVds().getName());
                    event.addCustomValue("poolId", getParameters().getStoragePoolId().toString());
                    event.addCustomValue("tasks", unclearedTasksDetails);
                    auditLogDirector.log(event, AuditLogType.VDS_SPM_NOT_EMPTY);
                } else if (getVDSReturnValue().getVdsError().getCode() == EngineError.VDS_NETWORK_ERROR) {
                    log.info("SpmStopVDSCommand::Could not get tasks on vds '{}' - network exception, not stopping spm! pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                }
            }
        } else {
            log.info("SpmStopVDSCommand:: vds '{}' is in '{}' status - not performing spm stop, pool id '{}'", getVds().getName(), getVds().getStatus(), getParameters().getStoragePoolId());
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Vds is in incorrect status"));
            getVDSReturnValue().setSucceeded(false);
        }
    } catch (RuntimeException exp) {
        log.warn("Could not stop spm of pool '{}' on vds '{}': {}", getParameters().getStoragePoolId(), getParameters().getVdsId(), exp.getMessage());
        log.debug("Exception", exp);
        getVDSReturnValue().setExceptionObject(exp);
        getVDSReturnValue().setSucceeded(false);
    } finally {
        if (lockAcquired) {
            lockManager.releaseLock(retrieveVdsExecutionLock());
        }
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    boolean lockAcquired = false;
    try {
        if (canVdsBeReached()) {
            lockAcquired = lockManager.acquireLock(retrieveVdsExecutionLock()).getFirst();
            if (!lockAcquired) {
                getVDSReturnValue().setVdsError(new VDSError(EngineError.ENGINE, "Failed to acquire vds execution lock - related operation is under execution"));
                getVDSReturnValue().setSucceeded(false);
                return;
            }
            boolean performSpmStop = true;
            Map<Guid, AsyncTaskStatus> unclearedTasks = null;
            try {
                VDSReturnValue vdsReturnValue = resourceManager.runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(getVds().getId()));
                if (isNotSPM(vdsReturnValue)) {
                    return;
                }
                getVDSReturnValue().setSucceeded(vdsReturnValue.getSucceeded());
                getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
                if (vdsReturnValue.getReturnValue() != null) {
                    unclearedTasks = (HashMap<Guid, AsyncTaskStatus>) vdsReturnValue.getReturnValue();
                    performSpmStop = unclearedTasks.isEmpty();
                }
            } catch (Exception e) {
                performSpmStop = false;
                log.info("SpmStopVDSCommand::Could not get tasks on vds '{}': {}", getVds().getName(), e.getMessage());
                log.debug("Exception", e);
            }
            if (performSpmStop) {
                log.info("SpmStopVDSCommand::Stopping SPM on vds '{}', pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                status = getBroker().spmStop(getParameters().getStoragePoolId().toString());
                proceedProxyReturnValue();
            } else {
                getVDSReturnValue().setSucceeded(false);
                if (getVDSReturnValue().getVdsError() == null) {
                    String unclearedTasksDetails = unclearedTasks.entrySet().stream().map(entry -> String.format("Task '%s', status '%s'", entry.getKey(), entry.getValue().getStatus())).collect(Collectors.joining("\n"));
                    log.error("SpmStopVDSCommand::Not stopping SPM on vds '{}', pool id '{}' as there are uncleared tasks '{}'", getVds().getName(), getParameters().getStoragePoolId(), unclearedTasksDetails);
                    VDSError error = new VDSError(EngineError.TaskInProgress, unclearedTasksDetails);
                    getVDSReturnValue().setVdsError(error);
                    AuditLogable event = new AuditLogableImpl();
                    event.addCustomValue("vdsName", getVds().getName());
                    event.addCustomValue("poolId", getParameters().getStoragePoolId().toString());
                    event.addCustomValue("tasks", unclearedTasksDetails);
                    auditLogDirector.log(event, AuditLogType.VDS_ALERT_NOT_STOPPING_SPM_UNCLEARED_TASKS);
                } else if (getVDSReturnValue().getVdsError().getCode() == EngineError.VDS_NETWORK_ERROR) {
                    log.info("SpmStopVDSCommand::Could not get tasks on vds '{}' - network exception, not stopping spm! pool id '{}'", getVds().getName(), getParameters().getStoragePoolId());
                }
            }
        } else {
            log.info("SpmStopVDSCommand:: vds '{}' is in '{}' status - not performing spm stop, pool id '{}'", getVds().getName(), getVds().getStatus(), getParameters().getStoragePoolId());
            getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, "Vds is in incorrect status"));
            getVDSReturnValue().setSucceeded(false);
        }
    } catch (RuntimeException exp) {
        log.warn("Could not stop spm of pool '{}' on vds '{}': {}", getParameters().getStoragePoolId(), getParameters().getVdsId(), exp.getMessage());
        log.debug("Exception", exp);
        getVDSReturnValue().setExceptionObject(exp);
        getVDSReturnValue().setSucceeded(false);
    } finally {
        if (lockAcquired) {
            lockManager.releaseLock(retrieveVdsExecutionLock());
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    Integer numericDomainFormat = Integer.valueOf(getStorageDomain().getStorageFormat().getValue());
    Optional<Boolean> haveNotSupportedVDSes = vdsDao.getAllForStoragePool(getStorageDomain().getStoragePoolId()).stream().map(VDS::getSupportedDomainVersions).map(versions -> versions.stream().filter(v -> v.equals(numericDomainFormat)).findAny()).map(vds -> !vds.isPresent()).findAny();
    if (haveNotSupportedVDSes.isPresent()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_VERSION_UNSUPPORTED);
    }
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(sdValidator.isNotIsoOrExportForBackup())) {
        return false;
    }
    ensureStorageFormatInitialized();
    if (!validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    if (!canAddDomain()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (!isSupportedByManagedBlockStorageDomain(getStorageDomain())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate() || !initializeVds() || !checkStorageDomainNameLengthValid()) {
        return false;
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO && !getStorageDomain().getStorageType().isFileDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.ISO);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ImportExport && getStorageDomain().getStorageType().isBlockDomain()) {
        addValidationMessageVariable("domainType", StorageConstants.EXPORT);
        addValidationMessageVariable("storageTypes", StorageConstants.FILE);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DOMAIN_TYPE_CAN_BE_CREATED_ONLY_ON_SPECIFIC_STORAGE_DOMAINS);
    }
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    StorageDomainValidator sdValidator = getStorageDomainValidator();
    if (!validate(sdValidator.isNotIsoOrExportForBackup())) {
        return false;
    }
    ensureStorageFormatInitialized();
    if (!validate(sdValidator.isStorageFormatCompatibleWithDomain())) {
        return false;
    }
    if (!checkDomainVersionSupport()) {
        return false;
    }
    initStorageDomainDiscardAfterDeleteIfNeeded();
    if (!validateDiscardAfterDeleteLegal(sdValidator)) {
        return false;
    }
    if (!canAddDomain()) {
        return false;
    }
    if (isStorageWithSameNameExists()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NAME_ALREADY_EXIST);
    }
    if (!isSupportedByManagedBlockStorageDomain(getStorageDomain())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public List<Integer> getSupportedDomainVersions() {
    return vdsDynamic.getSupportedDomainVersions();
}
#method_after
public Set<StorageFormatType> getSupportedDomainVersions() {
    return vdsDynamic.getSupportedDomainVersions();
}
#end_block

#method_before
public void setSupportedDomainVersions(List<Integer> supportedDomainVersions) {
    vdsDynamic.setSupportedDomainVersions(supportedDomainVersions);
}
#method_after
public void setSupportedDomainVersions(Set<StorageFormatType> supportedDomainVersions) {
    vdsDynamic.setSupportedDomainVersions(supportedDomainVersions);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    return getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getCpuCores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getCpuModel()).addValue("online_cpus", vds.getOnlineCpus()).addValue("cpu_speed_mh", vds.getCpuSpeedMh()).addValue("if_total_speed", vds.getIfTotalSpeed()).addValue("kvm_enabled", vds.getKvmEnabled()).addValue("mem_commited", vds.getMemCommited()).addValue("physical_mem_mb", vds.getPhysicalMemMb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getVmActive()).addValue("vm_count", vds.getVmCount()).addValue("vms_cores_count", vds.getVmsCoresCount()).addValue("vm_migrating", vds.getVmMigrating()).addValue("incoming_migrations", vds.getIncomingMigrations()).addValue("outgoing_migrations", vds.getOutgoingMigrations()).addValue("reserved_mem", vds.getReservedMem()).addValue("guest_overhead", vds.getGuestOverhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getSoftwareVersion()).addValue("version_name", vds.getVersionName()).addValue("build_name", vds.getBuildName()).addValue("previous_status", vds.getPreviousStatus()).addValue("cpu_flags", vds.getCpuFlags()).addValue("pending_vcpus_count", vds.getPendingVcpusCount()).addValue("pending_vmem_size", vds.getPendingVmemSize()).addValue("cpu_sockets", vds.getCpuSockets()).addValue("net_config_dirty", vds.getNetConfigDirty()).addValue("supported_cluster_levels", vds.getSupportedClusterLevels()).addValue("supported_engines", vds.getSupportedEngines()).addValue("host_os", vds.getHostOs()).addValue("kvm_version", vds.getKvmVersion()).addValue("libvirt_version", vds.getLibvirtVersion().getRpmName()).addValue("spice_version", vds.getSpiceVersion()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("librbd1_version", vds.getLibrbdVersion().getRpmName()).addValue("glusterfs_cli_version", vds.getGlusterfsCliVersion().getRpmName()).addValue("openvswitch_version", vds.getOvsVersion().getRpmName()).addValue("kernel_version", vds.getKernelVersion()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("kdump_status", vds.getKdumpStatus().getAsNumber()).addValue("selinux_enforce_mode", (vds.getSELinuxEnforceMode() != null) ? vds.getSELinuxEnforceMode().toInt() : null).addValue("auto_numa_balancing", vds.getAutoNumaBalancing().getValue()).addValue("is_numa_supported", vds.isNumaSupport()).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("maintenance_reason", vds.getMaintenanceReason()).addValue("is_update_available", vds.isUpdateAvailable()).addValue("kernel_args", vds.getKernelArgs()).addValue("is_hostdev_enabled", vds.isHostDevicePassthroughEnabled()).addValue("pretty_name", vds.getPrettyName()).addValue("hosted_engine_configured", vds.isHostedEngineConfigured()).addValue("in_fence_flow", vds.isInFenceFlow()).addValue("kernel_features", ObjectUtils.mapNullable(vds.getKernelFeatures(), JsonHelper::mapToJsonUnchecked)).addValue("vnc_encryption_enabled", vds.isVncEncryptionEnabled()).addValue("connector_info", ObjectUtils.mapNullable(vds.getConnectorInfo(), JsonHelper::mapToJsonUnchecked)).addValue("supported_domain_versions", this.createArrayOf("integer", vds.getSupportedDomainVersions().toArray()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VdsDynamic vds) {
    return getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getCpuCores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getCpuModel()).addValue("online_cpus", vds.getOnlineCpus()).addValue("cpu_speed_mh", vds.getCpuSpeedMh()).addValue("if_total_speed", vds.getIfTotalSpeed()).addValue("kvm_enabled", vds.getKvmEnabled()).addValue("mem_commited", vds.getMemCommited()).addValue("physical_mem_mb", vds.getPhysicalMemMb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getVmActive()).addValue("vm_count", vds.getVmCount()).addValue("vms_cores_count", vds.getVmsCoresCount()).addValue("vm_migrating", vds.getVmMigrating()).addValue("incoming_migrations", vds.getIncomingMigrations()).addValue("outgoing_migrations", vds.getOutgoingMigrations()).addValue("reserved_mem", vds.getReservedMem()).addValue("guest_overhead", vds.getGuestOverhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getSoftwareVersion()).addValue("version_name", vds.getVersionName()).addValue("build_name", vds.getBuildName()).addValue("previous_status", vds.getPreviousStatus()).addValue("cpu_flags", vds.getCpuFlags()).addValue("pending_vcpus_count", vds.getPendingVcpusCount()).addValue("pending_vmem_size", vds.getPendingVmemSize()).addValue("cpu_sockets", vds.getCpuSockets()).addValue("net_config_dirty", vds.getNetConfigDirty()).addValue("supported_cluster_levels", vds.getSupportedClusterLevels()).addValue("supported_engines", vds.getSupportedEngines()).addValue("host_os", vds.getHostOs()).addValue("kvm_version", vds.getKvmVersion()).addValue("libvirt_version", vds.getLibvirtVersion().getRpmName()).addValue("spice_version", vds.getSpiceVersion()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("librbd1_version", vds.getLibrbdVersion().getRpmName()).addValue("glusterfs_cli_version", vds.getGlusterfsCliVersion().getRpmName()).addValue("openvswitch_version", vds.getOvsVersion().getRpmName()).addValue("kernel_version", vds.getKernelVersion()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("kdump_status", vds.getKdumpStatus().getAsNumber()).addValue("selinux_enforce_mode", (vds.getSELinuxEnforceMode() != null) ? vds.getSELinuxEnforceMode().toInt() : null).addValue("auto_numa_balancing", vds.getAutoNumaBalancing().getValue()).addValue("is_numa_supported", vds.isNumaSupport()).addValue("supported_rng_sources", VmRngDevice.sourcesToCsv(vds.getSupportedRngSources())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("maintenance_reason", vds.getMaintenanceReason()).addValue("is_update_available", vds.isUpdateAvailable()).addValue("kernel_args", vds.getKernelArgs()).addValue("is_hostdev_enabled", vds.isHostDevicePassthroughEnabled()).addValue("pretty_name", vds.getPrettyName()).addValue("hosted_engine_configured", vds.isHostedEngineConfigured()).addValue("in_fence_flow", vds.isInFenceFlow()).addValue("kernel_features", ObjectUtils.mapNullable(vds.getKernelFeatures(), JsonHelper::mapToJsonUnchecked)).addValue("vnc_encryption_enabled", vds.isVncEncryptionEnabled()).addValue("connector_info", ObjectUtils.mapNullable(vds.getConnectorInfo(), JsonHelper::mapToJsonUnchecked)).addValue("backup_enabled", vds.isBackupEnabled()).addValue("supported_domain_versions", vds.getSupportedDomainVersionsAsString());
}
#end_block

#method_before
public List<Integer> getSupportedDomainVersions() {
    return supportedDomainVersions;
}
#method_after
public Set<StorageFormatType> getSupportedDomainVersions() {
    return supportedDomainVersions;
}
#end_block

#method_before
public void setSupportedDomainVersions(List<Integer> supportedDomainVersions) {
    this.supportedDomainVersions = supportedDomainVersions;
}
#method_after
public void setSupportedDomainVersions(Set<StorageFormatType> supportedDomainVersions) {
    this.supportedDomainVersions = supportedDomainVersions;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationUtils.updateEntity(getParameters().getCluster(), oldCluster, clusterDao, getCompensationContext());
        addOrUpdateAddtionalClusterFeatures();
        getCompensationContext().stateChanged();
        return null;
    });
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            parameters.setCompensationEnabled(true);
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextWithNoCleanupCompensation());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        TransactionSupport.executeInNewTransaction(() -> {
            final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
            CompensationUtils.saveEntity(managementNetworkCluster, networkClusterDao, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        });
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    // Executing the rest of the command in one transaction.
    // This avoids using compensation context inside functions
    // called here, which would be tricky.
    // 
    // If anything fails, this transaction is not committed and
    // changes committed before this block are reverted using compensation.
    TransactionSupport.executeInNewTransaction(() -> {
        updateDefaultNetworkProvider();
        if (getCluster().getFirewallType() != oldCluster.getFirewallType() || getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
            markHostsForReinstall();
        }
        if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
            // update gluster parameters on all hosts
            updateGlusterHosts();
        }
        alertIfFencingDisabled();
        boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
        if (isKsmPolicyChanged) {
            momPolicyUpdatedEvent.fire(getCluster());
        }
        if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
            vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
        }
        return null;
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
        reDetectDefaultsForDeprecatedCPUs();
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationUtils.updateEntity(getParameters().getCluster(), oldCluster, clusterDao, getCompensationContext());
        addOrUpdateAddtionalClusterFeatures();
        getCompensationContext().stateChanged();
        return null;
    });
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            parameters.setCompensationEnabled(true);
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextWithNoCleanupCompensation());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        TransactionSupport.executeInNewTransaction(() -> {
            final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
            CompensationUtils.saveEntity(managementNetworkCluster, networkClusterDao, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        });
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    // Executing the rest of the command in one transaction.
    // This avoids using compensation context inside functions
    // called here, which would be tricky.
    // 
    // If anything fails, this transaction is not committed and
    // changes committed before this block are reverted using compensation.
    TransactionSupport.executeInNewTransaction(() -> {
        updateDefaultNetworkProvider();
        if (getCluster().getFirewallType() != oldCluster.getFirewallType() || getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
            markHostsForReinstall();
        }
        if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
            // update gluster parameters on all hosts
            updateGlusterHosts();
        }
        alertIfFencingDisabled();
        boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
        if (isKsmPolicyChanged) {
            momPolicyUpdatedEvent.fire(getCluster());
        }
        if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
            vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
        }
        return null;
    });
    setSucceeded(true);
}
#end_block

#method_before
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateParams.setCompensationEnabled(true);
        upgradeGraphicsDevices(vm, updateParams);
        updateResumeBehavior(vm);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#method_after
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateParams.setCompensationEnabled(true);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    ClusterValidator clusterValidator = getClusterValidator(oldCluster, getCluster());
    boolean returnValue = validate(clusterValidator.oldClusterIsValid());
    if (returnValue) {
        readjustForDeprecatedCPUs();
        returnValue = validate(clusterValidator.newNameUnique()) && validate(clusterValidator.newClusterVersionSupported()) && validate(clusterValidator.decreaseClusterWithHosts()) && validate(clusterValidator.decreaseClusterBeneathDc(getClusterValidator(oldCluster))) && validate(clusterValidator.canChangeStoragePool()) && validate(clusterValidator.cpuNotFound(checkIfCpusExist())) && validate(clusterValidator.updateCpuIllegal(checkIfCpusExist(), checkIfCpusSameManufacture(oldCluster))) && validate(clusterValidator.architectureIsLegal(isArchitectureUpdatable())) && validate(clusterValidator.cpuUpdatable()) && validate(clusterValidator.vmInPrev()) && validateManagementNetworkAndAdditionToStoragePool() && validate(clusterValidator.vdsUp()) && validate(clusterValidator.hostsDown(getParameters().isForceResetEmulatedMachine())) && canUpdateCompatibilityVersionOrCpu() && validate(clusterValidator.updateSupportedFeatures()) && hasSuspendedVms() && validate(clusterValidator.addMoreThanOneHost()) && validate(clusterValidator.defaultClusterOnLocalfs()) && validate(clusterValidator.oneServiceEnabled()) && validate(clusterValidator.mixedClusterServicesSupportedForNewCluster()) && validate(clusterValidator.disableVirt()) && validate(clusterValidator.disableGluster()) && validate(clusterValidator.setTrustedAttestation()) && validate(clusterValidator.migrationOnError(getArchitecture())) && validateClusterPolicy(oldCluster) && validateConfiguration();
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    ClusterValidator clusterValidator = getClusterValidator(oldCluster, getCluster());
    boolean returnValue = validate(clusterValidator.oldClusterIsValid());
    if (returnValue) {
        returnValue = validate(clusterValidator.newNameUnique()) && validate(clusterValidator.newClusterVersionSupported()) && validate(clusterValidator.decreaseClusterWithHosts()) && validate(clusterValidator.decreaseClusterBeneathDc(getClusterValidator(oldCluster))) && validate(clusterValidator.canChangeStoragePool()) && validate(clusterValidator.cpuNotFound(checkIfCpusExist())) && validate(clusterValidator.updateCpuIllegal(checkIfCpusExist(), checkIfCpusSameManufacture(oldCluster))) && validate(clusterValidator.architectureIsLegal(isArchitectureUpdatable())) && validate(clusterValidator.cpuUpdatable()) && validate(clusterValidator.vmInPrev()) && validateManagementNetworkAndAdditionToStoragePool() && validate(clusterValidator.vdsUp()) && validate(clusterValidator.hostsDown(getParameters().isForceResetEmulatedMachine())) && canUpdateCompatibilityVersionOrCpu() && validate(clusterValidator.updateSupportedFeatures()) && hasSuspendedVms() && validate(clusterValidator.addMoreThanOneHost()) && validate(clusterValidator.defaultClusterOnLocalfs()) && validate(clusterValidator.oneServiceEnabled()) && validate(clusterValidator.mixedClusterServicesSupportedForNewCluster()) && validate(clusterValidator.disableVirt()) && validate(clusterValidator.disableGluster()) && validate(clusterValidator.setTrustedAttestation()) && validate(clusterValidator.migrationOnError(getArchitecture())) && validateClusterPolicy(oldCluster) && validateConfiguration();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isArchitectureUpdatable() {
    return oldCluster.getArchitecture() == ArchitectureType.undefined ? true : getArchitecture() == oldCluster.getArchitecture();
}
#method_after
protected boolean isArchitectureUpdatable() {
    if (isCpuDeprecated()) {
        return true;
    }
    return oldCluster.getArchitecture() == ArchitectureType.undefined ? true : getArchitecture() == oldCluster.getArchitecture();
}
#end_block

#method_before
protected boolean checkIfCpusSameManufacture(Cluster group) {
    return cpuFlagsManagerHandler.checkIfCpusSameManufacture(group.getCpuName(), getCluster().getCpuName(), getCluster().getCompatibilityVersion());
}
#method_after
protected boolean checkIfCpusSameManufacture(Cluster group) {
    if (!cpuFlagsManagerHandler.checkIfCpusExist(group.getCpuName(), getParameters().getCluster().getCompatibilityVersion()) || !cpuFlagsManagerHandler.checkIfCpusExist(getCluster().getCpuName(), getParameters().getCluster().getCompatibilityVersion())) {
        return true;
    }
    return cpuFlagsManagerHandler.checkIfCpusSameManufacture(group.getCpuName(), getCluster().getCpuName(), getCluster().getCompatibilityVersion());
}
#end_block

#method_before
protected boolean checkIfCpusExist() {
    return cpuFlagsManagerHandler.checkIfCpusExist(getCluster().getCpuName(), getCluster().getCompatibilityVersion());
}
#method_after
protected boolean checkIfCpusExist() {
    // then skip the validation so that we can adjust the cpu type in the executeCommand() function.
    if (isCpuDeprecated()) {
        return true;
    }
    return cpuFlagsManagerHandler.checkIfCpusExist(getCluster().getCpuName(), getCluster().getCompatibilityVersion());
}
#end_block

#method_before
private Dashboard getDashboard() throws DashboardDataException {
    Dashboard dashboard = new Dashboard();
    dashboard.setGlobalUtilization(lookupGlobalUtilization());
    dashboard.setHeatMapData(lookupClusterUtilization());
    dashboard.setVdoVolumeDetailsList(lookupVdoSavings());
    return dashboard;
}
#method_after
private Dashboard getDashboard() throws DashboardDataException {
    Dashboard dashboard = new Dashboard();
    dashboard.setGlobalUtilization(lookupGlobalUtilization());
    dashboard.setHeatMapData(lookupClusterUtilization());
    return dashboard;
}
#end_block

#method_before
private HeatMapData lookupClusterUtilization() throws DashboardDataException {
    HeatMapData utilization = new HeatMapData();
    HeatMapHelper.getCpuAndMemory(utilization, dwhDataSource);
    utilization.setStorage(HeatMapHelper.getStorage(dwhDataSource));
    return utilization;
}
#method_after
private HeatMapData lookupClusterUtilization() throws DashboardDataException {
    HeatMapData utilization = new HeatMapData();
    HeatMapHelper.getCpuAndMemory(utilization, dwhDataSource);
    utilization.setStorage(HeatMapHelper.getStorage(dwhDataSource));
    utilization.setVdoSavings(HeatMapHelper.getVdoSavings(engineDataSource));
    return utilization;
}
#end_block

#method_before
public List<VDOVolumeDetails> getVdoVolumesSavingsList() throws DashboardDataException {
    final List<VDOVolumeDetails> vdoSavingsVolumeList = new ArrayList<>();
    runQuery(GLUSTER_VOLUME_VDO_SAVINGS, rs -> {
        VDOVolumeDetails vdo = new VDOVolumeDetails();
        vdo.setVolumeId(Guid.createGuidFromString(rs.getString(VOLUME_ID)));
        vdo.setVolumeName(rs.getString(VOLUME_NAME));
        vdo.setVdoSavings(rs.getInt(VDO_SAVINGS));
        vdoSavingsVolumeList.add(vdo);
    });
    return vdoSavingsVolumeList;
}
#method_after
public List<VDOVolumeDetails> getVdoVolumesSavingsList() throws DashboardDataException {
    final List<VDOVolumeDetails> vdoSavingsVolumeList = new ArrayList<>();
    runQuery(GLUSTER_VOLUME_VDO_SAVINGS, rs -> {
        VDOVolumeDetails vdo = new VDOVolumeDetails();
        vdo.setVolumeName(rs.getString(VOLUME_NAME));
        vdo.setVdoSavings(rs.getInt(VDO_SAVINGS));
        vdoSavingsVolumeList.add(vdo);
    });
    return vdoSavingsVolumeList;
}
#end_block

#method_before
private void writeMemoryBacking() {
    Optional<Integer> hugepageSizeOpt = HugePageUtils.getHugePageSize(vm.getStaticData());
    if (!hugepageSizeOpt.isPresent()) {
        return;
    }
    writer.writeStartElement("memoryBacking");
    writer.writeStartElement("hugepages");
    writer.writeStartElement("page");
    int hugepageSize = hugepageSizeOpt.get();
    List<Integer> hugepageSizes = new ArrayList<>();
    if (hostStatisticsSupplier.get() != null) {
        hugepageSizes = hostStatisticsSupplier.get().getHugePages().stream().map(HugePage::getSizeKB).collect(Collectors.toList());
    }
    if (!hugepageSizes.contains(hugepageSize)) {
        hugepageSize = vmInfoBuildUtils.getDefaultHugepageSize(vm);
    }
    writer.writeAttributeString("size", String.valueOf(hugepageSize));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeMemoryBacking() {
    Optional<Integer> hugepageSizeOpt = HugePageUtils.getHugePageSize(vm.getStaticData());
    if (!hugepageSizeOpt.isPresent()) {
        return;
    }
    writer.writeStartElement("memoryBacking");
    writer.writeStartElement("hugepages");
    writer.writeStartElement("page");
    int hugepageSize = vmInfoBuildUtils.getDefaultHugepageSize(vm);
    if (hostStatisticsSupplier.get() != null) {
        int hugepageSizeFromOpt = hugepageSizeOpt.get();
        List<Integer> hugepageSizes = hostStatisticsSupplier.get().getHugePages().stream().map(HugePage::getSizeKB).collect(Collectors.toList());
        if (hugepageSizes.contains(hugepageSizeFromOpt)) {
            hugepageSize = hugepageSizeFromOpt;
        }
    }
    writer.writeAttributeString("size", String.valueOf(hugepageSize));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    if (mdevTypes != null) {
        String[] mdevDevices = mdevTypes.split(",");
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacement vgpuPlacement = hostVgpuPlacementSupplier.get();
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacement.CONSOLIDATED) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacement.SEPARATED) {
                    vgpuPlacementString = "separate";
                } else {
                    log.warn("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacement.CONSOLIDATED, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#method_after
void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    boolean display = true;
    if (StringUtils.isNotEmpty(mdevTypes)) {
        String[] mdevDevices = mdevTypes.split(",");
        if (mdevDevices.length > 0 && mdevDevices[0].equals("nodisplay")) {
            display = false;
            mdevDevices = Arrays.copyOfRange(mdevDevices, 1, mdevDevices.length);
        }
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            if (display && vm.getCompatibilityVersion().greaterOrEquals(Version.v4_3)) {
                // Nvidia vGPU VNC console is only supported on RHEL >= 7.6
                // See https://bugzilla.redhat.com/show_bug.cgi?id=1633623 for details and discussion
                writer.writeAttributeString("display", "on");
            }
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacement vgpuPlacement = hostVgpuPlacementSupplier.get();
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacement.CONSOLIDATED) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacement.SEPARATED) {
                    vgpuPlacementString = "separate";
                } else {
                    log.warn("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacement.CONSOLIDATED, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (networkless || !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", networkless ? String.valueOf(NetworkUtils.getHostDefaultMtu()) : String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public ValidationResult allDomainsHaveSpaceForMerge(List<SubchainInfo> snapshots, ActionType snapshotActionType) {
    // it could fail with NPA
    if (snapshots.isEmpty()) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_REMOVE_SNAPSHOT_ILLEGAL_IMAGE);
    }
    final Map<Guid, List<SubchainInfo>> storageToSnapshots = getDomainsToSnapshotsMap(snapshots);
    return validOrFirstFailure(entry -> {
        Guid sdId = entry.getKey();
        List<SubchainInfo> subchain = storageToSnapshots.get(sdId);
        return getStorageDomainValidator(entry).hasSpaceForMerge(subchain, snapshotActionType);
    });
}
#method_after
public ValidationResult allDomainsHaveSpaceForMerge(List<SubchainInfo> snapshots, ActionType snapshotActionType) {
    // it could fail with NPE
    if (snapshots.isEmpty()) {
        return new ValidationResult(EngineMessage.ERROR_CANNOT_REMOVE_SNAPSHOT_ILLEGAL_IMAGE);
    }
    final Map<Guid, List<SubchainInfo>> storageToSnapshots = getDomainsToSnapshotsMap(snapshots);
    return validOrFirstFailure(entry -> {
        Guid sdId = entry.getKey();
        List<SubchainInfo> subchain = storageToSnapshots.get(sdId);
        return getStorageDomainValidator(entry).hasSpaceForMerge(subchain, snapshotActionType);
    });
}
#end_block

#method_before
void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    boolean display = true;
    if (StringUtils.isNotEmpty(mdevTypes)) {
        String[] mdevDevices = mdevTypes.split(",");
        if (mdevDevices.length > 0 && mdevDevices[0].equals("nodisplay")) {
            display = false;
            mdevDevices = Arrays.copyOfRange(mdevDevices, 1, mdevDevices.length);
        }
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            if (display && vm.getCompatibilityVersion().greaterOrEquals(Version.v4_3)) {
                // Nvidia vGPUs are only supported on RHEL >= 7.6
                // See https://bugzilla.redhat.com/show_bug.cgi?id=1633623 for details and discussion
                writer.writeAttributeString("display", "on");
            }
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacement vgpuPlacement = hostVgpuPlacementSupplier.get();
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacement.CONSOLIDATED) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacement.SEPARATED) {
                    vgpuPlacementString = "separate";
                } else {
                    log.warn("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacement.CONSOLIDATED, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#method_after
void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    boolean display = true;
    if (StringUtils.isNotEmpty(mdevTypes)) {
        String[] mdevDevices = mdevTypes.split(",");
        if (mdevDevices.length > 0 && mdevDevices[0].equals("nodisplay")) {
            display = false;
            mdevDevices = Arrays.copyOfRange(mdevDevices, 1, mdevDevices.length);
        }
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            if (display && vm.getCompatibilityVersion().greaterOrEquals(Version.v4_3)) {
                // Nvidia vGPU VNC console is only supported on RHEL >= 7.6
                // See https://bugzilla.redhat.com/show_bug.cgi?id=1633623 for details and discussion
                writer.writeAttributeString("display", "on");
            }
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacement vgpuPlacement = hostVgpuPlacementSupplier.get();
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacement.CONSOLIDATED) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacement.SEPARATED) {
                    vgpuPlacementString = "separate";
                } else {
                    log.warn("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacement.CONSOLIDATED, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (networkless || !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", networkless ? String.valueOf(NetworkUtils.getHostDefaultMtu()) : String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public String buildHotplugNic(boolean isHotUpdate) {
    writer.writeStartDocument(false);
    writer.writeStartElement("hotplug");
    writer.writeStartElement("devices");
    writeInterface(device, nic, isHotUpdate);
    writer.writeEndElement();
    writer.writeStartElement("metadata");
    writer.setPrefix(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeNamespace(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeNetworkInterfaceMetadata();
    writer.writeEndElement();
    writer.writeEndElement();
    return writer.getStringXML();
}
#method_after
public String buildHotplugNic() {
    writer.writeStartDocument(false);
    writer.writeStartElement("hotplug");
    writer.writeStartElement("devices");
    writeInterface(device, nic);
    writer.writeEndElement();
    writer.writeStartElement("metadata");
    writer.setPrefix(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeNamespace(OVIRT_VM_PREFIX, OVIRT_VM_URI);
    writer.writeStartElement(OVIRT_VM_URI, "vm");
    writeNetworkInterfaceMetadata();
    writer.writeEndElement();
    writer.writeEndElement();
    return writer.getStringXML();
}
#end_block

#method_before
private void writeInterfaces(List<VmDevice> devices) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.stream().sorted(Comparator.comparing(dev -> devIdToNic.get(dev.getId()).getMacAddress())).forEach(dev -> writeInterface(dev, devIdToNic.get(dev.getId()), false));
}
#method_after
private void writeInterfaces(List<VmDevice> devices) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.stream().sorted(Comparator.comparing(dev -> devIdToNic.get(dev.getId()).getMacAddress())).forEach(dev -> writeInterface(dev, devIdToNic.get(dev.getId())));
}
#end_block

#method_before
private void writeGraphics(VmDevice device) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    writer.writeAttributeString("passwd", "*****");
    writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                adjustSpiceSecureChannels(channels.split(",")).forEach(channel -> {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                });
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("vdsm-%s", displayNetwork.getVdsmName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeGraphics(VmDevice device) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    if (graphicsType == GraphicsType.SPICE || /* VNC && */
    !vmInfoBuildUtils.isKernelFipsMode(hostStatisticsSupplier.get().getId())) {
        writer.writeAttributeString("passwd", "*****");
        writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    }
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                adjustSpiceSecureChannels(channels.split(",")).forEach(channel -> {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                });
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("vdsm-%s", displayNetwork.getVdsmName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic, boolean isHotUpdate) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!isHotUpdate && vnicProfile != null && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", networkless ? String.valueOf(NetworkUtils.getHostDefaultMtu()) : String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (networkless || !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", networkless ? String.valueOf(NetworkUtils.getHostDefaultMtu()) : String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = vdsDynamicDao.get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            switch(getMaintenanceCmdStatus(childCmdIds)) {
                case FAILED:
                case ENDED_WITH_FAILURE:
                    log.info("Host '{}' is on maintenance mode. But not invoking Upgrade process because moving to " + "maintenance completed with failure, please see logs for details.", getHostName(parameters.getVdsId()));
                    handleActionFailed(rootCommand, parameters);
                    break;
                case SUCCEEDED:
                case ENDED_SUCCESSFULLY:
                    log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
                    invokeHostUpgrade(rootCommand, parameters);
                    break;
                case UNKNOWN:
                    // if child command has not been executed the host is already in maintenance, so upgrade can be started
                    if (childCmdIds.isEmpty()) {
                        log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
                        invokeHostUpgrade(rootCommand, parameters);
                    }
                    break;
                default:
                    break;
            }
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds) || hasMaintenanceCmdFailed(childCmdIds)) {
                handleActionFailed(rootCommand, parameters);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = vdsDynamicDao.get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            // MaintenanceNumberOfVdssCommand status. So upgrade can be started
            if (childCmdIds.isEmpty()) {
                logAndinvokeHostUpgrade(rootCommand, parameters);
                break;
            }
            switch(getMaintenanceCmdStatus(childCmdIds)) {
                case FAILED:
                case ENDED_WITH_FAILURE:
                    log.info("Host '{}' is on maintenance mode. But not invoking Upgrade process because moving to " + "maintenance completed with failure, please see logs for details.", getHostName(parameters.getVdsId()));
                    handleActionFailed(rootCommand, parameters);
                    break;
                case SUCCEEDED:
                case ENDED_SUCCESSFULLY:
                    logAndinvokeHostUpgrade(rootCommand, parameters);
                    break;
                case UNKNOWN:
                    log.info("Host '{}' is on maintenance mode. But not invoking Upgrade process because moving to " + "maintenance command is in UNKNOWN status.", getHostName(parameters.getVdsId()));
                    break;
                default:
                    log.info("Host '{}' is on maintenance mode. But not invoking Upgrade process because moving to " + "maintenance command is in unhandled status '{}'.", getHostName(parameters.getVdsId()), host.getStatus());
                    break;
            }
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds) || hasMaintenanceCmdFailed(childCmdIds)) {
                handleActionFailed(rootCommand, parameters);
            }
            break;
    }
}
#end_block

#method_before
private CreateImageVDSCommandParameters getCreateVDSCommandParameters() {
    CreateVolumeVDSCommandParameters parameters = new CreateVolumeVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getSrcImageId(), getParameters().getSize(), getType(), getParameters().getVolumeFormat(), getParameters().getSrcImageGroupId(), getParameters().getImageId(), getParameters().getDescription(), getStoragePool().getCompatibilityVersion(), DiskContentType.DATA);
    if (getType() != VolumeType.Preallocated && ImagesHandler.isImageInitialSizeSupported(getStorageDomain().getStorageType())) {
        parameters.setImageInitialSizeInBytes(Optional.ofNullable(getParameters().getInitialSize()).orElse(0L));
    }
    return parameters;
}
#method_after
private CreateImageVDSCommandParameters getCreateVDSCommandParameters() {
    CreateVolumeVDSCommandParameters parameters = new CreateVolumeVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getSrcImageId(), getParameters().getSize(), getType(), getParameters().getVolumeFormat(), getParameters().getSrcImageGroupId(), getParameters().getImageId(), getParameters().getDescription(), getStoragePool().getCompatibilityVersion(), DiskContentType.DATA);
    if (getType() != VolumeType.Preallocated && getStorageDomain().getStorageType().isBlockDomain()) {
        parameters.setImageInitialSizeInBytes(Optional.ofNullable(getParameters().getInitialSize()).orElse(0L));
    } else if (supportsDeferredPrallocation()) {
        // In case of move/copy of preallocated disk on file storage domain,
        // the initial volume will be created with the minimum initial size in order
        // to reduce volume creation time.
        // Later, the engine starts copy_data job on VDSM that invoke qemuimg.convert()
        // with preallocation="falloc" and allocates the entire volume size.
        Long initialSize = Optional.ofNullable(getParameters().getInitialSize()).orElse(0L);
        parameters.setImageInitialSizeInBytes(initialSize);
    }
    return parameters;
}
#end_block

#method_before
private VolumeType getType() {
    if (!getStorageDomain().getStorageType().isOpenStackDomain() && getParameters().getVolumeFormat() == VolumeFormat.RAW) {
        return VolumeType.Preallocated;
    }
    return VolumeType.Sparse;
}
#method_after
private VolumeType getType() {
    if (getStorageDomain().getStorageType().isInternal() && getParameters().getVolumeFormat() == VolumeFormat.RAW) {
        return VolumeType.Preallocated;
    }
    return VolumeType.Sparse;
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    String selectedTimeZone = null;
    Integer selectedOsId = null;
    if (getTimeZone().getSelectedItem() != null) {
        selectedTimeZone = getTimeZone().getSelectedItem().getTimeZoneKey().toString();
    }
    if (getOSType().getSelectedItem() != null) {
        selectedOsId = getOSType().getSelectedItem();
    }
    behavior.dataCenterWithClusterSelectedItemChanged();
    refreshMigrationPolicies();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
    updateResumeBehavior();
    updateBiosType();
    if (selectedOsId != null) {
        getOSType().setSelectedItem(selectedOsId);
    }
    if (selectedTimeZone != null && !selectedTimeZone.isEmpty()) {
        getBehavior().updateTimeZone(selectedTimeZone);
    }
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    String selectedTimeZone = "";
    Integer selectedOsId = null;
    if (getTimeZone().getSelectedItem() != null) {
        selectedTimeZone = getBehavior().getSelectedTimeZone();
    }
    if (getOSType().getSelectedItem() != null) {
        selectedOsId = getBehavior().getSelectedOSType();
    }
    behavior.dataCenterWithClusterSelectedItemChanged();
    refreshMigrationPolicies();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
    updateResumeBehavior();
    updateBiosType();
    getBehavior().updateOSValue(selectedOsId);
    if (!selectedTimeZone.isEmpty()) {
        getBehavior().updateTimeZone(selectedTimeZone);
    }
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = vdsDynamicDao.get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            if (hasMaintenanceCmdSucceeded(childCmdIds)) {
                log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
                invokeHostUpgrade(rootCommand, parameters);
            }
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds) || hasMaintenanceCmdFailed(childCmdIds)) {
                log.error("Host '{}' failed to move to maintenance mode. Upgrade process is terminated.", getHostName(parameters.getVdsId()));
                auditLogDirector.log(rootCommand, AuditLogType.VDS_MAINTENANCE_FAILED);
                rootCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(List<Guid> childCmdIds, CommandBase<?> rootCommand) {
    UpgradeHostParameters parameters = (UpgradeHostParameters) rootCommand.getParameters();
    VdsDynamic host = vdsDynamicDao.get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            switch(getMaintenanceCmdStatus(childCmdIds)) {
                case FAILED:
                case ENDED_WITH_FAILURE:
                    log.info("Host '{}' is on maintenance mode. But not invoking Upgrade process because moving to " + "maintenance completed with failure, please see logs for details.", getHostName(parameters.getVdsId()));
                    handleActionFailed(rootCommand, parameters);
                    break;
                case SUCCEEDED:
                case ENDED_SUCCESSFULLY:
                    log.info("Host '{}' is on maintenance mode. Proceeding with Upgrade process.", getHostName(parameters.getVdsId()));
                    invokeHostUpgrade(rootCommand, parameters);
                    break;
                default:
                    break;
            }
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(childCmdIds) || hasMaintenanceCmdFailed(childCmdIds)) {
                handleActionFailed(rootCommand, parameters);
            }
            break;
    }
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        Guid storagePoolId = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            setDomains(cachedVds.getDomains());
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        Guid storagePoolId = null;
        ArrayList<VDSDomainsData> domainsList = null;
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (domainsList != null) {
            updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            setDomains(domainsList);
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    setVmName(getParameters().getExternalName());
    setVdsId(getParameters().getProxyHostId());
    setStorageDomainId(getParameters().getDestDomainId());
    setStoragePoolId(getCluster() != null ? getCluster().getStoragePoolId() : null);
    replaceImageActualSizeWithVirtualSizeIfNeeded();
    vmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
    adjustVolumeType();
}
#method_after
@Override
protected void init() {
    super.init();
    setVmName(getParameters().getExternalName());
    setVdsId(getParameters().getProxyHostId());
    setStorageDomainId(getParameters().getDestDomainId());
    setStoragePoolId(getCluster() != null ? getCluster().getStoragePoolId() : null);
    adjustKVMDataForBlockSD();
    vmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes(-1 * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    for (SPMTask task : tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogable logable = new AuditLogableImpl();
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                auditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}' since it reached a timeout of {} minutes", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime(), Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes));
                task.stopTask(true);
            } else {
                auditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}' since it reached a timeout of {} minutes", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime(), Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes));
                task.clearAsyncTask(true);
            }
        }
    }
}
#method_after
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes(-1 * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    int asyncZombieTaskLife = Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes);
    for (SPMTask task : tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogable logable = new AuditLogableImpl();
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                auditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}' since it reached a timeout of {} minutes", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime(), asyncZombieTaskLife);
                task.stopTask(true);
            } else {
                auditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}' since it reached a timeout of {} minutes", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime(), asyncZombieTaskLife);
                task.clearAsyncTask(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setClusterId(getParameters().getClusterId());
        if (getCluster() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getCluster().getArchitecture() == ArchitectureType.undefined) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.error("Unable to get the disk image from the provider proxy: ({}) {}", e.getErrorType(), e.getMessage());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
            case UNABLE_TO_ACCESS_IMAGE_REPOSITORY:
                auditLog(this, AuditLogType.ACCESS_REPOSITORY_IMAGE_FAILED);
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_ACCESS_IMAGE_REPOSITORY);
        }
    }
    if (diskImage == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    diskImage.setStoragePoolId(getStoragePoolId());
    if (!validate(createDiskImagesValidator(diskImage).isQcowVersionSupportedForDcVersion())) {
        return false;
    }
    return validateSpaceRequirements(diskImage);
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new StoragePoolValidator(getStoragePool()).existsAndUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setClusterId(getParameters().getClusterId());
        if (getCluster() == null) {
            addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getCluster().getArchitecture() == ArchitectureType.undefined) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        auditLog(this, AuditLogType.FAILED_IMPORT_IMAGE_FROM_REPOSITORY);
        log.error("Unable to get the disk image from the provider proxy: ({}) {}", e.getErrorType(), e.getMessage());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
            case IMAGE_NOT_FOUND:
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_FIND_SPECIFIED_IMAGE);
        }
    } catch (RuntimeException rte) {
        auditLog(this, AuditLogType.FAILED_IMPORT_IMAGE_FROM_REPOSITORY);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_IMPORT_IMAGE_FROM_REPOSITORY);
    }
    if (diskImage == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    diskImage.setStoragePoolId(getStoragePoolId());
    if (!validate(createDiskImagesValidator(diskImage).isQcowVersionSupportedForDcVersion())) {
        return false;
    }
    return validateSpaceRequirements(diskImage);
}
#end_block

#method_before
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage;
    try {
        glanceImage = getClient().images().show(id).execute();
    } catch (RuntimeException e) {
        log.error("Exception: {}", e.getMessage());
        log.debug("Exception", e);
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_ACCESS_IMAGE_REPOSITORY, "Cannot access the image repository. Please make sure it's accessible.");
    }
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    setDiskAttributes(diskImage, glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#method_after
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage;
    try {
        glanceImage = getClient().images().show(id).execute();
    } catch (OpenStackResponseException e) {
        log.debug("Exception:", e);
        throw new OpenStackImageException(OpenStackImageException.ErrorType.IMAGE_NOT_FOUND, "Cannot find the specified image.");
    } catch (RuntimeException rte) {
        log.error("Exception:", rte);
        throw new RuntimeException("Failed to import from the repository.");
    }
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    setDiskAttributes(diskImage, glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setVolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#end_block

#method_before
private void setGuestOsNamedVersion() {
    if (guestOsType == OsType.Linux) {
        // $NON-NLS-1$
        String optional = "";
        if (StringHelper.isNotNullOrEmpty(guestOsCodename)) {
            optional = messages.guestOSVersionOptional(guestOsCodename);
        }
        guestOsNamedVersion = messages.guestOSVersionLinux(guestOsDistribution, guestOsVersion, optional);
    } else if (guestOsType == OsType.Windows && guestOs != null) {
        // $NON-NLS-1$
        if (guestOs.startsWith("Win ")) {
            // This is for backword compatibility with oVirt Guest Agent
            if (guestOs.startsWith("Win 20")) {
                // $NON-NLS-1$
                guestOsNamedVersion = messages.guestOSVersionWindowsServer(guestOs.substring(4), guestOsVersion);
            } else {
                guestOsNamedVersion = messages.guestOSVersionWindows(guestOs.substring(4), guestOsVersion);
            }
        } else {
            // With new enough qemu-ga the names are already pretty enough
            guestOsNamedVersion = guestOs;
        }
    }
}
#method_after
private void setGuestOsNamedVersion() {
    if (guestOsType == OsType.Linux) {
        // $NON-NLS-1$
        String optional = "";
        if (StringHelper.isNotNullOrEmpty(guestOsCodename)) {
            optional = messages.guestOSVersionOptional(guestOsCodename);
        }
        guestOsNamedVersion = messages.guestOSVersionLinux(guestOsDistribution, guestOsVersion, optional);
    } else if (guestOsType == OsType.Windows && guestOs != null) {
        if (guestOs.startsWith("Win ")) {
            // This is for backword compatibility with oVirt Guest Agent
            if (guestOs.startsWith("Win 20")) {
                // $NON-NLS-1$
                guestOsNamedVersion = messages.guestOSVersionWindowsServer(guestOs.substring(4), guestOsVersion);
            } else {
                guestOsNamedVersion = messages.guestOSVersionWindows(guestOs.substring(4), guestOsVersion);
            }
        } else {
            // With new enough qemu-ga the names are already pretty enough
            guestOsNamedVersion = guestOs;
        }
    }
}
#end_block

#method_before
private LDAPConnectionPool createConnectionPool(MapProperties poolProps) throws Exception {
    log.debug("createConnectionPool Entry");
    SSLSocketVerifier sslSocketVerifier = null;
    PostConnectProcessor postConnectProcessor = null;
    SocketFactory socketFactory = SocketFactory.getDefault();
    TrustManager[] trustManagers = null;
    KeyManager[] keyManagers = null;
    MapProperties sslProps = poolProps.get("ssl");
    boolean enableSSL = sslProps.getBoolean(Boolean.FALSE, "enable");
    boolean enableStartTLS = sslProps.getBoolean(Boolean.FALSE, "startTLS");
    if (enableSSL || enableStartTLS) {
        if (sslProps.getBoolean(Boolean.TRUE, "host-name-verify", "enable")) {
            log.debug("Creating HostNameSSLSocketVerifier");
            sslSocketVerifier = new HostNameSSLSocketVerifier(sslProps.getBoolean(Boolean.TRUE, "host-name-verify", "wildcards"));
            log.debug("HostNameSSLSocketVerifier: {}", sslSocketVerifier);
        }
        if (sslProps.getBoolean(Boolean.FALSE, "insecure")) {
            log.warn("{} TLS/SSL insecure mode", logPrefix);
            trustManagers = new TrustManager[] { new TrustAllTrustManager() };
        } else {
            log.debug("Creating trust store");
            MapProperties truststoreProps = sslProps.getOrEmpty("truststore");
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(truststoreProps.getString(KeyManagerFactory.getDefaultAlgorithm(), "trustmanager", "algorithm"));
            tmf.init(Util.loadKeyStore(truststoreProps.getString(null, "provider"), truststoreProps.getString(null, "type"), truststoreProps.getString(null, "file"), truststoreProps.getString("changeit", "password")));
            trustManagers = tmf.getTrustManagers();
        }
        log.debug("Creating key store");
        MapProperties keystoreProps = sslProps.getOrEmpty("keystore");
        KeyStore keyStore = Util.loadKeyStore(keystoreProps.getString(null, "provider"), keystoreProps.getString(null, "type"), keystoreProps.getString(null, "file"), keystoreProps.getString("changeit", "password"));
        if (keyStore != null) {
            KeyManagerFactory kmf = KeyManagerFactory.getInstance(keystoreProps.getString(KeyManagerFactory.getDefaultAlgorithm(), "keymanager", "algorithm"));
            kmf.init(keyStore, keystoreProps.getMandatoryString("password").toCharArray());
            keyManagers = kmf.getKeyManagers();
        }
        if (enableSSL) {
            log.debug("Creating SocketFactory");
            socketFactory = new SSLUtil(keyManagers, trustManagers).createSSLContext(sslProps.getString("TLSv1.2", "protocol")).getSocketFactory();
        }
        if (enableStartTLS) {
            log.debug("Creating StartTLSPostConnectProcessor");
            postConnectProcessor = new StartTLSPostConnectProcessor(new SSLUtil(keyManagers, trustManagers).createSSLContext(sslProps.getString("TLSv1.2", "startTLSProtocol")));
            log.debug("StartTLSPostConnectProcessor: {}", postConnectProcessor);
        }
    }
    log.debug("Creating LDAPConnectionOptions");
    final LDAPConnectionOptions connectionOptions = new LDAPConnectionOptions();
    connectionOptions.setSSLSocketVerifier(sslSocketVerifier);
    Util.setObjectByProperties(connectionOptions, poolProps.get("connection-options"), "set");
    log.debug("LDAPConnectionOptions: {}", connectionOptions);
    log.debug("Creating SocketFactory");
    final String POOL_PREFIX_SOCKET_FACTORY = "socketfactory";
    String socketFactoryType = poolProps.getString("java", POOL_PREFIX_SOCKET_FACTORY, "type");
    MapProperties socketFactoryProps = poolProps.get(POOL_PREFIX_SOCKET_FACTORY, socketFactoryType);
    if ("java".equals(socketFactoryType)) {
    } else if ("resolver".equals(socketFactoryType)) {
        final Resolver resolver = createResolver(socketFactoryProps);
        /*
             * HACK-BEGIN
             * unboundid SDK resolves host using java native we need
             * dynamic support.
             */
        socketFactory = new ResolverSocketFactory(resolver, socketFactory);
        Util.setObjectByProperties(socketFactory, socketFactoryProps, "set");
        /* HACK-END */
        /*
             * HACK-BEGIN
             * unboundid SDK resolves host internally within its default
             * getReferralConnection(), until this is fixed, we need to
             * implement our own.
             */
        connectionOptions.setReferralConnector(new ResolverReferralConnector(resolver));
    /* HACK-END */
    } else {
        throw new IllegalArgumentException(String.format("Invalid socket factory set type '%s'", socketFactoryType));
    }
    log.debug("SocketFactory: {}", socketFactory);
    log.debug("Creating ServerSet");
    final String POOL_PREFIX_SERVERSET = "serverset";
    final String SERVERSET_SERVER = "server";
    final String SERVERSET_PORT = "port";
    String serversetType = poolProps.getString("single", POOL_PREFIX_SERVERSET, "type");
    MapProperties serverSetProps = poolProps.get(POOL_PREFIX_SERVERSET, serversetType);
    int defaultPort = Integer.valueOf(serverSetProps.getString("389", SERVERSET_PORT));
    ServerSet serverset;
    if ("single".equals(serversetType)) {
        serverset = new SingleServerSet(serverSetProps.getString(null, SERVERSET_SERVER), serverSetProps.getInt(null, SERVERSET_PORT), socketFactory, connectionOptions);
    } else if ("round-robin".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new RoundRobinServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("failover".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FailoverServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("fastest-connect".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FastestConnectServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("fewest-connections".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FewestConnectionsServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("dns-round-robin".equals(serversetType)) {
        serverset = new RoundRobinDNSServerSet(serverSetProps.getString(null, SERVERSET_SERVER), serverSetProps.getInt(null, SERVERSET_PORT), (RoundRobinDNSServerSet.AddressSelectionMode) Util.getObjectValueByString(RoundRobinDNSServerSet.AddressSelectionMode.class, serverSetProps.getString(null, "selectionMode")), serverSetProps.getLong(0l, "cacheTimeoutMillis"), null, serverSetProps.getOrEmpty("jndi-properties").toProperties(), (String[]) Util.getObjectValueByString(String[].class, serverSetProps.getString(null, "dnsRecordTypes")), socketFactory, connectionOptions);
    } else if ("srvrecord".equals(serversetType)) {
        final String CONVERSION_PREFIX = "domain-conversion";
        String domain = serverSetProps.getMandatoryString("domain");
        List<MapProperties> conversions = new ArrayList<>();
        conversions.add(serverSetProps.getOrEmpty(CONVERSION_PREFIX, "prep"));
        conversions.add(serverSetProps.getOrEmpty(CONVERSION_PREFIX));
        for (MapProperties conversionPropsRoot : conversions) {
            String conversionType = conversionPropsRoot.getString("none", "type");
            MapProperties conversionProps = conversionPropsRoot.getOrEmpty(conversionType);
            if ("none".equals(conversionType)) {
            // noop
            } else if ("regex".equals(conversionType)) {
                String pattern = conversionProps.getMandatoryString("pattern");
                String flags = conversionProps.getString("", "flags");
                log.debug("Domain conversion pattern: {} ({})", pattern, flags);
                Matcher matcher = Pattern.compile(pattern).matcher(domain);
                domain = (flags.indexOf('a') != -1 ? matcher.replaceAll(conversionProps.getMandatoryString("replacement")) : matcher.replaceFirst(conversionProps.getMandatoryString("replacement")));
            } else {
                throw new IllegalArgumentException(String.format("Invalid srvrecord set conversion type '%s'", conversionType));
            }
        }
        serverset = new DNSSRVRecordServerSet(String.format("_%s._%s.%s", serverSetProps.getMandatoryString("service"), serverSetProps.getMandatoryString("protocol"), domain), null, serverSetProps.getOrEmpty("jndi-properties").toProperties(), serverSetProps.getLong(0l, "ttlMillis"), socketFactory, connectionOptions);
    } else {
        throw new IllegalArgumentException(String.format("Invalid server set type '%s'", serversetType));
    }
    log.debug("ServerSet: {}", serverset);
    log.debug("Creating BindRequest");
    BindRequest bindRequest = createBindRequest(poolProps, "", "");
    log.debug("BindRequest: {}", bindRequest);
    log.debug("Creating LDAPConnectionPool");
    MapProperties cpoolProps = poolProps.get("connection-pool");
    LDAPConnectionPool connectionPool = null;
    try {
        connectionPool = new LDAPConnectionPool(serverset, bindRequest, cpoolProps.getInt(1, "initialConnections"), cpoolProps.getInt(10, "maxConnections"), cpoolProps.getInt(1, "initialConnectThreads"), postConnectProcessor, true);
        Util.setObjectByProperties(connectionPool, cpoolProps, "set");
    } catch (LDAPException ex) {
        log.warn("Error while connecting to '{}'", serverset.getConnection() != null ? serverset.getConnection().getConnectedAddress() : "N/A");
        throw ex;
    }
    log.debug("createConnectionPool Return: {}", connectionPool);
    return connectionPool;
}
#method_after
private LDAPConnectionPool createConnectionPool(MapProperties poolProps) throws Exception {
    log.debug("createConnectionPool Entry");
    SSLSocketVerifier sslSocketVerifier = null;
    PostConnectProcessor postConnectProcessor = null;
    SocketFactory socketFactory = SocketFactory.getDefault();
    TrustManager[] trustManagers = null;
    KeyManager[] keyManagers = null;
    MapProperties sslProps = poolProps.get("ssl");
    boolean enableSSL = sslProps.getBoolean(Boolean.FALSE, "enable");
    boolean enableStartTLS = sslProps.getBoolean(Boolean.FALSE, "startTLS");
    if (enableSSL || enableStartTLS) {
        if (sslProps.getBoolean(Boolean.TRUE, "host-name-verify", "enable")) {
            log.debug("Creating HostNameSSLSocketVerifier");
            sslSocketVerifier = new HostNameSSLSocketVerifier(sslProps.getBoolean(Boolean.TRUE, "host-name-verify", "wildcards"));
            log.debug("HostNameSSLSocketVerifier: {}", sslSocketVerifier);
        }
        if (sslProps.getBoolean(Boolean.FALSE, "insecure")) {
            log.warn("{} TLS/SSL insecure mode", logPrefix);
            trustManagers = new TrustManager[] { new TrustAllTrustManager() };
        } else {
            log.debug("Creating trust store");
            MapProperties truststoreProps = sslProps.getOrEmpty("truststore");
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(truststoreProps.getString(KeyManagerFactory.getDefaultAlgorithm(), "trustmanager", "algorithm"));
            tmf.init(Util.loadKeyStore(truststoreProps.getString(null, "provider"), truststoreProps.getString(null, "type"), truststoreProps.getString(null, "file"), truststoreProps.getString("changeit", "password")));
            trustManagers = tmf.getTrustManagers();
        }
        log.debug("Creating key store");
        MapProperties keystoreProps = sslProps.getOrEmpty("keystore");
        KeyStore keyStore = Util.loadKeyStore(keystoreProps.getString(null, "provider"), keystoreProps.getString(null, "type"), keystoreProps.getString(null, "file"), keystoreProps.getString("changeit", "password"));
        if (keyStore != null) {
            KeyManagerFactory kmf = KeyManagerFactory.getInstance(keystoreProps.getString(KeyManagerFactory.getDefaultAlgorithm(), "keymanager", "algorithm"));
            kmf.init(keyStore, keystoreProps.getMandatoryString("password").toCharArray());
            keyManagers = kmf.getKeyManagers();
        }
        if (enableSSL) {
            log.debug("Creating SocketFactory");
            socketFactory = new SSLUtil(keyManagers, trustManagers).createSSLContext(sslProps.getString("TLSv1.2", "protocol")).getSocketFactory();
        }
        if (enableStartTLS) {
            log.debug("Creating StartTLSPostConnectProcessor");
            postConnectProcessor = new StartTLSPostConnectProcessor(new SSLUtil(keyManagers, trustManagers).createSSLContext(sslProps.getString("TLSv1.2", "startTLSProtocol")));
            log.debug("StartTLSPostConnectProcessor: {}", postConnectProcessor);
        }
    }
    log.debug("Creating LDAPConnectionOptions");
    final LDAPConnectionOptions connectionOptions = new LDAPConnectionOptions();
    connectionOptions.setSSLSocketVerifier(sslSocketVerifier);
    Util.setObjectByProperties(connectionOptions, poolProps.get("connection-options"), "set");
    log.debug("LDAPConnectionOptions: {}", connectionOptions);
    log.debug("Creating SocketFactory");
    final String POOL_PREFIX_SOCKET_FACTORY = "socketfactory";
    String socketFactoryType = poolProps.getString("java", POOL_PREFIX_SOCKET_FACTORY, "type");
    MapProperties socketFactoryProps = poolProps.get(POOL_PREFIX_SOCKET_FACTORY, socketFactoryType);
    if ("java".equals(socketFactoryType)) {
    } else if ("resolver".equals(socketFactoryType)) {
        final Resolver resolver = createResolver(socketFactoryProps);
        /*
             * HACK-BEGIN
             * unboundid SDK resolves host using java native we need
             * dynamic support.
             */
        socketFactory = new ResolverSocketFactory(resolver, socketFactory);
        Util.setObjectByProperties(socketFactory, socketFactoryProps, "set");
        /* HACK-END */
        /*
             * HACK-BEGIN
             * unboundid SDK resolves host internally within its default
             * getReferralConnection(), until this is fixed, we need to
             * implement our own.
             */
        connectionOptions.setReferralConnector(new ResolverReferralConnector(resolver));
    /* HACK-END */
    } else {
        throw new IllegalArgumentException(String.format("Invalid socket factory set type '%s'", socketFactoryType));
    }
    log.debug("SocketFactory: {}", socketFactory);
    log.debug("Creating ServerSet");
    final String POOL_PREFIX_SERVERSET = "serverset";
    final String SERVERSET_SERVER = "server";
    final String SERVERSET_PORT = "port";
    String serversetType = poolProps.getString("single", POOL_PREFIX_SERVERSET, "type");
    MapProperties serverSetProps = poolProps.get(POOL_PREFIX_SERVERSET, serversetType);
    int defaultPort = Integer.valueOf(serverSetProps.getString("389", SERVERSET_PORT));
    ServerSet serverset;
    if ("single".equals(serversetType)) {
        serverset = new SingleServerSet(serverSetProps.getString(null, SERVERSET_SERVER), serverSetProps.getInt(null, SERVERSET_PORT), socketFactory, connectionOptions);
    } else if ("round-robin".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new RoundRobinServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("failover".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FailoverServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("fastest-connect".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FastestConnectServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("fewest-connections".equals(serversetType)) {
        String[] addresess = Util.getValueFromMapRecord(serverSetProps, SERVERSET_SERVER).toArray(new String[0]);
        serverset = new FewestConnectionsServerSet(addresess, Util.asIntArray(Util.getValueFromMapRecord(serverSetProps, SERVERSET_PORT), defaultPort, addresess.length), socketFactory, connectionOptions);
    } else if ("dns-round-robin".equals(serversetType)) {
        serverset = new RoundRobinDNSServerSet(serverSetProps.getString(null, SERVERSET_SERVER), serverSetProps.getInt(null, SERVERSET_PORT), (RoundRobinDNSServerSet.AddressSelectionMode) Util.getObjectValueByString(RoundRobinDNSServerSet.AddressSelectionMode.class, serverSetProps.getString(null, "selectionMode")), serverSetProps.getLong(0l, "cacheTimeoutMillis"), null, serverSetProps.getOrEmpty("jndi-properties").toProperties(), (String[]) Util.getObjectValueByString(String[].class, serverSetProps.getString(null, "dnsRecordTypes")), socketFactory, connectionOptions);
    } else if ("srvrecord".equals(serversetType)) {
        final String CONVERSION_PREFIX = "domain-conversion";
        String domain = serverSetProps.getMandatoryString("domain");
        List<MapProperties> conversions = new ArrayList<>();
        conversions.add(serverSetProps.getOrEmpty(CONVERSION_PREFIX, "prep"));
        conversions.add(serverSetProps.getOrEmpty(CONVERSION_PREFIX));
        for (MapProperties conversionPropsRoot : conversions) {
            String conversionType = conversionPropsRoot.getString("none", "type");
            MapProperties conversionProps = conversionPropsRoot.getOrEmpty(conversionType);
            if ("none".equals(conversionType)) {
            // noop
            } else if ("regex".equals(conversionType)) {
                String pattern = conversionProps.getMandatoryString("pattern");
                String flags = conversionProps.getString("", "flags");
                log.debug("Domain conversion pattern: {} ({})", pattern, flags);
                Matcher matcher = Pattern.compile(pattern).matcher(domain);
                domain = (flags.indexOf('a') != -1 ? matcher.replaceAll(conversionProps.getMandatoryString("replacement")) : matcher.replaceFirst(conversionProps.getMandatoryString("replacement")));
            } else {
                throw new IllegalArgumentException(String.format("Invalid srvrecord set conversion type '%s'", conversionType));
            }
        }
        serverset = new DNSSRVRecordServerSet(String.format("_%s._%s.%s", serverSetProps.getMandatoryString("service"), serverSetProps.getMandatoryString("protocol"), domain), null, serverSetProps.getOrEmpty("jndi-properties").toProperties(), serverSetProps.getLong(0l, "ttlMillis"), socketFactory, connectionOptions);
    } else {
        throw new IllegalArgumentException(String.format("Invalid server set type '%s'", serversetType));
    }
    log.debug("ServerSet: {}", serverset);
    log.debug("Creating BindRequest");
    BindRequest bindRequest = createBindRequest(poolProps, "", "");
    log.debug("BindRequest: {}", bindRequest);
    log.debug("Creating LDAPConnectionPool");
    MapProperties cpoolProps = poolProps.get("connection-pool");
    LDAPConnectionPool connectionPool = null;
    try {
        connectionPool = new LDAPConnectionPool(serverset, bindRequest, cpoolProps.getInt(1, "initialConnections"), cpoolProps.getInt(10, "maxConnections"), cpoolProps.getInt(1, "initialConnectThreads"), postConnectProcessor, true);
        Util.setObjectByProperties(connectionPool, cpoolProps, "set");
    } catch (LDAPException ex) {
        log.warn("Error while connecting to '{}': {}", serverset.getConnection() != null ? serverset.getConnection().getConnectedAddress() : "N/A", ex.getExceptionMessage());
        throw ex;
    }
    log.debug("createConnectionPool Return: {}", connectionPool);
    return connectionPool;
}
#end_block

#method_before
public void authCheck(String name, Map<String, Object> vars) throws Exception {
    log.debug("authCheck Entry name='{}'", name);
    final String PREFIX_AUTH_CHECK = "auth-check";
    MapProperties authCheckProps = Util.expandMap(new MapProperties(props.get(PREFIX_AUTH_CHECK, "default"), props.get(PREFIX_AUTH_CHECK, name)), "seq", vars);
    String pool = authCheckProps.getMandatoryString("pool");
    String user = authCheckProps.getMandatoryString("user");
    if (user == null || user.isEmpty()) {
        throw new IllegalArgumentException("User required for authentication check");
    }
    ConnectionPoolEntry connectionPoolEntry = getConnectionPoolEntry(pool, null, vars);
    LDAPConnection connection = null;
    try {
        connection = connectionPoolEntry.connectionPool.getConnection();
        log.debug("Creating BindRequest");
        BindRequest bindRequest = createBindRequest(authCheckProps, user, authCheckProps.getString(null, "password"));
        log.debug("BindRequest: {}", bindRequest);
        log.debug("User '{}' is performing bind request to: {}", user, connection.getConnectedAddress());
        BindResult bindResult = connection.bind(bindRequest);
        log.debug("BindResult: {}", bindResult);
        PasswordExpiringControl expiringControl = PasswordExpiringControl.get(bindResult);
        if (expiringControl != null) {
            log.debug("Password about to expire");
            int secondsToExpiration = expiringControl.getSecondsUntilExpiration();
            vars.put(VARS_MESSAGE, String.format("Password will be expired in %s days", expiringControl.getSecondsUntilExpiration() / 60 / 60 / 24));
        }
        if (connectionPoolEntry.supportWhoAmI && authCheckProps.getBoolean(Boolean.TRUE, "whoami", "enable")) {
            log.debug("Trying WhoAmI");
            WhoAmIExtendedResult whoAmIExtendedResult = (WhoAmIExtendedResult) connection.processExtendedOperation(new WhoAmIExtendedRequest());
            if (whoAmIExtendedResult.getResultCode() == ResultCode.SUCCESS) {
                String authzID = whoAmIExtendedResult.getAuthorizationID();
                log.debug("Got WhoAmI: {}", authzID);
                if (!Arrays.asList("", "u:", "dn:").contains(authzID)) {
                    vars.put(VARS_AUTH_WHO_AM_I, authzID);
                }
            }
        }
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(ResultCode.SUCCESS));
    } catch (LDAPException e) {
        log.debug("Authentication exception", e);
        log.warn("Authentication exception", e.getExceptionMessage());
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(e.getResultCode()));
        vars.put(VARS_MESSAGE, e.getMessage());
        if (ResultCode.LOCAL_ERROR.equals(e.getResultCode())) {
            vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getCause().getClass().getName(), e.getCause().getMessage()));
        } else {
            if (e.getDiagnosticMessage() != null) {
                vars.put(VARS_DIAGNOSTIC_MESSAGE, e.getDiagnosticMessage());
            }
        }
        try {
            if (PasswordExpiredControl.get(e) != null) {
                log.debug("Password is expired");
                vars.put(VARS_RESULT_CODE, "PASSWORD_EXPIRED");
                vars.put(VARS_MESSAGE, "Password expired");
            }
        } catch (LDAPException e1) {
            log.debug("Ignoring exception during get of expired control", e1);
        }
    } catch (Exception e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_MESSAGE, e.getMessage());
        vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getClass().getName(), e.getMessage()));
    } finally {
        if (connection != null) {
            if (authCheckProps.getBoolean(Boolean.FALSE, "reuse-connections")) {
                connectionPoolEntry.connectionPool.releaseAndReAuthenticateConnection(connection);
            } else {
                connectionPoolEntry.connectionPool.discardConnection(connection);
            }
        }
    }
    vars.put(VARS_AUTH_TRANSLATED_MESSAGE, translateDiagnosticMessage(authCheckProps.get("diagnostic"), vars));
    log.debug("authCheck Return");
}
#method_after
public void authCheck(String name, Map<String, Object> vars) throws Exception {
    log.debug("authCheck Entry name='{}'", name);
    final String PREFIX_AUTH_CHECK = "auth-check";
    MapProperties authCheckProps = Util.expandMap(new MapProperties(props.get(PREFIX_AUTH_CHECK, "default"), props.get(PREFIX_AUTH_CHECK, name)), "seq", vars);
    String pool = authCheckProps.getMandatoryString("pool");
    String user = authCheckProps.getMandatoryString("user");
    if (user == null || user.isEmpty()) {
        throw new IllegalArgumentException("User required for authentication check");
    }
    ConnectionPoolEntry connectionPoolEntry = getConnectionPoolEntry(pool, null, vars);
    LDAPConnection connection = null;
    try {
        connection = connectionPoolEntry.connectionPool.getConnection();
        log.debug("Creating BindRequest");
        BindRequest bindRequest = createBindRequest(authCheckProps, user, authCheckProps.getString(null, "password"));
        log.debug("BindRequest: {}", bindRequest);
        log.debug("User '{}' is performing bind request to: {}", user, connection.getConnectedAddress());
        BindResult bindResult = connection.bind(bindRequest);
        log.debug("BindResult: {}", bindResult);
        PasswordExpiringControl expiringControl = PasswordExpiringControl.get(bindResult);
        if (expiringControl != null) {
            log.debug("Password about to expire");
            int secondsToExpiration = expiringControl.getSecondsUntilExpiration();
            vars.put(VARS_MESSAGE, String.format("Password will be expired in %s days", expiringControl.getSecondsUntilExpiration() / 60 / 60 / 24));
        }
        if (connectionPoolEntry.supportWhoAmI && authCheckProps.getBoolean(Boolean.TRUE, "whoami", "enable")) {
            log.debug("Trying WhoAmI");
            WhoAmIExtendedResult whoAmIExtendedResult = (WhoAmIExtendedResult) connection.processExtendedOperation(new WhoAmIExtendedRequest());
            if (whoAmIExtendedResult.getResultCode() == ResultCode.SUCCESS) {
                String authzID = whoAmIExtendedResult.getAuthorizationID();
                log.debug("Got WhoAmI: {}", authzID);
                if (!Arrays.asList("", "u:", "dn:").contains(authzID)) {
                    vars.put(VARS_AUTH_WHO_AM_I, authzID);
                }
            }
        }
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(ResultCode.SUCCESS));
    } catch (LDAPException e) {
        log.warn("Authentication exception", e.getExceptionMessage());
        log.debug("Authentication exception", e);
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(e.getResultCode()));
        vars.put(VARS_MESSAGE, e.getMessage());
        if (ResultCode.LOCAL_ERROR.equals(e.getResultCode())) {
            vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getCause().getClass().getName(), e.getCause().getMessage()));
        } else {
            if (e.getDiagnosticMessage() != null) {
                vars.put(VARS_DIAGNOSTIC_MESSAGE, e.getDiagnosticMessage());
            }
        }
        try {
            if (PasswordExpiredControl.get(e) != null) {
                log.debug("Password is expired");
                vars.put(VARS_RESULT_CODE, "PASSWORD_EXPIRED");
                vars.put(VARS_MESSAGE, "Password expired");
            }
        } catch (LDAPException e1) {
            log.debug("Ignoring exception during get of expired control", e1);
        }
    } catch (Exception e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_MESSAGE, e.getMessage());
        vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getClass().getName(), e.getMessage()));
    } finally {
        if (connection != null) {
            if (authCheckProps.getBoolean(Boolean.FALSE, "reuse-connections")) {
                connectionPoolEntry.connectionPool.releaseAndReAuthenticateConnection(connection);
            } else {
                connectionPoolEntry.connectionPool.discardConnection(connection);
            }
        }
    }
    vars.put(VARS_AUTH_TRANSLATED_MESSAGE, translateDiagnosticMessage(authCheckProps.get("diagnostic"), vars));
    log.debug("authCheck Return");
}
#end_block

#method_before
private void writeSeclabel() {
    writer.writeStartElement("seclabel");
    writer.writeAttributeString("type", "none");
    writer.writeAttributeString("relabel", "no");
    writer.writeAttributeString("model", "dac");
    writer.writeEndElement();
}
#method_after
private void writeSeclabel() {
    // We need to make sure that libvirt DAC (file system permission driver)
    // is disabled for disks:
    // model='dac' -- dac is the file system permissions driver
    // type='none' -- type is currently used for SELinux/AppArmor drivers
    // relabel='no' -- disable the change of permissions
    // See https://libvirt.org/formatdomain.html#seclabel for more details.
    writer.writeStartElement("seclabel");
    writer.writeAttributeString("model", "dac");
    writer.writeAttributeString("type", "none");
    writer.writeAttributeString("relabel", "no");
    writer.writeEndElement();
}
#end_block

#method_before
public boolean isPrefixValid(String mask) {
    return mask != null && mask.matches("^/?" + ValidationUtils.IPV4_SUBNET_PREFIX_PATTERN + "$");
}
#method_after
public boolean isPrefixValid(String mask) {
    return mask != null && mask.matches("^/?" + ValidationUtils.SUBNET_PREFIX_PATTERN + "$");
}
#end_block

#method_before
public BigInteger convertIpAddressToBigInt(String ipAddr) {
    // Unfortunately GWT is not capable of using InetAddress so I have to by other method
    try {
        InetAddress inetAddress = InetAddress.getByName(ipAddr);
        return new BigInteger(inetAddress.getAddress());
    } catch (UnknownHostException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public BigInteger convertIpAddressToBigInt(String ipAddr) {
    if (ipAddr.matches(ValidationUtils.IPV4_PATTERN)) {
        return new BigInteger(convertIpv4AddressToBytes(ipAddr));
    } else if (ipAddr.matches(ValidationUtils.IPV6_PATTERN)) {
        return new BigInteger(expandIpv6String(ipAddr), 16);
    }
    // This should not happen as the string that is going to be converted should be already validated
    return null;
}
#end_block

#method_before
public boolean isCidrFormatValid(String cidr) {
    return cidr != null && cidr.matches(ValidationUtils.IPV4_CIDR_FORMAT_PATTERN);
}
#method_after
public boolean isCidrFormatValid(String cidr) {
    return cidr != null && cidr.matches(ValidationUtils.CIDR_FORMAT_PATTERN);
}
#end_block

#method_before
@Override
public Disk update(Disk incoming) {
    // If the QCOW version is specified, then perform the update:
    if (incoming.isSetQcowVersion()) {
        return performUpdate(incoming, new QueryIdResolver<>(QueryType.GetDiskByDiskId, IdQueryParameters.class), ActionType.AmendImageGroupVolumes, new UpdateParametersProvider());
    }
    // If the QCOW version isn't specified, then return 409
    throw new WebApplicationException(Response.Status.CONFLICT);
}
#method_after
@Override
public Disk update(Disk incoming) {
    // If the QCOW version is specified, then perform the update:
    if (incoming.isSetQcowVersion()) {
        return performUpdate(incoming, new QueryIdResolver<>(QueryType.GetDiskByDiskId, IdQueryParameters.class), ActionType.AmendImageGroupVolumes, new UpdateParametersProvider());
    }
    // If the QCOW version isn't specified, then return 409
    throw new WebFaultException(null, localize(Messages.DISK_UPDATE_NOT_PERMITTED), Response.Status.CONFLICT);
}
#end_block

#method_before
@Override
public List<T> getAll(Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("qos_type", getQosType()).addValue("v_is_filtered", isFiltered);
    if (userID != null) {
        parameterSource = parameterSource.addValue("v_user_id", userID.getUuid());
    }
    return getCallsHandler().executeReadList("GetAllQosByQosType", createEntityRowMapper(), parameterSource);
}
#method_after
@Override
public List<T> getAll(Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    if (userID != null) {
        parameterSource = parameterSource.addValue("user_id", userID.getUuid());
    }
    if (isFiltered) {
        switch(getQosType()) {
            case NETWORK:
                return getCallsHandler().executeReadList("GetAllNetworkQos", createEntityRowMapper(), parameterSource);
            case CPU:
                return getCallsHandler().executeReadList("GetAllCpuQos", createEntityRowMapper(), parameterSource);
            case STORAGE:
                return getCallsHandler().executeReadList("GetAllStorageQos", createEntityRowMapper(), parameterSource);
            case HOSTNETWORK:
                return getCallsHandler().executeReadList("GetAllHostNetworkQos", createEntityRowMapper(), parameterSource);
        }
    }
    parameterSource = parameterSource.addValue("qos_type", getQosType());
    return getCallsHandler().executeReadList("GetAllQosByQosType", createEntityRowMapper(), parameterSource);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    List<String> extraParams = new ArrayList<>();
    extraParams.add(getParameters().getVolumeId().toString());
    extraParams.add(getParameters().getImageId().toString());
    CinderlibReturnValue returnValue;
    try {
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(managedBlockStorage.getAllDriverOptions(), false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibExecutor.CinderlibCommand.CREATE_VOLUME_FROM_SNAPSHOT, params);
        Guid clonedVolumeGuid = Guid.createGuidFromString(returnValue.getOutput());
        getParameters().setDestinationImageId(clonedVolumeGuid);
    } catch (Exception e) {
        log.error("Failed executing creating volume from snapshot", e);
        return;
    }
    if (!returnValue.getSucceed()) {
        return;
    }
    createVolumeFromSnapshotInDB();
    setSucceeded(true);
    persistCommandIfNeeded();
}
#method_after
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    List<String> extraParams = new ArrayList<>();
    extraParams.add(getParameters().getVolumeId().toString());
    extraParams.add(getParameters().getImageId().toString());
    CinderlibReturnValue returnValue;
    try {
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(managedBlockStorage.getAllDriverOptions(), false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibExecutor.CinderlibCommand.CREATE_VOLUME_FROM_SNAPSHOT, params);
        if (!returnValue.getSucceed()) {
            return;
        }
        Guid clonedVolumeGuid = Guid.createGuidFromString(returnValue.getOutput());
        getParameters().setDestinationImageId(clonedVolumeGuid);
    } catch (Exception e) {
        log.error("Failed executing creating volume from snapshot", e);
        return;
    }
    createVolumeFromSnapshotInDB();
    setSucceeded(true);
    persistCommandIfNeeded();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotStatus.LOCKED, SnapshotType.PREVIEW, getVm(), true, previousActiveSnapshot.getMemoryDiskId(), previousActiveSnapshot.getMetadataDiskId(), null, null, null, getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), SnapshotStatus.OK, restoreMemory ? snapshotToBePreviewed.getMemoryDiskId() : null, restoreMemory ? snapshotToBePreviewed.getMetadataDiskId() : null, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    initializeSnapshotsLeasesParams();
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE) {
                        tryBackToManagedBlockSnapshot(image, newActiveSnapshotId);
                        continue;
                    }
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    if (log.isInfoEnabled()) {
        log.info("Previewing snapshot {} with the disks:\n{}", getSnapshotName(), filteredImages.stream().map(disk -> String.format("%s (%s) to imageId %s", disk.getName(), disk.getId().toString(), disk.getImageId().toString())).collect(Collectors.joining("\n")));
    }
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotStatus.LOCKED, SnapshotType.PREVIEW, getVm(), true, previousActiveSnapshot.getMemoryDiskId(), previousActiveSnapshot.getMetadataDiskId(), null, null, null, getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), SnapshotStatus.OK, restoreMemory ? snapshotToBePreviewed.getMemoryDiskId() : null, restoreMemory ? snapshotToBePreviewed.getMetadataDiskId() : null, snapshotToBePreviewed.getCreationDate(), images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    initializeSnapshotsLeasesParams();
    final List<ManagedBlockStorageDisk> managedBlockStorageDisks = new ArrayList<>();
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE) {
                        managedBlockStorageDisks.add((ManagedBlockStorageDisk) image);
                        continue;
                    }
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    ActionReturnValue actionReturnValue = runInternalActionWithTasksContext(ActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (actionReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(actionReturnValue.getInternalVdsmTaskIdList());
                    } else if (actionReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(actionReturnValue.getFault().getError(), actionReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (getParameters().getLeaseAction() == LeaseAction.CREATE_NEW_LEASE) {
                    if (!addVmLease(getParameters().getDstLeaseDomainId(), getVm().getId(), false)) {
                        log.error("Failed to create lease for VM '{}' on storage domain '{}'", getVm().getName(), getParameters().getDstLeaseDomainId());
                        throw new EngineException(EngineError.FailedToCreateLease);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                managedBlockStorageDisks.forEach(disk -> tryBackToManagedBlockSnapshot(disk, newActiveSnapshotId));
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(ActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and the VM Configuration
        // (including clusterCompatibilityVersionOrigin) is already restored at this point. Otherwise,
        // if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
private CreateCinderSnapshotParameters buildCinderChildCommandParameters(CinderDisk cinderDisk, Guid newSnapshotId) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDestinationImageId(cinderDisk.getImageId());
    createParams.setVmSnapshotId(newSnapshotId);
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#method_after
private CreateCinderSnapshotParameters buildCinderChildCommandParameters(DiskImage cinderDisk, Guid newSnapshotId) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDestinationImageId(cinderDisk.getImageId());
    createParams.setVmSnapshotId(newSnapshotId);
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<ManagedBlockStorageDisk> managedBlockDisksImagesToPreview = DisksFilter.filterManagedBlockStorageDisks(imagesToPreview);
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
        imagesToPreview.addAll(managedBlockDisksImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        List<ManagedBlockStorageDisk> managedBlockStorageDisks = DisksFilter.filterManagedBlockStorageDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
        imagesToPreview.addAll(managedBlockStorageDisks);
    }
    return imagesToPreview;
}
#end_block

#method_before
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getImageId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice);
    });
}
#method_after
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    return attachManagedBlockStorageDisks(vm, vmHandler, vds, false);
}
#end_block

#method_before
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getImageId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice);
    });
}
#method_after
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds, boolean isLiveMigration) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getImageId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice, isLiveMigration);
    });
}
#end_block

#method_before
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId());
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#method_after
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    return saveDevices(disk, vds, vmDevice, false);
}
#end_block

#method_before
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId());
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#method_after
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice, boolean isLiveMigration) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId(), isLiveMigration);
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    ActionReturnValue saveDeviceReturnValue = backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return saveDeviceReturnValue.getSucceeded();
}
#end_block

#method_before
private void saveAttachedHost(VmDevice vmDevice, Guid vdsId) {
    TransactionSupport.executeInNewTransaction(() -> {
        Map<String, Object> specParams = new HashMap<>();
        specParams.put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, vdsId);
        if (vmDevice.getSpecParams() != null) {
            vmDevice.getSpecParams().putAll(specParams);
        } else {
            vmDevice.setSpecParams(specParams);
        }
        vmDeviceDao.update(vmDevice);
        return null;
    });
}
#method_after
private void saveAttachedHost(VmDevice vmDevice, Guid vdsId, boolean isLiveMigration) {
    TransactionSupport.executeInNewTransaction(() -> {
        Map<String, Object> specParams = new HashMap<>();
        if (isLiveMigration) {
            specParams.put(ManagedBlockStorageDisk.DEST_VDS_ID, vdsId);
        } else {
            specParams.put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, vdsId);
        }
        if (vmDevice.getSpecParams() != null) {
            vmDevice.getSpecParams().putAll(specParams);
        } else {
            vmDevice.setSpecParams(specParams);
        }
        vmDeviceDao.update(vmDevice);
        return null;
    });
}
#end_block

#method_before
public void disconnectManagedBlockStorageDisks(VM vm, VmHandler vmHandler) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    disks.forEach(disk -> disconnectManagedBlockStorageDisk(vm, disk));
}
#method_after
public boolean disconnectManagedBlockStorageDisks(VM vm, VmHandler vmHandler) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    return disks.stream().allMatch(disk -> disconnectManagedBlockStorageDisk(vm, disk));
}
#end_block

#method_before
public void disconnectManagedBlockStorageDisk(VM vm, DiskImage disk) {
    VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
    DisconnectManagedBlockStorageDeviceParameters parameters = new DisconnectManagedBlockStorageDeviceParameters();
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    parameters.setDiskId(disk.getId());
    parameters.setVdsId((Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.ATTACHED_VDS_ID));
    backend.runInternalAction(ActionType.DisconnectManagedBlockStorageDevice, parameters);
}
#method_after
public boolean disconnectManagedBlockStorageDisk(VM vm, DiskImage disk) {
    VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
    DisconnectManagedBlockStorageDeviceParameters parameters = new DisconnectManagedBlockStorageDeviceParameters();
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    parameters.setDiskId(disk.getId());
    Guid vdsId = (Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.ATTACHED_VDS_ID);
    // Disk is being disconnected as part of live migration
    Guid destVdsId = (Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.DEST_VDS_ID);
    if (destVdsId != null) {
        // The device is now attached only to the destination host
        vmDevice.getSpecParams().put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, destVdsId);
        vmDevice.getSpecParams().remove(ManagedBlockStorageDisk.DEST_VDS_ID);
        TransactionSupport.executeInNewTransaction(() -> {
            vmDeviceDao.update(vmDevice);
            return null;
        });
    }
    parameters.setVdsId(vdsId);
    ActionReturnValue returnValue = backend.runInternalAction(ActionType.DisconnectManagedBlockStorageDevice, parameters);
    return returnValue.getSucceeded();
}
#end_block

#method_before
@Override
public void init() {
    getParameters().setUseCinderCommandCallback(isCinderDisksExist());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    setSnapshotName(getParameters().getDescription());
    setStoragePoolId(getVm() != null ? getVm().getStoragePoolId() : null);
}
#method_after
@Override
public void init() {
    getParameters().setUseCinderCommandCallback(diskOfTypeExists(DiskStorageType.CINDER));
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    setSnapshotName(getParameters().getDescription());
    setStoragePoolId(getVm() != null ? getVm().getStoragePoolId() : null);
}
#end_block

#method_before
private boolean shouldFreezeOrThawVm() {
    Predicate<List<DiskImage>> hasManagedBlockDisks = disks -> !DisksFilter.filterManagedBlockStorageDisks(disks).isEmpty();
    return isLiveSnapshotApplicable() && (isCinderDisksExist() || hasManagedBlockDisks.test(getDisksList())) && getParameters().getParentCommand() != ActionType.LiveMigrateDisk;
}
#method_after
private boolean shouldFreezeOrThawVm() {
    return isLiveSnapshotApplicable() && (diskOfTypeExists(DiskStorageType.CINDER) || diskOfTypeExists(DiskStorageType.MANAGED_BLOCK_STORAGE)) && getParameters().getParentCommand() != ActionType.LiveMigrateDisk;
}
#end_block

#method_before
public ValidationResult isOperationSupportedByManagedBlockStorage(ActionType actionType) {
    return allowedStorageOperations.contains(actionType) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_FOR_MANAGED_BLOCK_STORAGE_TYPE);
}
#method_after
public static ValidationResult isOperationSupportedByManagedBlockStorage(ActionType actionType) {
    if (!isDataBaseInitialized) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CINDERLIB_DATA_BASE_REQUIRED);
    }
    return allowedStorageOperations.contains(actionType) ? ValidationResult.VALID : new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_FOR_MANAGED_BLOCK_STORAGE_TYPE);
}
#end_block

#method_before
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE) {
            removeManagedBlockDiskSnapshot(source);
            continue;
        }
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == ActionType.RemoveSnapshotSingleDiskLive) {
            commandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            ActionReturnValue actionReturnValueturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            getTaskIdList().addAll(actionReturnValueturnValue.getInternalVdsmTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#method_after
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    List<ManagedBlockStorageDisk> managedBlockDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE) {
            managedBlockDisks.add((ManagedBlockStorageDisk) source);
            continue;
        }
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == ActionType.RemoveSnapshotSingleDiskLive) {
            commandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType());
            ActionReturnValue actionReturnValueturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
            getTaskIdList().addAll(actionReturnValueturnValue.getInternalVdsmTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
    managedBlockDisks.forEach(disk -> removeManagedBlockSnapshot(disk));
}
#end_block

#method_before
private ImagesContainterParametersBase buildRemoveCinderSnapshotDiskParameters(CinderDisk cinderDisk) {
    ImagesContainterParametersBase removeCinderSnapshotParams = new ImagesContainterParametersBase(cinderDisk.getImageId());
    removeCinderSnapshotParams.setDestinationImageId(cinderDisk.getImageId());
    removeCinderSnapshotParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    removeCinderSnapshotParams.setParentCommand(getActionType());
    removeCinderSnapshotParams.setParentParameters(getParameters());
    return removeCinderSnapshotParams;
}
#method_after
private ImagesContainterParametersBase buildRemoveCinderSnapshotDiskParameters(DiskImage disk) {
    ImagesContainterParametersBase removeCinderSnapshotParams = new ImagesContainterParametersBase(disk.getImageId());
    removeCinderSnapshotParams.setDestinationImageId(disk.getImageId());
    removeCinderSnapshotParams.setStorageDomainId(disk.getStorageIds().get(0));
    removeCinderSnapshotParams.setParentCommand(getActionType());
    removeCinderSnapshotParams.setParentParameters(getParameters());
    return removeCinderSnapshotParams;
}
#end_block

#method_before
@PostConstruct
private void init() {
    url = String.format(urlTemplate, config.getProperty(ENGINE_DB_USER), config.getProperty(ENGINE_DB_PASSWORD), config.getProperty(ENGINE_DB_HOST), config.getProperty(ENGINE_DB_PORT));
    cinderlibDir = Paths.get(config.getUsrDir().getAbsolutePath() + CINDERLIB_DIR).toFile();
}
#method_after
@PostConstruct
private void init() {
    url = String.format(urlTemplate, config.getProperty(CINDERLIB_DB_USER), config.getProperty(CINDERLIB_DB_PASSWORD), config.getProperty(CINDERLIB_DB_HOST), config.getProperty(CINDERLIB_DB_PORT), config.getProperty(CINDERLIB_DB_DATABASE));
    cinderlibDir = Paths.get(config.getUsrDir().getAbsolutePath() + CINDERLIB_DIR).toFile();
}
#end_block

#method_before
public CinderlibReturnValue runCommand(CinderlibCommand command, CinderlibCommandParameters params) throws Exception {
    ProcessBuilder cinderlibProcessBuilder = new ProcessBuilder().directory(cinderlibDir).command(generateCommand(command, params)).redirectErrorStream(true);
    Process process = cinderlibProcessBuilder.start();
    String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
    log.info("cinderlib output: {}", output);
    if (!process.waitFor(Config.getValue(ConfigValues.CinderlibCommandTimeoutInMinutes), TimeUnit.MINUTES)) {
        throw new Exception("cinderlib call timed out");
    }
    CinderlibReturnValue returnValue = new CinderlibReturnValue(process.exitValue(), output);
    return returnValue;
}
#method_after
public CinderlibReturnValue runCommand(CinderlibCommand command, CinderlibCommandParameters params) throws Exception {
    ProcessBuilder cinderlibProcessBuilder = new ProcessBuilder().directory(cinderlibDir).command(generateCommand(command, params)).redirectErrorStream(true);
    Process process = cinderlibProcessBuilder.start();
    String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
    if (!process.waitFor(Config.getValue(ConfigValues.CinderlibCommandTimeoutInMinutes), TimeUnit.MINUTES)) {
        throw new Exception("cinderlib call timed out");
    }
    CinderlibReturnValue returnValue = new CinderlibReturnValue(process.exitValue(), output);
    if (!returnValue.getSucceed()) {
        log.error("cinderlib execution failed: {}", output);
    } else {
        log.info("cinderlib output: {}", output);
    }
    return returnValue;
}
#end_block

#method_before
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice);
    });
}
#method_after
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    return attachManagedBlockStorageDisks(vm, vmHandler, vds, false);
}
#end_block

#method_before
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice);
    });
}
#method_after
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds, boolean isLiveMigration) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    if (!disks.isEmpty() && vds.getConnectorInfo() == null) {
        AuditLogable event = new AuditLogableImpl();
        event.addCustomValue("VdsName", vds.getName());
        event.addCustomValue("VmName", vm.getName());
        auditLogDirector.log(event, AuditLogType.CONNECTOR_INFO_MISSING_ON_VDS);
        return false;
    }
    return disks.stream().allMatch(disk -> {
        VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
        return this.saveDevices(disk, vds, vmDevice, isLiveMigration);
    });
}
#end_block

#method_before
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId());
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#method_after
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    return saveDevices(disk, vds, vmDevice, false);
}
#end_block

#method_before
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId());
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#method_after
public boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, VmDevice vmDevice, boolean isLiveMigration) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(vmDevice, vds.getId(), isLiveMigration);
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    vmInfoBuildUtils.setCinderDriverType(disk);
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    ActionReturnValue saveDeviceReturnValue = backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return saveDeviceReturnValue.getSucceeded();
}
#end_block

#method_before
private void saveAttachedHost(VmDevice vmDevice, Guid vdsId) {
    TransactionSupport.executeInNewTransaction(() -> {
        Map<String, Object> specParams = new HashMap<>();
        specParams.put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, vdsId);
        if (vmDevice.getSpecParams() != null) {
            vmDevice.getSpecParams().putAll(specParams);
        } else {
            vmDevice.setSpecParams(specParams);
        }
        vmDeviceDao.update(vmDevice);
        return null;
    });
}
#method_after
private void saveAttachedHost(VmDevice vmDevice, Guid vdsId, boolean isLiveMigration) {
    TransactionSupport.executeInNewTransaction(() -> {
        Map<String, Object> specParams = new HashMap<>();
        if (isLiveMigration) {
            specParams.put(ManagedBlockStorageDisk.DEST_VDS_ID, vdsId);
        } else {
            specParams.put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, vdsId);
        }
        if (vmDevice.getSpecParams() != null) {
            vmDevice.getSpecParams().putAll(specParams);
        } else {
            vmDevice.setSpecParams(specParams);
        }
        vmDeviceDao.update(vmDevice);
        return null;
    });
}
#end_block

#method_before
public void disconnectManagedBlockStorageDisks(VM vm, VmHandler vmHandler) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    disks.forEach(disk -> disconnectManagedBlockStorageDisk(vm, disk));
}
#method_after
public boolean disconnectManagedBlockStorageDisks(VM vm, VmHandler vmHandler) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    return disks.stream().allMatch(disk -> disconnectManagedBlockStorageDisk(vm, disk));
}
#end_block

#method_before
public void disconnectManagedBlockStorageDisk(VM vm, DiskImage disk) {
    VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
    DisconnectManagedBlockStorageDeviceParameters parameters = new DisconnectManagedBlockStorageDeviceParameters();
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    parameters.setDiskId(disk.getId());
    parameters.setVdsId((Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.ATTACHED_VDS_ID));
    backend.runInternalAction(ActionType.DisconnectManagedBlockStorageDevice, parameters);
}
#method_after
public boolean disconnectManagedBlockStorageDisk(VM vm, DiskImage disk) {
    VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), vm.getId()));
    DisconnectManagedBlockStorageDeviceParameters parameters = new DisconnectManagedBlockStorageDeviceParameters();
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    parameters.setDiskId(disk.getId());
    Guid vdsId = (Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.ATTACHED_VDS_ID);
    // Disk is being disconnected as part of live migration
    Guid destVdsId = (Guid) vmDevice.getSpecParams().get(ManagedBlockStorageDisk.DEST_VDS_ID);
    if (destVdsId != null) {
        // The device is now attached only to the destination host
        vmDevice.getSpecParams().put(ManagedBlockStorageDisk.ATTACHED_VDS_ID, destVdsId);
        vmDevice.getSpecParams().remove(ManagedBlockStorageDisk.DEST_VDS_ID);
        TransactionSupport.executeInNewTransaction(() -> {
            vmDeviceDao.update(vmDevice);
            return null;
        });
    }
    parameters.setVdsId(vdsId);
    ActionReturnValue returnValue = backend.runInternalAction(ActionType.DisconnectManagedBlockStorageDevice, parameters);
    return returnValue.getSucceeded();
}
#end_block

#method_before
private Guid findImageForSameDrive(Guid snapshotId, DiskImage diskImage) {
    List<DiskImage> imagesFromSnapshot = diskImageDao.getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage currDiskImage : imagesFromSnapshot) {
        if (diskImage.getId().equals(currDiskImage.getId())) {
            return currDiskImage.getImageId();
        }
    }
    return null;
}
#method_after
private Guid findImageForSameDrive(Guid snapshotId, DiskImage diskImage) {
    List<DiskImage> imagesFromSnapshot = diskImageDao.getAllSnapshotsForVmSnapshot(snapshotId);
    return imagesFromSnapshot.stream().filter(currDiskImage -> diskImage.getId().equals(currDiskImage.getId())).findFirst().map(DiskImage::getImageId).orElse(null);
}
#end_block

#method_before
private boolean handleUndo() {
    // the clone of the volume we created for the snapshot
    return getParameters().getManagedBlockStorageDisks().stream().allMatch(disk -> {
        TransactionSupport.executeInNewTransaction(() -> {
            managedBlockStorageDiskUtil.updateOldImageAsActive(Snapshot.SnapshotType.PREVIEW, true, disk);
            return null;
        });
        // Remove cloned volume
        return removeDisk(disk);
    });
}
#method_after
private boolean handleUndo() {
    // When undoing a preview snapshot we want to remove
    // the clone of the volume we created for the snapshot
    List<Guid> failedToRemoveDisks = new ArrayList<>();
    getParameters().getManagedBlockStorageDisks().stream().forEach(disk -> {
        TransactionSupport.executeInNewTransaction(() -> {
            managedBlockStorageDiskUtil.updateOldImageAsActive(Snapshot.SnapshotType.PREVIEW, true, disk);
            return null;
        });
        // Remove cloned volume
        if (!removeDisk(disk)) {
            failedToRemoveDisks.add(disk.getImageId());
        }
    });
    if (!failedToRemoveDisks.isEmpty()) {
        addCustomValue("DiskGuids", StringUtils.join(failedToRemoveDisks, ", "));
        auditLogDirector.log(this, AuditLogType.UNDO_SNAPSHOT_FAILURE_PARTIAL);
        return false;
    }
    return true;
}
#end_block

#method_before
private void createImage(DiskImage image) {
    VolumeFormat volumeFormat = determineVolumeFormat(getParameters().getDestDomain(), getParameters().getSrcDomain(), image.getVolumeFormat(), image.getVolumeType());
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), determineSourceImageGroup(image), image.getParentId(), getParameters().getImageGroupID(), image.getImageId(), volumeFormat, getParameters().getDescription(), image.getSize(), imagesHandler.determineImageInitialSize(image.getImage(), volumeFormat, getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId().toString()));
    runInternalActionWithTasksContext(ActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createImage(DiskImage image) {
    VolumeFormat volumeFormat = determineVolumeFormat(getParameters().getDestDomain(), image.getVolumeFormat(), image.getVolumeType());
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), determineSourceImageGroup(image), image.getParentId(), getParameters().getImageGroupID(), image.getImageId(), volumeFormat, getParameters().getDescription(), image.getSize(), imagesHandler.determineImageInitialSize(image.getImage(), volumeFormat, getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId().toString()));
    runInternalActionWithTasksContext(ActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
private VolumeFormat determineVolumeFormat(Guid destStorageDomainId, Guid srcStorageDomainId, VolumeFormat srcVolumeFormat, VolumeType srcVolumeType) {
    StorageDomainStatic destStorageDomain = storageDomainStaticDao.get(destStorageDomainId);
    StorageDomainStatic srcStorageDomain = storageDomainStaticDao.get(srcStorageDomainId);
    // File based raw/thin disk will convert to cow/sparse
    if (srcStorageDomain.getStorageType().isFileDomain() && destStorageDomain.getStorageType().isBlockDomain() && srcVolumeFormat.equals(VolumeFormat.RAW) && srcVolumeType.equals(VolumeType.Sparse)) {
        return VolumeFormat.COW;
    }
    return srcVolumeFormat;
}
#method_after
private VolumeFormat determineVolumeFormat(Guid destStorageDomainId, VolumeFormat srcVolumeFormat, VolumeType srcVolumeType) {
    // File based raw/thin disk will convert to cow/sparse
    if (srcVolumeFormat.equals(VolumeFormat.RAW) && srcVolumeType.equals(VolumeType.Sparse)) {
        StorageDomainStatic destStorageDomain = storageDomainStaticDao.get(destStorageDomainId);
        if (destStorageDomain.getStorageType().isBlockDomain()) {
            return VolumeFormat.COW;
        }
    }
    return srcVolumeFormat;
}
#end_block

#method_before
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) throws RuntimeException {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), req == null ? "" : req.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            if (queryRetVal.getActionReturnValue() == CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED) {
                throw new RuntimeException(String.format("Unable to login user %s@%s because the maximum number of allowed sessions %s is exceeded", username, profile, EngineLocalConfig.getInstance().getInteger("ENGINE_MAX_USER_SESSIONS")));
            }
            throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#method_after
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) throws Exception {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), req == null ? "" : req.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            if (queryRetVal.getActionReturnValue() == CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED) {
                throw new RuntimeException(String.format("Unable to login user %s@%s because the maximum number of allowed sessions %s is exceeded", username, profile, EngineLocalConfig.getInstance().getInteger("ENGINE_MAX_USER_SESSIONS")));
            }
            throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
        throw ex;
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#end_block

#method_before
private boolean propertiesRequiringUnplugPlugWereUpdated() {
    return !oldIface.getType().equals(getInterface().getType()) || getInterface().getType() == VmInterfaceType.pciPassthrough.getValue() || !oldIface.getMacAddress().equals(getMacAddress());
}
#method_after
private boolean propertiesRequiringUnplugPlugWereUpdated() {
    return !oldIface.getType().equals(getInterface().getType()) || oldIface.isPassthrough() || !oldIface.getMacAddress().equals(getMacAddress());
}
#end_block

#method_before
@Mapping(from = VmBackup.class, to = Backup.class)
public static Backup map(VmBackup entity, Backup template) {
    Backup model = template == null ? new Backup() : template;
    model.setId(entity.getId().toString());
    if (entity.getFromCheckpointId() != null) {
        model.setFromCheckpointId(entity.getFromCheckpointId().toString());
    }
    if (entity.getToCheckpointId() != null) {
        model.setToCheckpointId(entity.getToCheckpointId().toString());
    }
    if (entity.getPhase() != null) {
        model.setPhase(map(entity.getPhase()));
    }
    if (entity.getDisks() != null) {
        model.setDisks(new Disks());
        entity.getDisks().stream().map(id -> {
            Disk disk = new Disk();
            disk.setId(id.toString());
            return disk;
        }).forEach(model.getDisks().getDisks()::add);
    }
    if (entity.getCreationDate() != null) {
        model.setCreationDate(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getVmId() != null) {
        Vm vm = new Vm();
        vm.setId(entity.getVmId().toString());
        model.setVm(vm);
    }
    return model;
}
#method_after
@Mapping(from = VmBackup.class, to = Backup.class)
public static Backup map(VmBackup entity, Backup template) {
    Backup model = template == null ? new Backup() : template;
    model.setId(entity.getId().toString());
    if (entity.getFromCheckpointId() != null) {
        model.setFromCheckpointId(entity.getFromCheckpointId().toString());
    }
    if (entity.getToCheckpointId() != null) {
        model.setToCheckpointId(entity.getToCheckpointId().toString());
    }
    if (entity.getPhase() != null) {
        model.setPhase(map(entity.getPhase()));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationDate(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getVmId() != null) {
        Vm vm = new Vm();
        vm.setId(entity.getVmId().toString());
        model.setVm(vm);
    }
    return model;
}
#end_block

#method_before
public static BackupPhase map(org.ovirt.engine.core.common.businessentities.VmBackupPhase action) {
    switch(action) {
        case Initializing:
            return BackupPhase.INITIALIZING;
        case Starting:
            return BackupPhase.STARTING;
        case Ready:
            return BackupPhase.READY;
        case Finalizing:
            return BackupPhase.FINALIZING;
        default:
            return null;
    }
}
#method_after
public static BackupPhase map(org.ovirt.engine.core.common.businessentities.VmBackupPhase action) {
    switch(action) {
        case INITIALIZING:
            return BackupPhase.INITIALIZING;
        case STARTING:
            return BackupPhase.STARTING;
        case READY:
            return BackupPhase.READY;
        case FINALIZING:
            return BackupPhase.FINALIZING;
        default:
            return null;
    }
}
#end_block

#method_before
public static org.ovirt.engine.core.common.businessentities.VmBackupPhase map(BackupPhase action) {
    switch(action) {
        case INITIALIZING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.Initializing;
        case STARTING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.Starting;
        case READY:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.Ready;
        case FINALIZING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.Finalizing;
        default:
            return null;
    }
}
#method_after
public static org.ovirt.engine.core.common.businessentities.VmBackupPhase map(BackupPhase action) {
    switch(action) {
        case INITIALIZING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.INITIALIZING;
        case STARTING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.STARTING;
        case READY:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.READY;
        case FINALIZING:
            return org.ovirt.engine.core.common.businessentities.VmBackupPhase.FINALIZING;
        default:
            return null;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskExistenceValidator diskExistenceValidator = createDiskExistenceValidator(getDiskIds());
    if (!validate(diskExistenceValidator.disksNotExist())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImagesValidator(getDisks());
    if (!validate(diskImagesValidator.incrementalBackupEnabled())) {
        return false;
    }
    if (!getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.CANNOT_START_BACKUP_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    if (!vmBackupDao.getAllForVm(getVmId()).isEmpty()) {
        return failValidation(EngineMessage.CANNOT_START_BACKUP_ALREADY_IN_PROGRESS);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    DiskExistenceValidator diskExistenceValidator = createDiskExistenceValidator(getDiskIds());
    if (!validate(diskExistenceValidator.disksNotExist())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImagesValidator(getDisks());
    if (!validate(diskImagesValidator.incrementalBackupEnabled())) {
        return false;
    }
    if (!getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.CANNOT_START_BACKUP_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    if (!vmBackupDao.getAllForVm(getVmId()).isEmpty()) {
        return failValidation(EngineMessage.CANNOT_START_BACKUP_ALREADY_IN_PROGRESS);
    }
    if (!getVds().isBackupEnabled()) {
        return failValidation(EngineMessage.CANNOT_START_BACKUP_NOT_SUPPORTED_BY_VDS, String.format("$vdsName %s", getVdsName()));
    }
    return true;
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallRequiredAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    setHasGlusterDisconnectedAlert(false);
    setHasDefaultRouteAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.DefaultRouteReportedByVdsm, getEntity().getClusterCompatibilityVersion().getValue())) {
        Frontend.getInstance().runQuery(QueryType.IsDefaultRouteRoleNetworkAttachedToHost, new IsDefaultRouteRoleNetworkAttachedToHostQueryParameters(getEntity().getClusterId(), getEntity().getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
            getEntity().setIsDefaultRouteRoleNetworkAttached((Boolean) returnValue.getReturnValue());
            setHasDefaultRouteAlert(!(Boolean) returnValue.getReturnValue());
        }));
    }
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    if (getEntity().getStaticData().isReinstallRequired()) {
        setHasReinstallRequiredAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    if (getEntity().getClusterSupportsGlusterService() && !(getEntity().getStatus() == VDSStatus.Installing || getEntity().getStatus() == VDSStatus.Initializing) && getEntity().getGlusterPeerStatus() != PeerStatus.CONNECTED) {
        setHasGlusterDisconnectedAlert(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasUpgradeAlert(getEntity().isUpdateAvailable() && getEntity().getStatus() != VDSStatus.Installing);
    setHasAnyAlert();
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallRequiredAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    setHasGlusterDisconnectedAlert(false);
    setHasDefaultRouteAlert(false);
    // Check the network alert presense.
    setHasNICsAlert(getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty());
    if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.DefaultRouteReportedByVdsm, getEntity().getClusterCompatibilityVersion().getValue())) {
        setHasDefaultRouteAlert(getEntity().isDefaultRouteRoleNetworkAttached());
    }
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    if (getEntity().getStaticData().isReinstallRequired()) {
        setHasReinstallRequiredAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    if (getEntity().getClusterSupportsGlusterService() && !(getEntity().getStatus() == VDSStatus.Installing || getEntity().getStatus() == VDSStatus.Initializing) && getEntity().getGlusterPeerStatus() != PeerStatus.CONNECTED) {
        setHasGlusterDisconnectedAlert(true);
    }
    setNonOperationalReasonEntity(getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : getEntity().getNonOperationalReason());
    updateActionAvailability();
    setHasUpgradeAlert(getEntity().isUpdateAvailable() && getEntity().getStatus() != VDSStatus.Installing);
    setHasAnyAlert();
}
#end_block

#method_before
@Override
public void setItems(Collection<PairQueryable<VdsNetworkInterface, VDS>> value) {
    AsyncDataProvider.getInstance().updateVDSInterfaceList(value, () -> super.setItems(value));
    AsyncDataProvider.getInstance().updateVDSDefaultRouteRole(value, () -> super.setItems(value));
}
#method_after
@Override
public void setItems(Collection<PairQueryable<VdsNetworkInterface, VDS>> value) {
    AsyncDataProvider.getInstance().updateVDSDefaultRouteRole(value, () -> super.setItems(value));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Optional<Network> defRouteNetwork = networkDao.getAllForCluster(((IdsQueryParameters) getParameters()).getIds().get(0)).stream().filter(n -> n.getCluster().isDefaultRoute()).findFirst();
    Optional<NetworkAttachment> attachment = networkAttachmentDao.getAllForHost(((IdsQueryParameters) getParameters()).getIds().get(1)).stream().filter(na -> defRouteNetwork.isPresent() && Objects.equals(na.getNetworkId(), defRouteNetwork.get().getId())).findFirst();
    getQueryReturnValue().setReturnValue(attachment.isPresent());
}
#method_after
@Override
protected void executeQueryCommand() {
    Optional<Network> defRouteNetwork = networkDao.getAllForCluster(getParameters().getClusterId()).stream().filter(n -> n.getCluster().isDefaultRoute()).findFirst();
    Optional<NetworkAttachment> attachment = networkAttachmentDao.getAllForHost(getParameters().getHostId()).stream().filter(na -> defRouteNetwork.isPresent() && Objects.equals(na.getNetworkId(), defRouteNetwork.get().getId())).findFirst();
    getQueryReturnValue().setReturnValue(attachment.isPresent());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVdsStatus(VDSStatus.Installing);
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-mgmt-ansible").logFileName(getVds().getHostName()).logFileSuffix(CorrelationIdTracker.getCorrelationId()).variables(new Pair<>("ovirt_pki_dir", config.getPKIDir()), new Pair<>("ovirt_vds_hostname", getVds().getHostName()), new Pair<>("ovirt_engine_usr", config.getUsrDir()), new Pair<>("ovirt_organizationname", Config.getValue(ConfigValues.OrganizationName)), new Pair<>("ovirt_vdscertificatevalidityinyears", Config.<Integer>getValue(ConfigValues.VdsCertificateValidityInYears)), new Pair<>("ovirt_signcerttimeoutinseconds", Config.<Integer>getValue(ConfigValues.SignCertTimeoutInSeconds)), new Pair<>("ovirt_ca_cert", PKIResources.getCaCertificate().toString(PKIResources.Format.X509_PEM)), new Pair<>("ovirt_ca_key", PKIResources.getCaCertificate().toString(PKIResources.Format.OPENSSH_PUBKEY).replace("\n", ""))).playbook(AnsibleConstants.HOST_ENROLL_CERTIFICATE);
    setVdsStatus(VDSStatus.Maintenance);
    setSucceeded(true);
    if (ansibleExecutor.runCommand(command).getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        log.error("Failed to enroll certificate for host '{}': please check log for more details: {}", getVds().getName(), command.logFile());
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#method_after
@Override
protected void executeCommand() {
    setVdsStatus(VDSStatus.Installing);
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-enroll-certs-ansible").logFileName(getVds().getHostName()).logFileSuffix(CorrelationIdTracker.getCorrelationId()).variables(new Pair<>("ovirt_pki_dir", config.getPKIDir()), new Pair<>("ovirt_vds_hostname", getVds().getHostName()), new Pair<>("ovirt_engine_usr", config.getUsrDir()), new Pair<>("ovirt_organizationname", Config.getValue(ConfigValues.OrganizationName)), new Pair<>("ovirt_vdscertificatevalidityinyears", Config.<Integer>getValue(ConfigValues.VdsCertificateValidityInYears)), new Pair<>("ovirt_signcerttimeoutinseconds", Config.<Integer>getValue(ConfigValues.SignCertTimeoutInSeconds)), new Pair<>("ovirt_ca_cert", PKIResources.getCaCertificate().toString(PKIResources.Format.X509_PEM)), new Pair<>("ovirt_ca_key", PKIResources.getCaCertificate().toString(PKIResources.Format.OPENSSH_PUBKEY).replace("\n", ""))).playbook(AnsibleConstants.HOST_ENROLL_CERTIFICATE);
    setVdsStatus(VDSStatus.Maintenance);
    setSucceeded(true);
    if (ansibleExecutor.runCommand(command).getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        log.error("Failed to enroll certificate for host '{}': please check log for more details: {}", getVds().getName(), command.logFile());
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), NetworkUtils.getHostMtuActualValue(network), isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    addReportedIpv6Configuration(result);
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    boolean defaultRouteReportedByVdsm = FeatureSupported.isDefaultRouteReportedByVdsm(cluster.getCompatibilityVersion());
    result.add(DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), isDefaultRouteNetwork, !defaultRouteReportedByVdsm || Objects.equals(iface.isIpv4DefaultRoute(), isDefaultRouteNetwork));
    return result;
}
#method_after
public ReportedConfigurations reportConfigurationsOnHost() {
    ReportedConfigurations result = new ReportedConfigurations();
    result.add(ReportedConfigurationType.MTU, iface.getMtu(), NetworkUtils.getHostMtuActualValue(network), isNetworkMtuInSync());
    result.add(ReportedConfigurationType.BRIDGED, iface.isBridged(), network.isVmNetwork());
    result.add(ReportedConfigurationType.VLAN, iface.getVlanId(), network.getVlanId());
    result.add(ReportedConfigurationType.SWITCH_TYPE, iface.getReportedSwitchType(), cluster.getRequiredSwitchTypeForCluster());
    addReportedIpv4Configuration(result);
    addReportedIpv6Configuration(result);
    boolean reportHostQos = ifaceQos != null || hostNetworkQos != null;
    if (reportHostQos) {
        result.add(OUT_AVERAGE_LINK_SHARE, getOutAverageLinkshare(ifaceQos), getOutAverageLinkshare(hostNetworkQos));
        result.add(OUT_AVERAGE_UPPER_LIMIT, getOutAverageUpperlimit(ifaceQos), getOutAverageUpperlimit(hostNetworkQos));
        result.add(OUT_AVERAGE_REAL_TIME, getOutAverageRealtime(ifaceQos), getOutAverageRealtime(hostNetworkQos));
    }
    addDnsConfiguration(result);
    addReportedDefaultRouteConfiguration(result);
    return result;
}
#end_block

#method_before
private boolean isIpv6AddressInSync(String attachmentValue, String ifaceValue) {
    IpAddressPredicate p = new IpAddressPredicate(ifaceValue);
    return p.test(attachmentValue) || (p.isUnspecifiedIpv6() && attachmentValue == null);
}
#method_after
private boolean isIpv6AddressInSync(String attachmentValue, String ifaceValue) {
    IpAddressPredicate p = new IpAddressPredicate(ifaceValue);
    return p.test(attachmentValue);
}
#end_block

#method_before
private ReportedConfiguration defaultRouteReportedConfiguration(boolean expectedValue) {
    return new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, iface.isIpv4DefaultRoute(), expectedValue, Objects.equals(iface.isIpv4DefaultRoute(), expectedValue));
}
#method_after
private ReportedConfiguration defaultRouteReportedConfiguration(boolean expectedValue) {
    boolean isDefaultRouteInterface = isDefaultRouteOnInterfacePredicate().test(iface);
    return new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, isDefaultRouteInterface, expectedValue, Objects.equals(isDefaultRouteInterface, expectedValue));
}
#end_block

#method_before
@Test
public void testReportConfigurationsOnHostWhenDnsConfigurationResolverOutOfSync() {
    iface.setIpv4DefaultRoute(true);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    ReportedConfigurations reportedConfigurations = createTestedInstanceWithSameNonQosValues(true).reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), addressesAsString(network.getDnsResolverConfiguration().getNameServers()), false), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, true, true, true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#method_after
@Test
public void testReportConfigurationsOnHostWhenDnsConfigurationResolverOutOfSync() {
    iface.setIpv4DefaultRoute(true);
    iface.setIpv4Gateway(IPV4_GATEWAY);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    ReportedConfigurations reportedConfigurations = createTestedInstanceWithSameNonQosValues(true).reportConfigurationsOnHost();
    assertThat(reportedConfigurations.isNetworkInSync(), is(false));
    List<ReportedConfiguration> reportedConfigurationList = reportedConfigurations.getReportedConfigurationList();
    List<ReportedConfiguration> expectedReportedConfigurations = addReportedConfigurations(combineReportedConfigurations(createBasicReportedConfigurations(), reportQos(true)), new ReportedConfiguration(ReportedConfigurationType.IPV4_BOOT_PROTOCOL, iface.getIpv4BootProtocol().name(), /*ipv4Address*/
    address.getBootProtocol().name(), true), new ReportedConfiguration(ReportedConfigurationType.DNS_CONFIGURATION, addressesAsString(sampleDnsResolverConfiguration.getNameServers()), addressesAsString(network.getDnsResolverConfiguration().getNameServers()), false), new ReportedConfiguration(ReportedConfigurationType.DEFAULT_ROUTE, true, true, true));
    assertThat(reportedConfigurationList.containsAll(expectedReportedConfigurations), is(true));
    assertThat(reportedConfigurationList.size(), is(expectedReportedConfigurations.size()));
}
#end_block

#method_before
@Test
public void testIsNetworkInSyncWhenIpv6GatewayEqual() {
    initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, true);
    assertThat(createTestedInstance().isNetworkInSync(), is(true));
}
#method_after
@Test
public void testIsNetworkInSyncWhenIpv6GatewayEqual() {
    initIpv6ConfigurationBootProtocolGateway(Ipv6BootProtocol.STATIC_IP, true);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(true));
}
#end_block

#method_before
@Test
public void testIsNetworkInSyncForIpv6Synonyms() {
    List<String[]> tests = Arrays.asList(new String[] { "2001:0db8:85a3:0000:0000:8a2e:0370:7331", "2001:0db8:85a3:0000:0000:8a2e:0370:7331" }, new String[] { "2001:0db8:85a3:0000:0000:8a2e:0370:7331", "2001:db8:85a3::8a2e:370:7331" }, new String[] { "2001:db8:85a3::8a2e:370:7331", "2001:0db8:85a3:0000:0000:8a2e:0370:7331" }, new String[] { "::", "::0000" }, new String[] { "::", "0000::" }, new String[] { "::", "0:0:0:0:0:0:0:0" }, new String[] { null, null });
    for (String[] test : tests) {
        initIpv6ConfigurationStaticBootProtocol(Ipv6BootProtocol.STATIC_IP);
        ipv6Address.setGateway(test[0]);
        ipv6Address.setAddress(test[0]);
        iface.setIpv6Gateway(test[1]);
        iface.setIpv6Address(test[1]);
        assertThat(createTestedInstance().isNetworkInSync(), is(true));
    }
}
#method_after
@Test
public void testIsNetworkInSyncForIpv6Synonyms() {
    List<String[]> tests = Arrays.asList(// array of [network attachment address, interface address, default route role]
    new String[] { "2001:0db8:85a3:0000:0000:8a2e:0370:7331", "2001:0db8:85a3:0000:0000:8a2e:0370:7331" }, new String[] { "2001:0db8:85a3:0000:0000:8a2e:0370:7331", "2001:db8:85a3::8a2e:370:7331" }, new String[] { "2001:db8:85a3::8a2e:370:7331", "2001:0db8:85a3:0000:0000:8a2e:0370:7331" }, new String[] { "::", "::0000" }, new String[] { "::", "0000::" }, new String[] { "::", "0:0:0:0:0:0:0:0" });
    for (String[] test : tests) {
        initIpv6ConfigurationStaticBootProtocol(Ipv6BootProtocol.STATIC_IP);
        ipv6Address.setGateway(test[0]);
        ipv6Address.setAddress(test[0]);
        iface.setIpv6Gateway(test[1]);
        iface.setIpv6Address(test[1]);
        ReportedConfiguration reported = createTestedInstance().reportConfigurationsOnHost().getReportedConfigurationList().stream().filter(rc -> rc.getType() == ReportedConfigurationType.IPV6_ADDRESS).findFirst().get();
        assertThat(reported.isInSync(), is(true));
    }
}
#end_block

#method_before
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    iface.setIpv4DefaultRoute(true);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true, vdsDnsResolver).isNetworkInSync(), is(expectedInSync));
}
#method_after
private void testDnsResolverConfiguration(DnsResolverConfiguration vdsDnsResolver, DnsResolverConfiguration networkDnsResolver, DnsResolverConfiguration attachmentDnsResolver, boolean expectedInSync) {
    iface.setIpv4DefaultRoute(true);
    // cannot use initIpv4ConfigurationBootProtocol because of 'randomized tests' technique.
    iface.setIpv4BootProtocol(Ipv4BootProtocol.DHCP);
    iface.setIpv4Gateway(IPV4_GATEWAY);
    IPv4Address address = new IPv4Address();
    address.setBootProtocol(Ipv4BootProtocol.DHCP);
    testedNetworkAttachment.getIpConfiguration().setIPv4Addresses(Collections.singletonList(address));
    network.setDnsResolverConfiguration(networkDnsResolver);
    testedNetworkAttachment.setDnsResolverConfiguration(attachmentDnsResolver);
    assertThat(createTestedInstance(true, vdsDnsResolver).isNetworkInSync(), is(expectedInSync));
}
#end_block

#method_before
@Test
public void testDnsResolverConfigurationNonDefaultRouteNetwork() {
    iface.setIpv4DefaultRoute(true);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    assertThat(createTestedInstance(false, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#method_after
@Test
public void testDnsResolverConfigurationNonDefaultRouteNetwork() {
    iface.setIpv4DefaultRoute(true);
    iface.setIpv6Gateway(IPV6_GATEWAY);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    testedNetworkAttachment.setDnsResolverConfiguration(sampleDnsResolverConfiguration2);
    assertThat(createTestedInstance(false, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
@Test
public void testDefaultRouteNonDefaultRouteNetwork() {
    iface.setIpv4DefaultRoute(true);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(false, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#method_after
@Test
public void testDefaultRouteNonDefaultRouteNetwork() {
    iface.setIpv4DefaultRoute(true);
    iface.setIpv6Gateway(IPV6_GATEWAY);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(false, sampleDnsResolverConfiguration).isNetworkInSync(), is(false));
}
#end_block

#method_before
@Test
public void testDefaultRouteWhenInSync() {
    iface.setIpv4DefaultRoute(true);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(true));
}
#method_after
@Test
public void testDefaultRouteWhenInSync() {
    iface.setIpv4DefaultRoute(true);
    iface.setIpv4Gateway(IPV4_GATEWAY);
    network.setDnsResolverConfiguration(sampleDnsResolverConfiguration);
    assertThat(createTestedInstance(true, sampleDnsResolverConfiguration).isNetworkInSync(), is(true));
}
#end_block

#method_before
public static boolean hasIpv6Gateway(NetworkAttachment a) {
    return hasIpv6PrimaryAddress(a) && !IpAddressPredicate.isUnspecifiedIpv6(a.getIpConfiguration().getIpv6PrimaryAddress().getGateway());
}
#method_after
public static boolean hasIpv6Gateway(NetworkAttachment a) {
    return hasIpv6PrimaryAddress(a) && !ipUnspecifiedPredicate().test(a.getIpConfiguration().getIpv6PrimaryAddress().getGateway());
}
#end_block

#method_before
public static boolean areSameId(NetworkAttachment a, NetworkAttachment b) {
    return a != null && b != null && a.getId() != null && a.getId().equals(b.getId());
}
#method_after
private static boolean areSameId(NetworkAttachment a, NetworkAttachment b) {
    return a != null && b != null && a.getId() != null && a.getId().equals(b.getId());
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    NetworkAttachment currentDefaultRouteNetworkAttachment = findAttachmentByNetworkClusterId(findCurrentDefaultRouteNetworkForCluster());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), currentDefaultRouteNetworkAttachment, getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator, backend);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), selectNetworkAttachmentForValidatation(), getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, findActiveVmsUsingNetwork, hostSetupNetworksValidatorHelper, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator, backend);
    return validator.validate();
}
#end_block

#method_before
private List<NetworkAttachment> getAttachmentsWithMissingUpdatedDefaultRoute() {
    NetworkCluster currentDefaultRouteNetworkCluster = findCurrentDefaultRouteNetworkForCluster();
    NetworkAttachment currentDefaultRouteNetworkAttachment = findAttachmentByNetworkClusterId(currentDefaultRouteNetworkCluster);
    VdsNetworkInterface previousDefaultRouteNic = findPreviousDefaultRouteNic();
    NetworkAttachment previousDefaultRouteNetworkAttachment = previousDefaultRouteNic == null ? null : findNetworkAttachmentBy(networkNameAttachmentPredicate(previousDefaultRouteNic.getNetworkName()), getExistingAttachments());
    if (currentDefaultRouteNetworkAttachment != null && previousDefaultRouteNetworkAttachment != null && currentDefaultRouteNetworkAttachment.getId().equals(previousDefaultRouteNetworkAttachment.getId())) {
        return getParameters().getNetworkAttachments();
    }
    if (hasIpv6PrimaryAddress(previousDefaultRouteNetworkAttachment)) {
        previousDefaultRouteNetworkAttachment.getIpConfiguration().getIpv6PrimaryAddress().setGateway(null);
    }
    List<NetworkAttachment> extendedAttachments = getParameters().getNetworkAttachments();
    NetworkAttachment potentialyMissingAttachment = getPotentialyMissingAttachment(currentDefaultRouteNetworkCluster == null ? null : currentDefaultRouteNetworkCluster.getNetworkId(), currentDefaultRouteNetworkAttachment, previousDefaultRouteNetworkAttachment);
    addAttachmentIfMissing(potentialyMissingAttachment, extendedAttachments);
    return extendedAttachments;
}
#method_after
private List<NetworkAttachment> getAttachmentsWithMissingUpdatedDefaultRoute() {
    NetworkCluster currentDefaultRouteNetworkCluster = findCurrentDefaultRouteNetworkForCluster();
    NetworkAttachment currentDefaultRouteNetworkAttachment = findAttachmentByNetworkClusterId(currentDefaultRouteNetworkCluster);
    VdsNetworkInterface previousDefaultRouteNic = findPreviousDefaultRouteNic();
    NetworkAttachment previousDefaultRouteNetworkAttachment = findNetworkAttachmentByNetworkName(previousDefaultRouteNic, getExistingAttachments());
    if (currentDefaultRouteNetworkAttachment != null && previousDefaultRouteNetworkAttachment != null && currentDefaultRouteNetworkAttachment.getId().equals(previousDefaultRouteNetworkAttachment.getId())) {
        return getParameters().getNetworkAttachments();
    }
    List<NetworkAttachment> extendedAttachments = getParameters().getNetworkAttachments();
    NetworkAttachment potentialyMissingAttachment = getPotentialyMissingAttachment(currentDefaultRouteNetworkCluster == null ? null : currentDefaultRouteNetworkCluster.getNetworkId(), currentDefaultRouteNetworkAttachment, previousDefaultRouteNetworkAttachment);
    addAttachmentIfMissing(potentialyMissingAttachment, extendedAttachments);
    NetworkAttachment previousExtendedDefaultRouteAttachment = findNetworkAttachmentByNetworkName(previousDefaultRouteNic, extendedAttachments);
    if (hasIpv6PrimaryAddress(previousExtendedDefaultRouteAttachment)) {
        previousExtendedDefaultRouteAttachment.getIpConfiguration().getIpv6PrimaryAddress().setGateway(null);
    }
    return extendedAttachments;
}
#end_block

#method_before
private VdsNetworkInterface findPreviousDefaultRouteNic() {
    List<VdsNetworkInterface> existingNics = getExistingNics();
    return existingNics.stream().filter(nic -> DEFAULT_ROUTE_ON_IFACE_PREDICATE.test(nic)).findFirst().orElse(null);
}
#method_after
private VdsNetworkInterface findPreviousDefaultRouteNic() {
    List<VdsNetworkInterface> existingNics = getExistingNics();
    return existingNics.stream().filter(isDefaultRouteOnInterfacePredicate()).findFirst().orElse(null);
}
#end_block

#method_before
@Override
protected boolean validate() {
    ClusterValidator clusterValidator = getClusterValidator(oldCluster, getCluster());
    boolean returnValue = validate(clusterValidator.oldClusterIsValid());
    if (returnValue) {
        returnValue = validate(clusterValidator.newNameUnique()) && validate(clusterValidator.newClusterVersionSupported()) && validate(clusterValidator.decreaseClusterWithHosts()) && validate(clusterValidator.decreaseClusterBeneathDc(getClusterValidator(oldCluster))) && validate(clusterValidator.canChangeStoragePool()) && validate(clusterValidator.cpuNotFound(checkIfCpusExist())) && validate(clusterValidator.updateCpuIllegal(checkIfCpusExist(), checkIfCpusSameManufacture(oldCluster))) && validate(clusterValidator.architectureIsLegal(isArchitectureUpdatable())) && validate(clusterValidator.cpuUpdatable()) && validate(clusterValidator.vmInPrev()) && validateManagementNetworkAndAdditionToStoragePool() && validate(clusterValidator.vdsUp()) && validate(clusterValidator.hostsDown(getParameters().isForceResetEmulatedMachine())) && canUpdateCompatibilityVersionOrCpu() && validate(clusterValidator.updateSupportedFeatures()) && suspendedVms() && validate(clusterValidator.addMoreThanOneHost()) && validate(clusterValidator.defaultClusterOnLocalfs()) && validate(clusterValidator.oneServiceEnabled()) && validate(clusterValidator.mixedClusterServicesSupportedForNewCluster()) && validate(clusterValidator.disableVirt()) && validate(clusterValidator.disableGluster()) && validate(clusterValidator.setTrustedAttestation()) && validate(clusterValidator.migrationOnError(getArchitecture())) && validateClusterPolicy(oldCluster) && validateConfiguration();
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    ClusterValidator clusterValidator = getClusterValidator(oldCluster, getCluster());
    boolean returnValue = validate(clusterValidator.oldClusterIsValid());
    if (returnValue) {
        returnValue = validate(clusterValidator.newNameUnique()) && validate(clusterValidator.newClusterVersionSupported()) && validate(clusterValidator.decreaseClusterWithHosts()) && validate(clusterValidator.decreaseClusterBeneathDc(getClusterValidator(oldCluster))) && validate(clusterValidator.canChangeStoragePool()) && validate(clusterValidator.cpuNotFound(checkIfCpusExist())) && validate(clusterValidator.updateCpuIllegal(checkIfCpusExist(), checkIfCpusSameManufacture(oldCluster))) && validate(clusterValidator.architectureIsLegal(isArchitectureUpdatable())) && validate(clusterValidator.cpuUpdatable()) && validate(clusterValidator.vmInPrev()) && validateManagementNetworkAndAdditionToStoragePool() && validate(clusterValidator.vdsUp()) && validate(clusterValidator.hostsDown(getParameters().isForceResetEmulatedMachine())) && canUpdateCompatibilityVersionOrCpu() && validate(clusterValidator.updateSupportedFeatures()) && hasSuspendedVms() && validate(clusterValidator.addMoreThanOneHost()) && validate(clusterValidator.defaultClusterOnLocalfs()) && validate(clusterValidator.oneServiceEnabled()) && validate(clusterValidator.mixedClusterServicesSupportedForNewCluster()) && validate(clusterValidator.disableVirt()) && validate(clusterValidator.disableGluster()) && validate(clusterValidator.setTrustedAttestation()) && validate(clusterValidator.migrationOnError(getArchitecture())) && validateClusterPolicy(oldCluster) && validateConfiguration();
    }
    return returnValue;
}
#end_block

#method_before
private boolean canUpdateCompatibilityVersionOrCpu() {
    allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    List<VDS> upVdss = allForCluster.stream().filter(v -> v.getStatus() == VDSStatus.Up).collect(Collectors.toList());
    boolean valid = true;
    for (VDS vds : upVdss) {
        if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
        }
        if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
        }
        if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
        }
    }
    return valid;
}
#method_after
private boolean canUpdateCompatibilityVersionOrCpu() {
    allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    List<VDS> upVdss = allForCluster.stream().filter(v -> v.getStatus() == VDSStatus.Up).collect(Collectors.toList());
    boolean valid = true;
    for (VDS vds : upVdss) {
        if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
            valid = false;
            addValidationVarAndMessage("host", vds.getName(), EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
        }
        if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
            valid = false;
            addValidationVarAndMessage("host", vds.getName(), EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
        }
        if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
            valid = false;
            addValidationVarAndMessage("host", vds.getName(), EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
        }
    }
    return valid;
}
#end_block

#method_before
public static final AbstractFullDateTimeColumn<Disk> getDateCreatedColumn(String sortBy) {
    AbstractFullDateTimeColumn<Disk> column = new AbstractFullDateTimeColumn<Disk>() {

        @Override
        protected Date getRawValue(Disk object) {
            return object.getDiskStorageType() == DiskStorageType.IMAGE || object.getDiskStorageType() == DiskStorageType.CINDER || object.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE ? ((DiskImage) object).getCreationDate() : null;
        }
    };
    if (sortBy != null) {
        column.makeSortable(sortBy);
    } else {
        column.makeSortable();
    }
    return column;
}
#method_after
public static final AbstractFullDateTimeColumn<Disk> getDateCreatedColumn(String sortBy) {
    AbstractFullDateTimeColumn<Disk> column = new AbstractFullDateTimeColumn<Disk>() {

        @Override
        protected Date getRawValue(Disk object) {
            return object.getDiskStorageType() == DiskStorageType.IMAGE || object.getDiskStorageType() == DiskStorageType.CINDER || object.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE ? ((DiskImage) object).getCreationDate() : null;
        }
    };
    return makeSortable(column, sortBy);
}
#end_block

#method_before
private void addIpv6BootProtocol(Map<String, Object> opts, HostNetwork attachment) {
    final Ipv6BootProtocol ipv6BootProtocol = attachment.getIpv6BootProtocol();
    opts.put(DHCPV6_BOOT_PROTOCOL, IPV6_DHCP_PROTOCOL_SET.contains(ipv6BootProtocol));
    opts.put(DHCPV6_AUTOCONF, IPV6_AUTOCONF_PROTOCOL_SET.contains(ipv6BootProtocol));
    if (Ipv6BootProtocol.STATIC_IP == ipv6BootProtocol) {
        putIfNotEmpty(opts, "ipv6addr", getIpv6Address(attachment));
        opts.put("ipv6gateway", attachment.isDefaultRoute() && attachment.getIpv6Gateway() != null ? attachment.getIpv6Gateway() : // must reset ifcfg gateway to 'unspecified' if this network is not the v6 default route supplier
        IpAddressPredicate.UNSPECIFIED_IPV6);
    }
}
#method_after
private void addIpv6BootProtocol(Map<String, Object> opts, HostNetwork attachment) {
    final Ipv6BootProtocol ipv6BootProtocol = attachment.getIpv6BootProtocol();
    opts.put(DHCPV6_BOOT_PROTOCOL, IPV6_DHCP_PROTOCOL_SET.contains(ipv6BootProtocol));
    opts.put(DHCPV6_AUTOCONF, IPV6_AUTOCONF_PROTOCOL_SET.contains(ipv6BootProtocol));
    if (Ipv6BootProtocol.STATIC_IP == ipv6BootProtocol) {
        putIfNotEmpty(opts, "ipv6addr", getIpv6Address(attachment));
        opts.put("ipv6gateway", selectIpv6Gateway(attachment));
    }
}
#end_block

#method_before
@Override
public boolean test(String address) {
    if (Objects.equals(baseAddressString, address)) {
        return true;
    }
    final InetAddress inetAddress = convertToInetAddress(address);
    return address != null && inetAddress != null && baseAddress != null && baseAddress.equals(inetAddress);
}
#method_after
@Override
public boolean test(String address) {
    if (Objects.equals(baseAddressString, address)) {
        return true;
    }
    final InetAddress inetAddress = NetworkUtils.toInetAddressOrNull(address);
    return address != null && inetAddress != null && baseAddress != null && baseAddress.equals(inetAddress);
}
#end_block

#method_before
private void executeCommandQueryUnchecked() {
    ConsoleOptions options = getParameters().getOptions();
    fillCommonPart(options);
    // fill additional SPICE data
    if (options.getGraphicsType() == GraphicsType.SPICE) {
        fillSpice(options);
    }
    if (getQueryReturnValue().getSucceeded()) {
        setReturnValue(options);
    }
}
#method_after
private void executeCommandQueryUnchecked() {
    ConsoleOptions options = getParameters().getOptions();
    fillCommonPart(options);
    // fill additional SPICE data
    if (options.getGraphicsType() == GraphicsType.SPICE) {
        fillSpice(options);
    }
    // fill additional VNC data
    if (options.getGraphicsType() == GraphicsType.VNC) {
        fillVnc(options);
    }
    if (getQueryReturnValue().getSucceeded()) {
        setReturnValue(options);
    }
}
#end_block

#method_before
protected void initTemplateDisks(List<DiskImage> disks) {
    disks.sort(new DiskByDiskAliasComparator());
    ArrayList<DiskModel> list = new ArrayList<>();
    for (DiskImage disk : disks) {
        DiskModel diskModel = new DiskModel();
        diskModel.getAlias().setEntity(disk.getDiskAlias());
        diskModel.getVolumeType().setIsAvailable(false);
        switch(disk.getDiskStorageType()) {
            case IMAGE:
                diskModel.setSize(new EntityModel<>((int) disk.getSizeInGigabytes()));
                ListModel volumes = new ListModel();
                volumes.setItems(disk.getVolumeType() == VolumeType.Preallocated ? new ArrayList<>(Collections.singletonList(VolumeType.Preallocated)) : AsyncDataProvider.getInstance().getVolumeTypeList(), disk.getVolumeType());
                diskModel.setVolumeType(volumes);
                break;
            case CINDER:
                CinderDisk cinderDisk = (CinderDisk) disk;
                diskModel.setSize(new EntityModel<>((int) cinderDisk.getSizeInGigabytes()));
                ListModel volumeTypes = new ListModel();
                volumeTypes.setItems(new ArrayList<>(Collections.singletonList(cinderDisk.getVolumeType())), cinderDisk.getVolumeType());
                diskModel.setVolumeType(volumeTypes);
                ListModel volumeFormats = new ListModel();
                volumeFormats.setItems(new ArrayList<>(Collections.singletonList(cinderDisk.getVolumeFormat())), cinderDisk.getVolumeFormat());
                diskModel.setVolumeFormat(volumeFormats);
                break;
        }
        diskModel.setDisk(disk);
        list.add(diskModel);
    }
    getModel().setDisks(list);
    updateIsDisksAvailable();
    initStorageDomains();
}
#method_after
protected void initTemplateDisks(List<DiskImage> disks) {
    disks.sort(new DiskByDiskAliasComparator());
    ArrayList<DiskModel> list = new ArrayList<>();
    for (DiskImage disk : disks) {
        DiskModel diskModel = new DiskModel();
        diskModel.getAlias().setEntity(disk.getDiskAlias());
        diskModel.getVolumeType().setIsAvailable(false);
        switch(disk.getDiskStorageType()) {
            case IMAGE:
                diskModel.setSize(new EntityModel<>((int) disk.getSizeInGigabytes()));
                ListModel volumes = new ListModel();
                volumes.setItems(disk.getVolumeType() == VolumeType.Preallocated ? new ArrayList<>(Collections.singletonList(VolumeType.Preallocated)) : AsyncDataProvider.getInstance().getVolumeTypeList(), disk.getVolumeType());
                diskModel.setVolumeType(volumes);
                break;
            case CINDER:
                CinderDisk cinderDisk = (CinderDisk) disk;
                diskModel.setSize(new EntityModel<>((int) cinderDisk.getSizeInGigabytes()));
                ListModel volumeTypes = new ListModel();
                volumeTypes.setItems(new ArrayList<>(Collections.singletonList(cinderDisk.getVolumeType())), cinderDisk.getVolumeType());
                diskModel.setVolumeType(volumeTypes);
                ListModel volumeFormats = new ListModel();
                volumeFormats.setItems(new ArrayList<>(Collections.singletonList(cinderDisk.getVolumeFormat())), cinderDisk.getVolumeFormat());
                diskModel.setVolumeFormat(volumeFormats);
                break;
            case MANAGED_BLOCK_STORAGE:
                ManagedBlockStorageDisk managedBlockDisk = (ManagedBlockStorageDisk) disk;
                diskModel.setSize(new EntityModel<>((int) managedBlockDisk.getSizeInGigabytes()));
                ListModel managedBlockVolumeTypes = new ListModel();
                managedBlockVolumeTypes.setItems(new ArrayList<>(Collections.singletonList(VolumeType.Preallocated)), VolumeType.Preallocated);
                diskModel.setVolumeType(managedBlockVolumeTypes);
                ListModel managedBlockVolumeFormats = new ListModel();
                managedBlockVolumeFormats.setItems(new ArrayList<>(Collections.singletonList(VolumeFormat.RAW)), VolumeFormat.RAW);
                diskModel.setVolumeFormat(managedBlockVolumeFormats);
                break;
        }
        diskModel.setDisk(disk);
        list.add(diskModel);
    }
    getModel().setDisks(list);
    updateIsDisksAvailable();
    initStorageDomains();
}
#end_block

#method_before
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery<>(storageDomains -> {
        ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
        boolean provisioning = getModel().getProvisioning().getEntity();
        ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
        activeStorageDomains.sort(new NameableComparator());
        List<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
        for (DiskModel diskModel : diskImages) {
            List<StorageDomain> availableDiskStorageDomains;
            diskModel.getQuota().setItems(getModel().getQuota().getItems());
            List<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
            // Active storage domains that the disk resides on
            List<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
            // Set target storage domains
            availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
            availableDiskStorageDomains.sort(new NameableComparator());
            diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
            diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
            diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
        }
        List<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
        Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
        initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
    }), dataCenter.getId(), actionGroup);
}
#method_after
protected void postInitStorageDomains() {
    if (getModel().getDisks() == null) {
        return;
    }
    ActionGroup actionGroup = getModel().isCreateInstanceOnly() ? ActionGroup.CREATE_INSTANCE : ActionGroup.CREATE_VM;
    StoragePool dataCenter = getModel().getSelectedDataCenter();
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery<>(storageDomains -> {
        ArrayList<StorageDomain> activeStorageDomains = filterStorageDomains(storageDomains);
        boolean provisioning = getModel().getProvisioning().getEntity();
        ArrayList<DiskModel> disks = (ArrayList<DiskModel>) getModel().getDisks();
        activeStorageDomains.sort(new NameableComparator());
        List<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
        for (DiskModel diskModel : diskImages) {
            List<StorageDomain> availableDiskStorageDomains;
            diskModel.getQuota().setItems(getModel().getQuota().getItems());
            List<Guid> storageIds = ((DiskImage) diskModel.getDisk()).getStorageIds();
            // Active storage domains that the disk resides on
            List<StorageDomain> activeDiskStorageDomains = Linq.getStorageDomainsByIds(storageIds, activeStorageDomains);
            // Set target storage domains
            availableDiskStorageDomains = provisioning ? activeStorageDomains : activeDiskStorageDomains;
            availableDiskStorageDomains.sort(new NameableComparator());
            diskModel.getStorageDomain().setItems(availableDiskStorageDomains);
            diskModel.getStorageDomain().setIsChangeable(!availableDiskStorageDomains.isEmpty());
            diskModel.getStorageDomain().setChangeProhibitionReason(constants.noActiveTargetStorageDomainAvailableMsg());
        }
        initStorageDomainForType(StorageType.CINDER, DiskStorageType.CINDER, disks, storageDomains);
        initStorageDomainForType(StorageType.MANAGED_BLOCK_STORAGE, DiskStorageType.MANAGED_BLOCK_STORAGE, disks, storageDomains);
    }), dataCenter.getId(), actionGroup);
}
#end_block

#method_before
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery<>(list -> {
            if (list == null) {
                return;
            }
            Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : diskQuotaId;
            isItem.setItems(list);
            if (selectedQuota != null && list.size() > 1) {
                for (Quota quota : list) {
                    if (quota.getId().equals(selectedQuota)) {
                        isItem.setSelectedItem(quota);
                        break;
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#method_after
private void updateQuota(Guid storageDomainId, final ListModel<Quota> isItem, final Guid diskQuotaId) {
    if (getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && storageDomainId != null) {
        AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery<>(list -> {
            if (list == null) {
                return;
            }
            Guid selectedQuota = isItem.getSelectedItem() != null ? isItem.getSelectedItem().getId() : null;
            selectedQuota = selectedQuota != null ? selectedQuota : diskQuotaId;
            isItem.setItems(list);
            if (selectedQuota != null && list.size() > 1) {
                for (Quota quota : list) {
                    if (quota.getId().equals(selectedQuota)) {
                        isItem.setSelectedItem(quota);
                        break;
                    }
                }
            }
        }), storageDomainId, null);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validateVm() || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validate(diskVmElementValidator.isPassDiscardSupported(getStorageDomainId()))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
                return false;
            }
            return setAndValidateDiskProfiles() && validate(diskValidator.validateProvisionedSize(getStorageDomain()));
        case LUN:
            return checkIfLunDiskCanBeAdded(diskValidator) && validate(diskValidator.validateProvisionedSize(getStorageDomain()));
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
            cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
            StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
            CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
            return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist()) && validate(diskValidator.validateProvisionedSize(getStorageDomain()));
        default:
            return validate(diskValidator.validateProvisionedSize(getStorageDomain()));
    }
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validateVm() || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validate(diskVmElementValidator.isPassDiscardSupported(getStorageDomainId()))) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
                return false;
            }
            return setAndValidateDiskProfiles() && validate(diskValidator.validateDiskSize());
        case LUN:
            return checkIfLunDiskCanBeAdded(diskValidator) && validate(diskValidator.validateDiskSize());
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
            cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
            StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
            CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
            return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist()) && validate(diskValidator.validateDiskSize());
        case MANAGED_BLOCK_STORAGE:
            return isSupportedByManagedBlockStorageDomain(getStorageDomain()) && validate(diskValidator.validateDiskSize());
        default:
            return true;
    }
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskVmElementValidator diskVmElementValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && validateShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskVmElementValidator.isVirtIoScsiValid(vm)) && validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).existsAndUp()) && isStoragePoolMatching(vm) && validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskVmElementValidator diskVmElementValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && validateShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.domainIsValidDestination()) && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskVmElementValidator.isVirtIoScsiValid(vm)) && validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).existsAndUp()) && isStoragePoolMatching(vm) && validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    setDiskAlias();
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
        case MANAGED_BLOCK_STORAGE:
            createManagedBlockStorageDisk();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    setDiskAlias();
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
        case MANAGED_BLOCK_STORAGE:
            createManagedBlockStorageDisk();
            break;
    }
}
#end_block

#method_before
private void createManagedBlockStorageDisk() {
    Future<ActionReturnValue> future = commandCoordinatorUtil.executeAsyncCommand(ActionType.AddManagedBlockStorageDisk, getParameters(), cloneContextAndDetachFromParent());
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
private void createManagedBlockStorageDisk() {
    Future<ActionReturnValue> future = commandCoordinatorUtil.executeAsyncCommand(ActionType.AddManagedBlockStorageDisk, buildManagedBlockParams(), cloneContextAndDetachFromParent());
    try {
        setReturnValue(future.get());
        setSucceeded(getReturnValue().getSucceeded());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error creating Cinder disk '{}': {}", getParameters().getDiskInfo().getDiskAlias(), e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
@Test
public void validateMaxBlockDiskSizeCheckSucceeds() {
    Guid storageId = Guid.newGuid();
    DiskImage disk = new DiskImage();
    disk.setSizeInGigabytes(Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize));
    command.getParameters().setStorageDomainId(storageId);
    command.getParameters().setDiskInfo(disk);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void validateMaxBlockDiskSizeCheckSucceeds() {
    Guid storageId = Guid.newGuid();
    DiskImage disk = new DiskImage();
    disk.setSizeInGigabytes(Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize));
    command.getParameters().setDiskInfo(disk);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void validateMaxBlockDiskSizeCheckFails() {
    Guid storageId = Guid.newGuid();
    DiskImage disk = new DiskImage();
    disk.setSizeInGigabytes(Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize) * 2L);
    command.getParameters().setStorageDomainId(storageId);
    command.getParameters().setDiskInfo(disk);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
}
#method_after
@Test
public void validateMaxBlockDiskSizeCheckFails() {
    Guid storageId = Guid.newGuid();
    DiskImage disk = new DiskImage();
    disk.setSizeInGigabytes(Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize) * 2L);
    command.getParameters().setDiskInfo(disk);
    mockStorageDomain(storageId, StorageType.ISCSI);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
}
#end_block

#method_before
@Test
public void validateShareableDiskVolumeFormatSucceeds() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.RAW);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void validateShareableDiskVolumeFormatSucceeds() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.RAW);
    image.setSize(1);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockInterfaceList();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void validateShareableDiskVolumeFormatFails() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.COW);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
}
#method_after
@Test
public void validateShareableDiskVolumeFormatFails() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.COW);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    mockVm();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
}
#end_block

#method_before
@Test
public void validateShareableDiskOnGlusterFails() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.RAW);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    command.getParameters().setStorageDomainId(storageId);
    mockVm();
    mockStorageDomain(storageId, StorageType.GLUSTERFS);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
}
#method_after
@Test
public void validateShareableDiskOnGlusterFails() {
    DiskImage image = new DiskImage();
    image.setShareable(true);
    image.setVolumeFormat(VolumeFormat.RAW);
    Guid storageId = Guid.newGuid();
    command.getParameters().setDiskInfo(image);
    mockVm();
    mockStorageDomain(storageId, StorageType.GLUSTERFS);
    mockStoragePoolIsoMap();
    mockMaxPciSlots();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
}
#end_block

#method_before
private void initializeCommand(Guid storageId, VolumeType volumeType) {
    AddDiskParameters parameters = command.getParameters();
    DiskImage disk = new DiskImage();
    disk.setVolumeType(volumeType);
    parameters.setDiskInfo(disk);
    command.getParameters().setStorageDomainId(storageId);
}
#method_after
private void initializeCommand(Guid storageId, VolumeType volumeType) {
    AddDiskParameters parameters = command.getParameters();
    DiskImage disk = new DiskImage();
    disk.setSize(1);
    disk.setVolumeType(volumeType);
    parameters.setDiskInfo(disk);
    command.getParameters().setStorageDomainId(storageId);
}
#end_block

#method_before
private StorageDomain mockStorageDomain(Guid storageId, StorageType storageType) {
    StoragePool storagePool = mockStoragePool();
    Guid storagePoolId = storagePool.getId();
    StorageDomain sd = new StorageDomain();
    sd.setId(storageId);
    sd.setStoragePoolId(storagePoolId);
    sd.setStatus(StorageDomainStatus.Active);
    sd.setStorageType(storageType);
    when(storageDomainDao.get(storageId)).thenReturn(sd);
    when(storageDomainDao.getAllForStorageDomain(storageId)).thenReturn(Collections.singletonList(sd));
    when(storageDomainDao.getForStoragePool(storageId, storagePoolId)).thenReturn(sd);
    return sd;
}
#method_after
private StorageDomain mockStorageDomain(Guid storageId, StorageType storageType) {
    command.getParameters().setStorageDomainId(storageId);
    StoragePool storagePool = mockStoragePool();
    Guid storagePoolId = storagePool.getId();
    StorageDomain sd = new StorageDomain();
    sd.setId(storageId);
    sd.setStoragePoolId(storagePoolId);
    sd.setStatus(StorageDomainStatus.Active);
    sd.setStorageType(storageType);
    when(storageDomainDao.get(storageId)).thenReturn(sd);
    when(storageDomainDao.getAllForStorageDomain(storageId)).thenReturn(Collections.singletonList(sd));
    when(storageDomainDao.getForStoragePool(storageId, storagePoolId)).thenReturn(sd);
    return sd;
}
#end_block

#method_before
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUNId("lunid");
    lun.setLunType(StorageType.ISCSI);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setIqn("a");
    connection.setConnection("0.0.0.0");
    connection.setPort("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    disk.setId(Guid.newGuid());
    return disk;
}
#method_after
private static LunDisk createISCSILunDisk() {
    LunDisk disk = new LunDisk();
    LUNs lun = new LUNs();
    lun.setLUNId("lunid");
    lun.setLunType(StorageType.ISCSI);
    lun.setDeviceSize(1);
    StorageServerConnections connection = new StorageServerConnections();
    connection.setIqn("a");
    connection.setConnection("0.0.0.0");
    connection.setPort("1234");
    ArrayList<StorageServerConnections> connections = new ArrayList<>();
    connections.add(connection);
    lun.setLunConnections(connections);
    disk.setLun(lun);
    disk.setId(Guid.newGuid());
    return disk;
}
#end_block

#method_before
@Test
public void testLunDiskValid() {
    VDS vds = mockVds();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().setVdsId(vds.getId());
    command.setVds(vds);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    mockVm();
    mockMaxPciSlots();
    mockInterfaceList();
    List<LUNs> luns = Collections.singletonList(disk.getLun());
    doReturn(luns).when(command).executeGetDeviceList(any(), any(), any());
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testLunDiskValid() {
    VDS vds = mockVds();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().setVdsId(vds.getId());
    command.setVds(vds);
    mockVm();
    mockMaxPciSlots();
    mockInterfaceList();
    List<LUNs> luns = Collections.singletonList(disk.getLun());
    doReturn(luns).when(command).executeGetDeviceList(any(), any(), any());
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.IDE);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#method_after
@Test
public void testAddingIDELunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for IDE - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_IDE_SLOTS - 1, DiskInterface.IDE);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.IDE);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
}
#end_block

#method_before
@Test
public void testAddingSATALunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.SATA);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for SATA - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_SATA_SLOTS - 1, DiskInterface.SATA);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.SATA);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SATA_SLOTS);
}
#method_after
@Test
public void testAddingSATALunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.SATA);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for SATA - validate expected to succeed.
    mockOtherVmDisks(vm, VmCommand.MAX_SATA_SLOTS - 1, DiskInterface.SATA);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.SATA);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SATA_SLOTS);
}
#end_block

#method_before
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#method_after
@Test
public void testAddingPCILunExceedsSlotLimit() {
    mockInterfaceList();
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.VirtIO);
    VM vm = mockVm();
    mockMaxPciSlots();
    // use maximum slots for PCI. validate expected to succeed.
    mockOtherVmDisks(vm, MAX_PCI_SLOTS - 2, DiskInterface.VirtIO);
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    LunDisk newDisk = createISCSILunDisk();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    newDisk.setDiskVmElements(Collections.singletonList(dve));
    vm.getDiskMap().put(newDisk.getId(), newDisk);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
}
#end_block

#method_before
@Test
public void testLunDiskWithSgioCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(anyInt(), any(), any())).thenReturn(Collections.singletonList("VirtIO_SCSI"));
    mockInterfaceList();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testLunDiskWithSgioCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    disk.setSgio(ScsiGenericIO.UNFILTERED);
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.VirtIO_SCSI);
    mockVm();
    mockMaxPciSlots();
    when(osRepository.getDiskInterfaces(anyInt(), any(), any())).thenReturn(Collections.singletonList("VirtIO_SCSI"));
    mockInterfaceList();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testValidateSuccessOnAddFloatingDiskWithPlugUnset() {
    DiskImage disk = new DiskImage();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().setVmId(Guid.Empty);
    command.getParameters().setPlugDiskToVm(false);
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#method_after
@Test
public void testValidateSuccessOnAddFloatingDiskWithPlugUnset() {
    DiskImage disk = new DiskImage();
    disk.setSize(1);
    command.getParameters().setDiskInfo(disk);
    command.getParameters().setVmId(Guid.Empty);
    command.getParameters().setPlugDiskToVm(false);
    Guid storageId = Guid.newGuid();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testValidateQuota() {
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockVm();
    mockEntities(storageId);
    Guid quotaId = Guid.newGuid();
    ((DiskImage) command.getParameters().getDiskInfo()).setQuotaId(quotaId);
    doReturn(ValidationResult.VALID).when(quotaValidator).isValid();
    doReturn(ValidationResult.VALID).when(quotaValidator).isDefinedForStoragePool(any(Guid.class));
    doReturn(quotaValidator).when(command).createQuotaValidator(any(Guid.class));
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    verify(command, times(1)).createQuotaValidator(quotaId);
    verify(quotaValidator, times(1)).isValid();
    verify(quotaValidator, times(1)).isDefinedForStoragePool(any());
}
#method_after
@Test
public void testValidateQuota() {
    Guid storageId = Guid.newGuid();
    command.getParameters().setStorageDomainId(storageId);
    mockVm();
    mockEntities(storageId);
    Guid quotaId = Guid.newGuid();
    ((DiskImage) command.getParameters().getDiskInfo()).setSize(1);
    ((DiskImage) command.getParameters().getDiskInfo()).setQuotaId(quotaId);
    doReturn(ValidationResult.VALID).when(quotaValidator).isValid();
    doReturn(ValidationResult.VALID).when(quotaValidator).isDefinedForStoragePool(any(Guid.class));
    doReturn(quotaValidator).when(command).createQuotaValidator(any(Guid.class));
    doCallRealMethod().when(command).validateQuota();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
    verify(command, times(1)).createQuotaValidator(quotaId);
    verify(quotaValidator, times(1)).isValid();
    verify(quotaValidator, times(1)).isDefinedForStoragePool(any());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (oldCluster == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // if the name was changed then make sure the new name is unique
    if (!Objects.equals(oldCluster.getName(), getCluster().getName()) && !isClusterUnique(getCluster().getName())) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
    }
    if (!VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        return failValidation(VersionSupport.getUnsupportedVersionMessage());
    }
    allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = getClusterValidator(oldCluster);
            if (!validate(validator.dataCenterVersionMismatch())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    boolean allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    // Validate the cpu only if the cluster supports Virt
    if (getCluster().supportsVirtService() && (!"".equals(oldCluster.getCpuName()) || !"".equals(getCluster().getCpuName()))) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
            }
        }
    }
    List<VM> vmList = vmDao.getAllForCluster(oldCluster.getId());
    boolean hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    // cannot change the processor architecture while there are attached hosts or VMs to the cluster
    if (getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
    }
    boolean sameCpuNames = Objects.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
    if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
        return failValidation(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
    }
    if (!oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        List<String> vmInPreviewNames = vmList.stream().filter(VM::isPreviewSnapshot).map(VM::getName).collect(Collectors.toList());
        // can't change cluster version when a VM is in preview
        if (!vmInPreviewNames.isEmpty()) {
            return failValidation(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW, vmInPreviewNames);
        }
    }
    isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
    if (isAddedToStoragePool && !validateManagementNetwork()) {
        return false;
    }
    List<VDS> upVdss = allForCluster.stream().filter(v -> v.getStatus() == VDSStatus.Up).collect(Collectors.toList());
    if (!upVdss.isEmpty()) {
        if (isAddedToStoragePool) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
        }
        if (getParameters().isForceResetEmulatedMachine()) {
            return failValidation(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
        }
    }
    Boolean clusterVersionSupported = true;
    Boolean virtServiceSupported = true;
    Boolean emulatedMachinesMatchClusterLevel = true;
    String hostsToMoveToMaintenance = "";
    for (VDS vds : upVdss) {
        if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
            hostsToMoveToMaintenance = hostsToMoveToMaintenance.concat(vds.getName() + ",");
            clusterVersionSupported = false;
        }
        if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
            hostsToMoveToMaintenance = hostsToMoveToMaintenance.concat(vds.getName() + ",");
            virtServiceSupported = false;
        }
        if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
            hostsToMoveToMaintenance = hostsToMoveToMaintenance.concat(vds.getName() + ",");
            emulatedMachinesMatchClusterLevel = false;
        }
    }
    if (!clusterVersionSupported || !virtServiceSupported || !emulatedMachinesMatchClusterLevel) {
        hostsToMoveToMaintenance = hostsToMoveToMaintenance.substring(0, hostsToMoveToMaintenance.length() - 1);
        addValidationMessageVariable("host", hostsToMoveToMaintenance);
        if (!clusterVersionSupported) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
        }
        if (!virtServiceSupported) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
        }
        if (!emulatedMachinesMatchClusterLevel) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
        }
    }
    Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
    // New Features cannot be enabled if all up hosts are not supporting the selected feature
    if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(upVdss, additionalClusterFeaturesAdded)) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
    }
    boolean notDownVms = false;
    boolean hasVms = !vmList.isEmpty();
    if (!sameCpuNames) {
        for (VM vm : vmList) {
            if (vm.getStatus() == VMStatus.Suspended) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
            }
            if (vm.getStatus() != VMStatus.Down) {
                notDownVms = true;
                break;
            }
        }
        if (notDownVms) {
            int compareResult = compareCpuLevels(oldCluster);
            if (compareResult > 0) {
                // Upgrade of CPU in same compatibility level is allowed if
                // there are running VMs - but we should warn they cannot not be hibernated
                addCustomValue("Cluster", getParameters().getCluster().getName());
                auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
            }
        }
    }
    if (getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            }
            if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                return failValidation(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
            }
        }
    }
    if (!getCluster().supportsGlusterService() && !getCluster().supportsVirtService()) {
        return failValidation(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
    }
    if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
        return failValidation(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
    }
    if (hasVms && !getCluster().supportsVirtService()) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
    }
    if (!getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && !volumes.isEmpty()) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
        }
    }
    if (getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
    }
    if (!FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (!validateClusterPolicy(oldCluster)) {
        return false;
    }
    ClusterValidator clusterValidator = getClusterValidator(getCluster());
    if (!validate(clusterValidator.rngSourcesAllowed()) || !validate(clusterValidator.memoryOptimizationConfiguration()) || !validate(moveMacs.canMigrateMacsToAnotherMacPool(oldCluster, getNewMacPoolId())) || !validateDefaultNetworkProvider()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (oldCluster == null) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    // if the name was changed then make sure the new name is unique
    if (!Objects.equals(oldCluster.getName(), getCluster().getName()) && !isClusterUnique(getCluster().getName())) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_DO_ACTION_NAME_IN_USE);
    }
    if (!VersionSupport.checkVersionSupported(getCluster().getCompatibilityVersion())) {
        return failValidation(VersionSupport.getUnsupportedVersionMessage());
    }
    allForCluster = vdsDao.getAllForCluster(oldCluster.getId());
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (getCluster().getCompatibilityVersion().compareTo(oldCluster.getCompatibilityVersion()) < 0) {
        if (!allForCluster.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
        }
        if (oldCluster.getStoragePoolId() != null) {
            ClusterValidator validator = getClusterValidator(oldCluster);
            if (!validate(validator.dataCenterVersionMismatch())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (oldCluster.getStoragePoolId() != null && !oldCluster.getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_CHANGE_STORAGE_POOL);
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    boolean allVdssInMaintenance = areAllVdssInMaintenance(allForCluster);
    // Validate the cpu only if the cluster supports Virt
    if (getCluster().supportsVirtService() && (!"".equals(oldCluster.getCpuName()) || !"".equals(getCluster().getCpuName()))) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addValidationMessage(EngineMessage.VAR__TYPE__CLUSTER);
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldCluster.getCpuName()) && !checkIfCpusSameManufacture(oldCluster) && !allVdssInMaintenance) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ILLEGAL);
            }
        }
    }
    List<VM> vmList = vmDao.getAllForCluster(oldCluster.getId());
    boolean hasVmOrHost = !vmList.isEmpty() || !allForCluster.isEmpty();
    // cannot change the processor architecture while there are attached hosts or VMs to the cluster
    if (getCluster().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
    }
    boolean sameCpuNames = Objects.equals(oldCluster.getCpuName(), getCluster().getCpuName());
    boolean isOldCPUEmpty = StringUtils.isEmpty(oldCluster.getCpuName());
    if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldCluster) && hasVmOrHost) {
        return failValidation(EngineMessage.CLUSTER_CPU_IS_NOT_UPDATABLE);
    }
    if (!oldCluster.getCompatibilityVersion().equals(getCluster().getCompatibilityVersion())) {
        List<String> vmInPreviewNames = vmList.stream().filter(VM::isPreviewSnapshot).map(VM::getName).collect(Collectors.toList());
        // can't change cluster version when a VM is in preview
        if (!vmInPreviewNames.isEmpty()) {
            return failValidation(EngineMessage.CLUSTER_VERSION_CHANGE_VM_PREVIEW, vmInPreviewNames);
        }
        List<String> vmWithNextRunNames = vmList.stream().filter(vm -> !vm.isDown()).filter(this::hasNextRunConfiguration).map(VM::getName).collect(Collectors.toList());
        if (!vmWithNextRunNames.isEmpty()) {
            return failValidation(EngineMessage.CLUSTER_VERSION_CHANGE_VM_NEXT_RUN, vmWithNextRunNames);
        }
    }
    isAddedToStoragePool = oldCluster.getStoragePoolId() == null && getCluster().getStoragePoolId() != null;
    if (isAddedToStoragePool && !validateManagementNetwork()) {
        return false;
    }
    List<VDS> upVdss = allForCluster.stream().filter(v -> v.getStatus() == VDSStatus.Up).collect(Collectors.toList());
    if (!upVdss.isEmpty()) {
        if (isAddedToStoragePool) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_VDS_UP);
        }
        if (getParameters().isForceResetEmulatedMachine()) {
            return failValidation(EngineMessage.CLUSTER_HOSTS_MUST_BE_DOWN);
        }
    }
    boolean valid = true;
    for (VDS vds : upVdss) {
        if (!VersionSupport.checkClusterVersionSupported(getCluster().getCompatibilityVersion(), vds)) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
        }
        if (getCluster().supportsVirtService() && missingServerCpuFlags(vds) != null) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
        }
        if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
            valid = false;
            addValidationMessageVariable("host", vds.getName());
            addValidationMessage(EngineMessage.CLUSTER_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
        }
    }
    if (!valid) {
        return false;
    }
    Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
    // New Features cannot be enabled if all up hosts are not supporting the selected feature
    if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(upVdss, additionalClusterFeaturesAdded)) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
    }
    boolean notDownVms = false;
    boolean hasVms = !vmList.isEmpty();
    if (!sameCpuNames) {
        for (VM vm : vmList) {
            if (vm.getStatus() == VMStatus.Suspended) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
            }
            if (vm.getStatus() != VMStatus.Down) {
                notDownVms = true;
                break;
            }
        }
        if (notDownVms) {
            int compareResult = compareCpuLevels(oldCluster);
            if (compareResult > 0) {
                // Upgrade of CPU in same compatibility level is allowed if
                // there are running VMs - but we should warn they cannot not be hibernated
                addCustomValue("Cluster", getParameters().getCluster().getName());
                auditLogDirector.log(this, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
            }
        }
    }
    if (getCluster().getStoragePoolId() != null) {
        StoragePool storagePool = storagePoolDao.get(getCluster().getStoragePoolId());
        if (oldCluster.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!clusterDao.getAllForStoragePool(getCluster().getStoragePoolId()).isEmpty()) {
                return failValidation(EngineMessage.CLUSTER_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            }
            if (Config.getValue(ConfigValues.AutoRegistrationDefaultClusterID).equals(getCluster().getId())) {
                return failValidation(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
            }
        }
    }
    if (!getCluster().supportsGlusterService() && !getCluster().supportsVirtService()) {
        return failValidation(EngineMessage.CLUSTER_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
    }
    if (getCluster().supportsGlusterService() && getCluster().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
        return failValidation(EngineMessage.CLUSTER_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
    }
    if (hasVms && !getCluster().supportsVirtService()) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
    }
    if (!getCluster().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = glusterVolumeDao.getByClusterId(getCluster().getId());
        if (volumes != null && !volumes.isEmpty()) {
            return failValidation(EngineMessage.CLUSTER_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
        }
    }
    if (getCluster().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        return failValidation(EngineMessage.CLUSTER_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
    }
    if (!FeatureSupported.isMigrationSupported(getArchitecture(), getCluster().getCompatibilityVersion()) && getCluster().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failValidation(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (!validateClusterPolicy(oldCluster)) {
        return false;
    }
    ClusterValidator clusterValidator = getClusterValidator(getCluster());
    if (!validate(clusterValidator.rngSourcesAllowed()) || !validate(clusterValidator.memoryOptimizationConfiguration()) || !validate(moveMacs.canMigrateMacsToAnotherMacPool(oldCluster, getNewMacPoolId())) || !validateDefaultNetworkProvider()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private ActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(getParameters().getDiskVmElement());
    }
    return parameters;
}
#method_after
private ActionParametersBase buildAddCinderDiskParameters() {
    AddDiskParameters parameters = new AddDiskParameters(new DiskVmElement(null, getVmId()), getParameters().getDiskInfo());
    parameters.setPlugDiskToVm(getParameters().getPlugDiskToVm());
    parameters.setStorageDomainId(getParameters().getStorageDomainId());
    parameters.setQuotaId(getQuotaId());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    if (getVm() != null) {
        parameters.setVmSnapshotId(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
        parameters.setDiskVmElement(getParameters().getDiskVmElement());
    }
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    if (!validate(oldDiskValidator.isDiskExists())) {
        return false;
    }
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())) || !validate(snapshotsValidator.isSnapshotStatusOK(getSnapshot().getId())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(getDiskValidator(disk).isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    if (!validate(oldDiskValidator.isDiskExists())) {
        return false;
    }
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())) || !validate(snapshotsValidator.isSnapshotStatusOK(getSnapshot().getId())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(getDiskValidator(disk).isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive()) || !isSupportedByManagedBlockStorageDomain(storageDomain)) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#end_block

#method_before
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    return disks.stream().allMatch(disk -> this.saveDevices(disk, vds));
}
#method_after
public boolean attachManagedBlockStorageDisks(VM vm, VmHandler vmHandler, VDS vds) {
    if (vm.getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(vm);
    }
    List<ManagedBlockStorageDisk> disks = DisksFilter.filterManagedBlockStorageDisks(vm.getDiskMap().values());
    return disks.stream().allMatch(disk -> this.saveDevices(disk, vds, vm.getId()));
}
#end_block

#method_before
private boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#method_after
private boolean saveDevices(ManagedBlockStorageDisk disk, VDS vds, Guid vmId) {
    VDSReturnValue returnValue = attachManagedBlockStorageDisk(disk, vds);
    if (returnValue == null) {
        return false;
    }
    saveAttachedHost(disk, vmId, vds.getId());
    disk.setDevice((Map<String, Object>) returnValue.getReturnValue());
    SaveManagedBlockStorageDiskDeviceCommandParameters parameters = new SaveManagedBlockStorageDiskDeviceCommandParameters();
    parameters.setDevice(disk.getDevice());
    parameters.setDiskId(disk.getId());
    parameters.setStorageDomainId(disk.getStorageIds().get(0));
    backend.runInternalAction(ActionType.SaveManagedBlockStorageDiskDevice, parameters);
    return true;
}
#end_block

#method_before
private Map<String, Object>[] createCheckpointsMap() {
    final List<Map<String, Object>> result = new ArrayList<>();
    getParameters().getCheckpoints().forEach(checkpoint -> {
        Map<String, Object> params = new HashMap<>();
        params.put("id", checkpoint.getId().toString());
        params.put("created", checkpoint.getCreationDate().toString());
        params.put(VdsProperties.vm_disks, createDisksMap(checkpoint.getDisks()));
        result.add(params);
    });
    return result.toArray(new HashMap[0]);
}
#method_after
private HashMap[] createCheckpointsMap() {
    return getParameters().getCheckpoints().stream().map(checkpoint -> {
        Map<String, Object> params = new HashMap<>();
        params.put("id", checkpoint.getId().toString());
        params.put("created", checkpoint.getCreationDate().toString());
        params.put(VdsProperties.vm_disks, createDisksMap(checkpoint.getDisks()));
        return params;
    }).toArray(HashMap[]::new);
}
#end_block

#method_before
private Map<String, String>[] createDisksMap(List<DiskImage> disks) {
    final List<Map<String, String>> result = new ArrayList<>();
    disks.forEach(diskImage -> {
        Map<String, String> imageParams = new HashMap<>();
        imageParams.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        imageParams.put(VdsProperties.ImageId, diskImage.getId().toString());
        imageParams.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        result.add(imageParams);
    });
    return result.toArray(new HashMap[0]);
}
#method_after
private HashMap[] createDisksMap(List<DiskImage> disks) {
    return disks.stream().map(diskImage -> {
        Map<String, String> imageParams = new HashMap<>();
        imageParams.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        imageParams.put(VdsProperties.ImageId, diskImage.getId().toString());
        imageParams.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        return imageParams;
    }).toArray(HashMap[]::new);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    Guid fromCheckpointId = getParameters().getVmBackup().getFromCheckpointId();
    Guid toCheckpointId = getParameters().getVmBackup().getToCheckpointId();
    disksListReturn = getBroker().startVmBackup(getParameters().getVmBackup().getVmId().toString(), getParameters().getVmBackup().getId().toString(), createParametersStruct(), fromCheckpointId != null ? fromCheckpointId.toString() : null, toCheckpointId != null ? toCheckpointId.toString() : null);
    proceedProxyReturnValue();
    setReturnValue(disksListReturn.getDisks());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    Guid fromCheckpointId = getParameters().getVmBackup().getFromCheckpointId();
    Guid toCheckpointId = getParameters().getVmBackup().getToCheckpointId();
    disksListReturn = getBroker().startVmBackup(getParameters().getVmBackup().getVmId().toString(), getParameters().getVmBackup().getId().toString(), createDisksMap(), fromCheckpointId != null ? fromCheckpointId.toString() : null, toCheckpointId != null ? toCheckpointId.toString() : null);
    proceedProxyReturnValue();
    setReturnValue(disksListReturn.getDisks());
}
#end_block

#method_before
private Map<String, String>[] createDisksMap() {
    final List<Map<String, String>> result = new ArrayList<>();
    getParameters().getVmBackup().getDisks().forEach(diskImage -> {
        Map<String, String> imageParams = new HashMap<>();
        imageParams.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        imageParams.put(VdsProperties.ImageId, diskImage.getId().toString());
        imageParams.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        result.add(imageParams);
    });
    return result.toArray(new HashMap[0]);
}
#method_after
private HashMap[] createDisksMap() {
    return getParameters().getVmBackup().getDisks().stream().map(diskImage -> {
        Map<String, String> imageParams = new HashMap<>();
        imageParams.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
        imageParams.put(VdsProperties.ImageId, diskImage.getId().toString());
        imageParams.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
        return imageParams;
    }).toArray(HashMap[]::new);
}
#end_block

#method_before
public void setVmBackup(VmBackup value) {
    vmBackup = value;
}
#method_after
public void setVmBackup(VmBackup value) {
    this.vmBackup = value;
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        StorageDomain storageDomain = storageDomainDao.get(newDiskImage.getStorageIds().get(0));
        if (storageDomain.getStorageType().isBlockDomain()) {
            Integer maxBlockDiskSize = Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize);
            if (newDiskImage.getSize() / BYTES_IN_GB > maxBlockDiskSize) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED, String.format("$max_disk_size %1$s", maxBlockDiskSize));
            }
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!ActionUtils.canExecute(Collections.singletonList(vm), VM.class, ActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        if (newDiskImage.getDiskStorageType() == DiskStorageType.MANAGED_BLOCK_STORAGE) {
            if (!validate(isOperationSupportedByManagedBlockStorage(newDiskImage, getActionType()))) {
                return false;
            }
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        StorageDomain storageDomain = storageDomainDao.get(newDiskImage.getStorageIds().get(0));
        if (storageDomain.getStorageType().isBlockDomain()) {
            Integer maxBlockDiskSize = Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize);
            if (newDiskImage.getSize() / BYTES_IN_GB > maxBlockDiskSize) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED, String.format("$max_disk_size %1$s", maxBlockDiskSize));
            }
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!ActionUtils.canExecute(Collections.singletonList(vm), VM.class, ActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        if (storageDomain.getStorageType().isManagedBlockStorage()) {
            ManagedBlockStorageDomainValidator managedBlockStorageDomainValidator = new ManagedBlockStorageDomainValidator(storageDomain);
            if (!validate(managedBlockStorageDomainValidator.isOperationSupportedByManagedBlockStorage(getActionType()))) {
                return false;
            }
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
private void applyUserChanges(Disk diskToUpdate, DiskVmElement dveToUpdate) {
    updateSnapshotIdOnShareableChange(diskToUpdate, getNewDisk());
    diskToUpdate.setPropagateErrors(getNewDisk().getPropagateErrors());
    diskToUpdate.setWipeAfterDelete(getNewDisk().isWipeAfterDelete());
    diskToUpdate.setDiskAlias(getNewDisk().getDiskAlias());
    diskToUpdate.setDiskDescription(getNewDisk().getDiskDescription());
    diskToUpdate.setShareable(getNewDisk().isShareable());
    diskToUpdate.setSgio(getNewDisk().getSgio());
    dveToUpdate.setBoot(getDiskVmElement().isBoot());
    dveToUpdate.setDiskInterface(getDiskVmElement().getDiskInterface());
    dveToUpdate.setPassDiscard(getDiskVmElement().isPassDiscard());
    dveToUpdate.setUsingScsiReservation(getDiskVmElement().isUsingScsiReservation());
}
#method_after
private void applyUserChanges(Disk diskToUpdate, DiskVmElement dveToUpdate) {
    updateSnapshotIdOnShareableChange(diskToUpdate, getNewDisk());
    diskToUpdate.setPropagateErrors(getNewDisk().getPropagateErrors());
    diskToUpdate.setWipeAfterDelete(getNewDisk().isWipeAfterDelete());
    diskToUpdate.setDiskAlias(getNewDisk().getDiskAlias());
    diskToUpdate.setDiskDescription(getNewDisk().getDiskDescription());
    diskToUpdate.setShareable(getNewDisk().isShareable());
    diskToUpdate.setSgio(getNewDisk().getSgio());
    diskToUpdate.setBackup(getNewDisk().getBackup());
    dveToUpdate.setBoot(getDiskVmElement().isBoot());
    dveToUpdate.setDiskInterface(getDiskVmElement().getDiskInterface());
    dveToUpdate.setPassDiscard(getDiskVmElement().isPassDiscard());
    dveToUpdate.setUsingScsiReservation(getDiskVmElement().isUsingScsiReservation());
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskVmElementValidator diskVmElementValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && validateShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskVmElementValidator.isVirtIoScsiValid(vm)) && validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).existsAndUp()) && isStoragePoolMatching(vm) && validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskVmElementValidator diskVmElementValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = (getParameters().isSkipDomainCheck() || validate(storageDomainValidator.isDomainExistAndActive())) && validateShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.domainIsValidDestination()) && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskVmElementValidator.isVirtIoScsiValid(vm)) && validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).existsAndUp()) && isStoragePoolMatching(vm) && validate(new VmValidator(getVm()).vmNotLocked()) && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        warnIfVmNotFitInNumaNode();
        VMStatus status = null;
        try {
            acquireHostDevicesLock();
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections() && attachManagedBlockStorageDisks()) {
                if (!checkRequiredHostDevicesAvailability()) {
                    // (while the host-device lock wasn't being held) we need to bail here
                    throw new EngineException(EngineError.HOST_DEVICES_TAKEN_BY_OTHER_VM);
                } else {
                    status = createVm();
                    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                    markHostDevicesAsUsed();
                }
            }
        } catch (EngineException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                case HOST_DEVICES_TAKEN_BY_OTHER_VM:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            releaseHostDevicesLock();
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        warnIfVmNotFitInNumaNode();
        VMStatus status = null;
        try {
            acquireHostDevicesLock();
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections() && managedBlockStorageCommandUtil.attachManagedBlockStorageDisks(getVm(), vmHandler, getVds())) {
                if (!checkRequiredHostDevicesAvailability()) {
                    // (while the host-device lock wasn't being held) we need to bail here
                    throw new EngineException(EngineError.HOST_DEVICES_TAKEN_BY_OTHER_VM);
                } else {
                    status = createVm();
                    ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                    markHostDevicesAsUsed();
                }
            }
        } catch (EngineException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                case HOST_DEVICES_TAKEN_BY_OTHER_VM:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            releaseHostDevicesLock();
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writeVGpu();
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    boolean pciERootExists = false;
    int pciEPorts = 0;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "usb":
                        if (device.getSpecParams().get("model") != null && device.getSpecParams().get("model").equals("qemu-xhci")) {
                            device.getSpecParams().put("ports", 8);
                        }
                        break;
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                    case "pci":
                        if ("pcie-root".equals(device.getSpecParams().get("model"))) {
                            pciERootExists = true;
                        } else if ("pcie-root-port".equals(device.getSpecParams().get("model"))) {
                            pciEPorts++;
                        }
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86 && vm.getBiosType().getChipsetType() == ChipsetType.Q35) {
        writePciEControllers(pciERootExists, pciEPorts);
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writeVGpu();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            nativeIO = vmInfoBuildUtils.shouldUseNativeIO(vm, diskImage, device);
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            nativeIO = vmInfoBuildUtils.shouldUseNativeIO(vm, diskImage, device);
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(VmDevice device, Disk disk, String dev, DiskVmElement dve) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            if (FeatureSupported.isScsiReservationSupported(vm.getCompatibilityVersion()) && dve.isUsingScsiReservation()) {
                writer.writeStartElement("reservations");
                writer.writeAttributeString("managed", "yes");
                writer.writeEndElement();
            }
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
        case MANAGED_BLOCK_STORAGE:
            ManagedBlockStorageDisk managedBlockStorageDisk = (ManagedBlockStorageDisk) disk;
            String deviceGuid = (String) managedBlockStorageDisk.getDevice().get(DeviceInfoReturn.SCSI_WWN);
            String devicePath = String.format("/dev/mapper/%s", deviceGuid);
            writer.writeAttributeString("dev", devicePath);
            diskMetadata.put(dev, Collections.singletonMap("GUID", deviceGuid));
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(VmDevice device, Disk disk, String dev, DiskVmElement dve) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            // Change parameters for the HE disk
            if (vm.isHostedEngine()) {
                // Hosted engine disk images have to have empty storage pool ID,
                // so they can be mounted even if storage pool is not connected.
                diskImage.setStoragePoolId(Guid.Empty);
                diskImage.setPropagateErrors(PropagateErrors.Off);
                // The disk requires a lease
                addVolumeLease(diskImage.getImageId(), diskImage.getStorageIds().get(0));
            }
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            switch(diskType) {
                case "block":
                    writer.writeAttributeString("dev", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
                case "network":
                    String[] volInfo = vmInfoBuildUtils.getGlusterVolInfo(disk);
                    // drop to the 'file' case as a fallback.
                    if (volInfo != null) {
                        writer.writeAttributeString("protocol", "gluster");
                        writer.writeAttributeString("name", String.format("%s/%s/images/%s/%s", volInfo[1], diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
                        writer.writeStartElement("host");
                        writer.writeAttributeString("name", volInfo[0]);
                        writer.writeAttributeString("port", "0");
                        writer.writeEndElement();
                        break;
                    }
                case "file":
                    writer.writeAttributeString("file", vmInfoBuildUtils.getPathToImage(diskImage));
                    break;
            }
            diskMetadata.put(dev, createDiskParams(diskImage));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("dev", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            diskMetadata.put(dev, Collections.singletonMap("GUID", lunDisk.getLun().getLUNId()));
            if (FeatureSupported.isScsiReservationSupported(vm.getCompatibilityVersion()) && dve.isUsingScsiReservation()) {
                writer.writeStartElement("reservations");
                writer.writeAttributeString("managed", "yes");
                writer.writeEndElement();
            }
            break;
        case CINDER:
            // case RBD
            CinderDisk cinderDisk = (CinderDisk) disk;
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            writer.writeAttributeString("protocol", cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            writer.writeAttributeString("name", connectionInfoData.get("name").toString());
            List<String> hostAddresses = (List<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (List<String>) connectionInfoData.get("ports");
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                writer.writeStartElement("host");
                writer.writeAttributeString("name", hostAddresses.get(i));
                writer.writeAttributeString("port", hostPorts.get(i));
                // If no transport is specified, "tcp" is assumed.
                writer.writeEndElement();
            }
            break;
        case MANAGED_BLOCK_STORAGE:
            ManagedBlockStorageDisk managedBlockStorageDisk = (ManagedBlockStorageDisk) disk;
            String path = (String) managedBlockStorageDisk.getDevice().get(DeviceInfoReturn.PATH);
            Map<String, Object> attachment = (Map<String, Object>) managedBlockStorageDisk.getDevice().get(DeviceInfoReturn.ATTACHMENT);
            writer.writeAttributeString("dev", path);
            diskMetadata.put(dev, Collections.singletonMap("GUID", (String) attachment.get(DeviceInfoReturn.SCSI_WWN)));
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
public List<VmCheckpoint> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", id);
    List<VmCheckpoint> checkpoints = getCallsHandler().executeReadList("GetVmCheckpointsByVmId", vmCheckpointRowMapper, parameterSource);
    // Sort checkpoints from oldest to latest
    checkpoints.stream().sorted((o1, o2) -> {
        if (o1.getId() == o2.getId()) {
            return 0;
        }
        return o2.getParentId().equals(o1.getId()) ? -1 : 1;
    });
    return checkpoints;
}
#method_after
@Override
public List<VmCheckpoint> getAllForVm(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", id);
    return getCallsHandler().executeReadList("GetVmCheckpointsByVmId", vmCheckpointRowMapper, parameterSource);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.statusDisk(), "45px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractLinkColumn<StorageDomain>(new FieldUpdater<StorageDomain, String>() {

        @Override
        public void update(int index, StorageDomain storageDomain, String value) {
            Map<String, String> parameters = new HashMap<>();
            parameters.put(FragmentParams.NAME.getName(), storageDomain.getName());
            // The link was clicked, now fire an event to switch to details.
            getPlaceTransitionHandler().handlePlaceTransition(WebAdminApplicationPlaces.storageGeneralSubTabPlace, parameters);
        }
    }) {

        @Override
        public String getValue(StorageDomain object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> confirmedFreeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer confirmedAvailableSize = object.getConfirmedAvailableDiskSize();
            Long availableDiskSize = object.getAvailableDiskSize() == null ? null : Long.valueOf(object.getAvailableDiskSize());
            return confirmedAvailableSize == null ? availableDiskSize : Long.valueOf(confirmedAvailableSize);
        }

        @Override
        public SafeHtml getTooltip(StorageDomain object) {
            if (object.getConfirmedAvailableDiskSize() == null) {
                return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageNonThinTooltip());
            }
            return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageThinTooltip());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(confirmedFreeSpaceColumn, constants.confirmedFreeSpaceStorage(), "180px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    StorageDomainSharedStatusColumn sharedStatusColumn = new StorageDomainSharedStatusColumn();
    sharedStatusColumn.setContextMenuTitle(constants.sharedStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(sharedStatusColumn, constants.storageDomainStatus(), "45px");
    StorageDomainAdditionalStatusColumn additionalStatusColumn = new StorageDomainAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusStorage());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "60px");
    AbstractTextColumn<StorageDomain> nameColumn = new AbstractLinkColumn<StorageDomain>(new FieldUpdater<StorageDomain, String>() {

        @Override
        public void update(int index, StorageDomain storageDomain, String value) {
            Map<String, String> parameters = new HashMap<>();
            parameters.put(FragmentParams.NAME.getName(), storageDomain.getName());
            // The link was clicked, now fire an event to switch to details.
            getPlaceTransitionHandler().handlePlaceTransition(WebAdminApplicationPlaces.storageGeneralSubTabPlace, parameters);
        }
    }) {

        @Override
        public String getValue(StorageDomain object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StorageDomainFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.domainNameStorage(), "150px");
    CommentColumn<StorageDomain> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StorageDomain> domainTypeColumn = new AbstractEnumColumn<StorageDomain, StorageDomainType>() {

        @Override
        protected StorageDomainType getRawValue(StorageDomain object) {
            return object.getStorageDomainType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(domainTypeColumn, constants.domainTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> storageTypeColumn = new AbstractEnumColumn<StorageDomain, StorageType>() {

        @Override
        protected StorageType getRawValue(StorageDomain object) {
            return object.getStorageType();
        }
    };
    storageTypeColumn.makeSortable(StorageDomainFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storageTypeStorage(), "150px");
    AbstractTextColumn<StorageDomain> formatColumn = new AbstractEnumColumn<StorageDomain, StorageFormatType>() {

        @Override
        protected StorageFormatType getRawValue(StorageDomain object) {
            return object.getStorageFormat();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(formatColumn, constants.formatStorage(), "140px");
    AbstractTextColumn<StorageDomain> crossDataCenterStatusColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            if (object.getStorageDomainType() == StorageDomainType.ISO) {
                return EnumTranslator.getInstance().translate(object.getStorageDomainSharedStatus());
            } else {
                return EnumTranslator.getInstance().translate(object.getStatus());
            }
        }
    };
    crossDataCenterStatusColumn.makeSortable(StorageDomainFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(crossDataCenterStatusColumn, constants.crossDcStatusStorage(), "210px");
    AbstractStorageSizeColumn<StorageDomain> totalSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer totalSpace = object.getTotalDiskSize();
            return totalSpace == null ? null : Long.valueOf(totalSpace);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(totalSpaceColumn, constants.totalSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> freeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer availableDiskSize = object.getAvailableDiskSize();
            return availableDiskSize == null ? null : Long.valueOf(availableDiskSize);
        }
    };
    freeSpaceColumn.makeSortable(StorageDomainFieldAutoCompleter.SIZE);
    // $NON-NLS-1$
    getTable().addColumn(freeSpaceColumn, constants.freeSpaceStorage(), "130px");
    AbstractStorageSizeColumn<StorageDomain> confirmedFreeSpaceColumn = new AbstractStorageSizeColumn<StorageDomain>() {

        @Override
        public Long getRawValue(StorageDomain object) {
            Integer confirmedAvailableSize = object.getConfirmedAvailableDiskSize();
            Long availableDiskSize = object.getAvailableDiskSize() == null ? null : Long.valueOf(object.getAvailableDiskSize());
            return confirmedAvailableSize == null ? availableDiskSize : Long.valueOf(confirmedAvailableSize);
        }

        @Override
        public SafeHtml getTooltip(StorageDomain object) {
            if (object.getConfirmedAvailableDiskSize() == null) {
                return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageNonThinTooltip());
            }
            return SafeHtmlUtils.fromString(constants.confirmedFreeSpaceStorageThinTooltip());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(confirmedFreeSpaceColumn, constants.confirmedFreeSpaceStorage(), "180px");
    AbstractTextColumn<StorageDomain> descriptionColumn = new AbstractTextColumn<StorageDomain>() {

        @Override
        public String getValue(StorageDomain object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(StorageDomainFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.domainDescriptionStorage(), "200px");
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "usb":
                        if (device.getSpecParams().get("model").equals("qemu-xhci")) {
                            device.getSpecParams().put("ports", 8);
                        }
                        break;
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writeVGpu();
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmInfoBuildUtils.getVmDevices(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    devices = processPayload(devices);
    devices.stream().filter(d -> d.getSpecParams() == null).forEach(d -> d.setSpecParams(Collections.emptyMap()));
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllersForDomainXml(devices));
    writer.writeStartElement("devices");
    if (vm.getClusterArch() != ArchitectureType.s390x && !(vm.getClusterArch().getFamily() == ArchitectureType.ppc && vm.getVmType() == VmType.HighPerformance)) {
        // no mouse or tablet for s390x and for HP VMS with ppc architecture type
        writeInput();
    }
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    boolean balloonExists = false;
    boolean forceRefreshDevices = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                balloonExists = true;
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                // memory devices are only used for hot-plug
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "usb":
                        if (device.getSpecParams().get("model") != null && device.getSpecParams().get("model").equals("qemu-xhci")) {
                            device.getSpecParams().put("ports", 8);
                        }
                        break;
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        break;
                    case "virtio-scsi":
                        device.setDevice(VdsProperties.Scsi);
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("model", "virtio-scsi");
                        break;
                }
                writeController(device);
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if ("serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case REDIRDEV:
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                HostDevice hostDevice = hostDevicesSupplier.get().get(device.getDevice());
                if (hostDevice == null) {
                    if (!"mdev".equals(device.getDevice())) {
                        log.info("skipping VM host device {} for VM {}, no corresponding host device was found", device.getDevice(), device.getVmId());
                    }
                    forceRefreshDevices = true;
                    break;
                }
                writeHostDevice(device, hostDevice);
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    if (forceRefreshDevices) {
        vmInfoBuildUtils.refreshVmDevices(vm.getId());
    }
    if (!balloonExists) {
        writeDefaultBalloon();
    }
    writeSerialConsole(serialConsolePath);
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writeLeases();
    writeVGpu();
    writer.writeEndElement();
}
#end_block

#method_before
/*
     * USB controller
     */
public void addSpiceUsbControllers(Guid vmId, int numberOfControllers) {
    VmBase vmBase = getVmBase(vmId);
    // For each controller we need to create one EHCI and companion UHCI controllers or one Q35 usb controller
    if (vmBase.getBiosType().getChipsetType() == ChipsetType.Q35) {
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, createSingleUsbControllerSpecParams(Q35_MODEL), true, false);
    } else {
        for (int index = 0; index < numberOfControllers; index++) {
            addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getSpiceUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false);
            for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getSpiceUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false);
            }
        }
    }
}
#method_after
/*
     * USB controller
     */
public void addSpiceUsbControllers(Guid vmId, int numberOfControllers) {
    VmBase vmBase = getVmBase(vmId);
    if (vmBase.getBiosType().getChipsetType() == ChipsetType.Q35) {
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, createSingleUsbControllerSpecParams(XHCI_MODEL), true, false);
    } else {
        // For each EHCI controller we need to create companion UHCI controllers
        for (int index = 0; index < numberOfControllers; index++) {
            addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, createSpiceUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false);
            for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, createSpiceUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false);
            }
        }
    }
}
#end_block

#method_before
private void handleVmLease() {
    Guid importedLeaseStorageDomainId = getVm().getLeaseStorageDomainId();
    if (importedLeaseStorageDomainId == null) {
        return;
    }
    if (!getVm().isAutoStartup() || !shouldAddLease(getVm().getStaticData())) {
        getVm().setLeaseStorageDomainId(null);
        return;
    }
    if (validateLeaseStorageDomain(importedLeaseStorageDomainId)) {
        // In case of DR scenario, the lease should be exists on the domain and we need to avoid recreating it
        if (isVmLeaseExistsOnStorageDomain(importedLeaseStorageDomainId)) {
            return;
        } else if (addVmLease(importedLeaseStorageDomainId, getVm().getId(), false)) {
            return;
        }
    }
    getVm().setLeaseStorageDomainId(addVmLeaseToDefaultStorageDomain());
    if (getVm().getLeaseStorageDomainId() == null) {
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
    } else {
        log.warn("Creating the lease for the VM '{}' on storage domain '{}', because storage domain '{}' is unavailable", getVm().getId(), getVm().getLeaseStorageDomainId(), importedLeaseStorageDomainId);
    }
}
#method_after
private void handleVmLease() {
    Guid importedLeaseStorageDomainId = getVm().getLeaseStorageDomainId();
    if (importedLeaseStorageDomainId == null) {
        return;
    }
    if (!getVm().isAutoStartup() || !shouldAddLease(getVm().getStaticData())) {
        getVm().setLeaseStorageDomainId(null);
        return;
    }
    if (validateLeaseStorageDomain(importedLeaseStorageDomainId)) {
        return;
    }
    getVm().setLeaseStorageDomainId(findDefaultStorageDomainForVmLease());
    if (getVm().getLeaseStorageDomainId() == null) {
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
    } else {
        log.warn("Creating the lease for the VM '{}' on storage domain '{}', because storage domain '{}' is unavailable", getVm().getId(), getVm().getLeaseStorageDomainId(), importedLeaseStorageDomainId);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    handleVmLease();
    super.executeVmCommand();
}
#method_after
@Override
protected void executeVmCommand() {
    handleVmLease();
    super.executeVmCommand();
    addVmLeaseIfNeeded();
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    // it would be nicer to get this as part of the tasks rather
    // than initiating another call to the host, this approach is
    // easier and backward compatible though
    ActionReturnValue retVal = runInternalAction(ActionType.GetVmLeaseInfo, new VmLeaseParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getVmId()));
    if (retVal == null || !retVal.getSucceeded()) {
        return;
    }
    vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), retVal.getActionReturnValue());
    if (getParameters().isHotPlugLease()) {
        boolean hotPlugSucceeded = false;
        try {
            hotPlugSucceeded = runVdsCommand(VDSCommandType.HotPlugLease, new LeaseVDSParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot plugging a lease to VM {}, message: {}", getParameters().getVmId(), e.getMessage());
        }
        if (!hotPlugSucceeded) {
            setVmId(getParameters().getVmId());
            auditLog(this, AuditLogType.HOT_PLUG_LEASE_FAILED);
            getReturnValue().setEndActionTryAgain(false);
            setSucceeded(false);
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    // easier and backward compatible though
    if (getParameters().getVmLeaseInfo() == null) {
        ActionReturnValue retVal = runInternalAction(ActionType.GetVmLeaseInfo, new VmLeaseParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getVmId()));
        if (retVal == null || !retVal.getSucceeded()) {
            return;
        }
        getParameters().setVmLeaseInfo(retVal.getActionReturnValue());
    }
    vmDynamicDao.updateVmLeaseInfo(getParameters().getVmId(), getParameters().getVmLeaseInfo());
    if (getParameters().isHotPlugLease()) {
        boolean hotPlugSucceeded = false;
        try {
            hotPlugSucceeded = runVdsCommand(VDSCommandType.HotPlugLease, new LeaseVDSParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot plugging a lease to VM {}, message: {}", getParameters().getVmId(), e.getMessage());
        }
        if (!hotPlugSucceeded) {
            setVmId(getParameters().getVmId());
            auditLog(this, AuditLogType.HOT_PLUG_LEASE_FAILED);
            getReturnValue().setEndActionTryAgain(false);
            setSucceeded(false);
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    CinderlibReturnValue returnValue;
    List<String> extraParams = new ArrayList<>();
    extraParams.add(getParameters().getDiskId().toString());
    try {
        Map<String, Object> driverOptions = new HashMap<>(managedBlockStorage.getDriverOptions());
        if (managedBlockStorage.getDriverSensitiveOptions() != null) {
            driverOptions.putAll(managedBlockStorage.getDriverSensitiveOptions());
        }
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(driverOptions, false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibExecutor.CinderlibCommand.DELETE_VOLUME, params);
        if (!returnValue.getSucceed()) {
            setSucceeded(false);
            return;
        }
        ManagedBlockStorageDisk disk = new ManagedBlockStorageDisk();
        disk.setId(getParameters().getDiskId());
        disk.setImageId(getParameters().getDiskId());
        removeDiskFromDb(disk);
    } catch (Exception e) {
        log.error("Failed to remove volume: {}", e);
        setSucceeded(false);
        return;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    List<String> extraParams = new ArrayList<>();
    extraParams.add(getParameters().getDiskId().toString());
    CinderlibReturnValue returnValue;
    try {
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(managedBlockStorage.getAllDriverOptions(), false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibExecutor.CinderlibCommand.DELETE_VOLUME, params);
    } catch (Exception e) {
        log.error("Failed to remove volume: {}", e);
        return;
    }
    if (!returnValue.getSucceed()) {
        return;
    }
    removeDiskFromDb();
    setSucceeded(true);
}
#end_block

#method_before
private void removeDiskFromDb(ManagedBlockStorageDisk disk) {
    // Get the base volume and set it as active, so the disk will not disappear from the disks view.
    TransactionSupport.executeInNewTransaction(() -> {
        imageStorageDomainMapDao.remove(disk.getImageId());
        imageDao.remove(disk.getImageId());
        diskImageDynamicDao.remove(disk.getImageId());
        baseDiskDao.remove(disk.getId());
        return null;
    });
}
#method_after
private void removeDiskFromDb() {
    ManagedBlockStorageDisk disk = new ManagedBlockStorageDisk();
    disk.setId(getParameters().getDiskId());
    disk.setImageId(getParameters().getDiskId());
    TransactionSupport.executeInNewTransaction(() -> {
        imageStorageDomainMapDao.remove(disk.getImageId());
        imageDao.remove(disk.getImageId());
        diskImageDynamicDao.remove(disk.getImageId());
        baseDiskDao.remove(disk.getId());
        return null;
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    Guid volumeId = Guid.newGuid();
    CinderlibReturnValue returnValue;
    List<String> extraParams = new ArrayList<>();
    extraParams.add(volumeId.toString());
    Number sizeInGiB = SizeConverter.convert(getParameters().getDiskInfo().getSize(), SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB);
    extraParams.add(Long.toString(sizeInGiB.longValue()));
    try {
        Map<String, Object> driverOptions = new HashMap<>(managedBlockStorage.getDriverOptions());
        if (managedBlockStorage.getDriverSensitiveOptions() != null) {
            driverOptions.putAll(managedBlockStorage.getDriverSensitiveOptions());
        }
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(managedBlockStorage.getDriverOptions(), false), extraParams);
        new CinderlibCommandParameters(JsonHelper.mapToJson(driverOptions, false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibCommand.CREATE_VOLUME, params);
        if (!returnValue.getSucceed()) {
            setSucceeded(false);
            return;
        }
        saveDisk(volumeId);
    } catch (Exception e) {
        log.error("Failed executing volume creation", e);
        setSucceeded(false);
        return;
    }
    getReturnValue().setActionReturnValue(volumeId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    ManagedBlockStorage managedBlockStorage = cinderStorageDao.get(getParameters().getStorageDomainId());
    Guid volumeId = Guid.newGuid();
    List<String> extraParams = new ArrayList<>();
    extraParams.add(volumeId.toString());
    Number sizeInGiB = SizeConverter.convert(getParameters().getDiskInfo().getSize(), SizeConverter.SizeUnit.BYTES, SizeConverter.SizeUnit.GiB);
    extraParams.add(Long.toString(sizeInGiB.longValue()));
    CinderlibReturnValue returnValue;
    try {
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(managedBlockStorage.getAllDriverOptions(), false), extraParams);
        returnValue = cinderlibExecutor.runCommand(CinderlibCommand.CREATE_VOLUME, params);
    } catch (Exception e) {
        log.error("Failed executing volume creation", e);
        return;
    }
    if (!returnValue.getSucceed()) {
        return;
    }
    saveDisk(volumeId);
    getReturnValue().setActionReturnValue(volumeId);
    setSucceeded(true);
}
#end_block

#method_before
private ManagedBlockStorageDisk createDisk() {
    ManagedBlockStorageDisk disk = new ManagedBlockStorageDisk();
    disk.setDiskAlias(getDiskAlias());
    disk.setSize(getParameters().getDiskInfo().getSize());
    disk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    disk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    disk.setShareable(getParameters().getDiskInfo().isShareable());
    disk.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    disk.setSize(getParameters().getDiskInfo().getSize());
    disk.setVolumeType(VolumeType.Unassigned);
    disk.setVolumeFormat(VolumeFormat.RAW);
    disk.setCreationDate(new Date());
    disk.setLastModified(new Date());
    disk.setActive(true);
    disk.setQuotaId(getParameters().getQuotaId());
    return disk;
}
#method_after
private ManagedBlockStorageDisk createDisk() {
    ManagedBlockStorageDisk disk = new ManagedBlockStorageDisk();
    disk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
    disk.setSize(getParameters().getDiskInfo().getSize());
    disk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
    disk.setShareable(getParameters().getDiskInfo().isShareable());
    disk.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getStorageDomainId())));
    disk.setVolumeType(VolumeType.Unassigned);
    disk.setVolumeFormat(VolumeFormat.RAW);
    disk.setCreationDate(new Date());
    disk.setLastModified(new Date());
    disk.setActive(true);
    disk.setQuotaId(getParameters().getQuotaId());
    return disk;
}
#end_block

#method_before
private void initDiskImagesTable() {
    imageDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    AbstractDiskSizeColumn<EntityModel> actualSizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getActualSizeInBytes();
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(actualSizeColumn, constants.sizeVmDiskTable(), "100px");
    AbstractTextColumn<EntityModel> storageDomainColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    imageDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "100px");
    // $NON-NLS-1$
    imageDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    imageDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    imageDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    imageDiskTable.setWidth("100%");
    imageDiskTable.setEmptyTableWidget(new NoItemsLabel());
}
#method_after
private void initDiskImagesTable() {
    commonInitDiskImageTable(imageDiskTable, true);
}
#end_block

#method_before
private void initManagedBlockDisksTable() {
    managedBlockDiskTable.enableColumnResizing();
    AbstractTextColumn<EntityModel> aliasColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(aliasColumn, constants.aliasVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> descriptionColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getDiskDescription();
        }
    };
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(descriptionColumn, constants.descriptionVmDiskTable(), "85px");
    AbstractTextColumn<EntityModel> idColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getId().toString();
        }
    };
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(idColumn, constants.idVmDiskTable(), "85px");
    AbstractDiskSizeColumn<EntityModel> sizeColumn = new AbstractDiskSizeColumn<EntityModel>() {

        @Override
        protected Long getRawValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getSize();
        }
    };
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(sizeColumn, constants.provisionedSizeVmDiskTable(), "100px");
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(getDiskInterfaceSelectionColumn(), constants.interfaceVmDiskPopup(), "115px");
    AbstractTextColumn<EntityModel> storageDomainColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel object) {
            DiskImage diskImage = (DiskImage) ((DiskModel) object.getEntity()).getDisk();
            return diskImage.getStoragesNames().get(0);
        }
    };
    // $NON-NLS-1$
    managedBlockDiskTable.addColumn(storageDomainColumn, constants.storageDomainVmDiskTable(), "100px");
    managedBlockDiskTable.addColumn(getReadOnlyCheckBoxColumn(), new ImageResourceHeader(resources.readOnlyDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.readOnly())), // $NON-NLS-1$
    "30px");
    managedBlockDiskTable.addColumn(getBootCheckBoxColumn(), new ImageResourceHeader(resources.bootableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.bootableDisk())), // $NON-NLS-1$
    "30px");
    managedBlockDiskTable.addColumn(new AbstractImageResourceColumn<EntityModel>() {

        @Override
        public ImageResource getValue(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            return disk.isShareable() ? resources.shareableDiskIcon() : null;
        }

        @Override
        public SafeHtml getTooltip(EntityModel object) {
            Disk disk = ((DiskModel) object.getEntity()).getDisk();
            if (disk.isShareable()) {
                return SafeHtmlUtils.fromSafeConstant(constants.shareable());
            }
            return null;
        }
    }, new ImageResourceHeader(resources.shareableDiskIcon(), SafeHtmlUtils.fromTrustedString(constants.shareable())), // $NON-NLS-1$
    "30px");
    // $NON-NLS-1$
    managedBlockDiskTable.setWidth("100%");
    managedBlockDiskTable.setEmptyTableWidget(new NoItemsLabel());
}
#method_after
private void initManagedBlockDisksTable() {
    commonInitDiskImageTable(managedBlockDiskTable, false);
}
#end_block

#method_before
protected void updatePassDiscardAvailability() {
    if (!AsyncDataProvider.getInstance().isPassDiscardFeatureSupported(getDataCenter().getSelectedItem().getCompatibilityVersion())) {
        getPassDiscard().setIsAvailable(false);
        return;
    }
    if (getIsFloating()) {
        getPassDiscard().setIsAvailable(false);
    } else {
        DiskInterface selectedInterface = getDiskInterface().getSelectedItem();
        DiskStorageType selectedDiskStorageType = getDiskStorageType().getEntity();
        boolean isApplicableInterface = selectedInterface == DiskInterface.VirtIO_SCSI || selectedInterface == DiskInterface.IDE || selectedInterface == DiskInterface.SATA;
        boolean isApplicableDiskStorageType = selectedDiskStorageType == DiskStorageType.LUN || selectedDiskStorageType == DiskStorageType.IMAGE;
        boolean isApplicableStorageType = selectedDiskStorageType == DiskStorageType.LUN || (getStorageDomain().getSelectedItem() != null && getStorageDomain().getSelectedItem().getStorageType().isInternal());
        if (isApplicableInterface && isApplicableDiskStorageType && isApplicableStorageType) {
            getPassDiscard().setIsAvailable(true);
            if (!getIsNew()) {
                getPassDiscard().setEntity(getDiskVmElement().isPassDiscard());
            }
        } else {
            // Reset PassDiscard's availability and value.
            getPassDiscard().setIsAvailable(false);
            getPassDiscard().setEntity(false);
        }
    }
}
#method_after
protected void updatePassDiscardAvailability() {
    if (getIsFloating()) {
        getPassDiscard().setIsAvailable(false);
    } else {
        DiskInterface selectedInterface = getDiskInterface().getSelectedItem();
        DiskStorageType selectedDiskStorageType = getDiskStorageType().getEntity();
        boolean isApplicableInterface = selectedInterface == DiskInterface.VirtIO_SCSI || selectedInterface == DiskInterface.IDE || selectedInterface == DiskInterface.SATA;
        boolean isApplicableDiskStorageType = selectedDiskStorageType == DiskStorageType.LUN || selectedDiskStorageType == DiskStorageType.IMAGE;
        boolean isApplicableStorageType = selectedDiskStorageType == DiskStorageType.LUN || (getStorageDomain().getSelectedItem() != null && getStorageDomain().getSelectedItem().getStorageType().isInternal());
        if (isApplicableInterface && isApplicableDiskStorageType && isApplicableStorageType) {
            getPassDiscard().setIsAvailable(true);
            if (!getIsNew()) {
                getPassDiscard().setEntity(getDiskVmElement().isPassDiscard());
            }
        } else {
            // Reset PassDiscard's availability and value.
            getPassDiscard().setIsAvailable(false);
            getPassDiscard().setEntity(false);
        }
    }
}
#end_block

#method_before
public void flush() {
    switch(getDiskStorageType().getEntity()) {
        case LUN:
            LunDisk lunDisk = getLunDisk();
            DiskInterface diskInterface = getDiskInterface().getSelectedItem();
            if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
                lunDisk.setSgio(!getIsScsiPassthrough().getEntity() ? null : getIsSgIoUnfiltered().getEntity() ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
                if (!getIsFloating()) {
                    getDiskVmElement().setUsingScsiReservation(getIsUsingScsiReservation().getEntity());
                }
            } else {
                getIsScsiPassthrough().setEntity(false);
                lunDisk.setSgio(null);
                if (!getIsFloating()) {
                    getDiskVmElement().setUsingScsiReservation(false);
                }
            }
            setDisk(lunDisk);
            break;
        case CINDER:
            CinderDisk cinderDisk = getCinderDisk();
            updateQuota(cinderDisk);
            updateDiskSize(cinderDisk);
            setDisk(cinderDisk);
            break;
        case IMAGE:
            DiskImage diskImage = getDiskImage();
            // For a long time it was possible to delete all disk profiles
            if (getDiskProfile().getSelectedItem() != null) {
                diskImage.setDiskProfileId(getDiskProfile().getSelectedItem().getId());
            }
            updateQuota(diskImage);
            updateDiskSize(diskImage);
            setDisk(diskImage);
            break;
        case MANAGED_BLOCK_STORAGE:
            DiskImage managedBlockDisk = getManagedBlockDisk();
            updateQuota(managedBlockDisk);
            updateDiskSize(managedBlockDisk);
            setDisk(managedBlockDisk);
    }
    getDisk().setDiskAlias(getAlias().getEntity());
    getDisk().setDiskDescription(getDescription().getEntity());
    getDisk().setWipeAfterDelete(getIsWipeAfterDelete().getEntity());
    getDisk().setShareable(getIsShareable().getEntity());
    getDisk().setPlugged(getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    if (getVm() != null) {
        getDiskVmElement().setReadOnly(getIsReadOnly().getIsAvailable() ? getIsReadOnly().getEntity() : false);
        getDiskVmElement().setBoot(getIsBootable().getEntity());
        getDiskVmElement().setDiskInterface(getDiskInterface().getSelectedItem());
        getDiskVmElement().setPassDiscard(getPassDiscard().getEntity());
    }
}
#method_after
public void flush() {
    switch(getDiskStorageType().getEntity()) {
        case LUN:
            LunDisk lunDisk = getLunDisk();
            DiskInterface diskInterface = getDiskInterface().getSelectedItem();
            if (DiskInterface.VirtIO_SCSI.equals(diskInterface)) {
                lunDisk.setSgio(!getIsScsiPassthrough().getEntity() ? null : getIsSgIoUnfiltered().getEntity() ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
                if (!getIsFloating()) {
                    getDiskVmElement().setUsingScsiReservation(getIsUsingScsiReservation().getEntity());
                }
            } else {
                getIsScsiPassthrough().setEntity(false);
                lunDisk.setSgio(null);
                if (!getIsFloating()) {
                    getDiskVmElement().setUsingScsiReservation(false);
                }
            }
            setDisk(lunDisk);
            break;
        case CINDER:
            CinderDisk cinderDisk = getCinderDisk();
            updateQuota(cinderDisk);
            updateDiskSize(cinderDisk);
            setDisk(cinderDisk);
            break;
        case IMAGE:
            DiskImage diskImage = getDiskImage();
            // For a long time it was possible to delete all disk profiles
            if (getDiskProfile().getSelectedItem() != null) {
                diskImage.setDiskProfileId(getDiskProfile().getSelectedItem().getId());
            }
            updateQuota(diskImage);
            updateDiskSize(diskImage);
            setDisk(diskImage);
            break;
        case MANAGED_BLOCK_STORAGE:
            DiskImage managedBlockDisk = getManagedBlockDisk();
            updateQuota(managedBlockDisk);
            updateDiskSize(managedBlockDisk);
            setDisk(managedBlockDisk);
            break;
    }
    getDisk().setDiskAlias(getAlias().getEntity());
    getDisk().setDiskDescription(getDescription().getEntity());
    getDisk().setWipeAfterDelete(getIsWipeAfterDelete().getEntity());
    getDisk().setShareable(getIsShareable().getEntity());
    getDisk().setPlugged(getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    if (getVm() != null) {
        getDiskVmElement().setReadOnly(getIsReadOnly().getIsAvailable() ? getIsReadOnly().getEntity() : false);
        getDiskVmElement().setBoot(getIsBootable().getEntity());
        getDiskVmElement().setDiskInterface(getDiskInterface().getSelectedItem());
        getDiskVmElement().setPassDiscard(getPassDiscard().getEntity());
    }
}
#end_block

#method_before
private boolean testStorageConnection() {
    AddManagedBlockStorageDomainParameters parameters = (AddManagedBlockStorageDomainParameters) getParameters();
    Map<String, Object> driverOptions = new HashMap<>(parameters.getDriverOptions());
    if (parameters.getDriverSensitiveOptions() != null) {
        driverOptions.putAll(parameters.getDriverSensitiveOptions());
    }
    CinderlibReturnValue returnValue = null;
    Map<String, Object> storageStats;
    try {
        CinderlibCommandParameters params = new CinderlibCommandParameters(JsonHelper.mapToJson(driverOptions, false), Collections.singletonList(Boolean.TRUE.toString()));
        returnValue = cinderlibExecutor.runCommand(CinderlibExecutor.CinderlibCommand.STORAGE_STAT, params);
        storageStats = JsonHelper.jsonToMap(returnValue.getOutput());
    } catch (Exception e) {
        failValidation(EngineMessage.FAILED_TO_CONNECT_MANAGED_BLOCK_DOMAIN, String.format("$output %1$s", returnValue != null ? returnValue.getOutput() : ""));
        return false;
    }
    if (storageStats != null) {
        log.debug(storageStats.toString());
    }
    return (returnValue.getSucceed() && storageStats != null) || failValidation(EngineMessage.FAILED_TO_CONNECT_MANAGED_BLOCK_DOMAIN, String.format("$output %1$s", returnValue.getOutput()));
}
#method_after
private boolean testStorageConnection() {
    ActionReturnValue actionReturnValue = runInternalAction(ActionType.GetManagedBlockStorageStats, getParameters());
    return (actionReturnValue.getSucceeded() && actionReturnValue.getActionReturnValue() != null) || failValidation(EngineMessage.FAILED_TO_CONNECT_MANAGED_BLOCK_DOMAIN);
}
#end_block

#method_before
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getConnectedToPhysicalNetwork().setEntity(isConnectedToPhysicalNetwork());
    initMtu();
    initIsVm();
    getExternal().setEntity(getNetwork().isExternal());
    getExternal().setIsChangeable(false);
    if (isConnectedToPhysicalNetwork()) {
        if (getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
            getUsePhysicalNetworkFromDatacenter().setEntity(true);
        }
    } else {
        getNetworkLabel().setSelectedItem(getNetwork().getLabel());
        getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
        getVLanTag().setEntity(getNetwork().getVlanId());
    }
    initEnablePortSecurity();
    toggleProfilesAvailability();
}
#method_after
private void init() {
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    setHelpTag(HelpTag.edit_logical_network);
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getName());
    getDescription().setEntity(getNetwork().getDescription());
    getComment().setEntity(getNetwork().getComment());
    getIsStpEnabled().setEntity(getNetwork().getStp());
    getConnectedToPhysicalNetwork().setEntity(isConnectedToPhysicalNetwork());
    initMtu();
    initIsVm();
    getExternal().setEntity(getNetwork().isExternal());
    getExternal().setIsChangeable(false);
    if (isConnectedToPhysicalNetwork()) {
        if (getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
            getUsePhysicalNetworkFromDatacenter().setEntity(true);
        }
    } else {
        getNetworkLabel().setSelectedItem(getNetwork().getLabel());
        getHasVLanTag().setEntity(getNetwork().getVlanId() != null);
        getVLanTag().setEntity(getNetwork().getVlanId());
    }
    toggleProfilesAvailability();
}
#end_block

#method_before
@Override
public void syncWithBackend() {
    super.syncWithBackend();
    checkAndMapCustomExternalNetwork();
}
#method_after
@Override
public void syncWithBackend() {
    super.syncWithBackend();
    checkAndMapNetwork();
}
#end_block

#method_before
@Override
protected void initEnablePortSecurity() {
    if ((getNetwork().getProvidedBy() != null) && getNetwork().getProvidedBy().isPortSecurityConfigured()) {
        getPortSecuritySelector().setSelectedItem(getNetwork().getProvidedBy().getPortSecurityEnabled().equals(Boolean.TRUE) ? PortSecuritySelector.enablePortSecurity : PortSecuritySelector.disablePortSecurity);
    } else {
        getPortSecuritySelector().setSelectedItem(PortSecuritySelector.UNDEFINED);
    }
}
#method_after
@Override
protected void initEnablePortSecurity() {
    if (getNetwork().getProvidedBy().isPortSecurityConfigured()) {
        getPortSecuritySelector().setSelectedItem(getNetwork().getProvidedBy().getPortSecurityEnabled() ? PortSecuritySelectorValue.ENABLED : PortSecuritySelectorValue.DISABLED);
    } else {
        getPortSecuritySelector().setSelectedItem(PortSecuritySelectorValue.UNDEFINED);
    }
}
#end_block

#method_before
private ValidationResult checkHugepagesFitNumaNodes(final VmBase vmBase, final List<VmNumaNode> vmNumaNodes) {
    Optional<Integer> hugePageSizeKB = HugePageUtils.getHugePageSize(vmBase);
    if (!hugePageSizeKB.isPresent()) {
        return ValidationResult.VALID;
    }
    // Numa node size must be a multiple of hugepage size
    if (vmNumaNodes.stream().allMatch(node -> (node.getMemTotal() * 1024) % hugePageSizeKB.get() == 0)) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(EngineMessage.VM_NUMA_NODE_NOT_MULTIPLE_OF_HUGEPAGE);
}
#method_after
private ValidationResult checkHugepagesFitNumaNodes(final VmBase vmBase, final List<VmNumaNode> vmNumaNodes) {
    Optional<Integer> hugePageSizeKB = HugePageUtils.getHugePageSize(vmBase);
    if (!hugePageSizeKB.isPresent()) {
        return ValidationResult.VALID;
    }
    // NUMA node size must be a multiple of hugepage size
    if (vmNumaNodes.stream().allMatch(node -> (node.getMemTotal() * 1024) % hugePageSizeKB.get() == 0)) {
        return ValidationResult.VALID;
    }
    return new ValidationResult(EngineMessage.VM_NUMA_NODE_NOT_MULTIPLE_OF_HUGEPAGE);
}
#end_block

#method_before
public ValidationResult validateNumaCompatibility(final VM vm, final List<VmNumaNode> vmNumaNodes, final Map<String, List<VdsNumaNode>> hostsNumaNodesMap) {
    for (String pinnedVds : hostsNumaNodesMap.keySet()) {
        List<VdsNumaNode> currHostNumaNodes = hostsNumaNodesMap.get(pinnedVds);
        if (currHostNumaNodes == null || currHostNumaNodes.isEmpty()) {
            return new ValidationResult(EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY, String.format("$hostName %1$s", pinnedVds));
        }
        // One node is equal to no NUMA node architecture present
        if (currHostNumaNodes.size() == 1) {
            return new ValidationResult(EngineMessage.HOST_NUMA_NOT_SUPPORTED, String.format("$hostName %1$s", pinnedVds));
        }
        final Map<Integer, VdsNumaNode> hostNodeIndexToNodeMap = new HashMap<>();
        currHostNumaNodes.stream().forEach(node -> hostNodeIndexToNodeMap.put(node.getIndex(), node));
        for (VmNumaNode vmNumaNode : vmNumaNodes) {
            for (Integer vdsPinnedIndex : vmNumaNode.getVdsNumaNodeList()) {
                if (vdsPinnedIndex == null) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_PINNED_INDEX_ERROR);
                }
                if (!hostNodeIndexToNodeMap.containsKey(vdsPinnedIndex)) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX, String.format("$vdsNodeIndex %d", vdsPinnedIndex), String.format("$hostName %1$s", pinnedVds));
                }
                if (vm.getNumaTuneMode() == NumaTuneMode.STRICT && vmNumaNode.getMemTotal() > hostNodeIndexToNodeMap.get(vdsPinnedIndex).getMemTotal()) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_MEMORY_ERROR, String.format("$vmNodeIndex %d", vmNumaNode.getIndex()), String.format("$hostName %1$s", pinnedVds), String.format("$hostNodeIndex %d", vdsPinnedIndex));
                }
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateNumaCompatibility(final VM vm, final List<VmNumaNode> vmNumaNodes, final Map<Guid, List<VdsNumaNode>> hostsNumaNodesMap) {
    for (Map.Entry<Guid, List<VdsNumaNode>> entry : hostsNumaNodesMap.entrySet()) {
        Guid pinnedVds = entry.getKey();
        List<VdsNumaNode> pinnedVdsNumaNodes = entry.getValue();
        if (pinnedVdsNumaNodes == null || pinnedVdsNumaNodes.isEmpty()) {
            return new ValidationResult(EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY, String.format("$hostName %s", getHostNameOrId(pinnedVds)));
        }
        // One node is equal to no NUMA node architecture present
        if (pinnedVdsNumaNodes.size() == 1) {
            return new ValidationResult(EngineMessage.HOST_NUMA_NOT_SUPPORTED, String.format("$hostName %s", getHostNameOrId(pinnedVds)));
        }
        final Map<Integer, VdsNumaNode> hostNodeIndexToNodeMap = new HashMap<>();
        pinnedVdsNumaNodes.forEach(node -> hostNodeIndexToNodeMap.put(node.getIndex(), node));
        for (VmNumaNode vmNumaNode : vmNumaNodes) {
            for (Integer vdsPinnedIndex : vmNumaNode.getVdsNumaNodeList()) {
                if (vdsPinnedIndex == null) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_PINNED_INDEX_ERROR);
                }
                if (!hostNodeIndexToNodeMap.containsKey(vdsPinnedIndex)) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX, String.format("$vdsNodeIndex %d", vdsPinnedIndex), String.format("$hostName %s", getHostNameOrId(pinnedVds)));
                }
                if (vm.getNumaTuneMode() == NumaTuneMode.STRICT && vmNumaNode.getMemTotal() > hostNodeIndexToNodeMap.get(vdsPinnedIndex).getMemTotal()) {
                    return new ValidationResult(EngineMessage.VM_NUMA_NODE_MEMORY_ERROR, String.format("$vmNodeIndex %d", vmNumaNode.getIndex()), String.format("$hostName %s", getHostNameOrId(pinnedVds)), String.format("$hostNodeIndex %d", vdsPinnedIndex));
                }
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult checkVmNumaNodesIntegrity(final VM vm, final List<VmNumaNode> vmNumaNodes) {
    if (vmNumaNodes.isEmpty()) {
        return ValidationResult.VALID;
    }
    // Check VM's NUMA configuration
    ValidationResult validationResult = validateVmNumaConfig(vm, vmNumaNodes);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    // Check if the VM is pinned to at least one host
    if (vm.getDedicatedVmForVdsList().isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_AT_LEAST_ONE_HOST);
    }
    // check that VM's NUMA policy fits all pinned/assigned hosts NUMA policy
    final Map<String, List<VdsNumaNode>> hostsNumaNodesMap = new HashMap<>();
    for (Guid pinnedVds : vm.getDedicatedVmForVdsList()) {
        VDS host = vdsDao.get(pinnedVds);
        hostsNumaNodesMap.put(host == null ? pinnedVds.toString() : host.getName(), vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(pinnedVds));
    }
    return validateNumaCompatibility(vm, vmNumaNodes, hostsNumaNodesMap);
}
#method_after
public ValidationResult checkVmNumaNodesIntegrity(final VM vm, final List<VmNumaNode> vmNumaNodes) {
    if (vmNumaNodes.isEmpty()) {
        return ValidationResult.VALID;
    }
    // Check VM's NUMA configuration
    ValidationResult validationResult = validateVmNumaConfig(vm, vmNumaNodes);
    if (!validationResult.isValid()) {
        return validationResult;
    }
    // Check if the VM is pinned to at least one host
    if (vm.getDedicatedVmForVdsList().isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_AT_LEAST_ONE_HOST);
    }
    // check that VM's NUMA policy fits all pinned/assigned hosts NUMA policy
    final Map<Guid, List<VdsNumaNode>> hostsNumaNodesMap = new HashMap<>();
    vm.getDedicatedVmForVdsList().forEach(vdsId -> hostsNumaNodesMap.put(vdsId, vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId)));
    return validateNumaCompatibility(vm, vmNumaNodes, hostsNumaNodesMap);
}
#end_block

#method_before
@BeforeEach
public void setUp() {
    vdsNumaNodes = new ArrayList<>(Arrays.asList(createVdsNumaNode(1), createVdsNumaNode(2), createVdsNumaNode(3)));
    vmNumaNodes = new ArrayList<>(Arrays.asList(createVmNumaNode(0, vdsNumaNodes), createVmNumaNode(1)));
    mockVdsNumaNodeDao(vdsNumaNodeDao, vdsNumaNodes);
    mockVdsDao(vdsDao);
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setDedicatedVmForVdsList(Collections.singletonList(Guid.newGuid()));
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(2);
    vm.setVmMemSizeMb(4000);
    vm.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    vm.setNumaTuneMode(NumaTuneMode.INTERLEAVE);
    vm.setvNumaNodeList(vmNumaNodes);
}
#method_after
@BeforeEach
public void setUp() {
    vdsNumaNodes_host1 = new ArrayList<>(Arrays.asList(createVdsNumaNode(1), createVdsNumaNode(2), createVdsNumaNode(3)));
    vmNumaNodes = new ArrayList<>(Arrays.asList(createVmNumaNode(0, vdsNumaNodes_host1), createVmNumaNode(1)));
    mockVdsNumaNodeDao(vdsNumaNodeDao, vdsNumaNodes_host1);
    mockVdsDao(vdsDao);
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setDedicatedVmForVdsList(Collections.singletonList(Guid.newGuid()));
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(2);
    vm.setVmMemSizeMb(4000);
    vm.setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
    vm.setNumaTuneMode(NumaTuneMode.INTERLEAVE);
    vm.setvNumaNodeList(vmNumaNodes);
}
#end_block

#method_before
@Test
public void shouldDetectHostWihtoutNumaSupport() {
    vdsNumaNodes = new ArrayList(Collections.singletonList(createVdsNumaNode(1)));
    hostNumaNodesMap = new HashMap<>();
    hostNumaNodesMap.put(Guid.newGuid().toString(), vdsNumaNodes);
    assertValidationFailure(underTest.validateNumaCompatibility(vm, vm.getvNumaNodeList(), hostNumaNodesMap), EngineMessage.HOST_NUMA_NOT_SUPPORTED);
}
#method_after
@Test
public void shouldDetectHostWihtoutNumaSupport() {
    vdsNumaNodes_host1 = new ArrayList(Collections.singletonList(createVdsNumaNode(1)));
    hostNumaNodesMap = new HashMap<>();
    hostNumaNodesMap.put(Guid.newGuid(), vdsNumaNodes_host1);
    assertValidationFailure(underTest.validateNumaCompatibility(vm, vm.getvNumaNodeList(), hostNumaNodesMap), EngineMessage.HOST_NUMA_NOT_SUPPORTED);
}
#end_block

#method_before
@Test
public void shouldDetectZeroHostNodes() {
    vdsNumaNodes.clear();
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#method_after
@Test
public void shouldDetectZeroHostNodes() {
    vdsNumaNodes_host1.clear();
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#end_block

#method_before
@Test
public void shouldDetectInsufficientMemory() {
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    vmNumaNodes.get(0).setMemTotal(1000);
    vdsNumaNodes.get(0).setMemTotal(500);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_MEMORY_ERROR);
}
#method_after
@Test
public void shouldDetectInsufficientMemory() {
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    vmNumaNodes.get(0).setMemTotal(1000);
    vdsNumaNodes_host1.get(0).setMemTotal(500);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_MEMORY_ERROR);
}
#end_block

#method_before
@Test
public void shouldDetectTooMuchHostNodes() {
    vm.setvNumaNodeList(Collections.singletonList(createVmNumaNode(1, vdsNumaNodes)));
    vm.setNumaTuneMode(NumaTuneMode.PREFERRED);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_PREFERRED_NOT_PINNED_TO_SINGLE_NODE);
}
#method_after
@Test
public void shouldDetectTooMuchHostNodes() {
    vm.setvNumaNodeList(Collections.singletonList(createVmNumaNode(1, vdsNumaNodes_host1)));
    vm.setNumaTuneMode(NumaTuneMode.PREFERRED);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_PREFERRED_NOT_PINNED_TO_SINGLE_NODE);
}
#end_block

#method_before
@Test
public void shouldDetectSufficientMemory() {
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    vmNumaNodes.get(0).setMemTotal(1000);
    vdsNumaNodes.get(0).setMemTotal(2000);
    assertTrue(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()).isValid());
}
#method_after
@Test
public void shouldDetectSufficientMemory() {
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    vmNumaNodes.get(0).setMemTotal(1000);
    vdsNumaNodes_host1.get(0).setMemTotal(2000);
    assertTrue(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()).isValid());
}
#end_block

#method_before
@Test
public void shouldDetectMissingRequiredHostNumaNodes() {
    vdsNumaNodes.remove(0);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX);
}
#method_after
@Test
public void shouldDetectMissingRequiredHostNumaNodes() {
    vdsNumaNodes_host1.remove(0);
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX);
}
#end_block

#method_before
@Override
public void setVmsWithvNumaNodeList(List<VM> vmsWithvNumaNodeList) {
    super.setVmsWithvNumaNodeList(vmsWithvNumaNodeList);
    if (!vmsWithvNumaNodeList.contains(vm) & getParentModel() instanceof UnitVmModel) {
        UnitVmModel model = (UnitVmModel) getParentModel();
        if (model.getNumaNodeCount().getEntity() > 0 && model.getDefaultHost().getSelectedItems().contains(host)) {
            vmsWithvNumaNodeList.add(vm);
        }
    }
    if (Guid.isNullOrEmpty(vm.getId())) {
        if (getParentModel() instanceof UnitVmModel) {
            UnitVmModel model = (UnitVmModel) getParentModel();
            if (model.getVmNumaNodes() != null) {
                // maintains NUMA pinning settings in UI prior to save
                // for new VMs
                this.getVm().setvNumaNodeList(model.getVmNumaNodes());
            }
        }
        vmsWithvNumaNodeList.add(vm);
    } else {
        for (VM vmFromDb : vmsWithvNumaNodeList) {
            if (vmFromDb.getId().equals(vm.getId())) {
                // maintains NUMA pinning settings in UI prior to save
                // for existing VMs
                vmFromDb.setvNumaNodeList(vm.getvNumaNodeList());
                break;
            }
        }
    }
}
#method_after
@Override
public void setVmsWithvNumaNodeList(List<VM> vmsWithvNumaNodeList) {
    super.setVmsWithvNumaNodeList(vmsWithvNumaNodeList);
    // Fix displayed VMs list according to model configuration
    if (getParentModel() instanceof UnitVmModel && host.isNumaSupport()) {
        UnitVmModel model = (UnitVmModel) getParentModel();
        if (model.getNumaNodeCount().getEntity() > 0 && !vmsWithvNumaNodeList.contains(vm)) {
            vmsWithvNumaNodeList.add(vm);
        } else if (model.getNumaNodeCount().getEntity() == 0) {
            vmsWithvNumaNodeList.remove(vm);
        }
    }
    if (Guid.isNullOrEmpty(vm.getId())) {
        if (getParentModel() instanceof UnitVmModel) {
            UnitVmModel model = (UnitVmModel) getParentModel();
            if (model.getVmNumaNodes() != null) {
                // maintains NUMA pinning settings in UI prior to save
                // for new VMs
                this.getVm().setvNumaNodeList(model.getVmNumaNodes());
            }
        }
    } else {
        for (VM vmFromDb : vmsWithvNumaNodeList) {
            if (vmFromDb.getId().equals(vm.getId())) {
                // maintains NUMA pinning settings in UI prior to save
                // for existing VMs
                vmFromDb.setvNumaNodeList(vm.getvNumaNodeList());
                break;
            }
        }
    }
}
#end_block

#method_before
@PostConstruct
private void init() {
    url = String.format(urlTemplate, config.getProperty(ENGINE_DB_USER), config.getProperty(ENGINE_DB_PASSWORD), config.getProperty(ENGINE_DB_HOST), config.getProperty(ENGINE_DB_PORT));
}
#method_after
@PostConstruct
private void init() {
    url = String.format(urlTemplate, config.getProperty(ENGINE_DB_USER), config.getProperty(ENGINE_DB_PASSWORD), config.getProperty(ENGINE_DB_HOST), config.getProperty(ENGINE_DB_PORT));
    cinderlibDir = Paths.get(config.getUsrDir().getAbsolutePath() + CINDERLIB_DIR).toFile();
}
#end_block

#method_before
public CinderlibReturnValue runCommand(CinderlibCommand command, CinderlibCommandParameters params) throws Exception {
    File dir = Paths.get(config.getUsrDir().getAbsolutePath() + CINDERLIB_DIR).toFile();
    ProcessBuilder cinderlibProcessBuilder = new ProcessBuilder().directory(dir).command(generateCommand(command, params)).redirectErrorStream(true);
    Process process = cinderlibProcessBuilder.start();
    String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
    log.info("cinderlib output: {}", output);
    if (!process.waitFor(2, TimeUnit.MINUTES)) {
        throw new Exception("cinderlib call timed out");
    }
    CinderlibReturnValue returnValue = new CinderlibReturnValue(process.exitValue(), output);
    return returnValue;
}
#method_after
public CinderlibReturnValue runCommand(CinderlibCommand command, CinderlibCommandParameters params) throws Exception {
    ProcessBuilder cinderlibProcessBuilder = new ProcessBuilder().directory(cinderlibDir).command(generateCommand(command, params)).redirectErrorStream(true);
    Process process = cinderlibProcessBuilder.start();
    String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
    log.info("cinderlib output: {}", output);
    if (!process.waitFor(2, TimeUnit.MINUTES)) {
        throw new Exception("cinderlib call timed out");
    }
    CinderlibReturnValue returnValue = new CinderlibReturnValue(process.exitValue(), output);
    return returnValue;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (!(o instanceof CinderlibCommandParameters))
        return false;
    CinderlibCommandParameters that = (CinderlibCommandParameters) o;
    return Objects.equals(driverInfo, that.driverInfo) && Objects.equals(extraParams, that.extraParams);
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (!(o instanceof CinderlibCommandParameters)) {
        return false;
    }
    CinderlibCommandParameters that = (CinderlibCommandParameters) o;
    return Objects.equals(driverInfo, that.driverInfo) && Objects.equals(extraParams, that.extraParams);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    setDiskAlias();
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
        case STORAGE_OFFLOAD:
            createOffloadDisk();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    setDiskAlias();
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
        case MANAGED_BLOCK_STORAGE:
            createManagedBlockStorageDisk();
    }
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(ActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    ActionReturnValue tmpRetValue = runInternalActionWithTasksContext(ActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    attachImage();
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(ActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    ActionReturnValue tmpRetValue = runInternalActionWithTasksContext(ActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        attachImage();
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private Guid getQuotaId() {
    if (getParameters().getDiskInfo() != null && getParameters().getDiskInfo().getDiskStorageType().isInternal()) {
        Guid quotaId = ((DiskImage) getParameters().getDiskInfo()).getQuotaId();
        return getQuotaManager().getDefaultQuotaIfNull(quotaId, getStoragePoolId());
    }
    return null;
}
#method_after
private Guid getQuotaId() {
    if (getParameters().getDiskInfo() != null && getParameters().getDiskInfo().getDiskStorageType().isInternal()) {
        Guid quotaId = ((DiskImage) getParameters().getDiskInfo()).getQuotaId();
        return getQuotaManager().getFirstQuotaForUser(quotaId, getStoragePoolId(), getCurrentUser());
    }
    return null;
}
#end_block

#method_before
public List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    models.addAll(getOffLaodStorageModels());
    return models;
}
#method_after
public List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    return models;
}
#end_block

#method_before
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    List<IStorageModel> items = AsyncDataProvider.getInstance().getDataStorageModels();
    items.addAll(AsyncDataProvider.getInstance().getIsoStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getExportStorageModels());
    model.setStorageModels(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#method_after
private void newDomain() {
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDomainTitle());
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    // putting all Data domains at the beginning on purpose (so when choosing the
    // first selectable storage type/function, it will be a Data one, if relevant).
    List<IStorageModel> items = AsyncDataProvider.getInstance().getDataStorageModels();
    items.addAll(AsyncDataProvider.getInstance().getIsoStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getExportStorageModels());
    items.addAll(AsyncDataProvider.getInstance().getManagedBlockStorageModels());
    model.setStorageModels(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = createCancelCommand("Cancel");
    model.getCommands().add(command);
}
#end_block

#method_before
private IStorageModel getStorageModelByStorage(StorageDomain storage) {
    switch(storage.getStorageType()) {
        case NFS:
            return new NfsStorageModel();
        case FCP:
            return new FcpStorageModel();
        case ISCSI:
            return new IscsiStorageModel();
        case LOCALFS:
            return new LocalStorageModel();
        case POSIXFS:
            return new PosixStorageModel();
        case GLUSTERFS:
            return new GlusterStorageModel();
        case STORAGE_OFFLOAD:
            return new OffloadStorageModel();
    }
    return null;
}
#method_after
private IStorageModel getStorageModelByStorage(StorageDomain storage) {
    switch(storage.getStorageType()) {
        case NFS:
            return new NfsStorageModel();
        case FCP:
            return new FcpStorageModel();
        case ISCSI:
            return new IscsiStorageModel();
        case LOCALFS:
            return new LocalStorageModel();
        case POSIXFS:
            return new PosixStorageModel();
        case GLUSTERFS:
            return new GlusterStorageModel();
        case MANAGED_BLOCK_STORAGE:
            return new ManagedBlockStorageModel();
    }
    return null;
}
#end_block

#method_before
private void onSavePostNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        saveNfsStorage();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        saveLocalStorage();
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        savePosixStorage();
    } else if (model.getCurrentStorageItem() instanceof OffloadStorageModel) {
        saveOffloadStorage();
    } else {
        saveSanStorage();
    }
}
#method_after
private void onSavePostNameValidation() {
    StorageModel model = (StorageModel) getWindow();
    if (!model.validate()) {
        return;
    }
    if (model.getCurrentStorageItem() instanceof NfsStorageModel) {
        saveNfsStorage();
    } else if (model.getCurrentStorageItem() instanceof LocalStorageModel) {
        saveLocalStorage();
    } else if (model.getCurrentStorageItem() instanceof PosixStorageModel) {
        savePosixStorage();
    } else if (model.getCurrentStorageItem() instanceof ManagedBlockStorageModel) {
        saveManagedBlockStorage();
    } else {
        saveSanStorage();
    }
}
#end_block

#method_before
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    final PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                posixModel.getPath().setIsValid(false);
                handleDomainAlreadyExists(storages);
            } else {
                saveNewPosixStorage();
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void savePosixStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    final PosixStorageModel posixModel = (PosixStorageModel) storageModel;
    path = posixModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                posixModel.getPath().setIsValid(false);
                handleDomainAlreadyExists(storages.get(0).getStorageName());
            } else {
                saveNewPosixStorage();
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    final NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                nfsModel.getPath().setIsValid(false);
                handleDomainAlreadyExists(storages);
            } else {
                saveNewNfsStorage();
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveNfsStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    final NfsStorageModel nfsModel = (NfsStorageModel) storageModel;
    path = nfsModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    storageDomain.setStorageFormat(model.getFormat().getSelectedItem());
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                nfsModel.getPath().setIsValid(false);
                handleDomainAlreadyExists(storages.get(0).getStorageName());
            } else {
                saveNewNfsStorage();
            }
        }), null, path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                handleDomainAlreadyExists(storages);
            } else {
                saveNewLocalStorage();
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#method_after
private void saveLocalStorage(TaskContext context) {
    this.context = context;
    StorageDomain selectedItem = getSelectedItem();
    StorageModel model = (StorageModel) getWindow();
    VDS host = model.getHost().getSelectedItem();
    boolean isNew = model.getStorage() == null;
    storageModel = model.getCurrentStorageItem();
    LocalStorageModel localModel = (LocalStorageModel) storageModel;
    path = localModel.getPath().getEntity();
    storageDomain = isNew ? new StorageDomainStatic() : (StorageDomainStatic) Cloner.clone(selectedItem.getStorageStaticData());
    saveBaseStorageProperties(model);
    if (isNew) {
        AsyncDataProvider.getInstance().getStorageDomainsByConnection(new AsyncQuery<>(storages -> {
            if (storages != null && storages.size() > 0) {
                handleDomainAlreadyExists(storages.get(0).getStorageName());
            } else {
                saveNewLocalStorage();
            }
        }), host.getStoragePoolId(), path);
    } else {
        StorageDomain storageDomain = getSelectedItem();
        if (isPathEditable(storageDomain)) {
            updatePath();
        }
        updateStorageDomain();
    }
}
#end_block

#method_before
private void handleDomainAlreadyExists(List<StorageDomain> storages) {
    String storageName = storages.get(0).getStorageName();
    onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#method_after
private void handleDomainAlreadyExists(String storageName) {
    onFinish(context, false, storageModel, ConstantsManager.getInstance().getMessages().createFailedDomainAlreadyExistStorageMsg(storageName));
}
#end_block

#method_before
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if ("SaveNfs".equals(key)) {
        // $NON-NLS-1$
        saveNfsStorage(context);
    } else if ("SaveLocal".equals(key)) {
        // $NON-NLS-1$
        saveLocalStorage(context);
    } else if ("SavePosix".equals(key)) {
        // $NON-NLS-1$
        savePosixStorage(context);
    } else if ("SaveSan".equals(key)) {
        // $NON-NLS-1$
        saveSanStorage(context);
    } else if ("SaveOffload".equals(key)) {
        // $NON-NLS-1$
        saveOffloadStorage(context);
    } else if ("ImportFile".equals(key)) {
        // $NON-NLS-1$
        importFileStorage(context);
    } else if ("ImportSan".equals(key)) {
        // $NON-NLS-1$
        importSanStorage(context);
    } else if ("Finish".equals(key)) {
        // $NON-NLS-1$
        if (getWindow() == null) {
            return;
        }
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#method_after
@Override
public void run(TaskContext context) {
    ArrayList<Object> data = (ArrayList<Object>) context.getState();
    String key = (String) data.get(0);
    if ("SaveNfs".equals(key)) {
        // $NON-NLS-1$
        saveNfsStorage(context);
    } else if ("SaveLocal".equals(key)) {
        // $NON-NLS-1$
        saveLocalStorage(context);
    } else if ("SavePosix".equals(key)) {
        // $NON-NLS-1$
        savePosixStorage(context);
    } else if ("SaveSan".equals(key)) {
        // $NON-NLS-1$
        saveSanStorage(context);
    } else if ("SaveManagedBlock".equals(key)) {
        // $NON-NLS-1$
        saveManagedBlockStorage(context);
    } else if ("ImportFile".equals(key)) {
        // $NON-NLS-1$
        importFileStorage(context);
    } else if ("ImportSan".equals(key)) {
        // $NON-NLS-1$
        importSanStorage(context);
    } else if ("Finish".equals(key)) {
        // $NON-NLS-1$
        if (getWindow() == null) {
            return;
        }
        getWindow().stopProgress();
        if ((Boolean) data.get(1)) {
            cancel();
        } else {
            ((Model) data.get(2)).setMessage((String) data.get(3));
        }
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CinderStorage storage) {
    return createIdParameterMapper(storage.getId()).addValue("driver_options", ObjectUtils.mapNullable(storage.getDriverOptions(), JsonHelper::mapToJsonUnchecked)).addValue("driver_sensitive_options", DbFacadeUtils.encryptPassword(ObjectUtils.mapNullable(storage.getDriverSensitiveOptions(), JsonHelper::mapToJsonUnchecked)));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(ManagedBlockStorage storage) {
    return createIdParameterMapper(storage.getId()).addValue("driver_options", ObjectUtils.mapNullable(storage.getDriverOptions(), JsonHelper::mapToJsonUnchecked)).addValue("driver_sensitive_options", DbFacadeUtils.encryptPassword(ObjectUtils.mapNullable(storage.getDriverSensitiveOptions(), JsonHelper::mapToJsonUnchecked)));
}
#end_block

#method_before
@Override
protected RowMapper<CinderStorage> createEntityRowMapper() {
    return cinderStorageDomainStaticRowMapper;
}
#method_after
@Override
protected RowMapper<ManagedBlockStorage> createEntityRowMapper() {
    return cinderStorageDomainStaticRowMapper;
}
#end_block

#method_before
public void createLineModelsFromMap(Map<String, Object> keyValueMap) {
    List<KeyValueLineModel> lineModels = new ArrayList<>();
    if (useEditableKey) {
        for (String key : keyValueMap.keySet()) {
            KeyValueLineModel lineModel = createNewLineModel(null);
            lineModel.getValue().setEntity(key);
            lineModel.getEditableKey().setEntity((String) keyValueMap.get(key));
            lineModels.add(lineModel);
        }
    }
    setItems(lineModels);
}
#method_after
public void createLineModelsFromMap(Map<String, Object> keyValueMap) {
    List<KeyValueLineModel> lineModels = new ArrayList<>();
    if (useEditableKey) {
        for (Map.Entry<String, Object> entry : keyValueMap.entrySet()) {
            KeyValueLineModel lineModel = createNewLineModel(null);
            lineModel.getValue().setEntity(entry.getKey());
            lineModel.getEditableKey().setEntity((String) entry.getValue());
            lineModels.add(lineModel);
        }
    }
    setItems(lineModels);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getVdsId()) && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (Guid.isNullOrEmpty(getVdsId()) && !validate(validateEligibleProxyHostExists())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failValidation(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validateNoDuplicateImage()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getStorageDomain() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
    }
    if (!getStorageDomain().getStoragePoolId().equals(getStoragePoolId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_AND_CLUSTER_IN_DIFFERENT_POOL);
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (getStorageDomain().getStatus() != StorageDomainStatus.Active) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
    }
    if (!Guid.isNullOrEmpty(getVdsId()) && !validate(validateRequestedProxyHost())) {
        return false;
    }
    if (Guid.isNullOrEmpty(getVdsId()) && !validate(validateEligibleProxyHostExists())) {
        return false;
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateUniqueVmName()) {
        return false;
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!validateStorageSpace()) {
        return false;
    }
    if (getParameters().getVirtioIsoName() != null && getActiveIsoDomainId() == null) {
        return failValidation(EngineMessage.ERROR_CANNOT_FIND_ISO_IMAGE_PATH);
    }
    if (!validate(vmHandler.validateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void processImages() {
    ArrayList<Guid> diskIds = getVm().getImages().stream().map(this::adjustDisk).map(this::createDisk).collect(Collectors.toCollection(ArrayList::new));
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#method_after
@Override
protected void processImages() {
    regenerateDiskIds();
    ArrayList<Guid> diskIds = getVm().getImages().stream().map(this::adjustDisk).map(this::createDisk).collect(Collectors.toCollection(ArrayList::new));
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isStorageOffloadDomain()) {
        handleStorageOffloadDomain();
        return;
    }
    if (isCinderStorageDomain()) {
        handleCinderDomain();
        return;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Collections.singletonList(getStorageDomain().getId()), getParameters().getSessionId());
        parameters.setIsInternal(true);
        parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
        ActionReturnValue returnValue = runInternalAction(ActionType.AddStoragePoolWithStorages, parameters, getContext().clone().withoutCompensationContext());
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            getReturnValue().setFault(returnValue.getFault());
        }
    } else {
        map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
        if (map == null) {
            executeInNewTransaction(() -> {
                map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                storagePoolIsoMapDao.save(map);
                getCompensationContext().snapshotNewEntity(map);
                getCompensationContext().stateChanged();
                return null;
            });
            List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
            if (isAllHostConnectionFailed(hostsConnectionResults)) {
                log.error("Cannot connect storage connection server, aborting attach storage domain operation.");
                setSucceeded(false);
                return;
            }
            // Forcibly detach only data storage domains.
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                @SuppressWarnings("unchecked")
                Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                // If the storage domain is already related to another Storage Pool, detach it by force.
                Guid storagePoolId = domainFromIrs.getSecond();
                if (storagePoolId != null) {
                    // Master domain version is not relevant since force remove at
                    // DetachStorageDomainVdsCommand does not use it.
                    // Storage pool id can be empty
                    DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                    detachParams.setForce(true);
                    detachParams.setDetachFromOldStoragePool(true);
                    try {
                        runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                    } catch (EngineException e) {
                        log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                        throw e;
                    }
                }
                if (diskProfileDao.getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
                    createDefaultDiskProfile();
                }
            }
            runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
            final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = new ArrayList<>();
            if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                List<OvfEntityData> returnValueFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                unregisteredEntitiesFromOvfDisk.addAll(returnValueFromStorageOvfDisk);
            }
            List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
            executeInNewTransaction(() -> {
                final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                map.setStatus(StorageDomainStatus.Maintenance);
                storagePoolIsoMapDao.updateStatus(map.getId(), map.getStatus());
                if (sdType == StorageDomainType.Master) {
                    calcStoragePoolStatusByDomainsStatus();
                }
                if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                    registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                    // Update unregistered entities
                    for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                        unregisteredOVFDataDao.removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                        unregisteredOVFDataDao.saveOVFData(ovf);
                        log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                    }
                    initUnregisteredDisksToDB(getParameters().getStorageDomainId());
                }
                // upgrade the domain format to the storage pool format
                updateStorageDomainFormatIfNeeded(getStorageDomain());
                return null;
            });
            if (getParameters().getActivate()) {
                attemptToActivateDomain();
            }
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (isManagedBlockStorageDomain()) {
        handleManagedBlockStorageDomain();
        return;
    }
    if (isCinderStorageDomain()) {
        handleCinderDomain();
        return;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Collections.singletonList(getStorageDomain().getId()), getParameters().getSessionId());
        parameters.setIsInternal(true);
        parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
        ActionReturnValue returnValue = runInternalAction(ActionType.AddStoragePoolWithStorages, parameters, getContext().clone().withoutCompensationContext());
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            getReturnValue().setFault(returnValue.getFault());
        }
    } else {
        map = storagePoolIsoMapDao.get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
        if (map == null) {
            executeInNewTransaction(() -> {
                map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                storagePoolIsoMapDao.save(map);
                getCompensationContext().snapshotNewEntity(map);
                getCompensationContext().stateChanged();
                return null;
            });
            List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
            if (isAllHostConnectionFailed(hostsConnectionResults)) {
                log.error("Cannot connect storage connection server, aborting attach storage domain operation.");
                setSucceeded(false);
                return;
            }
            // Forcibly detach only data storage domains.
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                @SuppressWarnings("unchecked")
                Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                // If the storage domain is already related to another Storage Pool, detach it by force.
                Guid storagePoolId = domainFromIrs.getSecond();
                if (storagePoolId != null) {
                    // Master domain version is not relevant since force remove at
                    // DetachStorageDomainVdsCommand does not use it.
                    // Storage pool id can be empty
                    DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                    detachParams.setForce(true);
                    detachParams.setDetachFromOldStoragePool(true);
                    try {
                        runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                    } catch (EngineException e) {
                        log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                        throw e;
                    }
                }
                if (diskProfileDao.getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
                    createDefaultDiskProfile();
                }
            }
            runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
            final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = new ArrayList<>();
            if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                List<OvfEntityData> returnValueFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                unregisteredEntitiesFromOvfDisk.addAll(returnValueFromStorageOvfDisk);
            }
            List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
            executeInNewTransaction(() -> {
                final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                map.setStatus(StorageDomainStatus.Maintenance);
                storagePoolIsoMapDao.updateStatus(map.getId(), map.getStatus());
                if (sdType == StorageDomainType.Master) {
                    calcStoragePoolStatusByDomainsStatus();
                }
                if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                    registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                    // Update unregistered entities
                    for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                        unregisteredOVFDataDao.removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                        unregisteredOVFDataDao.saveOVFData(ovf);
                        log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                    }
                    initUnregisteredDisksToDB(getParameters().getStorageDomainId());
                }
                // upgrade the domain format to the storage pool format
                updateStorageDomainFormatIfNeeded(getStorageDomain());
                return null;
            });
            if (getParameters().getActivate()) {
                attemptToActivateDomain();
            }
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!validate(spValidator.exists()) || !initializeVds() || !checkStorageDomain()) {
        return false;
    }
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    if (!validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool())) {
        return false;
    }
    if (!spValidator.isNotInStatus(StoragePoolStatus.Uninitialized).isValid() && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        return failValidation(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    if (spValidator.isNotInStatus(StoragePoolStatus.Uninitialized).isValid()) {
        return checkMasterDomainIsUp();
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!validate(spValidator.exists()) || !initializeVds() || !checkStorageDomain()) {
        return false;
    }
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    if (!validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool())) {
        return false;
    }
    if (!spValidator.isNotInStatus(StoragePoolStatus.Uninitialized).isValid() && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        return failValidation(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    if (getStorageDomain().getStorageType().isManagedBlockStorage() && !FeatureSupported.isManagedBlockDomainSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_ACTIVATE_MANAGED_BLOCK_STORAGE_DOMAIN);
    }
    if (spValidator.isNotInStatus(StoragePoolStatus.Uninitialized).isValid()) {
        return checkMasterDomainIsUp();
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM vm = getVm();
    if (vm == null) {
        return;
    }
    /*VM nextRunVm = getNextRunVmConfiguration();
        if (nextRunVm != null) {
            vm.setCustomCompatibilityVersion(nextRunVm.getCustomCompatibilityVersion());
        }*/
    updateVMDetails(vm);
    getQueryReturnValue().setReturnValue(vm);
}
#method_after
@Override
protected void executeQueryCommand() {
    VM vm = getVm();
    if (vm == null) {
        return;
    }
    VM nextRunVm = getNextRunVmConfiguration();
    if (nextRunVm != null) {
        vm.setCustomCompatibilityVersion(nextRunVm.getCustomCompatibilityVersion());
    }
    updateVMDetails(vm);
    getQueryReturnValue().setReturnValue(vm);
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage");
    validateRange("nfs_timeio", storageDomain.getStorage().getNfsTimeo(), 0, 65535);
    validateRange("nfs_retrans", storageDomain.getStorage().getNfsRetrans(), 0, 65535);
    HostStorage storageConnectionFromUser = storageDomain.getStorage();
    Guid hostId = getHostId(storageDomain);
    StorageServerConnections cnx = null;
    if (!storageConnectionFromUser.isSetId()) {
        validateParameters(storageDomain, "storage.type");
        cnx = mapToCnx(storageDomain);
        if (cnx.getStorageType().isFileDomain()) {
            validateParameters(storageConnectionFromUser, "path");
        }
    } else {
        cnx = getStorageServerConnection(storageConnectionFromUser.getId());
        storageDomain.getStorage().setType(mapType(cnx.getStorageType()));
    }
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Response resp = null;
    switch(entity.getStorageType()) {
        case ISCSI:
        case FCP:
            if (storageDomain.isSetImport() && storageDomain.isImport()) {
                validateParameters(storageDomain, "id");
                resp = addExistingSAN(storageDomain, entity.getStorageType(), hostId);
            } else {
                resp = addSAN(storageDomain, entity.getStorageType(), entity, hostId);
            }
            break;
        case NFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "address");
            }
            resp = addDomain(ActionType.AddNFSStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case LOCALFS:
            resp = addDomain(ActionType.AddLocalStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case POSIXFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(ActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case GLUSTERFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(ActionType.AddGlusterFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case STORAGE_OFFLOAD:
            resp = addDomain(ActionType.AddCinderStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        default:
            break;
    }
    if (resp != null) {
        addLinks((StorageDomain) resp.getEntity(), getLinksToExclude(storageDomain));
    }
    return resp;
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage");
    validateRange("nfs_timeio", storageDomain.getStorage().getNfsTimeo(), 0, 65535);
    validateRange("nfs_retrans", storageDomain.getStorage().getNfsRetrans(), 0, 65535);
    HostStorage storageConnectionFromUser = storageDomain.getStorage();
    Guid hostId = getHostId(storageDomain);
    StorageServerConnections cnx = null;
    if (!storageConnectionFromUser.isSetId()) {
        validateParameters(storageDomain, "storage.type");
        cnx = mapToCnx(storageDomain);
        if (cnx.getStorageType().isFileDomain()) {
            validateParameters(storageConnectionFromUser, "path");
        }
    } else {
        cnx = getStorageServerConnection(storageConnectionFromUser.getId());
        storageDomain.getStorage().setType(mapType(cnx.getStorageType()));
    }
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Response resp = null;
    switch(entity.getStorageType()) {
        case ISCSI:
        case FCP:
            if (storageDomain.isSetImport() && storageDomain.isImport()) {
                validateParameters(storageDomain, "id");
                resp = addExistingSAN(storageDomain, entity.getStorageType(), hostId);
            } else {
                resp = addSAN(storageDomain, entity.getStorageType(), entity, hostId);
            }
            break;
        case NFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "address");
            }
            resp = addDomain(ActionType.AddNFSStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case LOCALFS:
            resp = addDomain(ActionType.AddLocalStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case POSIXFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(ActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case GLUSTERFS:
            if (!storageConnectionFromUser.isSetId()) {
                validateParameters(storageDomain.getStorage(), "vfsType");
            }
            resp = addDomain(ActionType.AddGlusterFsStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        case MANAGED_BLOCK_STORAGE:
            resp = addDomain(ActionType.AddManagedBlockStorageDomain, storageDomain, entity, hostId, cnx);
            break;
        default:
            break;
    }
    if (resp != null) {
        addLinks((StorageDomain) resp.getEntity(), getLinksToExclude(storageDomain));
    }
    return resp;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CinderStorage storage) {
    return getCustomMapSqlParameterSource().addValue("id", storage.getId()).addValue("driver_options", storage.getDriverOptions());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(ManagedBlockStorage storage) {
    return createIdParameterMapper(storage.getId()).addValue("driver_options", ObjectUtils.mapNullable(storage.getDriverOptions(), JsonHelper::mapToJsonUnchecked));
}
#end_block

#method_before
@Override
protected RowMapper<CinderStorage> createEntityRowMapper() {
    return cinderStorageDomainStaticRowMapper;
}
#method_after
@Override
protected RowMapper<ManagedBlockStorage> createEntityRowMapper() {
    return cinderStorageDomainStaticRowMapper;
}
#end_block

#method_before
@Test
public void testIsFileDomain() {
    assertFalse(StorageType.FCP.isFileDomain());
    assertFalse(StorageType.ISCSI.isFileDomain());
    assertTrue(StorageType.NFS.isFileDomain());
    assertTrue(StorageType.LOCALFS.isFileDomain());
    assertTrue(StorageType.POSIXFS.isFileDomain());
    assertTrue(StorageType.GLUSTERFS.isFileDomain());
    assertTrue(StorageType.GLANCE.isFileDomain());
    assertFalse(StorageType.CINDER.isFileDomain());
    assertFalse(StorageType.STORAGE_OFFLOAD.isFileDomain());
}
#method_after
@Test
public void testIsFileDomain() {
    assertFalse(StorageType.FCP.isFileDomain());
    assertFalse(StorageType.ISCSI.isFileDomain());
    assertTrue(StorageType.NFS.isFileDomain());
    assertTrue(StorageType.LOCALFS.isFileDomain());
    assertTrue(StorageType.POSIXFS.isFileDomain());
    assertTrue(StorageType.GLUSTERFS.isFileDomain());
    assertTrue(StorageType.GLANCE.isFileDomain());
    assertFalse(StorageType.CINDER.isFileDomain());
    assertFalse(StorageType.MANAGED_BLOCK_STORAGE.isFileDomain());
}
#end_block

#method_before
@Test
public void testIsBlockDomain() {
    assertTrue(StorageType.FCP.isBlockDomain());
    assertTrue(StorageType.ISCSI.isBlockDomain());
    assertFalse(StorageType.NFS.isBlockDomain());
    assertFalse(StorageType.LOCALFS.isBlockDomain());
    assertFalse(StorageType.POSIXFS.isBlockDomain());
    assertFalse(StorageType.GLUSTERFS.isBlockDomain());
    assertFalse(StorageType.GLANCE.isBlockDomain());
    assertFalse(StorageType.CINDER.isBlockDomain());
    assertFalse(StorageType.STORAGE_OFFLOAD.isBlockDomain());
}
#method_after
@Test
public void testIsBlockDomain() {
    assertTrue(StorageType.FCP.isBlockDomain());
    assertTrue(StorageType.ISCSI.isBlockDomain());
    assertFalse(StorageType.NFS.isBlockDomain());
    assertFalse(StorageType.LOCALFS.isBlockDomain());
    assertFalse(StorageType.POSIXFS.isBlockDomain());
    assertFalse(StorageType.GLUSTERFS.isBlockDomain());
    assertFalse(StorageType.GLANCE.isBlockDomain());
    assertFalse(StorageType.CINDER.isBlockDomain());
    assertFalse(StorageType.MANAGED_BLOCK_STORAGE.isBlockDomain());
}
#end_block

#method_before
@Test
public void testNewStorageTypes() {
    assertEquals(9, StorageType.values().length, "A storage type was added/removed. Update this test, and the isFileDomain/isBlockDomain " + "method accordingly");
}
#method_after
@Test
public void testNewStorageTypes() {
    assertEquals(10, StorageType.values().length, "A storage type was added/removed. Update this test, and the isFileDomain/isBlockDomain " + "method accordingly");
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setClusterId(getClusterId(host));
    BackendExternalProviderHelper.completeExternalNetworkProviderConfigurations(this, host.getExternalNetworkProviderConfigurations());
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    addParams.setHostedEngineDeployConfiguration(HostResourceParametersUtil.getHostedEngineDeployConfiguration(this));
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, addParams);
    boolean activate = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, ACTIVATE, true, true);
    addParams.setPreventActivation(!activate);
    return performCreate(ActionType.AddVds, addParams, new QueryIdResolver<Guid>(QueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setClusterId(getClusterId(host));
    BackendExternalProviderHelper.completeExternalNetworkProviderConfigurations(this, host.getExternalNetworkProviderConfigurations());
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    addParams.setHostedEngineDeployConfiguration(HostResourceParametersUtil.getHostedEngineDeployConfiguration(this));
    addParams = (AddVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(host, addParams);
    // default value for 'activate' is true
    boolean activate = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, ACTIVATE, true, true);
    addParams.setActivateHost(activate);
    return performCreate(ActionType.AddVds, addParams, new QueryIdResolver<Guid>(QueryType.GetVdsByVdsId, IdQueryParameters.class));
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    host.setVgpuPlacement(model.getVgpuPlacement().getValue());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        parameters.setPreventActivation(!model.getActivateHostAfterInstall().getIsSelected());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    host.setVgpuPlacement(model.getVgpuPlacement().getValue());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    host.setKernelCmdlineFips(model.getKernelCmdlineFips().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        parameters.setActivateHost(model.getActivateHostAfterInstall().getEntity());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
private void onApproveInternal() {
    HostModel model = (HostModel) getWindow();
    VDS vds = getSelectedItem();
    ApproveVdsParameters params = new ApproveVdsParameters(vds.getId());
    if (model.getUserPassword().getEntity() != null) {
        params.setPassword(model.getUserPassword().getEntity().toString());
    }
    params.setAuthMethod(model.getAuthenticationMethod());
    Frontend.getInstance().runMultipleAction(ActionType.ApproveVds, new ArrayList<>(Arrays.asList(new ActionParametersBase[] { params })), result -> {
    }, null);
}
#method_after
private void onApproveInternal() {
    HostModel model = (HostModel) getWindow();
    VDS vds = getSelectedItem();
    ApproveVdsParameters params = new ApproveVdsParameters(vds.getId());
    if (model.getUserPassword().getEntity() != null) {
        params.setPassword(model.getUserPassword().getEntity().toString());
    }
    params.setAuthMethod(model.getAuthenticationMethod());
    params.setActivateHost(model.getActivateHostAfterInstall().getEntity());
    Frontend.getInstance().runMultipleAction(ActionType.ApproveVds, new ArrayList<>(Arrays.asList(new ActionParametersBase[] { params })), result -> {
    }, null);
}
#end_block

#method_before
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false, null);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(cluster -> {
            if (cluster != null) {
                maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService(), clusterId);
            }
        }), clusterId);
    }
}
#method_after
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, null);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(cluster -> {
            if (cluster != null) {
                maintenance(cluster.supportsGlusterService(), clusterId);
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void maintenance(boolean isMaintenanceReasonVisible, boolean supportsGlusterService, Guid clusterId) {
    if (getConfirmWindow() != null) {
        return;
    }
    HostMaintenanceConfirmationModel model = new HostMaintenanceConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (supportsGlusterService) {
        model.getStopGlusterServices().setIsAvailable(true);
        model.getStopGlusterServices().setEntity(false);
        model.getForce().setIsAvailable(true);
        model.getForce().setEntity(false);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreGlusterQuorumChecks());
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    List<String> vdssNames = getSelectedItems().stream().map(d -> d.getName()).collect(Collectors.toList());
    List<Guid> vdssIds = getSelectedItems().stream().map(d -> d.getId()).collect(Collectors.toList());
    model.setItems(vdssNames);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
    // Display existence of pinned/hp VMs warning notification
    if (clusterId != null) {
        AsyncDataProvider.getInstance().getAllVmsRunningForMultipleVds(new AsyncQuery<>(vdsToVmsMap -> {
            if (!vdsToVmsMap.isEmpty()) {
                displayPinnedVmsInfoMsg(model, clusterId, vdsToVmsMap);
            }
        }), vdssIds);
    }
}
#method_after
private void maintenance(boolean supportsGlusterService, Guid clusterId) {
    if (getConfirmWindow() != null) {
        return;
    }
    HostMaintenanceConfirmationModel model = new HostMaintenanceConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    if (supportsGlusterService) {
        model.getStopGlusterServices().setIsAvailable(true);
        model.getStopGlusterServices().setEntity(false);
        model.getForce().setIsAvailable(true);
        model.getForce().setEntity(false);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreGlusterQuorumChecks());
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    List<String> vdssNames = getSelectedItems().stream().map(d -> d.getName()).collect(Collectors.toList());
    List<Guid> vdssIds = getSelectedItems().stream().map(d -> d.getId()).collect(Collectors.toList());
    model.setItems(vdssNames);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
    // Display existence of pinned/hp VMs warning notification
    if (clusterId != null) {
        AsyncDataProvider.getInstance().getAllVmsRunningForMultipleVds(new AsyncQuery<>(vdsToVmsMap -> {
            if (!vdsToVmsMap.isEmpty()) {
                displayPinnedVmsInfoMsg(model, clusterId, vdsToVmsMap);
            }
        }), vdssIds);
    }
}
#end_block

#method_before
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        Cluster hostCluster = clusterDao.get(getClusterId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(hostCluster.getCompatibilityVersion()), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = providerDao.get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        FirewallType hostFirewallType = hostCluster.getFirewallType();
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit(hostFirewallType.equals(FirewallType.IPTABLES)));
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        if (MapUtils.isNotEmpty(parameters.getHostedEngineConfiguration())) {
            deploy.addUnit(new VdsDeployHostedEngineUnit(parameters.getHostedEngineConfiguration()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                markCurrentCmdlineAsStored();
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                // TODO: When more logic goes to ovirt-host-deploy role,
                // this code should be moved to appropriate place, currently
                // we run this playbook only after successful run of otopi host-deploy
                runAnsibleHostDeployPlaybook(hostCluster);
                configureManagementNetwork();
                if ((getParameters().isPreventActivation()) || (!getParameters().getActivateHost() && VDSStatus.Maintenance.equals(vdsInitialStatus))) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#method_after
private void installHost() {
    try (final VdsDeploy deploy = new VdsDeploy("ovirt-host-deploy", getVds(), true)) {
        log.info("Before Installation host {}, {}", getVds().getId(), getVds().getName());
        T parameters = getParameters();
        deploy.setCorrelationId(getCorrelationId());
        Cluster hostCluster = clusterDao.get(getClusterId());
        deploy.addUnit(new VdsDeployMiscUnit(), new VdsDeployVdsmUnit(hostCluster.getCompatibilityVersion()), new VdsDeployPKIUnit(), new VdsDeployKdumpUnit(), new VdsDeployKernelUnit());
        if (parameters.getNetworkProviderId() != null) {
            Provider<?> provider = providerDao.get(parameters.getNetworkProviderId());
            if (provider.getType() == ProviderType.OPENSTACK_NETWORK) {
                OpenstackNetworkProviderProperties agentProperties = (OpenstackNetworkProviderProperties) provider.getAdditionalProperties();
                if (StringUtils.isNotBlank(parameters.getNetworkMappings())) {
                    agentProperties.getAgentConfiguration().setNetworkMappings(parameters.getNetworkMappings());
                }
                deploy.addUnit(new VdsDeployOpenStackUnit(agentProperties));
            }
        }
        FirewallType hostFirewallType = hostCluster.getFirewallType();
        if (parameters.getOverrideFirewall()) {
            switch(getVds().getVdsType()) {
                case VDS:
                case oVirtNode:
                    deploy.addUnit(new VdsDeployIptablesUnit(hostFirewallType.equals(FirewallType.IPTABLES)));
                    break;
                case oVirtVintageNode:
                    log.warn("Installation of Host {} will ignore Firewall Override option, since it is not supported for Host type {}", getVds().getName(), getVds().getVdsType().name());
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
        }
        if (parameters.getEnableSerialConsole()) {
            deploy.addUnit(new VdsDeployVmconsoleUnit());
        }
        if (MapUtils.isNotEmpty(parameters.getHostedEngineConfiguration())) {
            deploy.addUnit(new VdsDeployHostedEngineUnit(parameters.getHostedEngineConfiguration()));
        }
        switch(getParameters().getAuthMethod()) {
            case Password:
                deploy.setPassword(parameters.getPassword());
                break;
            case PublicKey:
                deploy.useDefaultKeyPair();
                break;
            default:
                throw new Exception("Invalid authentication method value was sent to InstallVdsInternalCommand");
        }
        setVdsStatus(VDSStatus.Installing);
        deploy.execute();
        switch(deploy.getDeployStatus()) {
            case Failed:
                throw new VdsInstallException(VDSStatus.InstallFailed, StringUtils.EMPTY);
            case Incomplete:
                markCurrentCmdlineAsStored();
                throw new VdsInstallException(VDSStatus.InstallFailed, "Partial installation");
            case Reboot:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                setVdsStatus(VDSStatus.Reboot);
                runSleepOnReboot(getStatusOnReboot());
                break;
            case Complete:
                markCurrentCmdlineAsStored();
                markVdsReinstalled();
                // TODO: When more logic goes to ovirt-host-deploy role,
                // this code should be moved to appropriate place, currently
                // we run this playbook only after successful run of otopi host-deploy
                runAnsibleHostDeployPlaybook(hostCluster);
                configureManagementNetwork();
                if (!getParameters().getActivateHost()) {
                    setVdsStatus(VDSStatus.Maintenance);
                } else {
                    setVdsStatus(VDSStatus.Initializing);
                }
                break;
        }
        log.info("After Installation host {}, {}", getVds().getName(), getVds().getVdsType().name());
        setSucceeded(true);
    } catch (VdsInstallException e) {
        handleError(e, e.getStatus());
    } catch (Exception e) {
        handleError(e, VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    activateHostAfterInstallEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        @Override
        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<Provider.AdditionalProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    rbProvisionedHost = new EntityModelRadioButtonEditor("2");
    kernelCmdlineBlacklistNouveau = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    consoleAddressEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    vgpuConsolidatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    vgpuSeparatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    activateHostAfterInstallEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        @Override
        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<Provider.AdditionalProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    rbProvisionedHost = new EntityModelRadioButtonEditor("2");
    kernelCmdlineBlacklistNouveau = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineFips = new EntityModelCheckBoxEditor(Align.RIGHT);
    consoleAddressEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    vgpuConsolidatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    vgpuSeparatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#end_block

#method_before
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressLabel.setText(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    activateHostAfterInstallEditor.setLabel(constants.activateHostAfterInstallLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    // Console and GPU tab
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    // Info icons
    kernelCmdlineUnsafeInterruptsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineUnsafeInterruptsInfoIcon()));
    kernelCmdlineBlacklistNouveauInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineBlacklistNouveauInfoIcon()));
    kernelCmdlineIommuInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineIommuInfoIcon()));
    kernelCmdlineKvmNestedInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineKvmNestedInfoIcon()));
    kernelCmdlinePciReallocInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlinePciReallocInfoIcon()));
    kernelCmdlineInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineInfoIcon()));
    // Affinity Labels Tab
    affinityLabelsTab.setLabel(constants.affinityLabels());
}
#method_after
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    hostAddressLabel.setText(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    activateHostAfterInstallEditor.setLabel(constants.activateHostAfterInstallLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    // Console and GPU tab
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    // Info icons
    kernelCmdlineUnsafeInterruptsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineUnsafeInterruptsInfoIcon()));
    kernelCmdlineBlacklistNouveauInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineBlacklistNouveauInfoIcon()));
    kernelCmdlineIommuInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineIommuInfoIcon()));
    kernelCmdlineKvmNestedInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineKvmNestedInfoIcon()));
    kernelCmdlinePciReallocInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlinePciReallocInfoIcon()));
    kernelCmdlineFipsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineFipsInfoIcon()));
    kernelCmdlineInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineInfoIcon()));
    // Affinity Labels Tab
    affinityLabelsTab.setLabel(constants.affinityLabels());
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    // ==Power Management Tab==
    nextTabIndex = powerManagementTab.setTabIndexes(nextTabIndex);
    pmEnabledEditor.setTabIndex(nextTabIndex++);
    pmKdumpDetectionEditor.setTabIndex(nextTabIndex++);
    disableAutomaticPowerManagementEditor.setTabIndex(nextTabIndex++);
    fenceAgentsEditor.setTabIndexes(nextTabIndex++);
    pmExpander.setTabIndexes(nextTabIndex);
    proxySourceEditor.setTabIndexes(nextTabIndex++);
    // ==SPM Tab==
    nextTabIndex = spmTab.setTabIndexes(nextTabIndex);
    // ==Console and GPU Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    consoleAddressEnabled.setTabIndex(nextTabIndex++);
    consoleAddress.setTabIndex(nextTabIndex++);
    vgpuConsolidatedPlacementEditor.setTabIndex(nextTabIndex++);
    vgpuSeparatedPlacementEditor.setTabIndex(nextTabIndex++);
    // ==Kernel Tab==
    nextTabIndex = kernelTab.setTabIndexes(nextTabIndex);
    kernelCmdlineBlacklistNouveau.setTabIndex(nextTabIndex++);
    kernelCmdlineIommu.setTabIndex(nextTabIndex++);
    kernelCmdlineKvmNested.setTabIndex(nextTabIndex++);
    kernelCmdlineUnsafeInterrupts.setTabIndex(nextTabIndex++);
    kernelCmdlinePciRealloc.setTabIndex(nextTabIndex++);
    kernelCmdlineText.setTabIndex(nextTabIndex++);
    // ==Hosted Engine Tab==
    nextTabIndex = hostedEngineTab.setTabIndexes(nextTabIndex);
    hostedEngineDeployActionsEditor.setTabIndex(nextTabIndex++);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    // ==Power Management Tab==
    nextTabIndex = powerManagementTab.setTabIndexes(nextTabIndex);
    pmEnabledEditor.setTabIndex(nextTabIndex++);
    pmKdumpDetectionEditor.setTabIndex(nextTabIndex++);
    disableAutomaticPowerManagementEditor.setTabIndex(nextTabIndex++);
    fenceAgentsEditor.setTabIndexes(nextTabIndex++);
    pmExpander.setTabIndexes(nextTabIndex);
    proxySourceEditor.setTabIndexes(nextTabIndex++);
    // ==SPM Tab==
    nextTabIndex = spmTab.setTabIndexes(nextTabIndex);
    // ==Console and GPU Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    consoleAddressEnabled.setTabIndex(nextTabIndex++);
    consoleAddress.setTabIndex(nextTabIndex++);
    vgpuConsolidatedPlacementEditor.setTabIndex(nextTabIndex++);
    vgpuSeparatedPlacementEditor.setTabIndex(nextTabIndex++);
    // ==Kernel Tab==
    nextTabIndex = kernelTab.setTabIndexes(nextTabIndex);
    kernelCmdlineIommu.setTabIndex(nextTabIndex++);
    kernelCmdlineKvmNested.setTabIndex(nextTabIndex++);
    kernelCmdlineUnsafeInterrupts.setTabIndex(nextTabIndex++);
    kernelCmdlinePciRealloc.setTabIndex(nextTabIndex++);
    kernelCmdlineBlacklistNouveau.setTabIndex(nextTabIndex++);
    kernelCmdlineFips.setTabIndex(nextTabIndex++);
    kernelCmdlineText.setTabIndex(nextTabIndex++);
    // ==Hosted Engine Tab==
    nextTabIndex = hostedEngineTab.setTabIndexes(nextTabIndex);
    hostedEngineDeployActionsEditor.setTabIndex(nextTabIndex++);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition) && (sender == getKernelCmdlineBlacklistNouveau() || sender == getKernelCmdlineIommu() || sender == getKernelCmdlineKvmNested() || sender == getKernelCmdlineUnsafeInterrupts() || sender == getKernelCmdlinePciRealloc())) {
        if (isKernelCmdlineParsable()) {
            updateKernelCmdlineAccordingToCheckboxes();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        dataCenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getCluster()) {
        cluster_SelectedItemChanged();
    } else if (sender == getConsoleAddressEnabled()) {
        consoleAddressChanged();
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition) && (sender == getKernelCmdlineBlacklistNouveau() || sender == getKernelCmdlineIommu() || sender == getKernelCmdlineKvmNested() || sender == getKernelCmdlineUnsafeInterrupts() || sender == getKernelCmdlinePciRealloc() || sender == getKernelCmdlineFips())) {
        if (isKernelCmdlineParsable()) {
            updateKernelCmdlineAccordingToCheckboxes();
        }
    }
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    setVgpuPlacement(VgpuPlacement.forValue(vds.getVgpuPlacement()));
    setVgpuPlacementChangeability(getCluster().getSelectedItem().getCompatibilityVersion());
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
}
#method_after
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    setVgpuPlacement(VgpuPlacement.forValue(vds.getVgpuPlacement()));
    setVgpuPlacementChangeability(getCluster().getSelectedItem().getCompatibilityVersion());
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
    getKernelCmdlineFips().setEntity(vds.isKernelCmdlineFips());
}
#end_block

#method_before
private void setKernelCmdlineCheckboxesChangeability(boolean changeable, String reason) {
    getKernelCmdlineBlacklistNouveau().setIsChangeable(changeable, reason);
    getKernelCmdlineIommu().setIsChangeable(changeable, reason);
    getKernelCmdlineKvmNested().setIsChangeable(changeable, reason);
    getKernelCmdlineUnsafeInterrupts().setIsChangeable(changeable, reason);
    getKernelCmdlinePciRealloc().setIsChangeable(changeable, reason);
}
#method_after
private void setKernelCmdlineCheckboxesChangeability(boolean changeable, String reason) {
    getKernelCmdlineBlacklistNouveau().setIsChangeable(changeable, reason);
    getKernelCmdlineIommu().setIsChangeable(changeable, reason);
    getKernelCmdlineKvmNested().setIsChangeable(changeable, reason);
    getKernelCmdlineUnsafeInterrupts().setIsChangeable(changeable, reason);
    getKernelCmdlinePciRealloc().setIsChangeable(changeable, reason);
    getKernelCmdlineFips().setIsChangeable(changeable, reason);
}
#end_block

#method_before
private void setKernelCmdlineCheckboxesValue(boolean checked) {
    getKernelCmdlineBlacklistNouveau().setEntity(checked);
    getKernelCmdlineIommu().setEntity(checked);
    getKernelCmdlineKvmNested().setEntity(checked);
    getKernelCmdlineUnsafeInterrupts().setEntity(checked);
    getKernelCmdlinePciRealloc().setEntity(checked);
}
#method_after
private void setKernelCmdlineCheckboxesValue(boolean checked) {
    getKernelCmdlineBlacklistNouveau().setEntity(checked);
    getKernelCmdlineIommu().setEntity(checked);
    getKernelCmdlineKvmNested().setEntity(checked);
    getKernelCmdlineUnsafeInterrupts().setEntity(checked);
    getKernelCmdlinePciRealloc().setEntity(checked);
    getKernelCmdlineFips().setEntity(checked);
}
#end_block

#method_before
private void addKernelCmdlineCheckboxesListeners() {
    getKernelCmdlineBlacklistNouveau().getEntityChangedEvent().addListener(this);
    getKernelCmdlineIommu().getEntityChangedEvent().addListener(this);
    getKernelCmdlineKvmNested().getEntityChangedEvent().addListener(this);
    getKernelCmdlineUnsafeInterrupts().getEntityChangedEvent().addListener(this);
    getKernelCmdlinePciRealloc().getEntityChangedEvent().addListener(this);
}
#method_after
private void addKernelCmdlineCheckboxesListeners() {
    getKernelCmdlineBlacklistNouveau().getEntityChangedEvent().addListener(this);
    getKernelCmdlineIommu().getEntityChangedEvent().addListener(this);
    getKernelCmdlineKvmNested().getEntityChangedEvent().addListener(this);
    getKernelCmdlineUnsafeInterrupts().getEntityChangedEvent().addListener(this);
    getKernelCmdlinePciRealloc().getEntityChangedEvent().addListener(this);
    getKernelCmdlineFips().getEntityChangedEvent().addListener(this);
}
#end_block

#method_before
private void updateKernelCmdlineAccordingToCheckboxes() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null || getKernelCmdlineBlacklistNouveau().getEntity() == null || getKernelCmdlineIommu().getEntity() == null || getKernelCmdlineKvmNested().getEntity() == null || getKernelCmdlineUnsafeInterrupts().getEntity() == null || getKernelCmdlinePciRealloc().getEntity() == null) {
        return;
    }
    final String kernelCmdline = KernelCmdlineUtil.create(cpuVendor, getKernelCmdlineBlacklistNouveau().getEntity(), getKernelCmdlineIommu().getEntity(), getKernelCmdlineKvmNested().getEntity(), getKernelCmdlineUnsafeInterrupts().getEntity(), getKernelCmdlinePciRealloc().getEntity());
    kernelCmdlineListener.whilePaused(() -> getKernelCmdline().setEntity(kernelCmdline));
}
#method_after
private void updateKernelCmdlineAccordingToCheckboxes() {
    final CpuVendor cpuVendor = getCurrentCpuVendor();
    if (cpuVendor == null || getKernelCmdlineBlacklistNouveau().getEntity() == null || getKernelCmdlineIommu().getEntity() == null || getKernelCmdlineKvmNested().getEntity() == null || getKernelCmdlineUnsafeInterrupts().getEntity() == null || getKernelCmdlinePciRealloc().getEntity() == null || getKernelCmdlineFips().getEntity() == null) {
        return;
    }
    final String kernelCmdline = KernelCmdlineUtil.create(cpuVendor, getKernelCmdlineBlacklistNouveau().getEntity(), getKernelCmdlineIommu().getEntity(), getKernelCmdlineKvmNested().getEntity(), getKernelCmdlineUnsafeInterrupts().getEntity(), getKernelCmdlinePciRealloc().getEntity(), getKernelCmdlineFips().getEntity());
    kernelCmdlineListener.whilePaused(() -> getKernelCmdline().setEntity(kernelCmdline));
}
#end_block

#method_before
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    boolean someSubTagSet = false;
    if (model.isSetHostName()) {
        someSubTagSet = true;
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        someSubTagSet = true;
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        someSubTagSet = true;
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        someSubTagSet = true;
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        someSubTagSet = true;
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        someSubTagSet = true;
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        someSubTagSet = true;
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        someSubTagSet = true;
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        someSubTagSet = true;
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        someSubTagSet = true;
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        someSubTagSet = true;
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        someSubTagSet = true;
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        someSubTagSet = true;
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        someSubTagSet = true;
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        someSubTagSet = true;
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        someSubTagSet = true;
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        someSubTagSet = true;
        entity.setActiveDirectoryOU(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        someSubTagSet = true;
        entity.setOrgName(model.getOrgName());
    }
    if (model.isSetCloudInit()) {
        someSubTagSet = true;
        VmMapper.map(model.getCloudInit(), entity);
    }
    if (model.isSetCloudInitProtocol()) {
        someSubTagSet = true;
        entity.setCloudInitProtocol(map(model.getCloudInitProtocol()));
    } else {
        // default value in case none supplied in request
        entity.setCloudInitProtocol(map(OPENSTACK_METADATA));
    }
    if (!someSubTagSet) {
        return null;
    }
    return entity;
}
#method_after
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    boolean someSubTagSet = false;
    if (model.isSetHostName()) {
        someSubTagSet = true;
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        someSubTagSet = true;
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        someSubTagSet = true;
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        someSubTagSet = true;
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        someSubTagSet = true;
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        someSubTagSet = true;
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        someSubTagSet = true;
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        someSubTagSet = true;
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        someSubTagSet = true;
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        someSubTagSet = true;
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        someSubTagSet = true;
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        someSubTagSet = true;
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        someSubTagSet = true;
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        someSubTagSet = true;
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        someSubTagSet = true;
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        someSubTagSet = true;
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        someSubTagSet = true;
        entity.setActiveDirectoryOU(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        someSubTagSet = true;
        entity.setOrgName(model.getOrgName());
    }
    if (model.isSetCloudInit()) {
        someSubTagSet = true;
        VmMapper.map(model.getCloudInit(), entity);
    }
    if (model.isSetCloudInitNetworkProtocol()) {
        someSubTagSet = true;
        entity.setCloudInitNetworkProtocol(map(model.getCloudInitNetworkProtocol()));
    }
    if (!someSubTagSet) {
        return null;
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VmInit.class, to = Initialization.class)
public static Initialization map(VmInit entity, Initialization template) {
    Initialization model = template != null ? template : new Initialization();
    if (entity.getHostname() != null) {
        model.setHostName(entity.getHostname());
    }
    if (StringUtils.isNotBlank(entity.getDomain())) {
        model.setDomain(entity.getDomain());
    }
    if (entity.getTimeZone() != null) {
        model.setTimezone(entity.getTimeZone());
    }
    if (entity.getAuthorizedKeys() != null) {
        model.setAuthorizedSshKeys(entity.getAuthorizedKeys());
    }
    if (entity.getRegenerateKeys() != null) {
        model.setRegenerateSshKeys(entity.getRegenerateKeys());
    }
    if (entity.getDnsServers() != null) {
        model.setDnsServers(entity.getDnsServers());
    }
    if (entity.getDnsSearch() != null) {
        model.setDnsSearch(entity.getDnsSearch());
    }
    if (entity.getWinKey() != null) {
        model.setWindowsLicenseKey(entity.getWinKey());
    }
    if (entity.getRootPassword() != null || entity.isPasswordAlreadyStored()) {
        model.setRootPassword("******");
    }
    if (entity.getCustomScript() != null) {
        model.setCustomScript(entity.getCustomScript());
    }
    if (entity.getNetworks() != null) {
        model.setNicConfigurations(new NicConfigurations());
        for (VmInitNetwork network : entity.getNetworks()) {
            model.getNicConfigurations().getNicConfigurations().add(map(network, null));
        }
    }
    if (entity.getInputLocale() != null) {
        model.setInputLocale(entity.getInputLocale());
    }
    if (entity.getUiLanguage() != null) {
        model.setUiLanguage(entity.getUiLanguage());
    }
    if (entity.getSystemLocale() != null) {
        model.setSystemLocale(entity.getSystemLocale());
    }
    if (entity.getUserLocale() != null) {
        model.setUserLocale(entity.getUserLocale());
    }
    if (entity.getUserName() != null) {
        model.setUserName(entity.getUserName());
    }
    if (entity.getActiveDirectoryOU() != null) {
        model.setActiveDirectoryOu(entity.getActiveDirectoryOU());
    }
    if (entity.getOrgName() != null) {
        model.setOrgName(entity.getOrgName());
    }
    if (entity.getCloudInitProtocol() != null) {
        model.setCloudInitProtocol(map(entity.getCloudInitProtocol()));
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.CloudInitNetworkProtocol.class, to = CloudInitNetworkProtocol.class)
public static CloudInitNetworkProtocol map(org.ovirt.engine.api.model.CloudInitNetworkProtocol protocol) {
    switch(protocol) {
        case ENI:
            return CloudInitNetworkProtocol.ENI;
        case OPENSTACK_METADATA:
            return CloudInitNetworkProtocol.OPENSTACK_METADATA;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmInit.class, to = Initialization.class)
public static Initialization map(VmInit entity, Initialization template) {
    Initialization model = template != null ? template : new Initialization();
    if (entity.getHostname() != null) {
        model.setHostName(entity.getHostname());
    }
    if (StringUtils.isNotBlank(entity.getDomain())) {
        model.setDomain(entity.getDomain());
    }
    if (entity.getTimeZone() != null) {
        model.setTimezone(entity.getTimeZone());
    }
    if (entity.getAuthorizedKeys() != null) {
        model.setAuthorizedSshKeys(entity.getAuthorizedKeys());
    }
    if (entity.getRegenerateKeys() != null) {
        model.setRegenerateSshKeys(entity.getRegenerateKeys());
    }
    if (entity.getDnsServers() != null) {
        model.setDnsServers(entity.getDnsServers());
    }
    if (entity.getDnsSearch() != null) {
        model.setDnsSearch(entity.getDnsSearch());
    }
    if (entity.getWinKey() != null) {
        model.setWindowsLicenseKey(entity.getWinKey());
    }
    if (entity.getRootPassword() != null || entity.isPasswordAlreadyStored()) {
        model.setRootPassword("******");
    }
    if (entity.getCustomScript() != null) {
        model.setCustomScript(entity.getCustomScript());
    }
    if (entity.getNetworks() != null) {
        model.setNicConfigurations(new NicConfigurations());
        for (VmInitNetwork network : entity.getNetworks()) {
            model.getNicConfigurations().getNicConfigurations().add(map(network, null));
        }
    }
    if (entity.getInputLocale() != null) {
        model.setInputLocale(entity.getInputLocale());
    }
    if (entity.getUiLanguage() != null) {
        model.setUiLanguage(entity.getUiLanguage());
    }
    if (entity.getSystemLocale() != null) {
        model.setSystemLocale(entity.getSystemLocale());
    }
    if (entity.getUserLocale() != null) {
        model.setUserLocale(entity.getUserLocale());
    }
    if (entity.getUserName() != null) {
        model.setUserName(entity.getUserName());
    }
    if (entity.getActiveDirectoryOU() != null) {
        model.setActiveDirectoryOu(entity.getActiveDirectoryOU());
    }
    if (entity.getOrgName() != null) {
        model.setOrgName(entity.getOrgName());
    }
    if (entity.getCloudInitProtocol() != null) {
        model.setCloudInitProtocol(map(entity.getCloudInitProtocol()));
    }
    return model;
}
#method_after
@Mapping(from = VmInit.class, to = Initialization.class)
public static Initialization map(VmInit entity, Initialization template) {
    Initialization model = template != null ? template : new Initialization();
    if (entity.getHostname() != null) {
        model.setHostName(entity.getHostname());
    }
    if (StringUtils.isNotBlank(entity.getDomain())) {
        model.setDomain(entity.getDomain());
    }
    if (entity.getTimeZone() != null) {
        model.setTimezone(entity.getTimeZone());
    }
    if (entity.getAuthorizedKeys() != null) {
        model.setAuthorizedSshKeys(entity.getAuthorizedKeys());
    }
    if (entity.getRegenerateKeys() != null) {
        model.setRegenerateSshKeys(entity.getRegenerateKeys());
    }
    if (entity.getDnsServers() != null) {
        model.setDnsServers(entity.getDnsServers());
    }
    if (entity.getDnsSearch() != null) {
        model.setDnsSearch(entity.getDnsSearch());
    }
    if (entity.getWinKey() != null) {
        model.setWindowsLicenseKey(entity.getWinKey());
    }
    if (entity.getRootPassword() != null || entity.isPasswordAlreadyStored()) {
        model.setRootPassword("******");
    }
    if (entity.getCustomScript() != null) {
        model.setCustomScript(entity.getCustomScript());
    }
    if (entity.getNetworks() != null) {
        model.setNicConfigurations(new NicConfigurations());
        for (VmInitNetwork network : entity.getNetworks()) {
            model.getNicConfigurations().getNicConfigurations().add(map(network, null));
        }
    }
    if (entity.getInputLocale() != null) {
        model.setInputLocale(entity.getInputLocale());
    }
    if (entity.getUiLanguage() != null) {
        model.setUiLanguage(entity.getUiLanguage());
    }
    if (entity.getSystemLocale() != null) {
        model.setSystemLocale(entity.getSystemLocale());
    }
    if (entity.getUserLocale() != null) {
        model.setUserLocale(entity.getUserLocale());
    }
    if (entity.getUserName() != null) {
        model.setUserName(entity.getUserName());
    }
    if (entity.getActiveDirectoryOU() != null) {
        model.setActiveDirectoryOu(entity.getActiveDirectoryOU());
    }
    if (entity.getOrgName() != null) {
        model.setOrgName(entity.getOrgName());
    }
    if (entity.getCloudInitNetworkProtocol() != null) {
        model.setCloudInitNetworkProtocol(map(entity.getCloudInitNetworkProtocol()));
    }
    return model;
}
#end_block

#method_before
public List<EngineMessage> validate(VmInit vmInit) {
    // validate only if 'Initial Run' parameters were specified
    if (vmInit != null) {
        if (vmInit.getCloudInitNetworkProtocol() == null) {
            // if no value specified in request set default
            vmInit.setCloudInitNetworkProtocol(OPENSTACK_METADATA);
        }
        switch(vmInit.getCloudInitNetworkProtocol()) {
            case OPENSTACK_METADATA:
                return new VmInitToOpenStackMetadataAdapter().validate(vmInit);
            case ENI:
        }
    }
    return Collections.emptyList();
}
#method_after
public List<EngineMessage> validate(VmInit vmInit) {
    // and required payload network protocol is OpenstackMetadata
    if (vmInit != null && isOpenstackMetadataProtocol(vmInit)) {
        return new VmInitToOpenStackMetadataAdapter().validate(vmInit);
    }
    return Collections.emptyList();
}
#end_block

#method_before
public Map<String, byte[]> getFileData() throws UnsupportedEncodingException, IOException, JsonGenerationException, JsonMappingException {
    if (vmInit != null) {
        try {
            storeHostname();
            storeAuthorizedKeys();
            storeRegenerateKeys();
            storeNetwork();
            storeTimeZone();
            storeRootPassword();
            storeUserName();
        } catch (IllegalArgumentException ex) {
            throw new IllegalArgumentException("Malformed input", ex);
        }
    }
    // Add other required/supplemental data
    storeExecutionParameters();
    String metaDataStr = mapToJson(metaData);
    String userDataStr = mapToYaml(userData);
    String networkDataStr = !MapUtils.isEmpty(networkData) ? mapToJson(networkData) : "";
    if (vmInit != null && vmInit.getCustomScript() != null) {
        userDataStr += vmInit.getCustomScript();
    }
    // add #cloud-config for user data file head
    if (StringUtils.isNotBlank(userDataStr)) {
        userDataStr = "#cloud-config\n" + userDataStr;
    }
    files.put("openstack/latest/meta_data.json", metaDataStr.getBytes("UTF-8"));
    files.put("openstack/latest/user_data", userDataStr.getBytes("UTF-8"));
    if (isOpenstackMetadataProtocol() && !StringUtils.isEmpty(networkDataStr)) {
        // must not pass an empty file or a file with an empty json to cloud-init-0.7.9-9 because the whole init flow fails
        files.put("openstack/latest/network_data.json", networkDataStr.getBytes("UTF-8"));
    }
    // mask password for log if exists
    if (metaDataStr.contains(passwordKey) && vmInit != null && vmInit.getRootPassword() != null) {
        String oldStr = String.format("\"%s\" : \"%s\"", passwordKey, vmInit.getRootPassword());
        String newStr = String.format("\"%s\" : ***", passwordKey);
        metaDataStr = metaDataStr.replace(oldStr, newStr);
    }
    log.debug("cloud-init meta-data:\n{}", metaDataStr);
    log.debug("cloud-init user-data:\n{}", userDataStr);
    if (isOpenstackMetadataProtocol()) {
        log.debug("cloud-init network-data:\n{}", networkDataStr);
    }
    return files;
}
#method_after
public Map<String, byte[]> getFileData() throws UnsupportedEncodingException, IOException, JsonGenerationException, JsonMappingException {
    if (vmInit != null) {
        try {
            storeHostname();
            storeAuthorizedKeys();
            storeRegenerateKeys();
            storeNetwork();
            storeTimeZone();
            storeRootPassword();
            storeUserName();
        } catch (IllegalArgumentException ex) {
            throw new IllegalArgumentException("Malformed input", ex);
        }
    }
    // Add other required/supplemental data
    storeExecutionParameters();
    String metaDataStr = mapToJson(metaData);
    String userDataStr = mapToYaml(userData);
    String networkDataStr = !MapUtils.isEmpty(networkData) ? mapToJson(networkData) : "";
    if (vmInit != null && vmInit.getCustomScript() != null) {
        userDataStr += vmInit.getCustomScript();
    }
    // add #cloud-config for user data file head
    if (StringUtils.isNotBlank(userDataStr)) {
        userDataStr = "#cloud-config\n" + userDataStr;
    }
    files.put("openstack/latest/meta_data.json", metaDataStr.getBytes("UTF-8"));
    files.put("openstack/latest/user_data", userDataStr.getBytes("UTF-8"));
    if (!StringUtils.isEmpty(networkDataStr) && isOpenstackMetadataProtocol()) {
        // must not pass an empty file or a file with an empty json to cloud-init-0.7.9-9 because the whole init flow fails
        files.put("openstack/latest/network_data.json", networkDataStr.getBytes("UTF-8"));
        log.debug("cloud-init network_data.json:\n{}", networkDataStr);
    }
    // mask password for log if exists
    if (metaDataStr.contains(passwordKey) && vmInit != null && vmInit.getRootPassword() != null) {
        String oldStr = String.format("\"%s\" : \"%s\"", passwordKey, vmInit.getRootPassword());
        String newStr = String.format("\"%s\" : ***", passwordKey);
        metaDataStr = metaDataStr.replace(oldStr, newStr);
    }
    log.debug("cloud-init meta-data:\n{}", metaDataStr);
    log.debug("cloud-init user-data:\n{}", userDataStr);
    return files;
}
#end_block

#method_before
private boolean isOpenstackMetadataProtocol() {
    return OPENSTACK_METADATA.equals(vmInit.getCloudInitNetworkProtocol());
}
#method_after
private boolean isOpenstackMetadataProtocol() {
    return isOpenstackMetadataProtocol(vmInit);
}
#end_block

#method_before
private boolean isOpenstackMetadataProtocol() {
    return OPENSTACK_METADATA.equals(vmInit.getCloudInitNetworkProtocol());
}
#method_after
private boolean isOpenstackMetadataProtocol(VmInit vmInit) {
    return OPENSTACK_METADATA.equals(vmInit.getCloudInitNetworkProtocol());
}
#end_block

#method_before
private void storeNetworkAsEni() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            if (Boolean.TRUE.equals(iface.getStartOnBoot())) {
                output.append("auto ").append(iface.getName()).append("\n");
            }
            storeIpv4(iface, output);
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        // bugzilla.redhat.com/1464043:
        // muting configuration of IPv6 until a proper solution is found
        // storeIpv6(iface, output);
        }
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
}
#method_after
private void storeNetworkAsEni() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            if (Boolean.TRUE.equals(iface.getStartOnBoot())) {
                output.append("auto ").append(iface.getName()).append("\n");
            }
            storeIpv4(iface, output);
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        // bugzilla.redhat.com/1464043:
        // muting configuration of IPv6 until a proper solution is found
        // storeIpv6(iface, output);
        }
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
    log.debug("cloud-init network-interfaces:\n{}", interfaces);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    incrementDbGeneration();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        handleVmLease();
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    incrementDbGeneration();
    setSucceeded(true);
}
#end_block

#method_before
SshClient createSshClient() {
    return SshClient.setUpDefaultClient();
}
#method_after
SshClient createSshClient() {
    SshClient sshClient = SshClient.setUpDefaultClient();
    /*
         * FIXME: We need to enforce only RSA signatures, because all our code around fingerprints assumes only RSA
         * public keys. This limitation can be removed when we will save all available host public keys into database
         * and perform host key verification by comparing received key with keys in our database.
         */
    sshClient.setSignatureFactories(Arrays.<NamedFactory<Signature>>asList(BuiltinSignatures.rsa));
    return sshClient;
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, true);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(cluster -> {
            if (cluster != null) {
                powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        // is populated with the current reason so the user can edit it.
        if (stoppingSingleVM && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#method_after
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerActionBase(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#method_after
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerActionBase(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), false);
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, requiredSwitchTypeForCluster, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, additionalRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, clusterHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, maintenanceReasonRequired, ksmMergeAcrossNumaNodes, customMigrationNetworkBandwidth, migrationBandwidthLimitType, migrationPolicyId, macPoolId, firewallType, defaultNetworkProviderId, logMaxMemoryUsedThreshold, logMaxMemoryUsedThresholdType, vncEncryptionEnabled);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, requiredSwitchTypeForCluster, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, additionalRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, clusterHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, ksmMergeAcrossNumaNodes, customMigrationNetworkBandwidth, migrationBandwidthLimitType, migrationPolicyId, macPoolId, firewallType, defaultNetworkProviderId, logMaxMemoryUsedThreshold, logMaxMemoryUsedThresholdType, vncEncryptionEnabled);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && Objects.equals(requiredSwitchTypeForCluster, other.requiredSwitchTypeForCluster) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(clusterHostsAndVms, other.clusterHostsAndVms) && Objects.equals(additionalRngSources, other.additionalRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(maintenanceReasonRequired, other.maintenanceReasonRequired) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && Objects.equals(customMigrationNetworkBandwidth, other.customMigrationNetworkBandwidth) && Objects.equals(migrationBandwidthLimitType, other.migrationBandwidthLimitType) && Objects.equals(migrationPolicyId, other.migrationPolicyId) && Objects.equals(macPoolId, other.macPoolId) && Objects.equals(firewallType, other.firewallType) && Objects.equals(defaultNetworkProviderId, other.defaultNetworkProviderId) && Objects.equals(logMaxMemoryUsedThreshold, other.logMaxMemoryUsedThreshold) && logMaxMemoryUsedThresholdType == other.logMaxMemoryUsedThresholdType && vncEncryptionEnabled == other.vncEncryptionEnabled;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && Objects.equals(requiredSwitchTypeForCluster, other.requiredSwitchTypeForCluster) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(clusterHostsAndVms, other.clusterHostsAndVms) && Objects.equals(additionalRngSources, other.additionalRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && Objects.equals(customMigrationNetworkBandwidth, other.customMigrationNetworkBandwidth) && Objects.equals(migrationBandwidthLimitType, other.migrationBandwidthLimitType) && Objects.equals(migrationPolicyId, other.migrationPolicyId) && Objects.equals(macPoolId, other.macPoolId) && Objects.equals(firewallType, other.firewallType) && Objects.equals(defaultNetworkProviderId, other.defaultNetworkProviderId) && Objects.equals(logMaxMemoryUsedThreshold, other.logMaxMemoryUsedThreshold) && logMaxMemoryUsedThresholdType == other.logMaxMemoryUsedThresholdType && vncEncryptionEnabled == other.vncEncryptionEnabled;
}
#end_block

#method_before
@Override
public void edit(HostMaintenanceConfirmationModel object) {
    driver.edit(object);
    // Bind "Latch.IsAvailable"
    object.getLatch().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            EntityModel entity = (EntityModel) sender;
            if (entity.getIsAvailable()) {
                latch.setVisible(true);
            }
        }
    });
    if (object.getForceLabel() != null) {
        force.setLabel(object.getForceLabel());
    }
    force.asCheckBox().setValue(object.getForce().getEntity());
    // Bind "Force.Label"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("ForceLabel".equals(args.propertyName)) {
            // $NON-NLS-1$
            ConfirmationModel entity = (ConfirmationModel) sender;
            force.setLabel(entity.getForceLabel());
        }
    });
    setNote(object.getNote());
    // Bind "Note"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("Note".equals(args.propertyName)) {
            // $NON-NLS-1$
            ConfirmationModel entity = (ConfirmationModel) sender;
            setNote(entity.getNote());
        }
    });
    // Bind "ReasonVisible"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("ReasonVisible".equals(args.propertyName)) {
            // $NON-NLS-1$
            updateReasonVisibility((HostMaintenanceConfirmationModel) sender);
        }
    });
    // Bind "pinnedVMsInfoPanelVisible"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("pinnedVMsInfoPanelVisible".equals(args.propertyName)) {
            // $NON-NLS-1$
            updatePinnedVMsInfoVisibility((HostMaintenanceConfirmationModel) sender);
        }
    });
    setPinnedVMsInfoMessage(object.getPinnedVMsInfoMessage());
    // Bind "pinnedVMsInfoMessage"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("pinnedVMsInfoMessage".equals(args.propertyName)) {
            // $NON-NLS-1$
            HostMaintenanceConfirmationModel entity = (HostMaintenanceConfirmationModel) sender;
            setPinnedVMsInfoMessage(entity.getPinnedVMsInfoMessage());
        }
    });
}
#method_after
@Override
public void edit(HostMaintenanceConfirmationModel object) {
    driver.edit(object);
    // Bind "Latch.IsAvailable"
    object.getLatch().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            EntityModel entity = (EntityModel) sender;
            if (entity.getIsAvailable()) {
                latch.setVisible(true);
            }
        }
    });
    if (object.getForceLabel() != null) {
        force.setLabel(object.getForceLabel());
    }
    force.asCheckBox().setValue(object.getForce().getEntity());
    // Bind "Force.Label"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("ForceLabel".equals(args.propertyName)) {
            // $NON-NLS-1$
            ConfirmationModel entity = (ConfirmationModel) sender;
            force.setLabel(entity.getForceLabel());
        }
    });
    setNote(object.getNote());
    // Bind "Note"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("Note".equals(args.propertyName)) {
            // $NON-NLS-1$
            ConfirmationModel entity = (ConfirmationModel) sender;
            setNote(entity.getNote());
        }
    });
    // Bind "pinnedVMsInfoPanelVisible"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("pinnedVMsInfoPanelVisible".equals(args.propertyName)) {
            // $NON-NLS-1$
            updatePinnedVMsInfoVisibility((HostMaintenanceConfirmationModel) sender);
        }
    });
    setPinnedVMsInfoMessage(object.getPinnedVMsInfoMessage());
    // Bind "pinnedVMsInfoMessage"
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("pinnedVMsInfoMessage".equals(args.propertyName)) {
            // $NON-NLS-1$
            HostMaintenanceConfirmationModel entity = (HostMaintenanceConfirmationModel) sender;
            setPinnedVMsInfoMessage(entity.getPinnedVMsInfoMessage());
        }
    });
}
#end_block

#method_before
protected DestroyImageParameters buildDestroyImageParameters(Guid imageGroupId, List<Guid> imageList) {
    StorageDomain storageDomain = storageDomainDao.get(getParameters().getStorageDomainId());
    DestroyImageParameters parameters = new DestroyImageParameters(getVdsId(), getVmId(), getParameters().getStoragePoolId(), storageDomain.getId(), imageGroupId, imageList, storageDomain.getWipeAfterDelete(), false);
    parameters.setEndProcedure(ActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#method_after
protected DestroyImageParameters buildDestroyImageParameters(Guid imageGroupId, List<Guid> imageList) {
    StorageDomain storageDomain = getStorageDomain();
    DestroyImageParameters parameters = new DestroyImageParameters(getVdsId(), getVmId(), getParameters().getStoragePoolId(), storageDomain.getId(), imageGroupId, imageList, storageDomain.getWipeAfterDelete(), false);
    parameters.setEndProcedure(ActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#end_block

#method_before
public static String create(CpuVendor cpuVendor, boolean blacklistNouveau, boolean iommu, boolean kvmNested, boolean unsafeInterrupts, boolean pciRealloc, boolean fips) {
    StringBuilder cmdlineBuilder = new StringBuilder();
    cmdlineBuilder.append(getBlacklistNouveau(cpuVendor, blacklistNouveau));
    cmdlineBuilder.append(getIommu(cpuVendor, iommu));
    cmdlineBuilder.append(getKvmNested(cpuVendor, kvmNested));
    cmdlineBuilder.append(getUnsafeInterrupts(cpuVendor, unsafeInterrupts));
    cmdlineBuilder.append(getPciRealloc(cpuVendor, pciRealloc));
    cmdlineBuilder.append(getFips(cpuVendor, fips));
    return cmdlineBuilder.toString().trim();
}
#method_after
public static String create(CpuVendor cpuVendor, boolean blacklistNouveau, boolean iommu, boolean kvmNested, boolean unsafeInterrupts, boolean pciRealloc, boolean fips) {
    StringBuilder cmdlineBuilder = new StringBuilder();
    cmdlineBuilder.append(getBlacklistNouveau(cpuVendor, blacklistNouveau));
    cmdlineBuilder.append(getIommu(cpuVendor, iommu));
    cmdlineBuilder.append(getKvmNested(cpuVendor, kvmNested));
    cmdlineBuilder.append(getUnsafeInterrupts(cpuVendor, unsafeInterrupts));
    cmdlineBuilder.append(getPciRealloc(cpuVendor, pciRealloc));
    cmdlineBuilder.append(getFips(fips));
    return cmdlineBuilder.toString().trim();
}
#end_block

#method_before
private static String getFips(CpuVendor cpuVendor, boolean pciRealloc) {
    if (!pciRealloc) {
        return "";
    }
    switch(cpuVendor) {
        case AMD:
        case INTEL:
            // $NON-NLS-1$
            return "fips=1 ";
        case IBM:
        case IBMS390:
            return "";
        default:
            // $NON-NLS-1$
            throw new RuntimeException("Unknown CpuType: " + cpuVendor);
    }
}
#method_after
private static String getFips(boolean fips) {
    if (!fips) {
        return "";
    }
    // $NON-NLS-1$
    return "fips=1 ";
}
#end_block

#method_before
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(cluster -> {
            if (cluster != null) {
                maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
            }
        }), clusterId);
    }
}
#method_after
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false, null);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(cluster -> {
            if (cluster != null) {
                maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService(), clusterId);
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void maintenance(boolean isMaintenanceReasonVisible, boolean supportsGlusterService) {
    if (getConfirmWindow() != null) {
        return;
    }
    HostMaintenanceConfirmationModel model = new HostMaintenanceConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (supportsGlusterService) {
        model.getStopGlusterServices().setIsAvailable(true);
        model.getStopGlusterServices().setEntity(false);
        model.getForce().setIsAvailable(true);
        model.getForce().setEntity(false);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreGlusterQuorumChecks());
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getName());
    }
    model.setItems(vdss);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void maintenance(boolean isMaintenanceReasonVisible, boolean supportsGlusterService, Guid clusterId) {
    if (getConfirmWindow() != null) {
        return;
    }
    HostMaintenanceConfirmationModel model = new HostMaintenanceConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (supportsGlusterService) {
        model.getStopGlusterServices().setIsAvailable(true);
        model.getStopGlusterServices().setEntity(false);
        model.getForce().setIsAvailable(true);
        model.getForce().setEntity(false);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreGlusterQuorumChecks());
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    List<String> vdssNames = getSelectedItems().stream().map(d -> d.getName()).collect(Collectors.toList());
    List<Guid> vdssIds = getSelectedItems().stream().map(d -> d.getId()).collect(Collectors.toList());
    model.setItems(vdssNames);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
    // Display existence of pinned/hp VMs warning notification
    if (clusterId != null) {
        AsyncDataProvider.getInstance().getAllVmsRunningForMultipleVds(new AsyncQuery<>(vdsToVmsMap -> {
            if (!vdsToVmsMap.isEmpty()) {
                displayPinnedVmsInfoMsg(model, clusterId, vdsToVmsMap);
            }
        }), vdssIds);
    }
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("rollbackOnFailure", isRollbackOnFailure()).append("connectivityTimeout", getConnectivityTimeout()).append("networks", getNetworks()).append("removedNetworks", getRemovedNetworks()).append("bonds", getCreateOrUpdateBonds()).append("removedBonds", getRemovedBonds()).append("clusterSwitchType", getClusterSwitchType()).append("commitOnSuccess", isCommitOnSuccess());
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("rollbackOnFailure", isRollbackOnFailure()).append("commitOnSuccess", isCommitOnSuccess()).append("connectivityTimeout", getConnectivityTimeout()).append("networks", getNetworks()).append("removedNetworks", getRemovedNetworks()).append("bonds", getCreateOrUpdateBonds()).append("removedBonds", getRemovedBonds()).append("clusterSwitchType", getClusterSwitchType()).append("managementNetworkChanged", isManagementNetworkChanged());
}
#end_block

#method_before
private Map<String, Object> generateOptions() {
    Map<String, Object> options = new HashMap<>();
    options.put(VdsProperties.CONNECTIVITY_CHECK, Boolean.toString(getParameters().isRollbackOnFailure()));
    options.put(VdsProperties.COMMIT_ON_SUCCESS, Boolean.toString(getParameters().isCommitOnSuccess()));
    // VDSM uses the connectivity timeout only if 'connectivityCheck' is set to true
    if (getParameters().isRollbackOnFailure()) {
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, getParameters().getConnectivityTimeout());
    }
    return options;
}
#method_after
private Map<String, Object> generateOptions() {
    Map<String, Object> options = new HashMap<>();
    options.put(VdsProperties.CONNECTIVITY_CHECK, Boolean.toString(getParameters().isRollbackOnFailure()));
    options.put(VdsProperties.COMMIT_ON_SUCCESS, getParameters().isCommitOnSuccess());
    // VDSM uses the connectivity timeout only if 'connectivityCheck' is set to true
    if (getParameters().isRollbackOnFailure()) {
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, getParameters().getConnectivityTimeout());
    }
    return options;
}
#end_block

#method_before
private void handleVmLease() {
    Guid importedLeaseStorageDomainId = getVmTemplate().getLeaseStorageDomainId();
    if (importedLeaseStorageDomainId == null) {
        return;
    }
    if (!getVmTemplate().isAutoStartup() || !shouldAddLease(getVmTemplate())) {
        getVmTemplate().setLeaseStorageDomainId(null);
        return;
    }
    if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
        getVmTemplate().setLeaseStorageDomainId(null);
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        return;
    }
    if (validateLeaseStorageDomain(importedLeaseStorageDomainId) && addVmLease(importedLeaseStorageDomainId, getVmTemplate().getId(), false)) {
        return;
    }
    getVmTemplate().setLeaseStorageDomainId(addVmLeaseToDefaultStorageDomain());
    if (getVmTemplate().getLeaseStorageDomainId() == null) {
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
    } else {
        log.warn("Creating the lease for the VM Template '{}' on storage domain '{}', because storage domain '{}' is unavailable", getVmTemplate().getId(), getVmTemplate().getLeaseStorageDomainId(), importedLeaseStorageDomainId);
    }
}
#method_after
private void handleVmLease() {
    Guid importedLeaseStorageDomainId = getVmTemplate().getLeaseStorageDomainId();
    if (importedLeaseStorageDomainId == null) {
        return;
    }
    if (!getVmTemplate().isAutoStartup() || !shouldAddLease(getVmTemplate())) {
        getVmTemplate().setLeaseStorageDomainId(null);
        return;
    }
    if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
        getVmTemplate().setLeaseStorageDomainId(null);
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_TEMPLATE_WITH_LEASE_COMPAT_VERSION);
        return;
    }
    if (validateLeaseStorageDomain(importedLeaseStorageDomainId)) {
        return;
    }
    getVmTemplate().setLeaseStorageDomainId(getVmLeaseToDefaultStorageDomain());
    if (getVmTemplate().getLeaseStorageDomainId() == null) {
        auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_TEMPLATE_WITH_LEASE_STORAGE_DOMAIN);
    } else {
        log.warn("Setting the lease for the VM Template '{}' to the storage domain '{}', because the storage domain '{}' is unavailable", getVmTemplate().getId(), getVmTemplate().getLeaseStorageDomainId(), importedLeaseStorageDomainId);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    handleVmLease();
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    incrementDbGeneration();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        handleVmLease();
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        addPermissionsToDB();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate().getVmInit());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity(), false);
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    incrementDbGeneration();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    switch(getParameters().getCreateSnapshotStage()) {
        case CREATE_VOLUME_FINISHED:
            getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_STARTED);
            Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
            // if the snapshot was not created in the DB
            // the command should also be handled as a failure
            getParameters().setTaskGroupSuccess(createdSnapshot != null && getParameters().getTaskGroupSuccess());
            if (getParameters().getTaskGroupSuccess()) {
                getParameters().setLiveSnapshotRequired(shouldPerformLiveSnapshot(createdSnapshot));
                if (getParameters().isLiveSnapshotRequired()) {
                    getParameters().setLiveSnapshotSucceeded(performLiveSnapshot(createdSnapshot));
                } else if (snapshotWithMemory(createdSnapshot)) {
                    logMemorySavingFailed();
                    snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                    removeMemoryVolumesOfSnapshot(createdSnapshot);
                }
            }
            getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_COMPLETED);
            break;
        default:
            return false;
    }
    persistCommandIfNeeded();
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getCreateSnapshotStage() == CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_VOLUME_FINISHED) {
        getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_STARTED);
        Snapshot createdSnapshot = snapshotDao.get(getParameters().getCreatedSnapshotId());
        // if the snapshot was not created in the DB
        // the command should also be handled as a failure
        getParameters().setTaskGroupSuccess(createdSnapshot != null && getParameters().getTaskGroupSuccess());
        if (getParameters().getTaskGroupSuccess()) {
            getParameters().setLiveSnapshotRequired(shouldPerformLiveSnapshot(createdSnapshot));
            if (getParameters().isLiveSnapshotRequired()) {
                getParameters().setLiveSnapshotSucceeded(performLiveSnapshot(createdSnapshot));
            } else if (snapshotWithMemory(createdSnapshot)) {
                logMemorySavingFailed();
                snapshotDao.removeMemoryFromSnapshot(createdSnapshot.getId());
                removeMemoryVolumesOfSnapshot(createdSnapshot);
            }
        }
        getParameters().setCreateSnapshotStage(CreateSnapshotForVmParameters.CreateSnapshotStage.CREATE_SNAPSHOT_COMPLETED);
        persistCommandIfNeeded();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean validate() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (!isValidConnection(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    if (isConnWithSameDetailsExists(paramConnection, storagePoolId)) {
        String storageId = getDuplicateStorageDomainId(paramConnection, storagePoolId);
        String storageDomainName = getStorageDomainNameById(storageId);
        addValidationMessageVariable("storage", storageId);
        addValidationMessageVariable("storageDomainName", storageDomainName);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NFS_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failValidation(EngineMessage.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    StorageServerConnections paramConnection = getConnection();
    // if an id was sent - it's not ok since only the backend should allocate ids
    if (StringUtils.isNotEmpty(paramConnection.getId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
    if (!isValidConnection(paramConnection)) {
        return false;
    }
    Guid storagePoolId = Guid.isNullOrEmpty(getParameters().getVdsId()) ? null : getVds().getStoragePoolId();
    String duplicateConnectionId = isConnWithSameDetailsExists(paramConnection, storagePoolId);
    if (!duplicateConnectionId.isEmpty() && !duplicateConnectionId.equalsIgnoreCase(paramConnection.getId())) {
        String storageDomainName = getStorageNameByConnectionId(duplicateConnectionId);
        addValidationMessageVariable("connectionId", duplicateConnectionId);
        addValidationMessageVariable("storageDomainName", storageDomainName);
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    // validate that it's a valid VDS ID and that the VDS is up.
    if (!Guid.isNullOrEmpty(getParameters().getVdsId())) {
        if (getVds() == null) {
            return failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
        }
        if (getVds().getStatus() != VDSStatus.Up) {
            return failValidation(EngineMessage.VDS_ADD_STORAGE_SERVER_STATUS_MUST_BE_UP);
        }
    }
    return true;
}
#end_block

#method_before
private IsWidget createRxColumn(VdsNetworkInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { hostInterface.getStatistics().getReceiveRate(), hostInterface.hasSpeed() ? hostInterface.getSpeed().doubleValue() : 0 })), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), SafeHtmlUtils.fromString(totalRenderer.render(hostInterface.getStatistics().getReceivedBytes())), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#method_after
private IsWidget createRxColumn(VdsNetworkInterface hostInterface) {
    Column rxCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { hostInterface.getStatistics().getReceiveRate(), hostInterface.hasSpeed() ? hostInterface.getSpeed().doubleValue() : 0.0 })), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    rxCol.add(divider);
    dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.rxTotal(), constants.bytes()), SafeHtmlUtils.fromString(totalRenderer.render(hostInterface.getStatistics().getReceivedBytes())), dl);
    dl.addClassName(Styles.PULL_LEFT);
    rxCol.getElement().appendChild(dl);
    return rxCol;
}
#end_block

#method_before
private IsWidget createTxColumn(VdsNetworkInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { hostInterface.getStatistics().getTransmitRate(), hostInterface.hasSpeed() ? hostInterface.getSpeed().doubleValue() : 0 })), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.txTotal(), constants.bytes()), SafeHtmlUtils.fromString(totalRenderer.render(hostInterface.getStatistics().getTransmittedBytes())), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#method_after
private IsWidget createTxColumn(VdsNetworkInterface hostInterface) {
    Column txCol = new Column(ColumnSize.SM_3);
    DListElement dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.txRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { hostInterface.getStatistics().getTransmitRate(), hostInterface.hasSpeed() ? hostInterface.getSpeed().doubleValue() : 0.0 })), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    FlowPanel divider = new FlowPanel();
    divider.addStyleName(RATE_DIVIDER);
    txCol.add(divider);
    dl = Document.get().createDLElement();
    addDetailItem(templates.sub(constants.txTotal(), constants.bytes()), SafeHtmlUtils.fromString(totalRenderer.render(hostInterface.getStatistics().getTransmittedBytes())), dl);
    dl.addClassName(Styles.PULL_LEFT);
    txCol.getElement().appendChild(dl);
    return txCol;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    try {
        compensator.compensate(commandId, getClass().getName(), getCompensationContext());
    } catch (Throwable t) {
        log.error("Unable to compensate command {}: {}", commandId, ExceptionUtils.getRootCauseMessage(t));
    }
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    // If the compensation data is not for the command do not perform compensation.
    if (!commandId.equals(getCompensationContext().getCommandId())) {
        return;
    }
    try {
        compensator.compensate(commandId, getClass().getName(), getCompensationContext());
    } catch (Throwable t) {
        log.error("Unable to compensate command {}: {}", commandId, ExceptionUtils.getRootCauseMessage(t));
        log.debug("Exception", t);
    }
}
#end_block

#method_before
protected IsWidget createBondInterfaceStatusPanel(boolean isUp) {
    Bond bond = (Bond) getEntity().getInterface();
    boolean isAdPartnerMacValid = isAdPartnerMacValid(bond);
    boolean isAdAggregatorIdValid = isAdAggregatorIdValid(bond, getEntity());
    if (!isAdPartnerMacValid || !isAdAggregatorIdValid) {
        IconStatusPanel iconStatusPanel = new IconStatusPanel(PatternflyConstants.PFICON_WARNING_TRIANGLE_O, PatternflyConstants.PFICON);
        iconStatusPanel.addStyleName(DOUBLE_SIZE);
        WidgetTooltip tooltip = new WidgetTooltip(iconStatusPanel);
        StringBuffer message = new StringBuffer();
        if (!isAdPartnerMacValid) {
            message.append(constants.bondInMode4HasNoPartnerMac());
        }
        if (!isAdAggregatorIdValid) {
            message.append(constants.bondInMode4HasInvalidAggregatorId());
        }
        tooltip.setHtml(templates.italicWordWrapMaxWidth(message.toString()));
        return tooltip;
    } else {
        return super.createInterfaceStatusPanel(isUp);
    }
}
#method_after
protected IsWidget createBondInterfaceStatusPanel(boolean isUp) {
    Bond bond = (Bond) getEntity().getInterface();
    boolean isAdPartnerMacValid = isAdPartnerMacValid(bond);
    boolean isAdAggregatorIdValid = isAdAggregatorIdValid(bond, getEntity());
    BondMode bondMode = BondMode.parseBondMode(bond.getBondOptions());
    if (BondMode.BOND4.equals(bondMode) && (!isAdPartnerMacValid || !isAdAggregatorIdValid)) {
        IconStatusPanel iconStatusPanel = new IconStatusPanel(PatternflyConstants.PFICON_WARNING_TRIANGLE_O, PatternflyConstants.PFICON);
        iconStatusPanel.addStyleName(DOUBLE_SIZE);
        WidgetTooltip tooltip = new WidgetTooltip(iconStatusPanel);
        StringBuffer message = new StringBuffer();
        if (!isAdPartnerMacValid) {
            message.append(constants.bondInMode4HasNoPartnerMac());
        }
        if (!isAdPartnerMacValid && !isAdAggregatorIdValid) {
            // $NON-NLS-1$
            message.append(" ");
        }
        if (!isAdAggregatorIdValid) {
            message.append(constants.bondInMode4HasInvalidAggregatorId());
        }
        tooltip.setHtml(templates.italicWordWrapMaxWidth(message.toString()));
        return tooltip;
    } else {
        return super.createInterfaceStatusPanel(isUp);
    }
}
#end_block

#method_before
private boolean isAdPartnerMacValid(Bond bond) {
    String partnerMac = bond.getAdPartnerMac();
    boolean isAdPartnerMacEmpty = partnerMac == null || partnerMac.isEmpty() || partnerMac.equals(INVALID_AD_PARTNER_MAC);
    boolean isIfcUp = InterfaceStatus.UP.equals(bond.getStatistics().getStatus());
    boolean isBond4 = BondMode.BOND4.equals(BondMode.parseBondMode(bond.getBondOptions()));
    boolean isAdPartnerSupportedForCluster = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.AdPartnerMacSupported, vds.getClusterCompatibilityVersion().getValue());
    return !isAdPartnerMacEmpty || !isIfcUp || !isBond4 || !isAdPartnerSupportedForCluster;
}
#method_after
private boolean isAdPartnerMacValid(Bond bond) {
    String partnerMac = bond.getAdPartnerMac();
    boolean isAdPartnerMacEmpty = partnerMac == null || partnerMac.isEmpty() || partnerMac.equals(INVALID_AD_PARTNER_MAC);
    boolean isIfcUp = InterfaceStatus.UP.equals(bond.getStatistics().getStatus());
    boolean isBond4 = BondMode.BOND4.equals(BondMode.parseBondMode(bond.getBondOptions()));
    return !isAdPartnerMacEmpty || !isIfcUp || !isBond4;
}
#end_block

#method_before
private boolean isAdAggregatorIdValid(Bond bond, HostInterfaceLineModel lineModel) {
    String bondAdAggregatorId = Objects.toString(bond.getAdAggregatorId(), "");
    for (HostInterface nic : lineModel.getInterfaces()) {
        String nicAggregatorId = Objects.toString(nic.getInterface().getAdAggregatorId(), "");
        if (!bondAdAggregatorId.equals(nicAggregatorId)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isAdAggregatorIdValid(Bond bond, HostInterfaceLineModel lineModel) {
    Integer aggregatorId = bond.getAdAggregatorId();
    if (aggregatorId == null) {
        return false;
    }
    for (HostInterface nic : lineModel.getInterfaces()) {
        if (!aggregatorId.equals(nic.getInterface().getAdAggregatorId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.isOnline()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_UP);
        addValidationMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (volume.getSnapshotsCount() > 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_HAS_SNAPSHOTS);
        addValidationMessageVariable("volumeName", volume.getName());
        addValidationMessageVariable("noOfSnapshots", volume.getSnapshotsCount());
        return false;
    }
    StorageDomain sd = glusterVolumeDao.getStorageDomainByGlusterVolumeId(getParameters().getVolumeId());
    if (sd != null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_GLUSTER_VOLUME_PRESENT_IN_STORAGE_DOMAIN);
        addValidationMessageVariable("volumeName", volume.getName());
        addValidationMessageVariable("storageDomainName", sd.getStorageName());
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.isOnline()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_UP);
        addValidationMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (volume.getSnapshotsCount() > 0) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_HAS_SNAPSHOTS);
        addValidationMessageVariable("volumeName", volume.getName());
        addValidationMessageVariable("noOfSnapshots", volume.getSnapshotsCount());
        return false;
    }
    StorageDomain sd = storageDomainDao.getStorageDomainByGlusterVolumeId(getParameters().getVolumeId());
    if (sd != null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_GLUSTER_VOLUME_PRESENT_IN_STORAGE_DOMAIN);
        addValidationMessageVariable("volumeName", volume.getName());
        addValidationMessageVariable("storageDomainName", sd.getStorageName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<BalanceResult> balance(Cluster cluster, List<VDS> hosts, Map<String, String> parameters) {
    final List<BalanceResult> migrationRule = super.balance(cluster, hosts, parameters);
    List<VDS> allHosts = vdsDao.getAllForCluster(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    List<VDS> maintenanceHostsWithOkExteranlStatus = new ArrayList<>();
    getHostLists(allHosts, emptyHosts, maintenanceHosts, downHosts, maintenanceHostsWithOkExteranlStatus);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, maintenanceHostsWithOkExteranlStatus, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#method_after
@Override
public List<BalanceResult> balance(Cluster cluster, List<VDS> hosts, Map<String, String> parameters) {
    final List<BalanceResult> migrationRule = super.balance(cluster, hosts, parameters);
    List<VDS> allHosts = vdsDao.getAllForCluster(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    List<VDS> maintenanceHostsWithOkExternalStatus = new ArrayList<>();
    getHostLists(allHosts, emptyHosts, maintenanceHosts, downHosts, maintenanceHostsWithOkExternalStatus);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, maintenanceHostsWithOkExternalStatus, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#end_block

#method_before
protected void getHostLists(List<VDS> allHosts, List<VDS> emptyHosts, List<VDS> maintenanceHosts, List<VDS> downHosts, List<VDS> maintenanceHostsWithOkExteranlStatus) {
    for (VDS vds : allHosts) {
        if (vds.getStatus() == VDSStatus.Up && vds.getVmCount() == 0 && vds.getVmMigrating() == 0 && PendingVM.collectForHost(getPendingResourceManager(), vds.getId()).size() == 0) {
            emptyHosts.add(vds);
        } else if (vds.isPowerManagementControlledByPolicy() && !vds.isDisablePowerManagementPolicy()) {
            if (vds.getStatus() == VDSStatus.Maintenance) {
                maintenanceHosts.add(vds);
                if (ExternalStatus.Ok.equals(vds.getExternalStatus())) {
                    maintenanceHostsWithOkExteranlStatus.add(vds);
                }
            // do not add host to downHosts if its external-status is not OK, because
            // we do not want such a host to be potentially selected to be powered-up
            } else if (vds.getStatus() == VDSStatus.Down && ExternalStatus.Ok.equals(vds.getExternalStatus())) {
                downHosts.add(vds);
            }
        }
    }
}
#method_after
protected void getHostLists(List<VDS> allHosts, List<VDS> emptyHosts, List<VDS> maintenanceHosts, List<VDS> downHosts, List<VDS> maintenanceHostsWithOkExternalStatus) {
    for (VDS vds : allHosts) {
        if (vds.getStatus() == VDSStatus.Up && vds.getVmCount() == 0 && vds.getVmMigrating() == 0 && PendingVM.collectForHost(getPendingResourceManager(), vds.getId()).size() == 0) {
            emptyHosts.add(vds);
        } else if (vds.isPowerManagementControlledByPolicy() && !vds.isDisablePowerManagementPolicy()) {
            if (vds.getStatus() == VDSStatus.Maintenance) {
                maintenanceHosts.add(vds);
                if (ExternalStatus.Ok.equals(vds.getExternalStatus())) {
                    maintenanceHostsWithOkExternalStatus.add(vds);
                }
            } else if (vds.getStatus() == VDSStatus.Down && ExternalStatus.Ok.equals(vds.getExternalStatus())) {
                downHosts.add(vds);
            }
        }
    }
}
#end_block

#method_before
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(Cluster cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> pmMaintenanceHostsWithOkExteranlStatus, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = NumberUtils.toInt(parameters.get(PolicyUnitParameter.HOSTS_IN_RESERVE.getDbName()), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get(PolicyUnitParameter.ENABLE_AUTOMATIC_HOST_POWER_MANAGEMENT.getDbName());
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM) {
        log.info("Automatic power management is disabled for cluster '{}'.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.info("Cluster '{}' does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        /* We have enough free hosts so shut some hosts in maintenance down
               keep at least one spare in maintenance during the process.
             */
        log.info("Cluster '{}' does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else if (requiredReserve < emptyHosts.size()) {
        /* We do have enough empty hosts to put something to maintenance */
        /* Find hosts with automatic PM enabled that are not the current SPM */
        /* and their external-status is OK*/
        Optional<VDS> hostsWithAutoPM = emptyHosts.stream().filter(vds -> !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.isPmEnabled() && ExternalStatus.Ok.equals(vds.getExternalStatus())).findFirst();
        if (!hostsWithAutoPM.isPresent()) {
            log.info("Cluster '{}' does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(), VDSStatus.Maintenance);
        }
    } else if (requiredReserve == emptyHosts.size() && !pmMaintenanceHosts.isEmpty()) {
        /* We have the right amount of empty hosts to start shutting the
               hosts that are resting in maintenance down.
             */
        log.info("Cluster '{}' does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else if (requiredReserve > emptyHosts.size() && !pmMaintenanceHosts.isEmpty()) {
        /* We do not have enough free hosts, but we still have some hosts
               in maintenance. We can easily activate those.
             */
        log.info("Cluster '{}' does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        /* We do not have enough free hosts and no hosts in pm maintenance, so we need to start some hosts up. */
        log.info("Cluster '{}' does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#method_after
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(Cluster cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> pmMaintenanceHostsWithOkExternalStatus, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = NumberUtils.toInt(parameters.get(PolicyUnitParameter.HOSTS_IN_RESERVE.getDbName()), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get(PolicyUnitParameter.ENABLE_AUTOMATIC_HOST_POWER_MANAGEMENT.getDbName());
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM) {
        log.info("Automatic power management is disabled for cluster '{}'.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.info("Cluster '{}' does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else if (requiredReserve < emptyHosts.size() && pmMaintenanceHostsWithOkExternalStatus.size() > 1) {
        /* We have enough free hosts so shut some hosts in maintenance down
               keep at least one spare in maintenance during the process.
             */
        log.info("Cluster '{}' does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHostsWithOkExternalStatus.get(0), VDSStatus.Down);
    } else if (requiredReserve < emptyHosts.size()) {
        /* We do have enough empty hosts to put something to maintenance */
        /* Find hosts with automatic PM enabled that are not the current SPM */
        /* and their external-status is OK*/
        Optional<VDS> hostsWithAutoPM = emptyHosts.stream().filter(vds -> !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.isPmEnabled() && ExternalStatus.Ok.equals(vds.getExternalStatus())).findFirst();
        if (!hostsWithAutoPM.isPresent()) {
            log.info("Cluster '{}' does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(), VDSStatus.Maintenance);
        }
    } else if (requiredReserve == emptyHosts.size() && !pmMaintenanceHostsWithOkExternalStatus.isEmpty()) {
        /* We have the right amount of empty hosts to start shutting the
               hosts that are resting in maintenance down.
             */
        log.info("Cluster '{}' does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHostsWithOkExternalStatus.get(0), VDSStatus.Down);
    } else if (requiredReserve > emptyHosts.size() && !pmMaintenanceHosts.isEmpty()) {
        /* We do not have enough free hosts, but we still have some hosts
               in maintenance. We can easily activate those.
             */
        log.info("Cluster '{}' does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        /* We do not have enough free hosts and no hosts in pm maintenance, so we need to start some hosts up. */
        log.info("Cluster '{}' does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#end_block

#method_before
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    Map<String, ExtMap> groupRecords = new HashMap<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecords);
    for (Map.Entry<String, ExtMap> group : groupRecords.entrySet()) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, group.getKey());
        if (dbGroup != null) {
            dbGroup.setName(group.getValue().get(Authz.GroupRecord.NAME));
            dbGroupDao.update(dbGroup);
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#method_after
private DbUser buildUser(T params, String authzName) {
    boolean externalSsoEnabled = EngineLocalConfig.getInstance().getBoolean("ENGINE_SSO_ENABLE_EXTERNAL_SSO");
    DbUser dbUser = externalSsoEnabled ? dbUserDao.getByUsernameAndDomain(params.getPrincipalName(), authzName) : dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(dbUser == null ? Guid.newGuid().toString() : params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    Map<String, ExtMap> groupRecords = new HashMap<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecords);
    for (Map.Entry<String, ExtMap> group : groupRecords.entrySet()) {
        String name = group.getValue().get(Authz.GroupRecord.NAME);
        // The domain is empty for predefined ovirt-administrator group
        String domain = name.equals(OVIRT_ADMINISTRATOR) ? "" : authzName;
        // If external sso integration is enabled we retrieve the group by their name and domain. We do not have
        // the external id for the groups in the OpenID Connect claim set.
        DbGroup dbGroup = externalSsoEnabled ? dbGroupDao.getByNameAndDomain(name, domain) : dbGroupDao.getByExternalId(authzName, group.getKey());
        if (dbGroup != null) {
            dbGroup.setName(name);
            dbGroupDao.update(dbGroup);
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    sourceIp = getParameters().getSourceIp();
    if (profile == null) {
        setSucceeded(false);
    } else {
        final DbUser user = buildUser(getParameters(), profile.getAuthzName());
        boolean isAdmin = !roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty();
        user.setAdmin(isAdmin);
        setCurrentUser(user);
        setUserName(String.format("%s@%s", getCurrentUser().getLoginName(), getCurrentUser().getDomain()));
        int maxSessions = EngineLocalConfig.getInstance().getMaxUserSessions();
        int currentNumSessions = sessionDataContainer.getNumUserSessions(user);
        if (maxSessions != -1 && currentNumSessions == maxSessions) {
            setSucceeded(false);
            // ArrayList<String> failedMessages = new ArrayList<>();
            // String maxSessionsErrorMsg = "user has reached the maximum number of sessions allowed";
            // failedMessages.add(maxSessionsErrorMsg);
            // getReturnValue().setExecuteFailedMessages(failedMessages);
            String err = String.format("user %s has reached the maximum number of sessions allowed (%d)", user.getLoginName(), maxSessions);
            log.error(err);
            throw new EngineException(EngineError.MAX_NUM_OF_SESSIONS_REACHED, err);
        } else if (getParameters().isAdminRequired() && !isAdmin) {
            setSucceeded(false);
        } else if (permissionDao.getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) {
            setSucceeded(false);
        } else {
            String engineSessionId = sessionDataContainer.generateEngineSessionId();
            sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp());
            sessionDataContainer.setUser(engineSessionId, user);
            sessionDataContainer.refresh(engineSessionId);
            sessionDataContainer.setProfile(engineSessionId, profile);
            sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName());
            sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken());
            sessionDataContainer.setSsoOvirtAppApiScope(engineSessionId, getParameters().getAppScope());
            getReturnValue().setActionReturnValue(engineSessionId);
            setSucceeded(true);
            sessionId = engineSessionId;
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    sourceIp = getParameters().getSourceIp();
    if (profile == null) {
        setSucceeded(false);
    } else {
        final DbUser user = buildUser(getParameters(), profile.getAuthzName());
        boolean isAdmin = !roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty();
        user.setAdmin(isAdmin);
        setCurrentUser(user);
        setUserName(String.format("%s@%s", getCurrentUser().getLoginName(), getCurrentUser().getDomain()));
        if (getParameters().isAdminRequired() && !isAdmin) {
            setActionReturnValue(CreateUserSessionsError.USER_NOT_AUTHORIZED);
            setSucceeded(false);
        } else if (permissionDao.getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) {
            setActionReturnValue(CreateUserSessionsError.USER_NOT_AUTHORIZED);
            setSucceeded(false);
        } else if (maxUserSessions != UNLIMITED_SESSIONS && sessionDataContainer.getNumUserSessions(user) >= maxUserSessions) {
            setActionReturnValue(CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED);
            setSucceeded(false);
        } else {
            String engineSessionId = sessionDataContainer.generateEngineSessionId();
            sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp());
            sessionDataContainer.setUser(engineSessionId, user);
            sessionDataContainer.refresh(engineSessionId);
            sessionDataContainer.setProfile(engineSessionId, profile);
            sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName());
            sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken());
            sessionDataContainer.setSsoOvirtAppApiScope(engineSessionId, getParameters().getAppScope());
            getReturnValue().setActionReturnValue(engineSessionId);
            setSucceeded(true);
            sessionId = engineSessionId;
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("SessionID", StringUtils.isEmpty(sessionId) ? UNKNOWN : sessionId);
    addCustomValue("SourceIP", StringUtils.isEmpty(sourceIp) ? UNKNOWN : sourceIp);
    addCustomValue("LoginErrMsg", "");
    return getSucceeded() ? AuditLogType.USER_VDC_LOGIN : AuditLogType.USER_VDC_LOGIN_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("SessionID", StringUtils.isEmpty(sessionId) ? UNKNOWN : sessionId);
    addCustomValue("SourceIP", StringUtils.isEmpty(sourceIp) ? UNKNOWN : sourceIp);
    addCustomValue("LoginErrMsg", "");
    if (getSucceeded()) {
        return AuditLogType.USER_VDC_LOGIN;
    }
    if (getActionReturnValue() == CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED) {
        addCustomValue("MaxUserSessions", String.valueOf(maxUserSessions));
        return AuditLogType.USER_MAX_SESSIONS_EXCEEDED;
    }
    return AuditLogType.USER_VDC_LOGIN_FAILED;
}
#end_block

#method_before
public int getNumUserSessions(DbUser user) {
    Iterator<Entry<String, SessionInfo>> iter = sessionInfoMap.entrySet().iterator();
    int numSessions = 0;
    while (iter.hasNext()) {
        Entry<String, SessionInfo> entry = iter.next();
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        DbUser sessionUser = (DbUser) sessionMap.get(USER_PARAMETER_NAME);
        if (user.getId().equals(sessionUser.getId())) {
            numSessions += 1;
        }
    }
    return numSessions;
}
#method_after
public long getNumUserSessions(DbUser user) {
    return sessionInfoMap.keySet().stream().filter(sessionId -> getUser(sessionId, false).getId().equals(user.getId())).filter(sessionId -> getSessionValid(sessionId, false)).count();
}
#end_block

#method_before
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), req == null ? "" : req.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            if (queryRetVal.getActionReturnValue() instanceof DbUser) {
                throw new RuntimeException(String.format(queryRetVal.getExecuteFailedMessages().get(0)));
            }
            throw new RuntimeException(String.format("The user %s is not authorized to perform login", username));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#method_after
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), req == null ? "" : req.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            if (queryRetVal.getActionReturnValue() == CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED) {
                throw new RuntimeException(String.format("Unable to login user %s@%s because the maximum number of allowed sessions %s is exceeded", username, profile, EngineLocalConfig.getInstance().getInteger("ENGINE_MAX_USER_SESSIONS")));
            }
            throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoPostLoginServlet");
    String username = null;
    String profile = null;
    InitialContext ctx = null;
    try {
        String error_description = request.getParameter("error_description");
        String error = request.getParameter("error");
        if (StringUtils.isNotEmpty(error_description) && StringUtils.isNotEmpty(error)) {
            throw new RuntimeException(String.format("%s: %s", error, error_description));
        }
        String code = request.getParameter("code");
        if (StringUtils.isEmpty(code)) {
            throw new RuntimeException("No authorization code found in request");
        }
        String appUrl = request.getParameter("app_url");
        log.debug("Received app_url '{}'", appUrl);
        Map<String, Object> jsonResponse = FiltersHelper.getPayloadForAuthCode(code, "ovirt-app-admin ovirt-app-portal ovirt-app-api", URLEncoder.encode(postActionUrl, "UTF-8"));
        Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
        username = (String) jsonResponse.get("user_id");
        profile = "";
        int index = username.lastIndexOf("@");
        if (index != -1) {
            profile = username.substring(index + 1);
            username = username.substring(0, index);
        }
        try {
            ctx = new InitialContext();
            ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), appScope, profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), request.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
            if (!queryRetVal.getSucceeded()) {
                if (queryRetVal.getActionReturnValue() instanceof DbUser) {
                    throw new RuntimeException(String.format(queryRetVal.getExecuteFailedMessages().get(0)));
                }
                throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
            } else {
                HttpSession httpSession = request.getSession(true);
                httpSession.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getActionReturnValue());
                httpSession.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                log.debug("Redirecting to '{}'", appUrl);
                response.sendRedirect(appUrl);
            }
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(String.format("User login failure: %s", username), ex);
        } finally {
            try {
                if (ctx != null) {
                    ctx.close();
                }
            } catch (NamingException ex) {
                log.error("Unable to close context", ex);
            }
        }
    } catch (Exception ex) {
        log.error(ex.getMessage());
        log.debug("User login failure", ex);
        String url = String.format("%s://%s:%s%s/", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
        response.sendRedirect(new URLBuilder(url).addParameter("error_description", StringUtils.defaultIfEmpty(ex.getMessage(), "Internal Server error")).addParameter("error", "server_error").build());
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered SsoPostLoginServlet");
    String username = null;
    String profile = null;
    InitialContext ctx = null;
    try {
        String error_description = request.getParameter("error_description");
        String error = request.getParameter("error");
        if (StringUtils.isNotEmpty(error_description) && StringUtils.isNotEmpty(error)) {
            throw new RuntimeException(String.format("%s: %s", error, error_description));
        }
        String code = request.getParameter("code");
        if (StringUtils.isEmpty(code)) {
            throw new RuntimeException("No authorization code found in request");
        }
        String appUrl = request.getParameter("app_url");
        log.debug("Received app_url '{}'", appUrl);
        Map<String, Object> jsonResponse = FiltersHelper.getPayloadForAuthCode(code, "ovirt-app-admin ovirt-app-portal ovirt-app-api", URLEncoder.encode(postActionUrl, "UTF-8"));
        Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
        username = (String) jsonResponse.get("user_id");
        profile = "";
        int index = username.lastIndexOf("@");
        if (index != -1) {
            profile = username.substring(index + 1);
            username = username.substring(0, index);
        }
        try {
            ctx = new InitialContext();
            ActionReturnValue queryRetVal = FiltersHelper.getBackend(ctx).runAction(ActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), (String) jsonResponse.get(SessionConstants.SSO_SCOPE_KEY), appScope, profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), (String) payload.get("first_name"), (String) payload.get("last_name"), (String) payload.get("namespace"), request.getRemoteAddr(), (Collection<ExtMap>) payload.get("group_ids"), loginAsAdmin));
            if (!queryRetVal.getSucceeded()) {
                if (queryRetVal.getActionReturnValue() == CreateUserSessionsError.NUM_OF_SESSIONS_EXCEEDED) {
                    throw new RuntimeException(String.format("Unable to login user %s@%s because the maximum number of allowed sessions %s is" + " exceeded", username, profile, maxUserSessions));
                }
                throw new RuntimeException(String.format("The user %s@%s is not authorized to perform login", username, profile));
            } else {
                HttpSession httpSession = request.getSession(true);
                httpSession.setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, queryRetVal.getActionReturnValue());
                httpSession.setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
                log.debug("Redirecting to '{}'", appUrl);
                response.sendRedirect(appUrl);
            }
        } catch (RuntimeException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new RuntimeException(String.format("User login failure: %s", username), ex);
        } finally {
            try {
                if (ctx != null) {
                    ctx.close();
                }
            } catch (NamingException ex) {
                log.error("Unable to close context", ex);
            }
        }
    } catch (Exception ex) {
        log.error(ex.getMessage());
        log.debug("User login failure", ex);
        String url = String.format("%s://%s:%s%s/", request.getScheme(), FiltersHelper.getRedirectUriServerName(request.getServerName()), request.getServerPort(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
        response.sendRedirect(new URLBuilder(url).addParameter("error_description", StringUtils.defaultIfEmpty(ex.getMessage(), "Internal Server error")).addParameter("error", "server_error").build());
    }
}
#end_block

#method_before
private void addPendingNumaMemory(VM vm, Guid hostId) {
    if (vm.getNumaTuneMode() == NumaTuneMode.PREFERRED) {
        return;
    }
    List<VmNumaNode> vmNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> hostNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(hostId);
    Map<Integer, Collection<Integer>> cpuPinning = CpuPinningHelper.parseCpuPinning(vm.getCpuPinning()).stream().collect(Collectors.toMap(p -> p.getvCpu(), p -> p.getpCpus()));
    Optional<Map<Integer, Integer>> nodeAssignment = NumaPinningHelper.findAssignment(vmNodes, hostNodes, cpuPinning);
    if (!nodeAssignment.isPresent()) {
        return;
    }
    Map<Integer, Long> hostNodePending = new HashMap<>(hostNodes.size());
    for (VmNumaNode vmNode : vmNodes) {
        // Ignore unpinned numa nodes
        if (vmNode.getVdsNumaNodeList().isEmpty()) {
            continue;
        }
        int hostNodeIndex = nodeAssignment.get().get(vmNode.getIndex());
        long vmNodeMem = vmNode.getMemTotal();
        hostNodePending.merge(hostNodeIndex, vmNodeMem, Long::sum);
    }
    for (Map.Entry<Integer, Long> entry : hostNodePending.entrySet()) {
        int hostNodeIndex = entry.getKey();
        long pendingMemory = entry.getValue();
        getPendingResourceManager().addPending(new PendingNumaMemory(hostId, vm, hostNodeIndex, pendingMemory));
    }
}
#method_after
private void addPendingNumaMemory(VM vm, Guid hostId) {
    if (vm.getNumaTuneMode() == NumaTuneMode.PREFERRED) {
        return;
    }
    List<VmNumaNode> vmNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> hostNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(hostId);
    Map<Integer, Collection<Integer>> cpuPinning = CpuPinningHelper.parseCpuPinning(vm.getCpuPinning()).stream().collect(Collectors.toMap(p -> p.getvCpu(), p -> p.getpCpus()));
    Optional<Map<Integer, Integer>> nodeAssignment = Optional.empty();
    if (!cpuPinning.isEmpty()) {
        nodeAssignment = NumaPinningHelper.findAssignment(vmNodes, hostNodes, cpuPinning);
    }
    if (!nodeAssignment.isPresent()) {
        nodeAssignment = NumaPinningHelper.findAssignment(vmNodes, hostNodes);
    }
    if (!nodeAssignment.isPresent()) {
        return;
    }
    Map<Integer, Long> hostNodePending = new HashMap<>(hostNodes.size());
    for (VmNumaNode vmNode : vmNodes) {
        // Ignore unpinned numa nodes
        if (vmNode.getVdsNumaNodeList().isEmpty()) {
            continue;
        }
        int hostNodeIndex = nodeAssignment.get().get(vmNode.getIndex());
        long vmNodeMem = vmNode.getMemTotal();
        hostNodePending.merge(hostNodeIndex, vmNodeMem, Long::sum);
    }
    for (Map.Entry<Integer, Long> entry : hostNodePending.entrySet()) {
        int hostNodeIndex = entry.getKey();
        long pendingMemory = entry.getValue();
        getPendingResourceManager().addPending(new PendingNumaMemory(hostId, vm, hostNodeIndex, pendingMemory));
    }
}
#end_block

#method_before
private void performLoadBalancingImpl() {
    log.debug("Load Balancer timer entered.");
    List<Cluster> clusters = clusterDao.getAll();
    for (Cluster cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Optional<BalanceResult> balanceResult = Optional.empty();
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = vdsDao.getAllForClusterWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult.isPresent() && balanceResult.get().isValid()) {
            migrationHandler.migrateVM(balanceResult.get().getCandidateHosts(), balanceResult.get().getVmToMigrate(), MessageBundler.getMessage(AuditLogType.MIGRATION_REASON_LOAD_BALANCING));
        }
    }
}
#method_after
private void performLoadBalancingImpl() {
    log.debug("Load Balancer timer entered.");
    List<Cluster> clusters = clusterDao.getAll();
    for (Cluster cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        List<BalanceResult> balanceResults = Collections.emptyList();
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = vdsDao.getAllForClusterWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResults = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResults = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        for (BalanceResult balanceResult : balanceResults) {
            if (!balanceResult.isValid()) {
                continue;
            }
            boolean migrated = migrationHandler.migrateVM(balanceResult.getCandidateHosts(), balanceResult.getVmToMigrate(), MessageBundler.getMessage(AuditLogType.MIGRATION_REASON_LOAD_BALANCING));
            if (migrated) {
                break;
            }
        }
    }
}
#end_block

#method_before
private Optional<BalanceResult> internalRunBalance(PolicyUnitImpl policyUnit, Cluster cluster, List<VDS> hosts) {
    return policyUnit.balance(cluster, hosts, cluster.getClusterPolicyProperties(), new ArrayList<>());
}
#method_after
private List<BalanceResult> internalRunBalance(PolicyUnitImpl policyUnit, Cluster cluster, List<VDS> hosts) {
    return policyUnit.balance(cluster, hosts, cluster.getClusterPolicyProperties());
}
#end_block

#method_before
private Optional<BalanceResult> externalRunBalance(PolicyUnitImpl policyUnit, Cluster cluster, List<VDS> hosts) {
    List<Guid> hostIDs = new ArrayList<>();
    for (VDS vds : hosts) {
        hostIDs.add(vds.getId());
    }
    Optional<BalanceResult> balanceResult = externalBroker.runBalance(policyUnit.getPolicyUnit().getName(), hostIDs, cluster.getClusterPolicyProperties());
    if (balanceResult.isPresent()) {
        return balanceResult;
    }
    log.warn("All external schedulers returned empty balancing result.");
    return Optional.empty();
}
#method_after
private List<BalanceResult> externalRunBalance(PolicyUnitImpl policyUnit, Cluster cluster, List<VDS> hosts) {
    List<Guid> hostIDs = new ArrayList<>();
    for (VDS vds : hosts) {
        hostIDs.add(vds.getId());
    }
    Optional<BalanceResult> balanceResult = externalBroker.runBalance(policyUnit.getPolicyUnit().getName(), hostIDs, cluster.getClusterPolicyProperties());
    if (balanceResult.isPresent()) {
        return Collections.singletonList(balanceResult.get());
    }
    log.warn("All external schedulers returned empty balancing result.");
    return Collections.emptyList();
}
#end_block

#method_before
@BeforeEach
public void setUp() {
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    vm.setvNumaNodeList(new ArrayList<>());
    doAnswer(arg -> vm.getvNumaNodeList()).when(vmNumaNodeDao).getAllVmNumaNodeByVmId(any(Guid.class));
    hostWithoutNuma = createHost(0, NODE_SIZE, CORES_PER_NODE);
    hostTwoNodes = createHost(2, NODE_SIZE, CORES_PER_NODE);
    hostFourNodes = createHost(4, NODE_SIZE, CORES_PER_NODE);
    hosts = Arrays.asList(hostWithoutNuma, hostTwoNodes, hostFourNodes);
    doAnswer(invocation -> hosts.stream().filter(h -> h.getId().equals((Guid) invocation.getArgument(0))).findAny().map(VDS::getNumaNodeList).orElse(Collections.emptyList())).when(vdsNumaNodeDao).getAllVdsNumaNodeByVdsId(any(Guid.class));
}
#method_after
@BeforeEach
public void setUp() {
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setNumaTuneMode(NumaTuneMode.STRICT);
    doAnswer(arg -> vm.getvNumaNodeList()).when(vmNumaNodeDao).getAllVmNumaNodeByVmId(any(Guid.class));
    hostWithoutNuma = createHost(0, NODE_SIZE);
    hostTwoNodes = createHost(2, NODE_SIZE);
    hostFourNodes = createHost(4, NODE_SIZE);
    hosts = Arrays.asList(hostWithoutNuma, hostTwoNodes, hostFourNodes);
    doAnswer(invocation -> hosts.stream().filter(h -> h.getId().equals((Guid) invocation.getArgument(0))).findAny().map(VDS::getNumaNodeList).orElse(Collections.emptyList())).when(vdsNumaNodeDao).getAllVdsNumaNodeByVdsId(any(Guid.class));
}
#end_block

#method_before
public static List<PinnedCpu> parseCpuPinning(final String cpuPinning) {
    if (cpuPinning == null) {
        return Collections.emptyList();
    }
    final List<PinnedCpu> rules = new ArrayList<>();
    for (final String rule : cpuPinning.split("_")) {
        String[] splitRule = rule.split("#");
        Collection<Integer> pCpus = parsePCpuPinningNumbers(splitRule[1]);
        rules.add(new PinnedCpu(Integer.parseInt(splitRule[0]), pCpus));
    }
    return rules;
}
#method_after
public static List<PinnedCpu> parseCpuPinning(final String cpuPinning) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return Collections.emptyList();
    }
    final List<PinnedCpu> rules = new ArrayList<>();
    for (final String rule : cpuPinning.split("_")) {
        String[] splitRule = rule.split("#");
        Collection<Integer> pCpus = parsePCpuPinningNumbers(splitRule[1]);
        rules.add(new PinnedCpu(Integer.parseInt(splitRule[0]), pCpus));
    }
    return rules;
}
#end_block

#method_before
public static Optional<Map<Integer, Integer>> findAssignment(List<VmNumaNode> vmNodes, List<VdsNumaNode> hostNodes, Map<Integer, Collection<Integer>> cpuPinning) {
    Map<Integer, Long> hostNodeFreeMem = hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, node -> node.getNumaNodeStatistics().getMemFree()));
    Map<Integer, List<Integer>> hostNodeCpuMap = hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, NumaNode::getCpuIds));
    // Check if all VM nodes are pinned to existing host nodes
    boolean allPinnedNodesExist = vmNodes.stream().flatMap(node -> node.getVdsNumaNodeList().stream()).allMatch(hostNodeFreeMem::containsKey);
    if (!allPinnedNodesExist) {
        return Optional.empty();
    }
    return new NumaPinningHelper(vmNodes, cpuPinning, hostNodeCpuMap).fitNodes(0, hostNodeFreeMem);
}
#method_after
public static Optional<Map<Integer, Integer>> findAssignment(List<VmNumaNode> vmNodes, List<VdsNumaNode> hostNodes) {
    return findAssignment(vmNodes, hostNodes, null);
}
#end_block

#method_before
public static Optional<Map<Integer, Integer>> findAssignment(List<VmNumaNode> vmNodes, List<VdsNumaNode> hostNodes, Map<Integer, Collection<Integer>> cpuPinning) {
    Map<Integer, Long> hostNodeFreeMem = hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, node -> node.getNumaNodeStatistics().getMemFree()));
    Map<Integer, List<Integer>> hostNodeCpuMap = hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, NumaNode::getCpuIds));
    // Check if all VM nodes are pinned to existing host nodes
    boolean allPinnedNodesExist = vmNodes.stream().flatMap(node -> node.getVdsNumaNodeList().stream()).allMatch(hostNodeFreeMem::containsKey);
    if (!allPinnedNodesExist) {
        return Optional.empty();
    }
    return new NumaPinningHelper(vmNodes, cpuPinning, hostNodeCpuMap).fitNodes(0, hostNodeFreeMem);
}
#method_after
public static Optional<Map<Integer, Integer>> findAssignment(List<VmNumaNode> vmNodes, List<VdsNumaNode> hostNodes, Map<Integer, Collection<Integer>> cpuPinning) {
    Map<Integer, Long> hostNodeFreeMem = hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, node -> node.getNumaNodeStatistics().getMemFree()));
    // Check if all VM nodes are pinned to existing host nodes
    boolean allPinnedNodesExist = vmNodes.stream().flatMap(node -> node.getVdsNumaNodeList().stream()).allMatch(hostNodeFreeMem::containsKey);
    if (!allPinnedNodesExist) {
        return Optional.empty();
    }
    if (cpuPinning != null && cpuPinning.isEmpty()) {
        cpuPinning = null;
    }
    Map<Integer, List<Integer>> hostNodeCpuMap = cpuPinning == null ? null : hostNodes.stream().collect(Collectors.toMap(NumaNode::getIndex, NumaNode::getCpuIds));
    NumaPinningHelper helper = new NumaPinningHelper(vmNodes, cpuPinning, hostNodeCpuMap);
    Map<Integer, Integer> assignment = helper.fitNodes(0, hostNodeFreeMem);
    return Optional.ofNullable(assignment);
}
#end_block

#method_before
private Optional<Map<Integer, Integer>> fitNodes(int vmNumaNodeIndex, Map<Integer, Long> hostNodeFreeMem) {
    // If all nodes fit, return an empty map
    if (vmNumaNodeIndex >= vmNodes.size()) {
        return Optional.of(new HashMap<>(vmNodes.size()));
    }
    VmNumaNode vmNode = vmNodes.get(vmNumaNodeIndex);
    // If the node is not pinned, skip it
    if (vmNode.getVdsNumaNodeList().isEmpty()) {
        return fitNodes(vmNumaNodeIndex + 1, hostNodeFreeMem);
    }
    for (Integer pinnedIndex : vmNode.getVdsNumaNodeList()) {
        long hostFreeMem = hostNodeFreeMem.get(pinnedIndex);
        List<Integer> hostNodeCpus = hostNodeCpuMap.get(pinnedIndex);
        if (!vmNodeFitsHostNode(vmNode, hostFreeMem, hostNodeCpus)) {
            continue;
        }
        // The current VM node fits to the host node,
        // store new free memory value in the list
        hostNodeFreeMem.put(pinnedIndex, hostFreeMem - vmNode.getMemTotal());
        // Recursive call to check if the rest of the nodes fit
        Optional<Map<Integer, Integer>> othersFit = fitNodes(vmNumaNodeIndex + 1, hostNodeFreeMem);
        // if a possible assignment was found, store it in the output map and return
        if (othersFit.isPresent()) {
            othersFit.get().put(vmNode.getIndex(), pinnedIndex);
            return othersFit;
        }
        // The rest of the VM nodes do not fit, return the old value to the list
        hostNodeFreeMem.put(pinnedIndex, hostFreeMem);
    }
    return Optional.empty();
}
#method_after
private Map<Integer, Integer> fitNodes(int vmNumaNodeIndex, Map<Integer, Long> hostNodeFreeMem) {
    // If all nodes fit, return an empty map
    if (vmNumaNodeIndex >= vmNodes.size()) {
        return new HashMap<>(vmNodes.size());
    }
    VmNumaNode vmNode = vmNodes.get(vmNumaNodeIndex);
    // preferred mode and to which host nodes they can be pinned.
    if (vmNode.getVdsNumaNodeList().isEmpty()) {
        return fitNodes(vmNumaNodeIndex + 1, hostNodeFreeMem);
    }
    for (Integer pinnedIndex : vmNode.getVdsNumaNodeList()) {
        long hostFreeMem = hostNodeFreeMem.get(pinnedIndex);
        if (hostFreeMem < vmNode.getMemTotal()) {
            continue;
        }
        if (cpuPinning != null) {
            if (!vmNodeFitsHostNodeCpuPinning(vmNode, hostNodeCpuMap.get(pinnedIndex))) {
                continue;
            }
        }
        // The current VM node fits to the host node,
        // store new free memory value in the list
        hostNodeFreeMem.put(pinnedIndex, hostFreeMem - vmNode.getMemTotal());
        // Recursive call to check if the rest of the nodes fit
        Map<Integer, Integer> othersFit = fitNodes(vmNumaNodeIndex + 1, hostNodeFreeMem);
        // if a possible assignment was found, store it in the output map and return
        if (othersFit != null) {
            othersFit.put(vmNode.getIndex(), pinnedIndex);
            return othersFit;
        }
        // The rest of the VM nodes do not fit, return the old value to the list
        hostNodeFreeMem.put(pinnedIndex, hostFreeMem);
    }
    return null;
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    // Preferred hosts are only used during VM startup
    if (!vm.isDown()) {
        return Collections.emptyList();
    }
    List<Pair<Guid, Integer>> weights = new ArrayList<>();
    Set<Guid> preferredHosts = new HashSet<>(vm.getDedicatedVmForVdsList());
    boolean isAnyPreferredHost = preferredHosts.size() > 0;
    // Add penalization to hosts that are not in the preferred list
    for (VDS host : hosts) {
        if (isAnyPreferredHost && !preferredHosts.contains(host.getId())) {
            log.info("Penalizing host '{}' because it is not preferred.", host.getName());
            // TODO externalize weight
            weights.add(new Pair<Guid, Integer>(host.getId(), 10000));
        } else {
            weights.add(new Pair<Guid, Integer>(host.getId(), 0));
        }
    }
    return weights;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    // Preferred hosts are only used during VM startup
    if (!vm.isDown()) {
        return Collections.emptyList();
    }
    List<Pair<Guid, Integer>> weights = new ArrayList<>();
    Set<Guid> preferredHosts = new HashSet<>(vm.getDedicatedVmForVdsList());
    boolean isAnyPreferredHost = preferredHosts.size() > 0;
    // Add penalization to hosts that are not in the preferred list
    for (VDS host : hosts) {
        if (isAnyPreferredHost && !preferredHosts.contains(host.getId())) {
            log.debug("Penalizing host '{}' because it is not preferred.", host.getName());
            // TODO externalize weight
            weights.add(new Pair<Guid, Integer>(host.getId(), 10000));
        } else {
            weights.add(new Pair<Guid, Integer>(host.getId(), 0));
        }
    }
    return weights;
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    // isHeSystem must be set before setWindow() because the view edit is called before it finishes
    hostModel.setIsHeSystem(isHeSystem());
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (!clusterChanging) {
            updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        clusterChanging = true;
        ListModel<Cluster> clusterModel = hostModel.getCluster();
        if (clusterModel.getSelectedItem() != null) {
            hostModel.getOverrideIpTables().setIsAvailable(true);
            hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
        }
        clusterChanging = false;
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        HostModel innerHostModel = (HostModel) getWindow();
        innerHostModel.getDataCenter().setItems(dataCenters);
        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
        innerHostModel.onDataInitialized();
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        innerHostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        innerHostModel.getCommands().add(cancelCommand);
    }));
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    // isHeSystem must be set before setWindow() because the view edit is called before it finishes
    hostModel.setIsHeSystem(isHeSystem());
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    hostModel.setVgpuPlacement(VgpuPlacement.CONSOLIDATED);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (!clusterChanging) {
            updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        clusterChanging = true;
        ListModel<Cluster> clusterModel = hostModel.getCluster();
        if (clusterModel.getSelectedItem() != null) {
            hostModel.getOverrideIpTables().setIsAvailable(true);
            hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
        }
        clusterChanging = false;
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        HostModel innerHostModel = (HostModel) getWindow();
        innerHostModel.getDataCenter().setItems(dataCenters);
        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
        innerHostModel.onDataInitialized();
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        innerHostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        innerHostModel.getCommands().add(cancelCommand);
    }));
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    host.setVgpuPlacement(model.getVgpuPlacement().getValue());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    // isHeSystem must be set before setWindow() because the view edit is called before it finishes
    hostModel.setIsHeSystem(isHeSystem());
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    hostModel.setVgpuPlacementValue(null);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (!clusterChanging) {
            updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        clusterChanging = true;
        ListModel<Cluster> clusterModel = hostModel.getCluster();
        if (clusterModel.getSelectedItem() != null) {
            hostModel.getOverrideIpTables().setIsAvailable(true);
            hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
        }
        clusterChanging = false;
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        HostModel innerHostModel = (HostModel) getWindow();
        innerHostModel.getDataCenter().setItems(dataCenters);
        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
        innerHostModel.onDataInitialized();
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        innerHostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        innerHostModel.getCommands().add(cancelCommand);
    }));
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    // isHeSystem must be set before setWindow() because the view edit is called before it finishes
    hostModel.setIsHeSystem(isHeSystem());
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    hostModel.setVgpuPlacement(VgpuPlacement.CONSOLIDATED);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery<>(returnValue -> hostModel.setPmProxyPreferences(returnValue)));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (!clusterChanging) {
            updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        clusterChanging = true;
        ListModel<Cluster> clusterModel = hostModel.getCluster();
        if (clusterModel.getSelectedItem() != null) {
            hostModel.getOverrideIpTables().setIsAvailable(true);
            hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
        }
        clusterChanging = false;
    });
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery<>(dataCenters -> {
        HostModel innerHostModel = (HostModel) getWindow();
        innerHostModel.getDataCenter().setItems(dataCenters);
        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
        innerHostModel.onDataInitialized();
        // $NON-NLS-1$
        UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", HostListModel.this);
        innerHostModel.getCommands().add(onSaveFalseCommand);
        // $NON-NLS-1$
        UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", HostListModel.this);
        innerHostModel.getCommands().add(cancelCommand);
    }));
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    host.setVgpuPlacement(model.getVgpuPlacementValue());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    host.setVgpuPlacement(model.getVgpuPlacement().getValue());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    host.setCurrentKernelCmdline(model.getKernelCmdline().getEntity());
    host.setKernelCmdlineBlacklistNouveau(model.getKernelCmdlineBlacklistNouveau().getEntity());
    host.setKernelCmdlineParsable(model.isKernelCmdlineParsable());
    host.setKernelCmdlineIommu(model.getKernelCmdlineIommu().getEntity());
    host.setKernelCmdlineKvmNested(model.getKernelCmdlineKvmNested().getEntity());
    host.setKernelCmdlineUnsafeInterrupts(model.getKernelCmdlineUnsafeInterrupts().getEntity());
    host.setKernelCmdlinePciRealloc(model.getKernelCmdlinePciRealloc().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.getVdsStaticData().setOpenstackNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        parameters.setHostedEngineDeployConfiguration(new HostedEngineDeployConfiguration(model.getHostedEngineHostModel().getSelectedItem()));
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        Frontend.getInstance().runAction(ActionType.AddVds, parameters, result -> {
            Object[] array = (Object[]) result.getState();
            HostListModel<Void> localModel = (HostListModel<Void>) array[0];
            boolean localApproveInitiated = (Boolean) array[1];
            localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        parameters.setAffinityLabels(model.getLabelList().getSelectedItems());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(ActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), result -> {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                boolean localApproveInitiated = (Boolean) array[2];
                ActionReturnValue localReturnValue = result.getReturnValue();
                if (localReturnValue != null && localReturnValue.getSucceeded()) {
                    localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                } else {
                    localModel.getWindow().stopProgress();
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        @Override
        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<Provider.AdditionalProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    rbProvisionedHost = new EntityModelRadioButtonEditor("2");
    kernelCmdlineBlacklistNouveau = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    consoleAddressEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    vgpuCompactPlacementEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    vgpuSeparatePlacementEditor = new EntityModelRadioButtonEditor("3");
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        @Override
        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<Provider.AdditionalProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    rbProvisionedHost = new EntityModelRadioButtonEditor("2");
    kernelCmdlineBlacklistNouveau = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    consoleAddressEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    vgpuConsolidatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    vgpuSeparatedPlacementEditor = new EntityModelRadioButtonEditor("3");
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener((ev, sender, args) -> {
        String fetchResultText = object.getFetchResult().getEntity();
        if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
            fetchResult.addStyleName(style.fetchResultErrorLabel());
        } else {
            fetchResult.removeStyleName(style.fetchResultErrorLabel());
        }
        fetchResult.setText(fetchResultText);
    });
    object.getPkSection().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            setPkPasswordSectionVisiblity(false);
        }
    });
    object.getProviders().getSelectedItemChangedEvent().addListener((ev, sender, args) -> object.updateHosts());
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
        boolean doProvisioning = object.externalProvisionEnabled();
        boolean isProvisioned = showForemanProviders && doProvisioning;
        providersEditor.setVisible(showForemanProviders);
        // showing or hiding radio buttons
        provisionedHostSection.setVisible(isProvisioned);
        discoveredHostSection.setVisible(isProvisioned);
        // disabling ip and name textbox when using provisioned hosts
        hostAddressEditor.setEnabled(!isProvisioned);
        hostAddressLabel.setStyleName(OvirtCss.LABEL_DISABLED, isProvisioned);
        if (isProvisioned) {
            object.updateHosts();
            object.getIsDiscoveredHosts().setEntity(true);
        } else {
            if (doProvisioning) {
                object.cleanHostParametersFields();
            }
            hideProviderWidgets(object);
            object.getIsDiscoveredHosts().setEntity(null);
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (object.getIsDiscoveredHosts().getEntity() != null) {
            if (object.getIsDiscoveredHosts().getEntity()) {
                rbDiscoveredHost.asRadioButton().setValue(true);
                showDiscoveredHostsWidgets(true);
            } else if (!object.getIsDiscoveredHosts().getEntity()) {
                rbProvisionedHost.asRadioButton().setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    nameEditor.asValueBox().addKeyDownHandler(event -> Scheduler.get().scheduleDeferred(() -> {
        if (object.getExternalHostProviderEnabled().getEntity() && Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
            ExternalHostGroup dhg = (ExternalHostGroup) object.getExternalHostGroups().getSelectedItem();
            if (dhg != null) {
                String base = nameEditor.asEditor().getSubEditor().getValue();
                if (base == null) {
                    base = constants.empty();
                }
                String generatedHostName = // $NON-NLS-1$
                base + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty());
                object.getHost().setEntity(generatedHostName);
            }
        }
    }));
    if (object.isPasswordSectionViewable()) {
        rbPassword.setValue(true);
        rbPassword.setFocus(true);
        fetchSshFingerprint.hideLabel();
        object.setAuthenticationMethod(AuthenticationMethod.Password);
        displayPassPkWindow(true);
        rbPassword.addClickHandler(event -> {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        });
        rbPublicKey.addClickHandler(event -> {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        });
    } else {
        passwordSection.getElement().getStyle().setDisplay(Display.NONE);
        rbPublicKey.getElement().getStyle().setDisplay(Display.NONE);
        rbPublicKeyLabel.setStyleName(OvirtCss.LABEL_DISABLED);
        object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    updateHostsButton.setResource(resources.searchButtonImage());
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = (ev, sender, args) -> createSpmControls(object);
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangeable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    this.fenceAgentsEditor.edit(object.getFenceAgentListModel());
    this.proxySourceEditor.edit(object.getPmProxyPreferencesList());
    addTextAndLinkAlert(fetchPanel, constants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    providerSearchFilterLabel.setText(constants.hostPopupProviderSearchFilter());
    nameEditor.setFocus(true);
    hostedEngineTab.setVisible(object.getIsHeSystem() && object.getIsNew());
    object.getHostedEngineWarning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        EntityModel entity = (EntityModel) sender;
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            hostedEngineWarningLabel.setVisible(entity.getIsAvailable());
        }
    });
    affinityLabelSelectionWidget.init(object.getLabelList());
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener((ev, sender, args) -> {
        String fetchResultText = object.getFetchResult().getEntity();
        if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
            fetchResult.addStyleName(style.fetchResultErrorLabel());
        } else {
            fetchResult.removeStyleName(style.fetchResultErrorLabel());
        }
        fetchResult.setText(fetchResultText);
    });
    object.getPkSection().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            setPkPasswordSectionVisiblity(false);
        }
    });
    object.getProviders().getSelectedItemChangedEvent().addListener((ev, sender, args) -> object.updateHosts());
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
        boolean doProvisioning = object.externalProvisionEnabled();
        boolean isProvisioned = showForemanProviders && doProvisioning;
        providersEditor.setVisible(showForemanProviders);
        // showing or hiding radio buttons
        provisionedHostSection.setVisible(isProvisioned);
        discoveredHostSection.setVisible(isProvisioned);
        // disabling ip and name textbox when using provisioned hosts
        hostAddressEditor.setEnabled(!isProvisioned);
        hostAddressLabel.setStyleName(OvirtCss.LABEL_DISABLED, isProvisioned);
        if (isProvisioned) {
            object.updateHosts();
            object.getIsDiscoveredHosts().setEntity(true);
        } else {
            if (doProvisioning) {
                object.cleanHostParametersFields();
            }
            hideProviderWidgets(object);
            object.getIsDiscoveredHosts().setEntity(null);
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (object.getIsDiscoveredHosts().getEntity() != null) {
            if (object.getIsDiscoveredHosts().getEntity()) {
                rbDiscoveredHost.asRadioButton().setValue(true);
                showDiscoveredHostsWidgets(true);
            } else if (!object.getIsDiscoveredHosts().getEntity()) {
                rbProvisionedHost.asRadioButton().setValue(true);
                showProvisionedHostsWidgets(true);
            }
        }
    });
    nameEditor.asValueBox().addKeyDownHandler(event -> Scheduler.get().scheduleDeferred(() -> {
        if (object.getExternalHostProviderEnabled().getEntity() && Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
            ExternalHostGroup dhg = (ExternalHostGroup) object.getExternalHostGroups().getSelectedItem();
            if (dhg != null) {
                String base = nameEditor.asEditor().getSubEditor().getValue();
                if (base == null) {
                    base = constants.empty();
                }
                String generatedHostName = // $NON-NLS-1$
                base + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty());
                object.getHost().setEntity(generatedHostName);
            }
        }
    }));
    if (object.isPasswordSectionViewable()) {
        rbPassword.setValue(true);
        rbPassword.setFocus(true);
        fetchSshFingerprint.hideLabel();
        object.setAuthenticationMethod(AuthenticationMethod.Password);
        displayPassPkWindow(true);
        rbPassword.addClickHandler(event -> {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        });
        rbPublicKey.addClickHandler(event -> {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        });
    } else {
        passwordSection.getElement().getStyle().setDisplay(Display.NONE);
        rbPublicKey.getElement().getStyle().setDisplay(Display.NONE);
        rbPublicKeyLabel.setStyleName(OvirtCss.LABEL_DISABLED);
        object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    updateHostsButton.setResource(resources.searchButtonImage());
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = (ev, sender, args) -> createSpmControls(object);
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangeable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    this.fenceAgentsEditor.edit(object.getFenceAgentListModel());
    this.proxySourceEditor.edit(object.getPmProxyPreferencesList());
    addTextAndLinkAlert(fetchPanel, constants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    providerSearchFilterLabel.setText(constants.hostPopupProviderSearchFilter());
    nameEditor.setFocus(true);
    hostedEngineTab.setVisible(object.getIsHeSystem() && object.getIsNew());
    object.getHostedEngineWarning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        EntityModel entity = (EntityModel) sender;
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            hostedEngineWarningLabel.setVisible(entity.getIsAvailable());
        }
    });
    affinityLabelSelectionWidget.init(object.getLabelList());
    vgpuConsolidatedPlacementEditor.asRadioButton().addValueChangeHandler(event -> {
        object.getVgpuConsolidatedPlacement().setEntity(vgpuConsolidatedPlacementEditor.asRadioButton().getValue());
        object.getVgpuSeparatedPlacement().setEntity(vgpuSeparatedPlacementEditor.asRadioButton().getValue());
    });
    vgpuSeparatedPlacementEditor.asRadioButton().addValueChangeHandler(event -> {
        object.getVgpuConsolidatedPlacement().setEntity(vgpuConsolidatedPlacementEditor.asRadioButton().getValue());
        object.getVgpuSeparatedPlacement().setEntity(vgpuSeparatedPlacementEditor.asRadioButton().getValue());
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    // ==Power Management Tab==
    nextTabIndex = powerManagementTab.setTabIndexes(nextTabIndex);
    pmEnabledEditor.setTabIndex(nextTabIndex++);
    pmKdumpDetectionEditor.setTabIndex(nextTabIndex++);
    disableAutomaticPowerManagementEditor.setTabIndex(nextTabIndex++);
    fenceAgentsEditor.setTabIndexes(nextTabIndex++);
    pmExpander.setTabIndexes(nextTabIndex);
    proxySourceEditor.setTabIndexes(nextTabIndex++);
    // ==SPM Tab==
    nextTabIndex = spmTab.setTabIndexes(nextTabIndex);
    // ==Console and GPU Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    consoleAddressEnabled.setTabIndex(nextTabIndex++);
    consoleAddress.setTabIndex(nextTabIndex++);
    vgpuCompactPlacementEditor.setTabIndex(nextTabIndex++);
    vgpuSeparatePlacementEditor.setTabIndex(nextTabIndex++);
    // ==Kernel Tab==
    nextTabIndex = kernelTab.setTabIndexes(nextTabIndex);
    kernelCmdlineBlacklistNouveau.setTabIndex(nextTabIndex++);
    kernelCmdlineIommu.setTabIndex(nextTabIndex++);
    kernelCmdlineKvmNested.setTabIndex(nextTabIndex++);
    kernelCmdlineUnsafeInterrupts.setTabIndex(nextTabIndex++);
    kernelCmdlinePciRealloc.setTabIndex(nextTabIndex++);
    kernelCmdlineText.setTabIndex(nextTabIndex++);
    // ==Hosted Engine Tab==
    nextTabIndex = hostedEngineTab.setTabIndexes(nextTabIndex);
    hostedEngineDeployActionsEditor.setTabIndex(nextTabIndex++);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    rbProvisionedHost.setTabIndex(nextTabIndex++);
    rbDiscoveredHost.setTabIndex(nextTabIndex++);
    externalDiscoveredHostsEditor.setTabIndex(nextTabIndex++);
    externalHostGroupsEditor.setTabIndex(nextTabIndex++);
    externalComputeResourceEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    // ==Power Management Tab==
    nextTabIndex = powerManagementTab.setTabIndexes(nextTabIndex);
    pmEnabledEditor.setTabIndex(nextTabIndex++);
    pmKdumpDetectionEditor.setTabIndex(nextTabIndex++);
    disableAutomaticPowerManagementEditor.setTabIndex(nextTabIndex++);
    fenceAgentsEditor.setTabIndexes(nextTabIndex++);
    pmExpander.setTabIndexes(nextTabIndex);
    proxySourceEditor.setTabIndexes(nextTabIndex++);
    // ==SPM Tab==
    nextTabIndex = spmTab.setTabIndexes(nextTabIndex);
    // ==Console and GPU Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    consoleAddressEnabled.setTabIndex(nextTabIndex++);
    consoleAddress.setTabIndex(nextTabIndex++);
    vgpuConsolidatedPlacementEditor.setTabIndex(nextTabIndex++);
    vgpuSeparatedPlacementEditor.setTabIndex(nextTabIndex++);
    // ==Kernel Tab==
    nextTabIndex = kernelTab.setTabIndexes(nextTabIndex);
    kernelCmdlineBlacklistNouveau.setTabIndex(nextTabIndex++);
    kernelCmdlineIommu.setTabIndex(nextTabIndex++);
    kernelCmdlineKvmNested.setTabIndex(nextTabIndex++);
    kernelCmdlineUnsafeInterrupts.setTabIndex(nextTabIndex++);
    kernelCmdlinePciRealloc.setTabIndex(nextTabIndex++);
    kernelCmdlineText.setTabIndex(nextTabIndex++);
    // ==Hosted Engine Tab==
    nextTabIndex = hostedEngineTab.setTabIndexes(nextTabIndex);
    hostedEngineDeployActionsEditor.setTabIndex(nextTabIndex++);
    // ==Affinity Labels Tab==
    nextTabIndex = affinityLabelsTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
protected void cluster_SelectedItemChanged() {
    Cluster cluster = getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    getFencingEnabled().setEntity(cluster.getFencingPolicy().isFencingEnabled());
    AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery<>(pmTypes -> updatePmTypeList(pmTypes)), cluster.getCompatibilityVersion());
    // Match the appropriate selected data center to the selected cluster, don't fire update events.
    if (getDataCenter() != null && getDataCenter().getItems() != null) {
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
    final CpuVendor newCpuVendor = getCurrentCpuVendor();
    if (newCpuVendor != null && !newCpuVendor.equals(lastNonNullCpuVendor)) {
        lastNonNullCpuVendor = newCpuVendor;
        cpuVendorChanged();
    }
    getHostedEngineWarning().setIsAvailable(cluster.getCompatibilityVersion().less(Version.v4_0));
    getNetworkProviderModel().setDefaultProviderId(cluster.getDefaultNetworkProviderId());
}
#method_after
protected void cluster_SelectedItemChanged() {
    Cluster cluster = getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    getFencingEnabled().setEntity(cluster.getFencingPolicy().isFencingEnabled());
    AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery<>(pmTypes -> updatePmTypeList(pmTypes)), cluster.getCompatibilityVersion());
    // Match the appropriate selected data center to the selected cluster, don't fire update events.
    if (getDataCenter() != null && getDataCenter().getItems() != null) {
        for (StoragePool datacenter : getDataCenter().getItems()) {
            if (datacenter.getId().equals(cluster.getStoragePoolId())) {
                getDataCenter().setSelectedItem(datacenter, false);
                break;
            }
        }
    }
    final CpuVendor newCpuVendor = getCurrentCpuVendor();
    if (newCpuVendor != null && !newCpuVendor.equals(lastNonNullCpuVendor)) {
        lastNonNullCpuVendor = newCpuVendor;
        cpuVendorChanged();
    }
    getHostedEngineWarning().setIsAvailable(cluster.getCompatibilityVersion().less(Version.v4_0));
    getNetworkProviderModel().setDefaultProviderId(cluster.getDefaultNetworkProviderId());
    setVgpuPlacementChangeability(cluster.getCompatibilityVersion());
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
}
#method_after
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    setVgpuPlacement(VgpuPlacement.forValue(vds.getVgpuPlacement()));
    setVgpuPlacementChangeability(getCluster().getSelectedItem().getCompatibilityVersion());
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    mdevMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    emulatedMachine = vm.getEmulatedMachine() != null ? vm.getEmulatedMachine() : vmInfoBuildUtils.getEmulatedMachineByClusterArch(vm.getClusterArch());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(emulatedMachine));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    vmCustomProperties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
    }
    vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
}
#method_after
private void init(VM vm, VmInfoBuildUtils vmInfoBuildUtils, Guid hostId) {
    this.vm = vm;
    this.vmInfoBuildUtils = vmInfoBuildUtils;
    payloadIndex = -1;
    cdRomIndex = -1;
    vnicMetadata = new HashMap<>();
    diskMetadata = new HashMap<>();
    mdevMetadata = new HashMap<>();
    hypervEnabled = vmInfoBuildUtils.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    emulatedMachine = vm.getEmulatedMachine() != null ? vm.getEmulatedMachine() : vmInfoBuildUtils.getEmulatedMachineByClusterArch(vm.getClusterArch());
    cdInterface = vmInfoBuildUtils.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(emulatedMachine));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
    vmCustomProperties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    if (hostId != null) {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getHostDevices(hostId));
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsStatistics(hostId));
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVdsNumaNodes(hostId));
        hostVgpuPlacementSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.vgpuPlacement(hostId));
    } else {
        hostDevicesSupplier = new MemoizingSupplier<>(() -> Collections.emptyMap());
        hostStatisticsSupplier = new MemoizingSupplier<>(() -> null);
        hostNumaNodesSupplier = new MemoizingSupplier<>(() -> Collections.emptyList());
        hostVgpuPlacementSupplier = new MemoizingSupplier<>(() -> null);
    }
    vmNumaNodesSupplier = new MemoizingSupplier<>(() -> vmInfoBuildUtils.getVmNumaNodes(vm));
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean secureBootEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !secureBootEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (secureBootEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean secureBootEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !secureBootEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        if (FeatureSupported.hyperVSynicStimerSupported(vm.getCompatibilityVersion())) {
            writer.writeStartElement("synic");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
            writer.writeStartElement("stimer");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (secureBootEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    if (mdevTypes != null) {
        String[] mdevDevices = mdevTypes.split(",");
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacementEnum vgpuPlacement = vmInfoBuildUtils.vgpuPlacement(vm);
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacementEnum.DEFAULT || vgpuPlacement == VgpuPlacementEnum.COMPACT) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacementEnum.SEPARATE) {
                    vgpuPlacementString = "separate";
                } else {
                    log.error("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacementEnum.COMPACT, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#method_after
private void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    if (mdevTypes != null) {
        String[] mdevDevices = mdevTypes.split(",");
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            String mdevTypeMeta = mdevType;
            if (FeatureSupported.isVgpuPlacementSupported(vm.getCompatibilityVersion())) {
                VgpuPlacement vgpuPlacement = hostVgpuPlacementSupplier.get();
                String vgpuPlacementString;
                if (vgpuPlacement == VgpuPlacement.CONSOLIDATED) {
                    vgpuPlacementString = "compact";
                } else if (vgpuPlacement == VgpuPlacement.SEPARATED) {
                    vgpuPlacementString = "separate";
                } else {
                    log.warn("Unrecognized vGPU placement type (using `{}' instead): {}", VgpuPlacement.CONSOLIDATED, vgpuPlacement);
                    vgpuPlacementString = "compact";
                }
                mdevTypeMeta = mdevTypeMeta + "|" + vgpuPlacementString;
            }
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevTypeMeta));
        }
    }
}
#end_block

#method_before
public VgpuPlacementEnum vgpuPlacement(VM vm) {
    return VgpuPlacementEnum.forValue(vdsDao.get(vm.getRunOnVds()).getVgpuPlacement());
}
#method_after
public VgpuPlacement vgpuPlacement(Guid hostId) {
    return VgpuPlacement.forValue(vdsStaticDao.get(hostId).getVgpuPlacement());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineBlacklistNouveau, other.kernelCmdlineBlacklistNouveau) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts) && reinstallRequired == other.reinstallRequired && Objects.equals(vgpuPlacement, other.vgpuPlacement);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsStatic)) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return Objects.equals(id, other.id) && Objects.equals(hostName, other.hostName) && Objects.equals(consoleAddress, other.consoleAddress) && Objects.equals(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && pmKdumpDetection == other.isPmKdumpDetection() && port == other.port && sshPort == other.sshPort && Objects.equals(sshUsername, other.sshUsername) && Objects.equals(serverSslEnabled, other.serverSslEnabled) && Objects.equals(uniqueId, other.uniqueId) && Objects.equals(clusterId, other.clusterId) && Objects.equals(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && Objects.equals(sshKeyFingerprint, other.sshKeyFingerprint) && disablePowerManagementPolicy == other.disablePowerManagementPolicy && Objects.equals(hostProviderId, other.hostProviderId) && Objects.equals(openstackNetworkProviderId, other.openstackNetworkProviderId) && Objects.equals(currentKernelCmdline, other.currentKernelCmdline) && Objects.equals(kernelCmdlineParsable, other.kernelCmdlineParsable) && Objects.equals(lastStoredKernelCmdline, other.lastStoredKernelCmdline) && Objects.equals(kernelCmdlineBlacklistNouveau, other.kernelCmdlineBlacklistNouveau) && Objects.equals(kernelCmdlineIommu, other.kernelCmdlineIommu) && Objects.equals(kernelCmdlineKvmNested, other.kernelCmdlineKvmNested) && Objects.equals(kernelCmdlinePciRealloc, other.kernelCmdlinePciRealloc) && Objects.equals(kernelCmdlineUnsafeInterrupts, other.kernelCmdlineUnsafeInterrupts) && reinstallRequired == other.reinstallRequired && vgpuPlacement == other.vgpuPlacement;
}
#end_block

#method_before
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    HttpServletRequest request = input.get(Authz.InvokeKeys.HTTP_SERVLET_REQUEST);
    dumpRequest(request);
    Map<String, String> headers = request == null ? input.<Map<String, String>>get(Authz.InvokeKeys.HTTP_SERVLET_REQUEST_PARAMS) : getHeaders(request);
    output.mput(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS).mput(Authz.InvokeKeys.PRINCIPAL_RECORD, queryExecutor.buildPrincipalRecord(headers, nameArg, groupsArg));
}
#method_after
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    // Fix after extensions-api is released
    // HttpServletRequest request = input.get(Authz.InvokeKeys.HTTP_SERVLET_REQUEST);
    HttpServletRequest request = input.get(HTTP_SERVLET_REQUEST);
    dumpRequest(request);
    Map<String, String> headers = request == null ? // input.<Map<String, String>> get(Authz.InvokeKeys.HTTP_SERVLET_REQUEST_PARAMS) :
    input.<Map<String, String>>get(HTTP_SERVLET_REQUEST_PARAMS) : getHeaders(request);
    output.mput(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS).mput(Authz.InvokeKeys.PRINCIPAL_RECORD, queryExecutor.buildPrincipalRecord(headers, nameArg, groupsArg));
}
#end_block

#method_before
private Map<String, Integer> getVideoDeviceSettings(VmBase vmBase) {
    Version vmVersion = vmBase.getCustomCompatibilityVersion();
    Supplier<Version> clusterVersionSupplier = () -> clusterUtils.getCompatibilityVersion(vmBase);
    /*
         * TODO: Do we want support VMs with compatibility version lower than 4.0? If not, we can remove
         * LegacyVideoSettings completely
         */
    if (CompatibilityVersionUtils.getEffective(vmVersion, clusterVersionSupplier).greaterOrEquals(v3_6_compat)) {
        if (vmBase.getDefaultDisplayType() == DisplayType.qxl) {
            return vgamemVideoSettings.getQxlVideoDeviceSettings(vmBase);
        } else {
            return vgamemVideoSettings.getVgaVideoDeviceSettings();
        }
    } else {
        return legacyVideoSettings.getVideoDeviceSettings(vmBase);
    }
}
#method_after
private Map<String, Integer> getVideoDeviceSettings(VmBase vmBase) {
    if (vmBase.getDefaultDisplayType() == DisplayType.qxl) {
        return vgamemVideoSettings.getQxlVideoDeviceSettings(vmBase);
    } else {
        return vgamemVideoSettings.getVgaVideoDeviceSettings();
    }
}
#end_block

#method_before
private Map<String, Object> parseInterface(XmlNode dev) {
    switch(DomainXmlUtils.parseAttribute(dev, "type")) {
        case "bridge":
            Map<String, Object> device = new HashMap<>();
            device.put(VdsProperties.Device, DomainXmlUtils.parseAttribute(dev, "type"));
            device.put(VdsProperties.Type, VmDeviceGeneralType.INTERFACE.getValue());
            device.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            device.put(VdsProperties.Alias, VmDevicesConverter.parseAlias(dev));
            device.put(VdsProperties.MAC_ADDR, DomainXmlUtils.parseMacAddress(dev));
            device.put(VdsProperties.NETWORK, DomainXmlUtils.parseNicNetwork(dev));
            device.put(VdsProperties.NIC_TYPE, DomainXmlUtils.parseNicType(dev));
            return device;
        default:
            return null;
    }
}
#method_after
private Map<String, Object> parseInterface(XmlNode dev) {
    switch(DomainXmlUtils.parseAttribute(dev, "type")) {
        case "bridge":
            Map<String, Object> device = new HashMap<>();
            device.put(VdsProperties.Device, DomainXmlUtils.parseAttribute(dev, "type"));
            device.put(VdsProperties.Type, VmDeviceGeneralType.INTERFACE.getValue());
            device.put(VdsProperties.DeviceId, Guid.newGuid().toString());
            device.put(VdsProperties.Alias, VmDevicesConverter.parseAlias(dev));
            device.put(VdsProperties.Name, VmDevicesConverter.parseAlias(dev));
            device.put(VdsProperties.MAC_ADDR, DomainXmlUtils.parseMacAddress(dev));
            device.put(VdsProperties.NETWORK, DomainXmlUtils.parseNicNetwork(dev));
            device.put(VdsProperties.NIC_TYPE, DomainXmlUtils.parseNicType(dev));
            return device;
        default:
            return null;
    }
}
#end_block

#method_before
private Map<String, Object> parseDisk(XmlNode dev) {
    switch(DomainXmlUtils.parseAttribute(dev, "device")) {
        case "disk":
            Map<String, String> uuids = parseDiskUuids(DomainXmlUtils.parseDiskPath(dev));
            if (uuids == null) {
                return null;
            }
            Map<String, Object> device = new HashMap<>();
            device.put(VdsProperties.Device, VdsProperties.Disk);
            device.put(VdsProperties.Alias, VmDevicesConverter.parseAlias(dev));
            device.put(VdsProperties.Format, "raw".equals(DomainXmlUtils.parseDiskDriver(dev)) ? VolumeFormat.RAW : VolumeFormat.COW);
            device.put(VdsProperties.INTERFACE, DiskInterface.forName(DomainXmlUtils.parseDiskBus(dev)));
            device.putAll(uuids);
            return device;
        default:
            return null;
    }
}
#method_after
private Map<String, Object> parseDisk(XmlNode dev) {
    switch(DomainXmlUtils.parseAttribute(dev, "device")) {
        case "disk":
            Map<String, String> uuids = parseDiskUuids(DomainXmlUtils.parseDiskPath(dev));
            if (uuids == null) {
                return null;
            }
            Map<String, Object> device = new HashMap<>();
            device.put(VdsProperties.Device, VdsProperties.Disk);
            device.put(VdsProperties.Alias, VmDevicesConverter.parseAlias(dev));
            device.put(VdsProperties.Format, "raw".equals(DomainXmlUtils.parseDiskDriver(dev)) ? "raw" : "cow");
            device.put(VdsProperties.INTERFACE, DomainXmlUtils.parseDiskBus(dev));
            device.putAll(uuids);
            return device;
        default:
            return null;
    }
}
#end_block

#method_before
public static final AbstractTextColumn<Disk> getLogicalNameColumn(String sortBy) {
    AbstractTextColumn<Disk> column = new AbstractTextColumn<Disk>() {

        @Override
        public String getValue(Disk object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getLogicalName();
            }
            return null;
        }
    };
    return makeSortable(column, sortBy);
}
#method_after
public static AbstractTextColumn<Disk> getLogicalNameColumn(String sortBy) {
    AbstractTextColumn<Disk> column = new AbstractTextColumn<Disk>() {

        @Override
        public String getValue(Disk object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getLogicalName();
            }
            return null;
        }
    };
    return makeSortable(column, sortBy);
}
#end_block

#method_before
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId()), null);
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            // (see: https://bugzilla.redhat.com/1388098)
            if (host.getExternalStatus() != null && host.getExternalStatus() != ExternalStatus.Ok) {
                log.warn("Host '{}' ({}) was not started by PM Health Check Manager becuse it has external-status: '{}'.", host.getName(), host.getId(), host.getExternalStatus());
                continue;
            }
            ActionReturnValue retValue = backend.get().runInternalAction(ActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#method_after
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId()), null);
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            // power-management operations on the host.
            if (!ExternalStatus.Ok.equals(host.getExternalStatus())) {
                log.warn("Host '{}' ({}) was not started by PM Health Check Manager becuse it has external-status: '{}'.", host.getName(), host.getId(), host.getExternalStatus());
                continue;
            }
            ActionReturnValue retValue = backend.get().runInternalAction(ActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !fenceValidator.isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        alertIfFenceOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            setCommandShouldBeLogged(false);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            alertIfPowerManagementOperationSkipped();
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // (see: https://bugzilla.redhat.com/1388098)
        if (host.getExternalStatus() != null && host.getExternalStatus() != ExternalStatus.Ok) {
            log.warn("Host '{}' ({}) is not fenced becuse it has external-status: '{}'.", host.getName(), host.getId(), host.getExternalStatus());
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDS host = getVds();
    if (!previousHostedEngineHost.isPreviousHostId(host.getId()) && !fenceValidator.isStartupTimeoutPassed() && !host.isInFenceFlow()) {
        alertIfFenceOperationSkipped();
        // If fencing can't be done and the host is the SPM, set storage-pool to non-operational
        if (host.getSpmStatus() != VdsSpmStatus.None) {
            setStoragePoolNonOperational();
        }
        return;
    }
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (shouldFencingBeSkipped(getVds())) {
        setSucceeded(false);
        setCommandShouldBeLogged(false);
        return;
    }
    boolean shouldBeFenced = getVds().shouldVdsBeFenced();
    ActionReturnValue restartVdsResult = null;
    if (shouldBeFenced) {
        getParameters().setParentCommand(ActionType.VdsNotRespondingTreatment);
        ActionReturnValue retVal;
        retVal = runInternalAction(ActionType.SshSoftFencing, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // SSH Soft Fencing was successful and host is Up, stop non responding treatment
            getReturnValue().setSucceeded(true);
            setCommandShouldBeLogged(false);
            return;
        }
        // proceed with non responding treatment only if PM action are allowed and PM enabled for host
        if (!monitoringStrategyFactory.getMonitoringStrategyForVds(getVds()).isPowerManagementSupported() || !getVds().isPmEnabled()) {
            alertIfPowerManagementOperationSkipped();
            setSucceeded(false);
            setCommandShouldBeLogged(false);
            return;
        }
        retVal = runInternalAction(ActionType.VdsKdumpDetection, getParameters(), cloneContext().withoutExecutionContext());
        if (retVal.getSucceeded()) {
            // kdump on host detected and finished successfully, stop hard fencing execution
            getReturnValue().setSucceeded(true);
            return;
        }
        // power-management operations on the host.
        if (!ExternalStatus.Ok.equals(host.getExternalStatus())) {
            AuditLogable logEntry = createAuditLogableForHost(host);
            logEntry.addCustomValue("ExternalStatus", host.getExternalStatus().toString());
            auditLogDirector.log(logEntry, AuditLogType.VDS_AUTO_FENCE_SKIPPED_DUE_TO_EXTERNAL_STATUS);
            getReturnValue().setSucceeded(false);
            return;
        }
        // load cluster fencing policy
        FencingPolicy fencingPolicy = clusterDao.get(getVds().getClusterId()).getFencingPolicy();
        getParameters().setFencingPolicy(fencingPolicy);
        waitUntilSkipFencingIfSDActiveAllowed(fencingPolicy.isSkipFencingIfSDActive());
        restartVdsResult = runInternalAction(ActionType.RestartVds, getParameters(), cloneContext().withoutExecutionContext());
    } else {
        setCommandShouldBeLogged(false);
        log.info("Host '{}' ({}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    if (restartVdsResult != null && restartVdsResult.<RestartVdsResult>getActionReturnValue() != null && restartVdsResult.<RestartVdsResult>getActionReturnValue().isSkippedDueToFencingPolicy()) {
        // fencing was skipped, fire an alert and suppress standard command logging
        AuditLogable alb = createAuditLogableForHost(getVds());
        auditLogDirector.log(alb, AuditLogType.VDS_ALERT_NOT_RESTARTED_DUE_TO_POLICY);
        setSucceeded(false);
        setCommandShouldBeLogged(false);
    } else {
        getReturnValue().setSucceeded(shouldBeFenced);
    }
}
#end_block

#method_before
public Guid getFirstQuotaForUserId(Guid storagePoolId, Guid adElementId) {
    List<Quota> quotas = getQuotaDao().getQuotaByAdElementId(adElementId, storagePoolId, false);
    if (quotas.isEmpty()) {
        return getDefaultQuotaId(storagePoolId);
    }
    return quotas.get(0).getId();
}
#method_after
public Guid getFirstQuotaForUserId(Guid storagePoolId, Guid adElementId) {
    List<Quota> quotas = getQuotaDao().getQuotaByAdElementId(adElementId, storagePoolId, false);
    Guid defaultQuotaId = getDefaultQuotaId(storagePoolId);
    if (quotas.isEmpty()) {
        return defaultQuotaId;
    }
    for (Quota quota : quotas) {
        if (quota.getId().equals(defaultQuotaId)) {
            return defaultQuotaId;
        }
    }
    return quotas.get(0).getId();
}
#end_block

#method_before
public Guid getDefaultQuotaIfNull(Guid quotaId, Guid storagePoolId) {
    return quotaId != null && !Guid.Empty.equals(quotaId) ? quotaId : getDefaultQuotaId(storagePoolId);
}
#method_after
private Guid getDefaultQuotaIfNull(Guid quotaId, Guid storagePoolId) {
    return quotaId != null && !Guid.Empty.equals(quotaId) ? quotaId : getDefaultQuotaId(storagePoolId);
}
#end_block

#method_before
public Guid getFirstQuotaForUser(Guid quotaId, Guid storagePoolId, Guid adElementId) {
    return quotaId != null && !Guid.Empty.equals(quotaId) ? quotaId : getFirstQuotaForUserId(storagePoolId, adElementId);
}
#method_after
public Guid getFirstQuotaForUser(Guid quotaId, Guid storagePoolId, DbUser currentUser) {
    if (currentUser != null) {
        return quotaId != null && !Guid.Empty.equals(quotaId) ? quotaId : getFirstQuotaForUserId(storagePoolId, currentUser.getId());
    }
    return getDefaultQuotaIfNull(quotaId, storagePoolId);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    StoragePoolValidator spValidator = new StoragePoolValidator(getStoragePool());
    if (!validate(spValidator.exists())) {
        return false;
    }
    if (!isExternalVM() && !validate(spValidator.isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    StoragePoolValidator spValidator = new StoragePoolValidator(getStoragePool());
    if (!validate(spValidator.exists())) {
        return false;
    }
    if (!isExternalVM() && !validate(spValidator.isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#end_block

#method_before
private Guid getQuotaId() {
    return getQuotaManager().getFirstQuotaForUser(getParameters().getVmStaticData().getQuotaId(), getStoragePoolId(), getCurrentUser().getId());
}
#method_after
private Guid getQuotaId() {
    return getQuotaManager().getFirstQuotaForUser(getParameters().getVmStaticData().getQuotaId(), getStoragePoolId(), getCurrentUser());
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = vmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = vmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVm().getBiosType().getChipsetType(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Job jobWithSteps = jobRepository.getJobWithSteps(getParameters().getId());
    if (getParameters().isFiltered()) {
        Guid userId = getUserID();
        if (jobWithSteps.getOwnerId().equals(userId) && jobWithSteps.getEngineSessionSeqId() == getEngineSessionSeqId()) {
            getQueryReturnValue().setReturnValue(jobWithSteps);
        }
    } else {
        getQueryReturnValue().setReturnValue(jobWithSteps);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    Job jobWithSteps = jobRepository.getJobWithSteps(getParameters().getId());
    if (getParameters().isFiltered()) {
        Guid ownerId = getUserID();
        if (jobWithSteps.getOwnerId().equals(ownerId)) {
            getQueryReturnValue().setReturnValue(jobWithSteps);
        }
    } else {
        getQueryReturnValue().setReturnValue(jobWithSteps);
    }
}
#end_block

#method_before
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations()).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations();
        default:
            throw new IllegalStateException("Unexpected enum item: " + getCluster().getMigrationBandwidthLimitType());
    }
}
#method_after
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations() / 8).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations() / 8;
        default:
            throw new IllegalStateException("Unexpected enum item: " + getCluster().getMigrationBandwidthLimitType());
    }
}
#end_block

#method_before
@Override
protected boolean validateImpl() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    // Till then, HP VMs and non HP pinned VMs can be manually migrated only if destination host is manually selected.
    if (isMigrationRestrictedDueToHostSpecificSettings()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_PINNED_HP_VM_MIGRATABLE_ONLY_WHEN_HOST_SELECTED);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.allPassthroughVnicsMigratable())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = ChangeVmClusterValidator.create(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(callFilterImageDisks(vm)).diskImagesNotLocked()) && !schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getReturnValue().getValidationMessages()).isEmpty();
}
#method_after
@Override
protected boolean validateImpl() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.allPassthroughVnicsMigratable())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = ChangeVmClusterValidator.create(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(callFilterImageDisks(vm)).diskImagesNotLocked()) && !schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getReturnValue().getValidationMessages()).isEmpty();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    queryVirtualFunctionMap(tempVar);
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    IdQueryParameters tempVar = new IdQueryParameters(getEntity().getId());
    tempVar.setRefresh(getIsQueryFirstTime());
    queryVirtualFunctionMap(tempVar);
    queryIsHostLockedOnNetworkOperation(tempVar);
}
#end_block

#method_before
private void queryIsHostLockedOnNetworkOperation(IdQueryParameters idQueryParameters) {
    Frontend.getInstance().runQuery(QueryType.IsHostLockedOnNetworkOperation, idQueryParameters, new AsyncQuery<QueryReturnValue>(returnValue -> {
        isNetworkOperationInProgress = returnValue.getReturnValue();
        queryHostInterfaces(idQueryParameters);
    }));
}
#method_after
private void queryIsHostLockedOnNetworkOperation(IdQueryParameters idQueryParameters) {
    Frontend.getInstance().runQuery(QueryType.IsHostLockedOnNetworkOperation, idQueryParameters, new AsyncQuery<QueryReturnValue>(returnValue -> isNetworkOperationInProgress = returnValue.getReturnValue()));
}
#end_block

#method_before
private void queryVirtualFunctionMap(IdQueryParameters idQueryParameters) {
    Frontend.getInstance().runQuery(QueryType.GetVfToPfMapByHostId, idQueryParameters, new AsyncQuery<QueryReturnValue>(returnValue -> {
        vfToPfMap = Optional.ofNullable((Map<Guid, Guid>) returnValue.getReturnValue()).orElse(Collections.emptyMap());
        queryIsHostLockedOnNetworkOperation(idQueryParameters);
    }));
}
#method_after
private void queryVirtualFunctionMap(IdQueryParameters idQueryParameters) {
    Frontend.getInstance().runQuery(QueryType.GetVfToPfMapByHostId, idQueryParameters, new AsyncQuery<QueryReturnValue>(returnValue -> {
        vfToPfMap = Optional.ofNullable((Map<Guid, Guid>) returnValue.getReturnValue()).orElse(Collections.emptyMap());
        queryHostInterfaces(idQueryParameters);
    }));
}
#end_block

#method_before
private void initProgressIndicator() {
    progressIndicator = new SimplePanel();
    getContainer().insert(progressIndicator, 0);
    getDetailModel().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (getDetailModel().isNetworkOperationInProgress()) {
            progressIndicator.getElement().setInnerSafeHtml(templates.hostInterfaceOperationInProgressSpinner(constants.networkUpdating()));
        } else {
            progressIndicator.getElement().setInnerSafeHtml(templates.sevenPixelPaddedEmptyPlaceholder());
        }
    });
}
#method_after
private void initProgressIndicator() {
    progressIndicator = new SimplePanel();
    getContainer().insert(progressIndicator, 0);
    getDetailModel().getPropertyChangedEvent().addListener((ev, sender, args) -> progressIndicator.getElement().setInnerSafeHtml(getDetailModel().isNetworkOperationInProgress() ? templates.networkUpdatingSpinner(constants.networkUpdating()) : SafeHtmlUtils.fromTrustedString("")));
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean secureBootEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !secureBootEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        Version version = vm.getCompatibilityVersion();
        if (version.getMajor() == 4 && version.getMinor() >= 3) {
            writer.writeStartElement("synic");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
            writer.writeStartElement("stimer");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (secureBootEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean secureBootEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !secureBootEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        if (FeatureSupported.hyperVSynicStimerSupported(vm.getCompatibilityVersion())) {
            writer.writeStartElement("synic");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
            writer.writeStartElement("stimer");
            writer.writeAttributeString("state", "on");
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (secureBootEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations()).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations();
        default:
            throw new IllegalStateException("Unexpected enum item: " + getCluster().getMigrationBandwidthLimitType());
    }
}
#method_after
private Integer getMaxBandwidth(MigrationPolicy migrationPolicy) {
    switch(getCluster().getMigrationBandwidthLimitType()) {
        case AUTO:
            return Optional.ofNullable(getAutoMaxBandwidth()).map(bandwidth -> bandwidth / migrationPolicy.getMaxMigrations() / 8).orElse(null);
        case VDSM_CONFIG:
            return null;
        case CUSTOM:
            return getCluster().getCustomMigrationNetworkBandwidth() / migrationPolicy.getMaxMigrations() / 8;
        default:
            throw new IllegalStateException("Unexpected enum item: " + getCluster().getMigrationBandwidthLimitType());
    }
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = vmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = vmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getEffectiveCompatibilityVersion(), getParameters().getVm().getBiosType().getChipsetType(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
@Test
public void canNotDoWithoutPinnedHost() {
    mockCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#method_after
@Test
public void canNotDoWithoutPinnedHost() {
    mockCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    getVmDeviceUtils().setCompensationContext(getCompensationContextIfEnabledByCaller());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
        clearUnmanagedDevices();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContextIfEnabledByCaller());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    // This cannot be reverted using compensation, but it should not be needed
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    if (isCompensationEnabledByCaller()) {
        VmStatic oldStatic = oldVm.getStaticData();
        getCompensationContext().snapshotEntityUpdated(oldStatic);
    }
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
        clearUnmanagedDevices();
    }
    iconUtils.removeUnusedIcons(oldIconIds, getCompensationContextIfEnabledByCaller());
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData(), getCompensationContextIfEnabledByCaller());
    checkTrustedService();
    liveUpdateCpuProfile();
    // Persist all data in compensation context.
    // It can be done here at the end, because the whole command runs in a transaction.
    compensationStateChanged();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        vmDynamicDao.updateVmLeaseInfo(getVmId(), null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    // Currently, compensation is only used when this command is called from UpdateClusterCommand,
    // and it does not update VM leases.
    // TODO - Add compensation support if needed.
    throwIfCompensationEnabled();
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        vmDynamicDao.updateVmLeaseInfo(getVmId(), null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
private void updateVmHostDevices() {
    if (isDedicatedVmForVdsChanged()) {
        log.info("Pinned host changed for VM: {}. Dropping configured host devices.", getVm().getName());
        vmDeviceDao.removeVmDevicesByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    }
}
#method_after
private void updateVmHostDevices() {
    if (isDedicatedVmForVdsChanged()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change preferred hosts of the VM.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        log.info("Pinned host changed for VM: {}. Dropping configured host devices.", getVm().getName());
        vmDeviceDao.removeVmDevicesByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    }
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        ActionReturnValue result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        ActionReturnValue result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContextIfEnabledByCaller());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    ActionReturnValue rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    ActionReturnValue rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextWithNoCleanupCompensation());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextWithNoCleanupCompensation());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextWithNoCleanupCompensation());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged() || isChipsetChanged()) {
        log.info("Emulated machine or BIOS chipset type has changed for VM: {} ({}), clearing device addresses.", getVm().getName(), getVm().getId());
        vmDeviceDao.clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = vmDevicesMonitoring.createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        change.flush();
    }
}
#method_after
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged() || isChipsetChanged()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change emulated machine or chipset.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        log.info("Emulated machine or BIOS chipset type has changed for VM: {} ({}), clearing device addresses.", getVm().getName(), getVm().getId());
        vmDeviceDao.clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = vmDevicesMonitoring.createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        change.flush();
    }
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        final int memoryAddedMb = newAmountOfMemory - currentMemory;
        final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
        final boolean memoryDividable = memoryAddedMb % factor == 0;
        if (!memoryDividable) {
            addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
            addCustomValue("requiredFactor", String.valueOf(factor));
            auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
            newVmStatic.setMemSizeMb(currentMemory);
            return;
        }
        hotSetMemory(currentMemory, newAmountOfMemory);
        return;
    }
    if (currentMemory > newAmountOfMemory) {
        hotUnplugMemory(newVm);
    }
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        // Temporarily setting to the currentMemory. It will be increased in hotPlugMemory().
        newVmStatic.setMemSizeMb(currentMemory);
        final int memoryAddedMb = newAmountOfMemory - currentMemory;
        final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
        final boolean memoryDividable = memoryAddedMb % factor == 0;
        if (!memoryDividable) {
            addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
            addCustomValue("requiredFactor", String.valueOf(factor));
            auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
            return;
        }
        hotPlugMemory(memoryAddedMb);
        return;
    }
    if (currentMemory > newAmountOfMemory) {
        hotUnplugMemory(newVm);
    }
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    ActionReturnValue setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#method_after
private boolean hotPlugMemoryDevice(int memHotplugSize) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, memHotplugSize > 0 ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, memHotplugSize);
    ActionReturnValue setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine() && setAmountOfMemoryResult.getSucceeded()) {
        newVmStatic.setMemSizeMb(newVmStatic.getMemSizeMb() + memHotplugSize);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
    return setAmountOfMemoryResult.getSucceeded();
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        QueryReturnValue query = runInternalQuery(QueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty() && getParameters().getWatchdog() == null) {
            return;
        }
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        if (getParameters().getWatchdog() != null) {
            parameters.setAction(getParameters().getWatchdog().getAction());
            parameters.setModel(getParameters().getWatchdog().getModel());
            if (watchdogs.isEmpty()) {
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                runInternalAction(ActionType.UpdateWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            // there is a watchdog in the vm, there should not be any, so let's delete
            runInternalAction(ActionType.RemoveWatchdog, parameters, cloneContextAndDetachFromParent());
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not update watchdog.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        QueryReturnValue query = runInternalQuery(QueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty() && getParameters().getWatchdog() == null) {
            return;
        }
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        if (getParameters().getWatchdog() != null) {
            parameters.setAction(getParameters().getWatchdog().getAction());
            parameters.setModel(getParameters().getWatchdog().getModel());
            if (watchdogs.isEmpty()) {
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                runInternalAction(ActionType.UpdateWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            // there is a watchdog in the vm, there should not be any, so let's delete
            runInternalAction(ActionType.RemoveWatchdog, parameters, cloneContextAndDetachFromParent());
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        backend.runInternalAction(ActionType.RemoveGraphicsDevice, new GraphicsParameters(existingGraphicsDevice));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        GraphicsParameters params = new GraphicsParameters(existingGraphicsDevice);
        params.setCompensationEnabled(isCompensationEnabledByCaller());
        backend.runInternalAction(ActionType.RemoveGraphicsDevice, params, cloneContextWithNoCleanupCompensation());
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    if (existingGraphicsDevice != null) {
        device.setDeviceId(existingGraphicsDevice.getDeviceId());
    }
    device.setVmId(getVmId());
    backend.runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, new GraphicsParameters(device));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    if (existingGraphicsDevice != null) {
        device.setDeviceId(existingGraphicsDevice.getDeviceId());
    }
    device.setVmId(getVmId());
    GraphicsParameters params = new GraphicsParameters(device);
    params.setCompensationEnabled(isCompensationEnabledByCaller());
    backend.runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, params, cloneContextWithNoCleanupCompensation());
}
#end_block

#method_before
private void updateVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            vmDeviceDao.remove(oldPayload.getId());
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
private void updateVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not update VM payload.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            vmDeviceDao.remove(oldPayload.getId());
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
private void updateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getClusterId(), getParameters().getVmStaticData().getClusterId())) {
        List<Network> networks = networkDao.getAllForCluster(getParameters().getVmStaticData().getClusterId());
        List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = networkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
}
#method_after
private void updateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getClusterId(), getParameters().getVmStaticData().getClusterId())) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change cluster ID.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        List<Network> networks = networkDao.getAllForCluster(getParameters().getVmStaticData().getClusterId());
        List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = networkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(backend.runInternalAction(ActionType.SetVmNumaNodes, params));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    // Currently, compensation is only used when this command is called from UpdateClusterCommand,
    // and it does not change NUMA nodes.
    // TODO - Add compensation support if needed.
    throwIfCompensationEnabled();
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(backend.runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMaxMemorySizeMb() < vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_MEMORY_CANNOT_BE_SMALLER_THAN_MEMORY_SIZE, ReplacementUtils.createSetVariableString("maxMemory", vmFromDB.getMaxMemorySizeMb()), ReplacementUtils.createSetVariableString("memory", vmFromParams.getMemSizeMb()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#end_block

#method_before
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    labelDao.updateLabelsForVm(getVmId(), labelIds);
}
#method_after
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    // Currently, this method does not use compensation to revert this operation,
    // because affinity groups are not changed when this command is called as a child of
    // UpdateClusterCommand.
    labelDao.updateLabelsForVm(getVmId(), labelIds);
}
#end_block

#method_before
@Test
public void shouldNotDoWithoutPinnedHost() {
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#method_after
@Test
public void shouldNotDoWithoutPinnedHost() {
    vm.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    assertValidationFailure(underTest.checkVmNumaNodesIntegrity(vm, vm.getvNumaNodeList()), EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#end_block

#method_before
private Map<String, Object> createTicket(VM vm, GraphicsInfo graphicsInfo) {
    Map<String, Object> jsonModel = new HashMap<>();
    jsonModel.put("host", graphicsInfo.getIp());
    Integer tlsPort = graphicsInfo.getTlsPort();
    final GraphicsType type = getParameters().getGraphicsType();
    boolean useSsl = false;
    if (type == GraphicsType.SPICE) {
        useSsl = tlsPort != null ? tlsPort != -1 : false;
    } else {
        final VDS host = vdsDao.getByName(vm.getVmHost());
        useSsl = host != null && host.isVncEncryptionEnabled();
        tlsPort = graphicsInfo.getPort();
    }
    int port = useSsl ? tlsPort : graphicsInfo.getPort();
    jsonModel.put("port", String.valueOf(port));
    jsonModel.put("ssl_target", useSsl);
    return jsonModel;
}
#method_after
private Map<String, Object> createTicket(VM vm, GraphicsInfo graphicsInfo) {
    Map<String, Object> jsonModel = new HashMap<>();
    jsonModel.put("host", graphicsInfo.getIp());
    Integer tlsPort = graphicsInfo.getTlsPort();
    final GraphicsType type = getParameters().getGraphicsType();
    boolean useSsl = false;
    if (type == GraphicsType.SPICE) {
        useSsl = tlsPort != null ? tlsPort != -1 : false;
    } else {
        final VdsDynamic host = vdsDynamicDao.get(vm.getRunOnVds());
        useSsl = host != null && host.isVncEncryptionEnabled();
        tlsPort = graphicsInfo.getPort();
    }
    int port = useSsl ? tlsPort : graphicsInfo.getPort();
    jsonModel.put("port", String.valueOf(port));
    jsonModel.put("ssl_target", useSsl);
    return jsonModel;
}
#end_block

#method_before
protected static String getLatestGuestToolsVersion(Set<String> isoList) {
    String latestVersion = null;
    for (String iso : isoList) {
        if (iso.toLowerCase().contains("rhev-toolssetup") || iso.toLowerCase().contains("rhv-toolssetup")) {
            Matcher m = ISO_VERSION_PATTERN.matcher(iso.toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String isoVersion = m.group(1).replace('_', '.');
                if (latestVersion == null) {
                    latestVersion = isoVersion;
                } else if (latestVersion.compareTo(isoVersion) < 0) {
                    latestVersion = isoVersion;
                }
            }
        }
    }
    return latestVersion;
}
#method_after
protected static String getLatestGuestToolsVersion(Set<String> isoList) {
    String latestVersion = null;
    for (String iso : isoList) {
        Matcher m = ISO_VERSION_PATTERN.matcher(iso.toLowerCase());
        if (m.matches() && m.groupCount() > 0) {
            String isoVersion = m.group(1).replace('_', '.');
            if (latestVersion == null) {
                latestVersion = isoVersion;
            } else if (latestVersion.compareTo(isoVersion) < 0) {
                latestVersion = isoVersion;
            }
        }
    }
    return latestVersion;
}
#end_block

#method_before
public static Stream<MockConfigDescriptor<?>> mockConfiguration() {
    return Stream.concat(AbstractQueryTest.mockConfiguration(), Stream.of(MockConfigDescriptor.of(ConfigValues.CustomBondNameSupported, Version.getLast(), true)));
}
#method_after
public static Stream<MockConfigDescriptor<?>> mockConfiguration() {
    return Stream.concat(AbstractQueryTest.mockConfiguration(), Stream.of(MockConfigDescriptor.of(ConfigValues.CustomBondNameSupported, Version.getLast(), true), MockConfigDescriptor.of(ConfigValues.CustomBondNameSupported, Version.v4_2, false)));
}
#end_block

#method_before
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, ChipsetType chipset, AsyncQuery<List<DiskInterface>> asyncQuery) {
    asyncQuery.converterCallback = returnValue -> {
        ArrayList<String> interfaces = (ArrayList<String>) returnValue;
        List<DiskInterface> interfaceTypes = new ArrayList<>();
        for (String diskIfs : interfaces) {
            try {
                interfaceTypes.add(DiskInterface.valueOf(diskIfs));
            } catch (IllegalArgumentException e) {
            // ignore if we can't find the enum value.
            }
        }
        return interfaceTypes;
    };
    Frontend.getInstance().runQuery(QueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion, chipset), asyncQuery);
}
#end_block

#method_before
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public ArrayList<DiskInterface> getDiskInterfaceList() {
    return new ArrayList<>(Arrays.asList(DiskInterface.values()));
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        queryTLVInformation();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(QueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), new AsyncQuery<QueryReturnValue>(returnValue -> {
        allBonds = returnValue.getReturnValue();
        queryCustomBondNameSupport();
        queryTLVInformation();
        initNetworkModels();
        initNicModels();
        stopProgress();
    }));
}
#end_block

#method_before
private void queryCustomBondNameSupport() {
    AsyncDataProvider.getInstance().getCustomBondNameSupported(new AsyncQuery<>(returnValue -> {
        customBondNameSupported = returnValue;
        // chain free bonds query
        queryFreeBonds();
    }), getEntity().getClusterCompatibilityVersion());
}
#method_after
private void queryCustomBondNameSupport() {
    AsyncDataProvider.getInstance().getCustomBondNameSupported(new AsyncQuery<>(returnValue -> {
        customBondNameSupported = returnValue;
    }), getEntity().getClusterCompatibilityVersion());
}
#end_block

#method_before
private void queryVfMap() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(QueryType.GetVfToPfMapByHostId, params, new AsyncQuery<QueryReturnValue>(returnValue -> {
        vfMap = returnValue.getReturnValue();
        if (vfMap == null) {
            vfMap = Collections.emptyMap();
        }
        // chain the custom bond name support query
        queryCustomBondNameSupport();
    // queryFreeBonds();
    }));
}
#method_after
private void queryVfMap() {
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(QueryType.GetVfToPfMapByHostId, params, new AsyncQuery<QueryReturnValue>(returnValue -> {
        vfMap = returnValue.getReturnValue();
        if (vfMap == null) {
            vfMap = Collections.emptyMap();
        }
        // chain the free bonds query
        queryFreeBonds();
    }));
}
#end_block

#method_before
public boolean validate(boolean customBondNameSupported) {
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), new BondNameValidation(customBondNameSupported) });
    getCustomBondEditor().setIsValid(true);
    if (getBondingOptions().getSelectedItem().getKey().equals(CUSTOM_BONDING_MODE)) {
        getCustomBondEditor().validateEntity(new IValidation[] { new KeyValueFormatValidation() });
    }
    return getBond().getIsValid() && getCustomBondEditor().getIsValid();
}
#method_after
public boolean validate(boolean customBondNameSupported) {
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), customBondNameSupported ? CUSTOM_BOND_NAME_VALIDATION : NUM_ONLY_BOND_NAME_VALIDATION });
    getCustomBondEditor().setIsValid(true);
    if (getBondingOptions().getSelectedItem().getKey().equals(CUSTOM_BONDING_MODE)) {
        getCustomBondEditor().validateEntity(new IValidation[] { new KeyValueFormatValidation() });
    }
    return getBond().getIsValid() && getCustomBondEditor().getIsValid();
}
#end_block

#method_before
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    if (clusterSupportsHostCpu && !clusterHasPpcArchitecture()) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setIsChangeable(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
    }
}
#method_after
public void updateUseHostCpuAvailability() {
    boolean clusterSupportsHostCpu = getCompatibilityVersion() != null;
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    if (isAutoAssign == null) {
        return;
    }
    if (clusterSupportsHostCpu && !clusterHasPpcArchitecture() && Boolean.FALSE.equals(isAutoAssign)) {
        getModel().getHostCpu().setIsChangeable(true);
    } else {
        getModel().getHostCpu().setEntity(false);
        getModel().getHostCpu().setIsChangeable(false);
        getModel().getHostCpu().setChangeProhibitionReason(constants.hosCPUUnavailable());
    }
}
#end_block

#method_before
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    Boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    if (isAutoAssign == null || isHighlyAvailable == null) {
        return;
    }
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (!automaticMigrationAllowed && getModel().getVmType().getSelectedItem() != VmType.HighPerformance && !isVmPinningConfigurationEnabled() && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2) && !isHighlyAvailable) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
        isHighlyAvailable = false;
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || getModel().getVmType().getSelectedItem() == VmType.HighPerformance || isVmPinningConfigurationEnabled() || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#method_after
public void updateHaAvailability() {
    boolean automaticMigrationAllowed = getModel().getMigrationMode().getSelectedItem() == MigrationSupport.MIGRATABLE;
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    Boolean isHighlyAvailable = getModel().getIsHighlyAvailable().getEntity();
    Boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    if (isAutoAssign == null || isHighlyAvailable == null) {
        return;
    }
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (!automaticMigrationAllowed && !isVmHpOrPinningConfigurationEnabled() && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2) && !isHighlyAvailable) {
        getModel().getIsHighlyAvailable().setChangeProhibitionReason(constants.hostNonMigratable());
        getModel().getIsHighlyAvailable().setEntity(false);
        isHighlyAvailable = false;
    }
    getModel().getIsHighlyAvailable().setIsChangeable(isHighlyAvailable || automaticMigrationAllowed || isVmHpOrPinningConfigurationEnabled() || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#end_block

#method_before
public void updateMigrationAvailability() {
    if (getModel().getIsHighlyAvailable().getEntity() == null || getModel().getDefaultHost().getItems() == null || getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    final boolean haHost = getModel().getIsHighlyAvailable().getEntity();
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    final boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (haHost && getModel().getVmType().getSelectedItem() != VmType.HighPerformance && !isVmPinningConfigurationEnabled() && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2)) {
        getModel().getMigrationMode().setChangeProhibitionReason(constants.hostIsHa());
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
    getModel().getMigrationMode().setIsChangeable(getModel().getVmType().getSelectedItem() == VmType.HighPerformance || isVmPinningConfigurationEnabled() || !haHost || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#method_after
public void updateMigrationAvailability() {
    if (getModel().getIsHighlyAvailable().getEntity() == null || getModel().getDefaultHost().getItems() == null || getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    final boolean haHost = getModel().getIsHighlyAvailable().getEntity();
    final Collection<VDS> allowedHosts = getModel().getDefaultHost().getSelectedItems();
    Collection<VDS> presentHosts = getModel().getDefaultHost().getItems();
    int pinToHostSize = allowedHosts == null ? 0 : allowedHosts.size();
    final boolean isAutoAssign = getModel().getIsAutoAssign().getEntity();
    // This is needed for the unittests to not crash..
    if (presentHosts == null) {
        presentHosts = new ArrayList<>();
    }
    if (haHost && !isVmHpOrPinningConfigurationEnabled() && (pinToHostSize == 1 || (pinToHostSize == 0 && presentHosts.size() < 2)) && (!isAutoAssign || presentHosts.size() < 2)) {
        getModel().getMigrationMode().setChangeProhibitionReason(constants.hostIsHa());
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
    getModel().getMigrationMode().setIsChangeable(isVmHpOrPinningConfigurationEnabled() || !haHost || (isAutoAssign && presentHosts.size() >= 2) || pinToHostSize >= 2 || (pinToHostSize == 0 && presentHosts.size() >= 2));
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type & ppc architecture
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop && !clusterHasPpcArchitecture());
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    if (vmType == VmType.Server) {
        getModel().getIoThreadsEnabled().setEntity(true);
    }
    // Configuration relevant only for High Performance
    if (vmType == VmType.HighPerformance) {
        // Console tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resource allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
        getModel().getIoThreadsEnabled().setEntity(true);
        if (getModel().getMultiQueues().getIsAvailable()) {
            getModel().getMultiQueues().setEntity(true);
        }
    } else {
        getModel().getHostCpu().setEntity(false);
    }
    // Configuration relevant for either High Performance or VMs with pinned configuration
    if (vmType == VmType.HighPerformance || isVmPinningConfigurationEnabled()) {
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    } else {
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
}
#method_after
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type & ppc architecture
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop && !clusterHasPpcArchitecture());
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    if (vmType == VmType.Server) {
        getModel().getIoThreadsEnabled().setEntity(true);
    }
    // Configuration relevant only for High Performance
    if (vmType == VmType.HighPerformance) {
        // Console tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resource allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
        getModel().getIoThreadsEnabled().setEntity(true);
        if (getModel().getMultiQueues().getIsAvailable()) {
            getModel().getMultiQueues().setEntity(true);
        }
    } else {
        getModel().getHostCpu().setEntity(false);
    }
    // Configuration relevant for either High Performance or VMs with pinned configuration
    if (isVmHpOrPinningConfigurationEnabled()) {
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    } else {
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.MIGRATABLE);
    }
}
#end_block

#method_before
protected DiskProfiles mapCollection(List<org.ovirt.engine.core.common.businessentities.profiles.DiskProfile> entities) {
    DiskProfiles collection = new DiskProfiles();
    Map<Guid, List<Qos>> qosMap = new HashMap<>();
    for (org.ovirt.engine.core.common.businessentities.profiles.DiskProfile entity : entities) {
        DiskProfile profile = populate(map(entity), entity);
        collection.getDiskProfiles().add(profile);
        if (entity.getQosId() != null) {
            List<Qos> qosList = qosMap.get(entity.getQosId());
            if (qosList == null) {
                qosList = new ArrayList<>();
                qosMap.put(entity.getQosId(), qosList);
            }
            qosList.add(profile.getQos());
        }
    }
    handleQosDataCenterLinks(qosMap);
    for (DiskProfile diskProfile : collection.getDiskProfiles()) {
        addLinks(diskProfile);
    }
    return collection;
}
#method_after
protected DiskProfiles mapCollection(List<org.ovirt.engine.core.common.businessentities.profiles.DiskProfile> entities) {
    DiskProfiles collection = new DiskProfiles();
    Map<Guid, List<Qos>> qosMap = new HashMap<>();
    for (org.ovirt.engine.core.common.businessentities.profiles.DiskProfile entity : entities) {
        DiskProfile profile = populate(map(entity), entity);
        collection.getDiskProfiles().add(profile);
        if (entity.getQosId() != null) {
            List<Qos> qosList = qosMap.computeIfAbsent(entity.getQosId(), id -> new ArrayList<>());
            qosList.add(profile.getQos());
        }
    }
    handleQosDataCenterLinks(qosMap);
    for (DiskProfile diskProfile : collection.getDiskProfiles()) {
        addLinks(diskProfile);
    }
    return collection;
}
#end_block

#method_before
private void handleQosDataCenterLinks(Map<Guid, List<Qos>> qosMap) {
    if (!qosMap.isEmpty()) {
        List<StorageQos> list = getBackendCollection(StorageQos.class, QueryType.GetAllQosByType, new QosQueryParameterBase(null, QosType.STORAGE));
        for (StorageQos storageQos : list) {
            List<Qos> qosList = qosMap.get(storageQos.getId());
            if (qosList != null) {
                DataCenter dc = new DataCenter();
                for (Qos qos : qosList) {
                    qos.setDataCenter(dc);
                    qos.getDataCenter().setId(storageQos.getStoragePoolId().toString());
                }
            }
        }
    }
}
#method_after
private void handleQosDataCenterLinks(Map<Guid, List<Qos>> qosMap) {
    if (!qosMap.isEmpty()) {
        List<StorageQos> list = getBackendCollection(StorageQos.class, QueryType.GetAllQosByType, new QosQueryParameterBase(null, QosType.STORAGE));
        for (StorageQos storageQos : list) {
            List<Qos> qosList = qosMap.get(storageQos.getId());
            if (qosList != null) {
                DataCenter dc = new DataCenter();
                dc.setId(storageQos.getStoragePoolId().toString());
                for (Qos qos : qosList) {
                    qos.setDataCenter(dc);
                }
            }
        }
    }
}
#end_block

#method_before
private int hostScore(VM vm, VDS host) {
    if (vm.getVmType() != VmType.HighPerformance) {
        return 1;
    }
    int vmSockets = vm.getNumOfSockets();
    int vmCores = vmSockets * vm.getCpuPerSocket();
    int vmThreads = vmCores * vm.getThreadsPerCpu();
    if (vmSockets <= host.getCpuSockets() && vmCores <= host.getCpuCores() && vmThreads <= host.getCpuThreads()) {
        return 1;
    }
    return getMaxSchedulerWeight();
}
#method_after
private int hostScore(VM vm, VDS host) {
    if (!policyUnitEnabled(vm)) {
        return 1;
    }
    int hostCoresPerSocket = host.getCpuCores() / host.getCpuSockets();
    int hostThreadsPerCore = host.getCpuThreads() / host.getCpuCores();
    if (vm.getNumOfSockets() <= host.getCpuSockets() && vm.getCpuPerSocket() <= hostCoresPerSocket && vm.getThreadsPerCpu() <= hostThreadsPerCore) {
        return 1;
    }
    return getMaxSchedulerWeight();
}
#end_block

#method_before
@BeforeEach
public void setUp() {
    host1 = createHost(1, 8, 1);
    host2 = createHost(2, 4, 1);
    host3 = createHost(2, 2, 2);
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setNumOfSockets(2);
    vm.setCpuPerSocket(2);
    vm.setThreadsPerCpu(2);
}
#method_after
@BeforeEach
public void setUp() {
    host1 = createHost(8, 1, 1);
    host2 = createHost(4, 2, 1);
    host3 = createHost(2, 2, 2);
    host4 = createHost(1, 4, 2);
    host5 = createHost(4, 4, 4);
    vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setNumOfSockets(2);
    vm.setCpuPerSocket(2);
    vm.setThreadsPerCpu(2);
    doReturn(Collections.emptyList()).when(vmNumaNodeDao).getAllVmNumaNodeByVmId(vm.getId());
}
#end_block

#method_before
@Test
public void testScoreRegularVm() {
    vm.setVmType(VmType.Server);
    assertThat(score()).extracting("first", "second").contains(tuple(host1.getId(), 1), tuple(host2.getId(), 1), tuple(host3.getId(), 1));
}
#method_after
@Test
public void testScoreRegularVm() {
    vm.setVmType(VmType.Server);
    assertThat(score()).extracting("first", "second").contains(tuple(host1.getId(), 1), tuple(host2.getId(), 1), tuple(host3.getId(), 1), tuple(host4.getId(), 1), tuple(host5.getId(), 1));
}
#end_block

#method_before
@Test
public void testScoreHighPerformanceVm() {
    vm.setVmType(VmType.HighPerformance);
    assertThat(score()).extracting("first", "second").contains(tuple(host1.getId(), 1000), tuple(host2.getId(), 1), tuple(host3.getId(), 1));
}
#method_after
@Test
public void testScoreHighPerformanceVm() {
    vm.setVmType(VmType.HighPerformance);
    assertThat(score()).extracting("first", "second").contains(tuple(host1.getId(), 1000), tuple(host2.getId(), 1000), tuple(host3.getId(), 1), tuple(host4.getId(), 1000), tuple(host5.getId(), 1));
}
#end_block

#method_before
private List<Pair<Guid, Integer>> score() {
    return unit.score(null, Arrays.asList(host1, host2, host3), vm, null);
}
#method_after
private List<Pair<Guid, Integer>> score() {
    return unit.score(null, Arrays.asList(host1, host2, host3, host4, host5), vm, null);
}
#end_block

#method_before
public ArrayList<DiskInterface> getDiskInterfaceList() {
    return new ArrayList<>(Arrays.asList(DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI, DiskInterface.SATA));
}
#method_after
public ArrayList<DiskInterface> getDiskInterfaceList() {
    return new ArrayList<>(Arrays.asList(DiskInterface.values()));
}
#end_block

#method_before
public void updateVirtioScsiEnabled(final Guid vmId, int osId, VirtioScasiEnablingFinished finishedCallback) {
    this.finishedCallback = finishedCallback;
    final Cluster cluster = model.getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getInstance().getDiskInterfaceList(osId, cluster.getCompatibilityVersion(), ChipsetType.I440FX, model.asyncQuery(diskInterfaces -> {
        boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
        callBeforeUpdates();
        model.getIsVirtioScsiEnabled().setIsChangeable(isOsSupportVirtioScsi);
        if (!isOsSupportVirtioScsi) {
            model.getIsVirtioScsiEnabled().setEntity(false);
            model.getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            callAfterUpdates();
        } else {
            AsyncDataProvider.getInstance().isVirtioScsiEnabledForVm(model.asyncQuery(returnValue -> {
                model.getIsVirtioScsiEnabled().setEntity(returnValue);
                callAfterUpdates();
            }), vmId);
        }
    }));
}
#method_after
public void updateVirtioScsiEnabled(final Guid vmId, int osId, VirtioScasiEnablingFinished finishedCallback) {
    this.finishedCallback = finishedCallback;
    final Cluster cluster = model.getSelectedCluster();
    if (cluster == null) {
        return;
    }
    // VirtIO_SCSI is not chipset-dependent at the moment, so we can pass chipset == null to the call
    AsyncDataProvider.getInstance().getDiskInterfaceList(osId, cluster.getCompatibilityVersion(), null, model.asyncQuery(diskInterfaces -> {
        boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
        callBeforeUpdates();
        model.getIsVirtioScsiEnabled().setIsChangeable(isOsSupportVirtioScsi);
        if (!isOsSupportVirtioScsi) {
            model.getIsVirtioScsiEnabled().setEntity(false);
            model.getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            callAfterUpdates();
        } else {
            AsyncDataProvider.getInstance().isVirtioScsiEnabledForVm(model.asyncQuery(returnValue -> {
                model.getIsVirtioScsiEnabled().setEntity(returnValue);
                callAfterUpdates();
            }), vmId);
        }
    }));
}
#end_block

#method_before
private void DiskInterface_SelectedItemChanged() {
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiPassthrough().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsUsingScsiReservation().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsReadOnly().setIsAvailable(!DiskInterface.IDE.equals(diskInterface));
    updatePassDiscardAvailability();
    updateScsiPassthroughChangeability();
    updateScsiReservationChangeability();
    updateReadOnlyChangeability();
    updatePlugChangeability();
    updatePassDiscardChangeability();
    updateWipeAfterDeleteChangeability();
}
#method_after
private void DiskInterface_SelectedItemChanged() {
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiPassthrough().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsUsingScsiReservation().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsReadOnly().setIsAvailable(diskInterface != DiskInterface.IDE && diskInterface != DiskInterface.SATA);
    updatePassDiscardAvailability();
    updateScsiPassthroughChangeability();
    updateScsiReservationChangeability();
    updateReadOnlyChangeability();
    updatePlugChangeability();
    updatePassDiscardChangeability();
    updateWipeAfterDeleteChangeability();
}
#end_block

#method_before
protected void updatePassDiscardAvailability() {
    if (!AsyncDataProvider.getInstance().isPassDiscardFeatureSupported(getDataCenter().getSelectedItem().getCompatibilityVersion())) {
        getPassDiscard().setIsAvailable(false);
        return;
    }
    if (getIsFloating()) {
        getPassDiscard().setIsAvailable(false);
    } else {
        DiskInterface selectedInterface = getDiskInterface().getSelectedItem();
        DiskStorageType selectedDiskStorageType = getDiskStorageType().getEntity();
        boolean isApplicableInterface = selectedInterface == DiskInterface.VirtIO_SCSI || selectedInterface == DiskInterface.IDE;
        boolean isApplicableDiskStorageType = selectedDiskStorageType == DiskStorageType.LUN || selectedDiskStorageType == DiskStorageType.IMAGE;
        boolean isApplicableStorageType = selectedDiskStorageType == DiskStorageType.LUN || (getStorageDomain().getSelectedItem() != null && getStorageDomain().getSelectedItem().getStorageType().isInternal());
        if (isApplicableInterface && isApplicableDiskStorageType && isApplicableStorageType) {
            getPassDiscard().setIsAvailable(true);
            if (!getIsNew()) {
                getPassDiscard().setEntity(getDiskVmElement().isPassDiscard());
            }
        } else {
            // Reset PassDiscard's availability and value.
            getPassDiscard().setIsAvailable(false);
            getPassDiscard().setEntity(false);
        }
    }
}
#method_after
protected void updatePassDiscardAvailability() {
    if (!AsyncDataProvider.getInstance().isPassDiscardFeatureSupported(getDataCenter().getSelectedItem().getCompatibilityVersion())) {
        getPassDiscard().setIsAvailable(false);
        return;
    }
    if (getIsFloating()) {
        getPassDiscard().setIsAvailable(false);
    } else {
        DiskInterface selectedInterface = getDiskInterface().getSelectedItem();
        DiskStorageType selectedDiskStorageType = getDiskStorageType().getEntity();
        boolean isApplicableInterface = selectedInterface == DiskInterface.VirtIO_SCSI || selectedInterface == DiskInterface.IDE || selectedInterface == DiskInterface.SATA;
        boolean isApplicableDiskStorageType = selectedDiskStorageType == DiskStorageType.LUN || selectedDiskStorageType == DiskStorageType.IMAGE;
        boolean isApplicableStorageType = selectedDiskStorageType == DiskStorageType.LUN || (getStorageDomain().getSelectedItem() != null && getStorageDomain().getSelectedItem().getStorageType().isInternal());
        if (isApplicableInterface && isApplicableDiskStorageType && isApplicableStorageType) {
            getPassDiscard().setIsAvailable(true);
            if (!getIsNew()) {
                getPassDiscard().setEntity(getDiskVmElement().isPassDiscard());
            }
        } else {
            // Reset PassDiscard's availability and value.
            getPassDiscard().setIsAvailable(false);
            getPassDiscard().setEntity(false);
        }
    }
}
#end_block

#method_before
public ValidationResult isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI).unless(vmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, ChipsetType.I440FX, DiskInterface.VirtIO_SCSI));
}
#method_after
public ValidationResult isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion) {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI).unless(vmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, null, DiskInterface.VirtIO_SCSI));
}
#end_block

#method_before
private static String getLatestGuestToolsVersion(Set<String> isoList) {
    String latestVersion = null;
    for (String iso : isoList) {
        if (iso.toLowerCase().contains("rhev-toolssetup")) {
            Matcher m = ISO_VERSION_PATTERN.matcher(iso.toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String isoVersion = m.group(1).replace('_', '.');
                if (latestVersion == null) {
                    latestVersion = isoVersion;
                } else if (latestVersion.compareTo(isoVersion) < 0) {
                    latestVersion = isoVersion;
                }
            }
        }
    }
    return latestVersion;
}
#method_after
private static String getLatestGuestToolsVersion(Set<String> isoList) {
    String latestVersion = null;
    for (String iso : isoList) {
        if (iso.toLowerCase().contains("rhev-toolssetup") || iso.toLowerCase().contains("rhv-toolssetup")) {
            Matcher m = ISO_VERSION_PATTERN.matcher(iso.toLowerCase());
            if (m.matches() && m.groupCount() > 0) {
                String isoVersion = m.group(1).replace('_', '.');
                if (latestVersion == null) {
                    latestVersion = isoVersion;
                } else if (latestVersion.compareTo(isoVersion) < 0) {
                    latestVersion = isoVersion;
                }
            }
        }
    }
    return latestVersion;
}
#end_block

#method_before
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(diskVmElement.isReadOnly())) {
        DiskInterface diskInterface = diskVmElement.getDiskInterface();
        if (diskInterface == DiskInterface.IDE) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
        if (disk.isScsiPassthrough()) {
            return new ValidationResult(EngineMessage.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(diskVmElement.isReadOnly())) {
        DiskInterface diskInterface = diskVmElement.getDiskInterface();
        if (diskInterface == DiskInterface.IDE || diskInterface == DiskInterface.SATA) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
        if (disk.isScsiPassthrough()) {
            return new ValidationResult(EngineMessage.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isPassDiscardSupported(Guid storageDomainId) {
    if (!diskVmElement.isPassDiscard()) {
        return ValidationResult.VALID;
    }
    DiskInterface diskInterface = diskVmElement.getDiskInterface();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.IDE) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_INTERFACE, getDiskAliasVarReplacement());
    }
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        return isPassDiscardSupportedByUnderlyingStorageForDirectLun();
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        return isPassDiscardSupportedByUnderlyingStorageForDiskImage(storageDomainId);
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_STORAGE_TYPE, getDiskAliasVarReplacement(), String.format("$diskStorageType %s", disk.getDiskStorageType()));
}
#method_after
public ValidationResult isPassDiscardSupported(Guid storageDomainId) {
    if (!diskVmElement.isPassDiscard()) {
        return ValidationResult.VALID;
    }
    DiskInterface diskInterface = diskVmElement.getDiskInterface();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.IDE && diskInterface != DiskInterface.SATA) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_INTERFACE, getDiskAliasVarReplacement());
    }
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        return isPassDiscardSupportedByUnderlyingStorageForDirectLun();
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        return isPassDiscardSupportedByUnderlyingStorageForDiskImage(storageDomainId);
    }
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PASS_DISCARD_NOT_SUPPORTED_BY_DISK_STORAGE_TYPE, getDiskAliasVarReplacement(), String.format("$diskStorageType %s", disk.getDiskStorageType()));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Map<Guid, DiskImage> imagesAncestors = new HashMap<>();
    for (Guid id : getParameters().getIds()) {
        DiskImage ancestor = diskImageDao.getAncestor(id, getUserID(), getParameters().isFiltered());
        imagesAncestors.put(id, ancestor);
    }
    getQueryReturnValue().setReturnValue(imagesAncestors);
}
#method_after
@Override
protected void executeQueryCommand() {
    Set<Guid> haveInvalidAncestor = new HashSet<>();
    Function<Guid, DiskImage> getAncestor = (Guid imageId) -> {
        DiskImage ancestor = diskImageDao.getAncestor(imageId, getUserID(), getParameters().isFiltered());
        if (ancestor == null) {
            haveInvalidAncestor.add(imageId);
        }
        return ancestor;
    };
    Map<Guid, DiskImage> haveValidAncestor = getParameters().getIds().stream().map(guid -> new Pair<>(guid, getAncestor.apply(guid))).filter(pair -> pair.getSecond() != null).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond));
    if (!haveInvalidAncestor.isEmpty()) {
        log.warn("Ancestor is missing for the following image id(s): {}", StringUtils.join(haveInvalidAncestor, ','));
    }
    getQueryReturnValue().setReturnValue(haveValidAncestor);
}
#end_block

#method_before
public List<BalanceResult> invoke(List<VDS> sourceHosts, List<VDS> destinationHosts, VmDao vmDao, VmStatisticsDao vmStatisticsDao) {
    Map<Guid, List<VM>> vmsForHost = getMigratableVmsRunningOnHosts(vmDao, sourceHosts.stream().map(VDS::getId).collect(Collectors.toList()));
    List<Guid> allVmIds = vmsForHost.values().stream().flatMap(List::stream).map(VM::getId).collect(Collectors.toList());
    Map<Guid, VmStatistics> vmStatisticsMap = vmStatisticsDao.getByIds(allVmIds);
    List<BalanceResult> results = new ArrayList<>();
    for (VDS sourceHost : sourceHosts) {
        List<VM> migratableVms = vmsForHost.get(sourceHost.getId());
        // Statistics are needed for sorting by cpu usage
        migratableVms.forEach(vm -> vm.setStatisticsData(vmStatisticsMap.get(vm.getId())));
        migratableVms.sort(VmCpuUsageComparator.INSTANCE);
        for (VM vm : migratableVms) {
            // Check if vm not over utilize memory or CPU of destination hosts
            List<VDS> validDestinationHosts = getValidHosts(destinationHosts, cluster, vm, highCpuUtilization, requiredMemory);
            if (!validDestinationHosts.isEmpty()) {
                // Add the current host, it is possible it is the best host after all,
                // because the balancer does not know about affinity for example
                validDestinationHosts.add(sourceHost);
                results.add(new BalanceResult(vm.getId(), validDestinationHosts.stream().map(VDS::getId).collect(Collectors.toList())));
            }
        }
    }
    return results;
}
#method_after
public List<BalanceResult> invoke(List<VDS> sourceHosts, List<VDS> destinationHosts, VmDao vmDao, ResourceManager resourceManager) {
    Map<Guid, List<VM>> vmsForHost = getMigratableVmsRunningOnHosts(vmDao, sourceHosts.stream().map(VDS::getId).collect(Collectors.toList()));
    List<BalanceResult> results = new ArrayList<>();
    for (VDS sourceHost : sourceHosts) {
        List<VM> migratableVms = vmsForHost.get(sourceHost.getId());
        // Statistics are needed for sorting by cpu usage
        migratableVms.forEach(vm -> vm.setStatisticsData(resourceManager.getVmManager(vm.getId(), false).getStatistics()));
        migratableVms.sort(VmCpuUsageComparator.INSTANCE);
        for (VM vm : migratableVms) {
            // Check if vm not over utilize memory or CPU of destination hosts
            List<VDS> validDestinationHosts = getValidHosts(destinationHosts, cluster, vm, highCpuUtilization, requiredMemory);
            if (!validDestinationHosts.isEmpty()) {
                // Add the current host, it is possible it is the best host after all,
                // because the balancer does not know about affinity for example
                validDestinationHosts.add(sourceHost);
                results.add(new BalanceResult(vm.getId(), validDestinationHosts.stream().map(VDS::getId).collect(Collectors.toList())));
            }
        }
    }
    return results;
}
#end_block

#method_before
private List<BalanceResult> getBalance(FindVmAndDestinations findVmAndDestinations, final List<VDS> overUtilizedHosts, final List<VDS> underUtilizedHosts) {
    return findVmAndDestinations.invoke(overUtilizedHosts, underUtilizedHosts, vmDao, vmStatisticsDao);
}
#method_after
private List<BalanceResult> getBalance(FindVmAndDestinations findVmAndDestinations, final List<VDS> overUtilizedHosts, final List<VDS> underUtilizedHosts) {
    return findVmAndDestinations.invoke(overUtilizedHosts, underUtilizedHosts, vmDao, resourceManager);
}
#end_block

#method_before
protected void initMocks(CpuAndMemoryBalancingPolicyUnit unit, Map<Guid, VDS> hosts, Map<Guid, VM> vms) throws ParseException {
    doReturn(TIME_FORMAT.parse("2015-01-01 12:00:00")).when(unit).getTime();
    doAnswer(invocation -> {
        Collection<Guid> hostIds = invocation.getArgument(0);
        return vms.values().stream().filter(vm -> hostIds.contains(vm.getRunOnVds())).collect(Collectors.groupingBy(VM::getRunOnVds));
    }).when(vmDao).getAllRunningForMultipleVds(any(Collection.class));
    for (Map.Entry<Guid, VM> vm : vms.entrySet()) {
        doReturn(vm.getValue()).when(vmDao).get(vm.getKey());
    }
    doAnswer(invocation -> {
        Collection<Guid> vmIds = invocation.getArgument(0);
        return vmIds.stream().collect(Collectors.toMap(id -> id, id -> vms.get(id).getStatisticsData()));
    }).when(vmStatisticsDao).getByIds(any(Collection.class));
}
#method_after
protected void initMocks(CpuAndMemoryBalancingPolicyUnit unit, Map<Guid, VDS> hosts, Map<Guid, VM> vms) throws ParseException {
    doReturn(TIME_FORMAT.parse("2015-01-01 12:00:00")).when(unit).getTime();
    doAnswer(invocation -> {
        Collection<Guid> hostIds = invocation.getArgument(0);
        return vms.values().stream().filter(vm -> hostIds.contains(vm.getRunOnVds())).collect(Collectors.groupingBy(VM::getRunOnVds));
    }).when(vmDao).getAllRunningForMultipleVds(any(Collection.class));
    for (Map.Entry<Guid, VM> vm : vms.entrySet()) {
        doReturn(vm.getValue()).when(vmDao).get(vm.getKey());
        VmManager vmManagerMock = mock(VmManager.class);
        doReturn(vm.getValue().getStatisticsData()).when(vmManagerMock).getStatistics();
        doReturn(vmManagerMock).when(resourceManager).getVmManager(eq(vm.getKey()), anyBoolean());
    }
}
#end_block

#method_before
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    List<LongRange> overlappingRanges = new LinkedList<>();
    this.macsStorage = createMacsStorage(this.rangesBoundaries, overlappingRanges);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    if (!overlappingRanges.isEmpty()) {
        StringBuilder builder = new StringBuilder();
        overlappingRanges.forEach(range -> builder.append(macToString(range.getMinimumLong())).append("-").append(macToString(range.getMaximumLong())).append(", "));
        String rangeReport = builder.delete(builder.length() - 2, builder.length() - 1).toString();
        String msg = String.format("MAC ranges %s overlap existing ranges in MAC pool '%s'", rangeReport, getId());
        log.warn(msg);
        AuditLogableImpl auditLoggable = new AuditLogableImpl();
        auditLoggable.addCustomValue("overlapping", rangeReport);
        auditLogDirector.log(auditLoggable, AuditLogType.MAC_POOL_VIOLATES_NO_OVERLAPPING_RANGES, msg);
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#method_after
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(this.rangesBoundaries);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#end_block

#method_before
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries, List<LongRange> overlappingRanges) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange longRange : rangesBoundaries) {
        log.debug("Adding range {} to pool {}.", longRange, this);
        Range range = new Range(longRange);
        if (macsStorage.overlaps(range)) {
            overlappingRanges.add(longRange);
        }
        macsStorage.addRange(range);
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#method_after
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange longRange : rangesBoundaries) {
        log.debug("Adding range {} to pool {}.", longRange, this);
        macsStorage.addRange(new Range(longRange));
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#end_block

#method_before
@PostConstruct
void initialize() {
    try {
        List<org.ovirt.engine.core.common.businessentities.MacPool> macPools = macPoolDao.getAll();
        for (org.ovirt.engine.core.common.businessentities.MacPool macPool : macPools) {
            createPoolInternal(macPool, true);
        }
        log.info("Successfully initialized");
    } catch (RuntimeException e) {
        log.error("Error initializing: {}", e.getMessage());
        throw e;
    }
}
#method_after
@PostConstruct
void initialize() {
    try {
        List<org.ovirt.engine.core.common.businessentities.MacPool> macPools = macPoolDao.getAll();
        for (org.ovirt.engine.core.common.businessentities.MacPool macPool : macPools) {
            createPoolInternal(macPool, true);
        }
        try (AutoCloseableLock lock = readLockResource()) {
            Set<Pair<MacPool, MacPool>> overlappingPools = computeOverlappingPools();
            if (!overlappingPools.isEmpty()) {
                reportOverlaps(overlappingPools);
            }
        }
        log.info("Successfully initialized");
    } catch (RuntimeException e) {
        log.error("Error initializing: {}", e.getMessage());
        throw e;
    }
}
#end_block

#method_before
private MacPool createPoolInternal(org.ovirt.engine.core.common.businessentities.MacPool macPool, boolean engineStartup) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    log.debug("Creating new MacPool {}.", macPool);
    MacPool poolForScope = macPoolFactory.createMacPool(macPool, engineStartup);
    boolean isOverlapping = macPools.entrySet().stream().anyMatch(poolEntry -> poolEntry.getKey() != poolForScope.getId() && poolEntry.getValue().overlaps(poolForScope));
    if (isOverlapping) {
        String msg = "MAC pool '%s' overlaps with other MAC pools in the system";
        log.warn(String.format(msg, macPool.getName()));
        auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_POOL_VIOLATES_NO_OVERLAPPING_RANGES, String.format(msg, macPool.getName()));
    }
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#method_after
private MacPool createPoolInternal(org.ovirt.engine.core.common.businessentities.MacPool macPool, boolean engineStartup) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    log.debug("Creating new MacPool {}.", macPool);
    MacPool poolForScope = macPoolFactory.createMacPool(macPool, engineStartup);
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#end_block

#method_before
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    List<LongRange> overlappingRanges = new LinkedList<>();
    this.macsStorage = createMacsStorage(this.rangesBoundaries, overlappingRanges);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    if (!overlappingRanges.isEmpty()) {
        StringBuilder builder = new StringBuilder();
        overlappingRanges.forEach(range -> builder.append(macToString(range.getMinimumLong())).append("-").append(macToString(range.getMaximumLong())).append(", "));
        String rangeReport = builder.delete(builder.length() - 2, builder.length() - 1).toString();
        String msg = String.format("MAC ranges %s overlap existing ranges in MAC pool '%s'", rangeReport, getId());
        log.warn(msg);
        AuditLogableImpl auditLoggable = new AuditLogableImpl();
        auditLoggable.addCustomValue("overlapping", rangeReport);
        auditLogDirector.log(auditLoggable, AuditLogType.MAC_POOL_VIOLATES_NO_OVERLAPPING_RANGES, msg);
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#method_after
void initialize(boolean engineStartup, List<String> macsForMacPool) {
    log.info("Initializing {}", this);
    this.macsStorage = createMacsStorage(this.rangesBoundaries);
    log.debug("Initializing {} with macs: {}", this, macsForMacPool);
    List<String> notAddedMacs = addMacs(macsForMacPool);
    if (!notAddedMacs.isEmpty()) {
        if (engineStartup) {
            String auditLogMessage = "Following MACs violates duplicity restriction, and was pushed into MAC pool without respect to it:" + notAddedMacs;
            auditLogDirector.log(new AuditLogableImpl(), AuditLogType.MAC_ADDRESS_VIOLATES_NO_DUPLICATES_SETTING, auditLogMessage);
            forceAddMacs(notAddedMacs);
        } else {
            throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED, "Unable to initialize MAC pool due to existing duplicates");
        }
    }
    log.info("Finished initializing {}. Available MACs in pool: {}", this, macsStorage.getAvailableMacsCount());
}
#end_block

#method_before
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries, List<LongRange> overlappingRanges) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange longRange : rangesBoundaries) {
        log.debug("Adding range {} to pool {}.", longRange, this);
        Range range = new Range(longRange);
        if (macsStorage.overlaps(range)) {
            overlappingRanges.add(longRange);
        }
        macsStorage.addRange(range);
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#method_after
private MacsStorage createMacsStorage(Collection<LongRange> rangesBoundaries) {
    MacsStorage macsStorage = new MacsStorage(allowDuplicates);
    for (LongRange longRange : rangesBoundaries) {
        log.debug("Adding range {} to pool {}.", longRange, this);
        macsStorage.addRange(new Range(longRange));
    }
    if (macsStorage.availableMacExist()) {
        return macsStorage;
    } else {
        throw new EngineException(EngineError.MAC_POOL_INITIALIZATION_FAILED);
    }
}
#end_block

#method_before
public boolean overlaps(Range other) {
    return range.overlapsRange(other.getRange());
}
#method_after
boolean overlaps(Range other) {
    return range.overlapsRange(other.range);
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    Guid storagePoolId = null;
    ArrayList<VDSDomainsData> domainsList = null;
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
        // synchronized part of code
        if (domainsList != null) {
            updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
        }
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        Guid storagePoolId = null;
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    setDomains(cachedVds.getDomains());
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
        }
        // synchronized part of code
        if (getDomains() != null) {
            updateVdsDomainsData(cachedVds, storagePoolId, getDomains());
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
public static ValidationResult checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<DiskVmElement> diskVmElements, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled) {
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += diskVmElements.stream().filter(dve -> dve.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = Injector.get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    ArrayList<EngineMessage> messages = new ArrayList<>();
    if (pciInUse > maxPciSlots) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
    } else if (VmCommand.MAX_IDE_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
    } else if (VmCommand.MAX_SATA_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SATA).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
    } else if (VmCommand.MAX_VIRTIO_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS);
    } else if (VmCommand.MAX_SPAPR_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS);
    }
    if (!messages.isEmpty()) {
        return new ValidationResult(messages);
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<? extends VmNic> interfaces, List<DiskVmElement> diskVmElements, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled) {
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += diskVmElements.stream().filter(dve -> dve.getDiskInterface() == DiskInterface.VirtIO).count();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = Injector.get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    ArrayList<EngineMessage> messages = new ArrayList<>();
    if (pciInUse > maxPciSlots) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS);
    } else if (VmCommand.MAX_IDE_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.IDE).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS);
    } else if (VmCommand.MAX_SATA_SLOTS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SATA).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SATA_SLOTS);
    } else if (VmCommand.MAX_VIRTIO_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.VirtIO_SCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS);
    } else if (VmCommand.MAX_SPAPR_SCSI_DISKS < diskVmElements.stream().filter(a -> a.getDiskInterface() == DiskInterface.SPAPR_VSCSI).count()) {
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS);
    }
    if (!messages.isEmpty()) {
        return new ValidationResult(messages);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) {
    StorageType storageType = diskImage.getStorageTypes().get(0);
    String diskType = getDiskType(vm, diskImage, device);
    boolean isNativeIO = !"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion()));
    // marked as transient disk and uses cache when snapshotId is not null
    if ("file".equals(diskType) && device.getSnapshotId() != null) {
        isNativeIO = false;
    }
    return isNativeIO;
}
#method_after
public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) {
    StorageType storageType = diskImage.getStorageTypes().get(0);
    String diskType = getDiskType(vm, diskImage, device);
    return (!"file".equals(diskType) || (storageType == StorageType.GLUSTERFS && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion()))) && device.getSnapshotId() == null;
// marked as transient disk (file type) and uses cache when snapshotId is not null
// so native io should not be used
}
#end_block

#method_before
private void checkDiff() {
    try {
        getConfigDao().getConfigDiff().stream().forEach(configDiff -> console.writeFormat("Option name: %s, Current value: %s, Default value: %s, version: %s\n", configDiff.getOptionName(), configDiff.getOptionValue(), configDiff.getDefaultValue(), configDiff.getVersion()));
    } catch (Exception e) {
        log.debug("Error details: ", e);
    }
}
#method_after
private void checkDiff() {
    try {
        getConfigDao().getConfigDiff().stream().filter(configKey -> configKey.getKey() != null).forEach(configDiff -> console.writeFormat("Name: %s\n" + "Version: %s\n" + "Current: %s\n" + "Default: %s\n\n", configDiff.getKey(), configDiff.getVersion(), configDiff.getValue(), configDiff.getDefaultValue()));
    } catch (Exception e) {
        log.error("Error details: ", e);
    }
}
#end_block

#method_before
@Override
public List<EngineConfigLogic.ConfigDiff> getConfigDiff() throws SQLException {
    List<EngineConfigLogic.ConfigDiff> configDiffs = new ArrayList<>();
    try (Connection connection = ds.getConnection();
        PreparedStatement prepareStatement = connection.prepareStatement(getConfigDiff)) {
        try (ResultSet resultSet = prepareStatement.executeQuery()) {
            while (resultSet.next()) {
                EngineConfigLogic.ConfigDiff configDiff = new EngineConfigLogic.ConfigDiff();
                configDiff.setOptionName(resultSet.getString(nameColumn));
                configDiff.setOptionValue(resultSet.getString(valueColumn));
                configDiff.setDefaultValue(resultSet.getString(defaultColumn));
                configDiff.setVersion(resultSet.getString(versionColumn));
                configDiffs.add(configDiff);
            }
        }
    }
    return configDiffs;
}
#method_after
@Override
public List<ConfigKey> getConfigDiff() throws SQLException {
    List<ConfigKey> configDiffs = new ArrayList<>();
    try (Connection connection = ds.getConnection();
        PreparedStatement prepareStatement = connection.prepareStatement(selectConfigDiff)) {
        try (ResultSet resultSet = prepareStatement.executeQuery()) {
            while (resultSet.next()) {
                configDiffs.add(ConfigKeyFactory.getInstance().fromResultSet(resultSet));
            }
        }
    }
    return configDiffs;
}
#end_block

#method_before
public static boolean isScsiReservationSupported(Version version) {
    return supportedInConfig(ConfigValues.IsScsiReservationSupported, version);
}
#method_after
public static boolean isScsiReservationSupported(Version version) {
    return supportedInConfig(ConfigValues.ScsiReservationSupported, version);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    switch(getParameters().getImportPhase()) {
        case CREATE_DISKS:
            getParameters().setImportPhase(Phase.CONVERT);
            if (getParameters().getProxyHostId() == null) {
                getParameters().setProxyHostId(selectProxyHost());
            }
            break;
        case CONVERT:
            if (EnumSet.of(OriginType.KVM, OriginType.OVIRT).contains(getVm().getOrigin())) {
                deleteV2VJob();
                return false;
            }
            getParameters().setImportPhase(Phase.POST_CONVERT);
            break;
        case POST_CONVERT:
            return false;
        default:
    }
    persistCommandIfNeeded();
    executeNextOperation();
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    switch(getParameters().getImportPhase()) {
        case CREATE_DISKS:
            getParameters().setImportPhase(Phase.CONVERT);
            if (getParameters().getProxyHostId() == null) {
                getParameters().setProxyHostId(selectProxyHost());
            }
            break;
        case CONVERT:
            if (getVm().getOrigin() == OriginType.OVIRT) {
                return false;
            }
            getParameters().setImportPhase(Phase.POST_CONVERT);
            break;
        case POST_CONVERT:
            return false;
        default:
    }
    persistCommandIfNeeded();
    executeNextOperation();
    return true;
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
private void executeNextOperation() {
    switch(getParameters().getImportPhase()) {
        case CONVERT:
            convert();
            break;
        case POST_CONVERT:
            updateVm();
            break;
    }
}
#method_after
@SuppressWarnings("incomplete-switch")
private void executeNextOperation() {
    switch(getParameters().getImportPhase()) {
        case CONVERT:
            convert();
            break;
        case POST_CONVERT:
            if (getVm().getOrigin() == OriginType.KVM) {
                deleteV2VJob();
            } else {
                updateVm();
            }
            break;
    }
}
#end_block

#method_before
private void runAnsibleHostDeployPlaybook(Cluster hostCluster) throws IOException, InterruptedException {
    // TODO: Remove when we remove support for legacy oVirt node:
    if (getVds().getVdsType().equals(VDSType.oVirtVintageNode)) {
        log.warn("Skipping Ansible runner, because it isn't supported for legacy oVirt node.");
        return;
    }
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", hostCluster.getCompatibilityVersion()), new Pair<>("host_deploy_cluster_name", hostCluster.getName()), new Pair<>("host_deploy_cluster_switch_type", hostCluster.getRequiredSwitchTypeForCluster().getOptionValue()), new Pair<>("host_deploy_gluster_enabled", hostCluster.supportsGlusterService()), new Pair<>("host_deploy_virt_enabled", hostCluster.supportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", hostCluster.getFirewallType().name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_interface", NetworkUtils.getHostIp(getVds())), new Pair<>("host_deploy_ovn_central", getOvnCentral())).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.setCorrelationId(getCorrelationId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
    if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#method_after
private void runAnsibleHostDeployPlaybook(Cluster hostCluster) throws IOException, InterruptedException {
    // TODO: Remove when we remove support for legacy oVirt node:
    if (getVds().getVdsType().equals(VDSType.oVirtVintageNode)) {
        log.warn("Skipping Ansible runner, because it isn't supported for legacy oVirt node.");
        return;
    }
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", hostCluster.getCompatibilityVersion()), new Pair<>("host_deploy_cluster_name", hostCluster.getName()), new Pair<>("host_deploy_cluster_switch_type", hostCluster.getRequiredSwitchTypeForCluster().getOptionValue()), new Pair<>("host_deploy_gluster_enabled", hostCluster.supportsGlusterService()), new Pair<>("host_deploy_virt_enabled", hostCluster.supportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", hostCluster.getFirewallType().name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_interface", NetworkUtils.getHostIp(getVds())), new Pair<>("host_deploy_ovn_central", getOvnCentral()), new Pair<>("host_deploy_vnc_tls", hostCluster.isVncEncryptionEnabled() ? "true" : "false")).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.setCorrelationId(getCorrelationId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
    if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#end_block

#method_before
@Override
public SafeHtml getEntityValue(Cluster object) {
    if (object.isClusterCompatibilityLevelUpgradeNeeded()) {
        return getImageSafeHtml(IconType.EXCLAMATION);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityValue(Cluster object) {
    if (object.isClusterCompatibilityLevelUpgradeNeeded() || isDeprecated(object)) {
        return getImageSafeHtml(IconType.EXCLAMATION);
    }
    return null;
}
#end_block

#method_before
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    if (object.isClusterCompatibilityLevelUpgradeNeeded()) {
        return SafeHtmlUtils.fromTrustedString(constants.clusterLevelUpgradeNeeded());
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    SafeHtmlBuilder builder = new SafeHtmlBuilder();
    boolean hasWarning = false;
    if (hasWarning = object.isClusterCompatibilityLevelUpgradeNeeded()) {
        builder.appendHtmlConstant(constants.clusterLevelUpgradeNeeded());
    }
    if (isDeprecated(object)) {
        if (hasWarning) {
            // $NON-NLS-1$
            builder.appendHtmlConstant("<br/><br/>");
        }
        builder.appendEscaped(messages.cpuDeprecationWarning(object.getCpuName()));
        hasWarning = true;
    }
    if (hasWarning) {
        return builder.toSafeHtml();
    }
    return null;
}
#end_block

#method_before
@Override
public Networks list() {
    Networks networks;
    // LinkHelper behavior)
    if (isFiltered()) {
        networks = mapCollection(getBackendCollection(queryType, getQueryParameters(), SearchType.Network), LinkHelper.NO_PARENT);
    } else {
        networks = mapCollection(getBackendCollection(SearchType.Network), LinkHelper.NO_PARENT);
    }
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#method_after
@Override
public Networks list() {
    Networks networks;
    // includes the datacenter-id.
    if (isFiltered()) {
        networks = mapCollection(getBackendCollection(queryType, getQueryParameters(), SearchType.Network), LinkHelper.NO_PARENT);
    } else {
        networks = mapCollection(getBackendCollection(SearchType.Network), LinkHelper.NO_PARENT);
    }
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#end_block

#method_before
@Override
protected List<VDS> getPrimarySources(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    int highUtilization = tryParseWithDefault(parameters.get(PolicyUnitParameter.HIGH_UTILIZATION.getDbName()), Config.<Integer>getValue(ConfigValues.HighUtilizationForPowerSave));
    final int lowUtilization = tryParseWithDefault(parameters.get(PolicyUnitParameter.LOW_UTILIZATION.getDbName()), Config.<Integer>getValue(ConfigValues.LowUtilizationForPowerSave));
    final int cpuOverCommitDurationMinutes = tryParseWithDefault(parameters.get(PolicyUnitParameter.CPU_OVERCOMMIT_DURATION_MINUTES.getDbName()), Config.<Integer>getValue(ConfigValues.CpuOverCommitDurationMinutes));
    final int highVdsCount = Math.min(Config.<Integer>getValue(ConfigValues.UtilizationThresholdInPercent) * highUtilization / 100, highUtilization - Config.<Integer>getValue(ConfigValues.VcpuConsumptionPercentage));
    // Over-utilized hosts are in the front of the list, because it is more important
    // to migrate a VM from an over-utrilized host than from an under-utilized
    List<VDS> result = new ArrayList<>();
    result.addAll(getOverUtilizedCPUHosts(candidateHosts, highVdsCount, cpuOverCommitDurationMinutes));
    result.addAll(getUnderUtilizedCPUHosts(candidateHosts, lowUtilization, 1, cpuOverCommitDurationMinutes));
    return result;
}
#method_after
@Override
protected List<VDS> getPrimarySources(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    int highUtilization = tryParseWithDefault(parameters.get(PolicyUnitParameter.HIGH_UTILIZATION.getDbName()), Config.<Integer>getValue(ConfigValues.HighUtilizationForPowerSave));
    final int lowUtilization = tryParseWithDefault(parameters.get(PolicyUnitParameter.LOW_UTILIZATION.getDbName()), Config.<Integer>getValue(ConfigValues.LowUtilizationForPowerSave));
    final int cpuOverCommitDurationMinutes = tryParseWithDefault(parameters.get(PolicyUnitParameter.CPU_OVERCOMMIT_DURATION_MINUTES.getDbName()), Config.<Integer>getValue(ConfigValues.CpuOverCommitDurationMinutes));
    final int highVdsCount = Math.min(Config.<Integer>getValue(ConfigValues.UtilizationThresholdInPercent) * highUtilization / 100, highUtilization - Config.<Integer>getValue(ConfigValues.VcpuConsumptionPercentage));
    // Over-utilized hosts are in the front of the list, because it is more important
    // to migrate a VM from an over-utilized host than from an under-utilized
    List<VDS> result = new ArrayList<>();
    result.addAll(getOverUtilizedCPUHosts(candidateHosts, highVdsCount, cpuOverCommitDurationMinutes));
    result.addAll(getUnderUtilizedCPUHosts(candidateHosts, lowUtilization, 1, cpuOverCommitDurationMinutes));
    return result;
}
#end_block

#method_before
@Override
protected List<VDS> getSecondarySources(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    long highMemoryLimit = parameters.containsKey(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName())) : Long.MAX_VALUE;
    // Over-utilized hosts are in the front of the list, because it is more important
    // to migrate a VM from an over-utrilized host than from an under-utilized
    List<VDS> result = new ArrayList<>();
    result.addAll(getOverUtilizedMemoryHosts(candidateHosts, lowMemoryLimit));
    result.addAll(getUnderUtilizedMemoryHosts(candidateHosts, highMemoryLimit, 1));
    return result;
}
#method_after
@Override
protected List<VDS> getSecondarySources(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    long highMemoryLimit = parameters.containsKey(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.HIGH_MEMORY_LIMIT_FOR_UNDER_UTILIZED.getDbName())) : Long.MAX_VALUE;
    // Over-utilized hosts are in the front of the list, because it is more important
    // to migrate a VM from an over-utilized host than from an under-utilized
    List<VDS> result = new ArrayList<>();
    result.addAll(getHostsWithLessFreeMemory(candidateHosts, lowMemoryLimit));
    result.addAll(getHostsWithMoreFreeMemory(candidateHosts, highMemoryLimit, 1));
    return result;
}
#end_block

#method_before
@Override
protected List<VDS> getSecondaryDestinations(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    return getUnderUtilizedMemoryHosts(candidateHosts, lowMemoryLimit, 0);
}
#method_after
@Override
protected List<VDS> getSecondaryDestinations(Cluster cluster, List<VDS> candidateHosts, Map<String, String> parameters) {
    long lowMemoryLimit = parameters.containsKey(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName()) ? Long.parseLong(parameters.get(PolicyUnitParameter.LOW_MEMORY_LIMIT_FOR_OVER_UTILIZED.getDbName())) : 0L;
    return getHostsWithMoreFreeMemory(candidateHosts, lowMemoryLimit, 0);
}
#end_block

#method_before
@Override
public Optional<BalanceResult> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return Optional.empty();
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return Optional.empty();
    }
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    Optional<BalanceResult> result = Optional.empty();
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " based on the CPU usage, will try memory based approach", cluster.getName());
        } else {
            result = getBalance(findVmAndDestinations, overUtilizedPrimaryHosts, underUtilizedHosts);
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if (!result.isPresent() && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " using memory based approach", cluster.getName());
            return Optional.empty();
        }
        result = getBalance(findVmAndDestinations, overUtilizedSecondaryHosts, underUtilizedHosts);
    }
    // add the current host, it is possible it is the best host after all,
    // because the balancer does not know about affinity for example
    result.map(res -> {
        Guid currentHostId = res.getCurrentHost();
        if (currentHostId != null && !res.getCandidateHosts().contains(currentHostId)) {
            res.getCandidateHosts().add(currentHostId);
        }
        return res;
    });
    return result;
}
#method_after
@Override
public Optional<BalanceResult> balance(final Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    Objects.requireNonNull(hosts);
    Objects.requireNonNull(cluster);
    if (hosts.size() < 2) {
        log.debug("No balancing for cluster '{}', contains only {} host(s)", cluster.getName(), hosts.size());
        return Optional.empty();
    }
    final List<VDS> overUtilizedPrimaryHosts = getPrimarySources(cluster, hosts, parameters);
    final List<VDS> overUtilizedSecondaryHosts = getSecondarySources(cluster, hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if ((overUtilizedPrimaryHosts == null || overUtilizedPrimaryHosts.size() == 0) && (overUtilizedSecondaryHosts == null || overUtilizedSecondaryHosts.size() == 0)) {
        log.debug("There is no over-utilized host in cluster '{}'", cluster.getName());
        return Optional.empty();
    }
    FindVmAndDestinations findVmAndDestinations = getFindVmAndDestinations(cluster, parameters);
    Optional<BalanceResult> result = Optional.empty();
    // try balancing based on CPU first
    if (overUtilizedPrimaryHosts != null && overUtilizedPrimaryHosts.size() > 0) {
        // returns hosts with utilization lower than the specified threshold
        List<VDS> underUtilizedHosts = getPrimaryDestinations(cluster, hosts, parameters);
        /* if no host has a spare power, then there is nothing we can do to balance it here, try
               the secondary aporoach */
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " based on the CPU usage, will try memory based approach", cluster.getName());
        } else {
            result = getBalance(findVmAndDestinations, overUtilizedPrimaryHosts, underUtilizedHosts);
        }
    }
    // if it is not possible (or necessary) to balance based on CPU, try with memory
    if (!result.isPresent() && (overUtilizedSecondaryHosts != null && overUtilizedSecondaryHosts.size() > 0)) {
        // returns hosts with more free memory than the specified threshold
        List<VDS> underUtilizedHosts = getSecondaryDestinations(cluster, hosts, parameters);
        // if no host has memory to spare, then there is nothing we can do to balance it..
        if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
            log.warn("All candidate hosts have been filtered, can't balance the cluster '{}'" + " using memory based approach", cluster.getName());
            return Optional.empty();
        }
        result = getBalance(findVmAndDestinations, overUtilizedSecondaryHosts, underUtilizedHosts);
    }
    // add the current host, it is possible it is the best host after all,
    // because the balancer does not know about affinity for example
    Optional<BalanceResult> finalResult = result;
    result.map(BalanceResult::getCurrentHost).filter(Objects::nonNull).ifPresent(h -> finalResult.ifPresent(res -> res.getCandidateHosts().add(h)));
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
        networkClusterDao.save(managementNetworkCluster);
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    updateDefaultNetworkProvider();
    if (getCluster().getFirewallType() != oldCluster.getFirewallType()) {
        markHostsForReinstall();
    }
    if (getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
        markHostsForReinstall();
    }
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    alertIfFencingDisabled();
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.migrateMacsToAnotherMacPool(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    setDefaultFirewallTypeIfNeeded();
    setDefaultLogMaxMemoryUsedThresholdIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    TransactionSupport.executeInNewTransaction(() -> {
        CompensationUtils.updateEntity(getParameters().getCluster(), oldCluster, clusterDao, getCompensationContext());
        addOrUpdateAddtionalClusterFeatures();
        getCompensationContext().stateChanged();
        return null;
    });
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            parameters.setCompensationEnabled(true);
            ActionReturnValue addVdsSpmIdReturn = runInternalAction(ActionType.AddVdsSpmId, parameters, cloneContextWithNoCleanupCompensation());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        TransactionSupport.executeInNewTransaction(() -> {
            final NetworkCluster managementNetworkCluster = createManagementNetworkCluster();
            CompensationUtils.saveEntity(managementNetworkCluster, networkClusterDao, getCompensationContext());
            getCompensationContext().stateChanged();
            return null;
        });
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    // Executing the rest of the command in one transaction.
    // This avoids using compensation context inside functions
    // called here, which would be tricky.
    // 
    // If anything fails, this transaction is not committed and
    // changes committed before this block are reverted using compensation.
    TransactionSupport.executeInNewTransaction(() -> {
        updateDefaultNetworkProvider();
        if (getCluster().getFirewallType() != oldCluster.getFirewallType() || getCluster().isVncEncryptionEnabled() != oldCluster.isVncEncryptionEnabled()) {
            markHostsForReinstall();
        }
        if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
            // update gluster parameters on all hosts
            updateGlusterHosts();
        }
        alertIfFencingDisabled();
        boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != oldCluster.isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != oldCluster.isEnableKsm());
        if (isKsmPolicyChanged) {
            momPolicyUpdatedEvent.fire(getCluster());
        }
        if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
            vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
        }
        return null;
    });
    setSucceeded(true);
}
#end_block

#method_before
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        updateResumeBehavior(vm);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#method_after
private void updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateParams.setCompensationEnabled(true);
        upgradeGraphicsDevices(vm, updateParams);
        updateResumeBehavior(vm);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        ActionReturnValue result = runInternalAction(ActionType.UpdateVm, updateParams, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
}
#end_block

#method_before
private void updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        updateResumeBehavior(template);
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
}
#method_after
private void updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        parameters.setCompensationEnabled(true);
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        updateResumeBehavior(template);
        final ActionReturnValue result = runInternalAction(ActionType.UpdateVmTemplate, parameters, cloneContextWithNoCleanupCompensation());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = backend.getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
}
#end_block

#method_before
private void addOrUpdateAddtionalClusterFeatures() {
    Set<SupportedAdditionalClusterFeature> featuresInDb = clusterFeatureDao.getAllByClusterId(getCluster().getId());
    Map<Guid, SupportedAdditionalClusterFeature> featuresEnabled = new HashMap<>();
    for (SupportedAdditionalClusterFeature feature : getCluster().getAddtionalFeaturesSupported()) {
        featuresEnabled.put(feature.getFeature().getId(), feature);
    }
    for (SupportedAdditionalClusterFeature featureInDb : featuresInDb) {
        if (featureInDb.isEnabled() && !featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Disable the features which are not selected in update cluster
            featureInDb.setEnabled(false);
            clusterFeatureDao.update(featureInDb);
        } else if (!featureInDb.isEnabled() && featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Enable the features which are selected in update cluster
            featureInDb.setEnabled(true);
            clusterFeatureDao.update(featureInDb);
        }
        featuresEnabled.remove(featureInDb.getFeature().getId());
    }
    // Add the newly add cluster features
    if (CollectionUtils.isNotEmpty(featuresEnabled.values())) {
        clusterFeatureDao.saveAll(featuresEnabled.values());
    }
}
#method_after
private void addOrUpdateAddtionalClusterFeatures() {
    Set<SupportedAdditionalClusterFeature> featuresInDb = clusterFeatureDao.getAllByClusterId(getCluster().getId());
    Map<Guid, SupportedAdditionalClusterFeature> featuresEnabled = new HashMap<>();
    for (SupportedAdditionalClusterFeature feature : getCluster().getAddtionalFeaturesSupported()) {
        featuresEnabled.put(feature.getFeature().getId(), feature);
    }
    for (SupportedAdditionalClusterFeature featureInDb : featuresInDb) {
        if (featureInDb.isEnabled() && !featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Disable the features which are not selected in update cluster
            getCompensationContext().snapshotEntityUpdated(featureInDb);
            featureInDb.setEnabled(false);
            clusterFeatureDao.update(featureInDb);
        } else if (!featureInDb.isEnabled() && featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Enable the features which are selected in update cluster
            getCompensationContext().snapshotEntityUpdated(featureInDb);
            featureInDb.setEnabled(true);
            clusterFeatureDao.update(featureInDb);
        }
        featuresEnabled.remove(featureInDb.getFeature().getId());
    }
    // Add the newly add cluster features
    if (CollectionUtils.isNotEmpty(featuresEnabled.values())) {
        clusterFeatureDao.saveAll(featuresEnabled.values());
        getCompensationContext().snapshotNewEntities(featuresEnabled.values());
    }
}
#end_block

#method_before
private void runAnsibleHostDeployPlaybook(Cluster hostCluster) throws IOException, InterruptedException {
    // TODO: Remove when we remove support for legacy oVirt node:
    if (getVds().getVdsType().equals(VDSType.oVirtVintageNode)) {
        log.warn("Skipping Ansible runner, because it isn't supported for legacy oVirt node.");
        return;
    }
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", hostCluster.getCompatibilityVersion()), new Pair<>("host_deploy_cluster_name", hostCluster.getName()), new Pair<>("host_deploy_cluster_switch_type", hostCluster.getRequiredSwitchTypeForCluster().getOptionValue()), new Pair<>("host_deploy_gluster_enabled", hostCluster.supportsGlusterService()), new Pair<>("host_deploy_virt_enabled", hostCluster.supportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", hostCluster.getFirewallType().name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_interface", NetworkUtils.getHostIp(getVds())), new Pair<>("host_deploy_ovn_central", getOvnCentral()), new Pair<>("host_deploy_vnc_tls", hostCluster.isVncEncryptionEnabled() ? 1 : 0)).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.setCorrelationId(getCorrelationId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
    if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#method_after
private void runAnsibleHostDeployPlaybook(Cluster hostCluster) throws IOException, InterruptedException {
    // TODO: Remove when we remove support for legacy oVirt node:
    if (getVds().getVdsType().equals(VDSType.oVirtVintageNode)) {
        log.warn("Skipping Ansible runner, because it isn't supported for legacy oVirt node.");
        return;
    }
    AnsibleCommandBuilder command = new AnsibleCommandBuilder().hostnames(getVds().getHostName()).variables(new Pair<>("host_deploy_cluster_version", hostCluster.getCompatibilityVersion()), new Pair<>("host_deploy_cluster_name", hostCluster.getName()), new Pair<>("host_deploy_cluster_switch_type", hostCluster.getRequiredSwitchTypeForCluster().getOptionValue()), new Pair<>("host_deploy_gluster_enabled", hostCluster.supportsGlusterService()), new Pair<>("host_deploy_virt_enabled", hostCluster.supportsVirtService()), new Pair<>("host_deploy_vdsm_port", getVds().getPort()), new Pair<>("host_deploy_override_firewall", getParameters().getOverrideFirewall()), new Pair<>("host_deploy_firewall_type", hostCluster.getFirewallType().name()), new Pair<>("ansible_port", getVds().getSshPort()), new Pair<>("host_deploy_post_tasks", AnsibleConstants.HOST_DEPLOY_POST_TASKS_FILE_PATH), new Pair<>("host_deploy_ovn_tunneling_interface", NetworkUtils.getHostIp(getVds())), new Pair<>("host_deploy_ovn_central", getOvnCentral()), new Pair<>("host_deploy_vnc_tls", hostCluster.isVncEncryptionEnabled() ? "true" : "false")).logFileDirectory(VdsDeployBase.HOST_DEPLOY_LOG_DIRECTORY).logFilePrefix("ovirt-host-deploy-ansible").logFileName(getVds().getHostName()).logFileSuffix(getCorrelationId()).playbook(AnsibleConstants.HOST_DEPLOY_PLAYBOOK);
    AuditLogable logable = new AuditLogableImpl();
    logable.setVdsName(getVds().getName());
    logable.setVdsId(getVds().getId());
    logable.setCorrelationId(getCorrelationId());
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_STARTED);
    AnsibleReturnValue ansibleReturnValue = ansibleExecutor.runCommand(command);
    if (ansibleReturnValue.getAnsibleReturnCode() != AnsibleReturnCode.OK) {
        throw new VdsInstallException(VDSStatus.InstallFailed, String.format("Failed to execute Ansible host-deploy role. Please check logs for more details: %1$s", command.logFile()));
    }
    auditLogDirector.log(logable, AuditLogType.VDS_ANSIBLE_INSTALL_FINISHED);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, requiredSwitchTypeForCluster, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, additionalRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, clusterHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, maintenanceReasonRequired, ksmMergeAcrossNumaNodes, customMigrationNetworkBandwidth, migrationBandwidthLimitType, migrationPolicyId, macPoolId, firewallType, defaultNetworkProviderId, logMaxMemoryUsedThreshold, logMaxMemoryUsedThresholdType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, requiredSwitchTypeForCluster, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, additionalRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, clusterHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, maintenanceReasonRequired, ksmMergeAcrossNumaNodes, customMigrationNetworkBandwidth, migrationBandwidthLimitType, migrationPolicyId, macPoolId, firewallType, defaultNetworkProviderId, logMaxMemoryUsedThreshold, logMaxMemoryUsedThresholdType, vncEncryptionEnabled);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && Objects.equals(requiredSwitchTypeForCluster, other.requiredSwitchTypeForCluster) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(clusterHostsAndVms, other.clusterHostsAndVms) && Objects.equals(additionalRngSources, other.additionalRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(maintenanceReasonRequired, other.maintenanceReasonRequired) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && Objects.equals(customMigrationNetworkBandwidth, other.customMigrationNetworkBandwidth) && Objects.equals(migrationBandwidthLimitType, other.migrationBandwidthLimitType) && Objects.equals(migrationPolicyId, other.migrationPolicyId) && Objects.equals(macPoolId, other.macPoolId) && Objects.equals(firewallType, other.firewallType) && Objects.equals(defaultNetworkProviderId, other.defaultNetworkProviderId) && Objects.equals(logMaxMemoryUsedThreshold, other.logMaxMemoryUsedThreshold) && logMaxMemoryUsedThresholdType == other.logMaxMemoryUsedThresholdType;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && Objects.equals(requiredSwitchTypeForCluster, other.requiredSwitchTypeForCluster) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(clusterHostsAndVms, other.clusterHostsAndVms) && Objects.equals(additionalRngSources, other.additionalRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(maintenanceReasonRequired, other.maintenanceReasonRequired) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && Objects.equals(customMigrationNetworkBandwidth, other.customMigrationNetworkBandwidth) && Objects.equals(migrationBandwidthLimitType, other.migrationBandwidthLimitType) && Objects.equals(migrationPolicyId, other.migrationPolicyId) && Objects.equals(macPoolId, other.macPoolId) && Objects.equals(firewallType, other.firewallType) && Objects.equals(defaultNetworkProviderId, other.defaultNetworkProviderId) && Objects.equals(logMaxMemoryUsedThreshold, other.logMaxMemoryUsedThreshold) && logMaxMemoryUsedThresholdType == other.logMaxMemoryUsedThresholdType && vncEncryptionEnabled == other.vncEncryptionEnabled;
}
#end_block

#method_before
public static Stream<MockConfigDescriptor<?>> mockConfiguration() {
    return Stream.of(MockConfigDescriptor.of(ConfigValues.GlusterVolumeFreeSpaceThresholdInPercent, String.valueOf(LOW_SPACE_THRESHOLD_VALUE)));
}
#method_after
public static Stream<MockConfigDescriptor<?>> mockConfiguration() {
    return Stream.of(MockConfigDescriptor.of(ConfigValues.GlusterVolumeFreeSpaceThresholdInPercent, LOW_SPACE_THRESHOLD_VALUE));
}
#end_block

#method_before
private GlusterBrickEntity getBrick(Guid id, String device, Double confirmedTotalSize, Double confirmedFreeSize) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(id);
    BrickProperties brickProperties = new BrickProperties();
    brickProperties.setConfirmedTotalSize(confirmedTotalSize);
    brickProperties.setConfirmedFreeSize(confirmedFreeSize);
    brickProperties.setDevice(device);
    BrickDetails brickDetails = new BrickDetails();
    brickDetails.setBrickProperties(brickProperties);
    brick.setServerId(serverId);
    brick.setBrickDetails(brickDetails);
    if (!brickId.equals(id)) {
        doReturn(brick).when(brickDao).getById(id);
    }
    return brick;
}
#method_after
private GlusterBrickEntity getBrick(Guid id, String device, Double confirmedTotalSize, Double confirmedFreeSize) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(id);
    BrickProperties brickProperties = new BrickProperties();
    brickProperties.setConfirmedTotalSize(confirmedTotalSize);
    brickProperties.setConfirmedFreeSize(confirmedFreeSize);
    brickProperties.setVdoSavings(80);
    brickProperties.setDevice(device);
    BrickDetails brickDetails = new BrickDetails();
    brickDetails.setBrickProperties(brickProperties);
    brick.setServerId(serverId);
    brick.setBrickDetails(brickDetails);
    if (!brickId.equals(id)) {
        doReturn(brick).when(brickDao).getById(id);
    }
    return brick;
}
#end_block

#method_before
@Test
public void testConfirmedVolumeCapacity() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.1));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long value = (long) (500.1 * SizeConverter.BYTES_IN_MB);
    assertEquals(value, volumeConfirmedCapacity);
}
#method_after
@Test
public void testConfirmedVolumeCapacity() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.1));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long value = (long) (500.1 * SizeConverter.BYTES_IN_MB);
    assertEquals(value, volumeConfirmedCapacity);
    int volumeConfirmedSavings = thinDeviceService.calculateVolumeSavings(volumeEntity);
    assertEquals(80, volumeConfirmedSavings);
}
#end_block

#method_before
@Test
public void testConfirmedVolumeCapacityForDist() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.1));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (500.1 * SizeConverter.BYTES_IN_MB) + (long) (400.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
}
#method_after
@Test
public void testConfirmedVolumeCapacityForDist() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.1));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (500.1 * SizeConverter.BYTES_IN_MB) + (long) (400.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
    int volumeConfirmedSavings = thinDeviceService.calculateVolumeSavings(volumeEntity);
    assertEquals(80, volumeConfirmedSavings);
}
#end_block

#method_before
@Test
public void testConfirmedVolumeCapacityForReplica() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 100.1, 500.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test3", 300.1, 200.2));
    volumeEntity.setVolumeType(GlusterVolumeType.REPLICATE);
    volumeEntity.setReplicaCount(3);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (200.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
}
#method_after
@Test
public void testConfirmedVolumeCapacityForReplica() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 100.1, 500.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test3", 300.1, 200.2));
    volumeEntity.setVolumeType(GlusterVolumeType.REPLICATE);
    volumeEntity.setReplicaCount(3);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (200.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
    int volumeConfirmedSavings = thinDeviceService.calculateVolumeSavings(volumeEntity);
    assertEquals(80, volumeConfirmedSavings);
}
#end_block

#method_before
@Test
public void testConfirmedVolumeCapacityForDistributedReplica() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test3", 300.1, 200.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test4", 300.1, 600.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test5", 300.1, 300.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test6", 300.1, 400.2));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    volumeEntity.setReplicaCount(3);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (200.2 * SizeConverter.BYTES_IN_MB + 300.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
}
#method_after
@Test
public void testConfirmedVolumeCapacityForDistributedReplica() {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 500.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test2", 300.1, 400.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test3", 300.1, 200.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test4", 300.1, 600.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test5", 300.1, 300.2));
    volumeEntity.addBrick(getBrick(Guid.newGuid(), "test6", 300.1, 400.2));
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTED_REPLICATE);
    volumeEntity.setReplicaCount(3);
    long volumeConfirmedCapacity = thinDeviceService.calculateConfirmedVolumeCapacity(volumeEntity);
    long expectedValue = (long) (200.2 * SizeConverter.BYTES_IN_MB + 300.2 * SizeConverter.BYTES_IN_MB);
    assertEquals(expectedValue, volumeConfirmedCapacity);
    int volumeConfirmedSavings = thinDeviceService.calculateVolumeSavings(volumeEntity);
    assertEquals(80, volumeConfirmedSavings);
}
#end_block

#method_before
public BrickProperties setConfirmedSize(Map<Guid, GlusterLocalVolumeInfo> volumeInfo, GlusterBrickEntity brick, BrickProperties brickProperties) {
    if (brickProperties.getDevice() != null && volumeInfo.get(brick.getServerId()) != null) {
        GlusterLocalVolumeInfo localVolumeInfo = volumeInfo.get(brick.getServerId());
        brickProperties.setConfirmedFreeSize(localVolumeInfo.getAvailableThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setConfirmedTotalSize(localVolumeInfo.getTotalThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
    }
    return brickProperties;
}
#method_after
public BrickProperties setConfirmedSize(Map<Guid, GlusterLocalVolumeInfo> volumeInfo, GlusterBrickEntity brick, BrickProperties brickProperties) {
    if (brickProperties.getDevice() != null && volumeInfo.get(brick.getServerId()) != null) {
        GlusterLocalVolumeInfo localVolumeInfo = volumeInfo.get(brick.getServerId());
        brickProperties.setConfirmedFreeSize(localVolumeInfo.getAvailableThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setConfirmedTotalSize(localVolumeInfo.getTotalThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setVdoSavings(localVolumeInfo.getSavingsForDevice(brickProperties.getDevice()).orElse(null));
    }
    return brickProperties;
}
#end_block

#method_before
public void setDomainConfirmedFreeSize(Long confirmedFreeSize, List<Guid> sdId) {
    sdId.stream().map(i -> storageDomainDynamicDao.get(i)).forEach(d -> {
        int confirmedFreeSizeInGb = (int) (confirmedFreeSize / SizeConverter.BYTES_IN_GB);
        if (confirmedFreeSizeInGb > d.getAvailableDiskSize()) {
            confirmedFreeSizeInGb = d.getAvailableDiskSize();
        }
        d.setConfirmedAvailableDiskSize(confirmedFreeSizeInGb);
        storageDomainDynamicDao.updateConfirmedSize(d);
    });
}
#method_after
public void setDomainConfirmedFreeSize(Long confirmedFreeSize, Integer vdoSavings, List<Guid> sdId) {
    sdId.stream().map(i -> storageDomainDynamicDao.get(i)).forEach(d -> {
        int confirmedFreeSizeInGb = (int) (confirmedFreeSize / SizeConverter.BYTES_IN_GB);
        if (confirmedFreeSizeInGb > d.getAvailableDiskSize()) {
            confirmedFreeSizeInGb = d.getAvailableDiskSize();
        }
        d.setConfirmedAvailableDiskSize(confirmedFreeSizeInGb);
        d.setVdoSavings(vdoSavings);
        storageDomainDynamicDao.updateConfirmedSize(d);
    });
}
#end_block

#method_before
public void sendLowConfirmedSpaceEvent(Long confirmedFreeSize, GlusterVolumeEntity volume, List<Guid> sdId) {
    Long confirmedTotalSize = this.calculateConfirmedVolumeTotal(volume);
    Double percentFreeSize = (confirmedFreeSize.doubleValue() / confirmedTotalSize) * 100;
    Double freeSpaceThreshold = Double.valueOf(Config.getValue(ConfigValues.GlusterVolumeFreeSpaceThresholdInPercent));
    if (percentFreeSize <= freeSpaceThreshold) {
        AuditLogable volumeEvent = new AuditLogableImpl();
        volumeEvent.setGlusterVolumeName(volume.getName());
        volumeEvent.setGlusterVolumeId(volume.getId());
        volumeEvent.setRepeatable(true);
        auditLogDirector.log(volumeEvent, AuditLogType.GLUSTER_VOLUME_CONFIRMED_SPACE_LOW);
    }
    sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() > percentFreeSize).forEach(sd -> {
        AuditLogable event = new AuditLogableImpl();
        event.setStorageDomainId(sd.getId());
        event.setStorageDomainName(sd.getName());
        event.setRepeatable(true);
        event.addCustomValue("DiskSpace", String.valueOf(confirmedFreeSize / SizeConverter.BYTES_IN_GB));
        auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
    });
}
#method_after
public void sendLowConfirmedSpaceEvent(Long confirmedFreeSize, GlusterVolumeEntity volume, List<Guid> sdId) {
    Long confirmedTotalSize = this.calculateConfirmedVolumeTotal(volume);
    Double percentFreeSize = (confirmedFreeSize.doubleValue() / confirmedTotalSize) * 100;
    Integer freeSpaceThreshold = Config.getValue(ConfigValues.GlusterVolumeFreeSpaceThresholdInPercent);
    if (percentFreeSize <= freeSpaceThreshold.doubleValue()) {
        AuditLogable volumeEvent = new AuditLogableImpl();
        volumeEvent.setGlusterVolumeName(volume.getName());
        volumeEvent.setGlusterVolumeId(volume.getId());
        volumeEvent.setRepeatable(true);
        auditLogDirector.log(volumeEvent, AuditLogType.GLUSTER_VOLUME_CONFIRMED_SPACE_LOW);
    }
    sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() > percentFreeSize).forEach(sd -> {
        AuditLogable event = new AuditLogableImpl();
        event.setStorageDomainId(sd.getId());
        event.setStorageDomainName(sd.getName());
        event.setRepeatable(true);
        event.addCustomValue("DiskSpace", String.valueOf(confirmedFreeSize / SizeConverter.BYTES_IN_GB));
        auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
    });
}
#end_block

#method_before
private void writeNumaTune() {
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune == null) {
        return;
    }
    Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodesSupplier.get());
    if (numaTuneSetting.isEmpty()) {
        return;
    }
    // <numatune>
    // <memory mode='strict' nodeset='0-1'/>
    // <memnode cellid='0' mode='strict' nodeset='1'>
    // </numatune>
    String nodeSet = (String) numaTuneSetting.get(VdsProperties.NUMA_TUNE_NODESET);
    String mode = (String) numaTuneSetting.get(VdsProperties.NUMA_TUNE_MODE);
    @SuppressWarnings("unchecked")
    List<Map<String, String>> memNodes = (List<Map<String, String>>) numaTuneSetting.get(VdsProperties.NUMA_TUNE_MEMNODES);
    if (nodeSet != null || memNodes != null) {
        writer.writeStartElement("numatune");
        if (nodeSet != null) {
            writer.writeStartElement("memory");
            writer.writeAttributeString("mode", mode);
            writer.writeAttributeString("modeset", nodeSet);
            writer.writeEndElement();
        }
        if (memNodes != null) {
            for (Map<String, String> memnode : memNodes) {
                writer.writeStartElement("memnode");
                writer.writeAttributeString("mode", mode);
                writer.writeAttributeString("cellid", memnode.get(VdsProperties.NUMA_TUNE_VM_NODE_INDEX));
                writer.writeAttributeString("nodeset", memnode.get(VdsProperties.NUMA_TUNE_NODESET));
                writer.writeEndElement();
            }
        }
        writer.writeEndElement();
    }
}
#method_after
private void writeNumaTune() {
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune == null) {
        return;
    }
    Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodesSupplier.get());
    if (numaTuneSetting.isEmpty()) {
        return;
    }
    // <numatune>
    // <memory mode='strict' nodeset='0-1'/>
    // <memnode cellid='0' mode='strict' nodeset='1'>
    // </numatune>
    String nodeSet = (String) numaTuneSetting.get(VdsProperties.NUMA_TUNE_NODESET);
    String mode = (String) numaTuneSetting.get(VdsProperties.NUMA_TUNE_MODE);
    @SuppressWarnings("unchecked")
    List<Map<String, String>> memNodes = (List<Map<String, String>>) numaTuneSetting.get(VdsProperties.NUMA_TUNE_MEMNODES);
    if (nodeSet != null || memNodes != null) {
        writer.writeStartElement("numatune");
        if (nodeSet != null) {
            writer.writeStartElement("memory");
            writer.writeAttributeString("mode", mode);
            writer.writeAttributeString("modeset", nodeSet);
            writer.writeEndElement();
        }
        if (memNodes != null) {
            for (Map<String, String> memnode : memNodes) {
                writer.writeStartElement("memnode");
                writer.writeAttributeString("mode", mode);
                writer.writeAttributeString("cellid", (String) memnode.get(VdsProperties.NUMA_TUNE_VM_NODE_INDEX));
                writer.writeAttributeString("nodeset", (String) memnode.get(VdsProperties.NUMA_TUNE_NODESET));
                writer.writeEndElement();
            }
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = this.vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            nativeIO = !"file".equals(diskType) || StorageType.GLUSTERFS.equals(diskImage.getStorageTypes().get(0));
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve, int pinTo) {
    writer.writeStartElement("driver");
    writer.writeAttributeString("name", "qemu");
    if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
        writer.writeAttributeString("discard", "unmap");
    }
    if (pinTo > 0) {
        writer.writeAttributeString("iothread", String.valueOf(pinTo));
    }
    boolean nativeIO = false;
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            String diskType = vmInfoBuildUtils.getDiskType(this.vm, diskImage, device);
            nativeIO = !"file".equals(diskType) || vmInfoBuildUtils.shouldUseNativeIO(vm, diskImage);
            writer.writeAttributeString("io", nativeIO ? "native" : "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            nativeIO = true;
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // case RBD
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", "raw");
            writer.writeAttributeString("error_policy", "stop");
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            case VirtIO_SCSI:
                String viodiskcache = vmCustomProperties.get("viodiskcache");
                if (viodiskcache != null && !nativeIO) {
                    writer.writeAttributeString("cache", viodiskcache);
                    break;
                }
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void initTableColumns() {
    Column<EntityModel, String> nameColumn = new Column<EntityModel, String>(new TextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getName();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(nameColumn, constants.nameHost(), "50px");
    nameColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setName(value));
    Column<EntityModel, String> addressColumn = new Column<EntityModel, String>(new TextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getAddress();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(addressColumn, constants.ipHost(), "100px");
    addressColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setAddress(value));
    Column<EntityModel, String> passwordColumn = new Column<EntityModel, String>(new PasswordTextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getPassword();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(passwordColumn, constants.hostPopupPasswordLabel(), "100px");
    passwordColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setPassword(value));
    hostsTable.addColumn(new AbstractEntityModelTextColumn<HostDetailModel>() {

        @Override
        public String getText(HostDetailModel hostModel) {
            return hostModel.getFingerprint();
        }
    }, constants.hostsPopupFingerprint(), // $NON-NLS-1$
    "300px");
}
#method_after
private void initTableColumns() {
    Column<EntityModel, String> nameColumn = new Column<EntityModel, String>(new TextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getName();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(nameColumn, constants.nameHost(), "80px");
    nameColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setName(value));
    hostsTable.addColumn(new AbstractEntityModelTextColumn<HostDetailModel>() {

        @Override
        public String getText(HostDetailModel hostModel) {
            return hostModel.getGlusterPeerAddress();
        }
    }, constants.glusterPeerAddress(), // $NON-NLS-1$
    "120px");
    Column<EntityModel, String> addressColumn = new Column<EntityModel, String>(new TextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getAddress();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(addressColumn, constants.ipHostImportCluster(), "180px");
    addressColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setAddress(value));
    Column<EntityModel, String> passwordColumn = new Column<EntityModel, String>(new PasswordTextInputCell()) {

        @Override
        public String getValue(EntityModel object) {
            return ((HostDetailModel) object.getEntity()).getPassword();
        }
    };
    // $NON-NLS-1$
    hostsTable.addColumn(passwordColumn, constants.hostPopupPasswordLabel(), "100px");
    passwordColumn.setFieldUpdater((index, object, value) -> ((HostDetailModel) object.getEntity()).setPassword(value));
    hostsTable.addColumn(new AbstractEntityModelTextColumn<HostDetailModel>() {

        @Override
        public String getText(HostDetailModel hostModel) {
            return hostModel.getFingerprint();
        }
    }, constants.hostsPopupFingerprint(), // $NON-NLS-1$
    "300px");
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if ("IsCustomPropertiesTabAvailable".equals(propName)) {
            // $NON-NLS-1$
            setupCustomPropertiesAvailability(object);
        } else if ("IsDisksAvailable".equals(propName)) {
            // $NON-NLS-1$
            addDiskAllocation(object);
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        boolean isAutoAssign = object.getIsAutoAssign().getEntity();
        defaultHostEditor.setEnabled(!isAutoAssign);
        // only this is not bind to the model, so needs to listen to the change explicitly
        specificHost.asRadioButton().setValue(!isAutoAssign);
    });
    object.getProvisioning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
        provisioningThinEditor.setEnabled(isProvisioningChangable);
        provisioningCloneEditor.setEnabled(isProvisioningChangable);
        boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
        changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
        boolean isDisksAvailable = object.getIsDisksAvailable();
        changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getEditingEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        Boolean enabled = object.getEditingEnabled().getEntity();
        if (Boolean.FALSE.equals(enabled)) {
            disableAllTabs();
            generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            generalWarningMessage.setVisible(true);
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            changeApplicationLevelVisibility(cpuSharesEditorRow, object.getCpuSharesAmountSelection().getIsAvailable());
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (object.getCloudInitEnabled().getEntity() != null) {
            vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (object.getSysprepEnabled().getEntity() != null) {
            vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener((ev, sender, args) -> changeApplicationLevelVisibility(serialNumberPolicyEditor, true));
    object.getIsRngEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> rngPanel.setVisible(object.getIsRngEnabled().getEntity()));
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
        customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        updateUrandomLabel(object);
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsChangable".equals(args.propertyName)) {
            // $NON-NLS-1$
            cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? OvirtCss.LABEL_ENABLED : OvirtCss.LABEL_DISABLED);
        }
    });
    object.getIoThreadsEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        ioThreadsPanel.setVisible(object.getIoThreadsEnabled().getEntity());
    });
    object.getCustomCompatibilityVersion().getSelectedItemChangedEvent().addListener((ev, sender, args) -> updateUrandomLabel(object));
    object.getIsHeadlessModeEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean isHeadlessEnabled = object.getIsHeadlessModeEnabled().getEntity();
        ssoMethodLabel.setEnabled(!isHeadlessEnabled);
        monitorsLabel.setEnabled(!isHeadlessEnabled);
        spiceProxyEnabledCheckboxWithInfoIcon.setEnabled(!isHeadlessEnabled);
    });
    affinityLabelSelectionWidget.init(object.getLabelList());
    object.getMultiQueues().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            multiQueuesLabel.setVisible(object.getMultiQueues().getIsAvailable());
            multiQueuesInfo.setVisible(object.getMultiQueues().getIsAvailable());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener((ev, sender, args) -> {
        String propName = args.propertyName;
        if ("IsCustomPropertiesTabAvailable".equals(propName)) {
            // $NON-NLS-1$
            setupCustomPropertiesAvailability(object);
        } else if ("IsDisksAvailable".equals(propName)) {
            // $NON-NLS-1$
            addDiskAllocation(object);
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        boolean isAutoAssign = object.getIsAutoAssign().getEntity();
        defaultHostEditor.setEnabled(!isAutoAssign);
        // only this is not bind to the model, so needs to listen to the change explicitly
        specificHost.asRadioButton().setValue(!isAutoAssign);
    });
    object.getProvisioning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
        provisioningThinEditor.setEnabled(isProvisioningChangable);
        provisioningCloneEditor.setEnabled(isProvisioningChangable);
        boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
        changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
        boolean isDisksAvailable = object.getIsDisksAvailable();
        changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getEditingEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        Boolean enabled = object.getEditingEnabled().getEntity();
        if (Boolean.FALSE.equals(enabled)) {
            disableAllTabs();
            generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            generalWarningMessage.setVisible(true);
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            changeApplicationLevelVisibility(cpuSharesEditorRow, object.getCpuSharesAmountSelection().getIsAvailable());
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (object.getCloudInitEnabled().getEntity() != null) {
            vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if (object.getSysprepEnabled().getEntity() != null) {
            vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener((ev, sender, args) -> changeApplicationLevelVisibility(serialNumberPolicyEditor, true));
    object.getIsRngEnabled().getPropertyChangedEvent().addListener((ev, sender, args) -> rngPanel.setVisible(object.getIsRngEnabled().getEntity()));
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
        customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
        updateUrandomLabel(object);
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsChangable".equals(args.propertyName)) {
            // $NON-NLS-1$
            cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? OvirtCss.LABEL_ENABLED : OvirtCss.LABEL_DISABLED);
        }
    });
    object.getIoThreadsEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> ioThreadsPanel.setVisible(object.getIoThreadsEnabled().getEntity()));
    object.getCustomCompatibilityVersion().getSelectedItemChangedEvent().addListener((ev, sender, args) -> updateUrandomLabel(object));
    object.getIsHeadlessModeEnabled().getEntityChangedEvent().addListener((ev, sender, args) -> {
        boolean isHeadlessEnabled = object.getIsHeadlessModeEnabled().getEntity();
        ssoMethodLabel.setEnabled(!isHeadlessEnabled);
        monitorsLabel.setEnabled(!isHeadlessEnabled);
        spiceProxyEnabledCheckboxWithInfoIcon.setEnabled(!isHeadlessEnabled);
    });
    affinityLabelSelectionWidget.init(object.getLabelList());
    object.getMultiQueues().getPropertyChangedEvent().addListener((ev, sender, args) -> {
        if ("IsAvailable".equals(args.propertyName)) {
            // $NON-NLS-1$
            multiQueuesLabel.setVisible(object.getMultiQueues().getIsAvailable());
            multiQueuesInfo.setVisible(object.getMultiQueues().getIsAvailable());
        }
    });
}
#end_block

#method_before
private IsWidget createDetailAdditionalInfo() {
    FlowPanel panel = new FlowPanel();
    List<HostVLan> logicalNetworks = calculateLogicalNetworks(getEntity());
    List<IsWidget> icons = new ArrayList<>();
    if (containsManagement(logicalNetworks)) {
        icons.add(createManagementStatusPanel());
    }
    if (containsOutOfSync(logicalNetworks)) {
        icons.add(createNeedsSyncStatusPanel());
    }
    String logicalNetworksText = logicalNetworks.size() == 1 ? constants.logicalNetwork() : messages.logicalNetworks(logicalNetworks.size());
    logicalNetworkExpand = new ExpandableListViewItem(SafeHtmlUtils.fromString(logicalNetworksText), icons);
    getClickHandlerRegistrations().add(logicalNetworkExpand.addClickHandler(this));
    panel.add(logicalNetworkExpand);
    return panel;
}
#method_after
private IsWidget createDetailAdditionalInfo() {
    FlowPanel panel = new FlowPanel();
    List<HostVLan> logicalNetworks = calculateLogicalNetworks(getEntity());
    List<IsWidget> icons = new ArrayList<>();
    if (containsManagement(logicalNetworks)) {
        icons.add(createManagementStatusPanel());
    }
    if (containsOutOfSync(logicalNetworks)) {
        icons.add(createNeedsSyncStatusPanel());
    }
    if (vds.isNetworkOperationInProgress()) {
        icons.add(createNetworkUpdatingStatusPanel());
    }
    String logicalNetworksText = logicalNetworks.size() == 1 ? constants.logicalNetwork() : messages.logicalNetworks(logicalNetworks.size());
    logicalNetworkExpand = new ExpandableListViewItem(SafeHtmlUtils.fromString(logicalNetworksText), icons);
    getClickHandlerRegistrations().add(logicalNetworkExpand.addClickHandler(this));
    panel.add(logicalNetworkExpand);
    return panel;
}
#end_block

#method_before
private void writeVGpu() {
    String mdevType = vmCustomProperties.remove("mdev_type");
    if (mdevType != null) {
        writer.writeStartElement("hostdev");
        writer.writeAttributeString("mode", "subsystem");
        writer.writeAttributeString("type", "mdev");
        writer.writeAttributeString("model", "vfio-pci");
        writer.writeStartElement("source");
        String address = Guid.newGuid().toString();
        writer.writeStartElement("address");
        writer.writeAttributeString("uuid", address);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevType));
    }
}
#method_after
private void writeVGpu() {
    String mdevTypes = vmCustomProperties.remove("mdev_type");
    if (mdevTypes != null) {
        String[] mdevDevices = mdevTypes.split(",");
        for (String mdevType : mdevDevices) {
            writer.writeStartElement("hostdev");
            writer.writeAttributeString("mode", "subsystem");
            writer.writeAttributeString("type", "mdev");
            writer.writeAttributeString("model", "vfio-pci");
            writer.writeStartElement("source");
            String address = Guid.newGuid().toString();
            writer.writeStartElement("address");
            writer.writeAttributeString("uuid", address);
            writer.writeEndElement();
            writer.writeEndElement();
            writer.writeEndElement();
            mdevMetadata.put(address, Collections.singletonMap("mdevType", mdevType));
        }
    }
}
#end_block

#method_before
private Container createNicsItemContainerPanel(List<VmNetworkInterface> nics) {
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    Row content = new Row();
    Container container = createItemContainerPanel(content);
    int i = 0;
    for (VmNetworkInterface nic : nics) {
        if (i % 4 == 0 && i > 0) {
            content = new Row();
            container.add(content);
        }
        Column column = new Column(calculateColSize(i));
        content.add(column);
        DListElement dl = Document.get().createDLElement();
        dl.addClassName(DL_HORIZONTAL);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameInterface()), SafeHtmlUtils.fromString(nic.getName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), SafeHtmlUtils.fromString(nic.getNetworkName() == null ? "" : nic.getNetworkName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.profileNameInterface()), SafeHtmlUtils.fromString(nic.getVnicProfileName() == null ? messages.emptyProfile().asString() : nic.getVnicProfileName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeInterface()), SafeHtmlUtils.fromString(VmInterfaceType.forValue(nic.getType()).getDescription()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macInterface()), SafeHtmlUtils.fromString(nic.getMacAddress()), dl);
        addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { nic.getStatistics().getReceiveRate(), nic.hasSpeed() ? nic.getSpeed().doubleValue() : 0 })), dl);
        addDetailItem(templates.sub(constants.txRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { nic.getStatistics().getTransmitRate(), nic.hasSpeed() ? nic.getSpeed().doubleValue() : 0 })), dl);
        addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), SafeHtmlUtils.fromString(String.valueOf(nic.getStatistics().getReceiveDropRate() != null ? nic.getStatistics().getReceiveDropRate() : "" + nic.getStatistics().getTransmitDropRate())), dl);
        column.getElement().appendChild(dl);
        i++;
    }
    if (nics.isEmpty()) {
        Column column = new Column(ColumnSize.MD_12);
        content.add(column);
        column.getElement().setInnerHTML(constants.noItemsToDisplay());
    }
    return container;
}
#method_after
private Container createNicsItemContainerPanel(List<VmNetworkInterface> nics) {
    RxTxRateRenderer rateRenderer = new RxTxRateRenderer();
    Row content = new Row();
    Container container = createItemContainerPanel(content);
    int i = 0;
    for (VmNetworkInterface nic : nics) {
        if (i % 4 == 0 && i > 0) {
            content = new Row();
            container.add(content);
        }
        Column column = new Column(calculateColSize(i));
        content.add(column);
        DListElement dl = Document.get().createDLElement();
        dl.addClassName(DL_HORIZONTAL);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.nameInterface()), SafeHtmlUtils.fromString(nic.getName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.networkNameInterface()), SafeHtmlUtils.fromString(nic.getNetworkName() == null ? constants.unAvailablePropertyLabel() : nic.getNetworkName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.profileNameInterface()), SafeHtmlUtils.fromString(nic.getVnicProfileName() == null ? messages.emptyProfile().asString() : nic.getVnicProfileName()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.typeInterface()), SafeHtmlUtils.fromString(VmInterfaceType.forValue(nic.getType()).getDescription()), dl);
        addDetailItem(SafeHtmlUtils.fromSafeConstant(constants.macInterface()), SafeHtmlUtils.fromString(nic.getMacAddress()), dl);
        addDetailItem(templates.sub(constants.rxRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { nic.getStatistics().getReceiveRate(), nic.hasSpeed() ? nic.getSpeed().doubleValue() : 0 })), dl);
        addDetailItem(templates.sub(constants.txRate(), constants.mbps()), SafeHtmlUtils.fromString(rateRenderer.render(new Double[] { nic.getStatistics().getTransmitRate(), nic.hasSpeed() ? nic.getSpeed().doubleValue() : 0 })), dl);
        addDetailItem(templates.sub(constants.dropsInterface(), constants.pkts()), SafeHtmlUtils.fromString(String.valueOf(nic.getStatistics().getReceiveDropRate() != null ? nic.getStatistics().getReceiveDropRate() : "" + nic.getStatistics().getTransmitDropRate())), dl);
        column.getElement().appendChild(dl);
        i++;
    }
    if (nics.isEmpty()) {
        Column column = new Column(ColumnSize.MD_12);
        content.add(column);
        column.getElement().setInnerHTML(constants.noItemsToDisplay());
    }
    return container;
}
#end_block

#method_before
private boolean isDeprecated(Cluster object) {
    String serverCPUList = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ServerCPUList, object.getCompatibilityVersion().toString());
    // $NON-NLS-1$
    String[] cpus = serverCPUList.split("[;]");
    for (String cpu : cpus) {
        // $NON-NLS-1$
        String[] info = cpu.split("[:]");
        if (info.length == 5) {
            if (object.getCpuName().equals(info[1].trim())) {
                try {
                    if (Integer.parseInt(info[0].trim()) < 0) {
                        return true;
                    }
                } catch (NumberFormatException e) {
                    return false;
                }
            }
        }
    }
    return false;
}
#method_after
private boolean isDeprecated(Cluster object) {
    for (String version : versions) {
        if (version.equals(object.getCompatibilityVersion().toString())) {
            for (String cpu : cpus) {
                if (cpu.equals(object.getCpuName())) {
                    return true;
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    String warning = null;
    if (object.isClusterCompatibilityLevelUpgradeNeeded()) {
        warning = constants.clusterLevelUpgradeNeeded();
    }
    if (isDeprecated(object)) {
        if (warning != null) {
            warning += constants.seperatorHTML();
            warning += constants.preCPUDepricationWarning();
        } else {
            warning = constants.preCPUDepricationWarning();
        }
        warning += object.getCpuName();
        warning += constants.postCPUDepricationWarning();
    }
    if (warning != null) {
        return SafeHtmlUtils.fromTrustedString(warning);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    SafeHtmlBuilder builder = new SafeHtmlBuilder();
    boolean hasWarning = false;
    if (hasWarning = object.isClusterCompatibilityLevelUpgradeNeeded()) {
        builder.appendHtmlConstant(constants.clusterLevelUpgradeNeeded());
    }
    if (isDeprecated(object)) {
        if (hasWarning) {
            // $NON-NLS-1$
            builder.appendHtmlConstant("<br/><br/>");
        }
        builder.appendEscaped(messages.cpuDeprecationWarning(object.getCpuName()));
        hasWarning = true;
    }
    if (hasWarning) {
        return builder.toSafeHtml();
    }
    return null;
}
#end_block

#method_before
protected IsWidget createNetworkUpdatingStatusPanel() {
    Span span = new Span();
    span.getElement().setInnerSafeHtml(SafeHtmlUtils.fromTrustedString(NETWORK_UPDATING));
    WidgetTooltip tooltip = new WidgetTooltip(span);
    tooltip.setText(constants.networksUpdating());
    return tooltip;
}
#method_after
protected IsWidget createNetworkUpdatingStatusPanel() {
    Span span = new Span();
    span.getElement().setInnerSafeHtml(templates.networkOperationInProgressSpinner(constants.networkUpdating()));
    WidgetTooltip tooltip = new WidgetTooltip(span);
    tooltip.setText(constants.networksUpdating());
    return tooltip;
}
#end_block

#method_before
private void writeSystemInfo() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    /**
     *         <sysinfo type="smbios">
     *          <system>
     *            <entry name="manufacturer">Fedora</entry>
     *            <entry name="product">Virt-Manager</entry>
     *            <entry name="version">0.8.2-3.fc14</entry>
     *            <entry name="serial">32dfcb37-5af1-552b-357c-be8c3aa38310</entry>
     *            <entry name="uuid">c7a5fdbd-edaf-9455-926a-d65c16db1809</entry>
     *          </system>
     *         </sysinfo>
     */
    writer.writeStartElement("sysinfo");
    writer.writeAttributeString("type", "smbios");
    writer.writeStartElement("system");
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "manufacturer");
    writer.writeRaw("oVirt");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "product");
    writer.writeRaw("OS-NAME:");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "version");
    writer.writeRaw("OS-VERSION:");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "serial");
    writer.writeRaw(vmInfoBuildUtils.getVmSerialNumber(vm, "HOST-SERIAL:"));
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "uuid");
    writer.writeRaw(vm.getId().toString());
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeSystemInfo() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    /**
     *         <sysinfo type="smbios">
     *          <system>
     *            <entry name="manufacturer">Fedora</entry>
     *            <entry name="product">Virt-Manager</entry>
     *            <entry name="version">0.8.2-3.fc14</entry>
     *            <entry name="serial">32dfcb37-5af1-552b-357c-be8c3aa38310</entry>
     *            <entry name="uuid">c7a5fdbd-edaf-9455-926a-d65c16db1809</entry>
     *          </system>
     *         </sysinfo>
     */
    writer.writeStartElement("sysinfo");
    writer.writeAttributeString("type", "smbios");
    writer.writeStartElement("system");
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "manufacturer");
    String product = Config.getValue(ConfigValues.OriginType);
    writer.writeRaw(OriginType.valueOf(product) == OriginType.OVIRT ? "oVirt" : "Red Hat");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "product");
    writer.writeRaw("OS-NAME:");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "version");
    writer.writeRaw("OS-VERSION:");
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "serial");
    writer.writeRaw(vmInfoBuildUtils.getVmSerialNumber(vm, "HOST-SERIAL:"));
    writer.writeEndElement();
    writer.writeStartElement("entry");
    writer.writeAttributeString("name", "uuid");
    writer.writeRaw(vm.getId().toString());
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$;" + "mdev_type=^(,?[0-9A-Za-z-]+)+$;hugepages=^[0-9]+$").when(utils).getPredefinedVMProperties(any());
    doReturn("").when(utils).getUserDefinedVMProperties(any());
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#method_after
private VmPropertiesUtils mockVmPropertiesUtils() throws InitializationException {
    VmPropertiesUtils utils = spy(new VmPropertiesUtils());
    doReturn("sap_agent=^(true|false)$;sndbuf=^[0-9]+$;" + "vhost=^(([a-zA-Z0-9_]*):(true|false))(,(([a-zA-Z0-9_]*):(true|false)))*$;" + "viodiskcache=^(none|writeback|writethrough)$;" + "mdev_type=^[^,](,?[0-9A-Za-z-]+)+$;hugepages=^[0-9]+$").when(utils).getPredefinedVMProperties(any());
    doReturn("").when(utils).getUserDefinedVMProperties(any());
    doReturn(new HashSet<>(Arrays.asList(Version.v3_6, Version.v4_0))).when(utils).getSupportedClusterLevels();
    doReturn(utils).when(runVmValidator).getVmPropertiesUtils();
    utils.init();
    return utils;
}
#end_block

#method_before
@Override
protected void verify(StorageDomain model, StorageDomain transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    // REVIST No descriptions for storage domains
    // assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertNotNull(transform.getStorage());
    assertEquals(model.getStorage().getType(), transform.getStorage().getType());
    assertEquals(model.getStorageFormat(), transform.getStorageFormat());
}
#method_after
@Override
protected void verify(StorageDomain model, StorageDomain transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    // REVIST No descriptions for storage domains
    // assertEquals(model.getDescription(), transform.getDescription());
    // REVIST No comment for storage domains
    // assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertNotNull(transform.getStorage());
    assertEquals(model.getStorage().getType(), transform.getStorage().getType());
    assertEquals(model.getStorageFormat(), transform.getStorageFormat());
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
}
#method_after
public void updateModelFromVds(VDS vds, List<StoragePool> dataCenters, boolean isEditWithPMemphasis) {
    setHostId(vds.getId());
    setIsHostedEngineDeployed(vds.isHostedEngineDeployed());
    updateExternalHostModels(vds.getHostProviderId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    if (StringHelper.isNotNullOrEmpty(vds.getKernelArgs())) {
        // $NON-NLS-1$
        getCurrentKernelCmdLine().setEntity(constants.currentKernelCmdLine() + " " + vds.getKernelArgs());
    }
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangeable(consoleAddressEnabled);
    getVncEncryptionEnabled().setEntity(vds.getVncEncryptionEnabled());
    if (!showInstallationProperties()) {
        getPkSection().setIsChangeable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    if (vds.isFenceAgentsExist()) {
        orderAgents(vds.getFenceAgents());
        List<FenceAgentModel> agents = getFenceAgentModelList(vds);
        getFenceAgentListModel().setItems(agents);
    }
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    getFencingEnabled().setEntity(vds.isFencingEnabled());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangeable(false);
    } else {
        getIsPm().setEntity(vds.isPmEnabled());
    }
    updateModelDataCenterFromVds(dataCenters, vds);
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    }
    getKernelCmdline().setEntity(vds.getCurrentKernelCmdline());
    setKernelCmdlineParsable(vds.isKernelCmdlineParsable());
    getKernelCmdlineBlacklistNouveau().setEntity(vds.isKernelCmdlineBlacklistNouveau());
    getKernelCmdlineIommu().setEntity(vds.isKernelCmdlineIommu());
    getKernelCmdlineKvmNested().setEntity(vds.isKernelCmdlineKvmNested());
    getKernelCmdlineUnsafeInterrupts().setEntity(vds.isKernelCmdlineUnsafeInterrupts());
    getKernelCmdlinePciRealloc().setEntity(vds.isKernelCmdlinePciRealloc());
}
#end_block

#method_before
public void addVmInitToDB(VmInit vmInit, CompensationContext compensationContext) {
    if (vmInit != null) {
        VmInit oldVmInit = vmInitDao.get(vmInit.getId());
        if (oldVmInit == null) {
            if (compensationContext != null) {
                compensationContext.snapshotNewEntity(vmInit);
            }
            vmInitDao.save(vmInit);
        } else {
            if (compensationContext != null) {
                compensationContext.snapshotEntityUpdated(oldVmInit);
            }
            if (vmInit.isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vmInit.setRootPassword(oldVmInit.getRootPassword());
            }
            vmInitDao.update(vmInit);
        }
    }
}
#method_after
public void addVmInitToDB(VmInit vmInit, CompensationContext compensationContext) {
    if (vmInit != null) {
        VmInit oldVmInit = vmInitDao.get(vmInit.getId());
        if (oldVmInit == null) {
            CompensationUtils.saveEntity(vmInit, vmInitDao, compensationContext);
        } else {
            if (vmInit.isPasswordAlreadyStored()) {
                // since we are not always returning the password in
                // updateVmInitFromDB()
                // method (we don't want to display it in the UI/API) we
                // don't want to override
                // the password if the flag is on
                vmInit.setRootPassword(oldVmInit.getRootPassword());
            }
            CompensationUtils.updateEntity(vmInit, oldVmInit, vmInitDao, compensationContext);
        }
    }
}
#end_block

#method_before
public void removeVmInitFromDB(VmBase vm, CompensationContext compensationContext) {
    if (compensationContext != null) {
        VmInit init = vmInitDao.get(vm.getId());
        if (init != null) {
            compensationContext.snapshotEntity(init);
        }
    }
    vmInitDao.remove(vm.getId());
}
#method_after
public void removeVmInitFromDB(VmBase vm, CompensationContext compensationContext) {
    CompensationUtils.removeEntity(vm.getId(), vmInitDao, compensationContext);
}
#end_block

#method_before
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, Guid memoryDumpDiskId, Guid memoryConfDiskId, Date creationDate, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, creationDate != null ? creationDate : new Date(), vm.getAppList(), memoryDumpDiskId, memoryConfDiskId);
    snapshotDao.save(snapshot);
    if (compensationContext != null) {
        compensationContext.snapshotNewEntity(snapshot);
    }
    return snapshot;
}
#method_after
public Snapshot addSnapshot(Guid snapshotId, String description, SnapshotStatus snapshotStatus, SnapshotType snapshotType, VM vm, boolean saveVmConfiguration, Guid memoryDumpDiskId, Guid memoryConfDiskId, Date creationDate, List<DiskImage> disks, Map<Guid, VmDevice> vmDevices, final CompensationContext compensationContext) {
    final Snapshot snapshot = new Snapshot(snapshotId, snapshotStatus, vm.getId(), saveVmConfiguration ? generateVmConfiguration(vm, disks, vmDevices) : null, snapshotType, description, creationDate != null ? creationDate : new Date(), vm.getAppList(), memoryDumpDiskId, memoryConfDiskId);
    CompensationUtils.saveEntity(snapshot, snapshotDao, compensationContext);
    return snapshot;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VmDevice> rngDevices = getRngDevices();
    Set<VmDeviceId> idsToRemove = new HashSet<>();
    for (VmDevice dev : rngDevices) {
        idsToRemove.add(dev.getId());
    }
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotEntities(rngDevices);
        getCompensationContext().stateChanged();
    }
    vmDeviceDao.removeAll(idsToRemove);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VmDevice> rngDevices = getRngDevices();
    CompensationUtils.removeEntities(rngDevices, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice rngDevice = getParameters().getRngDevice();
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotEntityUpdated(rngDevice);
    }
    vmDeviceDao.update(rngDevice);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmDevice rngDevice = getParameters().getRngDevice();
    CompensationUtils.updateEntity(rngDevice, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    if (getParameters().isCompensationEnabled()) {
        getVmDeviceUtils().setCompensationContext(getCompensationContext());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectResumeBehavior(getParameters().getVmStaticData(), getCluster());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    getVmDeviceUtils().setCompensationContext(getCompensationContextIfEnabledByCaller());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getParameters().isCompensationEnabled() ? getCompensationContext() : null);
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    // This cannot be reverted using compensation, but it should not be needed
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    if (getParameters().isCompensationEnabled()) {
        VmStatic oldStatic = oldVm.getStaticData();
        getCompensationContext().snapshotEntityUpdated(oldStatic);
    }
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
        clearUnmanagedDevices();
    }
    iconUtils.removeUnusedIcons(oldIconIds, getParameters().isCompensationEnabled() ? getCompensationContext() : null);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData(), getParameters().isCompensationEnabled() ? getCompensationContext() : null);
    checkTrustedService();
    liveUpdateCpuProfile();
    // It can be done here at the end, because the whole command runs in a transaction.
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContextIfEnabledByCaller());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    // This cannot be reverted using compensation, but it should not be needed
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    if (isCompensationEnabledByCaller()) {
        VmStatic oldStatic = oldVm.getStaticData();
        getCompensationContext().snapshotEntityUpdated(oldStatic);
    }
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
        clearUnmanagedDevices();
    }
    iconUtils.removeUnusedIcons(oldIconIds, getCompensationContextIfEnabledByCaller());
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData(), getCompensationContextIfEnabledByCaller());
    checkTrustedService();
    liveUpdateCpuProfile();
    // Persist all data in compensation context.
    // It can be done here at the end, because the whole command runs in a transaction.
    compensationStateChanged();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        if (getParameters().isCompensationEnabled()) {
            Guid vmId = getVmId();
            Map<String, String> oldLeaseInfo = oldVm.getLeaseInfo();
            getCompensationContext().snapshotObject(new FunctionCompensation(() -> {
                vmDynamicDao.updateVmLeaseInfo(vmId, oldLeaseInfo);
            }));
        }
        vmDynamicDao.updateVmLeaseInfo(getVmId(), null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    // Currently, compensation is only used when this command is called from UpdateClusterCommand,
    // and it does not update VM leases.
    // TODO - Add compensation support if needed.
    throwIfCompensationEnabled();
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        vmDynamicDao.updateVmLeaseInfo(getVmId(), null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
private void updateVmHostDevices() {
    if (isDedicatedVmForVdsChanged()) {
        log.info("Pinned host changed for VM: {}. Dropping configured host devices.", getVm().getName());
        if (getParameters().isCompensationEnabled()) {
            List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
            getCompensationContext().snapshotEntities(devices);
        }
        vmDeviceDao.removeVmDevicesByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    }
}
#method_after
private void updateVmHostDevices() {
    if (isDedicatedVmForVdsChanged()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change preferred hosts of the VM.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        log.info("Pinned host changed for VM: {}. Dropping configured host devices.", getVm().getName());
        vmDeviceDao.removeVmDevicesByVmIdAndType(getVmId(), VmDeviceGeneralType.HOSTDEV);
    }
}
#end_block

#method_before
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        ActionReturnValue result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getParameters().isCompensationEnabled() ? getCompensationContext() : null);
        setSucceeded(true);
    }
}
#method_after
private void updateVmTemplateVersion() {
    if (getVm().getStatus() == VMStatus.Down) {
        ActionReturnValue result = runInternalActionWithTasksContext(ActionType.UpdateVmVersion, new UpdateVmVersionParameters(getVmId(), getParameters().getVm().getVmtGuid(), getParameters().getVm().isUseLatestVersion()), getLock());
        if (result.getSucceeded()) {
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        }
        setSucceeded(result.getSucceeded());
        setActionReturnValue(ActionType.UpdateVmVersion);
    } else {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContextIfEnabledByCaller());
        setSucceeded(true);
    }
}
#end_block

#method_before
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    ActionReturnValue rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(getParameters().isCompensationEnabled());
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            params.setCompensationEnabled(getParameters().isCompensationEnabled());
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(getParameters().isCompensationEnabled());
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    QueryReturnValue query = runInternalQuery(QueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    ActionReturnValue rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            rngCommandResult = runInternalAction(ActionType.AddRngDevice, params, cloneContextWithNoCleanupCompensation());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            rngCommandResult = runInternalAction(ActionType.RemoveRngDevice, params, cloneContextWithNoCleanupCompensation());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.setCompensationEnabled(isCompensationEnabledByCaller());
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(ActionType.UpdateRngDevice, params, cloneContextWithNoCleanupCompensation());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged() || isChipsetChanged()) {
        log.info("Emulated machine or BIOS chipset type has changed for VM: {} ({}), clearing device addresses.", getVm().getName(), getVm().getId());
        if (getParameters().isCompensationEnabled()) {
            List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVmId());
            for (VmDevice device : allVmDevices) {
                getCompensationContext().snapshotEntityUpdated(device);
            }
        }
        vmDeviceDao.clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = vmDevicesMonitoring.createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        // TODO - Add to CompensationContext
        change.flush();
    }
}
#method_after
private void updateDeviceAddresses() {
    if (isEmulatedMachineChanged() || isChipsetChanged()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change emulated machine or chipset.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        log.info("Emulated machine or BIOS chipset type has changed for VM: {} ({}), clearing device addresses.", getVm().getName(), getVm().getId());
        vmDeviceDao.clearAllDeviceAddressesByVmId(getVmId());
        VmDevicesMonitoring.Change change = vmDevicesMonitoring.createChange(System.nanoTime());
        change.updateVm(getVmId(), VmDevicesMonitoring.EMPTY_HASH);
        change.flush();
    }
}
#end_block

#method_before
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        final int memoryAddedMb = newAmountOfMemory - currentMemory;
        final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
        final boolean memoryDividable = memoryAddedMb % factor == 0;
        if (!memoryDividable) {
            addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
            addCustomValue("requiredFactor", String.valueOf(factor));
            auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
            newVmStatic.setMemSizeMb(currentMemory);
            return;
        }
        hotSetMemory(currentMemory, newAmountOfMemory);
        return;
    }
    if (currentMemory > newAmountOfMemory) {
        hotUnplugMemory(newVm);
    }
}
#method_after
private void updateCurrentMemory(VM newVm) {
    int currentMemory = getVm().getMemSizeMb();
    int newAmountOfMemory = newVm.getMemSizeMb();
    if (getVm().getStatus().isNotRunning()) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() != VMStatus.Up) {
        newVmStatic.setMemSizeMb(currentMemory);
        log.warn("Memory update {}MB -> {}MB of VM {} ({}) left out. Memory can't be updated in current VM state ({}).", currentMemory, newAmountOfMemory, getVm().getName(), getVm().getId(), getVm().getStatus());
        return;
    }
    if (VmCommonUtils.isMemoryToBeHotplugged(getVm(), newVm)) {
        // Temporarily setting to the currentMemory. It will be increased in hotPlugMemory().
        newVmStatic.setMemSizeMb(currentMemory);
        final int memoryAddedMb = newAmountOfMemory - currentMemory;
        final int factor = Config.<Integer>getValue(ConfigValues.HotPlugMemoryBlockSizeMb);
        final boolean memoryDividable = memoryAddedMb % factor == 0;
        if (!memoryDividable) {
            addCustomValue("memoryAdded", String.valueOf(memoryAddedMb));
            addCustomValue("requiredFactor", String.valueOf(factor));
            auditLogDirector.log(this, AuditLogType.FAILED_HOT_SET_MEMORY_NOT_DIVIDABLE);
            return;
        }
        hotPlugMemory(memoryAddedMb);
        return;
    }
    if (currentMemory > newAmountOfMemory) {
        hotUnplugMemory(newVm);
    }
}
#end_block

#method_before
private void hotPlugMemoryDevice(int currentMemoryMb, int newAmountOfMemoryMb) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemoryMb < newAmountOfMemoryMb ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, newAmountOfMemoryMb - currentMemoryMb);
    ActionReturnValue setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine()) {
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemoryMb : currentMemoryMb);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
}
#method_after
private boolean hotPlugMemoryDevice(int memHotplugSize) {
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, memHotplugSize > 0 ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0, memHotplugSize);
    ActionReturnValue setAmountOfMemoryResult = runInternalAction(ActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    // into the OVF store and automatically used during the next HE VM start
    if (!getVm().isHostedEngine() && setAmountOfMemoryResult.getSucceeded()) {
        newVmStatic.setMemSizeMb(newVmStatic.getMemSizeMb() + memHotplugSize);
    }
    logHotSetActionEvent(setAmountOfMemoryResult, AuditLogType.FAILED_HOT_SET_MEMORY);
    return setAmountOfMemoryResult.getSucceeded();
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        QueryReturnValue query = runInternalQuery(QueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty() && getParameters().getWatchdog() == null) {
            return;
        }
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setCompensationEnabled(getParameters().isCompensationEnabled());
        if (getParameters().getWatchdog() != null) {
            parameters.setAction(getParameters().getWatchdog().getAction());
            parameters.setModel(getParameters().getWatchdog().getModel());
            if (watchdogs.isEmpty()) {
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
            } else {
                // there is a watchdog in the vm, we have to update.
                runInternalAction(ActionType.UpdateWatchdog, parameters, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
            }
        } else if (!watchdogs.isEmpty()) {
            // there is a watchdog in the vm, there should not be any, so let's delete
            runInternalAction(ActionType.RemoveWatchdog, parameters, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not update watchdog.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        QueryReturnValue query = runInternalQuery(QueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty() && getParameters().getWatchdog() == null) {
            return;
        }
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        if (getParameters().getWatchdog() != null) {
            parameters.setAction(getParameters().getWatchdog().getAction());
            parameters.setModel(getParameters().getWatchdog().getModel());
            if (watchdogs.isEmpty()) {
                runInternalAction(ActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                runInternalAction(ActionType.UpdateWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            // there is a watchdog in the vm, there should not be any, so let's delete
            runInternalAction(ActionType.RemoveWatchdog, parameters, cloneContextAndDetachFromParent());
        }
    }
}
#end_block

#method_before
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        GraphicsParameters params = new GraphicsParameters(existingGraphicsDevice);
        params.setCompensationEnabled(true);
        backend.runInternalAction(ActionType.RemoveGraphicsDevice, params, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
    }
}
#method_after
private void removeGraphicsDevice(GraphicsType type) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(type);
    if (existingGraphicsDevice != null) {
        GraphicsParameters params = new GraphicsParameters(existingGraphicsDevice);
        params.setCompensationEnabled(isCompensationEnabledByCaller());
        backend.runInternalAction(ActionType.RemoveGraphicsDevice, params, cloneContextWithNoCleanupCompensation());
    }
}
#end_block

#method_before
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    device.setVmId(getVmId());
    GraphicsParameters params = new GraphicsParameters(device);
    params.setCompensationEnabled(true);
    backend.runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, params, cloneContext().withoutExecutionContext().withoutLock().withCompensationContext(new ChildCompensationWrapper(getCompensationContext())));
}
#method_after
private void addOrUpdateGraphicsDevice(GraphicsDevice device) {
    GraphicsDevice existingGraphicsDevice = getGraphicsDevOfType(device.getGraphicsType());
    if (existingGraphicsDevice != null) {
        device.setDeviceId(existingGraphicsDevice.getDeviceId());
    }
    device.setVmId(getVmId());
    GraphicsParameters params = new GraphicsParameters(device);
    params.setCompensationEnabled(isCompensationEnabledByCaller());
    backend.runInternalAction(existingGraphicsDevice == null ? ActionType.AddGraphicsDevice : ActionType.UpdateGraphicsDevice, params, cloneContextWithNoCleanupCompensation());
}
#end_block

#method_before
private void updateVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            if (getParameters().isCompensationEnabled()) {
                getCompensationContext().snapshotEntity(oldPayload);
            }
            vmDeviceDao.remove(oldPayload.getId());
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#method_after
private void updateVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not update VM payload.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        List<VmDevice> disks = vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            vmDeviceDao.remove(oldPayload.getId());
        }
        if (!getParameters().isClearPayload()) {
            getVmDeviceUtils().addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
private void updateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getClusterId(), getParameters().getVmStaticData().getClusterId())) {
        List<Network> networks = networkDao.getAllForCluster(getParameters().getVmStaticData().getClusterId());
        List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = networkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                // If using compensation, make a snapshot
                if (getParameters().isCompensationEnabled()) {
                    getCompensationContext().snapshotEntityUpdated(iface);
                }
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
}
#method_after
private void updateVmNetworks() {
    // check if the cluster has changed
    if (!Objects.equals(getVm().getClusterId(), getParameters().getVmStaticData().getClusterId())) {
        // Currently, compensation is only used when this command is called from UpdateClusterCommand,
        // and it does not change cluster ID.
        // TODO - Add compensation support if needed.
        throwIfCompensationEnabled();
        List<Network> networks = networkDao.getAllForCluster(getParameters().getVmStaticData().getClusterId());
        List<VmNic> interfaces = vmNicDao.getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNic iface : interfaces) {
            final Network network = networkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
            boolean networkFound = networks.stream().anyMatch(n -> Objects.equals(n.getId(), network.getId()));
            // if network not exists in cluster we remove the network from the interface
            if (!networkFound) {
                iface.setVnicProfileId(null);
                vmNicDao.update(iface);
            }
        }
    }
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    params.setCompensationEnabled(getParameters().isCompensationEnabled());
    addLogMessages(backend.runInternalAction(ActionType.SetVmNumaNodes, params, cloneContext().withoutLock().withoutExecutionContext().withCompensationContext(new ChildCompensationWrapper(getCompensationContext()))));
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    // Currently, compensation is only used when this command is called from UpdateClusterCommand,
    // and it does not change NUMA nodes.
    // TODO - Add compensation support if needed.
    throwIfCompensationEnabled();
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(backend.runInternalAction(ActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMaxMemorySizeMb() < vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_MEMORY_CANNOT_BE_SMALLER_THAN_MEMORY_SIZE, ReplacementUtils.createSetVariableString("maxMemory", vmFromDB.getMaxMemorySizeMb()), ReplacementUtils.createSetVariableString("memory", vmFromParams.getMemSizeMb()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#end_block

#method_before
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    if (getParameters().isCompensationEnabled()) {
        Guid vmId = getVmId();
        List<Guid> oldLabelIds = labelDao.getAllByEntityIds(Collections.singleton(getVmId())).stream().map(Label::getId).collect(Collectors.toList());
        getCompensationContext().snapshotObject(new FunctionCompensation(() -> {
            labelDao.updateLabelsForVm(vmId, oldLabelIds);
        }));
    }
    labelDao.updateLabelsForVm(getVmId(), labelIds);
}
#method_after
private void updateAffinityLabels() {
    List<Label> affinityLabels = getParameters().getAffinityLabels();
    List<Guid> labelIds = affinityLabels.stream().map(Label::getId).collect(Collectors.toList());
    // Currently, this method does not use compensation to revert this operation,
    // because affinity groups are not changed when this command is called as a child of
    // UpdateClusterCommand.
    labelDao.updateLabelsForVm(getVmId(), labelIds);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice.getDeviceId() == null) {
        rngDevice.setDeviceId(Guid.newGuid());
    }
    vmDeviceDao.save(rngDevice);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(rngDevice);
        getCompensationContext().stateChanged();
    }
    setActionReturnValue(rngDevice.getDeviceId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice.getDeviceId() == null) {
        rngDevice.setDeviceId(Guid.newGuid());
    }
    CompensationUtils.saveEntity(rngDevice, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setActionReturnValue(rngDevice.getDeviceId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDeviceId graphicsDevId = getParameters().getDev().getId();
    if (getParameters().isCompensationEnabled()) {
        VmDevice existingEntity = vmDeviceDao.get(graphicsDevId);
        if (existingEntity != null) {
            getCompensationContext().snapshotEntity(existingEntity);
        }
    }
    vmDeviceDao.remove(graphicsDevId);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmDeviceId graphicsDevId = getParameters().getDev().getId();
    CompensationUtils.removeEntity(graphicsDevId, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    if (graphicsDev.getDeviceId() == null) {
        graphicsDev.setDeviceId(Guid.newGuid());
    }
    vmDeviceDao.save(graphicsDev);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(graphicsDev);
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
    setActionReturnValue(graphicsDev.getId().getDeviceId());
}
#method_after
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    if (graphicsDev.getDeviceId() == null) {
        graphicsDev.setDeviceId(Guid.newGuid());
    }
    CompensationUtils.saveEntity(graphicsDev, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setSucceeded(true);
    setActionReturnValue(graphicsDev.getId().getDeviceId());
}
#end_block

#method_before
private void updateCdPath(VmBase oldVmBase, VmBase newVmBase) {
    List<VmDevice> cdList = getCdDevices(oldVmBase.getId());
    if (cdList.size() > 0) {
        // this is done only for safety, each VM must have at least an empty CD
        // only one managed CD is currently supported.
        VmDevice cd = cdList.get(0);
        cd.getSpecParams().putAll(getCdDeviceSpecParams("", newVmBase.getIsoPath()));
        if (compensationContext != null) {
            VmDevice oldDevice = vmDeviceDao.get(cd.getId());
            compensationContext.snapshotEntityUpdated(oldDevice);
        }
        vmDeviceDao.update(cd);
    }
}
#method_after
private void updateCdPath(VmBase oldVmBase, VmBase newVmBase) {
    List<VmDevice> cdList = getCdDevices(oldVmBase.getId());
    if (cdList.size() > 0) {
        // this is done only for safety, each VM must have at least an empty CD
        // only one managed CD is currently supported.
        VmDevice cd = cdList.get(0);
        cd.getSpecParams().putAll(getCdDeviceSpecParams("", newVmBase.getIsoPath()));
        CompensationUtils.updateEntity(cd, vmDeviceDao, compensationContext);
    }
}
#end_block

#method_before
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    if (unmanagedControllers.isEmpty()) {
        return;
    }
    UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    // should not be here but due to https://bugzilla.redhat.com/1438188 can appear one
    // remove it
    removeVmDevices(managedUsbControllers);
    // has been created on pre 4.0 engine by VDSM, adopt it as ours
    VmDevice device = unmanagedControllers.iterator().next();
    device.setManaged(true);
    device.setPlugged(true);
    device.setReadOnly(false);
    device.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
    if (compensationContext != null) {
        compensationContext.snapshotEntityUpdated(device);
    }
    vmDeviceDao.update(device);
}
#method_after
private void acquireUnmanagedUsbController(VmBase vmBase, List<VmDevice> managedUsbControllers, List<VmDevice> unmanagedControllers) {
    if (unmanagedControllers.size() > 1) {
        throw new IllegalStateException(format("At most one unmanaged USB controller expected for VM=%s(%s), found=%s", vmBase.getName(), vmBase.getId(), unmanagedControllers));
    }
    if (unmanagedControllers.isEmpty()) {
        return;
    }
    UsbControllerModel controllerModel = getUsbControllerModel(vmBase);
    // should not be here but due to https://bugzilla.redhat.com/1438188 can appear one
    // remove it
    removeVmDevices(managedUsbControllers);
    // has been created on pre 4.0 engine by VDSM, adopt it as ours
    VmDevice device = unmanagedControllers.iterator().next();
    CompensationUtils.<VmDeviceId, VmDevice>updateEntity(device, dev -> {
        dev.setManaged(true);
        dev.setPlugged(true);
        dev.setReadOnly(false);
        dev.setSpecParams(createUsbControllerSpecParams(controllerModel.libvirtName, 0));
    }, vmDeviceDao, compensationContext);
}
#end_block

#method_before
/*
     * Disk device
     */
public void copyDiskDevices(Guid dstId, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping) {
    for (VmDevice device : srcDevices) {
        if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                Guid dstDeviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                device.setId(new VmDeviceId(dstDeviceId, dstId));
                device.setSpecParams(Collections.emptyMap());
                if (compensationContext != null) {
                    compensationContext.snapshotNewEntity(device);
                }
                vmDeviceDao.save(device);
            }
        }
    }
}
#method_after
/*
     * Disk device
     */
public void copyDiskDevices(Guid dstId, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping) {
    for (VmDevice device : srcDevices) {
        if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
            if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                Guid dstDeviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                device.setId(new VmDeviceId(dstDeviceId, dstId));
                device.setSpecParams(Collections.emptyMap());
                CompensationUtils.saveEntity(device, vmDeviceDao, compensationContext);
            }
        }
    }
}
#end_block

#method_before
public void removeVmDevices(List<VmDevice> devices) {
    removeVmDevices(devices, devices.size());
}
#method_after
public void removeVmDevices(List<VmDevice> devices) {
    CompensationUtils.removeEntities(devices, vmDeviceDao, compensationContext);
}
#end_block

#method_before
public void removeVmDevices(List<VmDevice> devices, int numberOfDevicesToRemove) {
    int size = devices.size();
    int maxIndex = Math.min(numberOfDevicesToRemove, size);
    for (int index = 1; index <= maxIndex; index++) {
        VmDevice device = devices.get(size - index);
        if (compensationContext != null) {
            compensationContext.snapshotEntity(device);
        }
        vmDeviceDao.remove(device.getId());
    }
}
#method_after
public void removeVmDevices(List<VmDevice> devices, int numberOfDevicesToRemove) {
    int size = devices.size();
    removeVmDevices(devices.subList(Math.max(size - numberOfDevicesToRemove, 0), size));
}
#end_block

#method_before
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, Boolean isPlugged, Boolean isReadOnly, String address, Map<String, String> customProps) {
    VmDevice managedDevice = new VmDevice(id, generalType, type.getName(), StringUtils.isNotBlank(address) ? address : "", specParams, true, isPlugged, isReadOnly, "", customProps, null, null);
    if (compensationContext != null) {
        compensationContext.snapshotNewEntity(managedDevice);
    }
    vmDeviceDao.save(managedDevice);
    return managedDevice;
}
#method_after
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, Boolean isPlugged, Boolean isReadOnly, String address, Map<String, String> customProps) {
    VmDevice managedDevice = new VmDevice(id, generalType, type.getName(), StringUtils.isNotBlank(address) ? address : "", specParams, true, isPlugged, isReadOnly, "", customProps, null, null);
    CompensationUtils.saveEntity(managedDevice, vmDeviceDao, compensationContext);
    return managedDevice;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    if (getParameters().isCompensationEnabled()) {
        VmDevice existingDevice = vmDeviceDao.get(graphicsDev.getId());
        getCompensationContext().snapshotEntityUpdated(existingDevice);
    }
    vmDeviceDao.update(graphicsDev);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
    setActionReturnValue(graphicsDev.getId().getDeviceId());
}
#method_after
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    CompensationUtils.updateEntity(graphicsDev, vmDeviceDao, getCompensationContextIfEnabledByCaller());
    compensationStateChanged();
    setSucceeded(true);
    setActionReturnValue(graphicsDev.getId().getDeviceId());
}
#end_block

#method_before
private boolean addImageTicketToDaemon(Guid imagedTicketId, long timeout) {
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getAllowedOperation() };
    // Sparse is not supported yet for block storage in imageio. See BZ#1619006.
    boolean sparse = getDiskImage().getVolumeType() == VolumeType.Sparse && getStorageDomain().getStorageType().isFileDomain();
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename(), sparse);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = vdsBroker.runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    return true;
}
#method_after
private boolean addImageTicketToDaemon(Guid imagedTicketId, long timeout) {
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getAllowedOperation() };
    // Sparse is not supported yet for block storage in imageio. See BZ#1619006.
    boolean sparse = getDiskImage().getVolumeType() == VolumeType.Sparse && getStorageDomain().getStorageType().isFileDomain();
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, getParameters().getCommandId(), transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename(), sparse);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = vdsBroker.runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    return true;
}
#end_block

#method_before
private String createSignedTicket(VDS vds, Guid transferToken) {
    String ticket;
    Map<String, Object> elements = new HashMap<>();
    long ts = System.currentTimeMillis() / 1000;
    elements.put(TOKEN_NOT_BEFORE, ts);
    elements.put(TOKEN_ISSUED_AT, ts);
    elements.put(TOKEN_EXPIRATION, ts + getClientTicketLifetime());
    elements.put(TOKEN_IMAGED_HOST_URI, getImageDaemonUri(vds.getHostName()));
    elements.put(TOKEN_TRANSFER_TICKET, transferToken.toString());
    String payload;
    try {
        payload = JsonHelper.mapToJson(elements);
    } catch (Exception e) {
        log.error("Failed to create JSON payload for signed ticket", e);
        return null;
    }
    log.debug("Signed ticket payload: {}", payload);
    try {
        ticket = new TicketEncoder(EngineEncryptionUtils.getPrivateKeyEntry().getCertificate(), EngineEncryptionUtils.getPrivateKeyEntry().getPrivateKey(), getClientTicketLifetime()).encode(payload);
    } catch (Exception e) {
        log.error("Failed to encode ticket for image transfer", e);
        return null;
    }
    return ticket;
}
#method_after
private String createSignedTicket(VDS vds, Guid transferToken) {
    String ticket;
    Map<String, Object> elements = new HashMap<>();
    long ts = System.currentTimeMillis() / 1000;
    elements.put(TOKEN_NOT_BEFORE, ts);
    elements.put(TOKEN_ISSUED_AT, ts);
    elements.put(TOKEN_EXPIRATION, ts + getClientTicketLifetime());
    elements.put(TOKEN_IMAGED_HOST_URI, getImageDaemonUri(vds.getHostName()));
    elements.put(TOKEN_TRANSFER_TICKET, transferToken.toString());
    elements.put(TOKEN_TRANSFER_ID, getParameters().getCommandId().toString());
    String payload;
    try {
        payload = JsonHelper.mapToJson(elements);
    } catch (Exception e) {
        log.error("Failed to create JSON payload for signed ticket", e);
        return null;
    }
    log.debug("Signed ticket payload: {}", payload);
    try {
        ticket = new TicketEncoder(EngineEncryptionUtils.getPrivateKeyEntry().getCertificate(), EngineEncryptionUtils.getPrivateKeyEntry().getPrivateKey(), getClientTicketLifetime()).encode(payload);
    } catch (Exception e) {
        log.error("Failed to encode ticket for image transfer", e);
        return null;
    }
    return ticket;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        executeCommand();
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        logException(e);
    } catch (RuntimeException e) {
        if (e.getCause() instanceof EngineException) {
            processExceptionToClient(new EngineFault(e, ((EngineException) e.getCause()).getVdsError().getCode()));
        } else {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        logException(e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            if (commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(noAsyncOperations() ? CommandStatus.ENDED_WITH_FAILURE : CommandStatus.EXECUTION_FAILED);
            }
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            if (getCompensationContext() != null && getCommandCompensationPhase() == CommandCompensationPhase.EXECUTION) {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            }
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        executeCommand();
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (EngineException e) {
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.debug("Exception", e);
        processExceptionToClient(new EngineFault(e, e.getVdsError().getCode()));
    } catch (OpenStackResponseException e) {
        // Adding a message to executeFailedMessages is needed only when the list is empty
        if (returnValue.getExecuteFailedMessages().isEmpty()) {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } catch (RuntimeException e) {
        if (e.getCause() instanceof EngineException) {
            EngineException ex = (EngineException) e.getCause();
            processExceptionToClient(new EngineFault(ex, ex.getVdsError().getCode()));
        } else {
            processExceptionToClient(new EngineFault(e, EngineError.ENGINE));
        }
        log.error("Command '{}' failed: {}", getClass().getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!exceptionOccurred) {
            setCommandExecuted();
        }
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
            if (commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(noAsyncOperations() ? CommandStatus.ENDED_WITH_FAILURE : CommandStatus.EXECUTION_FAILED);
            }
        } else {
            // set the status to ENDED_SUCCESSFULLY if the status is ACTIVE
            if (getReturnValue().getVdsmTaskIdList().isEmpty() && getReturnValue().getInternalVdsmTaskIdList().isEmpty() && getCallback() == null && commandStatus == CommandStatus.ACTIVE) {
                setCommandStatus(CommandStatus.ENDED_SUCCESSFULLY);
            }
            if (getCompensationContext() != null && getCommandCompensationPhase() == CommandCompensationPhase.EXECUTION) {
                getCompensationContext().cleanupCompensationDataAfterSuccessfulCommand();
            }
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
private Map<String, Object> extractCoreGeneralInfo(XmlNode domain) {
    Map<String, Object> info = new HashMap<>();
    info.put(VdsProperties.vm_name, domain.selectSingleNode("name").innerText);
    info.put(VdsProperties.vm_guid, domain.selectSingleNode("uuid").innerText);
    XmlNode cpusTopology = domain.selectSingleNode("cpu").selectSingleNode("topology");
    if (cpusTopology != null) {
        info.put(VdsProperties.num_of_cpus, cpusTopology.attributes.get("sockets").innerText);
    } else {
        // fallback when no topology is specified (ignoring offline CPUs)
        info.put(VdsProperties.num_of_cpus, domain.selectSingleNode("vcpu").innerText);
    }
    info.put(VdsProperties.mem_size_mb, domain.selectSingleNode("memory").innerText);
    XmlNode maxMemory = domain.selectSingleNode("maxMemory");
    if (maxMemory == null) {
        maxMemory = domain.selectSingleNode("memory");
    }
    info.putAll(DomainXmlUtils.parseMaxMemSize(maxMemory));
    info.put(VdsProperties.emulatedMachine, DomainXmlUtils.parseEmulatedMachine(domain.selectSingleNode("os")));
    return info;
}
#method_after
private Map<String, Object> extractCoreGeneralInfo(XmlNode domain) {
    Map<String, Object> info = new HashMap<>();
    info.put(VdsProperties.vm_name, domain.selectSingleNode("name").innerText);
    info.put(VdsProperties.vm_guid, domain.selectSingleNode("uuid").innerText);
    XmlNode cpusTopology = domain.selectSingleNode("cpu").selectSingleNode("topology");
    if (cpusTopology != null) {
        info.put(VdsProperties.num_of_cpus, cpusTopology.attributes.get("sockets").innerText);
    } else {
        // fallback when no topology is specified (ignoring offline CPUs)
        info.put(VdsProperties.num_of_cpus, domain.selectSingleNode("vcpu").innerText);
    }
    info.put(VdsProperties.mem_size_mb, DomainXmlUtils.parseMemSize(domain.selectSingleNode("memory")));
    info.putAll(DomainXmlUtils.parseMaxMemSize(domain.selectSingleNode("maxMemory")));
    info.put(VdsProperties.emulatedMachine, DomainXmlUtils.parseEmulatedMachine(domain.selectSingleNode("os")));
    return info;
}
#end_block

#method_before
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = NumaUtils.getVdsNumaNodeByIndex(dbVdsNumaNodes, node.getIndex());
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        if (!numaNodesToRemove.isEmpty()) {
            vdsNumaNodeDao.massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
        }
        if (!numaNodesToUpdate.isEmpty()) {
            vdsNumaNodeDao.massUpdateNumaNode(numaNodesToUpdate);
        }
        if (!numaNodesToSave.isEmpty()) {
            vdsNumaNodeDao.massSaveNumaNode(numaNodesToSave, vds.getId());
        }
        return null;
    });
}
#method_after
public void updateNumaData(final VDS vds) {
    if (vds.getNumaNodeList() == null || vds.getNumaNodeList().isEmpty()) {
        return;
    }
    final List<VdsNumaNode> numaNodesToSave = new ArrayList<>();
    final List<VdsNumaNode> numaNodesToUpdate = new ArrayList<>();
    final List<Guid> numaNodesToRemove = new ArrayList<>();
    List<VdsNumaNode> dbVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vds.getId());
    for (VdsNumaNode node : vds.getNumaNodeList()) {
        VdsNumaNode searchNode = dbVdsNumaNodes.stream().filter(n -> n.getIndex() == node.getIndex()).findAny().orElse(null);
        if (searchNode != null) {
            node.setId(searchNode.getId());
            numaNodesToUpdate.add(node);
            dbVdsNumaNodes.remove(searchNode);
        } else {
            node.setId(Guid.newGuid());
            numaNodesToSave.add(node);
        }
    }
    for (VdsNumaNode node : dbVdsNumaNodes) {
        numaNodesToRemove.add(node.getId());
    }
    // The database operation should be in one transaction
    TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
        if (!numaNodesToRemove.isEmpty()) {
            vdsNumaNodeDao.massRemoveNumaNodeByNumaNodeId(numaNodesToRemove);
        }
        if (!numaNodesToUpdate.isEmpty()) {
            vdsNumaNodeDao.massUpdateNumaNode(numaNodesToUpdate);
        }
        if (!numaNodesToSave.isEmpty()) {
            vdsNumaNodeDao.massSaveNumaNode(numaNodesToSave, vds.getId());
        }
        return null;
    });
}
#end_block

#method_before
private void checkVdsMemoryThresholdPercentage(Cluster cluster, VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = cluster.getLogMaxMemoryUsedThreshold();
    if (stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        logMemoryAuditLog(vds, stat, AuditLogType.VDS_HIGH_MEM_USE, maxUsedPercentageThreshold);
    }
}
#method_after
private void checkVdsMemoryThresholdPercentage(Cluster cluster, VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = cluster.getLogMaxMemoryUsedThreshold();
    if (stat.getUsageMemPercent() > maxUsedPercentageThreshold) {
        logMemoryAuditLog(vds, cluster, stat, AuditLogType.VDS_HIGH_MEM_USE, maxUsedPercentageThreshold);
    }
}
#end_block

#method_before
private void checkVdsMemoryThresholdAbsoluteValue(Cluster cluster, VdsStatistics stat) {
    Integer maxUsedAbsoluteThreshold = cluster.getLogMaxMemoryUsedThreshold();
    if (stat.getMemFree() < maxUsedAbsoluteThreshold) {
        logMemoryAuditLog(vds, stat, AuditLogType.VDS_LOW_MEM, maxUsedAbsoluteThreshold);
    }
}
#method_after
private void checkVdsMemoryThresholdAbsoluteValue(Cluster cluster, VdsStatistics stat) {
    Integer maxUsedAbsoluteThreshold = cluster.getLogMaxMemoryUsedThreshold();
    if (stat.getMemFree() < maxUsedAbsoluteThreshold) {
        logMemoryAuditLog(vds, cluster, stat, AuditLogType.VDS_LOW_MEM, maxUsedAbsoluteThreshold);
    }
}
#end_block

#method_before
private void logMemoryAuditLog(VDS vds, VdsStatistics stat, AuditLogType valueToLog, Integer threshold) {
    AuditLogable logable = createAuditLogableForHost();
    logable.addCustomValue("HostName", vds.getName());
    logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
    logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
    logable.addCustomValue("Threshold", threshold.toString());
    auditLog(logable, valueToLog);
}
#method_after
private void logMemoryAuditLog(VDS vds, Cluster cluster, VdsStatistics stat, AuditLogType valueToLog, Integer threshold) {
    AuditLogable logable = createAuditLogableForHost();
    logable.addCustomValue("HostName", vds.getName());
    logable.addCustomValue("Cluster", cluster.getName());
    logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
    logable.addCustomValue("UsedMemory", stat.getUsageMemPercent().toString());
    logable.addCustomValue("Threshold", threshold.toString());
    auditLog(logable, valueToLog);
}
#end_block

#method_before
private void initInfoIcons() {
    memoryOptimizationInfo = new InfoIcon(templates.italicText(constants.clusterPopupMemoryOptimizationInfo()));
    cpuThreadsInfo = new InfoIcon(templates.italicText(constants.clusterPopupCpuThreadsInfo()));
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    fencingEnabledInfo = new InfoIcon(templates.italicText(constants.fencingEnabledInfo()));
    skipFencingIfSDActiveInfo = new InfoIcon(templates.italicText(constants.skipFencingIfSDActiveInfo()));
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(templates.italicText(constants.skipFencingWhenConnectivityBrokenInfo()));
    skipFencingIfGlusterBricksUpInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterBricksUpInfo()));
    skipFencingIfGlusterBricksUpInfo.setVisible(false);
    skipFencingIfGlusterQuorumNotMetInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterQuorumNotMetInfo()));
    skipFencingIfGlusterQuorumNotMetInfo.setVisible(false);
    // $NON-NLS-1$
    isVirtioScsiEnabledInfoIcon = new InfoIcon(templates.italicText(""));
}
#method_after
private void initInfoIcons() {
    memoryOptimizationInfo = new InfoIcon(templates.italicText(constants.clusterPopupMemoryOptimizationInfo()));
    cpuThreadsInfo = new InfoIcon(templates.italicText(constants.clusterPopupCpuThreadsInfo()));
    schedulerOptimizationInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    allowOverbookingInfoIcon = new InfoIcon(SafeHtmlUtils.EMPTY_SAFE_HTML);
    fencingEnabledInfo = new InfoIcon(templates.italicText(constants.fencingEnabledInfo()));
    skipFencingIfSDActiveInfo = new InfoIcon(templates.italicText(constants.skipFencingIfSDActiveInfo()));
    skipFencingIfConnectivityBrokenInfo = new InfoIcon(templates.italicText(constants.skipFencingWhenConnectivityBrokenInfo()));
    skipFencingIfGlusterBricksUpInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterBricksUpInfo()));
    skipFencingIfGlusterBricksUpInfo.setVisible(false);
    skipFencingIfGlusterQuorumNotMetInfo = new InfoIcon(templates.italicText(constants.skipFencingIfGlusterQuorumNotMetInfo()));
    skipFencingIfGlusterQuorumNotMetInfo.setVisible(false);
    // $NON-NLS-1$
    isVirtioScsiEnabledInfoIcon = new InfoIcon(templates.italicText(""));
    logMaxMemoryUsedThresholdInfoIcon = new InfoIcon(templates.italicText(constants.logMaxMemoryUsedThresholdLabelHelpMessage()));
}
#end_block

#method_before
public VolumeType getVolumeType(VolumeFormat volumeFormat, StorageType storageType, Image diskImage) {
    switch(volumeFormat) {
        case COW:
            return VolumeType.Sparse;
        case RAW:
        default:
            return storageType.isFileDomain() ? // otherwise we set the volume type as sparse by default for file-based storage domain
            diskImage != null ? diskImage.getVolumeType() : VolumeType.Sparse : VolumeType.Preallocated;
    }
}
#method_after
public VolumeType getVolumeType(VolumeFormat volumeFormat, StorageType storageType, VM vm, Image diskImage) {
    switch(volumeFormat) {
        case COW:
            return VolumeType.Sparse;
        case RAW:
        default:
            boolean copyPreallocatedFileBasedDiskSupported = vm != null ? isCopyPreallocatedFileBasedDiskSupported(vm.getCompatibilityVersion()) : false;
            // if diskImage provided it means that we want to use the source image volume type,
            // otherwise we set the volume type as sparse by default for file-based storage domain
            VolumeType fileBasedVolumeType;
            if (copyPreallocatedFileBasedDiskSupported) {
                fileBasedVolumeType = diskImage != null ? diskImage.getVolumeType() : VolumeType.Sparse;
            } else {
                fileBasedVolumeType = VolumeType.Sparse;
            }
            return storageType.isFileDomain() ? fileBasedVolumeType : VolumeType.Preallocated;
    }
}
#end_block

#method_before
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(volumeFormat, storageDomain.getStorageType(), diskImage.getImage()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#method_after
private void updateImageToDestinationDomainMap() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        StorageDomain storageDomain = diskModel.getStorageDomain().getSelectedItem();
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
        diskImage.setDiskAlias(diskModel.getAlias().getEntity());
        DiskProfile diskProfile = diskModel.getDiskProfile().getSelectedItem();
        diskImage.setDiskProfileId(diskProfile != null ? diskProfile.getId() : null);
        if (diskModel.getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(diskModel.getQuota().getSelectedItem().getId());
        }
        if (diskModel.getVolumeFormat().getIsAvailable()) {
            VolumeFormat volumeFormat = diskModel.getVolumeFormat().getSelectedItem();
            diskImage.setVolumeFormat(volumeFormat);
            diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(volumeFormat, storageDomain.getStorageType(), diskModel.getVm(), diskImage.getImage()));
        } else if (diskModel.getVolumeType().getIsAvailable()) {
            VolumeType volumeType = diskModel.getVolumeType().getSelectedItem();
            diskImage.setVolumeType(volumeType);
            diskImage.setVolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(volumeType, storageDomain.getStorageType()));
        }
        imageToDestinationDomainMap.put(diskImage.getId(), diskImage);
    }
}
#end_block

#method_before
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setSize(getVirtualSize());
        diskImage.setActualSizeInBytes(imageInfoModel.getActualSize());
        diskImage.setVolumeFormat(getImageInfoModel().getFormat());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(diskImage.getVolumeFormat(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType(), null));
        diskImage.setContentType(getImageInfoModel().getContentType());
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#method_after
public boolean flush() {
    if (validate()) {
        diskModel.flush();
        DiskImage diskImage = (DiskImage) getDiskModel().getDisk();
        diskImage.setSize(getVirtualSize());
        diskImage.setActualSizeInBytes(imageInfoModel.getActualSize());
        diskImage.setVolumeFormat(getImageInfoModel().getFormat());
        diskImage.setVolumeType(AsyncDataProvider.getInstance().getVolumeType(diskImage.getVolumeFormat(), getDiskModel().getStorageDomain().getSelectedItem().getStorageType(), null, null));
        diskImage.setContentType(getImageInfoModel().getContentType());
        return true;
    } else {
        setIsValid(false);
    }
    return false;
}
#end_block

#method_before
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = getDiskImagesToValidate();
    List<DiskImage> allDiskImagesInSrcAndDstToValidate = getAllDiskImagesInSrcAndDstToValidate();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    DiskImagesValidator allDiskImagesInChainValidator = new DiskImagesValidator(allDiskImagesInSrcAndDstToValidate);
    return validateImagesNotLocked(diskImagesValidator) && (getVm().isQualifiedForLiveSnapshotMerge() || validate(allDiskImagesInChainValidator.diskImagesNotIllegal())) && (!getVm().isQualifiedForLiveSnapshotMerge() || validateSnapshotDisksArePlugged());
}
#method_after
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = getDiskImagesToValidate();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    List<DiskImage> allDiskImagesInSrcAndDstToValidate = getAllDiskImagesInSrcAndDstToValidate();
    DiskImagesValidator allDiskImagesInChainValidator = new DiskImagesValidator(allDiskImagesInSrcAndDstToValidate);
    return validateImagesNotLocked(diskImagesValidator) && (getVm().isQualifiedForLiveSnapshotMerge() || validate(allDiskImagesInChainValidator.diskImagesNotIllegal())) && (!getVm().isQualifiedForLiveSnapshotMerge() || validateSnapshotDisksArePlugged());
}
#end_block

#method_before
private List<DiskImage> getAllDiskImagesInSrcAndDstToValidate() {
    List<DiskImage> allDiskImages = new ArrayList<>();
    List<DiskImage> sourceImages = getSourceImages();
    sourceImages.stream().map(DiskImage::getImageId).forEach(d -> allDiskImages.addAll(diskImageDao.getAllSnapshotsForParent(d)));
    allDiskImages.addAll(sourceImages);
    return allDiskImages;
}
#method_after
private List<DiskImage> getAllDiskImagesInSrcAndDstToValidate() {
    List<Guid> parentsIds = getSourceImages().stream().map(DiskImage::getImageId).collect(Collectors.toList());
    List<DiskImage> allDiskImages = new ArrayList<>(diskImageDao.getAllSnapshotsForParents(parentsIds));
    allDiskImages.addAll(getSourceImages());
    return allDiskImages;
}
#end_block

#method_before
private void initInfoIcon() {
    consoleAddressInfoIcon = new InfoIcon(templates.italicText(constants.enableConsoleAddressOverrideHelpMessage()));
    // vncEncryptionEnabledInfoIcon =
    // new InfoIcon(templates.italicText(constants.vncEncryptionEnabledHelpMessage()));
    providerSearchInfoIcon = new InfoIcon(templates.italicText(constants.providerSearchInfo()));
    provisionedHostInfoIcon = new InfoIcon(templates.italicText(constants.provisionedHostInfo()));
    discoveredHostInfoIcon = new InfoIcon(templates.italicText(constants.discoveredHostInfoIcon()));
    hostAddressInfoIcon = new InfoIcon(templates.italicText(constants.hostPopupHostAddressLabelHelpMessage()));
}
#method_after
private void initInfoIcon() {
    consoleAddressInfoIcon = new InfoIcon(templates.italicText(constants.enableConsoleAddressOverrideHelpMessage()));
    providerSearchInfoIcon = new InfoIcon(templates.italicText(constants.providerSearchInfo()));
    provisionedHostInfoIcon = new InfoIcon(templates.italicText(constants.provisionedHostInfo()));
    discoveredHostInfoIcon = new InfoIcon(templates.italicText(constants.discoveredHostInfoIcon()));
    hostAddressInfoIcon = new InfoIcon(templates.italicText(constants.hostPopupHostAddressLabelHelpMessage()));
}
#end_block

#method_before
public void removeVmDevices(List<VmDevice> devices) {
    removeVmDevices(devices, devices.size());
}
#method_after
public void removeVmDevices(List<VmDevice> devices) {
    devices.stream().map(VmDevice::getId).forEach(vmDeviceDao::remove);
}
#end_block

#method_before
public void removeVmDevices(List<VmDevice> devices, int numberOfDevicesToRemove) {
    int size = devices.size();
    int maxIndex = Math.min(numberOfDevicesToRemove, size);
    for (int index = 1; index <= maxIndex; index++) {
        vmDeviceDao.remove(devices.get(size - index).getId());
    }
}
#method_after
public void removeVmDevices(List<VmDevice> devices, int numberOfDevicesToRemove) {
    int size = devices.size();
    removeVmDevices(devices.subList(Math.max(size - numberOfDevicesToRemove, 0), size));
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getNextCommandStep());
    switch(getParameters().getNextCommandStep()) {
        case UPDATE_OVF_STORE:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.UPDATE_OVF_STORE);
            runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), cloneContext().withoutCompensationContext());
            getParameters().setNextCommandStep(DeactivateStorageDomainWithOvfUpdateStep.DEACTIVATE_STORAGE_DOMAIN);
            break;
        case DEACTIVATE_STORAGE_DOMAIN:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.DEACTIVATE_STORAGE_DOMAIN);
            executeDeactivateCommand();
            getParameters().setNextCommandStep(DeactivateStorageDomainWithOvfUpdateStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.COMPLETE);
            setCommandStatus(CommandStatus.SUCCEEDED);
            return false;
    }
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getNextCommandStep());
    switch(getParameters().getNextCommandStep()) {
        case UPDATE_OVF_STORE:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.UPDATE_OVF_STORE);
            runInternalAction(ActionType.UpdateOvfStoreForStorageDomain, createUpdateOvfStoreParams(), cloneContext().withoutCompensationContext());
            getParameters().setNextCommandStep(DeactivateStorageDomainWithOvfUpdateStep.DEACTIVATE_STORAGE_DOMAIN);
            break;
        case DEACTIVATE_STORAGE_DOMAIN:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.DEACTIVATE_STORAGE_DOMAIN);
            executeDeactivateCommand();
            getParameters().setNextCommandStep(DeactivateStorageDomainWithOvfUpdateStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setCommandStep(DeactivateStorageDomainWithOvfUpdateStep.COMPLETE);
            setCommandStatus(CommandStatus.SUCCEEDED);
            return false;
    }
    persistCommandIfNeeded();
    return true;
}
#end_block

#method_before
@Test
public void testNumaNodesWithoutPinning() {
    vm.setvNumaNodeList(Arrays.asList(createVmNode(NODE_SIZE, 0, Collections.emptyList()), createVmNode(NODE_SIZE, 1, Collections.emptyList())));
    List<VDS> passedHosts = filter();
    assertThat(passedHosts).containsOnly(hostTwoNodes, hostFourNodes);
}
#method_after
@Test
public void testNumaNodesWithoutPinning() {
    vm.setvNumaNodeList(Arrays.asList(createVmNode(NODE_SIZE, 0, Collections.emptyList()), createVmNode(NODE_SIZE, 1, Collections.emptyList())));
    List<VDS> passedHosts = filter();
    assertThat(passedHosts).containsOnly(hostWithoutNuma, hostTwoNodes, hostFourNodes);
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.CpuPinMigrationEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
    }
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type & ppc architecture
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop && !clusterHasPpcArchitecture());
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    getModel().getIoThreadsEnabled().setEntity(vmType == VmType.Server || vmType == VmType.HighPerformance);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Console tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.IMPLICITLY_NON_MIGRATABLE, MigrationSupport.PINNED_TO_HOST));
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resource allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
        if (getModel().getMultiQueues().getIsAvailable()) {
            getModel().getMultiQueues().setEntity(true);
        }
    } else {
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    }
}
#method_after
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type & ppc architecture
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop && !clusterHasPpcArchitecture());
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    getModel().getIoThreadsEnabled().setEntity(vmType == VmType.Server || vmType == VmType.HighPerformance);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Console tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.IMPLICITLY_NON_MIGRATABLE, MigrationSupport.PINNED_TO_HOST));
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resource allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
    } else {
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    }
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getIsAutoAssign().getEntity() == null) {
        return;
    }
    if (getModel().getSelectedCluster() != null) {
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        getModel().getCpuPinning().setIsChangeable(hasCpuPinning);
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
        }
    }
}
#end_block

#method_before
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = glusterUtil.getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : volumeDao.getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // self heal info can be fetched only for started volumes
        if (volume.isOnline()) {
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#method_after
public void refreshSelfHealData(Cluster cluster) {
    VDS upServer = glusterUtil.getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debug("No server UP in cluster '{}'. Can't refresh self heal data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : volumeDao.getByClusterId(cluster.getId())) {
        log.debug("Refreshing self heal status for volume '{}' of cluster '{}'", volume.getName(), cluster.getName());
        // and for replica type volumes
        if (volume.isOnline() && volume.getVolumeType().isReplicatedType()) {
            try {
                refreshSelfHealData(upServer, volume);
            } catch (Exception e) {
                log.error("Error while refreshing brick statuses for volume '{}' of cluster '{}': {}", volume.getName(), cluster.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
}
#end_block

#method_before
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<Stream<T>, R> reduce) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    Stream<T> data = bricks.stream().map(field);
    return reduce.apply(data);
}
#method_after
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<List<Stream<T>>, R> reduce) {
    List<GlusterBrickEntity> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).collect(Collectors.toList());
    if (extractBrickData(bricks, field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    List<Stream<T>> replicaSets = new ArrayList<>();
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            while (!bricks.isEmpty()) {
                int replicaCounter = 0;
                List<GlusterBrickEntity> set = new ArrayList<>();
                while (replicaCounter < volume.getReplicaCount() && !bricks.isEmpty()) {
                    set.add(bricks.get(0));
                    bricks.remove(0);
                    replicaCounter++;
                }
                replicaSets.add(extractBrickData(set, field));
            }
            break;
        default:
            replicaSets = Collections.singletonList(extractBrickData(bricks, field));
            break;
    }
    return reduce.apply(replicaSets);
}
#end_block

#method_before
private Function<Stream<Double>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (Stream<Double> data) -> {
        Stream<Double> brickSizes = data.map(v -> v * SizeConverter.BYTES_IN_MB);
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return brickSizes.map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTE:
            case DISTRIBUTED_REPLICATE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return brickSizes.mapToLong(Double::longValue).sum();
        }
    };
}
#method_after
private Function<List<Stream<Double>>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (List<Stream<Double>> data) -> {
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTED_REPLICATE:
                return data.stream().map(b -> b.map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null)).filter(Objects::nonNull).mapToLong(s -> s).sum();
            case DISTRIBUTE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).mapToLong(Double::longValue).sum();
        }
    };
}
#end_block

#method_before
private Integer reduceBricksToSavings(Stream<Integer> data) {
    return data.collect(Collectors.averagingInt(Integer::intValue)).intValue();
}
#method_after
private Integer reduceBricksToSavings(List<Stream<Integer>> data) {
    return data.stream().flatMap(Function.identity()).collect(Collectors.averagingInt(Integer::intValue)).intValue();
}
#end_block

#method_before
public void sendLowConfirmedSpaceEvent(Long confirmedFreeSize, GlusterVolumeEntity volume, List<Guid> sdId) {
    Long confirmedTotalSize = this.calculateConfirmedVolumeTotal(volume);
    Double percentUsedSize = (1 - (confirmedFreeSize.doubleValue() / confirmedTotalSize)) * 100;
    sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() < percentUsedSize).forEach(sd -> {
        AuditLogable event = new AuditLogableImpl();
        event.setStorageDomainId(sd.getId());
        event.setStorageDomainName(sd.getName());
        event.setRepeatable(true);
        event.addCustomValue("DiskSpace", String.valueOf(confirmedFreeSize / SizeConverter.BYTES_IN_GB));
        auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
    });
}
#method_after
public void sendLowConfirmedSpaceEvent(Long confirmedFreeSize, GlusterVolumeEntity volume, List<Guid> sdId) {
    Long confirmedTotalSize = this.calculateConfirmedVolumeTotal(volume);
    Double percentFreeSize = (confirmedFreeSize.doubleValue() / confirmedTotalSize) * 100;
    sdId.stream().map(storageDomainStaticDao::get).filter(s -> s.getWarningLowConfirmedSpaceIndicator() != null).filter(s -> s.getWarningLowConfirmedSpaceIndicator() > percentFreeSize).forEach(sd -> {
        AuditLogable event = new AuditLogableImpl();
        event.setStorageDomainId(sd.getId());
        event.setStorageDomainName(sd.getName());
        event.setRepeatable(true);
        event.addCustomValue("DiskSpace", String.valueOf(confirmedFreeSize / SizeConverter.BYTES_IN_GB));
        auditLogDirector.log(event, AuditLogType.IRS_CONFIRMED_DISK_SPACE_LOW);
    });
}
#end_block

#method_before
private boolean addImageTicketToDaemon(Guid imagedTicketId, long timeout) {
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getAllowedOperation() };
    boolean sparse = getDiskImage().getVolumeType() == VolumeType.Sparse && getStorageDomain().getStorageType().isFileDomain();
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename(), sparse);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = vdsBroker.runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    return true;
}
#method_after
private boolean addImageTicketToDaemon(Guid imagedTicketId, long timeout) {
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (getParameters().getTransferType() == TransferType.Upload && !setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getAllowedOperation() };
    // Sparse is not supported yet for block storage in imageio. See BZ#1619006.
    boolean sparse = getDiskImage().getVolumeType() == VolumeType.Sparse && getStorageDomain().getStorageType().isFileDomain();
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath, getParameters().getDownloadFilename(), sparse);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = vdsBroker.runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    return true;
}
#end_block

#method_before
@Override
public IQNListReturn discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturn(response);
}
#method_after
@Override
public IQNListReturn discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).withOptionalParameter("ipv6_enabled", args.get("ipv6_enabled")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturn(response);
}
#end_block

#method_before
public Map<String, String> createStructFromConnection(final StorageServerConnections connection, final Guid vdsId) {
    Pair<String, String> credentials = getStorageConnectionCredentialsForhost(vdsId, connection);
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getId(), Guid.Empty.toString());
    con.put("connection", connection.getConnection(), "");
    con.putIfNotEmpty("tpgt", connection.getPortal());
    con.put("port", connection.getPort(), "");
    con.put("iqn", connection.getIqn(), "");
    con.put("user", credentials.getFirst(), "");
    con.put("password", credentials.getSecond(), "");
    con.put("ipv6_enabled", isValidIpv6(vdsId, connection.getConnection()), "false");
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfaceName", connection.getNetIfaceName());
    // For mnt_options, vfs_type, and protocol_version - if they are null
    // or empty we should not send a key with an empty value
    con.putIfNotEmpty("mnt_options", connection.getMountOptions());
    con.putIfNotEmpty("vfs_type", connection.getVfsType());
    if (connection.getNfsVersion() != null) {
        con.put("protocol_version", connection.getNfsVersion().getValue());
    }
    con.putIfNotEmpty("timeout", connection.getNfsTimeo());
    con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    return con;
}
#method_after
public Map<String, String> createStructFromConnection(final StorageServerConnections connection, final Guid vdsId) {
    Pair<String, String> credentials = getStorageConnectionCredentialsForhost(vdsId, connection);
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getId(), Guid.Empty.toString());
    con.put("connection", connection.getConnection(), "");
    con.putIfNotEmpty("tpgt", connection.getPortal());
    con.put("port", connection.getPort(), "");
    con.put("iqn", connection.getIqn(), "");
    con.put("user", credentials.getFirst(), "");
    con.put("password", credentials.getSecond(), "");
    if (FeatureSupported.ipv6IscsiSupported(vdsDao.get(vdsId).getClusterCompatibilityVersion())) {
        con.put("ipv6_enabled", isValidIpv6(connection.getConnection()), "false");
    }
    con.putIfNotEmpty("ifaceName", connection.getIface());
    con.putIfNotEmpty("netIfaceName", connection.getNetIfaceName());
    // For mnt_options, vfs_type, and protocol_version - if they are null
    // or empty we should not send a key with an empty value
    con.putIfNotEmpty("mnt_options", connection.getMountOptions());
    con.putIfNotEmpty("vfs_type", connection.getVfsType());
    if (connection.getNfsVersion() != null) {
        con.put("protocol_version", connection.getNfsVersion().getValue());
    }
    con.putIfNotEmpty("timeout", connection.getNfsTimeo());
    con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    return con;
}
#end_block

#method_before
private boolean isValidIpv6(Guid hostId, String address) {
    return ValidationUtils.isValidIpv6(address) && FeatureSupported.ipv6Supported(vdsDao.get(hostId).getClusterCompatibilityVersion());
}
#method_after
private boolean isValidIpv6(String address) {
    return ValidationUtils.isValidIpv6(address);
}
#end_block

#method_before
protected void updateDeviceProperties() {
    VmDevice device = vmDeviceDao.get(oldVmDevice.getId());
    device.setPlugged(true);
    device.setAlias(FeatureSupported.isDomainXMLSupported(getVm().getClusterCompatibilityVersion()) ? String.format("%s%s", DomainXmlUtils.USER_ALIAS_PREFIX, getDisk().getId()) : null);
    vmDeviceDao.updateHotPlugDisk(device);
}
#method_after
protected void updateDeviceProperties() {
    VmDevice device = vmDeviceDao.get(oldVmDevice.getId());
    device.setPlugged(true);
    device.setAlias(getDeviceAliasForDisk(disk));
    vmDeviceDao.updateHotPlugDisk(device);
}
#end_block

#method_before
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", null, true, getParameters().isPlugUnPlug(), getDiskVmElement().isReadOnly(), FeatureSupported.isDomainXMLSupported(getVm().getClusterCompatibilityVersion()) ? String.format("%s%s", DomainXmlUtils.USER_ALIAS_PREFIX, disk.getId()) : "", null, getParameters().getSnapshotId(), null);
}
#method_after
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", null, true, getParameters().isPlugUnPlug(), getDiskVmElement().isReadOnly(), getDeviceAliasForDisk(disk), null, getParameters().getSnapshotId(), null);
}
#end_block

#method_before
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    AnsibleReturnValue returnValue = new AnsibleReturnValue(AnsibleReturnCode.ERROR);
    Path inventoryFile = null;
    Process ansibleProcess = null;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().command(ansibleCommand).directory(command.playbookDir().toFile());
        // Ignore stdout/stderr, if don't care about output from stdout callback plugin to avoid process stuck:
        if (command.stdoutCallback() == null) {
            ansibleProcessBuilder.redirectErrorStream(true).redirectOutput(new File("/dev/null"));
        }
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        if (command.enableLogging()) {
            ansibleProcessBuilder.environment().put("ANSIBLE_LOG_PATH", command.logFile().toString());
        }
        if (command.stdoutCallback() != null) {
            ansibleProcessBuilder.environment().put(AnsibleEnvironmentConstants.ANSIBLE_STDOUT_CALLBACK, command.stdoutCallback());
        }
        // Execute the command:
        ansibleProcess = ansibleProcessBuilder.start();
        // Read the output of the ansible-playbook:
        StringBuilder out = new StringBuilder();
        BufferedReader reader = new BufferedReader(new InputStreamReader(ansibleProcess.getInputStream()));
        String line;
        while ((line = reader.readLine()) != null) {
            out.append(line);
        }
        // Wait for process to finish:
        if (!ansibleProcess.waitFor(timeout, TimeUnit.MINUTES)) {
            throw new Exception("Timeout occurred while executing Ansible playbook.");
        }
        returnValue.setAnsibleReturnCode(AnsibleReturnCode.values()[ansibleProcess.exitValue()]);
        if (command.stdoutCallback() != null) {
            returnValue.setStdout(out.toString());
        }
    } catch (Throwable t) {
        log.error("Ansible playbook execution failed: {}", t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    } finally {
        if (ansibleProcess != null) {
            ansibleProcess.destroy();
        }
        log.info("Ansible playbook command has exited with value: {}", returnValue.getAnsibleReturnCode());
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnValue;
}
#method_after
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    AnsibleReturnValue returnValue = new AnsibleReturnValue(AnsibleReturnCode.ERROR);
    Path inventoryFile = null;
    Process ansibleProcess = null;
    File stdoutFile = new File("/dev/null");
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Create file where stdout will be redirected:
        if (command.stdoutCallback() != null) {
            stdoutFile = Files.createTempFile("playbook-out", ".tmp").toFile();
        }
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().command(ansibleCommand).directory(command.playbookDir().toFile()).redirectErrorStream(command.stdoutCallback() == null).redirectOutput(stdoutFile);
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        if (command.enableLogging()) {
            ansibleProcessBuilder.environment().put("ANSIBLE_LOG_PATH", command.logFile().toString());
        }
        if (command.stdoutCallback() != null) {
            ansibleProcessBuilder.environment().put(AnsibleEnvironmentConstants.ANSIBLE_STDOUT_CALLBACK, command.stdoutCallback());
        }
        // Execute the command:
        ansibleProcess = ansibleProcessBuilder.start();
        // Wait for process to finish:
        if (!ansibleProcess.waitFor(timeout, TimeUnit.MINUTES)) {
            throw new Exception("Timeout occurred while executing Ansible playbook.");
        }
        returnValue.setAnsibleReturnCode(AnsibleReturnCode.values()[ansibleProcess.exitValue()]);
        if (command.stdoutCallback() != null) {
            returnValue.setStdout(new String(Files.readAllBytes(stdoutFile.toPath())));
        }
    } catch (Throwable t) {
        log.error("Ansible playbook execution failed: {}", t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    } finally {
        if (ansibleProcess != null) {
            ansibleProcess.destroy();
        }
        log.info("Ansible playbook command has exited with value: {}", returnValue.getAnsibleReturnCode());
        removeFile(inventoryFile);
        removeFile(stdoutFile.toPath());
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnValue;
}
#end_block

#method_before
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    mapCommonModelToEntity(entity, model);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
    }
    if (model.isSetBiosType()) {
        entity.setBiosType(map(model.getBiosType(), null));
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimeZone()) {
        if (model.getTimeZone().isSetName()) {
            String timezone = model.getTimeZone().getName();
            if (timezone.isEmpty()) {
                // normalize default timezone representation
                timezone = null;
            }
            entity.setTimeZone(timezone);
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        entity.setVmType(mapVmType(model.getType()));
    }
    if (model.isSetStorageErrorResumeBehaviour()) {
        entity.setResumeBehavior(mapResumeBehavior(model.getStorageErrorResumeBehaviour()));
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperties()));
    }
    if (model.isSetLargeIcon() && model.getLargeIcon().isSetId()) {
        entity.setLargeIconId(GuidUtils.asGuid(model.getLargeIcon().getId()));
    }
    if (model.isSetSmallIcon() && model.getSmallIcon().isSetId()) {
        entity.setSmallIconId(GuidUtils.asGuid(model.getSmallIcon().getId()));
    }
    if (model.isSetQuota() && model.getQuota().isSetId()) {
        entity.setQuotaId(GuidUtils.asGuid(model.getQuota().getId()));
    }
    if (model.isSetLease()) {
        entity.setLeaseStorageDomainId(StorageDomainLeaseMapper.map(model.getLease()));
    }
    if (model.isSetMultiQueuesEnabled()) {
        entity.setMultiQueuesEnabled(model.isMultiQueuesEnabled());
    }
}
#method_after
protected static void mapVmBaseModelToEntity(org.ovirt.engine.core.common.businessentities.VmBase entity, VmBase model) {
    mapCommonModelToEntity(entity, model);
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetBios()) {
        if (model.getBios().isSetBootMenu()) {
            entity.setBootMenuEnabled(model.getBios().getBootMenu().isEnabled());
        }
        if (model.getBios().isSetType()) {
            entity.setBiosType(map(model.getBios().getType(), null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
        if (model.getDisplay().isSetFileTransferEnabled()) {
            entity.setSpiceFileTransferEnabled(model.getDisplay().isFileTransferEnabled());
        }
        if (model.getDisplay().isSetCopyPasteEnabled()) {
            entity.setSpiceCopyPasteEnabled(model.getDisplay().isCopyPasteEnabled());
        }
        if (model.getDisplay().isSetDisconnectAction()) {
            DisplayDisconnectAction action = DisplayDisconnectAction.fromValue(model.getDisplay().getDisconnectAction());
            entity.setConsoleDisconnectAction(map(action, null));
        }
    }
    if (model.isSetTimeZone()) {
        if (model.getTimeZone().isSetName()) {
            String timezone = model.getTimeZone().getName();
            if (timezone.isEmpty()) {
                // normalize default timezone representation
                timezone = null;
            }
            entity.setTimeZone(timezone);
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        entity.setVmType(mapVmType(model.getType()));
    }
    if (model.isSetStorageErrorResumeBehaviour()) {
        entity.setResumeBehavior(mapResumeBehavior(model.getStorageErrorResumeBehaviour()));
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetStartPaused()) {
        entity.setRunAndPause(model.isStartPaused());
    }
    if (model.isSetCpuProfile() && model.getCpuProfile().isSetId()) {
        entity.setCpuProfileId(GuidUtils.asGuid(model.getCpuProfile().getId()));
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperties()));
    }
    if (model.isSetLargeIcon() && model.getLargeIcon().isSetId()) {
        entity.setLargeIconId(GuidUtils.asGuid(model.getLargeIcon().getId()));
    }
    if (model.isSetSmallIcon() && model.getSmallIcon().isSetId()) {
        entity.setSmallIconId(GuidUtils.asGuid(model.getSmallIcon().getId()));
    }
    if (model.isSetQuota() && model.getQuota().isSetId()) {
        entity.setQuotaId(GuidUtils.asGuid(model.getQuota().getId()));
    }
    if (model.isSetLease()) {
        entity.setLeaseStorageDomainId(StorageDomainLeaseMapper.map(model.getLease()));
    }
    if (model.isSetMultiQueuesEnabled()) {
        entity.setMultiQueuesEnabled(model.isMultiQueuesEnabled());
    }
}
#end_block

#method_before
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    mapCommonEntityToModel(model, entity);
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(mapVmType(entity.getVmType()));
    }
    if (entity.getResumeBehavior() != null) {
        model.setStorageErrorResumeBehaviour(mapResumeBehavior(entity.getResumeBehavior()));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getBiosType() != null) {
        model.setBiosType(map(entity.getBiosType(), null));
    }
    if (entity.getTimeZone() != null) {
        model.setTimeZone(new TimeZone());
        model.getTimeZone().setName(entity.getTimeZone());
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    model.setCpuShares(entity.getCpuShares());
    if (entity.getLargeIconId() != null) {
        if (!model.isSetLargeIcon()) {
            model.setLargeIcon(new Icon());
        }
        model.getLargeIcon().setId(entity.getLargeIconId().toString());
    }
    if (entity.getSmallIconId() != null) {
        if (!model.isSetSmallIcon()) {
            model.setSmallIcon(new Icon());
        }
        model.getSmallIcon().setId(entity.getSmallIconId().toString());
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setLease(StorageDomainLeaseMapper.map(entity.getLeaseStorageDomainId()));
    model.setMultiQueuesEnabled(entity.isMultiQueuesEnabled());
}
#method_after
protected static void mapVmBaseEntityToModel(VmBase model, org.ovirt.engine.core.common.businessentities.VmBase entity) {
    mapCommonEntityToModel(model, entity);
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    if (entity.getVmType() != null) {
        model.setType(mapVmType(entity.getVmType()));
    }
    if (entity.getResumeBehavior() != null) {
        model.setStorageErrorResumeBehaviour(mapResumeBehavior(entity.getResumeBehavior()));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setBios(new Bios());
    model.getBios().setBootMenu(new BootMenu());
    model.getBios().getBootMenu().setEnabled(entity.isBootMenuEnabled());
    if (entity.getBiosType() != null) {
        model.getBios().setType(map(entity.getBiosType(), null));
    }
    if (entity.getTimeZone() != null) {
        model.setTimeZone(new TimeZone());
        model.getTimeZone().setName(entity.getTimeZone());
    }
    if (entity.getVmInit() != null && entity.getVmInit().getDomain() != null && StringUtils.isNotBlank(entity.getVmInit().getDomain())) {
        Domain domain = new Domain();
        domain.setName(entity.getVmInit().getDomain());
        model.setDomain(domain);
    }
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setTunnelMigration(entity.getTunnelMigration());
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    model.setStartPaused(entity.isRunAndPause());
    if (entity.getCpuProfileId() != null) {
        CpuProfile cpuProfile = new CpuProfile();
        cpuProfile.setId(entity.getCpuProfileId().toString());
        model.setCpuProfile(cpuProfile);
    }
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    model.setCpuShares(entity.getCpuShares());
    if (entity.getLargeIconId() != null) {
        if (!model.isSetLargeIcon()) {
            model.setLargeIcon(new Icon());
        }
        model.getLargeIcon().setId(entity.getLargeIconId().toString());
    }
    if (entity.getSmallIconId() != null) {
        if (!model.isSetSmallIcon()) {
            model.setSmallIcon(new Icon());
        }
        model.getSmallIcon().setId(entity.getSmallIconId().toString());
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setLease(StorageDomainLeaseMapper.map(entity.getLeaseStorageDomainId()));
    model.setMultiQueuesEnabled(entity.isMultiQueuesEnabled());
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean ovmfEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !ovmfEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (ovmfEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean secureBootEnabled = vm.getBiosType() == BiosType.Q35_SECURE_BOOT;
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !secureBootEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (secureBootEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
public void init(final Collection<VmTemplate> externalTemplates, final Guid dataCenterId) {
    setCloseCommand(new UICommand(null, this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsDefault(true).setIsCancel(true));
    Map<VmTemplate, List<DiskImage>> templateToDisks = externalTemplates.stream().collect(Collectors.toMap(template -> template, template -> new ArrayList<>(template.getDiskTemplateMap().values())));
    templateToDisks.keySet().forEach(template -> {
        List<DiskImage> disks = template.getDiskList();
        disks.sort(new LexoNumericNameableComparator<>());
        templateToDisks.put(template, disks);
    });
    ((TemplateImportDiskListModel) getImportDiskListModel()).setExtendedItems(new ArrayList<>(templateToDisks.entrySet()));
    Frontend.getInstance().runQuery(QueryType.Search, new SearchParameters(createSearchPattern(externalTemplates), SearchType.VmTemplate), new AsyncQuery<>(new AsyncCallback<QueryReturnValue>() {

        @Override
        public void onSuccess(QueryReturnValue returnValue) {
            UIConstants constants = ConstantsManager.getInstance().getConstants();
            List<VmTemplate> vmtList = returnValue.getReturnValue();
            List<ImportTemplateData> templateDataList = new ArrayList<>();
            for (VmTemplate template : externalTemplates) {
                ImportTemplateData templateData = new ImportTemplateData(template);
                boolean templateExistsInSystem = vmtList.contains(template);
                templateData.setExistsInSystem(templateExistsInSystem);
                if (templateExistsInSystem) {
                    templateData.enforceClone(constants.importTemplateThatExistsInSystemMustClone());
                } else if (!template.isBaseTemplate() && findAnyVmTemplateById(vmtList, template.getBaseTemplateId()) == null) {
                    templateData.enforceClone(constants.importTemplateWithoutBaseMustClone());
                }
                templateDataList.add(templateData);
            }
            setItems(templateDataList);
            withDataCenterLoaded(r -> doInit(), dataCenterId);
        }

        private VmTemplate findAnyVmTemplateById(List<VmTemplate> vmtList, Guid templateId) {
            for (VmTemplate vmt : vmtList) {
                if (templateId.equals(vmt.getId())) {
                    return vmt;
                }
            }
            return null;
        }
    }));
}
#method_after
public void init(final Collection<VmTemplate> externalTemplates, final Guid dataCenterId) {
    setCloseCommand(new UICommand(null, this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsDefault(true).setIsCancel(true));
    Map<VmTemplate, List<DiskImage>> templateToDisks = externalTemplates.stream().collect(Collectors.toMap(template -> template, template -> new ArrayList<>(template.getDiskTemplateMap().values())));
    templateToDisks.keySet().forEach(template -> {
        List<DiskImage> disks = template.getDiskList();
        disks.sort(new LexoNumericNameableComparator<>());
        templateToDisks.put(template, disks);
    });
    ((TemplateImportDiskListModel) getImportDiskListModel()).setExtendedItems(new ArrayList<>(templateToDisks.entrySet()));
    AsyncDataProvider.getInstance().getTemplateList(createSearchPattern(externalTemplates), new AsyncQuery<>(returnValue -> {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        List<ImportTemplateData> templateDataList = new ArrayList<>();
        List<VmTemplate> vmtList = returnValue.getReturnValue();
        for (VmTemplate template : externalTemplates) {
            ImportTemplateData templateData = new ImportTemplateData(template);
            boolean templateExistsInSystem = vmtList.contains(template);
            templateData.setExistsInSystem(templateExistsInSystem);
            if (templateExistsInSystem) {
                templateData.enforceClone(constants.importTemplateThatExistsInSystemMustClone());
            } else if (!template.isBaseTemplate() && vmtList.stream().anyMatch(t -> t.getId().equals(template.getBaseTemplateId()))) {
                templateData.enforceClone(constants.importTemplateWithoutBaseMustClone());
            }
            templateDataList.add(templateData);
        }
        setItems(templateDataList);
        withDataCenterLoaded(r -> doInit(), dataCenterId);
    }));
}
#end_block

#method_before
@Override
public void edit(final ImportTemplatesModel model) {
    templatesTable.edit(model.getExternalTemplatesModels(), model.getImportedTemplatesModels(), model.getAddImportCommand(), model.getCancelImportCommand());
    driver.edit(model);
    model.getProblemDescription().getEntityChangedEvent().addListener((ev, object, args) -> updateErrorAndWarning(model));
    updateErrorAndWarning(model);
    updatePanelsVisibility(model);
    model.getImportSources().getSelectedItemChangedEvent().addListener((ev, sender, args) -> updatePanelsVisibility(model));
    loadVmsFromExportDomainButton.addClickHandler(event -> model.loadTemplatesFromExportDomain());
    loadOvaButton.addClickHandler(event -> model.loadVmFromOva());
}
#method_after
@Override
public void edit(final ImportTemplatesModel model) {
    driver.edit(model);
    templatesTable.edit(model.getExternalTemplatesModels(), model.getImportedTemplatesModels(), model.getAddImportCommand(), model.getCancelImportCommand());
    model.getProblemDescription().getEntityChangedEvent().addListener((ev, object, args) -> updateErrorAndWarning(model));
    updateErrorAndWarning(model);
    updatePanelsVisibility(model);
    model.getImportSources().getSelectedItemChangedEvent().addListener((ev, sender, args) -> updatePanelsVisibility(model));
    loadVmsFromExportDomainButton.addClickHandler(event -> model.loadTemplatesFromExportDomain());
    loadOvaButton.addClickHandler(event -> model.loadVmFromOva());
}
#end_block

#method_before
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getTemplateFromOva(new AsyncQuery<>(returnValue -> {
        if (returnValue.getSucceeded()) {
            Map<VmTemplate, String> templateToOva = returnValue.getReturnValue();
            templateNameToOva = templateToOva.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().getName(), Entry::getValue));
            updateTemplates(templateToOva.keySet());
        } else {
            setError(messages.failedToLoadOva(getOvaPath().getEntity()));
        }
        stopProgress();
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#method_after
public void loadVmFromOva() {
    clearForLoad();
    if (!validateOvaConfiguration()) {
        return;
    }
    startProgress();
    AsyncDataProvider.getInstance().getTemplateFromOva(new AsyncQuery<>(returnValue -> {
        if (returnValue.getSucceeded()) {
            Map<VmTemplate, String> templateToOva = returnValue.getReturnValue();
            templateNameToOva = new HashMap<>();
            templateToOva.forEach((template, ova) -> templateNameToOva.put(template.getName(), ova));
            updateTemplates(templateToOva.keySet());
        } else {
            setError(messages.failedToLoadOva(getOvaPath().getEntity()));
        }
        stopProgress();
    }), getHosts().getSelectedItem().getId(), getOvaPath().getEntity());
}
#end_block

#method_before
@Override
public Host get() {
    Host host = getVdsByVdsId();
    QueryReturnValue queryReturnValue = runQuery(QueryType.GetHostNetworkLocked, new IdQueryParameters(guid));
    boolean inProgress = queryReturnValue != null && queryReturnValue.getReturnValue() != null;
    if (inProgress) {
        host.setNetworkOperationInProgress(true);
    }
    return host;
}
#method_after
@Override
public Host get() {
    return getVdsByVdsId();
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = parent.addHostedEngineIfConfigured(model, entity);
    return host;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = parent.addHostedEngineIfConfigured(model, entity);
    parent.reportNetworkOperationInProgress(host, entity);
    return host;
}
#end_block

#method_before
private void setNetworkOperationInProgressOnVds(VDS vds) {
    LockInfo info = lockManager.getLockInfo(HostLocking.getLockKey(vds.getId()));
    vds.setNetworkOperationInProgress(info != null);
}
#method_after
private void setNetworkOperationInProgressOnVds(VDS vds) {
    vds.setNetworkOperationInProgress(lockManager.isExclusivelyLocked(new EngineLock(hostLocking.getSetupNetworksLock(vds.getId()))));
}
#end_block

#method_before
@BeforeEach
public void mockLockManager() {
    SearchObjectAutoCompleter search = new SearchObjectAutoCompleter();
    when(lockManager.getLockInfo(HostLocking.getLockKey(Guid.Empty))).thenReturn(new LockInfo());
}
#method_after
@BeforeEach
void mockLockManager() {
    SearchObjectAutoCompleter search = new SearchObjectAutoCompleter();
    when(lockManager.isExclusivelyLocked(any())).thenReturn(Boolean.TRUE);
}
#end_block

#method_before
private void writeClock() {
    // <clock offset="variable" adjustment="-3600">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    // for hyperv:
    // <clock offset="variable" adjustment="-3600">
    // <timer name="hypervclock" present="yes">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    writer.writeStartElement("clock");
    writer.writeAttributeString("offset", "variable");
    writer.writeAttributeString("adjustment", String.valueOf(vmInfoBuildUtils.getVmTimeZone(vm)));
    if (hypervEnabled) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hypervclock");
        writer.writeAttributeString("present", "yes");
        writer.writeEndElement();
    }
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "rtc");
    writer.writeAttributeString("tickpolicy", "catchup");
    writer.writeEndElement();
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "pit");
    writer.writeAttributeString("tickpolicy", "delay");
    writer.writeEndElement();
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hpet");
        writer.writeAttributeString("present", "no");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeClock() {
    // <clock offset="variable" adjustment="-3600">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    // for hyperv:
    // <clock offset="variable" adjustment="-3600">
    // <timer name="hypervclock" present="yes">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    writer.writeStartElement("clock");
    writer.writeAttributeString("offset", "variable");
    writer.writeAttributeString("adjustment", String.valueOf(vmInfoBuildUtils.getVmTimeZone(vm)));
    if (hypervEnabled) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hypervclock");
        writer.writeAttributeString("present", "yes");
        writer.writeEndElement();
    }
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "rtc");
    writer.writeAttributeString("tickpolicy", "catchup");
    writer.writeEndElement();
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "pit");
    writer.writeAttributeString("tickpolicy", "delay");
    writer.writeEndElement();
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hpet");
        writer.writeAttributeString("present", "no");
        writer.writeEndElement();
    }
    if (vm.getBiosType().isOvmf()) {
        writer.writeStartElement("loader");
        writer.writeAttributeString("readonly", "yes");
        writer.writeAttributeString("secure", vm.getBiosType() == BiosType.Q35_SECURE_BOOT ? "yes" : "no");
        writer.writeAttributeString("type", "pflash");
        writer.writeRaw("/usr/share/OVMF/OVMF_CODE.secboot.fd");
        writer.writeEndElement();
        writer.writeStartElement("nvram");
        writer.writeAttributeString("template", "/usr/share/OVMF/OVMF_VARS.fd");
        writer.writeRaw(String.format("/var/lib/libvirt/qemu/nvram/%s.fd", vm.getId()));
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    // Currently only
    // <features>
    // <acpi/>
    // <features/>
    // for hyperv:
    // <features>
    // <acpi/>
    // <hyperv>
    // <relaxed state='on'/>
    // </hyperv>
    // <features/>
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslr = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    if (!acpiEnabled && !hypervEnabled && !kaslr) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeStartElement("acpi");
        writer.writeEndElement();
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslr) {
        writer.writeElement("vmcoreinfo");
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean ovmfEnabled = vm.getBiosType().isOvmf();
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !ovmfEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (ovmfEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInput() {
    writer.writeStartElement("input");
    boolean tabletEnable = // avoid adding Tablet device for HP VMs since no USB devices are set
    vm.getVmType() != VmType.HighPerformance && vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#method_after
private void writeInput() {
    writer.writeStartElement("input");
    if (vmInfoBuildUtils.isTabletEnabled(vm)) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", vm.getClusterArch().getFamily() == ArchitectureType.x86 ? "ps2" : "usb");
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get(), e);
        if (!getParameters().isLiveMerge()) {
            throw e;
        }
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        log.info("Successfully started task to remove orphaned volumes resulting from live merge");
    } else {
        log.info("Retrying deleting image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get());
        MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, new HashSet<>(getParameters().getImageList()));
        getReturnValue().setActionReturnValue(returnValue);
        // At this point, we know that this command was executed during live merge and it is safe to do
        // the casting in the next line.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
    }
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupId()));
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, createVDSParameters());
    } catch (EngineException e) {
        log.error("Failed to delete image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get(), e);
        if (!getParameters().isLiveMerge()) {
            throw e;
        }
    }
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        Guid result = createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId());
        getTaskIdList().add(result);
        getReturnValue().getVdsmTaskIdList().add(result);
        log.info("Successfully started task to remove orphaned volumes");
    } else if (isMerge(getParentParameters().getParentCommand())) {
        log.info("Retrying deleting image {}/{}", getParameters().getImageGroupId(), getParameters().getImageList().stream().findFirst().get());
        MergeStatusReturnValue returnValue = new MergeStatusReturnValue(VmBlockJobType.COMMIT, new HashSet<>(getParameters().getImageList()));
        getReturnValue().setActionReturnValue(returnValue);
        // At this point, we know that this command was executed during live merge and it is safe to do
        // the casting in the next line.
        ((RemoveSnapshotSingleDiskParameters) getParameters().getParentParameters()).setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
    }
    setSucceeded(true);
    setCommandStatus(CommandStatus.SUCCEEDED);
}
#end_block

#method_before
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> hostsToRunOn = new ArrayList<>();
    // full name of the vm cpu
    String customCpu;
    Version latestVer = cpuFlagsManagerHandler.getLatestDictionaryVersion();
    // Handle CPU passthrough special cases
    if ((vm.isUseHostCpuFlags() || vm.getCustomCpuName().equals("hostModel") || vm.getCustomCpuName().equals("hostPassthrough")) && Objects.nonNull(vm.getCpuName())) {
        log.info("VM uses CPU flags passthrough, checking flag compatiblity with {}", vm.getCpuName());
        Set<String> requiredFlags = new HashSet<>(Arrays.asList(vm.getCpuName().split(",")));
        for (VDS host : hosts) {
            Set<String> providedFlags = new HashSet<>(Arrays.asList(host.getCpuFlags().split(",")));
            Set<String> missingFlags = new HashSet<>(requiredFlags);
            missingFlags.removeAll(providedFlags);
            if (missingFlags.isEmpty()) {
                hostsToRunOn.add(host);
            } else {
                log.debug("Host {} can't host the VM, flags are missing: {}", host.getName(), String.join(", ", missingFlags));
            }
        }
        return hostsToRunOn;
    }
    /* get required cpu name */
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        customCpu = vm.getCpuName();
    } else if (StringUtils.isNotEmpty(vm.getCustomCpuName())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(validate)
        customCpu = vm.getCustomCpuName();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    // translate vdsVerb to full cpu name
    customCpu = cpuFlagsManagerHandler.getCpuNameByCpuId(customCpu, latestVer);
    if (StringUtils.isNotEmpty(customCpu)) {
        /* find compatible hosts */
        for (VDS host : hosts) {
            ServerCpu cpu = cpuFlagsManagerHandler.findMaxServerCpuByFlags(host.getCpuFlags(), latestVer);
            String hostCpuName = cpu == null ? null : cpu.getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                if (cpuFlagsManagerHandler.checkIfCpusSameManufacture(customCpu, hostCpuName, latestVer)) {
                    // verify comparison uses only one cpu-level scale
                    int compareResult = cpuFlagsManagerHandler.compareCpuLevels(customCpu, hostCpuName, latestVer);
                    if (compareResult <= 0) {
                        hostsToRunOn.add(host);
                        log.debug("Host '{}' wasn't filtered out as it has a CPU level ({}) which is higher or equal than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                    } else {
                        log.debug("Host '{}' was filtered out as it has a CPU level ({}) which is lower than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                        messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                        messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", customCpu));
                        messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                    }
                }
            }
        }
    }
    return hostsToRunOn;
}
#method_after
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> hostsToRunOn = new ArrayList<>();
    // CPU passthrough VM can be started everywhere
    if (vm.getRunOnVds() == null && vm.isUsingCpuPassthrough()) {
        hostsToRunOn.addAll(hosts);
        return hostsToRunOn;
    }
    // full name of the vm cpu
    String customCpu;
    Version latestVer = cpuFlagsManagerHandler.getLatestDictionaryVersion();
    // TODO figure out how to handle hostModel
    if (vm.isUsingCpuPassthrough() && Objects.nonNull(vm.getCpuName())) {
        log.info("VM uses CPU flags passthrough, checking flag compatiblity with {}", vm.getCpuName());
        Set<String> requiredFlags = Arrays.stream(vm.getCpuName().split(",")).collect(Collectors.toSet());
        for (VDS host : hosts) {
            Set<String> providedFlags = Arrays.stream(host.getCpuFlags().split(",")).collect(Collectors.toSet());
            Set<String> missingFlags = new HashSet<>(requiredFlags);
            missingFlags.removeAll(providedFlags);
            log.info("Host {} provides flags {}", host.getName(), String.join(", ", providedFlags));
            if (missingFlags.isEmpty()) {
                hostsToRunOn.add(host);
            } else {
                log.info("Host {} can't host the VM, flags are missing: {}", host.getName(), String.join(", ", missingFlags));
            }
        }
        return hostsToRunOn;
    }
    /* get required cpu name */
    if (StringUtils.isNotEmpty(vm.getCpuName())) {
        // dynamic check - used for 1.migrating vms 2.run-once 3.after dynamic field is updated with current static-field\cluster
        customCpu = vm.getCpuName();
    } else if (StringUtils.isNotEmpty(vm.getCustomCpuName())) {
        // static check - used only for cases where the dynamic value hasn't been updated yet(validate)
        customCpu = vm.getCustomCpuName();
    } else {
        // use cluster default - all hosts are valid
        return hosts;
    }
    // translate vdsVerb to full cpu name
    customCpu = cpuFlagsManagerHandler.getCpuNameByCpuId(customCpu, latestVer);
    if (StringUtils.isNotEmpty(customCpu)) {
        /* find compatible hosts */
        for (VDS host : hosts) {
            ServerCpu cpu = cpuFlagsManagerHandler.findMaxServerCpuByFlags(host.getCpuFlags(), latestVer);
            String hostCpuName = cpu == null ? null : cpu.getCpuName();
            if (StringUtils.isNotEmpty(hostCpuName)) {
                if (cpuFlagsManagerHandler.checkIfCpusSameManufacture(customCpu, hostCpuName, latestVer)) {
                    // verify comparison uses only one cpu-level scale
                    int compareResult = cpuFlagsManagerHandler.compareCpuLevels(customCpu, hostCpuName, latestVer);
                    if (compareResult <= 0) {
                        hostsToRunOn.add(host);
                        log.debug("Host '{}' wasn't filtered out as it has a CPU level ({}) which is higher or equal than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                    } else {
                        log.debug("Host '{}' was filtered out as it has a CPU level ({}) which is lower than the CPU level the VM was run with ({})", host.getName(), hostCpuName, customCpu);
                        messages.addMessage(host.getId(), String.format("$hostCPULevel %1$s", hostCpuName));
                        messages.addMessage(host.getId(), String.format("$vmCPULevel %1$s", customCpu));
                        messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__LOW_CPU_LEVEL.toString());
                    }
                }
            }
        }
    }
    return hostsToRunOn;
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    updateVmDevicesOnRun();
    updateGraphicsAndDisplayInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    updateVmInit();
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        vmPayload = null;
    }
    updateVmGuestAgentVersion();
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    } else if (getVm().isUseHostCpuFlags()) {
        // CPU flags passthrough is special and does not use
        // the cpuName so we can store the flags used for
        // starting the VM here (scheduler needs those for
        // checking migration compatibility)
        getVm().setCpuName(getVds().getCpuFlags());
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getEffectiveEmulatedMachine());
    }
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    updateVmDevicesOnRun();
    updateGraphicsAndDisplayInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    updateVmInit();
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        vmPayload = null;
    }
    updateVmGuestAgentVersion();
    // - keep run-once selection if present
    if (!getVm().isUsingCpuPassthrough() && getVm().getCpuName() == null) {
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getEffectiveEmulatedMachine());
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), this, getCorrelationId());
    setVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), this, getCorrelationId());
    setVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    // checking migration compatibility in the future)
    if (getVm().isUsingCpuPassthrough()) {
        getVm().setCpuName(getVds().getCpuFlags());
        getVm().setUseHostCpuFlags(true);
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getClusterId(), getVm().getCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getClusterId(), getVm().getCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
    return list;
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
protected static String findBestMatchForEmulatedMachine(ChipsetType chipsetType, String currentEmulatedMachine, List<String> candidateEmulatedMachines) {
    if (candidateEmulatedMachines.contains(currentEmulatedMachine)) {
        return currentEmulatedMachine;
    }
    return candidateEmulatedMachines.stream().filter(em -> chipsetMatchesEmulatedMachine(chipsetType, em)).max(Comparator.comparingInt(s -> StringUtils.indexOfDifference(currentEmulatedMachine, s))).orElse(currentEmulatedMachine);
}
#method_after
protected static String findBestMatchForEmulatedMachine(ChipsetType chipsetType, String currentEmulatedMachine, List<String> candidateEmulatedMachines) {
    if (candidateEmulatedMachines.contains(currentEmulatedMachine)) {
        return currentEmulatedMachine;
    }
    return candidateEmulatedMachines.stream().map(em -> replaceChipset(em, chipsetType)).max(Comparator.comparingInt(s -> StringUtils.indexOfDifference(currentEmulatedMachine, s))).orElse(currentEmulatedMachine);
}
#end_block

#method_before
private static boolean chipsetMatchesEmulatedMachine(ChipsetType chipsetType, String emulatedMachine) {
    if (chipsetType == ChipsetType.I440FX) {
        return true;
    }
    return chipsetType == ChipsetType.fromMachineType(emulatedMachine);
}
#method_after
private static boolean chipsetMatchesEmulatedMachine(ChipsetType chipsetType, String emulatedMachine) {
    return chipsetType == ChipsetType.I440FX || chipsetType == ChipsetType.fromMachineType(emulatedMachine);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!ALLOWED_VM_STATES.contains(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        addValidationMessage(ReplacementUtils.createSetVariableString("vmStatus", getVm().getStatus()));
        return false;
    }
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        // External network linked to physical checks if the physical is attached on host
        if (getNetwork().isExternal() && !validate(validateExternalNetwork())) {
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                if (getVfPreallocatedForNic() == null && findFreeVf() == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!ALLOWED_VM_STATES.contains(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        addValidationMessage(ReplacementUtils.createSetVariableString("vmStatus", getVm().getStatus()));
        return false;
    }
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        // External network linked to physical checks if the physical is attached on host
        if (getNetwork() != null && getParameters().getAction().equals(PlugAction.PLUG) && getNetwork().isExternal() && !validate(validateExternalNetwork())) {
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                if (getVfPreallocatedForNic() == null && findFreeVf() == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void updateVmDeviceWithDataReturnedFromHost(VDSReturnValue vdsReturnValue) {
    if (vdsReturnValue.getSucceeded() && getParameters().getAction() == PlugAction.PLUG) {
        VmInfoReturn vmInfoReturn = (VmInfoReturn) vdsReturnValue.getReturnValue();
        if (vmInfoReturn.getVmInfo() != null) {
            Map<String, Object> vmInfo = (Map<String, Object>) vmInfoReturn.getVmInfo();
            for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
                Map<String, Object> vdsmDevice = (Map<String, Object>) o;
                if (vmDevice.getId().getDeviceId().toString().equals(vdsmDevice.get(VdsProperties.DeviceId))) {
                    vmDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
                    vmDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
                    break;
                }
            }
        }
    }
}
#method_after
private void updateVmDeviceWithDataReturnedFromHost(VDSReturnValue vdsReturnValue) {
    if (vdsReturnValue.getSucceeded() && getParameters().getAction() == PlugAction.PLUG) {
        VmInfoReturn vmInfoReturn = (VmInfoReturn) vdsReturnValue.getReturnValue();
        if (vmInfoReturn.getVmInfo() == null) {
            log.warn("failed to retrieve the device dynamic properties");
            return;
        }
        Map<String, Object> vmInfo = (Map<String, Object>) vmInfoReturn.getVmInfo();
        for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
            Map<String, Object> vdsmDevice = (Map<String, Object>) o;
            String reportedMacAddress = (String) vdsmDevice.get(VdsProperties.MAC_ADDR);
            if (StringUtils.equalsIgnoreCase(reportedMacAddress, getParameters().getNic().getMacAddress())) {
                vmDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
                break;
            }
        }
    }
}
#end_block

#method_before
private ValidationResult validateExternalNetwork() {
    if (!getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
        return ValidationResult.VALID;
    }
    Network physicalNetwork = networkDao.get(getNetwork().getProvidedBy().getPhysicalNetworkId());
    return ValidationResult.failWith(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS).when(!networkAttachedToVds(physicalNetwork.getName(), getVdsId()));
}
#method_after
private ValidationResult validateExternalNetwork() {
    if (!getNetwork().getProvidedBy().isSetPhysicalNetworkId()) {
        return ValidationResult.VALID;
    }
    Network physicalNetwork = networkDao.get(getNetwork().getProvidedBy().getPhysicalNetworkId());
    return ValidationResult.failWith(EngineMessage.PHYSICAL_NETWORK_LINKED_TO_EXTERNAL_NOT_IN_VDS).when(!networkAttachedToVds(physicalNetwork.getName(), getVdsId()));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (disk == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())) || !validate(snapshotsValidator.isSnapshotStatusOK(getSnapshot())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(getDiskValidator(disk).isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (disk == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator oldDiskValidator = new DiskValidator(disk);
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkOperationAllowedOnDiskContentType(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(snapshotsValidator.snapshotExists(getSnapshot())) || !validate(snapshotsValidator.isRegularSnapshot(getSnapshot())) || !validate(snapshotsValidator.isSnapshotStatusOK(getSnapshot().getId())))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType().isInternal();
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = diskHandler.loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addValidationMessageVariable("diskAliases", disk.getDiskAlias());
            return false;
        }
    }
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!validateDiskVmData()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (getDiskVmElement().isBoot() && !validate(getDiskValidator(disk).isVmNotContainsBootDisk(getVm()))) {
        return false;
    }
    if (!isDiskPassPciAndIdeLimit()) {
        return false;
    }
    if (vmDeviceDao.exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && storagePoolIsoMapDao.get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = storageDomainDao.getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(disk, getDiskVmElement());
    if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (!validate(diskVmElementValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    Guid storageDomainId = disk.getDiskStorageType() == DiskStorageType.IMAGE ? ((DiskImage) disk).getStorageIds().get(0) : null;
    if (!validate(diskVmElementValidator.isPassDiscardSupported(storageDomainId))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias());
    }
    return true;
}
#end_block

#method_before
@Test
public void validateSnapshotStatusOK() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.OK);
    validateValidResult(validator.isSnapshotStatusOK(snapshot));
}
#method_after
@Test
public void validateSnapshotStatusOK() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.OK);
    validateValidResult(validator.isSnapshotStatusOK(snapshot.getId()));
}
#end_block

#method_before
@Test
public void validateSnapshotStatusWhenSnapshotStatusLocked() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.LOCKED);
    validateInvalidResult(validator.isSnapshotStatusOK(snapshot), EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS);
}
#method_after
@Test
public void validateSnapshotStatusWhenSnapshotStatusLocked() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.LOCKED);
    validateInvalidResult(validator.isSnapshotStatusOK(snapshot.getId()), EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS);
}
#end_block

#method_before
@Test
public void validateSnapshotStatusWhenSnapshotStatusInPreview() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.IN_PREVIEW);
    validateInvalidResult(validator.isSnapshotStatusOK(snapshot), EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS);
}
#method_after
@Test
public void validateSnapshotStatusWhenSnapshotStatusInPreview() {
    when(snapshotDao.get(snapshot.getId())).thenReturn(snapshot);
    snapshot.setStatus(SnapshotStatus.IN_PREVIEW);
    validateInvalidResult(validator.isSnapshotStatusOK(snapshot.getId()), EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS);
}
#end_block

#method_before
public ValidationResult isSnapshotStatusOK(Snapshot snapshot) {
    Snapshot snap = snapshotDao.get(snapshot.getId());
    if (snap != null && snap.getStatus() != SnapshotStatus.OK) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS, String.format("$SnapshotStatus %1$s", snap.getStatus()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isSnapshotStatusOK(Guid snapshotId) {
    return isSnapshotInStatus(snapshotId, SnapshotStatus.OK, EngineMessage.ACTION_TYPE_FAILED_INVALID_SNAPSHOT_STATUS);
}
#end_block

#method_before
private Statistic addHistoryData(Statistic statistic, List<Integer> list) {
    if (list != null) {
        list.stream().forEach(i -> setDatum(statistic, i));
    }
    return statistic;
}
#method_after
private Statistic addHistoryData(Statistic statistic, List<Integer> list) {
    if (list != null) {
        List<Integer> cpy = new ArrayList<>(list);
        Collections.reverse(cpy);
        cpy.stream().forEach(i -> setDatum(statistic, i));
    }
    return statistic;
}
#end_block

#method_before
protected void verifyQuery(AbstractStatisticalQuery<Vm, org.ovirt.engine.core.common.businessentities.VM> query, org.ovirt.engine.core.common.businessentities.VM entity) throws Exception {
    assertEquals(Vm.class, query.getParentType());
    assertSame(entity, query.resolve(GUIDS[0]));
    List<Statistic> statistics = query.getStatistics(entity);
    verifyStatistics(statistics, new String[] { "memory.installed", "memory.used", "memory.free", "memory.buffered", "memory.cached", "cpu.current.guest", "cpu.current.hypervisor", "cpu.current.total", "migration.progress", "network.current.total", "cpu.usage.history", "memory.usage.history", "network.usage.history" }, new BigDecimal[] { asDec(10 * Mb), asDec(2 * Mb), asDec(5 * Mb), asDec(2 * Mb), asDec(1 * Mb), asDec(30), asDec(40), asDec(70), asDec(50), asDec(10), asDec(1), asDec(4), asDec(7) });
    Statistic adopted = query.adopt(new Statistic());
    assertTrue(adopted.isSetVm());
    assertEquals(GUIDS[0].toString(), adopted.getVm().getId());
}
#method_after
protected void verifyQuery(AbstractStatisticalQuery<Vm, org.ovirt.engine.core.common.businessentities.VM> query, org.ovirt.engine.core.common.businessentities.VM entity) throws Exception {
    assertEquals(Vm.class, query.getParentType());
    assertSame(entity, query.resolve(GUIDS[0]));
    List<Statistic> statistics = query.getStatistics(entity);
    verifyStatistics(statistics, new String[] { "memory.installed", "memory.used", "memory.free", "memory.buffered", "memory.cached", "cpu.current.guest", "cpu.current.hypervisor", "cpu.current.total", "migration.progress", "network.current.total", "cpu.usage.history", "memory.usage.history", "network.usage.history" }, new BigDecimal[] { asDec(10 * Mb), asDec(2 * Mb), asDec(5 * Mb), asDec(2 * Mb), asDec(1 * Mb), asDec(30), asDec(40), asDec(70), asDec(50), asDec(10), asDec(3), asDec(6), asDec(9) });
    Statistic adopted = query.adopt(new Statistic());
    assertTrue(adopted.isSetVm());
    assertEquals(GUIDS[0].toString(), adopted.getVm().getId());
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return callable.getMap() == null && super.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return !callable.isCallableInvoked() && super.isDone();
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
protected AddDiskParameters buildAddDiskParameters(DiskImage image) {
    image.setVolumeFormat(VolumeFormat.COW);
    image.setVolumeType(VolumeType.Sparse);
    AddDiskParameters diskParameters = new AddDiskParameters(image.getDiskVmElementForVm(getVmTemplateId()), image);
    diskParameters.setStorageDomainId(getParameters().getImageToDestinationDomainMap().get(image.getId()));
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    diskParameters.setUsePassedDiskId(true);
    diskParameters.setUsePassedImageId(true);
    return diskParameters;
}
#method_after
protected AddDiskParameters buildAddDiskParameters(DiskImage image) {
    AddDiskParameters diskParameters = new AddDiskParameters(image.getDiskVmElementForVm(getVmTemplateId()), image);
    diskParameters.setStorageDomainId(getParameters().getImageToDestinationDomainMap().get(image.getId()));
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    diskParameters.setUsePassedDiskId(true);
    diskParameters.setUsePassedImageId(true);
    return diskParameters;
}
#end_block

#method_before
protected DiskImage adjustDisk(DiskImage image) {
    image.setDiskVmElements(image.getDiskVmElements().stream().map(dve -> {
        DiskVmElement copy = DiskVmElement.copyOf(dve, image.getId(), getVmTemplateId());
        updatePassDiscardForDiskVmElement(copy);
        return copy;
    }).collect(Collectors.toList()));
    return image;
}
#method_after
protected DiskImage adjustDisk(DiskImage image) {
    image.setVolumeFormat(VolumeFormat.COW);
    image.setVolumeType(VolumeType.Sparse);
    image.setDiskVmElements(image.getDiskVmElements().stream().map(dve -> {
        DiskVmElement copy = DiskVmElement.copyOf(dve, image.getId(), getVmTemplateId());
        updatePassDiscardForDiskVmElement(copy);
        return copy;
    }).collect(Collectors.toList()));
    return image;
}
#end_block

#method_before
private ValidationResult validateStorageDomains(VM vm, boolean isInternalExecution, List<DiskImage> vmImages) {
    if (vmImages.isEmpty()) {
        return ValidationResult.VALID;
    }
    if (!vm.isAutoStartup() || !isInternalExecution) {
        Set<Guid> storageDomainIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageDomainValidator = new MultipleStorageDomainsValidator(vm.getStoragePoolId(), storageDomainIds);
        ValidationResult result = storageDomainValidator.allDomainsExistAndActive();
        if (!result.isValid()) {
            return result;
        }
        result = !vm.isAutoStartup() ? storageDomainValidator.allDomainsWithinThresholds() : ValidationResult.VALID;
        if (!result.isValid()) {
            return result;
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateStorageDomains(VM vm, boolean isInternalExecution, List<DiskImage> vmImages) {
    if (vmImages.isEmpty()) {
        return ValidationResult.VALID;
    }
    if (!vm.isAutoStartup() || !isInternalExecution) {
        // In order to check the storage domains statuses we need a set of all the VM images
        Set<Guid> storageDomainIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageDomainValidator = new MultipleStorageDomainsValidator(vm.getStoragePoolId(), storageDomainIds);
        ValidationResult result = storageDomainValidator.allDomainsExistAndActive();
        if (!result.isValid()) {
            return result;
        }
        // In order to check the storage domain thresholds we need a set of
        // non-preallocated and non read-only images
        Set<Guid> filteredStorageDomainIds = ImagesHandler.getAllStorageIdsForImageIds(filterReadOnlyAndPreallocatedDisks(vmImages));
        MultipleStorageDomainsValidator filteredStorageDomainValidator = new MultipleStorageDomainsValidator(vm.getStoragePoolId(), filteredStorageDomainIds);
        result = !vm.isAutoStartup() ? filteredStorageDomainValidator.allDomainsWithinThresholds() : ValidationResult.VALID;
        if (!result.isValid()) {
            return result;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private boolean validateImagesAvailability() {
    // invalid images are being removed from the images list.
    for (DiskImage image : new ArrayList<>(getImages())) {
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        // true iff it exists in at least one storage domain.
        boolean imageAvailable = false;
        for (Guid storageDomainId : image.getStorageIds()) {
            DiskImage fromIrs = null;
            try {
                fromIrs = (DiskImage) runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(getStoragePool().getId(), storageDomainId, imageGroupId, image.getImageId())).getReturnValue();
            } catch (Exception e) {
                log.debug("Unable to get image info from storage", e);
            }
            if (fromIrs == null) {
                log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'", imageGroupId, image.getImageId(), storageDomainId);
            } else {
                imageAvailable = true;
            }
        }
        if (!imageAvailable) {
            if (getParameters().isAllowPartialImport()) {
                log.warn("Disk image '{}/{}' doesn't exist on any of its storage domains. " + "Ignoring since the force flag in on", imageGroupId, image.getImageId());
                getImages().remove(image);
                failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
            } else {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
        }
    }
    return true;
}
#method_after
private boolean validateImagesAvailability() {
    // invalid images are being removed from the images list.
    for (DiskImage image : new ArrayList<>(getImages())) {
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        if (!validateImageAvailability(image, imageGroupId)) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.TEMPLATE_IMAGE_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on any of its storage domains. " + "Ignoring since the 'Allow Partial' flag is on", imageGroupId, image.getImageId());
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    return true;
}
#end_block

#method_before
private boolean validateSourceStorageDomainsAvailability() {
    // invalid images are being removed from the images list.
    for (DiskImage image : new ArrayList<>(getImages())) {
        // True iff at least one SD among image.getStorageIds() exists and is active.
        boolean storageDomainAvailable = false;
        for (Guid storageDomainId : image.getStorageIds()) {
            StorageDomain sd = storageDomainDao.getForStoragePool(storageDomainId, getStoragePool().getId());
            ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
            if (result.isValid()) {
                storageDomainAvailable = true;
            } else {
                log.warn("Storage domain '{}' does not exist.", storageDomainId);
            }
        }
        if (!storageDomainAvailable) {
            if (getParameters().isAllowPartialImport()) {
                log.warn("No active storage domain that contains the image {}/{} exists. " + "Ignoring since the force flag in on.", image.getId(), image.getImageId());
                getImages().remove(image);
                failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
            } else {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_FIND_DISK_IMAGE_IN_ACTIVE_DOMAINS, String.format("$diskImageId %1$s", image.getId()), String.format("$imageId %1$s", image.getImageId()));
            }
        }
    }
    return true;
}
#method_after
private boolean validateSourceStorageDomainsAvailability() {
    // invalid images are being removed from the images list.
    for (DiskImage image : new ArrayList<>(getImages())) {
        // True iff at least one SD among image.getStorageIds() exists and is active.
        boolean storageDomainAvailable = false;
        Iterator<Guid> iterator = image.getStorageIds().iterator();
        while (iterator.hasNext()) {
            Guid storageDomainId = iterator.next();
            StorageDomain sd = storageDomainDao.getForStoragePool(storageDomainId, getStoragePool().getId());
            ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
            if (!result.isValid()) {
                log.warn("Storage domain '{}' does not exist.", storageDomainId);
                iterator.remove();
            } else if (!storageDomainAvailable) {
                storageDomainAvailable = true;
            }
        }
        if (!storageDomainAvailable) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_FIND_DISK_IMAGE_IN_ACTIVE_DOMAINS, String.format("$diskImageId %1$s", image.getId()), String.format("$imageId %1$s", image.getImageId()));
            }
            log.warn("No active storage domain that contains the image {}/{} exists. " + "Ignoring since the 'Allow Partial' flag is on.", image.getId(), image.getImageId());
            getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    return true;
}
#end_block

#method_before
private void findAndSaveDiskCopies() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(ovfEntityData.getEntityId(), null);
    List<ImageStorageDomainMap> copiedTemplateDisks = new LinkedList<>();
    ovfEntityDataList.forEach(ovfEntityData -> populateDisksCopies(copiedTemplateDisks, getImages(), ovfEntityData.getStorageDomainId()));
    saveImageStorageDomainMapList(copiedTemplateDisks);
}
#method_after
private void findAndSaveDiskCopies() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(ovfEntityData.getEntityId(), null);
    removeIrrelevantOvfs(ovfEntityDataList, getImages());
    List<ImageStorageDomainMap> copiedTemplateDisks = new LinkedList<>();
    ovfEntityDataList.forEach(ovfEntityData -> populateDisksCopies(copiedTemplateDisks, getImages(), ovfEntityData.getStorageDomainId()));
    saveImageStorageDomainMapList(copiedTemplateDisks);
}
#end_block

#method_before
protected void readDiskImageItem(XmlNode node, DiskImage image) {
    XmlNode templateNode = selectSingleNode(node, "rasd:Template", _xmlNS);
    if (templateNode != null && StringUtils.isNotEmpty(templateNode.innerText)) {
        image.setImageTemplateId(new Guid(templateNode.innerText));
    }
    XmlNode applicationsNode = selectSingleNode(node, "rasd:ApplicationList", _xmlNS);
    if (applicationsNode != null) {
        image.setAppList(applicationsNode.innerText);
    }
    XmlNodeList nodesList = selectNodes(node, "rasd:StorageId", _xmlNS);
    if (nodesList.iterator().hasNext()) {
        image.setStorageIds(new LinkedList<>());
        for (XmlNode storageIdNode : nodesList) {
            if (storageIdNode != null && StringUtils.isNotEmpty(storageIdNode.innerText)) {
                image.getStorageIds().add(new Guid(storageIdNode.innerText));
            }
        }
    }
    XmlNode storagePoolNode = selectSingleNode(node, "rasd:StoragePoolId", _xmlNS);
    if (storagePoolNode != null && StringUtils.isNotEmpty(storagePoolNode.innerText)) {
        image.setStoragePoolId(new Guid(storagePoolNode.innerText));
    }
    XmlNode creationDateNode = selectSingleNode(node, "rasd:CreationDate", _xmlNS);
    Date creationDate = creationDateNode != null ? OvfParser.utcDateStringToLocalDate(creationDateNode.innerText) : null;
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    XmlNode lastModifiedNode = selectSingleNode(node, "rasd:LastModified", _xmlNS);
    Date lastModified = lastModifiedNode != null ? OvfParser.utcDateStringToLocalDate(lastModifiedNode.innerText) : null;
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    XmlNode lastModifiedDateNode = selectSingleNode(node, "rasd:last_modified_date", _xmlNS);
    Date last_modified_date = lastModifiedDateNode != null ? OvfParser.utcDateStringToLocalDate(lastModifiedDateNode.innerText) : null;
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.isPlugged());
}
#method_after
protected void readDiskImageItem(XmlNode node, DiskImage image) {
    XmlNode templateNode = selectSingleNode(node, "rasd:Template", _xmlNS);
    if (templateNode != null && StringUtils.isNotEmpty(templateNode.innerText)) {
        image.setImageTemplateId(new Guid(templateNode.innerText));
    }
    XmlNode applicationsNode = selectSingleNode(node, "rasd:ApplicationList", _xmlNS);
    if (applicationsNode != null) {
        image.setAppList(applicationsNode.innerText);
    }
    XmlNodeList storageNodes = selectNodes(node, "rasd:StorageId", _xmlNS);
    if (storageNodes.iterator().hasNext()) {
        for (XmlNode storageIdNode : storageNodes) {
            if (storageIdNode != null && StringUtils.isNotEmpty(storageIdNode.innerText)) {
                if (image.getStorageIds() == null) {
                    image.setStorageIds(new LinkedList<>());
                }
                image.getStorageIds().add(new Guid(storageIdNode.innerText));
            }
        }
    }
    XmlNode storagePoolNode = selectSingleNode(node, "rasd:StoragePoolId", _xmlNS);
    if (storagePoolNode != null && StringUtils.isNotEmpty(storagePoolNode.innerText)) {
        image.setStoragePoolId(new Guid(storagePoolNode.innerText));
    }
    XmlNode creationDateNode = selectSingleNode(node, "rasd:CreationDate", _xmlNS);
    Date creationDate = creationDateNode != null ? OvfParser.utcDateStringToLocalDate(creationDateNode.innerText) : null;
    if (creationDate != null) {
        image.setCreationDate(creationDate);
    }
    XmlNode lastModifiedNode = selectSingleNode(node, "rasd:LastModified", _xmlNS);
    Date lastModified = lastModifiedNode != null ? OvfParser.utcDateStringToLocalDate(lastModifiedNode.innerText) : null;
    if (lastModified != null) {
        image.setLastModified(lastModified);
    }
    XmlNode lastModifiedDateNode = selectSingleNode(node, "rasd:last_modified_date", _xmlNS);
    Date last_modified_date = lastModifiedDateNode != null ? OvfParser.utcDateStringToLocalDate(lastModifiedDateNode.innerText) : null;
    if (last_modified_date != null) {
        image.setLastModifiedDate(last_modified_date);
    }
    VmDevice readDevice = readManagedVmDevice(node, image.getId());
    image.setPlugged(readDevice.isPlugged());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VDS> hosts = vdsDao.getAllForCluster(getParameters().getClusterId());
    List<ActionParametersBase> params = new LinkedList<>();
    int i = 0;
    for (VDS host : hosts) {
        params.add(i++, new VdsActionParameters(host.getId()));
    }
    runInternalMultipleActions(ActionType.SyncAllHostNetworks, params, getExecutionContext());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<ActionParametersBase> params = hosts.stream().map(host -> new VdsActionParameters(host.getId())).collect(Collectors.toList());
    runInternalMultipleActions(ActionType.SyncAllHostNetworks, params);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.CLUSTER_SYNC_ALL_NETWORKS_FINISHED : AuditLogType.CLUSTER_SYNC_ALL_NETWORKS_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.CLUSTER_SYNC_ALL_NETWORKS_STARTED : AuditLogType.CLUSTER_SYNC_ALL_NETWORKS_FAILED;
}
#end_block

#method_before
private void updateActionAvailability() {
    Network network = getSelectedItem();
    // CanRemove = SelectedItems != null && SelectedItems.Count > 0;
    getSetAsDisplayCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1 && network != null && !network.getCluster().isDisplay() && network.getCluster().getStatus() != NetworkStatus.NON_OPERATIONAL);
    getSyncAllNetworksCommand().setIsExecutionAllowed(true);
}
#method_after
private void updateActionAvailability() {
    Network network = getSelectedItem();
    // CanRemove = SelectedItems != null && SelectedItems.Count > 0;
    getSetAsDisplayCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() == 1 && network != null && !network.getCluster().isDisplay() && network.getCluster().getStatus() != NetworkStatus.NON_OPERATIONAL);
    updateActionAvailabilitySyncAllNetworks();
}
#end_block

#method_before
private void syncAllNetworks() {
    ClusterParametersBase parameter = new ClusterParametersBase(getEntity().getId());
    Frontend.getInstance().runAction(ActionType.SyncAllClusterNetworks, parameter);
}
#method_after
private void syncAllNetworks() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().syncAllClusterNetworkConfirmationDialogTitle());
    model.setHelpTag(HelpTag.sync_all_cluster_networks);
    // $NON-NLS-1$
    model.setHashName("sync_all_cluster_networks");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToSyncAllClusterNetworksMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSyncAllClusterNetworksConfirm", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageCommand()) {
        manage();
    } else if (command == getSetAsDisplayCommand()) {
        setAsDisplay();
    } else if ("New".equals(command.getName())) {
        // $NON-NLS-1$
        newEntity();
    } else if (command == getSyncAllNetworksCommand()) {
        syncAllNetworks();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getManageCommand()) {
        manage();
    } else if (command == getSetAsDisplayCommand()) {
        setAsDisplay();
    } else if ("New".equals(command.getName())) {
        // $NON-NLS-1$
        newEntity();
    } else if (command == getSyncAllNetworksCommand()) {
        syncAllNetworks();
    } else if ("OnSyncAllClusterNetworksConfirm".equals(command.getName())) {
        // $NON-NLS-1$
        onSyncAllClusterNetworksConfirm();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validate(new VmValidator(getVm()).isVmExists()) || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!isFloatingDisk() && (!validateVm() || !validateDiskVmData())) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getParameters().getDiskInfo(), getDiskVmElement());
    if (vm != null) {
        if (!validateDiskVmData() || !canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        if (getDiskVmElement().isBoot() && !validate(diskValidator.isVmNotContainsBootDisk(vm))) {
            return false;
        }
        if (!validatePassDiscardSupported(diskVmElementValidator)) {
            return false;
        }
        // if user sent drive check that its not in use
        if (!isDiskPassPciAndIdeLimit()) {
            return false;
        }
        if (!validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failValidation(EngineMessage.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    if (!validateQuota()) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskVmElementValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Collections.singletonList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits()) && validate(cinderDisksValidator.validateCinderVolumeTypesExist());
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects;
    if (isFloatingDisk()) {
        listPermissionSubjects = new ArrayList<>();
    } else {
        listPermissionSubjects = super.getPermissionCheckSubjects();
    }
    // In order to do that we need CREATE_DISK permissions on System level
    if (getParameters().getStorageDomainId() == null || Guid.Empty.equals(getParameters().getStorageDomainId())) {
        listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CREATE_DISK));
        if (getParameters().getDiskInfo().getSgio() == ScsiGenericIO.UNFILTERED) {
            listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CONFIGURE_SCSI_GENERIC_IO));
        }
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> listPermissionSubjects = getVmPermissionSubject();
    // In order to do that we need CREATE_DISK permissions on System level
    if (getParameters().getStorageDomainId() == null || Guid.Empty.equals(getParameters().getStorageDomainId())) {
        listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CREATE_DISK));
        if (getParameters().getDiskInfo().getSgio() == ScsiGenericIO.UNFILTERED) {
            listPermissionSubjects.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, ActionGroup.CONFIGURE_SCSI_GENERIC_IO));
        }
    } else {
        listPermissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return listPermissionSubjects;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#method_after
@Override
protected void executeVmCommand() {
    createNewDiskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    setDiskAlias();
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(ActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    ActionReturnValue tmpRetValue = runInternalActionWithTasksContext(ActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        // The disk VM element has to be added before the VM device since as a part of the VM device creation the
        // boot order is determined so the VM device creation depends on the existence of the disk VM element
        getCompensationContext().snapshotEntity(addDiskVmElementForDisk(getDiskVmElement()));
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    if (getParameters().isUsePassedImageId()) {
        parameters.setDestinationImageId(getDiskImageInfo().getImageId());
    }
    parameters.setLeaveLocked(getParameters().isShouldRemainLockedOnSuccesfulExecution());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (useCallback()) {
        parameters.setParentCommand(ActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    } else {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    setVmSnapshotIdForDisk(parameters);
    ActionReturnValue tmpRetValue = runInternalActionWithTasksContext(ActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getTaskIdList().addAll(tmpRetValue.getInternalVdsmTaskIdList());
    attachImage();
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && (getVm().getStatus() == VMStatus.Paused || getVm().getStatus() == VMStatus.Up)) {
        VmDiskOperationParameterBase params = new VmDiskOperationParameterBase(new DiskVmElement(getParameters().getDiskInfo().getId(), getVmId()));
        params.setShouldBeLogged(false);
        ActionReturnValue returnValue = runInternalAction(ActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#method_after
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null) {
        if (!getVm().getStatus().isUpOrPaused()) {
            log.warn("Disk id - '{}' wasn't plug to VM - '{}'({}) because the VM status is - '{}'", getParameters().getDiskInfo().getId(), getVmId(), getVmName(), getVm().getStatus());
        } else {
            VmDiskOperationParameterBase params = new VmDiskOperationParameterBase(new DiskVmElement(getParameters().getDiskInfo().getId(), getVmId()));
            params.setShouldBeLogged(false);
            ActionReturnValue returnValue = runInternalAction(ActionType.HotPlugDiskToVm, params);
            if (!returnValue.getSucceeded()) {
                auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
            }
        }
    }
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (getParameters().getDiskInfo().getDiskStorageType().isInternal()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getStorageDomainId(), getRequestDiskSpace()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (getParameters().getDiskInfo().getDiskStorageType().isInternal()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaId(), QuotaConsumptionParameter.QuotaAction.CONSUME, getStorageDomainId(), getRequestDiskSpace()));
    }
    return list;
}
#end_block

#method_before
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Conosole tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.IMPLICITLY_NON_MIGRATABLE, MigrationSupport.PINNED_TO_HOST));
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resouce allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
        getModel().getIoThreadsEnabled().setEntity(true);
    } else {
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    }
}
#method_after
public void vmTypeChanged(VmType vmType) {
    if (basedOnCustomInstanceType()) {
        // this field is normally taken from instance type. If the "custom" is selected, then it is supposed to use the default
        // determined by vm type
        getModel().getIsSoundcardEnabled().setEntity(vmType == VmType.Desktop);
    }
    getModel().getAllowConsoleReconnect().setEntity(vmType == VmType.Server);
    getModel().getIoThreadsEnabled().setEntity(vmType == VmType.Server || vmType == VmType.HighPerformance);
    // High Performance
    if (vmType == VmType.HighPerformance) {
        // Console tab
        getModel().getIsHeadlessModeEnabled().setEntity(true);
        getModel().getIsConsoleDeviceEnabled().setEntity(true);
        getModel().getUsbPolicy().setSelectedItem(UsbPolicy.DISABLED);
        getModel().getIsSmartcardEnabled().setEntity(false);
        // High Availability tab
        getModel().getWatchdogModel().setSelectedItem(null);
        getModel().getWatchdogAction().setSelectedItem(getModel().getWatchdogAction().getItems().iterator().next());
        // Random Generator tab
        getModel().getIsRngEnabled().setEntity(true);
        // Host tab
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.IMPLICITLY_NON_MIGRATABLE, MigrationSupport.PINNED_TO_HOST));
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        if (!clusterHasPpcArchitecture()) {
            getModel().getHostCpu().setEntity(true);
        }
        // Resource allocation tab
        getModel().getMemoryBalloonDeviceEnabled().setEntity(false);
        if (getModel().getMultiQueues().getIsAvailable()) {
            getModel().getMultiQueues().setEntity(true);
        }
    } else {
        getModel().getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    }
}
#end_block

#method_before
@Override
public boolean canMoveToMaintenance(VDS vds) {
    List<VM> vms = vmDao.getAllRunningForVds(vds.getId()).stream().filter(vm -> !vm.isExternalVm()).collect(Collectors.toList());
    // We can only move to maintenance in case no VMs are running on the host
    return vms.isEmpty() && !isAnyVmRunOnVdsInDb(vds.getId());
}
#method_after
@Override
public boolean canMoveToMaintenance(VDS vds) {
    if (!Config.<Boolean>getValue(ConfigValues.MaintenanceVdsIgnoreExternalVms)) {
        // We can only move to maintenance in case no VMs are running on the host
        return vds.getVmCount() == 0 && !isAnyVmRunOnVdsInDb(vds.getId());
    }
    // We can only move to maintenance in case no managed VMs are running on the host ignoring all external VMs
    return !isAnyNonExternalVmRunningOnVds(vds);
}
#end_block

#method_before
protected boolean isAnyVmRunOnVdsInDb(Guid vdsId) {
    return !vmStaticDao.getAllRunningForVds(vdsId).stream().filter(vm -> !OriginType.EXTERNAL.equals(vm.getOrigin())).collect(Collectors.toList()).isEmpty();
}
#method_after
protected boolean isAnyVmRunOnVdsInDb(Guid vdsId) {
    return vmDynamicDao.isAnyVmRunOnVds(vdsId);
}
#end_block

#method_before
protected void orderListOfRunningVmsOnVds(Guid vdsId) {
    vms = vmDao.getAllRunningForVds(vdsId).stream().filter(vm -> !vm.isExternalVm()).collect(Collectors.toList());
    vms.sort(new VmsComparer().reversed());
}
#method_after
protected void orderListOfRunningVmsOnVds(Guid vdsId) {
    vms = vmDao.getAllRunningForVds(vdsId);
    if (Config.<Boolean>getValue(ConfigValues.MaintenanceVdsIgnoreExternalVms)) {
        vms = vms.stream().filter(vm -> !vm.isExternalVm()).collect(Collectors.toList());
    }
    vms.sort(new VmsComparer().reversed());
}
#end_block

#method_before
@BeforeEach
public void setUp() {
    vdsFromDb = new VDS();
    vdsFromDb.setId(vdsId);
    vdsFromDb.setClusterId(clusterId);
    virtStrategy = spy(new VirtMonitoringStrategy(mockCluster(), mockVdsDao(), mockVmDao(), null));
    doNothing().when(virtStrategy).vdsNonOperational(any(), any(), any());
}
#method_after
@BeforeEach
public void setUp() {
    vdsFromDb = new VDS();
    vdsFromDb.setId(vdsId);
    vdsFromDb.setClusterId(clusterId);
    virtStrategy = spy(new VirtMonitoringStrategy(mockCluster(), mockVdsDao(), mockVmDao(), null, null));
    doNothing().when(virtStrategy).vdsNonOperational(any(), any(), any());
}
#end_block

#method_before
@Test
public void testVirtCanMoveToMaintenance() {
    VDS vds = new VDS();
    vds.setStatus(VDSStatus.PreparingForMaintenance);
    vds.setId(vdsId);
    vds.setClusterId(clusterId);
    assertFalse(virtStrategy.canMoveToMaintenance(vds));
    vds.setId(vdsId2);
    doReturn(false).when(virtStrategy).isAnyVmRunOnVdsInDb(vdsId2);
    assertTrue(virtStrategy.canMoveToMaintenance(vds));
    doReturn(true).when(virtStrategy).isAnyVmRunOnVdsInDb(vdsId2);
    assertFalse(virtStrategy.canMoveToMaintenance(vds));
}
#method_after
@Test
public void testVirtCanMoveToMaintenance() {
    VDS vds = new VDS();
    vds.setStatus(VDSStatus.PreparingForMaintenance);
    vds.setId(vdsId);
    vds.setClusterId(clusterId);
    assertFalse(virtStrategy.canMoveToMaintenance(vds));
    vds.setId(vdsId2);
    doReturn(false).when(virtStrategy).isAnyNonExternalVmRunningOnVds(vds);
    assertTrue(virtStrategy.canMoveToMaintenance(vds));
    doReturn(true).when(virtStrategy).isAnyNonExternalVmRunningOnVds(vds);
    assertFalse(virtStrategy.canMoveToMaintenance(vds));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<Network> providedNetworks = getAllNetworks();
    Set<String> providedNetworkIds = externalIds(providedNetworks);
    List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
    Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).filter(Objects::nonNull).collect(Collectors.toSet());
    for (Guid dataCenterId : dataCenterIds) {
        Map<String, Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toMap(network -> network.getProvidedBy().getExternalId(), network -> network));
        providerNetworksInDataCenter.values().stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
        List<Cluster> clustersInDataCenter = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).collect(Collectors.toList());
        List<Guid> allClustersInDataCenterIds = clustersInDataCenter.stream().map(Cluster::getId).collect(Collectors.toList());
        List<Guid> allClustersWithOvsSwitchTypeIds = clustersInDataCenter.stream().filter(cluster -> cluster.hasRequiredSwitchType(SwitchType.OVS)).map(Cluster::getId).collect(Collectors.toList());
        for (Network network : providedNetworks) {
            Network networkInDataCenter = providerNetworksInDataCenter.get(network.getProvidedBy().getExternalId());
            networkHelper.mapPhysicalNetworkIdIfExists(network, dataCenterId);
            if (networkInDataCenter == null) {
                ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                if (importReturnValue.getSucceeded()) {
                    network.setId(importReturnValue.getActionReturnValue());
                    propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), network.getProvidedBy().isSetCustomPhysicalNetwork() ? allClustersWithOvsSwitchTypeIds : allClustersInDataCenterIds));
                }
            } else {
                updateNetwork(dataCenterId, network, networkInDataCenter);
                updateNetworkClusters(network.getProvidedBy().isSetCustomPhysicalNetwork() ? allClustersWithOvsSwitchTypeIds : allClustersInDataCenterIds, network, networkInDataCenter);
            }
        }
    }
    setSucceeded(!errorOccurred);
}
#method_after
@Override
protected void executeCommand() {
    List<Network> providedNetworks = getAllNetworks();
    Set<String> providedNetworkIds = externalIds(providedNetworks);
    List<Network> providerNetworksInDb = networkDao.getAllForProvider(getProvider().getId());
    List<Cluster> clusters = clusterDao.getAllClustersByDefaultNetworkProviderId(getProvider().getId());
    Set<Guid> dataCenterIds = clusters.stream().map(Cluster::getStoragePoolId).filter(Objects::nonNull).collect(Collectors.toSet());
    for (Guid dataCenterId : dataCenterIds) {
        Map<String, Network> providerNetworksInDataCenter = providerNetworksInDb.stream().filter(network -> dataCenterId.equals(network.getDataCenterId())).collect(Collectors.toMap(network -> network.getProvidedBy().getExternalId(), network -> network));
        providerNetworksInDataCenter.values().stream().filter(network -> !providedNetworkIds.contains(network.getProvidedBy().getExternalId())).forEach(network -> removeNetwork(network.getId()));
        List<Cluster> idsOfClustersInDataCenter = clusters.stream().filter(cluster -> dataCenterId.equals(cluster.getStoragePoolId())).collect(Collectors.toList());
        List<Guid> allClustersInDataCenterIds = idsOfClustersInDataCenter.stream().map(Cluster::getId).collect(Collectors.toList());
        List<Guid> clustersWithOvsSwitchTypeIds = idsOfClustersInDataCenter.stream().filter(cluster -> cluster.hasRequiredSwitchType(SwitchType.OVS)).map(Cluster::getId).collect(Collectors.toList());
        for (Network network : providedNetworks) {
            Network networkInDataCenter = providerNetworksInDataCenter.get(network.getProvidedBy().getExternalId());
            networkHelper.mapPhysicalNetworkIdIfApplicable(network.getProvidedBy(), dataCenterId);
            List<Guid> clusterIds = network.getProvidedBy().isLinkedToPhysicalNetwork() ? clustersWithOvsSwitchTypeIds : allClustersInDataCenterIds;
            if (networkInDataCenter == null) {
                ActionReturnValue importReturnValue = importNetwork(dataCenterId, network);
                if (importReturnValue.getSucceeded()) {
                    network.setId(importReturnValue.getActionReturnValue());
                    propagateReturnValue(networkHelper.attachNetworkToClusters(network.getId(), clusterIds));
                }
            } else {
                updateNetwork(dataCenterId, network, networkInDataCenter);
                updateNetworkClusters(clusterIds, network, networkInDataCenter);
            }
        }
    }
    setSucceeded(!errorOccurred);
}
#end_block

#method_before
private void updateNetwork(Guid dataCenterId, Network externalNetwork, Network networkInDataCenter) {
    if (!networkInDataCenter.getName().equals(externalNetwork.getName())) {
        networkInDataCenter.setName(externalNetwork.getName());
        AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, networkInDataCenter);
        propagateReturnValue(runInternalAction(ActionType.UpdateNetwork, parameters, getInternalCommandContext()));
    }
}
#method_after
private void updateNetwork(Guid dataCenterId, Network externalNetwork, Network networkInDataCenter) {
    boolean changed = false;
    if (!networkInDataCenter.getName().equals(externalNetwork.getName())) {
        networkInDataCenter.setName(externalNetwork.getName());
        changed = true;
    }
    if (networkInDataCenter.getMtu() != externalNetwork.getMtu()) {
        networkInDataCenter.setMtu(externalNetwork.getMtu());
        changed = true;
    }
    ProviderNetwork externalProviderNetwork = externalNetwork.getProvidedBy();
    ProviderNetwork dataCenterProviderNetwork = networkInDataCenter.getProvidedBy();
    if (!Objects.equals(dataCenterProviderNetwork.getPhysicalNetworkId(), externalProviderNetwork.getPhysicalNetworkId())) {
        dataCenterProviderNetwork.setPhysicalNetworkId(externalProviderNetwork.getPhysicalNetworkId());
        changed = true;
    }
    if (changed) {
        AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(dataCenterId, networkInDataCenter);
        propagateReturnValue(runInternalAction(ActionType.UpdateNetwork, parameters, getInternalCommandContext()));
    }
}
#end_block

#method_before
protected Network getNetwork() {
    if (network == null) {
        NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
        String networkId = getParameters().getNetworkExternalId();
        network = proxy.get(networkId);
        networkHelper.mapPhysicalNetworkIdIfExists(network, getParameters().getDataCenterId());
    }
    return network;
}
#method_after
protected Network getNetwork() {
    if (network == null) {
        NetworkProviderProxy proxy = providerProxyFactory.create(getProvider());
        String networkId = getParameters().getNetworkExternalId();
        network = proxy.get(networkId);
    }
    return network;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    InternalImportExternalNetworkParameters parameters = new InternalImportExternalNetworkParameters(getProvider().getName(), getNetwork(), getParameters().getDataCenterId(), getParameters().isPublicUse(), getParameters().isAttachToAllClusters());
    ActionReturnValue returnValue = runInternalAction(ActionType.InternalImportExternalNetwork, parameters, getContext().clone().withoutLock());
    if (!returnValue.getSucceeded()) {
        propagateFailure(runInternalAction(ActionType.InternalImportExternalNetwork, parameters));
        return;
    }
    getReturnValue().setActionReturnValue(returnValue.getActionReturnValue());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    networkHelper.mapPhysicalNetworkIdIfApplicable(network.getProvidedBy(), getParameters().getDataCenterId());
    InternalImportExternalNetworkParameters parameters = new InternalImportExternalNetworkParameters(getProvider().getName(), getNetwork(), getParameters().getDataCenterId(), getParameters().isPublicUse(), getParameters().isAttachToAllClusters());
    ActionReturnValue returnValue = runInternalAction(ActionType.InternalImportExternalNetwork, parameters, getContext().clone().withoutLock());
    if (!returnValue.getSucceeded()) {
        propagateFailure(runInternalAction(ActionType.InternalImportExternalNetwork, parameters));
        return;
    }
    getReturnValue().setActionReturnValue(returnValue.getActionReturnValue());
    setSucceeded(true);
}
#end_block

#method_before
@BeforeEach
public void setUp() {
    provider.setType(ProviderType.EXTERNAL_NETWORK);
    when(providerDao.get(PROVIDER_ID)).thenReturn(provider);
    when(providerProxyFactory.create(provider)).thenReturn(providerProxy);
    when(providerProxy.get(EXTERNAL_ID)).thenReturn(getProviderNetwork());
    doNothing().when(networkHelper).mapPhysicalNetworkIdIfExists(any(), eq(DATACENTER_ID));
    ActionReturnValue returnValue = new ActionReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setActionReturnValue(NETWORK_ID);
    when(backend.runInternalAction(eq(ActionType.InternalImportExternalNetwork), any(), any())).thenReturn(returnValue);
}
#method_after
@BeforeEach
public void setUp() {
    provider.setType(ProviderType.EXTERNAL_NETWORK);
    when(providerDao.get(PROVIDER_ID)).thenReturn(provider);
    when(providerProxyFactory.create(provider)).thenReturn(providerProxy);
    when(providerProxy.get(EXTERNAL_ID)).thenReturn(getProviderNetwork());
    doNothing().when(networkHelper).mapPhysicalNetworkIdIfApplicable(any(), eq(DATACENTER_ID));
    ActionReturnValue returnValue = new ActionReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setActionReturnValue(NETWORK_ID);
    when(backend.runInternalAction(eq(ActionType.InternalImportExternalNetwork), any(), any())).thenReturn(returnValue);
}
#end_block

#method_before
public ValidationResult externalNetworkVlanValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_WITH_VLAN_MUST_BE_LABELED).when(network.getProvidedBy().hasExternalVlanId() && !network.getProvidedBy().hasCustomPhysicalNetworkName());
}
#method_after
public ValidationResult externalNetworkVlanValid() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_WITH_VLAN_MUST_BE_CUSTOM).when(network.getProvidedBy().hasExternalVlanId() && !network.getProvidedBy().hasCustomPhysicalNetworkName());
}
#end_block

#method_before
@Override
public void executeSave() {
    Frontend.getInstance().runAction(ActionType.UpdateNetwork, new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork()), result -> {
        ActionReturnValue retVal = result.getReturnValue();
        postSaveAction(null, retVal != null && retVal.getSucceeded());
    }, null);
}
#method_after
@Override
public void executeSave() {
    if (getExternal().getEntity() && getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromCustom().getEntity()) {
        getNetwork().getProvidedBy().setCustomPhysicalNetworkName(null);
        getNetwork().getProvidedBy().setExternalVlanId(null);
    }
    Frontend.getInstance().runAction(ActionType.UpdateNetwork, new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork()), result -> {
        ActionReturnValue retVal = result.getReturnValue();
        postSaveAction(null, retVal != null && retVal.getSucceeded());
    }, null);
}
#end_block

#method_before
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getProvidedBy().hasCustomPhysicalNetworkName()) {
        networkForCreate.setProviderPhysicalNetwork(network.getProvidedBy().getCustomPhysicalNetworkName());
        if (network.getProvidedBy().hasExternalVlanId()) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getProvidedBy().getExternalVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!getProvider().isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#method_after
protected com.woorea.openstack.quantum.model.Network createNewNetworkEntity(Network network) {
    com.woorea.openstack.quantum.model.Network networkForCreate = new com.woorea.openstack.quantum.model.Network();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (!network.isDefaultMtu()) {
        networkForCreate.setMtu(network.getMtu());
    }
    if (network.getProvidedBy().hasCustomPhysicalNetworkName()) {
        networkForCreate.setProviderPhysicalNetwork(network.getProvidedBy().getCustomPhysicalNetworkName());
        if (network.getProvidedBy().hasExternalVlanId()) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getProvidedBy().getExternalVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!getProvider().isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    return networkForCreate;
}
#end_block

#method_before
private Network map(com.woorea.openstack.quantum.model.Network externalNetwork) {
    Network network = new Network();
    network.setVmNetwork(true);
    network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
    network.setName(externalNetwork.getName());
    mapPhysicalNetworkParameters(externalNetwork, network);
    return network;
}
#method_after
private Network map(com.woorea.openstack.quantum.model.Network externalNetwork) {
    Network network = new Network();
    network.setVmNetwork(true);
    network.setProvidedBy(new ProviderNetwork(getProvider().getId(), externalNetwork.getId()));
    network.setName(externalNetwork.getName());
    if (externalNetwork.getMtu() != null) {
        network.setMtu(externalNetwork.getMtu());
    }
    mapPhysicalNetworkParameters(externalNetwork, network);
    return network;
}
#end_block

#method_before
private void mapPhysicalNetworkParameters(com.woorea.openstack.quantum.model.Network externalNetwork, Network network) {
    String providerNetworkType = externalNetwork.getProviderNetworkType();
    network.getProvidedBy().setExternalVlanId(providerNetworkType != null && providerNetworkType.equals(VLAN_NETWORK) ? externalNetwork.getProviderSegmentationId() : null);
    network.getProvidedBy().setCustomPhysicalNetworkName(externalNetwork.getProviderPhysicalNetwork());
}
#method_after
private void mapPhysicalNetworkParameters(com.woorea.openstack.quantum.model.Network externalNetwork, Network network) {
    String providerNetworkType = externalNetwork.getProviderNetworkType();
    network.getProvidedBy().setExternalVlanId(VLAN_NETWORK.equals(providerNetworkType) ? externalNetwork.getProviderSegmentationId() : null);
    network.getProvidedBy().setCustomPhysicalNetworkName(externalNetwork.getProviderPhysicalNetwork());
    network.getProvidedBy().setProviderNetworkType(providerNetworkType);
}
#end_block

#method_before
@Override
protected void executeSave() {
    final AddNetworkWithSubnetParameters parameters = new AddNetworkWithSubnetParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    parameters.setNetworkClusterList(createNetworkAttachments());
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (hasDefinedSubnet()) {
            getSubnetModel().flush();
            parameters.setExternalSubnet(getSubnetModel().getSubnet());
        }
        if (getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromDatacenter().getEntity()) {
            Network network = getDatacenterPhysicalNetwork().getSelectedItem();
            providerNetwork.setPhysicalNetworkId(network.getId());
        } else {
            providerNetwork.setCustomPhysicalNetworkName(getCustomPhysicalNetwork().getEntity());
            providerNetwork.setExternalVlanId(getVLanTag().getEntity());
        }
        Frontend.getInstance().runAction(hasDefinedSubnet() ? ActionType.AddNetworkWithSubnetOnProvider : ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#method_after
@Override
protected void executeSave() {
    final AddNetworkWithSubnetParameters parameters = new AddNetworkWithSubnetParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    parameters.setNetworkClusterList(createNetworkAttachments());
    // New network
    if (getExternal().getEntity()) {
        Provider<?> externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        if (hasDefinedSubnet()) {
            getSubnetModel().flush();
            parameters.setExternalSubnet(getSubnetModel().getSubnet());
        }
        if (getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromDatacenter().getEntity()) {
            Network network = getDatacenterPhysicalNetwork().getSelectedItem();
            providerNetwork.setPhysicalNetworkId(network.getId());
        } else if (getConnectedToPhysicalNetwork().getEntity() && getUsePhysicalNetworkFromCustom().getEntity()) {
            providerNetwork.setCustomPhysicalNetworkName(getCustomPhysicalNetwork().getEntity());
            providerNetwork.setExternalVlanId(getVLanTag().getEntity());
        }
        Frontend.getInstance().runAction(hasDefinedSubnet() ? ActionType.AddNetworkWithSubnetOnProvider : ActionType.AddNetworkOnProvider, parameters, addNetworkCallback(), null);
    } else {
        Frontend.getInstance().runAction(ActionType.AddNetwork, parameters, addNetworkCallback(), null);
    }
}
#end_block

#method_before
@Test
public void externalNetworkVlanInvalid() {
    when(providerNetwork.hasExternalVlanId()).thenReturn(true);
    assertThat(validator.externalNetworkVlanValid(), failsWith(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_WITH_VLAN_MUST_BE_LABELED));
}
#method_after
@Test
public void externalNetworkVlanInvalid() {
    when(providerNetwork.hasExternalVlanId()).thenReturn(true);
    assertThat(validator.externalNetworkVlanValid(), failsWith(EngineMessage.ACTION_TYPE_FAILED_EXTERNAL_NETWORK_WITH_VLAN_MUST_BE_CUSTOM));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    StoragePoolValidator spValidator = new StoragePoolValidator(getStoragePool());
    if (!validate(spValidator.exists())) {
        return false;
    }
    if (!isExternalVM() && !validate(spValidator.isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    StoragePoolValidator spValidator = new StoragePoolValidator(getStoragePool());
    if (!validate(spValidator.exists())) {
        return false;
    }
    if (!isExternalVM() && !validate(spValidator.isInStatus(StoragePoolStatus.Up))) {
        return false;
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (getParameters().getVmStaticData().getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData()) && !canAddLease()) {
        return false;
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return diskInfoDestinationMap.values().stream().map(disk -> new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes())).collect(Collectors.toList());
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return diskInfoDestinationMap.values().stream().map(disk -> new QuotaStorageConsumptionParameter(disk.getQuotaId(), QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes())).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaSanityParameter(getQuotaId(), null));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaSanityParameter(getQuotaId()));
    return list;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_HOSTCPU_CANNOT_BE_AUTO_MIGRATABLE);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    if (FeatureSupported.isBiosTypeSupported(getCluster().getCompatibilityVersion()) && vmFromParams.getBiosType() != BiosType.I440FX_SEA_BIOS && getCluster().getArchitecture() != ArchitectureType.undefined && getCluster().getArchitecture().getFamily() != ArchitectureType.x86) {
        return failValidation(EngineMessage.NON_DEFAULT_BIOS_TYPE_FOR_X86_ONLY);
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (!getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getClusterId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaClusterConsumptionParameter(getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getClusterId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getQuotaId()));
        quotaSanityOnly = true;
    } else {
        if (!getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), QuotaConsumptionParameter.QuotaAction.RELEASE, getClusterId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaClusterConsumptionParameter(getQuotaId(), QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getClusterId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    // in vm_static table.
    if (getVm().isHostedEngine()) {
        getVmDeviceUtils().updateConsoleDevice(newVmStatic.getId(), Boolean.TRUE);
    }
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        logNameChange();
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    // for next run to be stored in vm_static table.
    if (getVm().isNotRunning() || getVm().isHostedEngine()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (!getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getClusterId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaClusterConsumptionParameter(getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getClusterId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getQuotaId()));
        quotaSanityOnly = true;
    } else {
        if (!getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), QuotaConsumptionParameter.QuotaAction.RELEASE, getClusterId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaClusterConsumptionParameter(getQuotaId(), QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getClusterId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#end_block

#method_before
public void clearSanStorageModel() {
    if (getStorageDomain() == null) {
        this.setItems(null);
    }
}
#method_after
public void clearSanStorageModel() {
    if (getStorageDomain() == null) {
        setItems(null);
    }
}
#end_block

#method_before
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery<>(hosts -> {
        ArrayList<VDS> filteredHosts = new ArrayList<>();
        for (VDS host : hosts) {
            if (isHostAvailable(host)) {
                filteredHosts.add(host);
            }
        }
        Collections.sort(filteredHosts, new NameableComparator());
        getHost().setItems(filteredHosts);
        getSanStorageModelBase().clearSanStorageModel();
    }), datacenter.getId());
}
#method_after
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery<>(hosts -> {
        ArrayList<VDS> filteredHosts = new ArrayList<>();
        for (VDS host : hosts) {
            if (isHostAvailable(host)) {
                filteredHosts.add(host);
            }
        }
        Collections.sort(filteredHosts, new NameableComparator());
        getHost().setItems(filteredHosts);
        if (getSanStorageModelBase() != null) {
            getSanStorageModelBase().clearSanStorageModel();
        }
    }), datacenter.getId());
}
#end_block

#method_before
@Override
public Response resetAllOptions(Action action) {
    return resetOption(action, "", null, action.isSetForce() ? action.isForce() : false);
}
#method_after
@Override
public Response resetAllOptions(Action action) {
    return resetOption(action, null, null, action.isSetForce() ? action.isForce() : false);
}
#end_block

#method_before
private Response resetOption(Action action, String optionName, String optionValue, boolean force) {
    return doAction(ActionType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsParameters(guid, new GlusterVolumeOptionEntity(guid, optionName, optionValue), force), action);
}
#method_after
private Response resetOption(Action action, String optionName, String optionValue, boolean force) {
    return doAction(ActionType.ResetGlusterVolumeOptions, new ResetGlusterVolumeOptionsParameters(guid, optionName == null ? null : new GlusterVolumeOptionEntity(guid, optionName, optionValue), force), action);
}
#end_block

#method_before
private void writeOs() {
    writer.writeStartElement("os");
    writer.writeStartElement("type");
    writer.writeAttributeString("arch", vm.getClusterArch().toString());
    writer.writeAttributeString("machine", emulatedMachine);
    writer.writeRaw("hvm");
    writer.writeEndElement();
    if (!StringUtils.isEmpty(vm.getInitrdUrl())) {
        writer.writeElement("initrd", vm.getInitrdUrl());
    }
    if (!StringUtils.isEmpty(vm.getKernelUrl())) {
        writer.writeElement("kernel", vm.getKernelUrl());
        if (!StringUtils.isEmpty(vm.getKernelParams())) {
            writer.writeElement("cmdline", vm.getKernelParams());
        }
    }
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("smbios");
        writer.writeAttributeString("mode", "sysinfo");
        writer.writeEndElement();
    }
    if (vm.isBootMenuEnabled()) {
        writer.writeStartElement("bootmenu");
        writer.writeAttributeString("enable", "yes");
        writer.writeAttributeString("timeout", String.valueOf(BOOT_MENU_TIMEOUT));
        writer.writeEndElement();
    }
    if (serialConsolePath != null && vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("bios");
        writer.writeAttributeString("useserial", "yes");
        writer.writeEndElement();
    }
    if (vm.getBiosType().isOvmf()) {
        writer.writeStartElement("loader");
        writer.writeAttributeString("readonly", "yes");
        writer.writeAttributeString("secure", vm.getBiosType() == BiosType.Q35_SECURE_BOOT ? "yes" : "no");
        writer.writeAttributeString("type", "pflash");
        writer.writeRaw("/usr/share/OVMF/OVMF_CODE.secboot.fd");
        writer.writeEndElement();
        writer.writeStartElement("nvram");
        writer.writeAttributeString("template", "/usr/share/OVMF/OVMF_VARS.fd");
        writer.writeRaw(String.format("/var/lib/libvirt/qemu/nvram/%s.fd", vm.getId()));
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeOs() {
    writer.writeStartElement("os");
    writer.writeStartElement("type");
    writer.writeAttributeString("arch", vm.getClusterArch().toString());
    writer.writeAttributeString("machine", emulatedMachine);
    writer.writeRaw("hvm");
    writer.writeEndElement();
    if (!StringUtils.isEmpty(vm.getInitrdUrl())) {
        writer.writeElement("initrd", vm.getInitrdUrl());
    }
    if (!StringUtils.isEmpty(vm.getKernelUrl())) {
        writer.writeElement("kernel", vm.getKernelUrl());
        if (!StringUtils.isEmpty(vm.getKernelParams())) {
            writer.writeElement("cmdline", vm.getKernelParams());
        }
    }
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("smbios");
        writer.writeAttributeString("mode", "sysinfo");
        writer.writeEndElement();
    }
    if (vm.isBootMenuEnabled()) {
        writer.writeStartElement("bootmenu");
        writer.writeAttributeString("enable", "yes");
        writer.writeAttributeString("timeout", String.valueOf(BOOT_MENU_TIMEOUT));
        writer.writeEndElement();
    }
    if (serialConsolePath != null && vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("bios");
        writer.writeAttributeString("useserial", "yes");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeClock() {
    // <clock offset="variable" adjustment="-3600">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    // for hyperv:
    // <clock offset="variable" adjustment="-3600">
    // <timer name="hypervclock" present="yes">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    writer.writeStartElement("clock");
    writer.writeAttributeString("offset", "variable");
    writer.writeAttributeString("adjustment", String.valueOf(vmInfoBuildUtils.getVmTimeZone(vm)));
    if (hypervEnabled) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hypervclock");
        writer.writeAttributeString("present", "yes");
        writer.writeEndElement();
    }
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "rtc");
    writer.writeAttributeString("tickpolicy", "catchup");
    writer.writeEndElement();
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "pit");
    writer.writeAttributeString("tickpolicy", "delay");
    writer.writeEndElement();
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hpet");
        writer.writeAttributeString("present", "no");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeClock() {
    // <clock offset="variable" adjustment="-3600">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    // for hyperv:
    // <clock offset="variable" adjustment="-3600">
    // <timer name="hypervclock" present="yes">
    // <timer name="rtc" tickpolicy="catchup">
    // </clock>
    writer.writeStartElement("clock");
    writer.writeAttributeString("offset", "variable");
    writer.writeAttributeString("adjustment", String.valueOf(vmInfoBuildUtils.getVmTimeZone(vm)));
    if (hypervEnabled) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hypervclock");
        writer.writeAttributeString("present", "yes");
        writer.writeEndElement();
    }
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "rtc");
    writer.writeAttributeString("tickpolicy", "catchup");
    writer.writeEndElement();
    writer.writeStartElement("timer");
    writer.writeAttributeString("name", "pit");
    writer.writeAttributeString("tickpolicy", "delay");
    writer.writeEndElement();
    if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeStartElement("timer");
        writer.writeAttributeString("name", "hpet");
        writer.writeAttributeString("present", "no");
        writer.writeEndElement();
    }
    if (vm.getBiosType().isOvmf()) {
        writer.writeStartElement("loader");
        writer.writeAttributeString("readonly", "yes");
        writer.writeAttributeString("secure", vm.getBiosType() == BiosType.Q35_SECURE_BOOT ? "yes" : "no");
        writer.writeAttributeString("type", "pflash");
        writer.writeRaw("/usr/share/OVMF/OVMF_CODE.secboot.fd");
        writer.writeEndElement();
        writer.writeStartElement("nvram");
        writer.writeAttributeString("template", "/usr/share/OVMF/OVMF_VARS.fd");
        writer.writeRaw(String.format("/var/lib/libvirt/qemu/nvram/%s.fd", vm.getId()));
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslr = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean ovmfEnabled = vm.getBiosType().isOvmf();
    if (!acpiEnabled && !hypervEnabled && !kaslr && !ovmfEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslr) {
        writer.writeElement("vmcoreinfo");
    }
    if (ovmfEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeFeatures() {
    if (vm.getClusterArch().getFamily() != ArchitectureType.x86) {
        return;
    }
    boolean acpiEnabled = vm.getAcpiEnable();
    boolean kaslrEnabled = vmInfoBuildUtils.isKASLRDumpEnabled(vm.getVmOsId());
    boolean ovmfEnabled = vm.getBiosType().isOvmf();
    if (!acpiEnabled && !hypervEnabled && !kaslrEnabled && !ovmfEnabled) {
        return;
    }
    writer.writeStartElement("features");
    if (acpiEnabled) {
        writer.writeElement("acpi");
    }
    if (hypervEnabled) {
        writer.writeStartElement("hyperv");
        writer.writeStartElement("relaxed");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("vapic");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
        writer.writeStartElement("spinlocks");
        writer.writeAttributeString("state", "on");
        writer.writeAttributeString("retries", "8191");
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (kaslrEnabled) {
        writer.writeElement("vmcoreinfo");
    }
    if (ovmfEnabled) {
        writer.writeStartElement("smm");
        writer.writeAttributeString("state", "on");
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = vnicProfile != null ? vnicProfile.getCustomProperties().remove("queues") : null;
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            if (queues != null || driverName != null) {
                writer.writeStartElement("driver");
                if (queues != null) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNic nic) {
    // <interface type="bridge">
    // <mac address="aa:bb:dd:dd:aa:bb"/>
    // <model type="virtio"/>
    // <source bridge="engine"/>
    // [<driver name="vhost/qemu" queues="int"/>]
    // [<filterref filter='filter name'>
    // [<parameter name='parameter name' value='parameter value'>]
    // </filterref>]
    // [<tune><sndbuf>0</sndbuf></tune>]
    // [<link state='up|down'/>]
    // [<bandwidth>
    // [<inbound average="int" [burst="int"]  [peak="int"]/>]
    // [<outbound average="int" [burst="int"]  [peak="int"]/>]
    // </bandwidth>]
    // </interface>
    // 
    // -- or -- a slightly different SR-IOV network interface
    // <interface type='hostdev' managed='no'>
    // <driver name='vfio'/>
    // <source>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // </source>
    // <mac address='52:54:00:6d:90:02'/>
    // <vlan>
    // <tag id=100/>
    // </vlan>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
    // function='0x0'/>
    // <boot order='1'/>
    // </interface>
    writer.writeStartElement("interface");
    VnicProfile vnicProfile = vmInfoBuildUtils.getVnicProfile(nic.getVnicProfileId());
    Network network = vnicProfile != null ? vmInfoBuildUtils.getNetwork(vnicProfile.getNetworkId()) : null;
    boolean networkless = network == null;
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            String evaluatedIfaceType = vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent());
            if ("pv".equals(evaluatedIfaceType)) {
                evaluatedIfaceType = "virtio";
            }
            writer.writeAttributeString("type", evaluatedIfaceType);
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", !networkless && nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // The source element is different when using legacy or OVS bridge. We
            // expect VDSM to replace the source element if it is a non legacy bridge
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", !networkless ? network.getVdsmName() : ";vdsmdummy;");
            writer.writeEndElement();
            String queues = null;
            if (vnicProfile != null) {
                queues = vnicProfile.getCustomProperties().remove("queues");
            }
            if (queues == null && vm.isMultiQueuesEnabled() && vmInfoBuildUtils.isInterfaceQueuable(device, nic)) {
                queues = String.valueOf(vmInfoBuildUtils.getOptimalNumOfQueuesPerVnic(vm.getNumOfCpus()));
            }
            String driverName = getDriverNameForNetwork(!networkless ? network.getName() : "");
            boolean nonDefaultQueues = queues != null && Integer.parseInt(queues) != 1;
            if (nonDefaultQueues || driverName != null) {
                writer.writeStartElement("driver");
                if (nonDefaultQueues) {
                    writer.writeAttributeString("queues", queues);
                    if (driverName == null) {
                        driverName = "vhost";
                    }
                }
                writer.writeAttributeString("name", driverName);
                writer.writeEndElement();
            }
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            if (!networkless && NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            writer.writeStartElement("source");
            writer.writeStartElement("address");
            String vfDeviceName = passthroughVnicToVfMap.get(nic.getId());
            Map<String, String> sourceAddress = hostDevicesSupplier.get().get(vfDeviceName).getAddress();
            sourceAddress.put("type", "pci");
            sourceAddress.forEach(writer::writeAttributeString);
            writer.writeEndElement();
            writer.writeEndElement();
            break;
    }
    writeAlias(device);
    writeAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    if (!networkless && !vnicProfile.isPassthrough()) {
        writer.writeStartElement("mtu");
        writer.writeAttributeString("size", String.valueOf(NetworkUtils.getVmMtuActualValue(network)));
        writer.writeEndElement();
    }
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        vmInfoBuildUtils.getAllNetworkFiltersForVmNic(nic.getId()).forEach(parameter -> {
            writer.writeStartElement("parameter");
            writer.writeAttributeString("name", parameter.getName());
            writer.writeAttributeString("value", parameter.getValue());
            writer.writeEndElement();
        });
        writer.writeEndElement();
    }
    String sndbuf = vmCustomProperties.get("sndbuf");
    if (sndbuf != null) {
        writer.writeStartElement("tune");
        writer.writeElement("sndbuf", sndbuf);
        writer.writeEndElement();
    }
    Map<String, Object> profileData = new HashMap<>();
    vmInfoBuildUtils.addProfileDataToNic(profileData, vm, device, nic, vnicProfile);
    List<String> portMirroring = (List<String>) profileData.get(VdsProperties.PORT_MIRRORING);
    if (portMirroring != null && !portMirroring.isEmpty()) {
        // store port mirroring in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("portMirroring", portMirroring);
    }
    Map<String, String> runtimeCustomProperties = vm.getRuntimeDeviceCustomProperties().get(device.getId());
    if (runtimeCustomProperties != null && !runtimeCustomProperties.isEmpty()) {
        // store runtime custom properties in the metadata
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).put("runtimeCustomProperties", runtimeCustomProperties);
    }
    if (vnicProfile != null && vnicProfile.getCustomProperties() != null) {
        vnicMetadata.computeIfAbsent(nic.getMacAddress(), mac -> new HashMap<>());
        vnicMetadata.get(nic.getMacAddress()).putAll(vnicProfile.getCustomProperties());
    }
    writer.writeStartElement("bandwidth");
    @SuppressWarnings("unchecked")
    Map<String, Object> specParams = (Map<String, Object>) profileData.get("specParams");
    if (specParams != null && (specParams.containsKey("inbound") || specParams.containsKey("outbound"))) {
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) specParams.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", String.valueOf(inboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(inboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(inboundMap.get("peak")));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) specParams.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", String.valueOf(outboundMap.get("average")));
            writer.writeAttributeString("burst", String.valueOf(outboundMap.get("burst")));
            writer.writeAttributeString("peak", String.valueOf(outboundMap.get("peak")));
            writer.writeEndElement();
        }
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInput() {
    writer.writeStartElement("input");
    boolean tabletEnable = // avoid adding Tablet device for HP VMs since no USB devices are set
    vm.getVmType() != VmType.HighPerformance && vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#method_after
private void writeInput() {
    writer.writeStartElement("input");
    if (vmInfoBuildUtils.isTabletEnabled(vm)) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", vm.getClusterArch().getFamily() == ArchitectureType.x86 ? "ps2" : "usb");
    }
    writer.writeEndElement();
}
#end_block

#method_before
private boolean consumeQuotaParameters(List<QuotaConsumptionParameter> parameters, CommandBase<?> command, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == command.getStoragePool().getQuotaEnforcementType();
    // Process the quota consumption parameters to a list of Requests
    // Each Request instance aggregates the requested consumption of a single QuotaStorage or QuotaCluster
    Optional<List<Request>> requests = createRequests(parameters, command, hardEnforcement, auditLogPair);
    if (!requests.isPresent()) {
        return false;
    }
    // Validate that all requests satisfy the quota limits
    for (Request request : requests.get()) {
        ValidationResult validation = request.validate(hardEnforcement, auditLogPair);
        if (!validation.isValid()) {
            command.getReturnValue().getValidationMessages().addAll(validation.getMessagesAsStrings());
            return false;
        }
    }
    // After successful validation, the requests are applied.
    // This changes only the cached quota objects in the QuotaManager, nothing is written to the DB.
    requests.get().forEach(Request::apply);
    return true;
}
#method_after
private boolean consumeQuotaParameters(List<QuotaConsumptionParameter> parameters, CommandBase<?> command, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == command.getStoragePool().getQuotaEnforcementType();
    // Process the quota consumption parameters to a list of Requests
    // Each Request instance aggregates all requested consumptions against a single quota limit
    Optional<List<Request>> requests = createRequests(parameters, command, hardEnforcement, auditLogPair);
    if (!requests.isPresent()) {
        return false;
    }
    // Validate that all requests satisfy the quota limits
    for (Request request : requests.get()) {
        ValidationResult validation = request.validate(hardEnforcement, auditLogPair);
        if (!validation.isValid()) {
            command.getReturnValue().getValidationMessages().addAll(validation.getMessagesAsStrings());
            return false;
        }
    }
    // After successful validation, the requests are applied.
    // This changes only the cached quota objects in the QuotaManager, nothing is written to the DB.
    requests.get().forEach(Request::apply);
    return true;
}
#end_block

#method_before
private Optional<List<Request>> createRequests(List<QuotaConsumptionParameter> parameters, CommandBase<?> command, boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    // The key is: Pair <Quota id, Cluster id>
    Map<Pair<Guid, Guid>, ClusterRequest> clusterRequests = new HashMap<>();
    // The key is: Pair <Quota id, Storage domain id>
    Map<Pair<Guid, Guid>, StorageRequest> storageRequests = new HashMap<>();
    for (QuotaConsumptionParameter param : parameters) {
        // Use default quota if the id is empty
        if (Guid.isNullOrEmpty(param.getQuotaGuid())) {
            param.setQuotaGuid(storagePoolDefaultQuotaIdMap.get(command.getStoragePoolId()));
        }
        Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), command.getStoragePoolId());
        if (quota == null) {
            log.error("The quota id '{}' is not found in backend and DB.", param.getQuotaGuid());
            if (hardEnforcement) {
                command.getReturnValue().getValidationMessages().add(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                command.getReturnValue().getValidationMessages().add(String.format("$VmName %1$s", command.getVmName()));
                return Optional.empty();
            }
            auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
            continue;
        }
        ValidationResult validation = ValidationResult.VALID;
        if (param instanceof QuotaClusterConsumptionParameter) {
            validation = validateAndAddToClusterRequests((QuotaClusterConsumptionParameter) param, quota, command.getClass().getName(), clusterRequests);
        }
        if (param instanceof QuotaStorageConsumptionParameter) {
            validation = validateAndAddToStorageRequests((QuotaStorageConsumptionParameter) param, quota, command.getClass().getName(), storageRequests);
        }
        if (!validation.isValid() && hardEnforcement) {
            command.getReturnValue().getValidationMessages().addAll(validation.getMessagesAsStrings());
            return Optional.empty();
        }
    }
    List<Request> result = new ArrayList<>(clusterRequests.values());
    result.addAll(storageRequests.values());
    return Optional.of(result);
}
#method_after
private Optional<List<Request>> createRequests(List<QuotaConsumptionParameter> parameters, CommandBase<?> command, boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    // The key is: Pair <Quota id, Cluster id>
    Map<Pair<Guid, Guid>, ClusterRequest> clusterRequests = new HashMap<>();
    // The key is: Pair <Quota id, Storage domain id>
    Map<Pair<Guid, Guid>, StorageRequest> storageRequests = new HashMap<>();
    for (QuotaConsumptionParameter param : parameters) {
        // Use default quota if the id is empty
        if (Guid.isNullOrEmpty(param.getQuotaGuid())) {
            param.setQuotaGuid(storagePoolDefaultQuotaIdMap.get(command.getStoragePoolId()));
        }
        Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), command.getStoragePoolId());
        if (quota == null) {
            log.error("The quota id '{}' is not found in backend and DB.", param.getQuotaGuid());
            if (hardEnforcement) {
                command.getReturnValue().getValidationMessages().add(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                command.getReturnValue().getValidationMessages().add(String.format("$VmName %1$s", command.getVmName()));
                return Optional.empty();
            }
            auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
            continue;
        }
        ValidationResult validation = ValidationResult.VALID;
        if (param instanceof QuotaClusterConsumptionParameter) {
            validation = validateAndAddToClusterRequests((QuotaClusterConsumptionParameter) param, quota, command.getClass().getName(), clusterRequests);
        } else if (param instanceof QuotaStorageConsumptionParameter) {
            validation = validateAndAddToStorageRequests((QuotaStorageConsumptionParameter) param, quota, command.getClass().getName(), storageRequests);
        }
        if (!validation.isValid() && hardEnforcement) {
            command.getReturnValue().getValidationMessages().addAll(validation.getMessagesAsStrings());
            return Optional.empty();
        }
    }
    List<Request> result = new ArrayList<>(clusterRequests.values());
    result.addAll(storageRequests.values());
    return Optional.of(result);
}
#end_block

#method_before
private ValidationResult validateAndAddToClusterRequests(QuotaClusterConsumptionParameter param, Quota quota, String commandClassName, Map<Pair<Guid, Guid>, ClusterRequest> requestMap) {
    if (param.getClusterId() == null) {
        log.error("Quota Vds parameters from command '{}' are missing vds group id", commandClassName);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    Pair<Guid, Guid> key = quota.isGlobalClusterQuota() ? new Pair<>(quota.getId(), null) : new Pair<>(quota.getId(), param.getClusterId());
    if (!requestMap.containsKey(key)) {
        // Quota must be a global cluster quota or be defined for the same cluster as is the consumption parameter.
        QuotaCluster quotaCluster = quota.isGlobalClusterQuota() ? quota.getGlobalQuotaCluster() : quota.getQuotaClusters().stream().filter(c -> c.getClusterId().equals(param.getClusterId())).findAny().orElse(null);
        if (quotaCluster == null) {
            log.error("Quota Vds parameters from command '{}'. Vds group does not match quota", commandClassName);
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        }
        requestMap.put(key, new ClusterRequest(quota, quotaCluster));
    }
    long requestedMemory = param.getQuotaAction() == QuotaConsumptionParameter.QuotaAction.CONSUME ? param.getRequestedMemory() : -param.getRequestedMemory();
    int requestedCpu = param.getQuotaAction() == QuotaConsumptionParameter.QuotaAction.CONSUME ? param.getRequestedCpu() : -param.getRequestedCpu();
    // Get the ClusterRequest corresponding to the quota and cluster,
    // and add the new requested memory and cpu.
    ClusterRequest request = requestMap.get(key);
    request.addVcpu(requestedCpu);
    request.addMemory(requestedMemory);
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateAndAddToClusterRequests(QuotaClusterConsumptionParameter param, Quota quota, String commandClassName, Map<Pair<Guid, Guid>, ClusterRequest> requestMap) {
    if (param.getClusterId() == null) {
        log.error("Quota Vds parameters from command '{}' are missing vds group id", commandClassName);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    Pair<Guid, Guid> key = quota.isGlobalClusterQuota() ? new Pair<>(quota.getId(), null) : new Pair<>(quota.getId(), param.getClusterId());
    if (!requestMap.containsKey(key)) {
        // Quota must be a global cluster quota or be defined for the same cluster as is the consumption parameter.
        QuotaCluster quotaCluster = quota.isGlobalClusterQuota() ? quota.getGlobalQuotaCluster() : quota.getQuotaClusters().stream().filter(c -> c.getClusterId().equals(param.getClusterId())).findAny().orElse(null);
        if (quotaCluster == null) {
            log.error("Quota Vds parameters from command '{}'. Vds group does not match quota", commandClassName);
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
        }
        requestMap.put(key, new ClusterRequest(quota, quotaCluster));
    }
    // If the quota is released, the values in the request will be negative
    int quotaActionCoef = 1;
    if (param.getQuotaAction() == QuotaConsumptionParameter.QuotaAction.RELEASE) {
        quotaActionCoef = -1;
    }
    // Get the ClusterRequest corresponding to the quota and cluster,
    // and add the new requested memory and cpu.
    ClusterRequest request = requestMap.get(key);
    request.addCpu(quotaActionCoef * param.getRequestedCpu());
    request.addMemory(quotaActionCoef * param.getRequestedMemory());
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateAndAddToStorageRequests(QuotaStorageConsumptionParameter param, Quota quota, String commandClassName, Map<Pair<Guid, Guid>, StorageRequest> requestMap) {
    if (param.getStorageDomainId() == null) {
        log.error("Quota storage parameters from command '{}' are missing storage domain id", commandClassName);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    Pair<Guid, Guid> key = quota.isGlobalStorageQuota() ? new Pair<>(quota.getId(), null) : new Pair<>(quota.getId(), param.getStorageDomainId());
    if (!requestMap.containsKey(key)) {
        // Quota must be a global storage quota or be defined for
        // the same storage domain as is the consumption parameter.
        QuotaStorage quotaStorage = quota.isGlobalStorageQuota() ? quota.getGlobalQuotaStorage() : quota.getQuotaStorages().stream().filter(s -> s.getStorageId().equals(param.getStorageDomainId())).findAny().orElse(null);
        if (quotaStorage == null) {
            log.error("Quota storage parameters from command '{}'. Storage domain does not match quota", commandClassName);
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN);
        }
        requestMap.put(key, new StorageRequest(quota, quotaStorage));
    }
    double requestedStorage = param.getQuotaAction() == QuotaConsumptionParameter.QuotaAction.CONSUME ? param.getRequestedStorageGB() : -param.getRequestedStorageGB();
    // Get the StorageRequest corresponding to the quota and storage domain,
    // and add the new requested storage.
    StorageRequest request = requestMap.get(key);
    request.addStorage(requestedStorage);
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateAndAddToStorageRequests(QuotaStorageConsumptionParameter param, Quota quota, String commandClassName, Map<Pair<Guid, Guid>, StorageRequest> requestMap) {
    if (param.getStorageDomainId() == null) {
        log.error("Quota storage parameters from command '{}' are missing storage domain id", commandClassName);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    Pair<Guid, Guid> key = quota.isGlobalStorageQuota() ? new Pair<>(quota.getId(), null) : new Pair<>(quota.getId(), param.getStorageDomainId());
    if (!requestMap.containsKey(key)) {
        // Quota must be a global storage quota or be defined for
        // the same storage domain as is the consumption parameter.
        QuotaStorage quotaStorage = quota.isGlobalStorageQuota() ? quota.getGlobalQuotaStorage() : quota.getQuotaStorages().stream().filter(s -> s.getStorageId().equals(param.getStorageDomainId())).findAny().orElse(null);
        if (quotaStorage == null) {
            log.error("Quota storage parameters from command '{}'. Storage domain does not match quota", commandClassName);
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN);
        }
        requestMap.put(key, new StorageRequest(quota, quotaStorage));
    }
    // If the quota is released, the values in the request will be negative
    int quotaActionCoef = 1;
    if (param.getQuotaAction() == QuotaConsumptionParameter.QuotaAction.RELEASE) {
        quotaActionCoef = -1;
    }
    // Get the StorageRequest corresponding to the quota and storage domain,
    // and add the new requested storage.
    StorageRequest request = requestMap.get(key);
    request.addStorage(quotaActionCoef * param.getRequestedStorageGB());
    return ValidationResult.VALID;
}
#end_block

#method_before
public void addMemory(long memMB) {
    memUsageMB += memMB;
}
#method_after
public void addMemory(long memMB) {
    memoryRequestMB += memMB;
}
#end_block

#method_before
@Override
public ValidationResult validate(boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    // The ClusterQuota must allow cpu and memory
    if (quotaCluster.getVirtualCpu() == 0 || quotaCluster.getMemSizeMB() == 0) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    int cpuLimit = quotaCluster.getVirtualCpu();
    long memLimit = quotaCluster.getMemSizeMB();
    // Valid if both, CPU and memory, are unlimited
    if (memLimit == QuotaCluster.UNLIMITED_MEM && cpuLimit == QuotaCluster.UNLIMITED_VCPU) {
        return ValidationResult.VALID;
    }
    // Valid if the request releases quota, not consumes it.
    if (vcpuUsage <= 0 && memUsageMB <= 0) {
        return ValidationResult.VALID;
    }
    double vcpuToAddPercentage = (double) vcpuUsage / (double) cpuLimit * 100;
    double vcpuCurrentPercentage = (double) quotaCluster.getVirtualCpuUsage() / (double) cpuLimit * 100;
    double newVcpuPercent = vcpuToAddPercentage + vcpuCurrentPercentage;
    double memToAddPercentage = (double) memUsageMB / (double) memLimit * 100;
    double memCurrentPercentage = (double) quotaCluster.getMemSizeMBUsage() / (double) memLimit * 100;
    double newMemoryPercent = memToAddPercentage + memCurrentPercentage;
    int threshold = getQuota().getThresholdClusterPercentage();
    int grace = getQuota().getGraceClusterPercentage() + 100;
    // Valid if CPU and memory usages are below grace
    if (newVcpuPercent <= grace && newMemoryPercent <= grace) {
        // Warn if the cluster limit or threshold is exceeded
        if (newVcpuPercent > 100 || newMemoryPercent > 100) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_LIMIT);
            quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > 100, newMemoryPercent > 100);
        } else if (newVcpuPercent > threshold || newMemoryPercent > threshold) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_THRESHOLD);
            quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), vcpuCurrentPercentage + vcpuToAddPercentage, vcpuToAddPercentage, memCurrentPercentage + memToAddPercentage, memToAddPercentage, newVcpuPercent > threshold, newMemoryPercent > threshold);
        }
        return ValidationResult.VALID;
    }
    // CPU or memory is above the grace - fail if enforcement is hard
    auditLogPair.setFirst(hardEnforcement ? AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_GRACE_LIMIT : AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_GRACE_LIMIT_PERMISSIVE_MODE);
    quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), vcpuCurrentPercentage, vcpuToAddPercentage, memCurrentPercentage, memToAddPercentage, newVcpuPercent > grace, newMemoryPercent > grace);
    if (!hardEnforcement) {
        return ValidationResult.VALID;
    }
    auditLogPair.getSecond().setQuotaIdForLog(getQuota().getId());
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_CLUSTER_LIMIT_EXCEEDED);
}
#method_after
@Override
public ValidationResult validate(boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    // The ClusterQuota must allow cpu and memory
    if (quotaCluster.getVirtualCpu() == 0 || quotaCluster.getMemSizeMB() == 0) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID);
    }
    int cpuLimit = quotaCluster.getVirtualCpu();
    long memLimit = quotaCluster.getMemSizeMB();
    // Valid if both, CPU and memory, are unlimited
    if (memLimit == QuotaCluster.UNLIMITED_MEM && cpuLimit == QuotaCluster.UNLIMITED_VCPU) {
        return ValidationResult.VALID;
    }
    // Valid if the request releases quota, not consumes it.
    if (coresRequest <= 0 && memoryRequestMB <= 0) {
        return ValidationResult.VALID;
    }
    double requestedCoresPercent = 100 * ((double) coresRequest / (double) cpuLimit);
    double currentCoresPercent = 100 * ((double) quotaCluster.getVirtualCpuUsage() / (double) cpuLimit);
    double newCoresPercent = requestedCoresPercent + currentCoresPercent;
    double requestedMemoryPercent = 100 * ((double) memoryRequestMB / (double) memLimit);
    double currentMemoryPercent = 100 * ((double) quotaCluster.getMemSizeMBUsage() / (double) memLimit);
    double newMemoryPercent = requestedMemoryPercent + currentMemoryPercent;
    int threshold = getQuota().getThresholdClusterPercentage();
    int grace = getQuota().getGraceClusterPercentage() + 100;
    // Valid if CPU and memory usages are below grace
    if (newCoresPercent <= grace && newMemoryPercent <= grace) {
        // Warn if the cluster limit or threshold is exceeded
        if (newCoresPercent > 100 || newMemoryPercent > 100) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_LIMIT);
            quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentCoresPercent + requestedCoresPercent, requestedCoresPercent, currentMemoryPercent + requestedMemoryPercent, requestedMemoryPercent, newCoresPercent > 100, newMemoryPercent > 100);
        } else if (newCoresPercent > threshold || newMemoryPercent > threshold) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_THRESHOLD);
            quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentCoresPercent + requestedCoresPercent, requestedCoresPercent, currentMemoryPercent + requestedMemoryPercent, requestedMemoryPercent, newCoresPercent > threshold, newMemoryPercent > threshold);
        }
        return ValidationResult.VALID;
    }
    // CPU or memory is above the grace - fail if enforcement is hard
    auditLogPair.setFirst(hardEnforcement ? AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_GRACE_LIMIT : AuditLogType.USER_EXCEEDED_QUOTA_CLUSTER_GRACE_LIMIT_PERMISSIVE_MODE);
    quotaManagerAuditLogger.addCustomValuesCluster(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentCoresPercent, requestedCoresPercent, currentMemoryPercent, requestedMemoryPercent, newCoresPercent > grace, newMemoryPercent > grace);
    if (!hardEnforcement) {
        return ValidationResult.VALID;
    }
    auditLogPair.getSecond().setQuotaIdForLog(getQuota().getId());
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_CLUSTER_LIMIT_EXCEEDED);
}
#end_block

#method_before
@Override
public void apply() {
    quotaCluster.setVirtualCpuUsage(vcpuUsage);
    quotaCluster.setMemSizeMBUsage(memUsageMB);
}
#method_after
@Override
public void apply() {
    quotaCluster.setVirtualCpuUsage(coresRequest);
    quotaCluster.setMemSizeMBUsage(memoryRequestMB);
}
#end_block

#method_before
public void addStorage(double storageGB) {
    storageUsageGB += storageGB;
}
#method_after
public void addStorage(double storageGB) {
    storageRequestGB += storageGB;
}
#end_block

#method_before
@Override
public ValidationResult validate(boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    long storageLimit = quotaStorage.getStorageSizeGB();
    // Valid if quota is unlimited
    if (storageLimit == QuotaStorage.UNLIMITED) {
        return ValidationResult.VALID;
    }
    // Valid if the request releases quota, not consumes it.
    if (storageUsageGB <= 0) {
        return ValidationResult.VALID;
    }
    double storageUsagePercentage = quotaStorage.getStorageSizeGBUsage() / storageLimit * 100;
    double storageRequestPercentage = storageUsageGB / storageLimit * 100;
    double storageTotalPercentage = storageUsagePercentage + storageRequestPercentage;
    int threshold = getQuota().getThresholdStoragePercentage();
    int grace = getQuota().getGraceStoragePercentage() + 100;
    // Valid if below grace
    if (storageTotalPercentage <= grace) {
        // Warn if storage limit or threshold is exceeded
        if (storageTotalPercentage > 100) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
            quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        } else if (storageTotalPercentage > threshold) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
            quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), storageUsagePercentage + storageRequestPercentage, storageRequestPercentage);
        }
        return ValidationResult.VALID;
    }
    // Storage is above the grace - fail if hard enforcement
    auditLogPair.setFirst(hardEnforcement ? AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT : AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT_PERMISSIVE_MODE);
    quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), storageUsagePercentage, storageRequestPercentage);
    if (!hardEnforcement) {
        return ValidationResult.VALID;
    }
    auditLogPair.getSecond().setQuotaIdForLog(getQuota().getId());
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED);
}
#method_after
@Override
public ValidationResult validate(boolean hardEnforcement, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    long storageLimit = quotaStorage.getStorageSizeGB();
    // Valid if quota is unlimited
    if (storageLimit == QuotaStorage.UNLIMITED) {
        return ValidationResult.VALID;
    }
    // Valid if the request releases quota, not consumes it.
    if (storageRequestGB <= 0) {
        return ValidationResult.VALID;
    }
    double requestStoragePercent = 100 * (storageRequestGB / (double) storageLimit);
    double currentStoragePercent = 100 * (quotaStorage.getStorageSizeGBUsage() / (double) storageLimit);
    double newStoragePercent = currentStoragePercent + requestStoragePercent;
    int threshold = getQuota().getThresholdStoragePercentage();
    int grace = getQuota().getGraceStoragePercentage() + 100;
    // Valid if below grace
    if (newStoragePercent <= grace) {
        // Warn if storage limit or threshold is exceeded
        if (newStoragePercent > 100) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT);
            quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentStoragePercent + requestStoragePercent, requestStoragePercent);
        } else if (newStoragePercent > threshold) {
            auditLogPair.setFirst(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD);
            quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentStoragePercent + requestStoragePercent, requestStoragePercent);
        }
        return ValidationResult.VALID;
    }
    // Storage is above the grace - fail if hard enforcement
    auditLogPair.setFirst(hardEnforcement ? AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT : AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT_PERMISSIVE_MODE);
    quotaManagerAuditLogger.addCustomValuesStorage(auditLogPair.getSecond(), getQuota().getQuotaName(), getQuota().getId(), currentStoragePercent, requestStoragePercent);
    if (!hardEnforcement) {
        return ValidationResult.VALID;
    }
    auditLogPair.getSecond().setQuotaIdForLog(getQuota().getId());
    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_QUOTA_STORAGE_LIMIT_EXCEEDED);
}
#end_block

#method_before
@Override
public void apply() {
    quotaStorage.setStorageSizeGBUsage(storageUsageGB);
}
#method_after
@Override
public void apply() {
    quotaStorage.setStorageSizeGBUsage(storageRequestGB);
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = NetworkUtils.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        reportedConfigurationsFiller.fillReportedConfiguration(existingNetworkAttachment, getVdsId());
        if (networkIsNotInSync) {
            List<String> errors = new ArrayList<>();
            List<ReportedConfiguration> reportedConfigurations = existingNetworkAttachment.getReportedConfigurations().getReportedConfigurationList();
            List<ReportedConfiguration> outOfSyncReportedConfigurations = reportedConfigurations.stream().filter(config -> !config.isInSync()).collect(Collectors.toList());
            Collections.sort(outOfSyncReportedConfigurations, Comparator.comparing(r -> r.getType().getName()));
            outOfSyncReportedConfigurations.stream().forEach(reportedConfiguration -> {
                // The format of the message is for example - "${MTU} ${HOST_OT_OF_SYNC} - 5, ${DC_OUT_OF_SYNC} - 4"
                errors.add(String.format("${%s} ${HOST_OUT_OF_SYNC} - %s, ${DC_OUT_OF_SYNC} - %s", reportedConfiguration.getType().getName().toUpperCase(), reportedConfiguration.getActualValue(), reportedConfiguration.getExpectedValue()));
                addValidationMessage(reportedConfiguration.getType().getName().toUpperCase());
            });
            addValidationMessage(EngineMessage.HOST_OUT_OF_SYNC);
            addValidationMessage(EngineMessage.DC_OUT_OF_SYNC);
            addValidationMessageVariable("OUT_OF_SYNC_VALUES", StringUtils.join(errors, ", "));
            return new ValidationResult(EngineMessage.NETWORK_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = NetworkUtils.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        reportedConfigurationsFiller.fillReportedConfiguration(existingNetworkAttachment, getVdsId());
        if (networkIsNotInSync) {
            List<String> errors = new ArrayList<>();
            List<ReportedConfiguration> reportedConfigurations = existingNetworkAttachment.getReportedConfigurations().getReportedConfigurationList();
            List<ReportedConfiguration> outOfSyncReportedConfigurations = reportedConfigurations.stream().filter(config -> !config.isInSync()).collect(Collectors.toList());
            Collections.sort(outOfSyncReportedConfigurations, Comparator.comparing(r -> r.getType().getName()));
            outOfSyncReportedConfigurations.stream().forEach(reportedConfiguration -> {
                // The format of the message is for example - "${MTU} ${HOST_OT_OF_SYNC} - 5, ${DC_OUT_OF_SYNC} - 4"
                errors.add(String.format("${%s} ${HOST_OUT_OF_SYNC} - %s, ${DC_OUT_OF_SYNC} - %s", reportedConfiguration.getType().getName().toUpperCase(), reportedConfiguration.getActualValue(), reportedConfiguration.getExpectedValue()));
                addValidationMessage(reportedConfiguration.getType().getName().toUpperCase());
            });
            addValidationMessage(EngineMessage.HOST_OUT_OF_SYNC);
            addValidationMessage(EngineMessage.DC_OUT_OF_SYNC);
            addValidationMessageVariable("OUT_OF_SYNC_VALUES", StringUtils.join(errors, "; "));
            return new ValidationResult(EngineMessage.NETWORK_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    Set<Guid> specifiedDiskIds = getParameters().getDiskIds();
    if (specifiedDiskIds != null && !specifiedDiskIds.isEmpty()) {
        if (!isSpecifiedDisksExist(specifiedDiskIds)) {
            return false;
        }
        List<Disk> allDisksForVm = diskDao.getAllForVm(getVm().getId());
        String notAllowSnapshot = allDisksForVm.stream().filter(disk -> specifiedDiskIds.contains(disk.getId())).filter(disk -> !disk.isAllowSnapshot()).map(BaseDisk::getDiskAlias).collect(Collectors.joining(", "));
        if (!notAllowSnapshot.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_SNAPSHOT_NOT_SUPPORTED, String.format("$diskAliases %s", notAllowSnapshot));
        }
        Set<Guid> guidsOfVmDisks = allDisksForVm.stream().map(BaseDisk::getId).collect(Collectors.toSet());
        String notAttachedToVm = specifiedDiskIds.stream().filter(guid -> !guidsOfVmDisks.contains(guid)).map(guid -> diskDao.get(guid)).map(BaseDisk::getDiskAlias).collect(Collectors.joining(", "));
        if (!notAttachedToVm.isEmpty()) {
            String[] replacements = { ReplacementUtils.createSetVariableString("VmName", getVm().getName()), ReplacementUtils.createSetVariableString("diskAliases", notAttachedToVm) };
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_ATTACHED_TO_VM, replacements);
        }
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.existsAndUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())) && validate(vmValidator.vmNotUsingMdevTypeHook()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(vmValidator.vmWithoutLocalDiskUserProperty()) && validate(diskImagesValidator.imageAlreadyExists(getParameters().getDiskToImageIds())))) {
            return false;
        }
    }
    return validateStorage();
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    Set<Guid> specifiedDiskIds = getParameters().getDiskIds();
    if (specifiedDiskIds != null && !specifiedDiskIds.isEmpty()) {
        if (!isSpecifiedDisksExist(specifiedDiskIds)) {
            return false;
        }
        List<Disk> allDisksForVm = diskDao.getAllForVm(getVm().getId());
        String notAllowSnapshot = allDisksForVm.stream().filter(disk -> specifiedDiskIds.contains(disk.getId())).filter(disk -> !disk.isAllowSnapshot()).map(BaseDisk::getDiskAlias).collect(Collectors.joining(", "));
        if (!notAllowSnapshot.isEmpty()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_SNAPSHOT_NOT_SUPPORTED, String.format("$diskAliases %s", notAllowSnapshot));
        }
        Set<Guid> guidsOfVmDisks = allDisksForVm.stream().map(BaseDisk::getId).collect(Collectors.toSet());
        String notAttachedToVm = specifiedDiskIds.stream().filter(guid -> !guidsOfVmDisks.contains(guid)).map(guid -> diskDao.get(guid)).map(BaseDisk::getDiskAlias).collect(Collectors.joining(", "));
        if (!notAttachedToVm.isEmpty()) {
            String[] replacements = { ReplacementUtils.createSetVariableString("VmName", getVm().getName()), ReplacementUtils.createSetVariableString("diskAliases", notAttachedToVm) };
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISKS_NOT_ATTACHED_TO_VM, replacements);
        }
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.existsAndUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && (!getParameters().isSaveMemory() || validate(vmValidator.vmNotHavingPciPassthroughDevices())) && validate(vmValidator.vmNotUsingMdevTypeHook()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(vmValidator.vmWithoutLocalDiskUserProperty()) && validate(diskImagesValidator.snapshotAlreadyExists(getParameters().getDiskToImageIds())))) {
            return false;
        }
    }
    return validateStorage();
}
#end_block

#method_before
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<List<Stream<T>>, R> reduce) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    List<Stream<T>> replicaSets = new ArrayList<>();
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            int replicaSize = bricks.size() / volume.getReplicaCount();
            while (!bricks.isEmpty()) {
                int replicaCounter = 0;
                List<BrickProperties> set = new ArrayList<>();
                while (replicaCounter < replicaSize) {
                    set.add(bricks.get(0));
                    replicaCounter++;
                }
                replicaSets.add(set.stream().map(field));
            }
            break;
        default:
            replicaSets = Collections.singletonList(bricks.stream().map(field));
            break;
    }
    return reduce.apply(replicaSets);
}
#method_after
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<List<Stream<T>>, R> reduce) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    List<Stream<T>> replicaSets = new ArrayList<>();
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            while (!bricks.isEmpty()) {
                int replicaCounter = 0;
                List<BrickProperties> set = new ArrayList<>();
                while (replicaCounter < volume.getReplicaCount() && !bricks.isEmpty()) {
                    set.add(bricks.get(0));
                    bricks.remove(0);
                    replicaCounter++;
                }
                replicaSets.add(set.stream().map(field));
            }
            break;
        default:
            replicaSets = Collections.singletonList(bricks.stream().map(field));
            break;
    }
    return reduce.apply(replicaSets);
}
#end_block

#method_before
private Function<List<Stream<Double>>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (List<Stream<Double>> data) -> {
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTED_REPLICATE:
                return data.stream().map(b -> b.map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null)).filter(Objects::nonNull).min(Long::compare).orElse(null);
            case DISTRIBUTE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).mapToLong(Double::longValue).sum();
        }
    };
}
#method_after
private Function<List<Stream<Double>>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (List<Stream<Double>> data) -> {
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTED_REPLICATE:
                return data.stream().map(b -> b.map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null)).filter(Objects::nonNull).mapToLong(s -> s).sum();
            case DISTRIBUTE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).mapToLong(Double::longValue).sum();
        }
    };
}
#end_block

#method_before
public BrickProperties setConfirmedSize(Map<Guid, GlusterLocalVolumeInfo> volumeInfo, GlusterBrickEntity brick, BrickProperties brickProperties) {
    if (brickProperties.getDevice() != null && volumeInfo.get(brick.getServerId()) != null) {
        GlusterLocalVolumeInfo localVolumeInfo = volumeInfo.get(brick.getServerId());
        brickProperties.setConfirmedFreeSize(localVolumeInfo.getAvailableThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setConfirmedTotalSize(localVolumeInfo.getTotalThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setVdoSavings(localVolumeInfo.getSavingsForDevice(brickProperties.getDevice()).orElse(null));
    }
    return brickProperties;
}
#method_after
public BrickProperties setConfirmedSize(Map<Guid, GlusterLocalVolumeInfo> volumeInfo, GlusterBrickEntity brick, BrickProperties brickProperties) {
    if (brickProperties.getDevice() != null && volumeInfo.get(brick.getServerId()) != null) {
        GlusterLocalVolumeInfo localVolumeInfo = volumeInfo.get(brick.getServerId());
        brickProperties.setConfirmedFreeSize(localVolumeInfo.getAvailableThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
        brickProperties.setConfirmedTotalSize(localVolumeInfo.getTotalThinSizeForDevice(brickProperties.getDevice()).map(this::toMB).orElse(null));
    }
    return brickProperties;
}
#end_block

#method_before
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<Stream<T>, R> reduce) {
    List<BrickProperties> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).filter(// Arbiter bricks are useless for a size calculation
    b -> !b.getIsArbiter()).map(GlusterBrickEntity::getBrickProperties).collect(Collectors.toList());
    if (bricks.stream().map(field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    Stream<T> data = bricks.stream().map(field);
    return reduce.apply(data);
}
#method_after
private <T, R> R calculateConfirmedVolume(GlusterVolumeEntity volume, Function<BrickProperties, T> field, Function<List<Stream<T>>, R> reduce) {
    List<GlusterBrickEntity> bricks = volume.getBricks().stream().map(GlusterBrickEntity::getId).map(b -> brickDao.getById(b)).filter(Objects::nonNull).collect(Collectors.toList());
    if (extractBrickData(bricks, field).anyMatch(Objects::isNull)) {
        // If we have bricks missing confirmed size, we can't calculate it for the volume.
        log.info("Volume {} have non-thin bricks, skipping confirmed free size calculation", volume.getName());
        return null;
    }
    List<Stream<T>> replicaSets = new ArrayList<>();
    switch(volume.getVolumeType()) {
        case REPLICATE:
        case DISTRIBUTED_REPLICATE:
            while (!bricks.isEmpty()) {
                int replicaCounter = 0;
                List<GlusterBrickEntity> set = new ArrayList<>();
                while (replicaCounter < volume.getReplicaCount() && !bricks.isEmpty()) {
                    set.add(bricks.get(0));
                    bricks.remove(0);
                    replicaCounter++;
                }
                replicaSets.add(extractBrickData(set, field));
            }
            break;
        default:
            replicaSets = Collections.singletonList(extractBrickData(bricks, field));
            break;
    }
    return reduce.apply(replicaSets);
}
#end_block

#method_before
private Function<Stream<Double>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (Stream<Double> data) -> {
        Stream<Double> brickSizes = data.map(v -> v * SizeConverter.BYTES_IN_MB);
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return brickSizes.map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTE:
            case DISTRIBUTED_REPLICATE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return brickSizes.mapToLong(Double::longValue).sum();
        }
    };
}
#method_after
private Function<List<Stream<Double>>, Long> reduceBricksToSize(GlusterVolumeEntity volume) {
    return (List<Stream<Double>> data) -> {
        switch(volume.getVolumeType()) {
            case REPLICATE:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null);
            case DISTRIBUTED_REPLICATE:
                return data.stream().map(b -> b.map(v -> v * SizeConverter.BYTES_IN_MB).map(Double::longValue).min(Long::compare).orElse(null)).filter(Objects::nonNull).mapToLong(s -> s).sum();
            case DISTRIBUTE:
            case STRIPE:
            case DISTRIBUTED_STRIPE:
            case STRIPED_REPLICATE:
            case DISTRIBUTED_STRIPED_REPLICATE:
            case DISPERSE:
            default:
                return data.stream().flatMap(Function.identity()).map(v -> v * SizeConverter.BYTES_IN_MB).mapToLong(Double::longValue).sum();
        }
    };
}
#end_block

#method_before
@Override
public void save(Network entity) {
    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();
    if (dnsResolverConfiguration != null) {
        dnsResolverConfigurationDao.save(dnsResolverConfiguration);
    }
    super.save(entity);
}
#method_after
@Override
public void save(Network entity) {
    DnsResolverConfiguration dnsResolverConfiguration = entity.getDnsResolverConfiguration();
    if (dnsResolverConfiguration != null) {
        Validate.isTrue(dnsResolverConfiguration.getId() == null);
        dnsResolverConfigurationDao.save(dnsResolverConfiguration);
    }
    super.save(entity);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("vdsm_name", network.getVdsmName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("provider_physical_network_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getPhysicalNetworkId()).addValue("provider_custom_physical_network", network.getProvidedBy() == null ? null : network.getProvidedBy().getCustomPhysicalNetwork()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(network));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("vdsm_name", network.getVdsmName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("provider_physical_network_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getPhysicalNetworkId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel()).addValue("dns_resolver_configuration_id", getDnsResolverConfigurationId(network));
}
#end_block

#method_before
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setVdsmName(rs.getString("vdsm_name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id"), getGuid(rs, "provider_physical_network_id"), rs.getString("provider_custom_physical_network")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    Guid dnsResolverConfigurationId = getGuid(rs, "dns_resolver_configuration_id");
    entity.setDnsResolverConfiguration(dnsResolverConfigurationDao.get(dnsResolverConfigurationId));
    return entity;
}
#method_after
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setVdsmName(rs.getString("vdsm_name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id"), getGuid(rs, "provider_physical_network_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    Guid dnsResolverConfigurationId = getGuid(rs, "dns_resolver_configuration_id");
    entity.setDnsResolverConfiguration(dnsResolverConfigurationDao.get(dnsResolverConfigurationId));
    return entity;
}
#end_block

